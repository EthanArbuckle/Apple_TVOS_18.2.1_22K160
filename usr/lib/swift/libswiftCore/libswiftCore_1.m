LABEL_38:
    v119 = v227;
    ((void (*)(void))v103)();
    v120 = v50(v8, a5);
    v121 = v226;
    v241 = (void (*)(char *, char *, uint64_t))v103;
    v103(v226, v119, v8);
    if ((v120 & 1) != 0)
    {
      v122 = v236(v8, a5);
      v123 = v217;
      v217(v121, v8);
      if (v122 < 65) {
        goto LABEL_46;
      }
      v124 = v218;
      v125 = v241;
      v241(v218, v227, (uint64_t)v8);
      v245[0] = 0x8000000000000000LL;
      v126 = v50(v8, a5);
      v215 = v50;
      if ((v126 & 1) != 0)
      {
        v127 = v236(v8, a5);
        if (v127 < 64)
        {
          v130 = v220;
          v125(v220, v124, (uint64_t)v8);
          v131 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
          v123 = v217;
          v217(v130, v8);
          v132 = v131 < v245[0];
          v133 = v124;
          goto LABEL_81;
        }

        v190 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
        v191 = lazy protocol witness table accessor for type Int and conformance Int(v127, v128, v129);
        v192 = v220;
        v190(v245, &type metadata for Int, v191, v8, a5);
        v93 = v237;
        v188 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                               + 16LL))( v124,  v192,  v8);
        v123 = v217;
        v217(v192, v8);
        v133 = v124;
        goto LABEL_74;
      }

      v180 = v50(v8, a5);
      v181 = v236(v8, a5);
      if ((v180 & 1) != 0)
      {
        if (v181 <= 64)
        {
          v196 = v223;
          v197 = AssociatedTypeWitness;
          v198 = swift_getAssociatedConformanceWitness( (uint64_t)v223,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v199 = v221;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v198 + 8))( &unk_18180BE68,  256LL,  v197,  v198);
          v200 = v220;
          (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v196 + 3))( v199,  v8,  v196);
          v201 = v218;
          LOBYTE(v197) = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v218,  v200,  v8);
          v202 = v200;
          v123 = v217;
          v217(v202, v8);
          v203 = v216;
          v241(v216, v201, (uint64_t)v8);
          if ((v197 & 1) != 0)
          {
            v123(v203, v8);
            goto LABEL_94;
          }

          v204 = v245[0];
          v205 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
          v123(v203, v8);
          v132 = v205 < v204;
          v93 = v237;
          v133 = v218;
          goto LABEL_81;
        }

        v184 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
        v185 = lazy protocol witness table accessor for type Int and conformance Int(v181, v182, v183);
        v186 = v220;
        v184(v245, &type metadata for Int, v185, v8, a5);
        v187 = v218;
        v188 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                               + 16LL))( v218,  v186,  v8);
        v189 = v186;
        v123 = v217;
        v217(v189, v8);
        v133 = v187;
        v93 = v237;
LABEL_74:
        v50 = v215;
        if ((v188 & 1) != 0) {
          goto LABEL_94;
        }
LABEL_45:
        v123(v133, v8);
LABEL_46:
        v134 = v123;
        v135 = v227;
        v136 = v236;
        v137 = v236(v8, a5);
        v138 = v225;
        v241(v225, v135, (uint64_t)v8);
        if (v137 < 65)
        {
          v140 = v136(v8, a5);
          v139 = v134;
          v134(v138, v8);
          if (v140 != 64 || (v50(v8, a5) & 1) != 0) {
            goto LABEL_60;
          }
        }

        else
        {
          v139 = v134;
          v134(v138, v8);
        }

        v141 = v224;
        v142 = v241;
        v241(v224, v227, (uint64_t)v8);
        v245[0] = 0x7FFFFFFFFFFFFFFFLL;
        v143 = v50(v8, a5);
        v144 = v236(v8, a5);
        if ((v143 & 1) != 0)
        {
          v147 = v220;
          if (v144 > 64)
          {
            v148 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
            v149 = lazy protocol witness table accessor for type Int and conformance Int(v144, v145, v146);
            v150 = v245;
            goto LABEL_58;
          }
        }

        else
        {
          v147 = v220;
          if (v144 > 63)
          {
            v244 = 0x7FFFFFFFFFFFFFFFLL;
            v148 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
            v149 = lazy protocol witness table accessor for type Int and conformance Int(v144, v145, v146);
            v150 = &v244;
LABEL_58:
            v148(v150, &type metadata for Int, v149, v8, a5);
            v151 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v147,  v141,  v8);
            v139(v147, v8);
            v93 = v237;
            if ((v151 & 1) != 0) {
              goto LABEL_92;
            }
            goto LABEL_59;
          }
        }

        v142(v147, v141, (uint64_t)v8);
        (*(void (**)(void *, uint64_t))(a5 + 120))(v8, a5);
        v139(v147, v8);
        v93 = v237;
LABEL_59:
        v139(v141, v8);
LABEL_60:
        v152 = v227;
        v153 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
        v154 = v139;
        v49 = v153;
        v154(v152, v8);
        goto LABEL_61;
      }

      v93 = v237;
      if (v181 < 64)
      {
        v193 = v220;
        v194 = v218;
        v125(v220, v218, (uint64_t)v8);
        v195 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
        v123 = v217;
        v217(v193, v8);
        v133 = v194;
        v132 = v195 < v245[0];
LABEL_81:
        v50 = v215;
        if (!v132) {
          goto LABEL_45;
        }
LABEL_94:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      }

      v133 = v218;
      v50 = v215;
    }

    else
    {
      v133 = v121;
    }

    v123 = v217;
    goto LABEL_45;
  }

  v52 = v241;
  v236 = *(uint64_t (**)(void *, uint64_t))(a5 + 128);
  v53 = v236(v8, a5);
  if (v53 >= 64)
  {
    v245[0] = v49;
    v69 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
    v70 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    v57 = v36;
    v69(v245, &type metadata for Int, v70, v8, a5);
    v71 = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                          + 16LL))( v52,  v36,  v8);
    v60 = *(void (**)(char *, void *))(v238 + 8);
    v60(v36, v8);
    v61 = v52;
    if ((v71 & 1) != 0) {
      goto LABEL_23;
    }
    goto LABEL_26;
  }

  v56 = v238;
  v57 = v36;
  (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v238 + 16))(v36, v52, v8);
  v58 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
  v59 = *(void (**)(char *, void *))(v56 + 8);
  v59(v36, v8);
  v132 = v58 < v49;
  v60 = v59;
  v61 = v52;
  if (!v132) {
    goto LABEL_26;
  }
LABEL_23:
  v92 = v242(a2, v243);
  v49 = -v92;
  if (__OFSUB__(0LL, v92))
  {
    __break(1u);
LABEL_91:
    __break(1u);
LABEL_92:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

  v93 = v237;
LABEL_61:
  v155 = *(void (**)(char *, char *, uint64_t))(v93 + 32);
  v156 = v240;
  v155(v240, v231, a2);
  v16 = v234;
  v157 = (*((uint64_t (**)(uint64_t, char *))v234 + 8))(a2, v234);
  v158 = v232;
  v19 = v233;
  v241 = v155;
  if ((v157 & 1) != 0)
  {
    v159 = v243;
    v160 = v242(a2, v243);
    if (!__OFSUB__(v160, 1LL))
    {
      v245[0] = v160 - 1;
      v163 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v16 + 12);
      v164 = lazy protocol witness table accessor for type Int and conformance Int(v160, v161, v162);
      v163(v245, &type metadata for Int, v164, a2, v16);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v159 + 200))(v156, v19, a2, v159);
      (*(void (**)(char *, uint64_t))(v93 + 8))(v19, a2);
      v165 = v230;
      v166 = swift_getAssociatedConformanceWitness( (uint64_t)v158,  a2,  v230,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v167 = v93;
      v168 = v229;
      goto LABEL_65;
    }

    goto LABEL_91;
  }

  v169 = v230;
  v166 = swift_getAssociatedConformanceWitness( (uint64_t)v232,  a2,  v230,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v167 = v93;
  v168 = v229;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v166 + 8))( &unk_18180BE68,  256LL,  v169,  v166);
  (*((void (**)(char *, uint64_t, const char *))v158 + 3))(v168, a2, v158);
  v165 = v169;
LABEL_65:
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v166 + 8))( &unk_18180BE68,  256LL,  v165,  v166);
  v170 = v235;
  (*((void (**)(char *, uint64_t, const char *))v158 + 3))(v168, a2, v158);
  v8 = *(void (**)(char *, uint64_t))(v167 + 8);
  if (v49 < 0)
  {
LABEL_85:
    v8(v239, a2);
    v206 = v243;
    v207 = v242(a2, v243);
    v173 = v240;
    if (__OFSUB__(0LL, v207))
    {
      __break(1u);
    }

    else if (-v207 < v49)
    {
      v208 = ((uint64_t (*)(char *, uint64_t))v8)(v235, a2);
      v245[0] = -v49;
      v209 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v16 + 12);
      v212 = lazy protocol witness table accessor for type Int and conformance Int(v208, v210, v211);
      v209(v245, &type metadata for Int, v212, a2, v16);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v206 + 216))(v173, v19, a2, v206);
      goto LABEL_68;
    }

    v8(v173, a2);
    v213 = v228;
    v214 = v235;
    return ((uint64_t (*)(uint64_t, char *, uint64_t))v241)(v213, v214, a2);
  }

  v8(v170, a2);
  v171 = v243;
  v172 = v242(a2, v243);
  v173 = v240;
  if (v49 >= v172)
  {
    v8(v240, a2);
    v213 = v228;
    v214 = v239;
    return ((uint64_t (*)(uint64_t, char *, uint64_t))v241)(v213, v214, a2);
  }

  v174 = ((uint64_t (*)(char *, uint64_t))v8)(v239, a2);
  v245[0] = v49;
  v175 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v16 + 12);
  v178 = lazy protocol witness table accessor for type Int and conformance Int(v174, v176, v177);
  v175(v245, &type metadata for Int, v178, a2, v16);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v171 + 200))(v173, v19, a2, v171);
LABEL_68:
  v8(v19, a2);
  return ((uint64_t (*)(char *, uint64_t))v8)(v173, a2);
}

      swift_bridgeObjectRelease(a1);
      return;
    }

    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v10))
    {
      v28 = (int64_t)&v10[2]->isa + 1;
      goto LABEL_47;
    }

    goto LABEL_39;
  }

  if ((v5 & 1) == 0)
  {
    v16 = 0LL;
    v5 = 1;
    if (!v6) {
      goto LABEL_71;
    }
    goto LABEL_62;
  }

  swift_bridgeObjectRelease((uint64_t)a4);
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  swift_bridgeObjectRelease((uint64_t)v62);
  v53 = (unint64_t)v4[3];
  if (v53 >= 2)
  {
    v54 = v53 >> 1;
    v51 = __OFSUB__(v54, v6);
    v55 = (__objc2_class *)(v54 - v6);
    if (v51) {
      goto LABEL_99;
    }
    v4[2] = v55;
  }

    if (!specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, v14, a1, a2, v12)) {
      return v15;
    }
    v36 = __OFSUB__(0LL, v15);
    v15 = -(uint64_t)v15;
    if (!v36) {
      return v15;
    }
    goto LABEL_43;
  }

  if ((a6 & 1) == 0)
  {
    if ((a3 & 1) == 0)
    {
      if (!a4)
      {
        v40 = a7;
        a8(&v41, &v40);
        return specialized RandomAccessCollection<>.distance(from:to:)(a2, a5, v41);
      }

          v121(v131, v8);
LABEL_39:
          v132 = v221;
          v133 = v119(v8, v6);
          v88(v122, v132, v8);
          if (v133 < 65)
          {
            v134 = v119(v8, v6);
            v121(v122, v8);
            if (v134 != 64 || (v219(v8, v6) & 1) != 0) {
              goto LABEL_59;
            }
          }

          else
          {
            v121(v122, v8);
          }

          v88(v218, v221, v8);
          v239[0] = 0x7FFFFFFFFFFFFFFFLL;
          v135 = v219(v8, v6);
          v136 = v119(v8, v6);
          if ((v135 & 1) != 0)
          {
            if (v136 > 64)
            {
              v139 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
              v140 = lazy protocol witness table accessor for type Int and conformance Int(v136, v137, v138);
              v141 = v239;
              goto LABEL_57;
            }
          }

          else if (v136 > 63)
          {
            v238 = 0x7FFFFFFFFFFFFFFFLL;
            v139 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
            v140 = lazy protocol witness table accessor for type Int and conformance Int(v136, v137, v138);
            v141 = &v238;
LABEL_57:
            v146 = v232;
            v139(v141, &type metadata for Int, v140, v8, v6);
            v143 = v218;
            v147 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v146,  v218,  v8);
            v121(v146, v8);
            if ((v147 & 1) != 0) {
              goto LABEL_92;
            }
            goto LABEL_58;
          }

          v142 = v232;
          v143 = v218;
          v88(v232, v218, v8);
          (*(void (**)(void *, uint64_t))(v6 + 120))(v8, v6);
          v121(v142, v8);
LABEL_58:
          v121(v143, v8);
LABEL_59:
          v148 = v221;
          v27 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
          v121(v148, v8);
          goto LABEL_60;
        }

        v88 = *(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(v228 + 16);
      }

      v105 = v232;
      v86 = v233;
      v88(v232, (char *)v233, v8);
      v106 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
      v216(v105, v8);
      if (v76 < v106) {
        goto LABEL_55;
      }
      goto LABEL_31;
    }

    goto LABEL_50;
  }

  v59(v30, v8);
  v30 = v231;
  v96 = ((uint64_t (*)(uint64_t, uint64_t))v231)(a3, v237);
LABEL_51:
  v27 = -v96;
  v35 = v230;
  if (__OFSUB__(0LL, v96))
  {
    __break(1u);
LABEL_91:
    __break(1u);
LABEL_92:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

  v145 = v235;
LABEL_61:
  v149 = v226;
  v233 = *(void (**)(void, void, void))(v226 + 32);
  v233(v145, v236, a3);
  v6 = v227;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v227 + 64))(a3, v227) & 1) != 0)
  {
    v150 = v237;
    v151 = ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v237);
    if (!__OFSUB__(v151, 1LL))
    {
      v239[0] = v151 - 1;
      v154 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
      v155 = lazy protocol witness table accessor for type Int and conformance Int(v151, v152, v153);
      v156 = v229;
      v154(v239, &type metadata for Int, v155, a3, v6);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v150 + 200))(v145, v156, a3, v150);
      v35 = v230;
      (*(void (**)(char *, uint64_t))(v149 + 8))(v156, a3);
      v157 = (uint64_t)v222;
      v158 = v225;
      v159 = swift_getAssociatedConformanceWitness( (uint64_t)v222,  a3,  v225,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v160 = v224;
      goto LABEL_65;
    }

    goto LABEL_91;
  }

  v157 = (uint64_t)v222;
  v161 = v225;
  v159 = swift_getAssociatedConformanceWitness( (uint64_t)v222,  a3,  v225,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v160 = v224;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v159 + 8))( &unk_18180BE68,  256LL,  v161,  v159);
  (*(void (**)(char *, uint64_t, uint64_t))(v157 + 24))(v160, a3, v157);
  v158 = v161;
  v30 = v231;
LABEL_65:
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v159 + 8))( &unk_18180BE68,  256LL,  v158,  v159);
  (*(void (**)(char *, uint64_t, uint64_t))(v157 + 24))(v160, a3, v157);
  v8 = *(void (**)(char *, uint64_t))(v149 + 8);
  if (v27 < 0)
  {
LABEL_85:
    v8(v234, a3);
    v201 = ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v237);
    if (__OFSUB__(0LL, v201))
    {
      __break(1u);
    }

    else if (-v201 < v27)
    {
      v202 = ((uint64_t (*)(char *, uint64_t))v8)(v35, a3);
      v239[0] = -v27;
      v203 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
      v206 = lazy protocol witness table accessor for type Int and conformance Int(v202, v204, v205);
      v168 = v229;
      v203(v239, &type metadata for Int, v206, a3, v6);
      v169 = v223;
      v170 = v235;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v237 + 216))(v235, v168, a3, v237);
      goto LABEL_68;
    }

    v8(v235, a3);
    v169 = v223;
    v207 = v223;
    v208 = v35;
LABEL_89:
    v171 = (uint64_t (*)(uint64_t, char *, uint64_t))v233;
    v233(v207, v208, a3);
    return v171(v236, v169, a3);
  }

  v8(v35, a3);
  v162 = v237;
  if (v27 >= ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v237))
  {
    v8(v235, a3);
    v169 = v223;
    v207 = v223;
    v208 = v234;
    goto LABEL_89;
  }

  v163 = ((uint64_t (*)(char *, uint64_t))v8)(v234, a3);
  v239[0] = v27;
  v164 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
  v167 = lazy protocol witness table accessor for type Int and conformance Int(v163, v165, v166);
  v168 = v229;
  v164(v239, &type metadata for Int, v167, a3, v6);
  v169 = v223;
  v170 = v235;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v162 + 200))(v235, v168, a3, v162);
LABEL_68:
  v8(v168, a3);
  v8(v170, a3);
  v171 = (uint64_t (*)(uint64_t, char *, uint64_t))v233;
  return v171(v236, v169, a3);
}

          v39 = (v46 - 1) & v46;
          v43 = __clz(__rbit64(v46)) + (v41 << 6);
        }

        v44 = *(void *)(v23 + 48) + 40 * v43;
        v123 = *(_OWORD *)v44;
        v124 = *(_OWORD *)(v44 + 16);
        v125 = *(void *)(v44 + 32);
        specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v123, (uint64_t)v35);
      }
    }

  __break(1u);
}

    v113 = (unint64_t)v35 >> (v46 & 0x38);
    v114 = v36 - v46;
    if ((v47 & 1) == 0) {
      goto LABEL_8;
    }
    v44 = ((1 << ((v46 >> 1) & 0x1C) << ((v46 >> 1) & 0x1C)) - 1) & (v35 + 16843009);
LABEL_40:
    LODWORD(v112[0]) = v44;
    v48 = *(void (**)(void *, ValueMetadata *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a10 + 104);
    v49 = lazy protocol witness table accessor for type Unicode.UTF8 and conformance Unicode.UTF8(v32, v33, v34);
    v48(v112, &type metadata for Unicode.UTF8, &type metadata for Unicode.UTF8, v49, v10, a10);
    v50 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v16 + 48);
    if (v50(v29, 1LL, v15) == 1)
    {
      (*(void (**)(char *, uint64_t))(v102 + 8))(v29, v103);
LABEL_8:
      v38 = v106;
      v39 = v100;
      (*(void (**)(uint64_t, uint64_t))(a10 + 80))(v10, a10);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a10,  v10,  v15,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.EncodedScalar: BidirectionalCollection);
      Sequence.forEach(_:)( (void (*)(char *))partial apply for closure #1 in closure #1 in String._slowWithCString<A, B>(encodedAs:_:),  (uint64_t)v107,  v15,  *(const char **)(*(void *)(AssociatedConformanceWitness + 8) + 8LL));
      v106 = v38;
      v32 = (*(uint64_t (**)(char *, unint64_t))(v16 + 8))(v39, v15);
      v29 = v99;
      goto LABEL_9;
    }

    v101 = (uint64_t (*)())a1;
    v51 = v10;
    v52 = v16;
    v54 = v102;
    v53 = v103;
    (*(void (**)(char *, char *, uint64_t))(v102 + 16))(v25, v29, v103);
    if (v50(v25, 1LL, v15) == 1)
    {
      v55 = *(void (**)(char *, uint64_t))(v54 + 8);
      v55(v29, v53);
      v55(v25, v53);
      v16 = v52;
      v10 = v51;
      a1 = (unsigned __int8 *)v101;
      goto LABEL_8;
    }

    v56 = v53;
    v57 = v98;
    (*(void (**)(char *, char *, unint64_t))(v52 + 32))(v98, v25, v15);
    v58 = swift_getAssociatedConformanceWitness( a10,  v51,  v15,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.EncodedScalar: BidirectionalCollection);
    v59 = v106;
    Sequence.forEach(_:)( (void (*)(char *))partial apply for closure #1 in closure #1 in String._slowWithCString<A, B>(encodedAs:_:),  (uint64_t)v107,  v15,  *(const char **)(*(void *)(v58 + 8) + 8LL));
    v106 = v59;
    (*(void (**)(char *, unint64_t))(v52 + 8))(v57, v15);
    v60 = *(uint64_t (**)(char *, uint64_t))(v54 + 8);
    v16 = v52;
    v10 = v51;
    v32 = v60(v29, v56);
    a1 = (unsigned __int8 *)v101;
LABEL_9:
    v36 = v114;
    v35 = v113;
    v25 = v104;
  }

  if (a1 && a1 != (unsigned __int8 *)v105)
  {
    v41 = (char)*a1++;
    v42 = a1;
    v43 = v41;
    if ((v41 & 0x80000000) == 0)
    {
      v44 = v43 + 1;
      goto LABEL_40;
    }

    v35 = v35 & 0xFFFFFF00 | v43;
    v36 = 8;
    goto LABEL_16;
  }

  v112[0] = 0LL;
  v61 = v94;
  v62 = swift_getAssociatedConformanceWitness( a10,  v10,  (uint64_t)v94,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger);
  v63 = *(void *)(v62 + 8);
  v64 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v63 + 88);
  v67 = lazy protocol witness table accessor for type Int and conformance Int(v62, v65, v66);
  v68 = (uint64_t)v93;
  v64(v112, &type metadata for Int, v67, v61, v63);
  Array.append(_:)(v68, v92);
  v69 = (uint64_t)v115;
  swift_bridgeObjectRetain_n((uint64_t)v115, 2LL, v70, v71);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v61, v61) && (v69 < 0 || (v69 & 0x4000000000000000LL) != 0))
  {
    v82 = Array._getCount()();
    v73 = v90;
    if (!v82)
    {
      swift_bridgeObjectRelease(v69);
      v74 = 0LL;
      goto LABEL_54;
    }

    v112[0] = v69;
    v86 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)v61, v83, v84);
    WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v86, v87);
    v81 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v86, WitnessTable);
    swift_bridgeObjectRelease(v69);
    v74 = (unint64_t)v81
        + ((*(unsigned __int8 *)(v73 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v73 + 80));
  }

  else
  {
    swift_bridgeObjectRelease(v69);
    isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v61, v61);
    v73 = v90;
    if (isClassOrObjCExistentialType) {
      v74 = (v69 & 0xFFFFFFFFFFFFFF8LL)
    }
          + ((*(unsigned __int8 *)(v90 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v90 + 80));
    else {
      v74 = v69 + ((*(unsigned __int8 *)(v90 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v90 + 80));
    }
LABEL_54:
    if (_swift_isClassOrObjCExistentialType((uint64_t)v61, v61) && (v69 < 0 || (v69 & 0x4000000000000000LL) != 0))
    {
      if (v69 < 0) {
        v81 = (void *)v69;
      }
      else {
        v81 = (void *)(v69 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_unknownObjectRetain(v81, v75, v76, v77);
      if (!v74) {
        goto LABEL_69;
      }
LABEL_61:
      swift_bridgeObjectRelease(v69);
    }

    else
    {
      else {
        v81 = (void *)v69;
      }
      swift_bridgeObjectRetain(v69, v78, v79, v80);
      if (v74) {
        goto LABEL_61;
      }
LABEL_69:
      v85 = ~*(_DWORD *)(v73 + 80);
      swift_bridgeObjectRelease(v69);
      v74 = *(void *)&v85 | 0xFFFFFFFFFFFFFF00LL;
    }
  }

  v97(v74);
  swift_bridgeObjectRelease(v69);
  swift_unknownObjectRelease(v81);
}

  v32 = _StringGuts.nativeUnusedCapacity.getter(v9, v6);
  v35 = (v33 & 1) == 0 && v32 >= v27;
  if ((v29 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
  {
    v24 = v277;
    if (v35) {
      goto LABEL_137;
    }
    goto LABEL_131;
  }

  v24 = v277;
  if (!v35)
  {
LABEL_131:
    v119 = _StringGuts.nativeCapacity.getter(v9, v6);
    if ((v120 & 1) != 0) {
      v121 = 0LL;
    }
    else {
      v121 = v119;
    }
    if (v121 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_306;
    }

    v122 = 2 * v121;
    if (v122 > v22) {
      v22 = v122;
    }
LABEL_137:
    _StringGuts.grow(_:)(v22);
  }

  swift_bridgeObjectRelease_n(v19, 4LL);
  if ((v19 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v19);
    v6 = (unint64_t)&v281;
    _StringGuts._foreignAppendInPlace(_:)(v18, v19, 0LL, v275);
    swift_bridgeObjectRelease_n(v19, 2LL);
LABEL_142:
    v3 = v271;
    goto LABEL_165;
  }

  if (v14)
  {
    swift_bridgeObjectRelease_n(v19, 2LL);
    v279 = v18;
    v280 = v19 & 0xFFFFFFFFFFFFFFLL;
    v123 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v3, (uint64_t)&v279, v3);
    v6 = (unint64_t)&v281;
    _StringGuts.appendInPlace(_:isASCII:)(v123, v124, (v19 & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease(v19);
    goto LABEL_142;
  }

  if ((v18 & 0x1000000000000000LL) == 0)
  {
LABEL_306:
    v136 = _StringObject.sharedUTF8.getter(v18, v19);
    v138 = v262;
    swift_bridgeObjectRelease(v19);
    if (v138 < v269) {
LABEL_285:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    v24 = v277;
    v3 = v271;
    v14 = v274;
    v137 = v269;
    goto LABEL_157;
  }

  swift_bridgeObjectRelease(v19);
  v136 = (id)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
  v137 = v269;
  v138 = v269;
  v3 = v271;
  v14 = v274;
LABEL_157:
  v139 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v137, (uint64_t)v136, v138);
  v6 = (unint64_t)&v281;
  _StringGuts.appendInPlace(_:isASCII:)(v139, v140, v18 < 0);
  swift_bridgeObjectRelease_n(v19, 2LL);
  if (v24 != 1) {
    goto LABEL_167;
  }
  return v281;
}

  v32 = _StringGuts.nativeUnusedCapacity.getter(v9, v6);
  v35 = (v33 & 1) == 0 && v32 >= v27;
  if ((v29 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
  {
    v24 = v282;
    if (v35) {
      goto LABEL_137;
    }
    goto LABEL_131;
  }

  v24 = v282;
  if (!v35)
  {
LABEL_131:
    v119 = _StringGuts.nativeCapacity.getter(v9, v6);
    if ((v120 & 1) != 0) {
      v121 = 0LL;
    }
    else {
      v121 = v119;
    }
    if (v121 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_307;
    }

    v122 = 2 * v121;
    if (v122 > v22) {
      v22 = v122;
    }
LABEL_137:
    _StringGuts.grow(_:)(v22);
  }

  swift_bridgeObjectRelease_n(v19, 4LL);
  if ((v19 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v19);
    v6 = (unint64_t)&v286;
    _StringGuts._foreignAppendInPlace(_:)(v18, v19, 0LL, v280);
    swift_bridgeObjectRelease_n(v19, 2LL);
LABEL_142:
    v3 = v276;
    goto LABEL_165;
  }

  if (v14)
  {
    swift_bridgeObjectRelease_n(v19, 2LL);
    v284 = v18;
    v285 = v19 & 0xFFFFFFFFFFFFFFLL;
    v123 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v3, (uint64_t)&v284, v3);
    v6 = (unint64_t)&v286;
    _StringGuts.appendInPlace(_:isASCII:)(v123, v124, (v19 & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease(v19);
    goto LABEL_142;
  }

  if ((v18 & 0x1000000000000000LL) == 0)
  {
LABEL_307:
    v136 = _StringObject.sharedUTF8.getter(v18, v19);
    v138 = v267;
    swift_bridgeObjectRelease(v19);
    if (v138 < v274) {
LABEL_286:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    v24 = v282;
    v3 = v276;
    v14 = v279;
    v137 = v274;
    goto LABEL_157;
  }

  swift_bridgeObjectRelease(v19);
  v136 = (id)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
  v137 = v274;
  v138 = v274;
  v3 = v276;
  v14 = v279;
LABEL_157:
  v139 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v137, (uint64_t)v136, v138);
  v6 = (unint64_t)&v286;
  _StringGuts.appendInPlace(_:isASCII:)(v139, v140, v18 < 0);
  swift_bridgeObjectRelease_n(v19, 2LL);
  if (v24 != 1) {
    goto LABEL_167;
  }
  return v286;
}

          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
        }
      }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  v35 = swift_slowAlloc(2 * v6, 0xFFFFFFFFFFFFFFFFLL);
  if (v5 > v20) {
    goto LABEL_38;
  }
  if (v7)
  {
    __break(1u);
    goto LABEL_45;
  }

  v36 = v35;
  objc_msgSend((id)(v4 & 0xFFFFFFFFFFFFFFFLL), sel_getCharacters_range_, v35, v5, v6);
  v57[0] = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v6,  0,  (uint64_t)&_swiftEmptyArrayStorage);
  specialized transcode<A, B, C>(_:from:to:stoppingOnError:into:)((uint64_t)v36, (uint64_t)v36 + 2 * v6, 0LL, v57);
  v37 = (uint8x16_t *)v57[0];
  v38 = *(void *)(v57[0] + 16);
  swift_bridgeObjectRetain(v57[0], v39, v40, v41);
  v14 = specialized static String._uncheckedFromUTF8(_:)(v37 + 2, v38);
  v15 = v42;
  v3 = 2;
  swift_bridgeObjectRelease_n((uint64_t)v37, 2LL);
  if ((v15 & 0x2000000000000000LL) != 0) {
    v46 = HIBYTE(v15) & 0xF;
  }
  else {
    v46 = v14 & 0xFFFFFFFFFFFFLL;
  }
  if (!v46) {
LABEL_45:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from an empty String",  43LL,  2,  "Swift/Character.swift",  21LL,  v3,  0xAFuLL,  0);
  swift_bridgeObjectRetain(v15, v43, v44, v45);
  v47._rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15LL)._rawBits;
  v48 = String._uncheckedIndex(after:)(v47)._rawBits;
  swift_bridgeObjectRelease(v15);
  if (v48 >> 14 != 4 * v46) {
    goto LABEL_36;
  }
  if (!(v15 & 0x2000000000000000LL | v14 & 0x1000000000000000LL))
  {
    v14 = specialized static String._copying(_:)(v14, v15);
    v54 = v53;
    swift_bridgeObjectRelease(v15);
    v15 = v54;
  }

  swift_slowDealloc(v36);
LABEL_35:
  v49 = v14;
  v50 = (void *)v15;
  result._object = v50;
  result._countAndFlagsBits = v49;
  return result;
}

    v77 = __OFADD__(v58++, 1LL);
    if (v77) {
      goto LABEL_78;
    }
  }

  (*(void (**)(char *, void (*)(void, void, void, void, void)))(v95 + 8))(v98, v94);
  v103 = (void (*)(char *, char *, unint64_t))v99[2];
LABEL_55:
  v122 = v161;
  v123 = (uint64_t)v186;
  v103(v161, (char *)v186, v28);
  v124 = *(uint64_t (**)(unint64_t, uint64_t))(v33 + 64);
  if ((v124(v28, v33) & 1) == 0)
  {
    v131 = v124(v28, v33);
    v132 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
    if ((v131 & 1) != 0)
    {
      AssociatedConformanceWitness = v157;
      if (v132 > 64)
      {
        v198 = 128LL;
        v135 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
        v136 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
        v137 = v175;
        v135(&v198, &type metadata for Int, v136, v28, v33);
        v138 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v33 + 32) + 8LL)
                                                                           + 16LL))( v122,  v137,  v28);
        v130 = *(void (**)(char *, unint64_t))(v182 + 8);
        v130(v137, v28);
        v139 = v122;
        goto LABEL_69;
      }

      v145 = v169;
      v163(&unk_18180BE68, 256LL);
      v146 = v175;
      v162(v145, v28, v171);
      LODWORD(v181) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v33 + 32)
                                                                                              + 8LL)
                                                                                  + 16LL))( v122,  v146,  v28);
      v147 = v182;
      v130 = *(void (**)(char *, unint64_t))(v182 + 8);
      v130(v146, v28);
      v148 = v160;
      (*(void (**)(char *, char *, unint64_t))(v147 + 32))(v160, v122, v28);
      if ((v181 & 1) != 0)
      {
        v130(v148, v28);
        goto LABEL_70;
      }

      v144 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
      v130(v148, v28);
    }

    else
    {
      AssociatedConformanceWitness = v157;
      v143 = v182;
      if (v132 >= 64)
      {
        v198 = 128LL;
        v181 = *(void (**)(void, void, void, void, void))(v33 + 96);
        v149 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
        v150 = v175;
        v181(&v198, &type metadata for Int, v149, v28, v33);
        v138 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v33 + 32) + 8LL)
                                                                           + 16LL))( v122,  v150,  v28);
        v130 = *(void (**)(char *, unint64_t))(v143 + 8);
        v130(v122, v28);
        v139 = v150;
LABEL_69:
        v130(v139, v28);
        if ((v138 & 1) == 0) {
          goto LABEL_74;
        }
        goto LABEL_70;
      }

      v144 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
      v130 = *(void (**)(char *, unint64_t))(v143 + 8);
      v130(v122, v28);
    }

    if (v144 >= 128) {
      goto LABEL_74;
    }
    goto LABEL_70;
  }

  v125 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
  v128 = v175;
  if (v125 >= 64)
  {
    v198 = 128LL;
    v140 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
    v141 = lazy protocol witness table accessor for type Int and conformance Int(v125, v126, v127);
    v140(&v198, &type metadata for Int, v141, v28, v33);
    v142 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v33 + 32) + 8LL) + 16LL))( v122,  v128,  v28);
    v130 = *(void (**)(char *, unint64_t))(v182 + 8);
    v130(v128, v28);
    v130(v122, v28);
    AssociatedConformanceWitness = v157;
    if ((v142 & 1) != 0) {
      goto LABEL_70;
    }
LABEL_74:
    v152 = specialized numericCast<A, B>(_:)(v123, v28, v33);
    if (v193 != &type metadata for Unicode.UTF8.ForwardParser) {
      goto LABEL_79;
    }
    v153 = v152;
    v130((char *)v123, v28);
    v154 = v166;
    v155 = v192;
    (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, &type metadata for Unicode.UTF8.ForwardParser);
    LODWORD(v198) = v153;
    BYTE4(v198) = 8;
    (*(void (**)(char *, uint64_t *, ValueMetadata *))(v154 + 16))( v155,  &v198,  &type metadata for Unicode.UTF8.ForwardParser);
    goto LABEL_2;
  }

  v129 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
  v130 = *(void (**)(char *, unint64_t))(v182 + 8);
  v130(v122, v28);
  AssociatedConformanceWitness = v157;
  if (v129 >= 128) {
    goto LABEL_74;
  }
LABEL_70:
  v130((char *)v123, v28);
  (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, v193);
  (*(void (**)(char *, uint64_t))(v165 + 8))(v196, v197);
  return v58;
}

  *(void *)a2 = v14;
  *(void *)(a2 + 8) = v15;
  *(_BYTE *)(a2 + 32) = 0;
}

  *(void *)a2 = v14;
  *(void *)(a2 + 8) = v15;
  *(_BYTE *)(a2 + 32) = 0;
}

  v28 = *((int *)v17 + 2);
  v29 = (void *)((char *)v17 + v28 + 8);
  if ((_DWORD)v28) {
    v30 = v29 == 0LL;
  }
  else {
    v30 = 1;
  }
  if (v30)
  {
    v143 = (uint64_t *)v17;
    v31 = (void *)atomic_load((unint64_t *)&qword_18C575880);
    if (!v31 || (uint64_t *)*v31 != v143)
    {
      do
      do
      {
        v33 = atomic_load(&qword_18C575860);
        v34 = atomic_load((unint64_t *)&qword_18C575868);
        v35 = atomic_load((unsigned int *)&dword_18C57585C);
        v36 = atomic_load(&qword_18C575860);
      }

      while (v33 != v36);
      if (v33) {
        v37 = v34 == 0;
      }
      else {
        v37 = 1;
      }
      v38 = v37 || v35 == 0;
      if (v38
      {
        do
        v144 = v143;
        os_unfair_lock_lock((os_unfair_lock_t)&unk_18C575870);
        v42 = (qword_18C575868 & 3) == 0;
        if ((qword_18C575868 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
          v42 = 1;
        }
        v138 = v42;
        lock = (os_unfair_lock_t)(qword_18C575868 & 0xFFFFFFFFFFFFFFFCLL);
        v141 = a2;
        if (v42) {
          v43 = 4;
        }
        else {
          v43 = *(unsigned __int8 *)(qword_18C575868 & 0xFFFFFFFFFFFFFFFCLL);
        }
        v46 = dword_18C57585C;
        v47 = (_DWORD *)qword_18C575860;
        v48 = qword_18C575868;
        if (!v49)
        {
          v136 = v47;
          __src = v47 + 2;
          v133 = v46 + 1;
          v134 = v46;
          if ((1LL << v43) / ((1LL << v43) - (unint64_t)(v46 + 1)) < 4)
          {
            v58 = v46;
            LOBYTE(v59) = v48;
          }

          else
          {
            v51 = (v43 + 1);
            if (v51 >= 0x11) {
              v52 = 4;
            }
            else {
              v52 = 2;
            }
            if (v51 < 9) {
              v53 = 1LL;
            }
            else {
              v53 = v52;
            }
            v54 = (unint64_t)calloc(2LL << v43, v53);
            if (!v54) {
              swift::hashable_support::findHashableBaseTypeOfHashableType();
            }
            if ((_DWORD)v53 != 1)
            {
              if ((_DWORD)v53 == 4) {
                v53 = 3LL;
              }
              else {
                v53 = 2LL;
              }
            }

            v59 = v53 | v54;
            *(_BYTE *)v54 = v43 + 1;
            if (v43) {
              __asm { BR              X8 }
            }

            atomic_store(v59, (unint64_t *)&qword_18C575868);
            if (!v138)
            {
              v66 = malloc(0x10uLL);
              *v66 = qword_18C575878;
              v66[1] = lock;
              qword_18C575878 = (uint64_t)v66;
            }

            v58 = v134;
          }

          v67 = (unint64_t)v136;
          if (!v136 || v58 >= *v136)
          {
            v68 = v58 + (v58 >> 2);
            if (v68 <= v58 + 1) {
              v68 = v58 + 1;
            }
            v69 = malloc_good_size(8 * v68 + 8);
            v70 = malloc(v69);
            if (!v70) {
              swift::hashable_support::findHashableBaseTypeOfHashableType();
            }
            v67 = (unint64_t)v70;
            *v70 = (v69 + 0x7FFFFFFF8LL) >> 3;
            if (v136)
            {
              memcpy(v70 + 2, __src, 8 * v58);
              v71 = malloc(0x10uLL);
              *v71 = qword_18C575878;
              v71[1] = v136;
              qword_18C575878 = (uint64_t)v71;
            }

            atomic_store(v67, &qword_18C575860);
          }

          v145[0] = 21;
          v72 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)v145, 0x40uLL, (const char *)8, v50);
          *(void *)v72 = v143;
          *(_OWORD *)((char *)v72 + 8) = 0u;
          *(_OWORD *)((char *)v72 + 24) = 0u;
          *(_OWORD *)((char *)v72 + 40) = 0u;
          *((void *)v72 + 7) = 0LL;
          *(void *)(v67 + 8 * v58 + 8) = v72;
          atomic_store(v133, (unsigned int *)&dword_18C57585C);
          __asm { BR              X11 }
        }

        v31 = *v49;
        __dmb(0xBu);
        {
          a2 = v141;
          v22 = a1 + 1;
        }

        else
        {
          v56 = (void **)qword_18C575878;
          a2 = v141;
          v22 = a1 + 1;
          if (qword_18C575878)
          {
            do
            {
              v57 = (void **)*v56;
              free(v56[1]);
              free(v56);
              v56 = v57;
            }

            while (v57);
          }

          qword_18C575878 = 0LL;
        }

        os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C575870);
        qword_18C575880 = (uint64_t)v31;
      }

      else
      {
        qword_18C575880 = *v39;
        v31 = (void *)*v39;
        do
      }
    }

    v29 = v31 + 1;
  }

  else if (v29[7] != -1LL)
  {
  }

  v73 = (os_unfair_lock_s *)(v29 + 6);
  v143 = a2;
  v74 = (unint64_t *)atomic_load(v29 + 5);
  if (!v74 || (uint64_t *)v74[1] != v143)
  {
    do
      v75 = __ldaxr((unsigned int *)v29);
    while (__stxr(v75 + 1, (unsigned int *)v29));
    do
    {
      v76 = atomic_load(v29 + 1);
      v77 = atomic_load(v29 + 2);
      v78 = atomic_load((unsigned int *)v29 + 1);
      v79 = atomic_load(v29 + 1);
    }

    while (v76 != v79);
    if (v76) {
      v80 = v77 == 0;
    }
    else {
      v80 = 1;
    }
    v81 = v80 || v78 == 0;
    if (v81
    {
      do
        v84 = __ldxr((unsigned int *)v29);
      while (__stlxr(v84 - 1, (unsigned int *)v29));
      v142 = v22;
      v144 = v143;
      locka = (os_unfair_lock_s *)(v29 + 3);
      os_unfair_lock_lock((os_unfair_lock_t)v29 + 6);
      v85 = v29[2];
      v86 = (v85 & 3) == 0;
      if ((v85 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
        v86 = 1;
      }
      v137 = v86;
      if (v86) {
        v87 = 4;
      }
      else {
        v87 = *(unsigned __int8 *)(v85 & 0xFFFFFFFFFFFFFFFCLL);
      }
      v88 = *((unsigned int *)v29 + 1);
      v89 = (_DWORD *)v29[1];
      v90 = v89 + 2;
      if (!v91)
      {
        v135 = v88;
        v132 = (v88 + 1);
        if ((1LL << v87) / (unint64_t)((1LL << v87) - v132) < 4)
        {
          LOBYTE(v99) = v85;
        }

        else
        {
          v93 = (v87 + 1);
          if (v93 >= 0x11) {
            v94 = 4;
          }
          else {
            v94 = 2;
          }
          if (v93 < 9) {
            v95 = 1LL;
          }
          else {
            v95 = v94;
          }
          v96 = (unint64_t)calloc(2LL << v87, v95);
          if (!v96) {
            swift::hashable_support::findHashableBaseTypeOfHashableType();
          }
          if ((_DWORD)v95 != 1)
          {
            if ((_DWORD)v95 == 4) {
              v95 = 3LL;
            }
            else {
              v95 = 2LL;
            }
          }

          v99 = v95 | v96;
          *(_BYTE *)v96 = v87 + 1;
          if (v87) {
            __asm { BR              X8 }
          }

          atomic_store(v99, v29 + 2);
          if (!v137)
          {
            v100 = malloc(0x10uLL);
            *v100 = v29[4];
            v100[1] = v85 & 0xFFFFFFFFFFFFFFFCLL;
            v29[4] = v100;
          }

          v90 = v89 + 2;
        }

        if (!v89 || (v101 = (unint64_t)v89, v88 >= *v89))
        {
          v102 = v90;
          v103 = v88 + (v88 >> 2);
          if (v103 <= v88 + 1) {
            v103 = v88 + 1;
          }
          v104 = malloc_good_size(8 * v103 + 8);
          v105 = malloc(v104);
          if (!v105) {
            swift::hashable_support::findHashableBaseTypeOfHashableType();
          }
          v101 = (unint64_t)v105;
          *v105 = (v104 + 0x7FFFFFFF8LL) >> 3;
          if (v89)
          {
            memcpy(v105 + 2, v102, 8 * v88);
            v106 = malloc(0x10uLL);
            *v106 = v29[4];
            v106[1] = v89;
            v29[4] = v106;
          }

          atomic_store(v101, v29 + 1);
        }

        v107 = *a1;
        if ((_DWORD)v107)
        {
          v108 = (char *)a1 + (v107 & 0xFFFFFFFFFFFFFFFELL);
          if ((v107 & 1) != 0) {
            v108 = *(char **)v108;
          }
        }

        else
        {
          v108 = 0LL;
        }

        v109 = a1[3];
        v110 = (unsigned int *)(((unint64_t)&a1[3 * BYTE1(v109) + 4 + ((v109 >> 6) & 1)]
                               + ((v109 >> 21) & 0x7F8)
                               + 3) & 0xFFFFFFFFFFFFFFFCLL);
        if ((v109 & 0x10000) != 0) {
          v111 = *v110;
        }
        else {
          v111 = 0LL;
        }
        v112 = 8
             * ((*((_DWORD *)v108 + 4) + 1)
        v145[0] = 16;
        v113 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)v145, v112, (const char *)8, v92);
        v114 = v143;
        v115 = (os_unfair_lock_s *)swift_slowAlloc(0x10uLL, 7uLL);
        *(_OWORD *)&v115->_os_unfair_lock_opaque = xmmword_1817FFD30;
        os_unfair_lock_lock(v115 + 2);
        *(void *)v113 = (unint64_t)v115 | 1;
        *((void *)v113 + 1) = v114;
        *((void *)v113 + 2) = a1;
        *(void *)(v101 + 8 + 8 * v135) = v113;
        atomic_store(v132, (unsigned int *)v29 + 1);
        __asm { BR              X11 }
      }

      v74 = *v91;
      __dmb(0xBu);
      if (*(_DWORD *)v29)
      {
        os_unfair_lock_unlock(locka);
        v29[5] = v74;
        v73 = (os_unfair_lock_s *)(v29 + 6);
        v22 = v142;
      }

      else
      {
        v97 = (void **)v29[4];
        if (v97)
        {
          do
          {
            v98 = (void **)*v97;
            free(v97[1]);
            free(v97);
            v97 = v98;
          }

          while (v98);
        }

        v73 = (os_unfair_lock_s *)(v29 + 6);
        v22 = v142;
        v29[4] = 0LL;
        os_unfair_lock_unlock(locka);
        v29[5] = v74;
      }
    }

    else
    {
      v29[5] = *v82;
      v74 = *v82;
      do
        v83 = __ldxr((unsigned int *)v29);
      while (__stlxr(v83 - 1, (unsigned int *)v29));
    }
  }

  v7 = atomic_load(v74);
  if (v7 >= 2 && (v7 & 1) != 0)
  {
    os_unfair_lock_lock(v73);
    v7 = *v74;
    if ((*v74 & 1) != 0 && (v117 = v7 & 0xFFFFFFFFFFFFFFFELL, (v7 & 0xFFFFFFFFFFFFFFFELL) != 0))
    {
      ++*(void *)v117;
      os_unfair_lock_unlock(v73);
      os_unfair_lock_lock((os_unfair_lock_t)(v117 + 8));
      os_unfair_lock_unlock((os_unfair_lock_t)(v117 + 8));
      os_unfair_lock_lock(v73);
      if (*(void *)v117 == 1LL) {
        swift_slowDealloc((void *)(v7 & 0xFFFFFFFFFFFFFFFELL));
      }
      else {
        --*(void *)v117;
      }
      os_unfair_lock_unlock(v73);
      v7 = *v74;
    }

    else
    {
      os_unfair_lock_unlock(v73);
    }
  }

  if (!v7) {
    return v7;
  }
  v118 = a1[3];
  if ((v118 & 0x80) == 0) {
    return v7;
  }
  v120 = (v118 >> 3) & 7;
  if (v120 != 1)
  {
    if (!v120)
    {
      v14 = *v22;
      v15 = (char *)v22 + v14;
LABEL_193:
      if ((_DWORD)v14) {
        v44 = (uint64_t)v15;
      }
      else {
        v44 = 0LL;
      }
      v45 = *a1;
      if (!(_DWORD)v45) {
        goto LABEL_197;
      }
LABEL_199:
      v121 = (void *)((char *)a1 + (v45 & 0xFFFFFFFFFFFFFFFELL));
      if ((v45 & 1) != 0) {
        v121 = (void *)*v121;
      }
      return _getForeignWitnessTable(v7, v44, (uint64_t)v121);
    }

  operator delete(*(void **)(v34 - 128));
  if (((char)v62.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_24:
    goto LABEL_40;
  }

    abort();
  }

          v9 = -1000;
          return swift::Demangle::__runtime::Demangler::getDependentGenericParamType(this, v13, v9, a4, a5);
        }

        v9 = -1000;
        if ((v24 & 0x80000000) == 0 && v15 < v6 && v25 == 95)
        {
          *((void *)this + 9) = v15 + 1;
          v9 = v24 + 1;
        }

        return swift::Demangle::__runtime::Demangler::getDependentGenericParamType(this, v13, v9, a4, a5);
      case 's':
        *((void *)this + 9) = v7 + 1;
        result = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!result || (unint64_t)(result + 24) > *((void *)this + 2))
        {
          v17 = 2LL * *((void *)this + 4);
          if (v17 <= 0x20) {
            v17 = 32LL;
          }
          *((void *)this + 4) = v17;
          v18 = v17 + 8;
          v19 = malloc(v17 + 8);
          *v19 = *((void *)this + 3);
          result = ((unint64_t)v19 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v19 + v18;
          *((void *)this + 3) = v19;
        }

        *((void *)this + 1) = result + 24;
        *(_WORD *)(result + 16) = 85;
        *(_BYTE *)(result + 18) = 0;
        return result;
      case 'z':
        *((void *)this + 9) = v7 + 1;
        v13 = 0;
        v9 = 0;
        return swift::Demangle::__runtime::Demangler::getDependentGenericParamType(this, v13, v9, a4, a5);
      default:
        v10 = 0;
        v9 = -999;
        break;
    }

    while (1)
    {
      v11 = *(unsigned __int8 *)(v8 + v7);
      v12 = v11 + 10 * v10 - 48;
      if (v12 < v10) {
        goto LABEL_10;
      }
      *((void *)this + 9) = ++v7;
      v10 = v12;
      if (v6 == v7) {
        goto LABEL_11;
      }
    }

    v9 = -999;
    if ((v10 & 0x80000000) == 0 && v7 < v6 && v11 == 95)
    {
      *((void *)this + 9) = v7 + 1;
      v9 = v10 + 2;
    }
  }

  v38 = v10 + 1;
  if (v4 < v10 + 1) {
    v38 = v4;
  }
  a1 += v38;
  v4 -= v38;
LABEL_41:
  if (!v4) {
    return 1LL;
  }
  v39 = 0;
  v40 = 72;
LABEL_43:
  v41 = 0LL;
  v42 = 36;
  v43 = 1;
  v44 = v39;
  while (1)
  {
    v45 = (char)a1[v41];
    v46 = v45 - 97;
    if ((v45 - 97) > 0x19)
    {
      v46 = v45 - 39;
    }

    if (v46 < 0 || v46 > (v44 ^ 0x7FFFFFFF) / v43) {
      return 0LL;
    }
    v44 += v46 * v43;
    v47 = v42 - v40;
    if (v42 >= v40 + 26) {
      v47 = 26;
    }
    if (v42 <= v40) {
      v47 = 1;
    }
    if (v46 < v47)
    {
      v48 = v44 - v39;
      v49 = v3->__begin_;
      v50 = v3->__end_ - v3->__begin_;
      if (v39) {
        v51 = 2;
      }
      else {
        v51 = 700;
      }
      v52 = v48 / v51 / ((int)v50 + 1) + v48 / v51;
      if (v52 < 456)
      {
        v53 = 0;
      }

      else
      {
        v53 = 0;
        v54 = v52;
        do
        {
          v52 = v54 / 0x23;
          v53 += 36;
          v55 = v54 >> 3;
          v54 /= 0x23u;
        }

        while (v55 > 0x7CA);
      }

      v56 = v50 + 1;
      v57 = v44 / v56;
      v58 = __x;
      if (v57 > (__x ^ 0x7FFFFFFF)) {
        return 0LL;
      }
      __x += v57;
      v67 = v4 - 1;
      v59 = (uint64_t)&a1[v41 + 1];
      v40 = 36 * v52 / (v52 + 38) + v53;
      v60 = ~v41 + v4;
      v61 = v44 % v56;
      v62.__i_ = &v49[(int)v61];
      std::vector<unsigned int>::insert(v3, v62, &__x);
      v39 = v61 + 1;
      v4 = v60;
      a1 = (unsigned __int8 *)v59;
      result = 1LL;
      if (v67 != v41) {
        goto LABEL_43;
      }
      return result;
    }

    if (v43 <= 0x7FFFFFFF / (36 - v47))
    {
      v43 *= 36 - v47;
      v42 += 36;
      if (v4 != ++v41) {
        continue;
      }
    }

    return 0LL;
  }

    if (v13 >> 7 >= 0x1B1 && (v13 - 57344) >> 13 > 0x80) {
      goto LABEL_72;
    }
LABEL_40:
    if (v7 >= (unsigned int *)v8)
    {
      v26 = v7 - v10;
      v27 = v26 + 1;
      else {
        v28 = v27;
      }
      if (v28)
      {
        if (v28 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        v29 = operator new(4 * v28);
      }

      else
      {
        v29 = 0LL;
      }

      v30 = (unsigned int *)&v29[4 * v26];
      *v30 = v13;
      v11 = v30 + 1;
      if (v7 == v10) {
        goto LABEL_55;
      }
      v31 = (char *)v7 - (char *)v10 - 4;
      if (v31 >= 0xBC)
      {
        v34 = ((char *)(v7 - 1) - (char *)v10) & 0xFFFFFFFFFFFFFFFCLL;
        if (&v29[(char *)v7 - (char *)v10 - 4 - v34] > &v29[(char *)v7 - (char *)v10 - 4])
        {
          v32 = v7;
        }

        else if ((unsigned int *)((char *)v7 - v34 - 4) > v7 - 1)
        {
          v32 = v7;
        }

        else if ((unint64_t)((char *)v10 - v29) >= 0x20)
        {
          v35 = (v31 >> 2) + 1;
          v36 = 4 * (v35 & 0x7FFFFFFFFFFFFFF8LL);
          v32 = &v7[v36 / 0xFFFFFFFFFFFFFFFCLL];
          v30 = (unsigned int *)((char *)v30 - v36);
          v37 = &v29[4 * v26 - 16];
          v38 = v7 - 4;
          v39 = v35 & 0x7FFFFFFFFFFFFFF8LL;
          do
          {
            v40 = *(_OWORD *)v38;
            *(v37 - 1) = *((_OWORD *)v38 - 1);
            *v37 = v40;
            v37 -= 2;
            v38 -= 8;
            v39 -= 8LL;
          }

          while (v39);
          if (v35 == (v35 & 0x7FFFFFFFFFFFFFF8LL)) {
            goto LABEL_55;
          }
        }

        else
        {
          v32 = v7;
        }
      }

      else
      {
        v32 = v7;
      }

      do
      {
        v33 = *--v32;
        *--v30 = v33;
      }

      while (v32 != v10);
LABEL_55:
      v8 = &v29[4 * v28];
      __p = v30;
      v47 = v8;
      if (v10) {
        operator delete(v10);
      }
      v10 = v30;
      goto LABEL_5;
    }

    *v7 = v13;
    v11 = v7 + 1;
LABEL_5:
    v46 = v11;
    v7 = v11;
  }

  if (v12 != v9)
  {
    v17 = *v12;
    if ((v17 & 0xC0) == 0x80)
    {
      a1 += 2;
      v13 = v17 & 0x3F | ((v13 & 0x1F) << 6);
      goto LABEL_40;
    }
  }

    if (a10) {
      std::string::append(&__p, __s, a10);
    }
    v36 = *((unsigned __int8 *)v14 + 18);
    if (v36 != 2)
    {
      if (v36 != 5 || *((_DWORD *)v14 + 2) < 2u)
      {
        v37 = 0LL;
LABEL_46:
        size = __p.__r_.__value_.__s.__size_;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          size = __p.__r_.__value_.__l.__size_;
        }
        if (!size || *((_WORD *)v37 + 8) != 101) {
          goto LABEL_75;
        }
        v39 = *(_DWORD *)(a1 + 12736);
        v40 = *(unsigned int *)(a1 + 12740);
        v41 = *(char **)(a1 + 12728);
        if (v39 < v40)
        {
LABEL_68:
          *(_DWORD *)(a1 + 12736) = v39 + 1;
          v41[v39] = 80;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            v51 = &__p;
          }
          else {
            v51 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            v52 = __p.__r_.__value_.__s.__size_;
          }
          else {
            v52 = __p.__r_.__value_.__l.__size_;
          }
          swift::Demangle::__runtime::CharVector::append( (unsigned int *)(a1 + 12728),  v52,  *(swift::Demangle::__runtime::NodeFactory **)(a1 + 12744));
          swift::Demangle::__runtime::CharVector::append((char **)(a1 + 12728), v51, v52, *(void **)(a1 + 12744));
          *(_DWORD *)a8 = 0;
          *(void *)(a8 + 8) = 0LL;
          *(_DWORD *)(a8 + 16) = 0;
LABEL_75:
          return;
        }

        v42 = *(void **)(a1 + 12744);
        v43 = (char *)v42[1];
        if (&v41[v40] == v43)
        {
          v45 = (unint64_t)&v41[v40 + 1];
          v44 = v42[2];
          if (v45 <= v44)
          {
            v42[1] = v45;
            v50 = 1;
LABEL_67:
            *(_DWORD *)(a1 + 12740) = v40 + v50;
            goto LABEL_68;
          }
        }

        else
        {
          v44 = v42[2];
        }

        LODWORD(v46) = 2 * v40;
        else {
          v46 = v46;
        }
        v59 = v46;
        v47 = v46 + v40;
        if (!v43 || (unint64_t)&v43[v47] > v44)
        {
          v48 = 2LL * v42[4];
          if (v48 <= v47 + 1) {
            v48 = v47 + 1;
          }
          v42[4] = v48;
          v57 = v48 + 8;
          v49 = malloc(v48 + 8);
          *v49 = v42[3];
          v43 = (char *)(v49 + 1);
          v42[2] = (char *)v49 + v57;
          v42[3] = v49;
        }

        v42[1] = &v43[v47];
        if ((_DWORD)v40)
        {
          memcpy(v43, *(const void **)(a1 + 12728), v40);
          LODWORD(v40) = *(_DWORD *)(a1 + 12740);
          v39 = *(_DWORD *)(a1 + 12736);
        }

        v50 = v59;
        *(void *)(a1 + 12728) = v43;
        v41 = v43;
        goto LABEL_67;
      }

      v14 = (uint64_t *)*v14;
    }

    v37 = (swift::Demangle::__runtime::Node *)v14[1];
    goto LABEL_46;
  }

uint64_t static UInt64.& infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 & a1;
}

BOOL static UInt64.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL static Bool.random()()
{
  uint64_t __buf = 0LL;
  swift_stdlib_random(&__buf, 8uLL);
  return (__buf & 0x20000) == 0;
}

Swift::Bool __swiftcall Bool.init(BOOLeanLiteral:)(Swift::Bool BOOLeanLiteral)
{
  return BOOLeanLiteral;
}

uint64_t protocol witness for _ExpressibleByBuiltinBooleanLiteral.init(_builtinBooleanLiteral:) in conformance Bool@<X0>( uint64_t result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = result;
  return result;
}

_BYTE *protocol witness for ExpressibleByBooleanLiteral.init(BOOLeanLiteral:) in conformance Bool@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = *result;
  return result;
}

uint64_t Bool.description.getter(char a1)
{
  if ((a1 & 1) != 0) {
    return 1702195828LL;
  }
  else {
    return 0x65736C6166LL;
  }
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Bool()
{
  if (*v0) {
    return 1702195828LL;
  }
  else {
    return 0x65736C6166LL;
  }
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Bool( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

void Bool.hash(into:)(uint64_t a1, char a2)
{
}

Swift::Int Bool.hashValue.getter(char a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Bool()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Bool()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Bool()
{
  return Hasher._finalize()();
}

Swift::Bool_optional __swiftcall Bool.init(_:)(Swift::String a1)
{
  object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  if ((~(uint64_t)a1._object & 0x6000000000000000LL) == 0)
  {
    if (a1._countAndFlagsBits == 1702195828)
    {
LABEL_14:
      swift_bridgeObjectRelease((uint64_t)a1._object);
      return (Swift::Bool_optional)2;
    }

uint64_t static String.== infix(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a1 == a3 && a2 == a4) {
    return 1LL;
  }
  if ((~a2 & 0x6000000000000000LL) == 0 && (a4 & 0x2000000000000000LL) != 0 && (a4 & 0x4000000000000000LL) != 0) {
    return 0LL;
  }
  return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, 0);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Bool( uint64_t a1@<X0>, unint64_t a2@<X1>, char *a3@<X8>)
{
  if (a1 == 1702195828 && a2 == 0xE400000000000000LL) {
    goto LABEL_10;
  }
  if ((~a2 & 0x6000000000000000LL) == 0)
  {
    if (a1 == 1702195828)
    {
      if (a2 == 0xE400000000000000LL) {
        goto LABEL_10;
      }
LABEL_14:
      swift_bridgeObjectRelease(a2);
      char v7 = 2;
      goto LABEL_11;
    }

    if (a1 != 0x65736C6166LL || a2 != 0xE500000000000000LL) {
      goto LABEL_14;
    }
LABEL_17:
    swift_bridgeObjectRelease(a2);
    char v7 = 0;
    goto LABEL_11;
  }

  if ((_stringCompareInternal(_:_:expecting:)(a1, a2, 1702195828LL, 0xE400000000000000LL, 0) & 1) != 0)
  {
LABEL_10:
    swift_bridgeObjectRelease(a2);
    char v7 = 1;
    goto LABEL_11;
  }

  if (a1 == 0x65736C6166LL && a2 == 0xE500000000000000LL) {
    goto LABEL_17;
  }
  char v8 = _stringCompareInternal(_:_:expecting:)(a1, a2, 0x65736C6166LL, 0xE500000000000000LL, 0);
  swift_bridgeObjectRelease(a2);
  char v7 = 0;
  if ((v8 & 1) == 0) {
    char v7 = 2;
  }
LABEL_11:
  *a3 = v7;
}

Swift::Void __swiftcall Bool.toggle()()
{
  BOOL *v0 = !*v0;
}

unint64_t *_SwiftCreateBridgedArray_DoNotCall(values:numValues:)(char *a1, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  v2 = specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2);
  v4 = (unint64_t *)v2;
  if (((unint64_t)v2 & 0x8000000000000000LL) == 0 && ((unint64_t)v2 & 0x4000000000000000LL) == 0)
  {
    if (one-time initialization token for _bridgeInitializedSuccessfully != -1) {
      swift_once( &one-time initialization token for _bridgeInitializedSuccessfully,  (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully,  v3);
    }
    if (!_bridgeInitializedSuccessfully) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0x82uLL,  0);
    }
    _orphanedFoundationSubclassesReparented = 1;
    if (v4[2])
    {
      uint64_t v5 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
      swift_retain(v4, v6, v7, v8);
      _swift_setClassMetadata(v5, v4);
      v9 = (__objc2_class **)v4;
    }

    else
    {
      v9 = &_swiftEmptyArrayStorage;
    }

    swift_release((uint64_t)v4);
    return (unint64_t *)v9;
  }

  return v4;
}

void *_SwiftCreateBridgedMutableArray(char *a1, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  v2 = specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2);
  uint64_t v3 = type metadata accessor for _SwiftNSMutableArray();
  Swift::Bool_optional result = swift_allocObject(v3, 0x18uLL, 7uLL);
  result[2] = v2;
  return result;
}

void *_SwiftCreateBridgedMutableArray_DoNotCall(values:numValues:)(char *a1, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  v2 = specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2);
  uint64_t v3 = type metadata accessor for _SwiftNSMutableArray();
  Swift::Bool_optional result = swift_allocObject(v3, 0x18uLL, 7uLL);
  result[2] = v2;
  return result;
}

objc_class *one-time initialization function for _bridgeInitializedSuccessfully()
{
  Swift::Bool_optional result = swift_stdlib_connectNSBaseClasses();
  _bridgeInitializedSuccessfully = result & 1;
  return result;
}

void *_BridgeableMetatype._bridgeToObjectiveC()()
{
  return swift_getObjCClassFromMetadata(*v0);
}

uint64_t static _BridgeableMetatype._forceBridgeFromObjectiveC(_:result:)( void *a1, void *a2, uint64_t a3, char *a4)
{
  char v8 = a1;
  swift_unknownObjectRetain(a1, (uint64_t)a2, a3, a4);
  uint64_t v5 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Swift.AnyObject.Type);
  uint64_t result = swift_dynamicCast((char *)&v7, (uint64_t *)&v8, (swift *)&unk_189B8D230, v5, 7uLL);
  *a2 = v7;
  return result;
}

uint64_t static _BridgeableMetatype._conditionallyBridgeFromObjectiveC(_:result:)( void *a1, void *a2, uint64_t a3, char *a4)
{
  v9 = a1;
  swift_unknownObjectRetain(a1, (uint64_t)a2, a3, a4);
  uint64_t v5 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Swift.AnyObject.Type);
  uint64_t result = swift_dynamicCast((char *)&v8, (uint64_t *)&v9, (swift *)&unk_189B8D230, v5, 6uLL);
  if ((_DWORD)result) {
    uint64_t v7 = v8;
  }
  else {
    uint64_t v7 = 0LL;
  }
  *a2 = v7;
  return result;
}

uint64_t static _BridgeableMetatype._unconditionallyBridgeFromObjectiveC(_:)@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xB4uLL,  0);
  }
  uint64_t v8 = a1;
  swift_unknownObjectRetain(a1, a2, a3, a4);
  uint64_t v6 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Swift.AnyObject.Type);
  return swift_dynamicCast(a5, (uint64_t *)&v8, (swift *)&unk_189B8D230, v6, 7uLL);
}

void *protocol witness for _ObjectiveCBridgeable._bridgeToObjectiveC() in conformance _BridgeableMetatype()
{
  return swift_getObjCClassFromMetadata(*v0);
}

uint64_t protocol witness for static _ObjectiveCBridgeable._forceBridgeFromObjectiveC(_:result:) in conformance _BridgeableMetatype( void *a1, void *a2, uint64_t a3, char *a4)
{
  uint64_t v8 = a1;
  swift_unknownObjectRetain(a1, (uint64_t)a2, a3, a4);
  uint64_t v5 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Swift.AnyObject.Type);
  uint64_t result = swift_dynamicCast((char *)&v7, (uint64_t *)&v8, (swift *)&unk_189B8D230, v5, 7uLL);
  *a2 = v7;
  return result;
}

uint64_t protocol witness for static _ObjectiveCBridgeable._conditionallyBridgeFromObjectiveC(_:result:) in conformance _BridgeableMetatype( void *a1, void *a2, uint64_t a3, char *a4)
{
  v9 = a1;
  swift_unknownObjectRetain(a1, (uint64_t)a2, a3, a4);
  uint64_t v5 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Swift.AnyObject.Type);
  uint64_t result = swift_dynamicCast((char *)&v8, (uint64_t *)&v9, (swift *)&unk_189B8D230, v5, 6uLL);
  if ((_DWORD)result) {
    uint64_t v7 = v8;
  }
  else {
    uint64_t v7 = 0LL;
  }
  *a2 = v7;
  return result;
}

char *_bridgeAnythingToObjectiveC<A>(_:)(id *a1, uint64_t *a2)
{
  uint64_t v4 = *(a2 - 1);
  uint64_t v5 = *(void *)(v4 + 64);
  MEMORY[0x1895F8858](a1);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v6, v6))
  {
    if (v5 != 8) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }
    return (char *)swift_unknownObjectRetain(*a1, v7, v8, v9);
  }

  else
  {
    (*(void (**)(char *, id *, uint64_t *))(v4 + 16))( (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a1,  a2);
    return _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)( (id *)((char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL)),  a2,  v11,  v12);
  }

id _bridgeAnyObjectToAny(_:)@<X0>( id a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, void *a5@<X8>)
{
  if (a1)
  {
    ObjectType = (void *)swift_getObjectType((unint64_t)a1);
    id v8 = a1;
  }

  else
  {
    id v8 = 0LL;
    ObjectType = &unk_189B88DA0;
  }

  a5[3] = ObjectType;
  *a5 = v8;
  return swift_unknownObjectRetain(a1, a2, a3, a4);
}

uint64_t _forceBridgeFromObjectiveC<A>(_:_:)@<X0>( void *a1@<X0>, char *a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v7 = type metadata accessor for Optional(0LL, (uint64_t)a2, (uint64_t)a2, a3);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (uint64_t *)((char *)&v19 - v12);
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, (uint64_t *)a2))
  {
    v20 = a1;
    swift_unknownObjectRetain(a1, v14, v15, v16);
    return swift_dynamicCast(a4, (uint64_t *)&v20, (swift *)&unk_189B8D230, a2, 7uLL);
  }

  else
  {
    uint64_t v18 = *((void *)a2 - 1);
    (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v18 + 56))(v13, 1LL, 1LL, a2);
    _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)a1, (uint64_t)a2, v13);
    (*(void (**)(char *, uint64_t *, uint64_t))(v8 + 16))(v11, v13, v7);
    if ((*(unsigned int (**)(char *, uint64_t, char *))(v18 + 48))(v11, 1LL, a2) == 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
    }
    (*(void (**)(uint64_t *, uint64_t))(v8 + 8))(v13, v7);
    return (*(uint64_t (**)(char *, char *, char *))(v18 + 32))(a4, v11, a2);
  }

uint64_t _forceBridgeFromObjectiveC_bridgeable<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, a2, a2, a3);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v17 - v13;
  uint64_t v15 = *(void *)(a2 - 8);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 56))((char *)&v17 - v13, 1LL, 1LL, a2);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a3 + 24))(a1, v14, a2, a3);
  (*(void (**)(char *, char *, uint64_t))(v9 + 16))(v12, v14, v8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v15 + 48))(v12, 1LL, a2) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0x109uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v9 + 8))(v14, v8);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v15 + 32))(a4, v12, a2);
}

uint64_t _conditionallyBridgeFromObjectiveC<A>(_:_:)@<X0>( void *a1@<X0>, char *a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v7 = type metadata accessor for Optional(0LL, (uint64_t)a2, (uint64_t)a2, a3);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (uint64_t *)((char *)&v16 - v9);
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, (uint64_t *)a2))
  {
    uint64_t v17 = a1;
    swift_unknownObjectRetain(a1, v11, v12, v13);
    int v14 = swift_dynamicCast(a4, (uint64_t *)&v17, (swift *)&unk_189B8D230, a2, 6uLL);
    return (*(uint64_t (**)(char *, void, uint64_t, char *))(*((void *)a2 - 1) + 56LL))( a4,  v14 ^ 1u,  1LL,  a2);
  }

  else
  {
    (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(*((void *)a2 - 1) + 56LL))(v10, 1LL, 1LL, a2);
    _bridgeNonVerbatimFromObjectiveCConditional<A>(_:_:_:)((swift *)a1, (uint64_t)a2, v10);
    return (*(uint64_t (**)(char *, uint64_t *, uint64_t))(v8 + 32))(a4, v10, v7);
  }

uint64_t _conditionallyBridgeFromObjectiveC_bridgeable<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 32))(a1, a4, a2, a3);
}

id _bridgeNonVerbatimFromObjectiveCToAny(void *a1, uint64_t *a2)
{
  a2[3] = swift_getObjectType((unint64_t)a1);
  *a2 = (uint64_t)a1;
  return swift_unknownObjectRetain(a1, v4, v5, v6);
}

uint64_t _bridgeNonVerbatimBoxedValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for Optional(0LL, a3, a3, a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8LL))(a2, v7);
  uint64_t v8 = *(void *)(a3 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 16))(a2, a1, a3);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v8 + 56))(a2, 0LL, 1LL, a3);
}

BOOL _isBridgedToObjectiveC<A>(_:)(uint64_t a1, uint64_t *a2)
{
}

BOOL _isBridgedVerbatimToObjectiveC<A>(_:)(uint64_t a1, uint64_t *a2)
{
  return _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
}

const char *_getBridgedObjectiveCType<A>(_:)(uint64_t a1, uint64_t *a2)
{
  else {
    return _getBridgedNonVerbatimObjectiveCType<A>(_:)((uint64_t)a2, (uint64_t)a2);
  }
}

uint64_t AutoreleasingUnsafeMutablePointer.pointee.getter@<X0>( id *a1@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  id v7 = *a1;
  if (v7) {
    id v7 = swift_unknownObjectRetain(v7, (uint64_t)a2, a3, a4);
  }
  id v9 = v7;
  return swift_dynamicCast(a5, (uint64_t *)&v9, (swift *)&unk_189B88DA0, a2, 7uLL);
}

uint64_t key path getter for AutoreleasingUnsafeMutablePointer.pointee : <A>AutoreleasingUnsafeMutablePointer<A>@<X0>( id **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v6 = *(const char **)(a3 + a2 - 8);
  id v7 = **a1;
  if (v7) {
    id v7 = swift_unknownObjectRetain(v7, a2, a3, a4);
  }
  id v9 = v7;
  return swift_dynamicCast(a5, (uint64_t *)&v9, (swift *)&unk_189B88DA0, v6, 7uLL);
}

id key path setter for AutoreleasingUnsafeMutablePointer.pointee : <A>AutoreleasingUnsafeMutablePointer<A>( uint64_t a1, void **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(swift **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  id v7 = (uint64_t *)((char *)&v12 - v6);
  (*(void (**)(char *))(v8 + 16))((char *)&v12 - v6);
  id v9 = *a2;
  swift_dynamicCast((char *)&v13, v7, v5, byte_189B88DA0, 7uLL);
  id v10 = v13;
  id result = v13;
  void *v9 = v10;
  return result;
}

id AutoreleasingUnsafeMutablePointer.pointee.setter(uint64_t *a1, void *a2, swift *a3)
{
  id v4 = v6;
  id result = v6;
  *a2 = v4;
  return result;
}

uint64_t _unsafeReferenceCast<A, B>(_:to:)@<X0>( uint64_t a1@<X0>, swift *a2@<X2>, const char *a3@<X3>, char *a4@<X8>)
{
  uint64_t v8 = (uint64_t *)((char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *))(v9 + 16))(v8);
  return swift_dynamicCast(a4, v8, a2, a3, 7uLL);
}

void (*AutoreleasingUnsafeMutablePointer.pointee.modify( uint64_t **a1, id *a2, const char *a3))(uint64_t *a1, char a2)
{
  id v6 = (uint64_t *)malloc(0x40uLL);
  *a1 = v6;
  v6[3] = (uint64_t)a2;
  v6[4] = (uint64_t)a3;
  uint64_t v7 = *((void *)a3 - 1);
  v6[5] = v7;
  size_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = (char *)malloc(v8);
  v6[6] = (uint64_t)v9;
  id v13 = malloc(v8);
  v6[7] = (uint64_t)v13;
  id v14 = *a2;
  if (*a2) {
    id v14 = swift_unknownObjectRetain(v14, v10, v11, v12);
  }
  *id v6 = (uint64_t)v14;
  swift_dynamicCast(v9, v6, (swift *)byte_189B88DA0, a3, 7uLL);
  (*(void (**)(void *, char *, const char *))(v7 + 32))(v13, v9, a3);
  return AutoreleasingUnsafeMutablePointer.pointee.modify;
}

void AutoreleasingUnsafeMutablePointer.pointee.modify(uint64_t *a1, char a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 40);
  (*(void (**)(void, void, void))(v4 + 16))( *(void *)(*a1 + 48),  *(void *)(v3 + 56),  *(void *)(v3 + 32));
  id v6 = *(void **)(v3 + 48);
  uint64_t v5 = *(void **)(v3 + 56);
  size_t v8 = *(void **)(v3 + 24);
  uint64_t v7 = *(void *)(v3 + 32);
  BOOL v9 = (a2 & 1) == 0;
  if ((a2 & 1) != 0) {
    uint64_t v10 = 8LL;
  }
  else {
    uint64_t v10 = 16LL;
  }
  if (v9) {
    uint64_t v11 = (char *)(v3 + 16);
  }
  else {
    uint64_t v11 = (char *)(v3 + 8);
  }
  swift_dynamicCast(v11, *(uint64_t **)(v3 + 48), *(swift **)(v3 + 32), byte_189B88DA0, 7uLL);
  uint64_t v12 = *(void **)(v3 + v10);
  id v13 = v12;
  *size_t v8 = v12;
  (*(void (**)(void *, uint64_t))(v4 + 8))(v5, v7);
  free(v5);
  free(v6);
  free((void *)v3);
}

uint64_t AutoreleasingUnsafeMutablePointer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  id v7 = *(id *)(a2 + *(void *)(*((void *)a3 - 1) + 72LL) * a1);
  if (v7) {
    id v7 = swift_unknownObjectRetain(v7, a2, (uint64_t)a3, a4);
  }
  id v9 = v7;
  return swift_dynamicCast(a5, (uint64_t *)&v9, (swift *)byte_189B88DA0, a3, 7uLL);
}

uint64_t _Pointer.advanced(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 48))(a2, a3);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for _Pointer,  associated type descriptor for _Pointer.Pointee);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))( v6 + *(void *)(*(void *)(AssociatedTypeWitness - 8) + 72LL) * a1,  a2,  a3);
}

Swift::Int AutoreleasingUnsafeMutablePointer.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter( a1,  a2,  (uint64_t (*)(void))type metadata accessor for AutoreleasingUnsafeMutablePointer,  (uint64_t)&protocol conformance descriptor for AutoreleasingUnsafeMutablePointer<A>);
}

uint64_t protocol witness for _Pointer._rawValue.getter in conformance AutoreleasingUnsafeMutablePointer<A>()
{
  return *(void *)v0;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter(*v1, *(void *)(a1 + 16));
}

void protocol witness for Hashable.hash(into:) in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable( &protocol conformance descriptor for AutoreleasingUnsafeMutablePointer<A>,  a2,  a3);
  _Pointer.hash(into:)(a1, a2, WitnessTable);
}

void _Pointer.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  v20[1] = a1;
  uint64_t v7 = *(void *)(a2 - 8);
  size_t v8 = *(void *)(v7 + 64);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = type metadata accessor for Optional(0LL, v9, v10, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)v20 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)v20 - v17;
  memcpy((char *)v20 - v17, v4, v8);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v7 + 56))(v18, 0LL, 1LL, a2);
  (*(void (**)(char *, char *, uint64_t))(v13 + 32))(v16, v18, v12);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v7 + 48))(v16, 1LL, a2) == 1)
  {
    (*(void (**)(char *, uint64_t))(v13 + 8))(v16, v12);
    Swift::UInt v19 = 0LL;
  }

  else
  {
    memcpy((char *)v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), v16, v8);
    Swift::UInt v19 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 48))(a2, a3);
  }

  Hasher._combine(_:)(v19);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance AutoreleasingUnsafeMutablePointer<A>( Swift::Int a1, uint64_t a2, uint64_t a3)
{
  return _Pointer._rawHashValue(seed:)(a1);
}

Swift::Int __swiftcall _Pointer._rawHashValue(seed:)(Swift::Int seed)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  Swift::Int v22 = seed;
  uint64_t v7 = *(void *)(v1 - 8);
  size_t v8 = *(void *)(v7 + 64);
  MEMORY[0x1895F8858](seed);
  uint64_t v12 = type metadata accessor for Optional(0LL, v9, v10, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v21 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v21 - v17;
  memcpy((char *)&v21 - v17, v4, v8);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v7 + 56))(v18, 0LL, 1LL, v6);
  (*(void (**)(char *, char *, uint64_t))(v13 + 32))(v16, v18, v12);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v7 + 48))(v16, 1LL, v6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v13 + 8))(v16, v12);
    uint64_t v19 = 0LL;
  }

  else
  {
    memcpy((char *)&v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), v16, v8);
    uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 48))(v6, v5);
  }

  return specialized static Hasher._hash(seed:_:)(v22, v19);
}

void *protocol witness for Strideable.distance(to:) in conformance AutoreleasingUnsafeMutablePointer<A>@<X0>( void *result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 72LL);
  if (!v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  uint64_t v5 = *result - *v3;
  if (v4 == -1 && v5 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  *a3 = v5 / v4;
  return result;
}

uint64_t _Pointer.distance(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 48);
  uint64_t v6 = v5(a2, a3);
  uint64_t v7 = v5(a2, a3);
  uint64_t v8 = *(void *)(*(void *)(swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for _Pointer,  associated type descriptor for _Pointer.Pointee)
                             - 8)
                 + 72LL);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  if (v6 - v7 == 0x8000000000000000LL && v8 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  return (v6 - v7) / v8;
}

void *protocol witness for Strideable.advanced(by:) in conformance AutoreleasingUnsafeMutablePointer<A>@<X0>( void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = *v3 + *(void *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 72LL) * *result;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0LL;
}

uint64_t static Strideable._step(after:from:by:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, a7, "index value ", 0LL);
  uint64_t v15 = *(TupleTypeMetadata2 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v18 = (char *)&v20 - v17;
  *(void *)uint64_t v18 = a2;
  v18[8] = a3 & 1;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL))( (char *)&v20 + *(int *)(v16 + 48) - v17,  a4,  a7);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a8 + 48))(a6, a7, a8);
  (*(void (**)(char *, unint64_t *))(v15 + 8))(v18, TupleTypeMetadata2);
  return 0LL;
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable( &protocol conformance descriptor for AutoreleasingUnsafeMutablePointer<A>,  a1,  a3);
  return _Pointer.debugDescription.getter(a1, WitnessTable);
}

uint64_t _Pointer.debugDescription.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(*(uint64_t (**)(void))(a2 + 48))();
  return _rawPointerToString(_:)(v2)._countAndFlagsBits;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance AutoreleasingUnsafeMutablePointer<A>@<X0>( swift *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return _Pointer.customMirror.getter(a1, a3);
}

uint64_t specialized _Pointer.customMirror.getter@<X0>(uint64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  uint64_t v7 = swift_allocObject(v6, 0x50uLL, 7uLL);
  *((_OWORD *)v7 + 1) = xmmword_1817FFC60;
  strcpy((char *)v7 + 32, "pointerValue");
  *((_BYTE *)v7 + 45) = 0;
  *((_WORD *)v7 + 23) = -5120;
  v7[9] = &type metadata for UInt64;
  v7[6] = a1;
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)( a1,  (uint64_t)v7,  8,  0LL,  0LL,  a2,  a3);
}

uint64_t _Pointer.customMirror.getter@<X0>(swift *a1@<X0>, uint64_t a2@<X8>)
{
  size_t v5 = *(void *)(*((void *)a1 - 1) + 64LL);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(v7 + 48))(v6);
  memcpy((char *)v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL), v2, v5);
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  uint64_t v10 = swift_allocObject(v9, 0x50uLL, 7uLL);
  *((_OWORD *)v10 + 1) = xmmword_1817FFC60;
  strcpy((char *)v10 + 32, "pointerValue");
  *((_BYTE *)v10 + 45) = 0;
  *((_WORD *)v10 + 23) = -5120;
  v10[9] = &type metadata for UInt64;
  v10[6] = v8;
  char v13 = 8;
  v12[1] = 0LL;
  v12[2] = 0LL;
  return Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)( (uint64_t)v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v10,  a1,  a2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance AutoreleasingUnsafeMutablePointer<A>( void *a1, void *a2)
{
  return *a1 == *a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance AutoreleasingUnsafeMutablePointer<A>( void *a1, void *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return static Comparable.<= infix(_:_:)(a1, a2, a3, a4);
}

uint64_t specialized static Comparable.<= infix(_:_:)( unint64_t a1, uint64_t a2, char a3, unint64_t a4, uint64_t a5, char a6)
{
  if (a4 >> 14 != a1 >> 14) {
    return a4 >> 14 >= a1 >> 14;
  }
  if ((a6 & 1) == 0)
  {
    if ((a3 & 1) == 0) {
      return a5 >= a2;
    }
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

  if ((a3 & 1) == 0) {
    goto LABEL_8;
  }
  return 1LL;
}

uint64_t specialized static Comparable.<= infix(_:_:)( unint64_t a1, unint64_t a2, char a3, unint64_t a4, unint64_t a5, char a6)
{
  BOOL v6 = a4 >> 14 >= a1 >> 14;
  if (a4 >> 14 == a1 >> 14)
  {
    if ((a6 & 1) != 0)
    {
      if ((a3 & 1) != 0) {
        return 1LL;
      }
    }

    else if ((a3 & 1) == 0)
    {
      BOOL v6 = a5 >> 14 >= a2 >> 14;
      goto LABEL_5;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

LABEL_5:
  int v7 = !v6;
  return v7 ^ 1u;
}

    v26 = v12;
    v23 = type metadata accessor for Array(v13, v9, v14, v15);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v23, v24);
    char v13 = (const char *)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v26, v23, WitnessTable);
    goto LABEL_6;
  }

  (*(void (**)(uint64_t, uint64_t))(*(void *)(v9 - 8) + 8LL))(a1, v9);
  _swift_isClassOrObjCExistentialType(v9, (uint64_t *)v9);
  uint64_t v12 = &_swiftEmptyArrayStorage;
  char v13 = (const char *)_ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, (uint64_t *)v9);
  if (!v13) {
    goto LABEL_5;
  }
  uint64_t v16 = v13;
  uint64_t v17 = &_swiftEmptyArrayStorage;
LABEL_7:
  swift_bridgeObjectRelease((uint64_t)v17);
  *a5 = v16;
}

  while (1)
  {
    uint64_t v9 = v5[1]._rawBits;
    uint64_t v10 = *(void *)(v5->_rawBits + 16);
    if (v9 == v10) {
      break;
    }
    if (v9 >= v10) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }
    uint64_t v11 = v9 + 1;
    uint64_t v14 = (uint64_t *)(v5->_rawBits + 16 * v9 + 32);
    uint64_t v12 = *v14;
    char v13 = v14[1];
    v5[1]._rawBits = v11;
    uint64_t v15 = (void (*)(unint64_t *__return_ptr, void *))v5[2]._rawBits;
    v36[0] = v12;
    v36[1] = v13;
    swift_bridgeObjectRetain(v13, a2, a3, a4);
    v15(&v37, v36);
    swift_bridgeObjectRelease(v13);
    uint64_t v16 = v37;
    rawBits = v38;
    swift_bridgeObjectRelease(v5[5]._rawBits);
    v5[4]._rawBits = v16;
    v5[5]._rawBits = rawBits;
    v5[6]._rawBits = 15LL;
    if (rawBits) {
      goto LABEL_2;
    }
  }

  uint64_t v17 = 0;
  uint64_t v18 = 1;
  return v17 | (v18 << 8);
}

        uint64_t v8 = (v8 + 1) & a4;
        if (((*(void *)(a3 + ((v8 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v8) & 1) == 0) {
          break;
        }
      }
    }

    uint64_t v15 = (uint64_t *)(a3 + 8 * ((unint64_t)offset >> 6));
    uint64_t v16 = *v15;
    uint64_t v17 = (-1LL << offset) - 1;
  }

  else
  {
    uint64_t v15 = (uint64_t *)(a3 + 8 * ((unint64_t)before.offset >> 6));
    uint64_t v17 = *v15;
    uint64_t v16 = (-1LL << SLOBYTE(before.offset)) - 1;
  }

  *uint64_t v15 = v17 & v16;
  return before.offset;
}

        BOOL v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    v24 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    v25 = *v24;
    v26 = (-1LL << offset) - 1;
  }

  else
  {
    v24 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    v26 = *v24;
    v25 = (-1LL << SLOBYTE(before.offset)) - 1;
  }

  *v24 = v26 & v25;
  v27 = *(void *)(a2 + 16);
  v28 = __OFSUB__(v27, 1LL);
  v29 = v27 - 1;
  if (v28)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v29;
    ++*(_DWORD *)(a2 + 36);
  }

  return before.offset;
}

        BOOL v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    v25 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    v26 = *v25;
    v27 = (-1LL << offset) - 1;
  }

  else
  {
    v25 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    v27 = *v25;
    v26 = (-1LL << SLOBYTE(before.offset)) - 1;
  }

  *v25 = v27 & v26;
  v28 = *(void *)(a2 + 16);
  v29 = __OFSUB__(v28, 1LL);
  v30 = v28 - 1;
  if (v29)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v30;
    ++*(_DWORD *)(a2 + 36);
  }

  return before.offset;
}

        BOOL v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    v23 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    v24 = *v23;
    v25 = (-1LL << offset) - 1;
  }

  else
  {
    v23 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    v25 = *v23;
    v24 = (-1LL << SLOBYTE(before.offset)) - 1;
  }

  *v23 = v25 & v24;
  v26 = *(void *)(a2 + 16);
  v27 = __OFSUB__(v26, 1LL);
  v28 = v26 - 1;
  if (v27)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v28;
    ++*(_DWORD *)(a2 + 36);
  }

  return before.offset;
}

        uint64_t v9 = (v9 + 1) & v10;
      }

      while (((*(void *)(v7 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) != 0);
    }

    *(void *)(v7 + (((unint64_t)v5.offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << SLOBYTE(v5.offset)) - 1;
    id result = swift_release(v6);
  }

  else
  {
    *(void *)(v7 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << result) - 1;
  }

  v24 = *(void *)(v6 + 16);
  v25 = __OFSUB__(v24, 1LL);
  v26 = v24 - 1;
  if (v25)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v6 + 16) = v26;
    ++*(_DWORD *)(v6 + 36);
  }

  return result;
}

        uint64_t v9 = (v9 + 1) & v10;
      }

      while (((*(void *)(v7 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) != 0);
    }

    *(void *)(v7 + (((unint64_t)v5.offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << SLOBYTE(v5.offset)) - 1;
    id result = swift_release(v6);
  }

  else
  {
    *(void *)(v7 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << result) - 1;
  }

  v24 = *(void *)(v6 + 16);
  v25 = __OFSUB__(v24, 1LL);
  v26 = v24 - 1;
  if (v25)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v6 + 16) = v26;
    ++*(_DWORD *)(v6 + 36);
  }

  return result;
}

  LOBYTE(v59) = v3;
  return v4 | ((unint64_t)v3 << 48);
}

      v4 += 4;
    }

    BOOL *v0 = (uint64_t)v1;
  }

    (*(void (**)(char *, uint64_t))(v32 + 8))(v33, v3);
    (*(void (**)(char *, uint64_t))(v30 + 8))(v31, v25);
    return 0LL;
  }

  v35 = *(void *)(v14 + 8);
  v36 = v47;
  v37 = v51;
  v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v35 + 16))(v47, v51, v3, v35);
  v30 = v49;
  v31 = v43;
  v39 = v37;
  v25 = v50;
  (*(void (**)(char *, uint64_t, uint64_t))(v49 + 16))(v43, v39, v50);
  v32 = v48;
  v33 = v45;
  (*(void (**)(char *, uint64_t, uint64_t))(v48 + 16))(v45, v36, v3);
  if ((v38 & 1) != 0) {
    goto LABEL_5;
  }
  v34 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v35 + 24))(&v31[*(int *)(v25 + 36)], v33, v3, v35);
LABEL_7:
  v41 = v34;
  (*(void (**)(char *, uint64_t))(v32 + 8))(v33, v3);
  (*(void (**)(char *, uint64_t))(v30 + 8))(v31, v25);
  if ((v41 & 1) != 0) {
    return 0LL;
  }
  else {
    return 2LL;
  }
}

    (*(void (**)(char *, uint64_t))(v33 + 8))(v34, v3);
    (*(void (**)(char *, uint64_t))(v31 + 8))(v32, v25);
    return 0LL;
  }

  v27 = *(void *)(v14 + 8);
  v28 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v27 + 16);
  v36 = v47;
  v37 = v51;
  v38 = v28(v47, v51, v3, v27);
  v31 = v49;
  v32 = v43;
  v39 = v37;
  v25 = v50;
  (*(void (**)(char *, uint64_t, uint64_t))(v49 + 16))(v43, v39, v50);
  v33 = v48;
  v34 = v45;
  (*(void (**)(char *, uint64_t, uint64_t))(v48 + 16))(v45, v36, v3);
  if ((v38 & 1) != 0) {
    goto LABEL_5;
  }
  v35 = &v32[*(int *)(v25 + 36)];
LABEL_7:
  v41 = v28((uint64_t)v35, (uint64_t)v34, v3, v27);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v34, v3);
  (*(void (**)(char *, uint64_t))(v31 + 8))(v32, v25);
  if ((v41 & 1) != 0) {
    return 0LL;
  }
  else {
    return 2LL;
  }
}

  uint64_t v14 = 0LL;
  size_t v5 = swift::Demangle::__runtime::Demangler::demangleSymbol((uint64_t)a1, a2, a3, v13);
  BOOL v6 = v14;
  if (v14 == v13)
  {
    int v7 = 4LL;
    BOOL v6 = v13;
  }

  else
  {
    if (!v14) {
      goto LABEL_10;
    }
    int v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_10:
  if (!v5) {
    return 0LL;
  }
  id result = swift::Demangle::__runtime::Node::findByKind(v5, 76LL, 2);
  if (result)
  {
    id result = swift::Demangle::__runtime::Node::findByKind(result, 232LL, 2);
    if (result)
    {
      uint64_t v9 = result;
      uint64_t v10 = swift::Demangle::__runtime::Node::findByKind(result, 44LL, 1);
      if (v10)
      {
        uint64_t v11 = swift::Demangle::__runtime::Node::findByKind(v10, 232LL, 1);
        return swift::Demangle::__runtime::Node::findByKind(v11, 82LL, 1);
      }

      uint64_t v12 = *(unsigned __int8 *)(v9 + 18);
      if (v12 == 5 && *(_DWORD *)(v9 + 8))
      {
        uint64_t v9 = *(void *)v9;
        return *(void *)v9;
      }

      return 0LL;
    }
  }

  return result;
}

  CanonicalTypeMetadata = swift::TargetProtocolConformanceDescriptor<swift::InProcess>::getCanonicalTypeMetadata(a2);
  if (CanonicalTypeMetadata)
  {
    int v7 = 0;
    if (!v2) {
      return 0LL;
    }
    goto LABEL_10;
  }

  if (v2) {
    goto LABEL_14;
  }
  return CanonicalTypeMetadata;
}

          uint64_t v11 = *(swift::Demangle::__runtime::Node **)a2;
LABEL_6:
          ++v8;
          goto LABEL_7;
        }

        v496 = (swift::Demangle::__runtime::Node **)a2;
        if (v120 < 2) {
          goto LABEL_1389;
        }
        if (v119 == 5)
        {
          if (!*((_DWORD *)a2 + 2))
          {
            v281 = 0LL;
            goto LABEL_1834;
          }

          v496 = *(swift::Demangle::__runtime::Node ***)a2;
LABEL_1389:
          v281 = *v496;
        }

        else
        {
          v281 = 0LL;
        }

        if (v119 == 2)
        {
LABEL_1733:
          v593 = (swift::Demangle::__runtime::Node *)*((void *)a2 + 1);
          goto LABEL_1835;
        }

        if (v119 == 5 && *((_DWORD *)a2 + 2) >= 2u)
        {
          a2 = *(swift::Demangle::__runtime::Node **)a2;
          goto LABEL_1733;
        }

  uint64_t v12 = (void *)*((void *)&v66 + 1);
  *((void *)&v66 + 1) = 0LL;
  if (v12) {
    operator delete(v12);
  }
  v79[0] = off_189B8E4D8;
  id result = swift::Demangle::__runtime::NodeFactory::freeSlabs(v80);
  if (v82) {
    *(_BYTE *)(v82 + 48) = 0;
  }
  return result;
}

uint64_t specialized static Comparable.<= infix(_:_:)( uint64_t a1, unint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6)
{
  if (a4 != a1) {
    return a4 >= a1;
  }
  if ((a6 & 1) == 0)
  {
    if ((a3 & 1) == 0) {
      return a5 >> 14 >= a2 >> 14;
    }
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

  if ((a3 & 1) == 0) {
    goto LABEL_8;
  }
  return 1LL;
}

BOOL static Comparable.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a2, a1) & 1) == 0;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return static Comparable.>= infix(_:_:)(a1, a2, a3, a4);
}

BOOL static Comparable.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(void))(a4 + 16))() & 1) == 0;
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return static Comparable.> infix(_:_:)(a1, a2, a3, a4) & 1;
}

uint64_t specialized static Comparable.> infix(_:_:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t ObjectType = swift_getObjectType(a3);
  uint64_t v9 = (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 8))(ObjectType, a4);
  unint64_t v10 = swift_getObjectType(a1);
  if (v9 != (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(v10, a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Base index types differ",  23LL,  2,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x755uLL,  0);
  }
  unint64_t v11 = swift_getObjectType(a3);
  return (*(uint64_t (**)(unint64_t, uint64_t, unint64_t, uint64_t))(a4 + 32))(a1, a2, v11, a4) & 1;
}

uint64_t static Comparable.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a2, a1) & 1;
}

uint64_t _Pointer.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 48))(a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))(v5, a2, a3);
}

{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t static MemoryLayout.size(ofValue:)(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a2 - 8) + 64LL);
}

uint64_t static MemoryLayout.size.getter(uint64_t a1)
{
  return *(void *)(*(void *)(a1 - 8) + 64LL);
}

const char *_getObjCTypeEncoding<A>(_:)()
{
  return "@";
}

uint64_t (*_BridgeStorage.rawValue.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _objectPointerLowSpareBitShift.getter()
{
  return 0LL;
}

uint64_t static FixedWidthInteger.<< infix<A>(_:_:)@<X0>( char *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v8 = (void (*)(char *, uint64_t))a3;
  v215 = a1;
  v195 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v195,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v193 = (char *)&v190 - v11;
  v210 = *(char **)(a4 + 8);
  v207 = *(const char **)(*((void *)v210 + 3) + 16LL);
  unint64_t v205 = swift_getAssociatedTypeWitness( 0LL,  v207,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](v205);
  v204 = (char *)&v190 - v13;
  v212 = (char *)*((void *)v8 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v190 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v190 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  v192 = (char *)&v190 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v24 = (char *)&v190 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  v199 = (char *)&v190 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  v198 = (char *)&v190 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  v191 = (char *)&v190 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  v196 = (char *)&v190 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  v197 = (char *)&v190 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  v211 = (char *)&v190 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  v214 = (char *)&v190 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  v208 = (char *)&v190 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  v213 = (char *)&v190 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  v209 = (char *)&v190 - v44;
  MEMORY[0x1895F8858](v43);
  uint64_t v216 = v45;
  v46 = *(void (**)(void))(v45 + 16);
  v206 = (char *)&v190 - v47;
  v46();
  v217 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 56);
  uint64_t v218 = a4;
  uint64_t v48 = v217(a2, a4);
  uint64_t v49 = -v48;
  if (__OFSUB__(0LL, v48))
  {
    __break(1u);
    goto LABEL_81;
  }

  v50 = *(uint64_t (**)(void *, uint64_t))(a5 + 64);
  char v51 = v50(v8, a5);
  v202 = v50;
  uint64_t v203 = a6;
  if ((v51 & 1) != 0)
  {
    uint64_t v16 = v215;
    v201 = *(uint64_t (**)(void *, uint64_t))(a5 + 128);
    uint64_t v52 = v201(v8, a5);
    uint64_t v55 = v216;
    if (v52 < 64)
    {
      uint64_t v19 = v211;
      v56 = v212;
      (*((void (**)(char *, char *, void (*)(char *, uint64_t)))v212 + 2))(v211, v16, v8);
      goto LABEL_14;
    }

    v220[0] = v49;
    v64 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
    unint64_t v65 = lazy protocol witness table accessor for type Int and conformance Int(v52, v53, v54);
    uint64_t v19 = v211;
    v64(v220, &type metadata for Int, v65, v8, a5);
    char v63 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                          + 16LL))( v16,  v19,  v8);
LABEL_9:
    char v66 = v63;
    v67 = (void (*)(char *, void *))*((void *)v212 + 1);
    v67(v19, v8);
    if ((v66 & 1) == 0) {
      goto LABEL_15;
    }
    goto LABEL_47;
  }

  char v57 = v50(v8, a5);
  v201 = *(uint64_t (**)(void *, uint64_t))(a5 + 128);
  uint64_t v58 = v201(v8, a5);
  uint64_t v55 = v216;
  if ((v57 & 1) != 0)
  {
    if (v58 > 64)
    {
      v220[0] = v49;
      v61 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
      unint64_t v62 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
      uint64_t v19 = v211;
      v61(v220, &type metadata for Int, v62, v8, a5);
      uint64_t v16 = v215;
      char v63 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                            + 16LL))( v215,  v19,  v8);
      goto LABEL_9;
    }

    v190 = v24;
    v82 = v195;
    unint64_t v83 = AssociatedTypeWitness;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v195,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v85 = v193;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v83,  AssociatedConformanceWitness);
    v86 = v211;
    (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v82 + 3))(v85, v8, v82);
    uint64_t v16 = v215;
    LOBYTE(v83) = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                                  + 16LL))( v215,  v86,  v8);
    v24 = v212;
    v87 = v86;
    v67 = (void (*)(char *, void *))*((void *)v212 + 1);
    v67(v87, v8);
    (*((void (**)(char *, char *, void (*)(char *, uint64_t)))v24 + 2))(v19, v16, v8);
    if ((v83 & 1) != 0)
    {
      v67(v19, v8);
    }

    else
    {
      uint64_t v135 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
      v67(v19, v8);
      uint64_t v19 = v211;
      v24 = v190;
      if (v135 >= v49) {
        goto LABEL_15;
      }
    }
  }

  else
  {
    if (v58 < 64)
    {
      uint64_t v19 = v211;
      v56 = v212;
      uint64_t v16 = v215;
      (*((void (**)(char *, char *, void (*)(char *, uint64_t)))v212 + 2))(v211, v215, v8);
LABEL_14:
      uint64_t v68 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
      v67 = (void (*)(char *, void *))*((void *)v56 + 1);
      v67(v19, v8);
      if (v68 >= v49) {
        goto LABEL_15;
      }
      goto LABEL_47;
    }

    uint64_t v88 = (uint64_t)v212;
    uint64_t v89 = (*((uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))v212 + 2))(v16, v215, v8);
    uint64_t v19 = v211;
    if (v49 <= 0) {
      goto LABEL_50;
    }
    v220[0] = v49;
    uint64_t v92 = v88;
    v93 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
    unint64_t v94 = lazy protocol witness table accessor for type Int and conformance Int(v89, v90, v91);
    v93(v220, &type metadata for Int, v94, v8, a5);
    char v95 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                          + 16LL))( v16,  v19,  v8);
    v67 = *(void (**)(char *, void *))(v92 + 8);
    v67(v19, v8);
    v67(v16, v8);
    uint64_t v16 = v215;
    if ((v95 & 1) == 0) {
      goto LABEL_15;
    }
  }

LABEL_47:
  uint64_t v88 = a2;
  uint64_t v136 = v217(a2, v218);
  uint64_t v49 = -v136;
  if (__OFSUB__(0LL, v136))
  {
    __break(1u);
LABEL_50:
    v67 = *(void (**)(char *, void *))(v88 + 8);
    v67(v16, v8);
LABEL_15:
    v200 = v67;
    uint64_t v69 = v217(a2, v218);
    char v70 = v202(v8, a5);
    v71 = v201;
    uint64_t v72 = v201(v8, a5);
    v190 = v24;
    if ((v70 & 1) != 0)
    {
      if (v72 > 64)
      {
        v220[0] = v69;
        v75 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
        unint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
        v75(v220, &type metadata for Int, v76, v8, a5);
        v77 = v215;
        char v78 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                              + 16LL))( v19,  v215,  v8);
        v79 = v200;
        v200(v19, v8);
        if ((v78 & 1) == 0)
        {
          v80 = (uint64_t (*)(char *, char *, void (*)(char *, uint64_t)))*((void *)v212 + 2);
          goto LABEL_29;
        }

        goto LABEL_52;
      }
    }

    else if (v72 > 63)
    {
      v96 = v192;
      v80 = (uint64_t (*)(char *, char *, void (*)(char *, uint64_t)))*((void *)v212 + 2);
      uint64_t v97 = v80(v192, v215, v8);
      if (v69 < 0)
      {
        v200(v96, v8);
        goto LABEL_52;
      }

      v220[0] = v69;
      v100 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
      unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
      v100(v220, &type metadata for Int, v101, v8, a5);
      char v102 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                             + 16LL))( v19,  v96,  v8);
      v79 = v200;
      v200(v19, v8);
      v79(v96, v8);
      v77 = v215;
      if ((v102 & 1) != 0)
      {
LABEL_52:
        uint64_t v49 = v217(a2, v218);
LABEL_57:
        uint64_t v55 = v216;
        goto LABEL_58;
      }

        v201[0] = v68;
        char v159 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v53 + 88);
        uint64_t v160 = lazy protocol witness table accessor for type Int and conformance Int(v78, v79, v80);
        v159(v201, &type metadata for Int, v160, v55, v53);
        uint64_t v161 = v11;
        uint64_t v162 = v187;
        v163 = v183;
        (*(void (**)(char *, uint64_t, uint64_t))(v187 + 48))(v61, v161, v187);
        v197 = (uint64_t)v76;
        v76(v61, v55);
        unint64_t v164 = v176;
        v165 = v182;
        (*(void (**)(char *, char *, uint64_t))(v176 + 16))(v182, v163, v161);
        v167 = v184;
        char v166 = v185;
        unint64_t v168 = v81;
        char v169 = v199;
        (*(void (**)(char *, uint64_t, uint64_t))(v185 + 16))(v184, v198, v199);
        if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v162 + 8) + 32LL))(v165, v167, v161) & 1) == 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Advancing past start index",  26LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0xFBuLL,  0);
        }
        (*(void (**)(char *, uint64_t))(v166 + 8))(v167, v169);
        v170 = *(void (**)(char *, uint64_t))(v164 + 8);
        v170(v165, v161);
        ((void (*)(char *, uint64_t))v197)(v200, v55);
        v170(v168, v161);
        uint64_t v171 = v196;
        v174(v196, v163, v161);
        return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v164 + 56))(v171, 0LL, 1LL, v161);
      }

      uint64_t v68 = v197;
      v201[0] = v197;
      uint64_t v69 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v53 + 96);
      char v70 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
      v61 = v194;
      v69(v201, &type metadata for Int, v70, v55, v53);
      v71 = v67;
    }

    uint64_t v74 = swift_getAssociatedConformanceWitness( v71,  v11,  v55,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
    v75 = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v74 + 16))(v57, v61, v55, v74);
    unint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v193 + 8);
    v77 = v61;
LABEL_14:
    char v78 = v76(v77, v55);
    uint64_t v81 = v181;
    if ((v75 & 1) != 0) {
      goto LABEL_26;
    }
    goto LABEL_47;
  }

  v46 = v197;
  if (v197)
  {
    if (v197 < 0)
    {
      uint64_t v47 = v199;
      (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v42, v198 + *(int *)(v199 + 36), v11);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v31 + 56))(v42, 0LL, 1LL, v11);
      ClosedRange<>.index(_:offsetBy:)(v42, v46 + 1, v47, a4, v195);
      return (*(uint64_t (**)(char *, uint64_t))(v39 + 8))(v42, v38);
    }

    v172 = 264LL;
LABEL_55:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Advancing past end index",  24LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  v172,  0);
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v45)(v196, a1, v38);
}

                __break(1u);
                goto LABEL_48;
              }
            }

            __break(1u);
            goto LABEL_47;
          }

          __break(1u);
LABEL_30:
          uint64_t v33 = 0LL;
          goto LABEL_31;
        }
      }

      __break(1u);
      goto LABEL_56;
    }
  }

  swift_retain(a1, v18, v19, v20);
  uint64_t v21 = a1;
LABEL_44:
  v49[0] = v21;
  _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)v49, (uint64_t)a1, (uint64_t)a2);
  return swift_dynamicCastClassUnconditional((int64_t)v21, (const char *)a3, 0LL, 0LL, 0LL);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }
    }

    else
    {
      uint64_t v14 = _StringObject.sharedUTF8.getter(a1._countAndFlagsBits, object);
      uint64_t v15 = v31;
      uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
      if ((v3 & 0x2000000000000000LL) == 0) {
        goto LABEL_20;
      }
    }

    __s2 = v4;
    uint64_t v40 = v3 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v18 = (char *)&__s2 + v13;
    if (v15 >= v11) {
      uint64_t v20 = v11;
    }
    else {
      uint64_t v20 = v15;
    }
    goto LABEL_39;
  }

  __s2 = a1._countAndFlagsBits;
  uint64_t v40 = object & 0xFFFFFFFFFFFFFFLL;
  if ((v2 & 0x2000000000000000LL) == 0)
  {
    if ((v1 & 0x1000000000000000LL) != 0)
    {
      uint64_t v22 = (v2 & 0xFFFFFFFFFFFFFFFLL) + 32;
      uint64_t v23 = v4 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v35 = v1 & 0xFFFFFFFFFFFFLL;
      uint64_t v36 = _StringObject.sharedUTF8.getter(v1, v2);
      uint64_t v23 = v37;
      if (v37 < v35) {
        goto LABEL_47;
      }
      uint64_t v22 = (uint64_t)v36;
      uint64_t v9 = v35;
    }

    v24 = (const void *)specialized UnsafeBufferPointer.init(rebasing:)(v13, v9, v22, v23);
    uint64_t v26 = v25;
    if (v10 >= v25) {
      uint64_t v27 = v25;
    }
    else {
      uint64_t v27 = v10;
    }
    uint64_t v28 = _swift_stdlib_memcmp(v24, &__s2, v27);
    uint64_t v29 = v28;
    uint64_t v30 = v26 - v10;
LABEL_40:
    if (!v28) {
      uint64_t v29 = v30;
    }
    if (v29) {
      return 0;
    }
    return _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v13 << 16));
  }

  v38[0] = v1;
  v38[1] = v2 & 0xFFFFFFFFFFFFFFLL;
  return 0;
}

    if ((v6 & ~v5 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v45 = _StringGuts.nativeUnusedCapacity.getter(v6, v5);
      if ((v46 & 1) != 0) {
        goto LABEL_208;
      }
      if ((uint64_t)v9 < 16 && ((v5 & 0x2000000000000000LL) != 0 || v45 < (uint64_t)v10))
      {
LABEL_59:
        swift_bridgeObjectRelease(v39);
        char v51 = v179;
        swift_bridgeObjectRetain(v5, v52, v53, v54);
        uint64_t v55 = _StringGuts._convertedToSmall()(v51, v5);
        char v57 = v56;
        swift_bridgeObjectRelease(v5);
        v58._rawBits = v8 & 0xFFFFFFFFFFFF0000LL | 1;
        v59._rawBits = v12 & 0xFFFFFFFFFFFF0000LL | 1;
        v60._rawBits = _StringGuts.validateScalarRange(_:)(v58, v59, v41, v39);
        if (v60._rawBits < 0x10000) {
          v60._rawBits |= 3;
        }
        unint64_t v62 = specialized String.init(_:)(v60, v61, v41, v39);
        v64 = v63;
        swift_bridgeObjectRelease(v39);
        unint64_t v65 = _StringGuts._convertedToSmall()(v62, v64);
        v67 = v66;
        swift_bridgeObjectRelease(v64);
        uint64_t v68 = specialized _SmallString.init(_:appending:)(v55, v57, v65, v67);
        if ((v70 & 1) != 0) {
          goto LABEL_207;
        }
        v71 = v68;
        uint64_t v72 = v69;
        swift_bridgeObjectRelease(v5);
        uint64_t v179 = v71;
        BOOL v180 = v72;
        goto LABEL_67;
      }
    }

    else if ((uint64_t)v9 <= 15)
    {
      goto LABEL_59;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v9, v10);
    swift_bridgeObjectRelease(v39);
    if ((v39 & 0x1000000000000000LL) != 0)
    {
      _StringGuts._foreignAppendInPlace(_:)(v41, v39, v170, v40);
LABEL_64:
      swift_bridgeObjectRelease(v39);
      goto LABEL_67;
    }

    if ((v39 & 0x2000000000000000LL) == 0)
    {
      if ((v41 & 0x1000000000000000LL) != 0)
      {
        uint64_t v47 = (id)((v39 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v48 = v41 & 0xFFFFFFFFFFFFLL;
        if ((v41 & 0xFFFFFFFFFFFFLL) < v40) {
          goto LABEL_181;
        }
      }

      else
      {
        uint64_t v47 = _StringObject.sharedUTF8.getter(v41, v39);
        uint64_t v48 = v162;
        if (v162 < v40) {
          goto LABEL_181;
        }
      }

      uint64_t v49 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v170, v40, (uint64_t)v47, v48);
      _StringGuts.appendInPlace(_:isASCII:)(v49, v50, v41 < 0);
      goto LABEL_64;
    }

    swift_bridgeObjectRelease(v39);
    v75 = HIBYTE(v39) & 0xF;
    v177 = v41;
    v178 = v39 & 0xFFFFFFFFFFFFFFLL;
    if (v75 < v40) {
      goto LABEL_181;
    }
    unint64_t v76 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v170, v40, (uint64_t)&v177, v75);
    _StringGuts.appendInPlace(_:isASCII:)(v76, v77, (v39 & 0x4000000000000000LL) != 0);
LABEL_67:
    unint64_t v10 = v179;
    uint64_t v12 = v180;
    if ((v180 & 0x2000000000000000LL) != 0) {
      uint64_t v40 = HIBYTE(v180) & 0xF;
    }
    else {
      uint64_t v40 = v179 & 0xFFFFFFFFFFFFLL;
    }
    if (&full type metadata for EmptyCollection<Character> == &full type metadata for String) {
      goto LABEL_204;
    }
    if (&full type metadata for EmptyCollection<Character> == &full type metadata for Substring) {
      goto LABEL_205;
    }
    if (&full type metadata for EmptyCollection<Character> == &full type metadata for [Character]) {
      goto LABEL_206;
    }
    swift_bridgeObjectRetain_n(v180, 3LL, v73, v74);
    v78._rawBits = startingAt;
    BOOL v6 = specialized Collection.subscript.getter(v78, v173, v174);
    uint64_t v5 = v79;
    uint64_t v8 = v43;
    uint64_t v9 = v79 >> 16;
    unint64_t v174 = v6 >> 16;
    startingAt = v42;
    if ((v43 & 0x1000000000000000LL) == 0)
    {
      v4._rawBits = v9 - (v6 >> 16);
      swift_bridgeObjectRetain_n(v43, 2LL, v42, (char *)v43);
      v80 = v12;
      goto LABEL_75;
    }

    uint64_t v39 = v21 - v31;
    if (v21 >= v67)
    {
      uint64_t v11 = 0LL;
      if (v31 <= 0) {
        goto LABEL_60;
      }
      goto LABEL_58;
    }

    if (v39 >= a4)
    {
      uint64_t v11 = 1LL;
      if (v31 <= 0) {
        goto LABEL_60;
      }
      goto LABEL_58;
    }

    v79 = v29;
    v80 = v21 - v31;
    char v78 = -v31;
    char v70 = v61 - v31;
    v71 = v21;
    uint64_t v40 = v21;
    do
    {
      if (v21 < 0
        || (uint64_t v41 = v31,
            uint64_t v42 = v76,
            uint64_t v43 = *(void *)(v76 + 72),
            uint64_t v44 = *(void (**)(char *, uint64_t, unint64_t))(v76 + 16),
            v44(v15, v77 + v43 * v40, AssociatedTypeWitness),
            v80 < 0))
      {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
      }

      uint64_t v45 = v22;
      v46 = v15;
      uint64_t v47 = AssociatedTypeWitness;
      uint64_t v48 = v73;
      v44(v73, v74 + v43 * (v78 + v40), v47);
      uint64_t v49 = v75(v46, v48);
      v50 = *(void (**)(char *, unint64_t))(v42 + 8);
      char v51 = v48;
      unint64_t AssociatedTypeWitness = v47;
      uint64_t v15 = v46;
      v50(v51, AssociatedTypeWitness);
      v50(v46, AssociatedTypeWitness);
      if ((v49 & 1) == 0)
      {
        uint64_t v31 = v41;
        uint64_t v39 = v40 - v41;
        uint64_t v11 = 1LL;
        uint64_t v21 = v40;
        a4 = v60;
        uint64_t v22 = v45;
        uint64_t v29 = v79;
        if (v41 >= 1) {
          goto LABEL_58;
        }
LABEL_60:
        a2 = -v31;
        if (!__OFSUB__(0LL, v31))
        {
          uint64_t v20 = v39;
          goto LABEL_62;
        }

        __break(1u);
        goto LABEL_91;
      }

      uint64_t v22 = v45;
      uint64_t v31 = v41;
      if (v72 == v40)
      {
        uint64_t v11 = 0LL;
        uint64_t v39 = v40 - v41 + 1;
        uint64_t v21 = v67;
        a4 = v60;
        uint64_t v29 = v79;
        if (v41 > 0) {
          goto LABEL_58;
        }
        goto LABEL_60;
      }

      ++v40;
      uint64_t v21 = v71;
      uint64_t v29 = v79;
    }

    while (v70 + v40);
    uint64_t v11 = 1LL;
    a4 = v60;
    uint64_t v39 = v60;
    uint64_t v21 = v40;
    if (v41 <= 0) {
      goto LABEL_60;
    }
LABEL_58:
    uint64_t v20 = v39;
    a2 = v31 - 1;
LABEL_62:
    id result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(v29);
    if ((result & 1) != 0)
    {
      uint64_t v30 = v63;
      if ((a2 & 0x8000000000000000LL) == 0) {
        goto LABEL_64;
      }
LABEL_95:
      uint64_t v55 = 688LL;
LABEL_86:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  v55,  0);
    }

    id result = specialized _ArrayBuffer._consumeAndCreateNew()(v29);
    uint64_t v29 = (uint64_t)result;
    uint64_t v30 = v63;
    if ((a2 & 0x8000000000000000LL) != 0) {
      goto LABEL_95;
    }
LABEL_64:
    if (a2 >= *(void *)(v29 + 16)) {
      goto LABEL_95;
    }
    *(void *)(v29 + 8 * a2 + 32) = v21;
    if (v20 < a4) {
      uint64_t v52 = 1;
    }
    else {
      uint64_t v52 = v11;
    }
    uint64_t v31 = v69;
    a2 = v66;
    if ((v52 & 1) == 0)
    {
      swift_bridgeObjectRelease(v29);
      uint64_t v29 = a2;
      goto LABEL_87;
    }
  }

  if (!((v31 != v22) | v64 & 1) && BYTE4(v64) & 1 | (v65 != 0x8000000000000000LL))
  {
    if (v22)
    {
      LODWORD(v64) = 1;
      uint64_t v69 = v22;
      uint64_t v33 = v62;
      if (v22 > 1) {
        goto LABEL_33;
      }
      goto LABEL_34;
    }

    uint64_t v32 = 0LL;
    uint64_t v69 = 0LL;
    LODWORD(v64) = 1;
LABEL_28:
    if ((v32 & 0x8000000000000000LL) != 0 || v32 >= *(void *)(a2 + 16)) {
      goto LABEL_85;
    }
    uint64_t v21 = *(void *)(v68 + 8 * v32);
    goto LABEL_47;
  }

  swift_bridgeObjectRelease(a2);
  if (v20 < a4 || v21 < v67)
  {
    a2 = v29;
    uint64_t v54 = v22 == v59;
    uint64_t v22 = v57;
    uint64_t v23 = v58;
    if (!v54) {
      goto LABEL_6;
    }
  }

  else
  {
LABEL_87:
    uint64_t v23 = v58;
  }

  swift_bridgeObjectRelease(v29);
  return v23;
}

  v61(v72, a3);
LABEL_48:
  v93 = v118;
  unint64_t v94 = v118(a3, a4);
  char v95 = v117;
  v63(v117, (uint64_t)v27, a3);
  if (v94 >= 65)
  {
    v61(v95, a3);
    goto LABEL_50;
  }

  v103 = v93(a3, a4);
  v61(v95, a3);
  if (v103 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_50:
    v63(v17, (uint64_t)v27, a3);
    uint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
    v96 = v119(a3, a4);
    uint64_t v97 = v118(a3, a4);
    if ((v96 & 1) != 0)
    {
      if (v97 > 64)
      {
        v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
        char v102 = &v122;
        goto LABEL_59;
      }
    }

    else if (v97 >= 64)
    {
      uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
      char v102 = &v121;
LABEL_59:
      v100(v102, &type metadata for Int, v101, a3, a4);
      v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v17,  a3);
      v61(v29, a3);
      if ((v104 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_60;
    }

    v63(v29, (uint64_t)v17, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
LABEL_60:
    v61(v17, a3);
  }

  char v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  id result = v61(v27, a3);
  v106 = *v120;
  char v51 = v120[1];
  if ((v105 & 0x8000000000000000LL) == 0)
  {
    if (v105 < 0x80)
    {
      uint64_t v53 = (v51 << v105) | (v106 >> 1 >> ~(_BYTE)v105);
      uint64_t v52 = v106 << v105;
      if ((v105 & 0x40) != 0)
      {
        uint64_t v53 = v106 << v105;
        uint64_t v52 = 0LL;
      }

      goto LABEL_65;
    }

  v87 = 0LL;
  uint64_t v88 = &TypeName->u8[v76];
  v86 = 1;
  for (i = TypeName; ; i = (uint8x16_t *)((char *)i + 3))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (!i || v88 == (unsigned __int8 *)i)
          {
            if (v76 > 15) {
              goto LABEL_106;
            }
            goto LABEL_107;
          }

          uint64_t v91 = i->u8[0];
          i = (uint8x16_t *)((char *)i + 1);
          uint64_t v90 = v91;
          if ((v90 & 0x80) != 0) {
            break;
          }
          ++v87;
        }

        if (v90 > 0xDF) {
          break;
        }
        v86 = 0;
        i = (uint8x16_t *)((char *)i + 1);
        v87 += 2LL;
      }

      if (v90 != 224) {
        break;
      }
      if (!i) {
        goto LABEL_96;
      }
      uint64_t v92 = &i->u8[1];
      if ((i->i8[0] & 0xE0) != 0xA0) {
        goto LABEL_96;
      }
LABEL_74:
      if (v92 == v88 || (*v92 & 0xC0) != 0x80) {
        goto LABEL_96;
      }
      v86 = 0;
      i = (uint8x16_t *)((char *)i + 2);
      v87 += 3LL;
    }

    if (v90 <= 0xEC)
    {
LABEL_66:
      uint64_t v92 = &i->u8[1];
      LOBYTE(v93) = i->i8[0];
LABEL_73:
      if ((v93 & 0xC0) != 0x80) {
        goto LABEL_96;
      }
      goto LABEL_74;
    }

    if (v90 == 237)
    {
      if (!i) {
        goto LABEL_96;
      }
      uint64_t v92 = &i->u8[1];
      v93 = i->u8[0];
      if (v93 > 0x9F) {
        goto LABEL_96;
      }
      goto LABEL_73;
    }

    if (v90 <= 0xEF) {
      goto LABEL_66;
    }
    if (v90 != 240) {
      break;
    }
    if (!i) {
      goto LABEL_96;
    }
    unint64_t v94 = &i->u8[1];
LABEL_91:
    v86 = 0;
    v87 += 4LL;
  }

  if ((v90 + 15) <= 2u)
  {
    unint64_t v94 = &i->u8[1];
    LOBYTE(v95) = i->i8[0];
    goto LABEL_90;
  }

  if (i)
  {
    if (v88 != (unsigned __int8 *)i)
    {
      unint64_t v94 = &i->u8[1];
      char v95 = i->u8[0];
      if (v95 <= 0x8F)
      {
LABEL_90:
        if ((v95 & 0xC0) != 0x80) {
          goto LABEL_96;
        }
        goto LABEL_91;
      }
    }
  }

LABEL_29:
      v103 = v71;
      v104 = v197;
      v80(v197, v77, v8);
      char v105 = v202(v8, a5);
      v106 = v196;
      v107 = v104;
      v108 = v104;
      v109 = (void (*)(char *, char *, void (*)(char *, uint64_t)))v80;
      v80(v196, v108, v8);
      if ((v105 & 1) != 0)
      {
        uint64_t v110 = v103(v8, a5);
        v79(v106, v8);
        v111 = v199;
        v112 = v198;
        v113 = v109;
        v114 = v107;
        v115 = v103;
        v116 = v211;
        if (v110 < 65) {
          goto LABEL_37;
        }
        v117 = v202;
        v118 = v191;
        v113(v191, v114, v8);
        v220[0] = 0x8000000000000000LL;
        if ((v117(v8, a5) & 1) != 0)
        {
          uint64_t v119 = v201(v8, a5);
          if (v119 < 64)
          {
            v113(v116, v118, v8);
            uint64_t v122 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
            v200(v116, v8);
            v123 = v118;
            v115 = v201;
            v111 = v199;
            if (v122 < v220[0]) {
              goto LABEL_89;
            }
            goto LABEL_36;
          }

          v167 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
          unint64_t v168 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
          v167(v220, &type metadata for Int, v168, v8, a5);
          v112 = v198;
          char v169 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                                 + 16LL))( v118,  v116,  v8);
          v200(v116, v8);
          v123 = v118;
          v115 = v201;
          v111 = v199;
          if ((v169 & 1) != 0) {
LABEL_89:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
        }

        else
        {
          char v159 = v117(v8, a5);
          v115 = v201;
          uint64_t v160 = v201(v8, a5);
          if ((v159 & 1) != 0)
          {
            v111 = v199;
            if (v160 <= 64)
            {
              v201 = v115;
              v172 = v195;
              unint64_t v173 = AssociatedTypeWitness;
              unint64_t v174 = swift_getAssociatedConformanceWitness( (uint64_t)v195,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v175 = v193;
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v174 + 8))( &unk_18180BE68,  256LL,  v173,  v174);
              (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v172 + 3))( v175,  v8,  v172);
              v176 = v191;
              LODWORD(v215) = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v191,  v116,  v8);
              v177 = v200;
              v200(v116, v8);
              v178 = v190;
              v113(v190, v176, v8);
              if ((v215 & 1) != 0)
              {
                v177(v178, v8);
                goto LABEL_89;
              }

              v215 = (char *)v220[0];
              uint64_t v179 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
              v177(v178, v8);
              BOOL v180 = v179 < (uint64_t)v215;
              v112 = v198;
              v123 = v191;
              v115 = v201;
              if (v180) {
                goto LABEL_89;
              }
            }

            else
            {
              v163 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
              unint64_t v164 = lazy protocol witness table accessor for type Int and conformance Int(v160, v161, v162);
              v163(v220, &type metadata for Int, v164, v8, a5);
              v165 = v191;
              char v166 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v191,  v116,  v8);
              v200(v116, v8);
              v123 = v165;
              v112 = v198;
              if ((v166 & 1) != 0) {
                goto LABEL_89;
              }
            }
          }

          else
          {
            v111 = v199;
            if (v160 < 64)
            {
              v170 = v191;
              v113(v116, v191, v8);
              uint64_t v171 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
              v200(v116, v8);
              v123 = v170;
              v112 = v198;
              if (v171 < v220[0]) {
                goto LABEL_89;
              }
            }

            else
            {
              v112 = v198;
              v123 = v191;
            }
          }
        }
      }

      else
      {
        v123 = v106;
        v111 = v199;
        v112 = v198;
        v113 = v109;
        v114 = v107;
        v115 = v103;
        v116 = v211;
      }

        unint64_t v10 = (v17 - 1) & v17;
        uint64_t v16 = __clz(__rbit64(v17)) + (v13 << 6);
      }

      ++v14;
      *v12++ = (__objc2_class *)v16;
      if (v14 == v4) {
        goto LABEL_34;
      }
    }
  }

  id result = &_swiftEmptyArrayStorage;
  uint64_t v11 = (unint64_t)qword_18C565BD0 >> 1;
  uint64_t v12 = &_swiftEmptySetSingleton;
  if (!a2)
  {
    unint64_t v10 = 0LL;
    uint64_t v13 = 0LL;
LABEL_34:
    if (!v10) {
      goto LABEL_39;
    }
    goto LABEL_35;
  }

  uint64_t v13 = 0LL;
  unint64_t v10 = *a1;
  if (!*a1) {
    goto LABEL_39;
  }
LABEL_35:
  uint64_t v19 = __clz(__rbit64(v10));
  v10 &= v10 - 1;
  uint64_t v20 = v19 | (v13 << 6);
  if (v11)
  {
LABEL_36:
    uint64_t v8 = __OFSUB__(v11--, 1LL);
    if (!v8) {
      goto LABEL_61;
    }
LABEL_67:
    __break(1u);
    goto LABEL_68;
  }

  while (1)
  {
    uint64_t v23 = (unint64_t)result[3];
    v24 = v23 & 0xFFFFFFFFFFFFFFFELL;
    if (v24 <= 1) {
      uint64_t v25 = 1LL;
    }
    else {
      uint64_t v25 = v24;
    }
    uint64_t v26 = result;
    uint64_t v27 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>();
    uint64_t v28 = (__objc2_class **)swift_allocObject(v27, 8 * v25 + 32, 7uLL);
    uint64_t v29 = _swift_stdlib_malloc_size(v28);
    uint64_t v31 = v29 - 32;
    uint64_t v30 = v29 < 32;
    uint64_t v32 = v29 - 25;
    uint64_t v33 = (uint64_t)v26;
    if (v30) {
      uint64_t v31 = v32;
    }
    uint64_t v34 = v31 >> 3;
    v28[2] = (__objc2_class *)v25;
    v28[3] = (__objc2_class *)(2 * (v31 >> 3));
    uint64_t v35 = (unint64_t)(v28 + 4);
    uint64_t v36 = (unint64_t)v26[3] >> 1;
    if (v26[2])
    {
      uint64_t v37 = v26 + 4;
      if (v28 != v26 || v35 >= (unint64_t)v37 + 8 * v36)
      {
        memmove(v28 + 4, v37, 8 * v36);
        uint64_t v33 = (uint64_t)v26;
      }

      *(void *)(v33 + 16) = 0LL;
    }

    uint64_t v12 = (__objc2_class **)(v35 + 8 * v36);
    uint64_t v38 = (v34 & 0x7FFFFFFFFFFFFFFFLL) - v36;
    swift_release(v33);
    id result = v28;
    uint64_t v8 = __OFSUB__(v38, 1LL);
    uint64_t v11 = v38 - 1;
    if (v8) {
      goto LABEL_67;
    }
LABEL_61:
    *v12++ = (__objc2_class *)v20;
    if (v10) {
      goto LABEL_35;
    }
LABEL_39:
    uint64_t v8 = __OFADD__(v13++, 1LL);
    if (v8) {
      goto LABEL_69;
    }
    if (v13 >= a2) {
      break;
    }
    uint64_t v21 = a1[v13];
    if (!v21)
    {
      uint64_t v22 = v13 + 1;
      if (v13 + 1 >= a2) {
        break;
      }
      uint64_t v21 = a1[v22];
      if (!v21)
      {
        while (1)
        {
          uint64_t v13 = v22 + 1;
          if (__OFADD__(v22, 1LL)) {
            break;
          }
          if (v13 >= a2) {
            goto LABEL_63;
          }
          uint64_t v21 = a1[v13];
          ++v22;
          if (v21) {
            goto LABEL_48;
          }
        }

    char v51 = *(TupleTypeMetadata2 - 1);
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v51 + 56))(v16, v43, 1LL, TupleTypeMetadata2);
    (*(void (**)(char *, char *, uint64_t))(v232 + 32))(v21, v16, v233);
    uint64_t v52 = &v21[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v53 = *(void (**)(char *, char *, char *))(v236 + 32);
    uint64_t v54 = v238;
    uint64_t v26 = (uint64_t)v243;
    v53(v238, v21, v243);
    v239 = *(void (**)(char *, char *, unint64_t))(v237 + 32);
    v239(v242, v52, v3);
    if ((v37 & 1) != 0) {
      goto LABEL_80;
    }
    char v57 = v247;
    uint64_t v4 = v248;
    uint64_t v58 = HIBYTE(v248) & 0xF;
    uint64_t v3 = v247 & 0xFFFFFFFFFFFFLL;
    if ((v248 & 0x2000000000000000LL) != 0) {
      uint64_t v59 = HIBYTE(v248) & 0xF;
    }
    else {
      uint64_t v59 = v247 & 0xFFFFFFFFFFFFLL;
    }
    if (!v59 && (v247 & ~v248 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v248);
      v247 = 8236LL;
      char v95 = 0xE200000000000000LL;
LABEL_78:
      v248 = v95;
      goto LABEL_79;
    }

    if ((v248 & 0x2000000000000000LL) != 0 && v58 <= 0xD)
    {
      uint64_t v60 = 8 * (HIBYTE(v248) & 7);
      v61 = (-255LL << v60) - 1;
      unint64_t v62 = 44LL << v60;
      char v63 = v58 + 1;
      if (v58 >= 8)
      {
        v64 = v62 | v61 & v248;
LABEL_71:
        uint64_t v98 = (32LL << (8 * (v63 & 7u))) | ((-255LL << (8 * (v63 & 7u))) - 1) & v64;
      }

      else
      {
        char v57 = v62 | v61 & v247;
        if (v58 == 7)
        {
          char v63 = 8;
          v64 = v248;
          goto LABEL_71;
        }

        char v57 = (32LL << (8 * (v63 & 7u))) | ((-255LL << (8 * (v63 & 7u))) - 1) & v57;
        uint64_t v98 = v248;
      }

      swift_bridgeObjectRelease(v248);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v99 = 0xE000000000000000LL;
      if (v57 & 0x8080808080808080LL | v98 & 0x80808080808080LL) {
        uint64_t v99 = 0xA000000000000000LL;
      }
      char v95 = (v99 & 0xFF00000000000000LL | (v58 << 56) | v98 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
LABEL_77:
      v247 = v57;
      goto LABEL_78;
    }

    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v55, v56);
    if ((v4 & 0x1000000000000000LL) != 0)
    {
      uint64_t v155 = String.UTF8View._foreignCount()();
      char v66 = v155 + 2;
      if (__OFADD__(v155, 2LL)) {
        goto LABEL_253;
      }
    }

    else
    {
      unint64_t v65 = __OFADD__(v59, 2LL);
      char v66 = v59 + 2;
      if (v65) {
        goto LABEL_253;
      }
    }

    if ((v57 & ~v4 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
    {
      v67 = _StringGuts.nativeUnusedCapacity.getter(v57, v4);
      if ((v68 & 1) != 0) {
        goto LABEL_269;
      }
      if (v66 <= 15)
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
LABEL_50:
          uint64_t v72 = v4;
          goto LABEL_51;
        }

        if (v67 <= 1) {
          goto LABEL_49;
        }
      }
    }

    else if (v66 <= 15)
    {
LABEL_49:
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
      if ((v4 & 0x2000000000000000LL) != 0) {
        goto LABEL_50;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        char v57 = _StringGuts._foreignConvertedToSmall()(v57, v4);
        uint64_t v72 = v167;
      }

      else
      {
        if ((v57 & 0x1000000000000000LL) != 0)
        {
          uint64_t v161 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          uint64_t v161 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v57, v4);
          uint64_t v3 = v69;
        }

        swift_bridgeObjectRetain(v4, v69, v70, v71);
        closure #1 in _StringGuts._convertedToSmall()(v161, v3, &v246);
        swift_bridgeObjectRelease(v4);
        uint64_t v72 = *((void *)&v246 + 1);
        char v57 = v246;
      }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }

  v227 = (char *)v139;
  v163 = v229;
  unint64_t v164 = v198;
  v165 = v161;
  ((void (*)(void))v218)();
  char v166 = v187;
  v167 = v210;
  ((void (*)(char *, uint64_t, uint64_t))v219)(v187, v155, v210);
  unint64_t v168 = &v164[*(int *)(v163 + 36)];
  char v169 = v196;
  v165(v160, v156);
  LOBYTE(v168) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(v214 + 8) + 8LL))( v168,  v169,  AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v225)(v169, AssociatedTypeWitness);
  if ((v168 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x12FuLL,  0);
  }
  ((void (*)(char *, uint64_t))v217)(v166, v167);
  char v139 = (void (*)(char *, uint64_t))v227;
  ((void (*)(char *, uint64_t))v227)(v198, v163);
  v170 = v163;
LABEL_26:
  v139(v230, v170);
  return ((uint64_t (*)(char *, uint64_t))v139)(v228, v170);
}

  swift_release((uint64_t)v4);
  *uint64_t v2 = v8;
}

  swift_release((uint64_t)v4);
  *uint64_t v2 = v8;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x69uLL,  0);
  }

  outlined destroy of AnyHashable((uint64_t *)&v43);
  return 0LL;
}

        v102(v89, v11);
        uint64_t v31 = v185;
        uint64_t v49 = v87;
        goto LABEL_30;
      }
    }

    else if (v91 <= 32)
    {
      v111 = v186;
      v88(v186, v89, v11);
      v112 = ((uint64_t (*)(uint64_t, void *))v12[15])(v11, v12);
      char v102 = (void (*)(char *, uint64_t))v87[1];
      v102(v111, v11);
      if (v190 < v112) {
        goto LABEL_54;
      }
      goto LABEL_29;
    }

    v107 = (void (*)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, void *))v12[12];
    v108 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v91, v92, v93);
    v109 = v186;
    v107(&v190, &type metadata for UInt32, v108, v11, v12);
    uint64_t v110 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8LL) + 16LL))(v109, v89, v11);
    char v102 = (void (*)(char *, uint64_t))v87[1];
    v102(v109, v11);
    if ((v110 & 1) != 0) {
      goto LABEL_54;
    }
    goto LABEL_29;
  }

  v50 = 0LL;
  char v51 = 0;
LABEL_44:
  (*(void (**)(char *, unint64_t))(v158 + 8))(v176, v177);
  char v137 = v188;
  v138 = *(uint64_t (**)(uint64_t, uint64_t))(v188 + 56);
  char v139 = v138(v11, v188);
  v140 = v160;
  if (!v139 || (uint64_t v141 = v139, (v142 = v138(v11, v137)) == 0)) {
LABEL_55:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  uint64_t v144 = v51;
  v145 = v161;
  unint64_t v146 = *(_BYTE *)(v140 + 4);
  uint64_t v147 = v50 / v142 - (v164 - v161) / v141;
  v190 = *(_DWORD *)v140;
  v191 = v146;
  unint64_t v148 = v175;
  unint64_t v149 = swift_getWitnessTable(L"D\r\r\u0AD5", v175, v143);
  v150 = Collection.count.getter(v148, v149);
  if (__OFADD__(v150, v147))
  {
    __break(1u);
LABEL_58:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xDDuLL,  0);
  }

  unint64_t v151 = v188;
  if (specialized _UIntBuffer.capacity.getter(v11, v188) < v150 + v147) {
    goto LABEL_58;
  }
  uint64_t v152 = v138(v11, v151);
  if (!v152) {
    goto LABEL_55;
  }
  uint64_t v153 = v152;
  v154 = v138(v11, v151);
  if (!v154) {
    goto LABEL_55;
  }
  uint64_t v155 = v145 / v153;
  uint64_t v156 = v164 / v154;
  id result = v138(v11, v151);
  *(_DWORD *)v140 = (*(_DWORD *)v140 >> ((result * v156 + 1) >> 1) >> ((result * v156) >> 1) << (result * (v156 + v147))) | (v144 << (result * v155)) | ((1 << ((result * v155 + 1) >> 1) << ((result * v155) >> 1)) - 1) & *(_DWORD *)v140;
  *(_BYTE *)(v140 + 4) += result * v147;
  return result;
}

  *(void *)a4 = v11;
  *(_BYTE *)(a4 + 8) = v12;
  return result;
}

  outlined destroy of _PlaygroundQuickLook?((uint64_t)&v89);
  *(void *)&uint64_t v89 = 0LL;
  *((void *)&v89 + 1) = 0xE000000000000000LL;
  _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)a1,  (uint64_t)&v89,  (swift *)byte_189B8D218,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  id result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  unint64_t v62 = *((void *)&v89 + 1);
  *(void *)a2 = v89;
  *(void *)(a2 + 8) = v62;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

  LOBYTE(v73) = 0;
  uint64_t v74 = v118;
LABEL_48:
  *uint64_t v74 = v73;
  return result;
}

  LOWORD(v73) = 0;
  uint64_t v74 = v118;
LABEL_48:
  *uint64_t v74 = v73;
  return result;
}

    --v24;
    uint64_t v25 = v22;
    goto LABEL_30;
  }

  _Block_release(v15);
  swift_release((uint64_t)v19);
  swift_release_n(v61, 2LL);
  return swift_release(v71);
}

    swift_getTypeByMangledNameImpl(a1, a2, a3, a4, v26, v24, a7);
    uint64_t v22 = v25;
    if (v25 == v24)
    {
      uint64_t v23 = 4LL;
      uint64_t v22 = v24;
    }

    else
    {
      if (!v25) {
        goto LABEL_34;
      }
      uint64_t v23 = 5LL;
    }

    (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_34:
    id result = v27;
    if (v27 == v26)
    {
      uint64_t v21 = 4LL;
      id result = v26;
      return (void *)(*(uint64_t (**)(void))(*result + 8 * v21))();
    }

    goto LABEL_35;
  }

  if (v15)
  {
    if (v15 == a5)
    {
      uint64_t v31 = v30;
      (*(void (**)(void *, _BYTE *))(*a5 + 24LL))(a5, v30);
      uint64_t v16 = (void *)a6[3];
      if (!v16) {
        goto LABEL_5;
      }
    }

    else
    {
      uint64_t v31 = (_BYTE *)(*(uint64_t (**)(void *))(*v15 + 16LL))(v15);
      uint64_t v16 = (void *)a6[3];
      if (!v16)
      {
LABEL_5:
        uint64_t v29 = 0LL;
        goto LABEL_17;
      }
    }
  }

  else
  {
    uint64_t v31 = 0LL;
    uint64_t v16 = (void *)a6[3];
    if (!v16) {
      goto LABEL_5;
    }
  }

  if (v16 == a6)
  {
    uint64_t v29 = v28;
    (*(void (**)(void *, _BYTE *))(*a6 + 24LL))(a6, v28);
  }

  else
  {
    uint64_t v29 = (_BYTE *)(*(uint64_t (**)(void *))(*v16 + 16LL))(v16);
  }

    swift_getTypeByMangledNodeImpl(a1, a2, a3, a4, v26, v24, a7);
    uint64_t v22 = v25;
    if (v25 == v24)
    {
      uint64_t v23 = 4LL;
      uint64_t v22 = v24;
    }

    else
    {
      if (!v25) {
        goto LABEL_34;
      }
      uint64_t v23 = 5LL;
    }

    (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_34:
    id result = v27;
    if (v27 == v26)
    {
      uint64_t v21 = 4LL;
      id result = v26;
      return (void *)(*(uint64_t (**)(void))(*result + 8 * v21))();
    }

    goto LABEL_35;
  }

  if (v15)
  {
    if (v15 == a5)
    {
      uint64_t v31 = v30;
      (*(void (**)(void *, _BYTE *))(*a5 + 24LL))(a5, v30);
      uint64_t v16 = (void *)a6[3];
      if (!v16) {
        goto LABEL_5;
      }
    }

    else
    {
      uint64_t v31 = (_BYTE *)(*(uint64_t (**)(void *))(*v15 + 16LL))(v15);
      uint64_t v16 = (void *)a6[3];
      if (!v16)
      {
LABEL_5:
        uint64_t v29 = 0LL;
        goto LABEL_17;
      }
    }
  }

  else
  {
    uint64_t v31 = 0LL;
    uint64_t v16 = (void *)a6[3];
    if (!v16) {
      goto LABEL_5;
    }
  }

  if (v16 == a6)
  {
    uint64_t v29 = v28;
    (*(void (**)(void *, _BYTE *))(*a6 + 24LL))(a6, v28);
  }

  else
  {
    uint64_t v29 = (_BYTE *)(*(uint64_t (**)(void *))(*v16 + 16LL))(v16);
  }

          if (v23 == v245)
          {
            v272 = v271;
            (*(void (**)(void *, void *))(v245[0] + 24LL))(v245, v271);
          }

          else
          {
            v272 = (void *)(*(uint64_t (**)(void *))(*v23 + 16LL))(v23);
          }

        uint64_t v13 = 0LL;
LABEL_30:
        uint64_t v14 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::popFunctionParamLabels( this,  v13,  a3,  a4,  a5);
        unint64_t v10 = 1;
LABEL_31:
        uint64_t v23 = (swift::Demangle::__runtime::Node *)v7;
        v24 = swift::Demangle::__runtime::Demangler::popContext(this, a2, a3, a4, a5);
        if (v24)
        {
          uint64_t v27 = v24;
          uint64_t v28 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
          if (!v28 || v28 + 24 > *((void *)this + 2))
          {
            uint64_t v29 = 2LL * *((void *)this + 4);
            if (v29 <= 0x20) {
              uint64_t v29 = 32LL;
            }
            *((void *)this + 4) = v29;
            uint64_t v30 = v29 + 8;
            uint64_t v31 = malloc(v29 + 8);
            uint64_t v32 = (char *)v31 + v30;
            *uint64_t v31 = *((void *)this + 3);
            uint64_t v28 = ((unint64_t)v31 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *((void *)this + 2) = v32;
            *((void *)this + 3) = v31;
          }

          *((void *)this + 1) = v28 + 24;
          *(_WORD *)(v28 + 16) = v12;
          *(_BYTE *)(v28 + 18) = 0;
          swift::Demangle::__runtime::Node::addChild((unsigned int *)v28, v27, this, v25, v26);
          if (v10 != 1)
          {
LABEL_38:
            if (v10 == 2)
            {
              int v7 = 0LL;
              if (!v23 || !v28) {
                return (swift::Demangle::__runtime::Node *)v7;
              }
              swift::Demangle::__runtime::Node::addChild((unsigned int *)v28, v23, this, v25, v26);
              if (!v13) {
                return 0LL;
              }
              uint64_t v33 = (unsigned int *)v28;
              uint64_t v34 = v13;
              goto LABEL_55;
            }

            if (v10 == 3)
            {
              int v7 = 0LL;
              if (!v23 || !v28) {
                return (swift::Demangle::__runtime::Node *)v7;
              }
              goto LABEL_50;
            }

            return (swift::Demangle::__runtime::Node *)v28;
          }
        }

        else
        {
          uint64_t v28 = 0LL;
          if (v10 != 1) {
            goto LABEL_38;
          }
        }

        if (v14 && v28) {
          swift::Demangle::__runtime::Node::addChild((unsigned int *)v28, v14, this, v25, v26);
        }
        int v7 = 0LL;
        if (!v13 || !v28) {
          return (swift::Demangle::__runtime::Node *)v7;
        }
        swift::Demangle::__runtime::Node::addChild((unsigned int *)v28, v13, this, v25, v26);
        if (v23)
        {
LABEL_50:
          uint64_t v33 = (unsigned int *)v28;
          uint64_t v34 = v23;
LABEL_55:
          swift::Demangle::__runtime::Node::addChild(v33, v34, this, v25, v26);
        }

        return (swift::Demangle::__runtime::Node *)v28;
      case 35:
        unint64_t v10 = 0;
        int v7 = 0LL;
        uint64_t v13 = 0LL;
        uint64_t v14 = 0LL;
        uint64_t v12 = 50;
        goto LABEL_31;
      case 36:
        unint64_t v10 = 0;
        int v7 = 0LL;
        uint64_t v13 = 0LL;
        uint64_t v14 = 0LL;
        uint64_t v12 = 103;
        goto LABEL_31;
      case 40:
        unint64_t v10 = 0;
        int v7 = 0LL;
        uint64_t v13 = 0LL;
        uint64_t v14 = 0LL;
        uint64_t v12 = 125;
        goto LABEL_31;
      case 44:
        uint64_t v19 = 138;
        return swift::Demangle::__runtime::Demangler::demangleEntity(this, v19, a3, a4, a5);
      case 47:
        uint64_t v19 = 262;
        return swift::Demangle::__runtime::Demangler::demangleEntity(this, v19, a3, a4, a5);
      case 52:
        uint64_t v11 = 117;
LABEL_20:
        int v7 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
        uint64_t v20 = *((_DWORD *)this + 24);
        if (v20
          && (uint64_t v21 = v20 - 1,
              uint64_t v13 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v21),
              *((_WORD *)v13 + 8) == 232))
        {
          uint64_t v14 = 0LL;
          *((_DWORD *)this + 24) = v21;
        }

        else
        {
          uint64_t v13 = 0LL;
          uint64_t v14 = 0LL;
        }

        unint64_t v10 = 2;
        uint64_t v12 = v11;
        goto LABEL_31;
      default:
        return (swift::Demangle::__runtime::Node *)v7;
    }
  }

  return 0LL;
}

            uint64_t v13 = -999;
          }

          break;
        }

      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = 0LL;
      *(_DWORD *)(a4 + 16) = 0;
      uint64_t v16 = (char **)(this + 1591);
      uint64_t v17 = this[1593];
      uint64_t v18 = "XC";
      uint64_t v19 = 2LL;
      goto LABEL_51;
    }

    if (!*((_DWORD *)a2 + 2)) {
      goto LABEL_29;
    }
    uint64_t v8 = *(swift::Demangle::__runtime::Node **)a2;
  }

  if (*(_WORD *)(*(void *)v8 + 16LL) != 23) {
    goto LABEL_11;
  }
  if ((_DWORD)v7 != 1)
  {
    if ((_DWORD)v7 == 5)
    {
      int v7 = *((unsigned int *)a2 + 2);
    }

    else
    {
      uint64_t v9 = (_DWORD)v7 == 2;
      int v7 = 2LL;
      if (!v9) {
        int v7 = 0LL;
      }
    }
  }

  uint64_t v20 = a3 + 1;
  uint64_t v21 = v7 - 1;
  while (v21)
  {
    uint64_t v22 = *((unsigned __int8 *)v4 + 18);
    uint64_t v23 = v22 - 1;
    if ((_DWORD)v22 != 1)
    {
      if ((_DWORD)v22 == 5)
      {
        uint64_t v22 = *((unsigned int *)v4 + 2);
      }

      else
      {
        if ((_DWORD)v22 != 2) {
          goto LABEL_32;
        }
        uint64_t v22 = 2LL;
      }
    }

    if (v22 <= v21)
    {
LABEL_32:
      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = 0LL;
      *(_DWORD *)(a4 + 16) = 0;
      --v21;
    }

    else
    {
      v24 = v4;
      if (v23 >= 2) {
        v24 = *(swift::Demangle::__runtime::Node **)v4;
      }
      if (*(_DWORD *)a4) {
        return result;
      }
    }
  }

  swift::Demangle::__runtime::CharVector::append((char **)this + 1591, "XzC", 3uLL, this[1593]);
  uint64_t v25 = *((unsigned __int8 *)v4 + 18);
  if (v25 == 5 && *((_DWORD *)v4 + 2))
  {
    uint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
LABEL_48:
    uint64_t v26 = *(swift::Demangle::__runtime::Node **)v4;
  }

  else
  {
    uint64_t v26 = 0LL;
  }

  swift::Demangle::__runtime::CharVector::append((unsigned int *)this + 3182, *((void *)v26 + 1), this[1593]);
  uint64_t v18 = *(const char **)v26;
  uint64_t v19 = *((void *)v26 + 1);
  uint64_t v17 = this[1593];
  uint64_t v16 = (char **)(this + 1591);
LABEL_51:
  id result = swift::Demangle::__runtime::CharVector::append(v16, v18, v19, v17);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

    *(_DWORD *)a4 = 1;
    a4[1] = (uint64_t)a2;
    *((_DWORD *)a4 + 4) = 1221;
    return result;
  }

  uint64_t v15 = *a2;
  uint64_t v16 = *((void *)*a2 + 1);
  if (*(_WORD *)(v16 + 16) != 101) {
    goto LABEL_29;
  }
  if (*(void *)(v16 + 8) != 1LL)
  {
LABEL_23:
    *(_DWORD *)a4 = 1;
    a4[1] = (uint64_t)a2;
    *((_DWORD *)a4 + 4) = 1222;
    return result;
  }

      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = 0LL;
      *(_DWORD *)(a4 + 16) = 0;
      uint64_t v16 = (char **)(this + 1591);
      uint64_t v17 = this[1593];
      uint64_t v18 = "XB";
      uint64_t v19 = 2LL;
      goto LABEL_51;
    }

    if (!*((_DWORD *)a2 + 2)) {
      goto LABEL_29;
    }
    uint64_t v8 = *(swift::Demangle::__runtime::Node **)a2;
  }

  if (*(_WORD *)(*(void *)v8 + 16LL) != 23) {
    goto LABEL_11;
  }
  if ((_DWORD)v7 != 1)
  {
    if ((_DWORD)v7 == 5)
    {
      int v7 = *((unsigned int *)a2 + 2);
    }

    else
    {
      uint64_t v9 = (_DWORD)v7 == 2;
      int v7 = 2LL;
      if (!v9) {
        int v7 = 0LL;
      }
    }
  }

  uint64_t v20 = a3 + 1;
  uint64_t v21 = v7 - 1;
  while (v21)
  {
    uint64_t v22 = *((unsigned __int8 *)v4 + 18);
    uint64_t v23 = v22 - 1;
    if ((_DWORD)v22 != 1)
    {
      if ((_DWORD)v22 == 5)
      {
        uint64_t v22 = *((unsigned int *)v4 + 2);
      }

      else
      {
        if ((_DWORD)v22 != 2) {
          goto LABEL_32;
        }
        uint64_t v22 = 2LL;
      }
    }

    if (v22 <= v21)
    {
LABEL_32:
      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = 0LL;
      *(_DWORD *)(a4 + 16) = 0;
      --v21;
    }

    else
    {
      v24 = v4;
      if (v23 >= 2) {
        v24 = *(swift::Demangle::__runtime::Node **)v4;
      }
      if (*(_DWORD *)a4) {
        return result;
      }
    }
  }

  swift::Demangle::__runtime::CharVector::append((char **)this + 1591, "XzB", 3uLL, this[1593]);
  uint64_t v25 = *((unsigned __int8 *)v4 + 18);
  if (v25 == 5 && *((_DWORD *)v4 + 2))
  {
    uint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
LABEL_48:
    uint64_t v26 = *(swift::Demangle::__runtime::Node **)v4;
  }

  else
  {
    uint64_t v26 = 0LL;
  }

  swift::Demangle::__runtime::CharVector::append((unsigned int *)this + 3182, *((void *)v26 + 1), this[1593]);
  uint64_t v18 = *(const char **)v26;
  uint64_t v19 = *((void *)v26 + 1);
  uint64_t v17 = this[1593];
  uint64_t v16 = (char **)(this + 1591);
LABEL_51:
  id result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(v16, v18, v19, v17);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

      if (++v18 > v3)
      {
        uint64_t v38 = v131;
        if (*((_DWORD *)v5 + 3196))
        {
          uint64_t v39 = *((_DWORD *)v5 + 3184);
          uint64_t v40 = *((unsigned int *)v5 + 3185);
          uint64_t v41 = v5[1591];
          if (v39 >= v40)
          {
            uint64_t v42 = v5[1593];
            uint64_t v43 = (char *)v42[1];
            if ((char *)v41 + v40 != v43)
            {
              uint64_t v44 = v42[2];
              goto LABEL_75;
            }

            uint64_t v45 = (unint64_t)v41 + v40 + 1;
            uint64_t v44 = v42[2];
            if (v45 <= v44)
            {
              v42[1] = v45;
              LODWORD(v46) = 1;
            }

            else
            {
LABEL_75:
              else {
                v46 = (2 * v40);
              }
              uint64_t v47 = v46 + v40;
              if (!v43 || (unint64_t)&v43[v47] > v44)
              {
                uint64_t v48 = 2LL * v42[4];
                if (v48 <= v47 + 1) {
                  uint64_t v48 = v47 + 1;
                }
                v42[4] = v48;
                uint64_t v49 = v48 + 8;
                v50 = malloc(v48 + 8);
                *v50 = v42[3];
                uint64_t v43 = (char *)(v50 + 1);
                uint64_t v38 = v131;
                v42[2] = (char *)v50 + v49;
                v42[3] = v50;
              }

              v42[1] = &v43[v47];
              if ((_DWORD)v40)
              {
                memcpy(v43, v5[1591], v40);
                LODWORD(v40) = *((_DWORD *)v5 + 3185);
                uint64_t v39 = *((_DWORD *)v5 + 3184);
              }

              *(void *)char v128 = v43;
              uint64_t v41 = v43;
            }

            *((_DWORD *)v5 + 3185) = v40 + v46;
          }

          *((_DWORD *)v5 + 3184) = v39 + 1;
          *((_BYTE *)v41 + v39) = 48;
          uint64_t v3 = a3;
        }

        __p.__r_.__value_.__r.__words[0] = v3;
        LODWORD(__p.__r_.__value_.__r.__words[1]) = -1;
        swift::Demangle::__runtime::Vector<swift::Mangle::__runtime::WordReplacement>::push_back( (uint64_t)v124,  (__n128 *)&__p,  *v5);
        v123 = *((unsigned int *)v5 + 3196);
        if (!(_DWORD)v123)
        {
LABEL_197:
          *((_DWORD *)v5 + 3196) = 0;
          return;
        }

        char v51 = 0LL;
        uint64_t v52 = 0LL;
        uint64_t v125 = v5;
        while (2)
        {
          v126 = v51;
          v56 = *v124 + 16 * v51;
          if (*(void *)v56 > v52)
          {
            swift::Demangle::__runtime::CharVector::append( v128,  *(void *)v56 - v52,  (swift::Demangle::__runtime::NodeFactory *)v5[1593]);
            char v57 = 1;
            v132 = v56;
            while (1)
            {
              if (v38 < *((unsigned int *)v5 + 3192))
              {
                uint64_t v59 = (void *)(*v130 + 16 * v38);
                if (v52 == *v59)
                {
                  *uint64_t v59 = *((unsigned int *)v5 + 3184);
                  ++v38;
                }
              }

              LODWORD(v60) = v4[v52];
              if ((v57 & 1) != 0)
              {
                v61 = *((_DWORD *)v5 + 3184);
                if ((v60 - 48) <= 9)
                {
                  unint64_t v62 = *((unsigned int *)v5 + 3185);
                  char v63 = (char *)v5[1591];
                  if (v61 < v62)
                  {
                    LOBYTE(v60) = 88;
                    goto LABEL_101;
                  }

                  v77 = v38;
                  char v78 = v5[1593];
                  v79 = (char *)v78[1];
                  if (&v63[v62] != v79)
                  {
                    v80 = v78[2];
                    goto LABEL_131;
                  }

                  uint64_t v81 = (unint64_t)&v63[v62 + 1];
                  v80 = v78[2];
                  if (v81 <= v80)
                  {
                    v78[1] = v81;
                    LODWORD(v60) = 1;
                    v79 = v63;
                  }

                  else
                  {
LABEL_131:
                    else {
                      uint64_t v60 = (2 * v62);
                    }
                    v82 = v60 + v62;
                    if (!v79 || (unint64_t)&v79[v82] > v80)
                    {
                      unint64_t v83 = 2LL * v78[4];
                      if (v83 <= v82 + 1) {
                        unint64_t v83 = v82 + 1;
                      }
                      v78[4] = v83;
                      v84 = v83 + 8;
                      v85 = malloc(v83 + 8);
                      char *v85 = v78[3];
                      v79 = (char *)(v85 + 1);
                      v78[2] = (char *)v85 + v84;
                      v78[3] = v85;
                    }

                    v78[1] = &v79[v82];
                    if ((_DWORD)v62)
                    {
                      memcpy(v79, v5[1591], v62);
                      LODWORD(v62) = *((_DWORD *)v5 + 3185);
                      v61 = *((_DWORD *)v5 + 3184);
                    }

                    uint64_t v4 = v129;
                    *(void *)char v128 = v79;
                  }

                  uint64_t v58 = v62 + v60;
                  LOBYTE(v60) = 88;
                  char v63 = v79;
                  uint64_t v38 = v77;
                  v56 = v132;
                  goto LABEL_100;
                }
              }

              else
              {
                v61 = *((_DWORD *)v5 + 3184);
              }

              v64 = *((unsigned int *)v5 + 3185);
              char v63 = (char *)v5[1591];
              unint64_t v65 = v5[1593];
              char v66 = (char *)v65[1];
              if (&v63[v64] != v66) {
                break;
              }
              uint64_t v68 = (unint64_t)&v63[v64 + 1];
              v67 = v65[2];
              if (v68 > v67) {
                goto LABEL_114;
              }
              v65[1] = v68;
              LODWORD(v69) = 1;
              uint64_t v4 = v129;
LABEL_99:
              uint64_t v58 = v64 + v69;
LABEL_100:
              *((_DWORD *)v5 + 3185) = v58;
LABEL_101:
              char v57 = 0;
              *((_DWORD *)v5 + 3184) = v61 + 1;
              v63[v61] = v60;
              if (++v52 >= *(void *)v56) {
                goto LABEL_144;
              }
            }

            v67 = v65[2];
LABEL_114:
            else {
              uint64_t v69 = (2 * v64);
            }
            char v70 = v69 + v64;
            if (v66) {
              v71 = (unint64_t)&v66[v69 + v64] > v67;
            }
            else {
              v71 = 1;
            }
            char v63 = (char *)v65[1];
            if (v71)
            {
              uint64_t v72 = 2LL * v65[4];
              if (v72 <= v70 + 1) {
                uint64_t v72 = v70 + 1;
              }
              v65[4] = v72;
              uint64_t v73 = v38;
              uint64_t v74 = v72 + 8;
              v75 = malloc(v72 + 8);
              *v75 = v65[3];
              char v63 = (char *)(v75 + 1);
              unint64_t v76 = (char *)v75 + v74;
              uint64_t v38 = v73;
              uint64_t v5 = v125;
              v65[2] = v76;
              v65[3] = v75;
            }

            v65[1] = &v63[v70];
            if ((_DWORD)v64)
            {
              memcpy(v63, v5[1591], v64);
              LODWORD(v64) = *((_DWORD *)v5 + 3185);
              v61 = *((_DWORD *)v5 + 3184);
            }

            uint64_t v4 = v129;
            v56 = v132;
            *(void *)char v128 = v63;
            goto LABEL_99;
          }

  *((_DWORD *)this + 3184) = v8 + 1;
  v10[v8] = 95;
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
}

  if (v7 != v10)
  {
    while (1)
    {
      if (*((_WORD *)*v7 + 8) != 37) {
        goto LABEL_24;
      }
      uint64_t v18 = *(void *)*v7;
      if (!v18) {
        break;
      }
LABEL_32:
      if (++v7 == v10) {
        goto LABEL_56;
      }
    }

    uint64_t v19 = *(_DWORD *)(v4 + 12736);
    uint64_t v20 = *(unsigned int *)(v4 + 12740);
    uint64_t v21 = *(_BYTE **)(v4 + 12728);
    if (v19 < v20)
    {
LABEL_54:
      *(_DWORD *)(v4 + 12736) = v19 + 1;
      v21[v19] = 122;
      goto LABEL_32;
    }

    uint64_t v22 = *(void **)(v4 + 12744);
    uint64_t v23 = (_BYTE *)v22[1];
    if (&v21[v20] == v23)
    {
      uint64_t v25 = (unint64_t)&v21[v20 + 1];
      v24 = v22[2];
      if (v25 <= v24)
      {
        v22[1] = v25;
        LODWORD(v26) = 1;
LABEL_53:
        *(_DWORD *)(v4 + 12740) = v20 + v26;
        goto LABEL_54;
      }
    }

    else
    {
      v24 = v22[2];
    }

    else {
      uint64_t v26 = (2 * v20);
    }
    uint64_t v27 = v26 + v20;
    if (v23) {
      uint64_t v28 = (unint64_t)&v23[v26 + v20] > v24;
    }
    else {
      uint64_t v28 = 1;
    }
    uint64_t v21 = (_BYTE *)v22[1];
    if (v28)
    {
      uint64_t v29 = 2LL * v22[4];
      if (v29 <= v27 + 1) {
        uint64_t v29 = v27 + 1;
      }
      v22[4] = v29;
      uint64_t v30 = v29 + 8;
      this = malloc(v29 + 8);
      uint64_t v31 = (char *)this + v30;
      *this = v22[3];
      uint64_t v21 = this + 1;
      v22[2] = v31;
      v22[3] = this;
    }

    v22[1] = &v21[v27];
    if ((_DWORD)v20)
    {
      this = memcpy(v21, *(const void **)(v4 + 12728), v20);
      LODWORD(v20) = *(_DWORD *)(v4 + 12740);
      uint64_t v19 = *(_DWORD *)(v4 + 12736);
    }

    *(void *)(v4 + 12728) = v21;
    goto LABEL_53;
  }

LABEL_36:
      v200(v123, v8);
LABEL_37:
      uint64_t v124 = v115(v8, a5);
      v113(v112, v114, v8);
      if (v124 < 65)
      {
        uint64_t v125 = v115(v8, a5);
        v126 = v112;
        v127 = v200;
        v200(v126, v8);
        if (v125 != 64 || (v202(v8, a5) & 1) != 0) {
          goto LABEL_56;
        }
      }

      else
      {
        v200(v112, v8);
      }

      v113(v111, v114, v8);
      v220[0] = 0x7FFFFFFFFFFFFFFFLL;
      char v128 = v202(v8, a5);
      uint64_t v129 = v115(v8, a5);
      if ((v128 & 1) != 0)
      {
        if (v129 > 64)
        {
          v132 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
          unint64_t v133 = lazy protocol witness table accessor for type Int and conformance Int(v129, v130, v131);
          v134 = v220;
LABEL_54:
          v132(v134, &type metadata for Int, v133, v8, a5);
          char v137 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                                 + 16LL))( v116,  v111,  v8);
          v127 = v200;
          v200(v116, v8);
          if ((v137 & 1) != 0) {
            goto LABEL_87;
          }
          v127(v111, v8);
          goto LABEL_56;
        }
      }

      else if (v129 > 63)
      {
        uint64_t v219 = 0x7FFFFFFFFFFFFFFFLL;
        v132 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
        unint64_t v133 = lazy protocol witness table accessor for type Int and conformance Int(v129, v130, v131);
        v134 = &v219;
        goto LABEL_54;
      }

      v113(v116, v111, v8);
      (*(void (**)(void *, uint64_t))(a5 + 120))(v8, a5);
      v127 = v200;
      v200(v116, v8);
      v127(v111, v8);
LABEL_56:
      uint64_t v49 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
      v127(v114, v8);
      goto LABEL_57;
    }

    v80 = (uint64_t (*)(char *, char *, void (*)(char *, uint64_t)))*((void *)v212 + 2);
    v77 = v215;
    v80(v19, v215, v8);
    uint64_t v81 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
    v79 = v200;
    v200(v19, v8);
    if (v69 < v81) {
      goto LABEL_52;
    }
    goto LABEL_29;
  }

        char v63 = TupleTypeMetadata2;
        unint64_t v157 = (v79 - 1) & v79;
        v158 = (unint64_t *)v78;
        v64 = __clz(__rbit64(v79)) + (v78 << 6);
      }

      uint64_t v81 = v148;
      v82 = *(void *)(v51 + 48) + *(void *)(v148 + 72) * v64;
      unint64_t v83 = v51;
      v84 = v136;
      v85 = v155;
      (*(void (**)(char *, unint64_t, char *))(v148 + 16))(v136, v82, v155);
      v86 = *(void *)(v83 + 56);
      v87 = v156;
      uint64_t v88 = v137;
      (*(void (**)(char *, unint64_t, uint64_t *))(v156 + 16))( v137,  v86 + *(void *)(v156 + 72) * v64,  v34);
      uint64_t v89 = &v62[*((int *)v63 + 12)];
      (*(void (**)(char *, char *, char *))(v81 + 32))(v62, v84, v85);
      uint64_t v90 = *(void (**)(char *, char *, uint64_t *))(v87 + 32);
      TupleTypeMetadata2 = v63;
      v90(v89, v88, v34);
      uint64_t v60 = v149;
      (*(void (**)(char *, void, uint64_t, unint64_t *))(v149 + 56))(v62, 0LL, 1LL, v63);
      uint64_t v20 = v135;
      uint64_t v23 = v147;
      goto LABEL_38;
    }

    unint64_t v65 = v134;
    char v66 = *(void *)(v134 + 216);
    v67 = v155;
    if (v66 < 0) {
      goto LABEL_54;
    }
    uint64_t v68 = *(void **)(v134 + 208);
    if (v66 == *(void *)(v134 + 224)) {
      break;
    }
LABEL_19:
    char v70 = *(void *)(v65 + 24);
    if (!v70) {
      goto LABEL_61;
    }
    if ((unint64_t)(v66 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_58:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    v71 = (void **)(v70 + 8 * v66);
    uint64_t v72 = *v71;
    *(void *)(v65 + 216) = v66 + 1;
    swift_unknownObjectRetain(v72, v56, v57, v58);
    uint64_t v73 = (swift *)objc_msgSend(v68, sel_objectForKey_, v72);
    if (!v73)
    {
      v117 = 784LL;
      goto LABEL_63;
    }

    uint64_t v74 = v73;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v67, (uint64_t *)v67))
    {
      uint64_t v160 = (swift *)v72;
      v75 = v153;
      swift_dynamicCast(v153, (uint64_t *)&v160, v130, v67, 7uLL);
    }

    else
    {
      v150 = v50;
      v158 = TupleTypeMetadata2;
      v108 = v119;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v148 + 56))(v119, 1LL, 1LL, v67);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v72, (uint64_t)v67, v108);
      v109 = v72;
      uint64_t v110 = v108;
      swift_unknownObjectRelease(v109);
      v111 = v123;
      v112 = v120;
      (*(void (**)(char *, uint64_t *))(v124 + 16))(v123, v110);
      (*(void (**)(uint64_t *, uint64_t))(v124 + 8))(v110, v112);
      v75 = v153;
      (*(void (**)(char *, char *, char *))(v148 + 32))(v153, v123, v67);
      TupleTypeMetadata2 = v158;
      v50 = v150;
    }

    unint64_t v76 = &v75[*((int *)TupleTypeMetadata2 + 12)];
    v77 = (const char *)v151;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v151, v151))
    {
      uint64_t v160 = v74;
      swift_dynamicCast(v76, (uint64_t *)&v160, (swift *)&unk_189B8D230, v77, 7uLL);
    }

    else
    {
      (*(void (**)(uint64_t *, uint64_t, uint64_t, const char *))(v156 + 56))(v61, 1LL, 1LL, v77);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v74, (uint64_t)v77, v61);
      swift_unknownObjectRelease(v74);
      v113 = v61;
      v114 = v121;
      v115 = v122;
      (*(void (**)(char *, uint64_t *, uint64_t))(v23 + 16))(v121, v113, v122);
      if ((*(unsigned int (**)(char *, uint64_t, const char *))(v156 + 48))(v114, 1LL, v77) == 1) {
LABEL_64:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      (*(void (**)(uint64_t *, uint64_t))(v23 + 8))(v146, v115);
      (*(void (**)(char *, char *, const char *))(v156 + 32))(v76, v114, v77);
    }

    unint64_t v62 = v153;
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v60 + 56))(v153, 0LL, 1LL, TupleTypeMetadata2);
    unint64_t v157 = v50;
    v158 = v152;
LABEL_38:
    (*(void (**)(char *, char *, unint64_t *))(v60 + 32))(v20, v62, TupleTypeMetadata2);
    uint64_t v91 = &v20[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v92 = v143;
    v93 = v159;
    v144(v91);
    char v159 = v93;
    if (v93)
    {
      (*(void (**)(char *, unint64_t *))(v60 + 8))(v20, TupleTypeMetadata2);
      swift_release((uint64_t)v161);
      return (__objc2_class **)outlined consume of [A : B].Iterator._Variant<A, B>(v142);
    }

    unint64_t v94 = v139;
    char v95 = v154;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v139 + 48))(v92, 1LL, v154) == 1)
    {
      (*(void (**)(char *, unint64_t *))(v60 + 8))(v20, TupleTypeMetadata2);
      (*(void (**)(char *, uint64_t))(v132 + 8))(v92, v133);
      v50 = v157;
      uint64_t v59 = v158;
      uint64_t v34 = v151;
      char v51 = v142;
    }

    else
    {
      v96 = *(void (**)(char *, char *, uint64_t))(v94 + 32);
      uint64_t v97 = v20;
      uint64_t v98 = v131;
      v96(v131, v92, v95);
      uint64_t v99 = v140 + *((int *)TupleTypeMetadata2 + 12);
      v100 = v97;
      unint64_t v101 = (unint64_t)v155;
      (*(void (**)(void))(v148 + 32))();
      char v102 = v91;
      v103 = v151;
      (*(void (**)(uint64_t, char *, uint64_t *))(v156 + 32))(v99, v102, v151);
      v96(v141, v98, v95);
      v104 = v161;
      char v105 = v161[2];
      if (v161[3] <= v105)
      {
        v106 = (Swift::Int)&v105->isa + 1;
        type metadata accessor for _NativeDictionary(0LL, v101, v154, v138);
        v107 = v106;
        char v95 = v154;
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v107, 1);
        v104 = v161;
      }

      _NativeDictionary._unsafeInsertNew(key:value:)(v140, (uint64_t)v141, v104, v101, v95, v138);
      uint64_t v34 = v103;
      (*(void (**)(uint64_t, uint64_t *))(v156 + 8))(v99, v103);
      v50 = v157;
      uint64_t v59 = v158;
      uint64_t v60 = v149;
      uint64_t v20 = v100;
      uint64_t v23 = v147;
      char v51 = v142;
    }
  }

  uint64_t v69 = objc_msgSend(*(id *)(v134 + 208), sel_countByEnumeratingWithState_objects_count_, v127, v126, 16);
  unint64_t v65 = v134;
  *(void *)(v134 + 224) = v69;
  if (v69)
  {
    char v66 = 0LL;
    *(void *)(v65 + 216) = 0LL;
    goto LABEL_19;
  }

  *(void *)(v65 + 216) = -1LL;
LABEL_54:
  unint64_t v62 = v153;
LABEL_55:
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v60 + 56))(v62, 1LL, 1LL, TupleTypeMetadata2);
  outlined consume of [A : B].Iterator._Variant<A, B>(v51);
  return v161;
}

    (*(void (**)(char *, char *, uint64_t))(v118 + 32))(v65, v62, v119);
    unint64_t v76 = &v65[*((int *)TupleTypeMetadata2 + 12)];
    v77 = v10;
    char v78 = TupleTypeMetadata2;
    v79 = v9;
    v80 = v125;
    uint64_t v81 = v126;
    v82 = v121;
    (*(void (**)(char *, char *, uint64_t *))(v126 + 32))(v121, v65, v125);
    unint64_t v83 = v124;
    v84 = *(void (**)(char *, char *, char *))(v124 + 32);
    v85 = v122;
    v127 = v64;
    v86 = v123;
    v84(v122, v76, v123);
    v87 = *(void *)(v116 + 64);
    uint64_t v88 = *(_OWORD *)(v116 + 16);
    v130[0] = *(_OWORD *)v116;
    v130[1] = v88;
    uint64_t v89 = *(_OWORD *)(v116 + 48);
    v130[2] = *(_OWORD *)(v116 + 32);
    v130[3] = v89;
    uint64_t v131 = v87;
    (*(void (**)(_OWORD *, uint64_t *))(v113 + 24))(v130, v80);
    uint64_t v90 = *(void (**)(char *, uint64_t *))(v81 + 8);
    uint64_t v9 = v79;
    TupleTypeMetadata2 = v78;
    unint64_t v10 = v77;
    v90(v82, v80);
    (*(void (**)(_OWORD *, char *))(v114 + 24))(v130, v86);
    uint64_t v25 = v86;
    (*(void (**)(char *, char *))(v83 + 8))(v85, v86);
    v46 = Hasher._finalize()();
    uint64_t v40 = v128;
    v50 = v46 ^ v129;
    char v51 = v127;
    uint64_t v41 = v115;
  }

  outlined consume of [A : B].Iterator._Variant<A, B>(v115);
  Hasher._combine(_:)(v129);
}

        v100 = (uint64_t)v152;
        unint64_t v101 = (uint64_t)v161;
        (*(void (**)(char *, char *, uint64_t *))(v158 + 32))(v152, v163, v161);
        v104 = type metadata accessor for Array(0LL, v101, v102, v103);
        Array.append(_:)(v100, v104);
        char v105 = v162[2];
        uint64_t v45 = v159;
        if (v159 >= v105) {
          break;
        }
        uint64_t v44 = v37[2];
      }

      while (v169 < v44);
      if (v159 >= v105) {
        goto LABEL_46;
      }
LABEL_45:
      swift_release((uint64_t)v37);
      v108 = v161;
      v107 = v162;
      *(void *)&v170[0] = v162;
      v111 = type metadata accessor for ContiguousArray(0LL, (uint64_t)v161, v109, v110);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v111, v112);
      specialized MutableCollection.subscript.getter(v45, v111, WitnessTable);
      v114 = (uint64_t)v107;
      goto LABEL_48;
    }

    char v169 = 0LL;
    uint64_t v45 = 0LL;
    if (v43 > 0) {
      goto LABEL_45;
    }
  }

  else
  {
    char v169 = 0LL;
  }

        if ((rawBits & 0xC) == v15)
        {
          v40._rawBits = rawBits;
          v79 = v15;
          v86 = a2;
          v93 = v20;
          v100 = v19;
          v108 = a5;
          uint64_t v41 = v13;
          uint64_t v42 = v16;
          uint64_t v72 = v17;
          uint64_t v43 = v18;
          v44._rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v40)._rawBits;
          uint64_t v20 = v93;
          uint64_t v19 = v100;
          a5 = v108;
          uint64_t v18 = v43;
          uint64_t v17 = v72;
          uint64_t v15 = v79;
          uint64_t v16 = v42;
          uint64_t v13 = v41;
          a2 = v86;
          rawBits = v44._rawBits;
        }

        uint64_t v36 = rawBits >> 16;
        if (rawBits >> 16 >= v19) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
        }
        if ((a7 & 0x1000000000000000LL) != 0)
        {
          uint64_t v45 = rawBits;
          unint64_t v101 = v19;
          v109 = a5;
          v46 = a2;
          uint64_t v60 = v18;
          char v66 = v13;
          uint64_t v47 = v15;
          char v57 = v16;
          uint64_t v48 = v17;
          unint64_t v94 = v20;
          uint64_t v49 = specialized String.UTF16View._foreignIndex(after:)(v45);
          uint64_t v20 = v94;
          uint64_t v19 = v101;
          a5 = v109;
          uint64_t v16 = v57;
          uint64_t v18 = v60;
          uint64_t v17 = v48;
          uint64_t v15 = v47;
          uint64_t v13 = v66;
          a2 = v46;
          rawBits = v49;
          goto LABEL_58;
        }

        if (v20)
        {
          rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
          goto LABEL_58;
        }

        if ((rawBits & 0xC001) != 0)
        {
          if ((a7 & 0x2000000000000000LL) == 0) {
            goto LABEL_44;
          }
        }

        else
        {
          v50._rawBits = rawBits;
          uint64_t v81 = v15;
          uint64_t v88 = a2;
          v103 = v19;
          v111 = a5;
          char v51 = v13;
          uint64_t v52 = v16;
          uint64_t v74 = v17;
          uint64_t v53 = v18;
          v54._rawBits = _StringGuts.scalarAlignSlow(_:)(v50)._rawBits;
          uint64_t v20 = 0;
          uint64_t v19 = v103;
          a5 = v111;
          uint64_t v18 = v53;
          uint64_t v17 = v74;
          uint64_t v15 = v81;
          uint64_t v16 = v52;
          uint64_t v13 = v51;
          a2 = v88;
          rawBits = v54._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
          uint64_t v36 = v54._rawBits >> 16;
          if ((a7 & 0x2000000000000000LL) == 0)
          {
LABEL_44:
            uint64_t v37 = (unsigned __int8 *)v18;
            if ((a6 & 0x1000000000000000LL) == 0)
            {
              v82 = v15;
              uint64_t v89 = a2;
              v104 = v19;
              v112 = a5;
              uint64_t v68 = v13;
              v75 = v17;
              uint64_t v55 = v16;
              unint64_t v62 = v18;
              v96 = v20;
              uint64_t v37 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a6, a7);
              uint64_t v20 = v96;
              uint64_t v19 = v104;
              a5 = v112;
              uint64_t v18 = v62;
              uint64_t v13 = v68;
              uint64_t v17 = v75;
              uint64_t v15 = v82;
              uint64_t v16 = v55;
              a2 = v89;
            }

            uint64_t v38 = v37[v36];
            if ((v38 & 0x80) == 0)
            {
LABEL_56:
              uint64_t v39 = 1LL;
              goto LABEL_57;
            }

            goto LABEL_47;
          }
        }

        v113 = a6;
        v114 = v17;
        uint64_t v38 = *((unsigned __int8 *)&v113 + v36);
        if ((v38 & 0x80) == 0) {
          goto LABEL_56;
        }
LABEL_47:
        LODWORD(v39) = __clz(v38 ^ 0xFF) - 24;
        if ((_DWORD)v39 != 4)
        {
          uint64_t v39 = v39;
          goto LABEL_57;
        }

        if ((rawBits & 0xC000) != 0)
        {
          uint64_t v39 = 4LL;
LABEL_57:
          rawBits = (rawBits + (v39 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
          goto LABEL_58;
        }

        rawBits = rawBits & 0xFFFFFFFFFFFF0000LL | 0x4004;
LABEL_58:
        *(_WORD *)(a2 + 2 * v12++) = v33;
        if (a3 == v12) {
          goto LABEL_63;
        }
      }
    }

    rawBits = a4._rawBits;
LABEL_63:
    uint64_t v12 = a3;
  }

  else
  {
    uint64_t v12 = 0LL;
    rawBits = a4._rawBits;
  }

    v50 = (v30 - 1) & v30;
    char v51 = v31;
  }

  uint64_t v32 = v29 + 2;
  if (v32 >= v49) {
    return;
  }
  uint64_t v30 = *(void *)(v45 + 8 * v32);
  if (v30)
  {
    uint64_t v31 = v32;
    goto LABEL_36;
  }

  while (1)
  {
    uint64_t v31 = v32 + 1;
    if (__OFADD__(v32, 1LL)) {
      break;
    }
    if (v31 >= v49) {
      return;
    }
    uint64_t v30 = *(void *)(v45 + 8 * v31);
    ++v32;
    if (v30) {
      goto LABEL_36;
    }
  }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1E1uLL,  0);
    }

    v69(v85, v5);
  }

  v104 = v67(v5, v7);
  v69(v71, v5);
  char v105 = v3[4];
  *(_DWORD *)v3 |= v104 << v105;
  id result = (*(uint64_t (**)(uint64_t))(v112 + 56))(v5);
  v3[4] = v105 + result;
  return result;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from a String containing more than one extended grapheme cluster",  87LL,  2,  "Swift/Character.swift",  21LL,  2,  0xB1uLL,  0);
  }

  if (v6 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Allocation capacity must be greater than or equal to zero",  57LL,  2,  "Swift/TemporaryAllocation.swift",  31LL,  2,  0x29uLL,  0);
  }
  if (v6 + 0x4000000000000000LL < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Allocation byte count too large",  31LL,  2,  "Swift/TemporaryAllocation.swift",  31LL,  2,  0x2EuLL,  0);
  }
  uint64_t v20 = endingAt;
  if (2 * v6 <= 1024 || (startingAt = swift_stdlib_isStackAllocationSafe(), (startingAt & 1) != 0))
  {
    MEMORY[0x1895F8858](startingAt);
    uint64_t v22 = (char *)v57 - v21;
    if (v5 <= v20)
    {
      if (v7)
      {
        __break(1u);
      }

      else
      {
        objc_msgSend((id)(v4 & 0xFFFFFFFFFFFFFFFLL), sel_getCharacters_range_, v22, v5, v6);
        v57[0] = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v6,  0,  (uint64_t)&_swiftEmptyArrayStorage);
        specialized transcode<A, B, C>(_:from:to:stoppingOnError:into:)((uint64_t)v22, (uint64_t)&v22[2 * v6], 0LL, v57);
        uint64_t v23 = (uint8x16_t *)v57[0];
        v24 = *(void *)(v57[0] + 16);
        swift_bridgeObjectRetain(v57[0], v25, v26, v27);
        uint64_t v14 = specialized static String._uncheckedFromUTF8(_:)(v23 + 2, v24);
        uint64_t v15 = v28;
        LOBYTE(v20) = 2;
        swift_bridgeObjectRelease_n((uint64_t)v23, 2LL);
        if ((v15 & 0x2000000000000000LL) != 0) {
          uint64_t v32 = HIBYTE(v15) & 0xF;
        }
        else {
          uint64_t v32 = v14 & 0xFFFFFFFFFFFFLL;
        }
        if (v32)
        {
          swift_bridgeObjectRetain(v15, v29, v30, v31);
          v33._rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15LL)._rawBits;
          uint64_t v34 = String._uncheckedIndex(after:)(v33)._rawBits;
          swift_bridgeObjectRelease(v15);
          if (v34 >> 14 != 4 * v32) {
            goto LABEL_36;
          }
          if (!(v15 & 0x2000000000000000LL | v14 & 0x1000000000000000LL))
          {
            uint64_t v14 = specialized static String._copying(_:)(v14, v15);
            uint64_t v52 = v51;
            swift_bridgeObjectRelease(v15);
            uint64_t v15 = v52;
          }

          goto LABEL_35;
        }
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from an empty String",  43LL,  2,  "Swift/Character.swift",  21LL,  v20,  0xAFuLL,  0);
    }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  return 1LL;
}

        if (!_swift_stdlib_isLinkingConsonant(a2)) {
          goto LABEL_32;
        }
LABEL_37:
        swift_bridgeObjectRetain(a5, v19, v20, v21);
        uint64_t v23 = specialized _StringGuts.checkIfInIndicSequence(at:with:)(a3, (uint64_t)a4, a5);
        goto LABEL_38;
      }

      if (v13 != 8)
      {
        if (v13 == 7)
        {
LABEL_14:
          swift_bridgeObjectRelease_n(a5, 4LL);
          goto LABEL_15;
        }

  uint64_t v15 = v22;
  if (v22 == &v19)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &v19;
  }

  else
  {
    if (!v22) {
      goto LABEL_41;
    }
    uint64_t v16 = 5LL;
  }

  ((void (*)(uint64_t (***)()))(*v15)[v16])(v15);
LABEL_41:
  id result = v24;
  if (v24 == v23)
  {
    uint64_t v18 = 4LL;
    id result = v23;
  }

  else
  {
    if (!v24) {
      return result;
    }
    uint64_t v18 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void *))(*result + 8 * v18))(result);
}

        uint64_t v27 = v26;
        v24[0] = off_189B8DCF8;
        uint64_t v25 = v24;
        v26[0] = off_189B8DCB0;
        swift_getTypeByMangledNode( 0LL,  (uint64_t)v32,  (swift::Demangle::__runtime::Node *)TypeByMangledNameUntrusted,  0LL,  v26,  v24,  (uint64_t)v28);
        if (v29 == 1)
        {
          ((void (*)(void, uint64_t, void))v28[1])(v28[0], 3LL, 0LL);
          TypeByMangledNameUntrusted = 0LL;
        }

        else
        {
          TypeByMangledNameUntrusted = 0LL;
          if (!v29) {
            TypeByMangledNameUntrusted = v28[0];
          }
        }

        uint64_t v18 = v25;
        if (v25 == v24)
        {
          uint64_t v19 = 4LL;
          uint64_t v18 = v24;
        }

        else
        {
          if (!v25) {
            goto LABEL_45;
          }
          uint64_t v19 = 5LL;
        }

        (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_45:
        uint64_t v20 = v27;
        if (v27 == v26)
        {
          uint64_t v21 = 4LL;
          uint64_t v20 = v26;
        }

        else
        {
          if (!v27)
          {
LABEL_50:
            uint64_t v17 = 1;
LABEL_51:
            v32[0] = off_189B8E500;
            uint64_t v22 = v71;
            if (v71 == v70)
            {
              uint64_t v23 = 4LL;
              uint64_t v22 = v70;
            }

            else
            {
              if (!v71) {
                goto LABEL_56;
              }
              uint64_t v23 = 5LL;
            }

            (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_56:
            v32[0] = off_189B8E4D8;
            swift::Demangle::__runtime::NodeFactory::freeSlabs(v33);
            if (v35) {
              *(_BYTE *)(v35 + 48) = 0;
            }
            if ((v17 & 1) == 0) {
              return 0LL;
            }
            goto LABEL_14;
          }

          uint64_t v21 = 5LL;
        }

        (*(void (**)(void))(*v20 + 8 * v21))();
        goto LABEL_50;
      default:
        goto LABEL_36;
    }

    uint64_t v16 = TypeByMangledNameUntrusted;
    goto LABEL_34;
  }

  uint64_t v4 = 0LL;
  BOOL v6 = 0LL;
LABEL_9:
  if (swift::Demangle::__runtime::getManglingPrefixLength((uint64_t)__s, v6)
    || (*__s & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1895F8770] + 4LL * *__s + 60) & 0x400) != 0
    || strchr(__s, 46))
  {
    TypeByMangledNameUntrusted = swift_stdlib_getTypeByMangledNameUntrusted((unsigned __int8 *)__s, v4);
LABEL_14:
    if (TypeByMangledNameUntrusted)
    {
      ObjCClassFromMetadataConditional = (objc_class *)swift::swift_getObjCClassFromMetadataConditional((void *)TypeByMangledNameUntrusted);
      if (ObjCClassFromMetadataConditional)
      {
        *a2 = ObjCClassFromMetadataConditional;
        return 1LL;
      }
    }
  }

  return OldGetClassHook(__s, a2);
}

  while (v25 != v27)
  {
    uint64_t v28 = *v25++;
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v10, v28, a1, a4, a5);
  }

  return v10;
}

    abort();
  }

  if (*((_BYTE *)a1 + 18) == 5) {
    a1 = (void *)*a1;
  }
  BOOL v6 = a1[1];
  int v7 = *(void *)(v6 + 8);
  if (v7 > 0x7FFFFFFFFFFFFFF7LL) {
    goto LABEL_36;
  }
  uint64_t v8 = *(const void **)v6;
  uint64_t v9 = *(void *)*a1 + 1LL;
  if (v7 >= 0x17)
  {
    uint64_t v14 = (v7 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v14 = v7 | 7;
    }
    uint64_t v15 = v14 + 1;
    p_dst = (std::string *)operator new(v14 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__l.__cap_ = v15 | 0x8000000000000000LL;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_22;
  }

  __dst.__r_.__value_.__s.__size_ = *(void *)(v6 + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_22:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  uint64_t v16 = std::string::append(&__dst, " #");
  cap = v16->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__l.__cap_ = cap;
  v16->__r_.__value_.__l.__size_ = 0LL;
  v16->__r_.__value_.__l.__cap_ = 0LL;
  v16->__r_.__value_.__r.__words[0] = 0LL;
  std::to_string(&__p, v9);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size = __p.__r_.__value_.__s.__size_;
  }
  else {
    size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v20 = std::string::append(&v23, (const std::string::value_type *)p_p, size);
  *(std::string *)a2 = *v20;
  v20->__r_.__value_.__r.__words[0] = 0LL;
  v20->__r_.__value_.__l.__size_ = 0LL;
  v20->__r_.__value_.__l.__cap_ = 0LL;
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (((char)v23.__r_.__value_.__s.__size_ & 0x80000000) == 0)
    {
LABEL_31:
LABEL_35:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return;
    }
  }

  else if (((char)v23.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    goto LABEL_31;
  }

  operator delete(v23.__r_.__value_.__l.__data_);
}

  v21[0] = &v22;
  v21[1] = this;
  v21[2] = &v24;
  v21[3] = &v23;
  v21[4] = &v25;
  v21[5] = &v26;
  if (v15 != v11)
  {
    uint64_t v18 = *v15;
    uint64_t v17 = v15 + 1;
    while (v17 != v11)
    {
      if (v25) {
        uint64_t v19 = ", ";
      }
      else {
        uint64_t v19 = "";
      }
      std::string::append(this, v19, 2LL * v25);
      uint64_t v20 = *v17++;
    }
  }

  std::string::push_back(this, 41);
}

  v4[3184] = v10 + 1;
  v12[v10] = 121;
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

  *(_DWORD *)(v5 + 12736) = v13 + 1;
  v15[v13] = 117;
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

  *(_DWORD *)(v5 + 12736) = v13 + 1;
  v15[v13] = 99;
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

    uint64_t v21 = a5 + 1;
    while (1)
    {
      if (*((_WORD *)*v18 + 8) == 217)
      {
        if (*(_DWORD *)a6) {
          return result;
        }
      }

      if (++v18 == v20) {
        goto LABEL_41;
      }
    }
  }

  if (v12 == 2)
  {
    uint64_t v15 = (swift::Demangle::__runtime::Node **)(a2 + 16);
    if (v13 != (swift::Demangle::__runtime::Node **)(a2 + 16)) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }

  if (v12 != 5)
  {
    uint64_t v15 = 0LL;
    if (v13) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }

  uint64_t v14 = *(swift::Demangle::__runtime::Node **)a2;
LABEL_9:
  uint64_t v15 = (swift::Demangle::__runtime::Node **)((char *)v14 + 8 * *(unsigned int *)(a2 + 8));
  if (v13 == v15) {
    goto LABEL_21;
  }
LABEL_18:
  while (1)
  {
    if (*((_WORD *)*v13 + 8) != 217)
    {
      if (*(_DWORD *)a6) {
        return result;
      }
    }

    if (++v13 == v15) {
      goto LABEL_21;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

  uint64_t v25 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v22 == v24) {
      goto LABEL_39;
    }
  }

LABEL_58:
  v138 = *(void (**)(char *, char *, uint64_t))(v55 + 32);
  v24 = v209;
  v138(v209, v206, a2);
  uint64_t v16 = v210;
  char v139 = (*((uint64_t (**)(uint64_t, char *))v210 + 8))(a2, v210);
  v140 = v207;
  uint64_t v19 = v208;
  v215 = (char *)v138;
  if ((v139 & 1) != 0)
  {
    uint64_t v141 = v218;
    uint64_t v142 = v217(a2, v218);
    if (!__OFSUB__(v142, 1LL))
    {
      v220[0] = v142 - 1;
      v145 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v16 + 12);
      unint64_t v146 = lazy protocol witness table accessor for type Int and conformance Int(v142, v143, v144);
      v145(v220, &type metadata for Int, v146, a2, v16);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v141 + 200))(v24, v19, a2, v141);
      uint64_t v147 = v216;
      (*(void (**)(char *, uint64_t))(v216 + 8))(v19, a2);
      unint64_t v148 = v205;
      unint64_t v149 = swift_getAssociatedConformanceWitness( (uint64_t)v140,  a2,  v205,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v150 = v204;
      goto LABEL_62;
    }

    __break(1u);
LABEL_87:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

  unint64_t v151 = v205;
  unint64_t v149 = swift_getAssociatedConformanceWitness( (uint64_t)v207,  a2,  v205,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v150 = v204;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v149 + 8))( &unk_18180BE68,  256LL,  v151,  v149);
  (*((void (**)(char *, uint64_t, const char *))v140 + 3))(v150, a2, v140);
  unint64_t v148 = v151;
  uint64_t v147 = v216;
LABEL_62:
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v149 + 8))( &unk_18180BE68,  256LL,  v148,  v149);
  (*((void (**)(char *, uint64_t, const char *))v140 + 3))(v150, a2, v140);
  uint64_t v8 = *(void (**)(char *, uint64_t))(v147 + 8);
  if ((v49 & 0x8000000000000000LL) == 0)
  {
    v8(v213, a2);
    uint64_t v152 = v218;
    if (v49 < v217(a2, v218))
    {
      uint64_t v153 = ((uint64_t (*)(char *, uint64_t))v8)(v214, a2);
      v220[0] = v49;
      v154 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v16 + 12);
      unint64_t v157 = lazy protocol witness table accessor for type Int and conformance Int(v153, v155, v156);
      v154(v220, &type metadata for Int, v157, a2, v16);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v152 + 216))(v24, v19, a2, v152);
LABEL_65:
      v8(v19, a2);
      return ((uint64_t (*)(char *, uint64_t))v8)(v24, a2);
    }

    v8(v24, a2);
    uint64_t v188 = v203;
    v189 = v214;
    return ((uint64_t (*)(uint64_t, char *, uint64_t))v215)(v188, v189, a2);
  }

  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v12;
}

        v193 = v329;
        ((void (**)(char *, char *, unint64_t *))v336)[4](v329, v182, v45);
        v194 = (*(uint64_t (**)(unint64_t *, uint64_t))(v178 + 120))(v45, v178);
        ((void (*)(char *, unint64_t *))v181)(v193, v45);
        if (v187 == v194) {
          goto LABEL_69;
        }
        goto LABEL_59;
      }

      if (v189 <= 63) {
        goto LABEL_58;
      }
      v234 = v295;
      ((void (**)(char *, char *, unint64_t *))v336)[4](v295, v182, v45);
      if ((v187 & 0x8000000000000000LL) == 0)
      {
        v344 = v187;
        v235 = v329;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v178 + 96))( &v344,  &type metadata for Int,  v333,  v45,  v178);
        v191 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v178 + 16) + 8LL)
                                                                             + 8LL))( v235,  v234,  v45);
        ((void (*)(char *, unint64_t *))v181)(v235, v45);
        v192 = v234;
LABEL_68:
        ((void (*)(char *, unint64_t *))v181)(v192, v45);
        if ((v191 & 1) != 0)
        {
LABEL_69:
          ((void (*)(char *, unint64_t *))v181)(v342, v45);
          v236 = v324;
          v237 = v334;
          v238 = v304;
          v239 = swift_getAssociatedConformanceWitness( (uint64_t)v324,  v334,  v304,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v240 = v322;
          (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v239 + 8))( &unk_18180BE68,  256LL,  v238,  v239);
          v241 = v323;
          (*((void (**)(char *, uint64_t, const char *))v236 + 3))(v240, v237, v236);
          LOBYTE(v238) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v179 + 24) + 8LL)
                                                                             + 16LL))( v340,  v241,  v237);
          ((void (*)(char *, uint64_t))v306)(v241, v237);
          v242 = *(void (**)(char *, char *, unint64_t *))(v328 + 32);
          v243 = v292;
          v244 = v341;
          v242(v292, v332, v341);
          if ((v238 & 1) == 0)
          {
            (*(void (**)(char *, unint64_t *))(v328 + 8))(v243, v244);
            goto LABEL_76;
          }

          v245 = v343;
          v246 = swift_getAssociatedConformanceWitness( v339,  v343,  (uint64_t)v244,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
          v247 = *(uint64_t (**)(unint64_t *, unint64_t))(v246 + 64);
          if ((v247(v244, v246) & 1) != 0)
          {
            if ((*(uint64_t (**)(unint64_t *, unint64_t))(v246 + 128))(v244, v246) < 64)
            {
LABEL_82:
              v268 = v292;
              v269 = v341;
              v270 = (*(uint64_t (**)(unint64_t *, unint64_t))(v246 + 120))(v341, v246);
              (*(void (**)(char *, unint64_t *))(v328 + 8))(v268, v269);
              if (!v270) {
                goto LABEL_88;
              }
              goto LABEL_76;
            }
          }

          else
          {
            v259 = v247(v244, v246);
            v260 = (*(uint64_t (**)(unint64_t *, unint64_t))(v246 + 128))(v244, v246);
            if ((v259 & 1) == 0)
            {
              if (v260 < 64) {
                goto LABEL_82;
              }
              v344 = 0LL;
              v283 = v327;
              v262 = v341;
              (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v246 + 96))( &v344,  &type metadata for Int,  v333,  v341,  v246);
              v284 = swift_getAssociatedConformanceWitness( v289,  v245,  (uint64_t)v262,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
              v285 = v292;
              v265 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v284 + 8) + 8LL))( v292,  v283,  v262);
              v266 = *(void (**)(char *, unint64_t *))(v328 + 8);
              v266(v285, v262);
              v267 = v283;
LABEL_87:
              v266(v267, v262);
              if ((v265 & 1) != 0)
              {
LABEL_88:
                v258 = v290;
                (*(void (**)(uint64_t))(v337 + 72))(v245);
                v254 = 0LL;
                v255 = v325;
                v256 = v326;
                v257 = v291;
                uint64_t v160 = v305;
                goto LABEL_89;
              }

  $defer #1 <A>() in _merge<A>(low:mid:high:buffer:by:)(&v77, &v76, &v75, a7);
  return 1LL;
}

  if (v16 < v20) {
    goto LABEL_66;
  }
  return (Swift::String::Index)(((v22 + v19) << 16) | 5);
}

    *(_DWORD *)(a3 + 24) = 0;
    goto LABEL_21;
  }

  swift::BuilderError::BuilderError((swift::BuilderError *)&v35, "Class dumping is not yet implemented");
  if ((char)v35.__r_.__value_.__s.__size_ < 0)
  {
    std::string::__init_copy_ctor_external(&__dst, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
    uint64_t v28 = 1;
    if ((char)v35.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(v35.__r_.__value_.__l.__data_);
      uint64_t v20 = v28;
      if (!v28) {
        goto LABEL_58;
      }
    }

    else
    {
      uint64_t v20 = 1;
    }
  }

  else
  {
    __dst = v35;
    uint64_t v28 = 1;
    uint64_t v20 = 1;
  }

  if (v20 == 1) {
    uint64_t v21 = &__dst;
  }
  else {
    uint64_t v21 = 0LL;
  }
  v24 = (uint64_t)&__dst.__r_.__value_.__r.__words[2] + 7;
  if (v20 != 1) {
    v24 = 23LL;
  }
  if (*(char *)v24 < 0)
  {
    uint64_t v23 = (const std::string::value_type *)v21->__r_.__value_.__r.__words[0];
    goto LABEL_60;
  }

        swift::Demangle::__runtime::Node::addChild( v32,  (swift::Demangle::__runtime::Node *)v44,  (swift::Demangle::__runtime::NodeFactory *)a1,  v35,  v36);
        ++v33;
        v43 -= 8LL;
        if (!v43) {
          goto LABEL_37;
        }
      }
    }

    *(_DWORD *)(a1 + 96) = v31 - 1;
    swift::Demangle::__runtime::Node::addChild( v32,  (swift::Demangle::__runtime::Node *)v34,  (swift::Demangle::__runtime::NodeFactory *)a1,  v35,  v36);
    if ((v34[8] & 0xFFFE) == 0xAA) {
      uint64_t v32 = (unsigned int *)v34;
    }
    uint64_t v31 = *(_DWORD *)(a1 + 96);
  }

  while (v31);
LABEL_37:
  uint64_t v37 = *(unsigned __int8 *)(v26 + 18);
LABEL_42:
  uint64_t v38 = v49;
  *(_OWORD *)(v49 + 88) = v50;
  *(_OWORD *)(v38 + 104) = v51;
  *(_DWORD *)(v38 + 536) = v52;
  *(_OWORD *)(v38 + 56) = v53;
  *(void *)(v38 + 72) = v54;
  uint64_t v39 = *(void **)(v38 + 568);
  *(void *)(v38 + 568) = 0LL;
  if (v39 == (void *)(v38 + 544))
  {
    uint64_t v40 = 4LL;
    uint64_t v39 = (void *)(v38 + 544);
LABEL_46:
    (*(void (**)(void))(*v39 + 8 * v40))();
  }

  else if (v39)
  {
    uint64_t v40 = 5LL;
    goto LABEL_46;
  }

  if (v56)
  {
    uint64_t v41 = v55;
    if (v56 == v55)
    {
      *(void *)(v38 + 568) = v38 + 544;
      (*(void (**)(void *, uint64_t))(v55[0] + 24LL))(v55, v38 + 544);
      if (v56 == v55)
      {
        uint64_t v42 = 4LL;
      }

      else
      {
        if (!v56) {
          return v26;
        }
        uint64_t v42 = 5LL;
        uint64_t v41 = v56;
      }

      (*(void (**)(void *))(*v41 + 8 * v42))(v41);
      return v26;
    }

    *(void *)(v38 + 568) = v56;
  }

  else
  {
    *(void *)(v38 + 568) = 0LL;
  }

  return v26;
}

    uint64_t v36 = v7->u32[2];
    if (v31 != v36)
    {
      uint64_t v37 = (void *)(v7->i64[0] + 8 * v36 - 8);
      if ((unint64_t)v37 > v7->i64[0] + 8 * v31)
      {
        uint64_t v38 = v7->i64[0] + 8 * v31 + 8;
        do
        {
          uint64_t v39 = *(void *)(v38 - 8);
          *(void *)(v38 - 8) = *v37;
          *v37-- = v39;
          uint64_t v40 = v38 >= (unint64_t)v37;
          v38 += 8LL;
        }

        while (!v40);
      }
    }

    return v7;
  }

  uint64_t v13 = *((void *)this + 8);
  uint64_t v12 = *((void *)this + 9);
  if (v12 < v13)
  {
    while (1)
    {
      uint64_t v14 = *((void *)this + 7);
      uint64_t v15 = *(unsigned __int8 *)(v14 + v12);
      switch(v15)
      {
        case '_':
          *((void *)this + 9) = v12 + 1;
          uint64_t v19 = 1;
          break;
        case 'z':
          uint64_t v19 = 0;
          *((void *)this + 9) = v12 + 1;
          break;
        case 'l':
          *((void *)this + 9) = v12 + 1;
          goto LABEL_39;
        default:
          uint64_t v16 = 0;
          while (1)
          {
            uint64_t v17 = *(unsigned __int8 *)(v14 + v12);
            uint64_t v18 = v17 + 10 * v16 - 48;
            if (v18 >= v16)
            {
              *((void *)this + 9) = ++v12;
              uint64_t v16 = v18;
              if (v13 != v12) {
                continue;
              }
            }

            return 0LL;
          }

          id result = 0LL;
          if (v16 < 0 || v12 >= v13 || v17 != 95) {
            return result;
          }
          *((void *)this + 9) = v12 + 1;
          uint64_t v19 = v16 + 2;
          break;
      }

      uint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v21 || v21 + 24 > *((void *)this + 2))
      {
        uint64_t v22 = 2LL * *((void *)this + 4);
        if (v22 <= 0x20) {
          uint64_t v22 = 32LL;
        }
        *((void *)this + 4) = v22;
        uint64_t v23 = v22 + 8;
        v24 = malloc(v22 + 8);
        char *v24 = *((void *)this + 3);
        uint64_t v21 = ((unint64_t)v24 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)this + 2) = (char *)v24 + v23;
        *((void *)this + 3) = v24;
      }

      *((void *)this + 1) = v21 + 24;
      *(_WORD *)(v21 + 16) = 37;
      *(_BYTE *)(v21 + 18) = 4;
      *(void *)uint64_t v21 = v19;
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v7,  (swift::Demangle::__runtime::Node *)v21,  this,  a4,  a5);
      id result = 0LL;
      uint64_t v13 = *((void *)this + 8);
      uint64_t v12 = *((void *)this + 9);
      if (v12 >= v13) {
        return result;
      }
    }
  }

  return 0LL;
}

      *(_DWORD *)a5 = 0;
      *(void *)(a5 + 8) = 0LL;
      *(_DWORD *)(a5 + 16) = 0;
      return;
    }

    if (v16 == 234)
    {
      uint64_t v35 = 0uLL;
      LOBYTE(v36) = 0;
      {
        if (*(_DWORD *)a5) {
          return;
        }
        swift::Demangle::__runtime::RemanglerBase::addSubstitution( (char *)a1,  (const swift::Demangle::__runtime::SubstitutionEntry *)&v35);
      }

      *(_DWORD *)a5 = 0;
      goto LABEL_58;
    }

    if (v16 != 232)
    {
LABEL_54:
      *(_DWORD *)a5 = 5;
      *(void *)(a5 + 8) = v5;
      *(_DWORD *)(a5 + 16) = 2375;
      return;
    }

    uint64_t v18 = *(unsigned __int8 *)(v5 + 18);
    if ((v18 - 1) >= 2)
    {
      if (v18 != 5 || !*(_DWORD *)(v5 + 8))
      {
        uint64_t v19 = 0LL;
LABEL_57:
        if (*(_DWORD *)a5) {
          return;
        }
        goto LABEL_58;
      }

      uint64_t v5 = *(void *)v5;
    }

    uint64_t v19 = *(void *)v5;
    goto LABEL_57;
  }

  unint64_t v10 = *(_DWORD *)(a1 + 12736);
  uint64_t v11 = *(unsigned int *)(a1 + 12740);
  uint64_t v12 = *(char **)(a1 + 12728);
  uint64_t v13 = *(void **)(a1 + 12744);
  uint64_t v14 = (char *)v13[1];
  if (&v12[v11] != v14)
  {
    uint64_t v15 = v13[2];
LABEL_22:
    LODWORD(v21) = 2 * v11;
    else {
      uint64_t v21 = v21;
    }
    uint64_t v34 = v21;
    uint64_t v22 = v21 + v11;
    uint64_t v23 = (unint64_t)&v14[v21 + v11];
    if (v14) {
      v24 = v23 > v15;
    }
    else {
      v24 = 1;
    }
    uint64_t v12 = (char *)v13[1];
    if (v24)
    {
      uint64_t v25 = 2LL * v13[4];
      if (v25 <= v22 + 1) {
        uint64_t v25 = v22 + 1;
      }
      v13[4] = v25;
      uint64_t v33 = a3;
      uint64_t v26 = v25 + 8;
      uint64_t v27 = malloc(v25 + 8);
      *uint64_t v27 = v13[3];
      uint64_t v12 = (char *)(v27 + 1);
      uint64_t v28 = (char *)v27 + v26;
      a3 = v33;
      v13[2] = v28;
      v13[3] = v27;
    }

    v13[1] = &v12[v22];
    if ((_DWORD)v11)
    {
      memcpy(v12, *(const void **)(a1 + 12728), v11);
      LODWORD(v11) = *(_DWORD *)(a1 + 12740);
      unint64_t v10 = *(_DWORD *)(a1 + 12736);
    }

    uint64_t v29 = v34;
    *(void *)(a1 + 12728) = v12;
    goto LABEL_36;
  }

  uint64_t v20 = (unint64_t)&v12[v11 + 1];
  uint64_t v15 = v13[2];
  if (v20 > v15) {
    goto LABEL_22;
  }
  v13[1] = v20;
  uint64_t v29 = 1;
LABEL_36:
  *(_DWORD *)(a1 + 12740) = v11 + v29;
LABEL_37:
  *(_DWORD *)(a1 + 12736) = v10 + 1;
  v12[v10] = 71;
  swift::Demangle::__runtime::getUnspecialized(v5, *(swift::Demangle::__runtime::Node **)a1, (uint64_t)&v35);
  if ((_DWORD)v35)
  {
    *(_OWORD *)a5 = v35;
    *(void *)(a5 + 16) = v36;
  }

  else
  {
    uint64_t v30 = a4 + 1;
    if (!*(_DWORD *)a5) {
  }
    }

LABEL_81:
  v8(v214, a2);
  uint64_t v181 = v218;
  uint64_t v182 = v217(a2, v218);
  if (__OFSUB__(0LL, v182))
  {
    __break(1u);
  }

  else if (-v182 < v49)
  {
    uint64_t v183 = ((uint64_t (*)(char *, uint64_t))v8)(v213, a2);
    v220[0] = -v49;
    v184 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v16 + 12);
    unint64_t v187 = lazy protocol witness table accessor for type Int and conformance Int(v183, v185, v186);
    v184(v220, &type metadata for Int, v187, a2, v16);
    (*(void (**)(char *, char *, uint64_t, uint64_t))(v181 + 200))(v24, v19, a2, v181);
    goto LABEL_65;
  }

  v8(v24, a2);
  uint64_t v188 = v203;
  v189 = v213;
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v215)(v188, v189, a2);
}

        v573 = 0LL;
        v310 = v566;
        v311 = v558;
        v312 = v568;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v566 + 96))( &v573,  &type metadata for Int,  v545,  v568,  v566);
        v313 = v514;
        LOBYTE(v310) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v310 + 32) + 8LL)
                                                                          + 16LL))( v514,  v311,  v312);
        v314 = v311;
        v315 = v550;
        v550(v314, v312);
        v315(v313, v312);
        if ((v310 & 1) != 0) {
          goto LABEL_125;
        }
        goto LABEL_92;
      }

      v289 = v568;
      v292 = v514;
      if (v309 < 64)
      {
        v333 = (*(uint64_t (**)(uint64_t))(v566 + 120))(v568);
        v334 = v292;
        goto LABEL_124;
      }
    }

    v293 = v173;
    v550(v292, v289);
    goto LABEL_92;
  }

  v519 = v178;
  v514 = (char *)v184;
  v238 = v237(v235, v236);
  v528 = (char *)v173;
  v239 = v173 - v238;
  v240 = v525;
  v241 = v512;
  v242 = swift_getAssociatedConformanceWitness( (uint64_t)v525,  (uint64_t)v171,  v512,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v243 = v511;
  v527 = *(char **)(v242 + 8);
  ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v527)( &qword_18180BE70,  512LL,  v241,  v242);
  v244 = (uint64_t (*)(char *, unint64_t *, const char *))*((void *)v240 + 3);
  v245 = v523;
  id result = v244(v243, v171, v240);
  v549 = v239;
  v246 = v239 - 1;
  if (__OFSUB__(v239, 1LL))
  {
    __break(1u);
    goto LABEL_177;
  }

  v247 = v241;
  v248 = v243;
  v573 = v246;
  (*(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v172 + 256))( v245,  &v573,  &type metadata for Int,  v545,  v171,  v172);
  v541 = *(char **)(v531 + 8);
  ((void (*)(char *, unint64_t *))v541)(v245, v171);
  v249 = v527;
  ((void (*)(void *, uint64_t, unint64_t, unint64_t))v527)(&unk_18180BE80, 768LL, v247, v242);
  v250 = v506;
  v244(v248, v171, v525);
  v520 = (char *)v244;
  v251 = (void (*)(uint64_t *, uint64_t, unint64_t, uint64_t (*)(void, void)))v249;
  v252 = (uint64_t (*)(uint64_t, const char *))v242;
  v253 = AssociatedConformanceWitness;
  (*(void (**)(char *, char *, unint64_t *, unint64_t))(AssociatedConformanceWitness + 64))( v250,  v524,  v171,  AssociatedConformanceWitness);
  ((void (*)(char *, unint64_t *))v541)(v250, v171);
  v518 = v252;
  v251(&qword_18180BE70, 512LL, v247, (uint64_t (*)(void, void))v252);
  ((void (*)(char *, unint64_t *, const char *))v520)(v248, v171, v525);
  v254 = v507;
  (*(void (**)(char *, char *, unint64_t *))(*(void *)(v253 + 8) + 40LL))(v245, v250, v171);
  v255 = (void (*)(char *, unint64_t *))v541;
  ((void (*)(char *, unint64_t *))v541)(v250, v171);
  v255(v245, v171);
  v256 = *(void (**)(char *, char *, unint64_t *, unint64_t))(v172 + 192);
  v257 = v172;
  v258 = v245;
  v259 = v522;
  v260 = v539;
  v256(v539, v254, v171, v257);
  v255(v254, v171);
  v573 = v549;
  (*(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v257 + 240))( v260,  &v573,  &type metadata for Int,  v545,  v171,  v257);
  v255(v260, v171);
  v261 = v562;
  v262 = *(void (**)(char *, unint64_t *, unint64_t, unint64_t *, uint64_t))(v562 + 96);
  v263 = v564;
  v549 = v257;
  v264 = v551;
  v262(v258, v171, v257, v551, v562);
  v265 = *(void (**)(char *, char *, unint64_t *, uint64_t))(v261 + 192);
  v265(v263, v572, v264, v261);
  v540(v263, v264);
  v266 = swift_getAssociatedConformanceWitness( v532,  v568,  (uint64_t)v171,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  v267 = v524;
  LOBYTE(v263) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v266 + 40))( v259,  v524,  v171,  v266);
  v268 = v531;
  v269 = v509;
  (*(void (**)(char *, char *, unint64_t *))(v531 + 16))(v509, v259, v171);
  v270 = v508;
  v271 = v267;
  v272 = *(void (**)(char *, char *, unint64_t *))(v268 + 32);
  v272(v508, v271, v171);
  v539 = (char *)v266;
  if ((v263 & 1) != 0)
  {
    v255(v270, v171);
    v255(v269, v171);
    goto LABEL_64;
  }

  v296 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v266 + 8) + 8LL))(v269, v270, v171);
  v255(v270, v171);
  v255(v269, v171);
  if ((v296 & 1) == 0) {
    goto LABEL_130;
  }
  v297 = v557;
  ((void (*)(uint64_t *, uint64_t))v556)(&qword_18180BE70, 512LL);
  v298 = v564;
  v299 = v551;
  v504(v297, v551, v571);
  v300 = v562;
  v265(v526, v298, v299, v562);
  v540(v298, v299);
  v301 = *(uint64_t (**)(unint64_t *, uint64_t))(v300 + 64);
  if ((v301(v299, v300) & 1) != 0)
  {
    goto LABEL_95;
  }

  v335 = v551;
  v336 = v562;
  v337 = v301(v551, v562);
  v338 = (*(uint64_t (**)(unint64_t *, uint64_t))(v336 + 128))(v335, v336);
  if ((v337 & 1) == 0)
  {
    if (v338 < 64)
    {
LABEL_107:
      v362 = *(uint64_t (**)(unint64_t *))(v562 + 120);
      v363 = &v535;
      goto LABEL_108;
    }

    v573 = 1LL;
    v406 = v564;
    v340 = v551;
    v407 = v562;
    v262((char *)&v573, (unint64_t *)&type metadata for Int, v545, v551, v562);
    v408 = v503;
    v343 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v407 + 16) + 8LL)
                                                                         + 8LL))( v503,  v406,  v340);
    v409 = v408;
    v344 = v540;
    v540(v409, v340);
    v345 = v406;
    goto LABEL_129;
  }

  if (v338 > 64)
  {
LABEL_95:
    v573 = 1LL;
    v339 = v564;
    v340 = v551;
    v341 = v562;
    v262((char *)&v573, (unint64_t *)&type metadata for Int, v545, v551, v562);
    v342 = v503;
    v343 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v341 + 16) + 8LL)
                                                                         + 8LL))( v503,  v339,  v340);
    v344 = v540;
    v540(v339, v340);
    v345 = v342;
LABEL_129:
    v344(v345, v340);
    if ((v343 & 1) != 0) {
      goto LABEL_64;
    }
LABEL_130:
    v410 = v572;
    v411 = v551;
    v412 = &v572;
    goto LABEL_131;
  }

  v402 = v557;
  ((void (*)(void *, uint64_t))v556)(&unk_18180BE68, 256LL);
  v403 = v564;
  v404 = v551;
  v504(v402, v551, v571);
  v405 = v503;
  LOBYTE(v402) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v562 + 32) + 8LL)
                                                                               + 32LL))( v503,  v403,  v404);
  v540(v403, v404);
  (*(void (**)(char *, char *, unint64_t *))(v559 + 32))(v486, v405, v404);
  if ((v402 & 1) == 0)
  {
    v540(v486, v551);
    goto LABEL_130;
  }

  v362 = *(uint64_t (**)(unint64_t *))(v562 + 120);
  v363 = (unint64_t **)&v518;
LABEL_108:
  v364 = (char *)*(v363 - 32);
  v365 = v551;
  v366 = v362(v551);
  v540(v364, v365);
  if (v366 != 1) {
    goto LABEL_130;
  }
LABEL_64:
  v273 = v557;
  ((void (*)(uint64_t *, uint64_t))v556)(&qword_18180BE70, 512LL);
  v274 = v560;
  v275 = v551;
  v504(v273, v551, v571);
  v276 = v564;
  v277 = v526;
  LOBYTE(v273) = (*(uint64_t (**)(char *, char *, unint64_t *))(v561 + 80))(v564, v274, v275);
  v278 = v274;
  v279 = v540;
  v540(v278, v275);
  v279(v277, v275);
  v280 = *(void (**)(char *, char *, unint64_t *))(v559 + 32);
  v280(v277, v276, v275);
  v281 = v502;
  v280(v502, v572, v275);
  if ((v273 & 1) != 0)
  {
    id result = ((uint64_t (*)(char *, unint64_t *))v279)(v281, v275);
  }

  else
  {
    v302 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v562 + 32) + 8LL)
                                                                         + 40LL))( v526,  v281,  v275);
    id result = ((uint64_t (*)(char *, unint64_t *))v279)(v281, v275);
    v303 = v566;
    if ((v302 & 1) == 0) {
      goto LABEL_132;
    }
  }

  if (!__OFADD__(v528++, 1LL))
  {
    v305 = v493;
    v306 = (uint64_t)v567;
    v307 = v538;
    v547(v567, v538);
    ((void (*)(uint64_t, uint64_t))v546)(v306, v307);
    v534(v305, v306);
    if ((v519() & 1) != 0)
    {
      if (v548(v533, v536) < 64) {
        goto LABEL_98;
      }
LABEL_85:
      v573 = (uint64_t)v528;
      v320 = v536;
      v321 = v521;
      v322 = v533;
      (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v536 + 96))( &v573,  &type metadata for Int,  v545,  v533,  v536);
      v323 = v513;
      LOBYTE(v320) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v320 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v513,  v321,  v322);
      v324 = v321;
      v325 = v514;
      ((void (*)(char *, unint64_t *))v514)(v324, v322);
      ((void (*)(char *, unint64_t *))v325)(v323, v322);
      v303 = v566;
      if ((v320 & 1) == 0) {
        goto LABEL_132;
      }
      goto LABEL_114;
    }

    v316 = v533;
    v317 = v536;
    v318 = ((uint64_t (*)(unint64_t *, uint64_t))v519)(v533, v536);
    v319 = v548(v316, v317);
    if ((v318 & 1) != 0)
    {
      if (v319 <= 64)
      {
        v367 = (void (**)(char *, unint64_t *, const char *))v500;
        v368 = v533;
        v369 = v499;
        v370 = swift_getAssociatedConformanceWitness( (uint64_t)v500,  (uint64_t)v533,  v499,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v371 = v498;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v370 + 8))( &unk_18180BE68,  256LL,  v369,  v370);
        v372 = v521;
        v367[3](v371, v368, (const char *)v367);
        v373 = v513;
        LOBYTE(v367) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v536 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v513,  v372,  v368);
        ((void (*)(char *, unint64_t *))v514)(v372, v368);
        (*(void (**)(char *, char *, unint64_t *))(v529 + 32))(v489, v373, v368);
        if ((v367 & 1) != 0)
        {
          ((void (*)(char *, unint64_t *))v514)(v489, v533);
          v303 = v566;
          goto LABEL_114;
        }

        v346 = *(uint64_t (**)(unint64_t *))(v536 + 120);
        v347 = (unint64_t *)&v521;
        goto LABEL_99;
      }

      goto LABEL_85;
    }

    if (v319 < 64)
    {
LABEL_98:
      v346 = *(uint64_t (**)(unint64_t *))(v536 + 120);
      v347 = &v545;
LABEL_99:
      v348 = *(v347 - 32);
      v349 = v533;
      v350 = v346(v533);
      ((void (*)(uint64_t, unint64_t *))v514)(v348, v349);
      v303 = v566;
      if (v350 >= (uint64_t)v528)
      {
LABEL_132:
        v413 = v568;
        v414 = v530;
        v415 = v530(v568, v303);
        (*(void (**)(char *, uint64_t, uint64_t))(v565 + 16))(v517, v569, v413);
        if ((v415 & 1) != 0)
        {
          v416 = v414;
          if ((v414(v413, v303) & 1) != 0)
          {
            if (v537(v568, v566) < 64)
            {
              v417 = *(uint64_t (**)(uint64_t))(v566 + 120);
              v418 = &v549;
LABEL_136:
              v419 = (char *)*(v418 - 32);
              v413 = v568;
              goto LABEL_143;
            }

            goto LABEL_139;
          }

          v420 = v568;
          v421 = v566;
          v422 = v416(v568, v566);
          v423 = v537(v420, v421);
          if ((v422 & 1) != 0)
          {
            if (v423 <= 64)
            {
              v464 = (void (**)(char *, uint64_t, const char *))v544;
              v465 = v568;
              v466 = v542;
              v467 = swift_getAssociatedConformanceWitness( (uint64_t)v544,  v568,  v542,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v468 = v543;
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v467 + 8))( &unk_18180BE68,  256LL,  v466,  v467);
              v469 = v558;
              v464[3](v468, v465, (const char *)v464);
              v470 = v517;
              LOBYTE(v464) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v566 + 32)
                                                                                            + 8LL)
                                                                                + 16LL))( v517,  v469,  v465);
              v550(v469, v465);
              (*(void (**)(char *, char *, uint64_t))(v565 + 32))(v487, v470, v465);
              if ((v464 & 1) != 0)
              {
                v550(v487, v568);
                v431 = 1LL;
                goto LABEL_147;
              }

              v417 = *(uint64_t (**)(uint64_t))(v566 + 120);
              v418 = (uint64_t *)&v519;
              goto LABEL_136;
            }

  v8(v246, a3);
  v208 = v248;
  v209 = ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v248);
  if (__OFSUB__(0LL, v209))
  {
    __break(1u);
  }

  else if (-v209 < v27)
  {
    v210 = v208;
    v211 = ((uint64_t (*)(char *, uint64_t))v8)(v245, a3);
    v252[0] = -v27;
    v212 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
    v215 = lazy protocol witness table accessor for type Int and conformance Int(v211, v213, v214);
    uint64_t v216 = v243;
    v212(v252, &type metadata for Int, v215, a3, v6);
    v217 = v236;
    (*(void (**)(char *, char *, uint64_t, uint64_t))(v210 + 200))(a2, v216, a3, v210);
    v8(v216, a3);
    v8(a2, a3);
    return ((uint64_t (*)(uint64_t, char *, uint64_t))v250)(v247, v217, a3);
  }

  v8(a2, a3);
  v220 = v236;
  v221 = v250;
  ((void (*)(char *, char *, uint64_t))v250)(v236, v245, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v221)(v247, v220, a3);
}

    swift_release(v5);
    goto LABEL_83;
  }

  if (v7 > v6) {
    uint64_t v8 = *(void *)(*v3 + 24);
  }
  uint64_t v9 = specialized static _HashTable.scale(forCapacity:)(v8);
  LOBYTE(v93) = 1;
  uint64_t v13 = specialized static _SetStorage.allocate(scale:age:seed:)(v9, 0x100000000LL, 0LL, 1);
  if (!*(void *)(v5 + 16)) {
    goto LABEL_81;
  }
  uint64_t v14 = 1LL << *(_BYTE *)(v5 + 32);
  uint64_t v15 = (void *)(v5 + 56);
  uint64_t v16 = -1LL;
  if (v14 < 64) {
    uint64_t v16 = ~(-1LL << v14);
  }
  uint64_t v17 = v16 & *(void *)(v5 + 56);
  uint64_t v18 = (unint64_t)(v14 + 63) >> 6;
  swift_retain((unint64_t *)v5, v10, v11, v12);
  uint64_t v19 = 0LL;
  while (1)
  {
    if (v17)
    {
      uint64_t v20 = __clz(__rbit64(v17));
      v17 &= v17 - 1;
      uint64_t v21 = v20 | (v19 << 6);
      goto LABEL_11;
    }

    uint64_t v23 = v19 + 1;
    if (__OFADD__(v19, 1LL))
    {
      __break(1u);
      goto LABEL_93;
    }

    if (v23 >= v18)
    {
LABEL_55:
      swift_release(v5);
      uint64_t v49 = 1LL << *(_BYTE *)(v5 + 32);
      if (v49 > 63) {
        specialized UnsafeMutablePointer.assign(repeating:count:)( 0LL,  (unint64_t)(v49 + 63) >> 6,  (int64x2_t *)(v5 + 56));
      }
      else {
        *uint64_t v15 = -1LL << v49;
      }
      *(void *)(v5 + 16) = 0LL;
      goto LABEL_81;
    }

    v24 = v15[v23];
    ++v19;
    if (!v24)
    {
      uint64_t v19 = v23 + 1;
      if (v23 + 1 >= v18) {
        goto LABEL_55;
      }
      v24 = v15[v19];
      if (!v24)
      {
        uint64_t v19 = v23 + 2;
        if (v23 + 2 >= v18) {
          goto LABEL_55;
        }
        v24 = v15[v19];
        if (!v24) {
          break;
        }
      }
    }

  uint64_t v161 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000LL) == 0) {
    uint64_t v161 = v407 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v162 = v380;
  if (v161 || (v407 & ~v408 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236LL;
    v408 = 0xE200000000000000LL;
  }

  v145(1LL, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v163 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v163, v162, v3);
  unint64_t v164 = v402;
  v165 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  char v166 = (void *)swift_getDynamicType(v165, v164, 1);
  LODWORD(v164) = swift_isOptionalType(v166);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v164)
  {
    memcpy(v101, v162, v3);
    v167 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v167, 7uLL);
LABEL_88:
    unint64_t v168 = (uint64_t)v402;
    char v169 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    v170 = (*(uint64_t (**)(uint64_t, uint64_t))(v169 + 8))(v168, v169);
    v172 = v171;
    specialized String.write<A>(to:)(&v407, v170, v171, v173);
    swift_bridgeObjectRelease(v172);
LABEL_89:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_92;
  }

  unint64_t v174 = v372;
  memcpy(v372, v162, v3);
  if ((swift_dynamicCast((char *)&v401, v174, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v175 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v175);
  }

  else
  {
    v286 = v366;
    memcpy(v366, v162, v3);
    v287 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v286, v2, v287, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v288 = (uint64_t)v402;
      v289 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v289 + 8))( &v407,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v288,  v289);
      goto LABEL_89;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v310 = v360;
    memcpy(v360, v162, v3);
    v311 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v310, v2, v311, 6uLL)
      || (v406 = 0LL,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomStringConvertible?),  v312 = v354,  memcpy(v354, v162, v3),  v313 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v404, v312, v2, v313, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_88;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v405 + 1) = v2;
    v333 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v333, v162, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v334 = v401._object;
    v335 = v162;
    v336 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v335,  &v401,  &v407,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v336);
    swift_release((uint64_t)v334);
  }

            uint64_t v35 = *(unsigned __int8 *)(v34 + 18);
          }

          if (v35 == 2) {
            uint64_t v41 = 2LL;
          }
          else {
            uint64_t v41 = 0LL;
          }
LABEL_87:
          if (j >= v41) {
            goto LABEL_118;
          }
          goto LABEL_88;
        }

        uint64_t v45 = swift::Demangle::__runtime::Node::findByKind(v20, 3LL, 5);
        if (!v45) {
          goto LABEL_118;
        }
        v46 = *(unsigned __int8 *)(v45 + 18);
        if ((v46 - 1) >= 2)
        {
          if (v46 != 5 || !*(_DWORD *)(v45 + 8))
          {
            uint64_t v47 = 0LL;
            goto LABEL_111;
          }

          uint64_t v45 = *(void *)v45;
        }

        uint64_t v47 = *(void *)v45;
LABEL_111:
        uint64_t v48 = *(unsigned __int8 *)(v47 + 18);
        uint64_t v49 = (uint64_t *)v47;
        if (v48 == 5 && *(_DWORD *)(v47 + 8))
        {
          uint64_t v49 = *(uint64_t **)v47;
LABEL_115:
          v50 = *v49;
          if (v50)
          {
            if (*(_WORD *)(v50 + 16) == 223)
            {
              while (1)
              {
                LODWORD(v68) = *(unsigned __int8 *)(v47 + 18);
                uint64_t v69 = v68 - 1;
                char v70 = (uint64_t *)v47;
                if ((v68 - 1) >= 2)
                {
                  if ((_DWORD)v68 != 5 || !*(_DWORD *)(v47 + 8)) {
                    break;
                  }
                  char v70 = *(uint64_t **)v47;
                }

                if (!*v70) {
                  break;
                }
                v71 = (uint64_t *)v47;
                if (v69 >= 2) {
                  v71 = *(uint64_t **)v47;
                }
                if (*(_WORD *)(*v71 + 16) == 224) {
                  break;
                }
                if (v69 >= 2)
                {
                  if ((_DWORD)v68 != 5 || !*(_DWORD *)(v47 + 8)) {
                    goto LABEL_118;
                  }
                  uint64_t v47 = *(void *)v47;
                }

                uint64_t v47 = *(void *)v47;
                if (!v47) {
                  goto LABEL_118;
                }
              }

              uint64_t v72 = 0LL;
              if ((_DWORD)v68 == 1) {
                goto LABEL_164;
              }
LABEL_157:
              if ((_DWORD)v68 == 5)
              {
                uint64_t v68 = *(unsigned int *)(v47 + 8);
              }

              else if ((_DWORD)v68 == 2)
              {
                uint64_t v68 = 2LL;
              }

              else
              {
                uint64_t v68 = 0LL;
              }

              while (v72 < v68)
              {
                std::string::append(&v118, "_:");
                ++v72;
                LODWORD(v68) = *(unsigned __int8 *)(v47 + 18);
                if ((_DWORD)v68 != 1) {
                  goto LABEL_157;
                }
LABEL_164:
                uint64_t v68 = v68;
              }
            }

            else
            {
              std::string::append(&v118, "_:");
            }
          }
        }

          if (v9 < v32)
          {
            uint64_t v45 = *(os_unfair_lock_s **)a2;
            os_unfair_lock_lock(*(os_unfair_lock_t *)a2);
            v46 = *(void **)(a2 + 8);
            if (*v46 == 1LL)
            {
              uint64_t v47 = *(void *)(a2 + 8);
            }

            else
            {
              uint64_t v47 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
              *(_OWORD *)uint64_t v47 = 0u;
              *(_OWORD *)(v47 + 16) = 0u;
              *(_OWORD *)(v47 + 32) = 0u;
              *(void *)uint64_t v47 = 1LL;
              *(void *)(v47 + 16) = 0LL;
              *(void *)(v47 + 24) = 0LL;
              os_unfair_lock_lock((os_unfair_lock_t)(v47 + 8));
              uint64_t v48 = v46[2];
              v46[2] = 0LL;
              uint64_t v49 = *(void **)(v47 + 16);
              *(void *)(v47 + 16) = v48;
              if (v49) {
                operator delete(v49);
              }
            }

            *(void *)(v47 + 24) = v11;
            *(void *)(v47 + 32) = v70;
            atomic_store(*(unsigned __int8 *)(a2 + 17) | v47 | 8, (unint64_t *)a1);
            uint64_t v26 = v47 == (void)v46;
            uint64_t v8 = v69;
            if (!v26)
            {
              os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a2 + 8) + 8LL));
              v50 = *(void **)(a2 + 8);
              if (*v50 == 1LL)
              {
                char v51 = (void *)v50[2];
                v50[2] = 0LL;
                if (v51) {
                  operator delete(v51);
                }
                swift_slowDealloc(v50);
              }

              else
              {
                --*v50;
              }

              *(void *)(a2 + 8) = v47;
            }

            os_unfair_lock_unlock(v45);
            char v66 = *(void *)(a2 + 8);
          }

          swift::blockOnMetadataDependency((uint64_t)v6, v67, v11, v70);
          goto LABEL_6;
        }

        uint64_t v13 = 0;
        if (!v11)
        {
          if (a2 >= 2) {
            uint64_t v11 = v14;
          }
          else {
            uint64_t v11 = 0LL;
          }
        }
      }

      ++v12;
    }

    while (v10 != v12);
    uint64_t v15 = *(void *)(a1 + 120);
    uint64_t v16 = *(ValueWitnessTable **)(a1 + 104);
    *(void *)(a1 + 104) = v65;
    if (!v15)
    {
      uint64_t v30 = 0;
      uint64_t v18 = 0LL;
      uint64_t v17 = 0LL;
      uint64_t v29 = 0;
      uint64_t v28 = 1;
      BOOL v6 = v64;
      goto LABEL_37;
    }

    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v19 = 1;
    uint64_t v20 = v63;
    LOBYTE(v21) = 1;
    LOBYTE(v22) = 1;
    uint64_t v8 = v69;
    do
    {
      uint64_t v23 = *(void *)(*(v20 - 1) - 8);
      v24 = *(_DWORD *)(v23 + 80);
      uint64_t v25 = (v17 + v24) & ~(unint64_t)v24;
      void *v20 = v25;
      v20 += 2;
      uint64_t v17 = v25 + *(void *)(v23 + 64);
      uint64_t v21 = ((v24 & 0x10000) == 0) & v21;
      uint64_t v22 = ((v24 & 0x100000) == 0) & v22;
      uint64_t v26 = v15 == v19++;
    }

    while (!v26);
    if (v18 >= 8 || v17 >= 0x19) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = v22;
    }
    uint64_t v29 = v18;
    if (v21) {
      uint64_t v30 = 0;
    }
    else {
      uint64_t v30 = 0x10000;
    }
    BOOL v6 = v64;
    if (!v22)
    {
      uint64_t v28 = 0;
      uint64_t v31 = 0x100000;
      goto LABEL_39;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    LODWORD(v15) = 0;
    uint64_t v30 = 0;
    uint64_t v18 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v29 = 0;
    uint64_t v16 = *(ValueWitnessTable **)(a1 + 104);
    *(void *)(a1 + 104) = v65;
    uint64_t v13 = 1;
    uint64_t v28 = 1;
LABEL_37:
    uint64_t v8 = v69;
  }

  uint64_t v31 = 0;
LABEL_39:
  if (v28) {
    uint64_t v33 = 0;
  }
  else {
    uint64_t v33 = 0x20000;
  }
  uint64_t v34 = (v17 + v18) & ~v18;
  *(_DWORD *)(a1 + 96) = v33 | v31 | v30 | v29;
  if (v34 <= 1) {
    uint64_t v34 = 1LL;
  }
  *(void *)(a1 + 80) = v17;
  *(void *)(a1 + 88) = v34;
  if ((_DWORD)v15)
  {
    uint64_t v35 = 0LL;
    uint64_t v36 = 0;
    uint64_t v37 = -1;
    uint64_t v38 = v7;
    do
    {
      uint64_t v39 = *v38;
      v38 += 2;
      uint64_t v40 = *(_DWORD *)(*(void *)(v39 - 8) + 84LL);
      if (v40 > v36)
      {
        uint64_t v37 = v35;
        uint64_t v36 = v40;
      }

      ++v35;
    }

    while (v15 != v35);
    *(_DWORD *)(a1 + 100) = v36;
    if (v36)
    {
      uint64_t v41 = 0;
      *(_DWORD *)(a1 + 8) = v37;
      if (v16) {
        goto LABEL_64;
      }
      goto LABEL_54;
    }
  }

  else
  {
    *(_DWORD *)(a1 + 100) = 0;
  }

  uint64_t v41 = 1;
  if (v16) {
    goto LABEL_64;
  }
LABEL_54:
  if (v28)
  {
    uint64_t v16 = (ValueWitnessTable *)&tuple_witnesses_nonpod_inline;
    if ((v30 & 0x10000) != 0) {
      goto LABEL_64;
    }
    if (v17 == 8) {
      uint64_t v42 = v41;
    }
    else {
      uint64_t v42 = 0;
    }
    if (v42 == 1)
    {
      uint64_t v16 = &value witness table for Builtin.Int64;
      goto LABEL_107;
    }

    if (v17 == 4) {
      uint64_t v52 = v41;
    }
    else {
      uint64_t v52 = 0;
    }
    if (v52 == 1)
    {
      uint64_t v16 = &value witness table for Builtin.Int32;
      goto LABEL_107;
    }

    if (v17 == 2) {
      uint64_t v53 = v41;
    }
    else {
      uint64_t v53 = 0;
    }
    if (v53 == 1)
    {
      uint64_t v16 = &value witness table for Builtin.Int16;
      goto LABEL_107;
    }

    if (v17 == 1) {
      uint64_t v54 = v41;
    }
    else {
      uint64_t v54 = 0;
    }
    uint64_t v16 = &value witness table for Builtin.Int8;
    if ((v54 & 1) == 0) {
LABEL_107:
    }
      uint64_t v16 = (ValueWitnessTable *)&tuple_witnesses_pod_inline;
  }

  else
  {
    uint64_t v16 = (ValueWitnessTable *)tuple_witnesses_nonpod_noninline;
    if ((v30 & 0x10000) == 0) {
      uint64_t v16 = (ValueWitnessTable *)tuple_witnesses_pod_noninline;
    }
  }

  else {
    uint64_t v43 = *(void *)(a1 + 8);
  }
  uint64_t v45 = *(unsigned __int8 *)(a1 + 23);
  if ((v45 & 0x80u) != 0LL) {
    uint64_t v45 = *(void *)(a1 + 8);
  }
  if (v45 != v43) {
    std::string::push_back((std::string *)a1, 46);
  }
  uint64_t v34 = (swift::Demangle::__runtime::Node *)v44;
  a5 = v32;
  v24 = v85;
LABEL_89:
  uint64_t v31 = a9;
  uint64_t v37 = __na;
  if ((a6 & 1) != 0) {
    goto LABEL_93;
  }
LABEL_90:
  if (!v37)
  {
    v46 = a3;
    uint64_t v47 = v87;
    if (!v11) {
      goto LABEL_114;
    }
    goto LABEL_112;
  }

unint64_t _makeNativeBridgeObject(_:_:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4 = a1 | a2;
  swift_unknownObjectRetain((id)a1, a2, a3, a4);
  return v4;
}

uint64_t _makeObjCBridgeObject(_:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = ~(a1 >> 1) & 0x4000000000000000LL | a1;
  swift_unknownObjectRetain((id)a1, a2, a3, a4);
  return v4;
}

unint64_t _BridgeStorage.init(taggedPayload:)(uint64_t a1)
{
  return a1 | 0x8000000000000000LL;
}

unint64_t _bridgeObject(taggingPayload:)(uint64_t a1)
{
  return a1 | 0x8000000000000000LL;
}

uint64_t static _BridgeStorage.flagMask.getter()
{
  return 1LL;
}

unint64_t _bridgeObjectTaggedPointerBits.getter()
{
  return 0x8000000000000000LL;
}

unint64_t _objCTaggedPointerBits.getter()
{
  return 0x8000000000000000LL;
}

uint64_t _objectPointerIsObjCBit.getter()
{
  return 0x4000000000000000LL;
}

uint64_t _BridgeStorage.isObjC.getter(uint64_t a1)
{
  if (a1 < 0) {
    return 1LL;
  }
  else {
    return ((unint64_t)a1 >> 62) & 1;
  }
}

uint64_t _nonPointerBits(_:)(uint64_t a1)
{
  return a1 & 0x7000000000000007LL;
}

BOOL _isUnique_native<A>(_:)(uint64_t *a1)
{
  return swift_isUniquelyReferenced_nonNull_native(*a1);
}

void *ManagedBufferPointer.init(_uncheckedBufferClass:minimumCapacity:)( void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a3 - 8);
  uint64_t v5 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = (v5 + 16) & ~v5;
  uint64_t v7 = *(void *)(v4 + 64);
  BOOL v8 = __OFADD__(v6, v7);
  uint64_t v9 = v6 + v7;
  if (v8)
  {
    __break(1u);
    goto LABEL_11;
  }

  uint64_t v10 = *(void *)(a4 - 8);
  unint64_t v11 = *(unsigned __int8 *)(v10 + 80) + 1LL;
  BOOL v12 = __CFADD__(v9, v11);
  uint64_t v13 = v9 + v11;
  if (v12)
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }

  uint64_t v14 = *(void *)(v10 + 72);
  uint64_t v15 = a2 * v14;
  if ((unsigned __int128)(a2 * (__int128)v14) >> 64 != (a2 * v14) >> 63)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }

  uint64_t v16 = (v13 - 1) & -(uint64_t)v11;
  if (__OFADD__(v16, v15))
  {
LABEL_13:
    __break(1u);
    return result;
  }

  unint64_t v17 = v5 + 1;
  if (v11 > v17) {
    unint64_t v17 = v11;
  }
  if (v17 <= 8) {
    unint64_t v17 = 8LL;
  }
  return swift_bufferAllocate((uint64_t)result, v16 + v15, v17 - 1);
}

uint64_t (*ManagedBufferPointer.header.read())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*ManagedBufferPointer.header.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt __swiftcall _roundUpImpl(_:toAlignment:)(Swift::UInt _, Swift::Int toAlignment)
{
  if (!__CFADD__(_, toAlignment)) {
    return (_ + toAlignment - 1) & -toAlignment;
  }
  __break(1u);
  return _;
}

Swift::Bool __swiftcall _isPowerOf2(_:)(Swift::Int a1)
{
  return a1 >= 1 && (a1 & (a1 - 1)) == 0;
}

uint64_t static UInt.+ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __CFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v2) {
    __break(1u);
  }
  return result;
}

Swift::UInt __swiftcall _roundUp(_:toAlignment:)(Swift::UInt _, Swift::Int toAlignment)
{
  if (!__CFADD__(_, toAlignment)) {
    return (_ + toAlignment - 1) & -toAlignment;
  }
  __break(1u);
  return _;
}

Swift::Int __swiftcall _roundUp(_:toAlignment:)(Swift::Int _, Swift::Int toAlignment)
{
  if (!__CFADD__(_, toAlignment)) {
    return (_ + toAlignment - 1) & -toAlignment;
  }
  __break(1u);
  return _;
}

uint64_t _canBeClass<A>(_:)()
{
  return 2LL;
}

id _reinterpretCastToAnyObject<A>(_:)(id *a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != 8LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  return swift_unknownObjectRetain(*a1, a2, a3, a4);
}

BOOL != infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 != a2;
}

{
  return a1 != a2;
}

{
  BOOL v2;
  BOOL v3;
  BOOL v2 = (a1 | a2) == 0;
  uint64_t v3 = a1 == a2;
  if (!a2) {
    uint64_t v3 = a1 == 0;
  }
  if (a1) {
    BOOL v2 = v3;
  }
  return !v2;
}

uint64_t ~= infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))() & 1;
}

id unsafeDowncast<A>(_:to:)(void *a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v11 = a1;
  swift_unknownObjectRetain(a1, a2, (uint64_t)a3, a4);
  if (!swift_dynamicCast((char *)&v10, (uint64_t *)&v11, (swift *)&unk_189B8D230, a3, 6uLL)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  swift_unknownObjectRelease(v10);
  return swift_unknownObjectRetain(a1, v6, v7, v8);
}

uint64_t _getUnsafePointerToStoredProperties(_:)(uint64_t a1)
{
  return a1 + 16;
}

uint64_t static MemoryLayout.alignment.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 - 8) + 80LL) + 1LL;
}

Swift::Int __swiftcall _minAllocationAlignment()()
{
  return 16LL;
}

uint64_t _class_getInstancePositiveExtentSize(_:)(uint64_t a1)
{
  if (v1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  return v1;
}

Swift::Bool __swiftcall _isValidAddress(_:)(Swift::UInt a1)
{
  return HIDWORD(a1) != 0;
}

BOOL static BinaryInteger.>= infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v104 = a1;
  uint64_t v105 = a2;
  uint64_t v99 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v99,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v96 = (char *)&v87 - v10;
  char v95 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t v94 = swift_getAssociatedTypeWitness( 0LL,  v95,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v94);
  v93 = (char *)&v87 - v12;
  uint64_t v103 = *(void *)(a4 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v98 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v17 = (char *)&v87 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  unint64_t v101 = (char *)&v87 - v19;
  uint64_t v102 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v87 - v24;
  MEMORY[0x1895F8858](v23);
  v100 = (char *)&v87 - v26;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  int v28 = v27(a3, a5);
  if (((v28 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a6 + 64))(a4, a6)) & 1) != 0)
  {
    v87 = v25;
    uint64_t v88 = v22;
    uint64_t v29 = v99;
    uint64_t v89 = v17;
    char v30 = v27(a3, a5);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v91 = a5;
    uint64_t v32 = v31(a3, a5);
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    uint64_t v92 = a4;
    uint64_t v90 = a6;
    uint64_t v34 = v33(a4, a6);
    uint64_t v35 = a3;
    if ((v30 & 1) != 0)
    {
      if (v34 >= v32)
      {
        unint64_t v54 = v94;
        uint64_t v55 = v95;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v95,  a3,  v94,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v57 = v93;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v54,  AssociatedConformanceWitness);
        uint64_t v58 = v100;
        (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
        uint64_t v59 = v91;
        uint64_t v60 = v104;
        LOBYTE(v54) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v91 + 32) + 8LL)
                                                                          + 16LL))( v104,  v58,  a3);
        uint64_t v61 = v102;
        unint64_t v62 = *(void (**)(char *, uint64_t))(v102 + 8);
        v62(v58, v35);
        char v63 = v87;
        (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v87, v60, v35);
        uint64_t v64 = v103;
        unint64_t v65 = v89;
        uint64_t v66 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v89, v105, v92);
        if ((v54 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t))(v64 + 8))(v65, v66);
          v62(v63, v35);
          char v40 = 1;
        }

        else
        {
          uint64_t v84 = v90;
          v85 = v101;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v63, v35, v59, v66, v90);
          char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v84 + 32) + 8LL) + 16LL))( v85,  v65,  v66);
          v86 = *(void (**)(char *, uint64_t))(v64 + 8);
          v86(v85, v66);
          v86(v65, v66);
        }
      }

      else
      {
        uint64_t v36 = v101;
        uint64_t v37 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v105, v92);
        uint64_t v38 = v91;
        uint64_t v39 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v36, v37, v90, a3, v91);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v38 + 32) + 8LL) + 16LL))( v104,  v39,  a3);
        (*(void (**)(char *, uint64_t))(v102 + 8))(v39, a3);
      }
    }

    else if (v32 >= v34)
    {
      uint64_t v67 = v92;
      unint64_t v68 = AssociatedTypeWitness;
      unint64_t v69 = swift_getAssociatedConformanceWitness( (uint64_t)v29,  v92,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v70 = v96;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v69 + 8))( &unk_18180BE68,  256LL,  v68,  v69);
      v71 = v101;
      (*((void (**)(char *, uint64_t, const char *))v29 + 3))(v70, v67, v29);
      uint64_t v72 = v90;
      uint64_t v73 = v105;
      LOBYTE(v68) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8LL) + 40LL))( v105,  v71,  v67);
      uint64_t v74 = v103;
      v75 = *(void (**)(char *, uint64_t))(v103 + 8);
      v75(v71, v67);
      uint64_t v76 = v102;
      v77 = v88;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v88, v104, v35);
      char v78 = *(void (**)(char *, uint64_t, uint64_t))(v74 + 16);
      v79 = v98;
      v78(v98, v73, v67);
      if ((v68 & 1) != 0)
      {
        uint64_t v80 = v72;
        uint64_t v81 = v91;
        v82 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v79, v67, v80, v35, v91);
        char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v81 + 32) + 8LL) + 16LL))( v77,  v82,  v35);
        unint64_t v83 = *(void (**)(char *, uint64_t))(v76 + 8);
        v83(v82, v35);
        v83(v77, v35);
      }

      else
      {
        v75(v79, v67);
        (*(void (**)(char *, uint64_t))(v76 + 8))(v77, v35);
        char v40 = 0;
      }
    }

    else
    {
      v46 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v104, a3);
      uint64_t v47 = v90;
      uint64_t v48 = v101;
      uint64_t v49 = v46;
      uint64_t v50 = v92;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v49, a3, v91, v92, v90);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v47 + 32) + 8LL) + 16LL))( v48,  v105,  v50);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v48, v50);
    }
  }

  else
  {
    uint64_t v41 = v104;
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
    uint64_t v43 = v105;
    if (v42 >= (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6))
    {
      char v51 = v101;
      (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v43, a4);
      uint64_t v52 = v100;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v51, a4, a6, a3, a5);
      char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v41,  v52,  a3);
      (*(void (**)(char *, uint64_t))(v102 + 8))(v52, a3);
    }

    else
    {
      uint64_t v44 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v41, a3);
      uint64_t v45 = v101;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v44, a3, a5, a4, a6);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v45,  v43,  a4);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v45, a4);
    }
  }

  return (v40 & 1) == 0;
}

uint64_t _objectPointerSpareBits.getter()
{
  return 0x7000000000000007LL;
}

BOOL static Int32.< infix(_:_:)(int a1, int a2)
{
  return a1 < a2;
}

unint64_t _isTaggedObject(_:)(unint64_t a1)
{
  return a1 >> 63;
}

BOOL _isNativePointer(_:)(unint64_t a1)
{
  return a1 >> 62 == 0;
}

BOOL _isNonTaggedObjCPointer(_:)(uint64_t a1)
{
  return a1 >= 0 && (unint64_t)a1 >> 62 != 0;
}

uint64_t _getNonTagBits(_:)(uint64_t a1)
{
  return a1 & 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t _bridgeObject(fromNonTaggedObjC:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = ~(a1 >> 1) & 0x4000000000000000LL | a1;
  swift_unknownObjectRetain((id)a1, a2, a3, a4);
  return v4;
}

id _bridgeObject(toNonTaggedObjC:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return swift_unknownObjectRetain((id)a1, a2, a3, a4);
}

uint64_t _bridgeObject(toTagPayload:)(uint64_t a1)
{
  return a1 & 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t _nativeObject(fromBridge:)(int64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a1 < 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  swift_bridgeObjectRetain(a1, a2, a3, a4);
  return v4;
}

unint64_t _makeBridgeObject(_:_:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4 = a1 | a2;
  swift_unknownObjectRetain((id)a1, a2, a3, a4);
  return v4;
}

swift *_getSuperclass(_:)(uint64_t *a1)
{
  if (swift_isClassType(a1)) {
    uint64_t result = (swift *)a1;
  }
  else {
    uint64_t result = 0LL;
  }
  if (result) {
    return (swift *)_swift_class_getSuperclass(result);
  }
  return result;
}

BOOL _isPOD<A>(_:)(uint64_t a1, uint64_t a2)
{
  return (*(_BYTE *)(*(void *)(a2 - 8) + 82LL) & 1) == 0;
}

BOOL _isBitwiseTakable<A>(_:)(uint64_t a1, uint64_t a2)
{
  return (*(_BYTE *)(*(void *)(a2 - 8) + 82LL) & 0x10) == 0;
}

BOOL _isOptional<A>(_:)(void *a1)
{
  return swift_isOptionalType(a1);
}

char *_unsafeDowncastToAnyObject(fromAny:)(void *a1)
{
  uint64_t v1 = (uint64_t *)a1[3];
  BOOL v2 = (id *)__swift_project_boxed_opaque_existential_0Tm(a1, (uint64_t)v1);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v1, v1);
  if (isClassOrObjCExistentialType)
  {
    if (*(void *)(*(v1 - 1) + 64) != 8LL) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }
    return (char *)swift_unknownObjectRetain(*v2, v4, v5, v6);
  }

  else
  {
    MEMORY[0x1895F8858](isClassOrObjCExistentialType);
    uint64_t v9 = (id *)((char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    (*(void (**)(id *, id *, uint64_t *))(v10 + 16))(v9, v2, v1);
    return _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v9, v1, v11, v12);
  }

Builtin::Int1 __swiftcall _trueAfterDiagnostics()()
{
  return 1;
}

uint64_t StaticString.utf8Start.getter(uint64_t result, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "StaticString should have pointer representation",  47LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x85uLL,  0);
  }
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x88uLL,  0);
  }
  return result;
}

Swift::Float __swiftcall _nearbyint(_:)(Swift::Float a1)
{
  return nearbyintf(a1);
}

Swift::Float __swiftcall _rint(_:)(Swift::Float a1)
{
  return rintf(a1);
}

Swift::Double __swiftcall _nearbyint(_:)(Swift::Double a1)
{
  return nearbyint(a1);
}

Swift::Double __swiftcall _rint(_:)(Swift::Double a1)
{
  return rint(a1);
}

uint64_t Character._str.getter(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  return a1;
}

void Character._str.setter(uint64_t a1, uint64_t a2)
{
  *BOOL v2 = a1;
  v2[1] = a2;
}

uint64_t (*Character._str.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::String __swiftcall Character.init(_:)(Swift::Unicode::Scalar a1)
{
  uint64_t v1 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a1._value);
  result._object = v2;
  result._uint64_t countAndFlagsBits = v1;
  return result;
}

Swift::String __swiftcall String.init(_:)(Swift::Unicode::Scalar a1)
{
  uint64_t v1 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a1._value);
  result._object = v2;
  result._uint64_t countAndFlagsBits = v1;
  return result;
}

uint64_t Character.init(_builtinUnicodeScalarLiteral:)(unsigned int a1)
{
  return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a1);
}

Swift::String __swiftcall Character.init(_builtinExtendedGraphemeClusterLiteral:utf8CodeUnitCount:isASCII:)( Builtin::RawPointer _builtinExtendedGraphemeClusterLiteral, Builtin::Word utf8CodeUnitCount, Builtin::Int1 isASCII)
{
  if ((utf8CodeUnitCount & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (utf8CodeUnitCount)
  {
    if (utf8CodeUnitCount <= 0xF)
    {
      int64_t v7 = utf8CodeUnitCount - 8;
      Builtin::Word v8 = 8LL;
      uint64_t v5 = *(unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral;
      if (v8 != 1)
      {
        v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 1) << 8;
        if (v8 != 2)
        {
          v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 2) << 16;
          if (v8 != 3)
          {
            v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 3) << 24;
            if (v8 != 4)
            {
              v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 4) << 32;
              if (v8 != 5)
              {
                v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 5) << 40;
                if (v8 != 6)
                {
                  v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 6) << 48;
                  if (v8 != 7) {
                    v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 7) << 56;
                  }
                }
              }
            }
          }
        }
      }

      uint64_t v9 = 0LL;
      if (utf8CodeUnitCount >= 9)
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = (unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 8;
        unint64_t v12 = v7 & ~(v7 >> 63);
        do
        {
          if (v12 <= utf8CodeUnitCount - 9) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
          }
          unsigned int v13 = *v11++;
          v9 |= (unint64_t)v13 << v10;
          v10 += 8LL;
          --v7;
        }

        while (v7);
      }

      unint64_t v14 = 0xA000000000000000LL;
      if (((v9 | v5) & 0x8080808080808080LL) == 0) {
        unint64_t v14 = 0xE000000000000000LL;
      }
      uint64_t v6 = (void *)(v14 | (utf8CodeUnitCount << 56) | v9);
    }

    else
    {
      Builtin::Word v4 = utf8CodeUnitCount | 0xC000000000000000LL;
      if (!isASCII) {
        Builtin::Word v4 = utf8CodeUnitCount;
      }
      uint64_t v5 = v4 | 0x1000000000000000LL;
      uint64_t v6 = (void *)(((unint64_t)_builtinExtendedGraphemeClusterLiteral + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    }
  }

  else
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = (void *)0xE000000000000000LL;
  }

  result._object = v6;
  result._uint64_t countAndFlagsBits = v5;
  return result;
}

Swift::String __swiftcall String.init(_builtinExtendedGraphemeClusterLiteral:utf8CodeUnitCount:isASCII:)( Builtin::RawPointer _builtinExtendedGraphemeClusterLiteral, Builtin::Word utf8CodeUnitCount, Builtin::Int1 isASCII)
{
  if ((utf8CodeUnitCount & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (utf8CodeUnitCount)
  {
    if (utf8CodeUnitCount <= 0xF)
    {
      int64_t v7 = utf8CodeUnitCount - 8;
      Builtin::Word v8 = 8LL;
      uint64_t v5 = *(unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral;
      if (v8 != 1)
      {
        v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 1) << 8;
        if (v8 != 2)
        {
          v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 2) << 16;
          if (v8 != 3)
          {
            v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 3) << 24;
            if (v8 != 4)
            {
              v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 4) << 32;
              if (v8 != 5)
              {
                v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 5) << 40;
                if (v8 != 6)
                {
                  v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 6) << 48;
                  if (v8 != 7) {
                    v5 |= (unint64_t)*((unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 7) << 56;
                  }
                }
              }
            }
          }
        }
      }

      uint64_t v9 = 0LL;
      if (utf8CodeUnitCount >= 9)
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = (unsigned __int8 *)_builtinExtendedGraphemeClusterLiteral + 8;
        unint64_t v12 = v7 & ~(v7 >> 63);
        do
        {
          if (v12 <= utf8CodeUnitCount - 9) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
          }
          unsigned int v13 = *v11++;
          v9 |= (unint64_t)v13 << v10;
          v10 += 8LL;
          --v7;
        }

        while (v7);
      }

      unint64_t v14 = 0xA000000000000000LL;
      if (((v9 | v5) & 0x8080808080808080LL) == 0) {
        unint64_t v14 = 0xE000000000000000LL;
      }
      uint64_t v6 = (void *)(v14 | (utf8CodeUnitCount << 56) | v9);
    }

    else
    {
      Builtin::Word v4 = utf8CodeUnitCount | 0xC000000000000000LL;
      if (!isASCII) {
        Builtin::Word v4 = utf8CodeUnitCount;
      }
      uint64_t v5 = v4 | 0x1000000000000000LL;
      uint64_t v6 = (void *)(((unint64_t)_builtinExtendedGraphemeClusterLiteral + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    }
  }

  else
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = (void *)0xE000000000000000LL;
  }

  result._object = v6;
  result._uint64_t countAndFlagsBits = v5;
  return result;
}

Swift::String __swiftcall Character.init(_:)(Swift::String a1)
{
  else {
    uint64_t v1 = a1._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from an empty String",  43LL,  2,  "Swift/Character.swift",  21LL,  2,  0xAFuLL,  0);
  }
  unint64_t object = (unint64_t)a1._object;
  unint64_t countAndFlagsBits = a1._countAndFlagsBits;
  v4._rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15LL)._rawBits;
  if (String._uncheckedIndex(after:)(v4)._rawBits >> 14 != 4 * v1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from a String containing more than one extended grapheme cluster",  87LL,  2,  "Swift/Character.swift",  21LL,  2,  0xB1uLL,  0);
  }
  if (!(object & 0x2000000000000000LL | countAndFlagsBits & 0x1000000000000000LL))
  {
    unint64_t countAndFlagsBits = specialized static String._copying(_:)(countAndFlagsBits, object);
    unint64_t v8 = v7;
    swift_bridgeObjectRelease(object);
    unint64_t object = v8;
  }

  uint64_t v5 = countAndFlagsBits;
  uint64_t v6 = (void *)object;
  result._unint64_t object = v6;
  result._unint64_t countAndFlagsBits = v5;
  return result;
}

BOOL String.isEmpty.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  return v2 == 0;
}

uint64_t String.startIndex.getter()
{
  return 15LL;
}

Swift::String::Index __swiftcall String.index(after:)(Swift::String::Index after)
{
  v1._rawBits = _StringGuts.validateCharacterIndex(_:)(after)._rawBits;
  return String._uncheckedIndex(after:)(v1);
}

BOOL static String.Index.== infix(_:_:)(unint64_t a1, uint64_t a2)
{
  return (a2 ^ a1) < 0x4000;
}

unsigned __int8 *protocol witness for _ExpressibleByBuiltinExtendedGraphemeClusterLiteral.init(_builtinExtendedGraphemeClusterLiteral:utf8CodeUnitCount:isASCII:) in conformance Character@<X0>( unsigned __int8 *result@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (a2)
  {
    if ((unint64_t)a2 <= 0xF)
    {
      uint64_t v7 = a2 - 8;
      if (a2 >= 8) {
        uint64_t v8 = 8LL;
      }
      else {
        uint64_t v8 = a2;
      }
      uint64_t v5 = *result;
      if (v8 != 1)
      {
        v5 |= (unint64_t)result[1] << 8;
        if (v8 != 2)
        {
          v5 |= (unint64_t)result[2] << 16;
          if (v8 != 3)
          {
            v5 |= (unint64_t)result[3] << 24;
            if (v8 != 4)
            {
              v5 |= (unint64_t)result[4] << 32;
              if (v8 != 5)
              {
                v5 |= (unint64_t)result[5] << 40;
                if (v8 != 6)
                {
                  v5 |= (unint64_t)result[6] << 48;
                  if (v8 != 7) {
                    v5 |= (unint64_t)result[7] << 56;
                  }
                }
              }
            }
          }
        }
      }

      uint64_t v9 = 0LL;
      if ((unint64_t)a2 >= 9)
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = result + 8;
        unint64_t v12 = v7 & ~(v7 >> 63);
        do
        {
          if (v12 <= a2 - 9) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
          }
          unsigned int v13 = *v11++;
          v9 |= (unint64_t)v13 << v10;
          v10 += 8LL;
          --v7;
        }

        while (v7);
      }

      unint64_t v14 = 0xA000000000000000LL;
      if (((v9 | v5) & 0x8080808080808080LL) == 0) {
        unint64_t v14 = 0xE000000000000000LL;
      }
      unint64_t v6 = v14 | (a2 << 56) | v9;
    }

    else
    {
      unint64_t v4 = a2 | 0xC000000000000000LL;
      if ((a3 & 1) == 0) {
        unint64_t v4 = a2;
      }
      uint64_t v5 = v4 | 0x1000000000000000LL;
      unint64_t v6 = (unint64_t)(result + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
    }
  }

  else
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = 0xE000000000000000LL;
  }

  *a4 = v5;
  a4[1] = v6;
  return result;
}

uint64_t protocol witness for _ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:) in conformance Character@<X0>( unsigned int a1@<W0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a1);
  *a2 = result;
  a2[1] = v4;
  return result;
}

void *protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Character@<X0>( void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[1];
  *a2 = *result;
  a2[1] = v2;
  return result;
}

uint64_t Character.description.getter(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  return a1;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Character( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *v4;
  swift_bridgeObjectRetain(v4[1], a2, a3, a4);
  return v5;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Character( unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, unint64_t *a5@<X8>)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v6 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from an empty String",  43LL,  2,  "Swift/Character.swift",  21LL,  2,  0xAFuLL,  0);
  }
  unint64_t v7 = a2;
  unint64_t v8 = a1;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  v9._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15LL)._rawBits;
  Swift::UInt64 rawBits = String._uncheckedIndex(after:)(v9)._rawBits;
  swift_bridgeObjectRelease(v7);
  if (rawBits >> 14 != 4 * v6) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from a String containing more than one extended grapheme cluster",  87LL,  2,  "Swift/Character.swift",  21LL,  2,  0xB1uLL,  0);
  }
  if (!(v7 & 0x2000000000000000LL | v8 & 0x1000000000000000LL))
  {
    unint64_t v8 = specialized static String._copying(_:)(v8, v7);
    unint64_t v12 = v11;
    swift_bridgeObjectRelease(v7);
    unint64_t v7 = v12;
  }

  *a5 = v8;
  a5[1] = v7;
}

uint64_t String.debugDescription.getter(uint64_t a1, unint64_t x1_0, uint64_t a3, char *a4)
{
  uint64_t v5 = 34LL;
  uint64_t v6 = 0xE100000000000000LL;
  uint64_t v248 = 34LL;
  unint64_t v249 = 0xE100000000000000LL;
  uint64_t v7 = HIBYTE(x1_0) & 0xF;
  uint64_t v241 = a1;
  uint64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
  if ((x1_0 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = v8;
  }
  uint64_t v240 = v7;
  if (!v7)
  {
    unint64_t v178 = 0xE100000000000000LL;
LABEL_221:
    uint64_t v246 = 34LL;
    uint64_t v247 = 0xE100000000000000LL;
    uint64_t v198 = HIBYTE(v178) & 0xF;
    if ((v178 & 0x2000000000000000LL) == 0) {
      uint64_t v198 = v5 & 0xFFFFFFFFFFFFLL;
    }
    if (!v198)
    {
LABEL_254:
      swift_bridgeObjectRelease(v6);
      return v5;
    }

    while (1)
    {
      uint64_t v204 = v246;
      uint64_t v205 = v247;
      swift_bridgeObjectRetain(v247, x1_0, a3, a4);
      unint64_t v206 = specialized Collection.first.getter(v204, v205);
      swift_bridgeObjectRelease(v205);
      if ((v206 & 0x100000000LL) != 0) {
        break;
      }
      uint64_t v244 = v5;
      unint64_t v245 = v178;
      uint64_t v248 = 0LL;
      unint64_t v249 = 0xE000000000000000LL;
      unint64_t v207 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v206);
      uint64_t v209 = v208;
      _StringGuts.append(_:)(v207, v208);
      swift_bridgeObjectRelease(v209);
      uint64_t v18 = v244;
      unint64_t v23 = v245;
      swift_bridgeObjectRetain_n(v245, 2LL, v210, v211);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      uint64_t v215 = HIBYTE(v23) & 0xF;
      if ((v23 & 0x2000000000000000LL) == 0) {
        uint64_t v215 = v18;
      }
      if (((v23 >> 60) & ((v18 & 0x800000000000000LL) == 0)) != 0) {
        uint64_t v216 = 11LL;
      }
      else {
        uint64_t v216 = 7LL;
      }
      v217._Swift::UInt64 rawBits = v216 | (v215 << 16);
      swift_bridgeObjectRetain(v23, v212, v213, v214);
      v218._Swift::UInt64 rawBits = String.index(before:)(v217)._rawBits;
      swift_bridgeObjectRelease(v23);
      v219._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v217)._rawBits;
      if (!(v219._rawBits >> 14)) {
        goto LABEL_259;
      }
      Swift::UInt64 rawBits = v219._rawBits;
      swift_bridgeObjectRelease(v23);
      if ((v23 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v225 = String.UnicodeScalarView._foreignIndex(before:)((Swift::String::Index)rawBits)._rawBits;
        swift_bridgeObjectRelease(v23);
      }

      else
      {
        if ((v23 & 0x2000000000000000LL) != 0)
        {
          uint64_t v222 = 0LL;
          uint64_t v244 = v18;
          unint64_t v245 = v23 & 0xFFFFFFFFFFFFFFLL;
          do
            int v224 = *(&v243 + (rawBits >> 16) + v222--) & 0xC0;
          while (v224 == 128);
        }

        else
        {
          if ((v18 & 0x1000000000000000LL) != 0) {
            v221 = (char *)((v23 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            v221 = (char *)_StringObject.sharedUTF8.getter(v18, v23);
          }
          uint64_t v222 = 0LL;
          do
            int v223 = v221[(rawBits >> 16) - 1 + v222--] & 0xC0;
          while (v223 == 128);
        }

        swift_bridgeObjectRelease(v23);
        Swift::UInt64 v225 = (rawBits - -65536 * v222) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (v218._rawBits >> 14 >= v225 >> 14) {
        goto LABEL_252;
      }
      uint64_t v244 = v18;
      unint64_t v245 = v23;
      specialized RangeReplaceableCollection<>.removeLast()();
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unsigned int v226 = specialized RangeReplaceableCollection<>.removeLast()();
      swift_bridgeObjectRelease(0xE000000000000000LL);
      uint64_t v248 = v244;
      unint64_t v249 = v245;
      Swift::String_optional v227 = Unicode.Scalar._escaped(asASCII:)(1);
      unint64_t object = v227.value._object;
      if (v227.value._object) {
        uint64_t countAndFlagsBits = v227.value._countAndFlagsBits;
      }
      else {
        uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v226);
      }
      unint64_t v228 = (unint64_t)object;
      v201._Swift::UInt64 rawBits = 15LL;
      v202._Swift::UInt64 rawBits = 15LL;
      specialized String.UnicodeScalarView.replaceSubrange<A>(_:with:)(v201, v202, countAndFlagsBits, v228);
      swift_bridgeObjectRelease(v228);
      uint64_t v5 = v248;
      unint64_t v178 = v249;
      unint64_t v203 = HIBYTE(v249) & 0xF;
      if ((v249 & 0x2000000000000000LL) == 0) {
        unint64_t v203 = v248 & 0xFFFFFFFFFFFFLL;
      }
      if (!v203)
      {
        uint64_t v6 = v247;
        goto LABEL_254;
      }
    }

    unint64_t v235 = 839LL;
LABEL_265:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  v235,  0);
  }

  uint64_t v9 = x1_0;
  uint64_t v10 = 0LL;
  uint64_t v237 = (x1_0 & 0xFFFFFFFFFFFFFFFLL) + 32;
  uint64_t v238 = x1_0 & 0xFFFFFFFFFFFFFFLL;
  char v11 = 1;
  while (1)
  {
    while (1)
    {
      if ((v9 & 0x1000000000000000LL) != 0)
      {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v10 << 16));
        Swift::Int scalarLength = v15.scalarLength;
        Swift::UInt32 value = v15._0._value;
      }

      else
      {
        if ((v9 & 0x2000000000000000LL) != 0)
        {
          uint64_t v246 = v241;
          uint64_t v247 = v238;
          Swift::UInt32 value = *((unsigned __int8 *)&v246 + v10);
          if (*((char *)&v246 + v10) < 0) {
            __asm { BR              X9 }
          }
        }

        else
        {
          unint64_t v12 = (unsigned __int8 *)v237;
          if ((v241 & 0x1000000000000000LL) == 0) {
            unint64_t v12 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v241, v9);
          }
          Swift::UInt32 value = v12[v10];
          if ((char)v12[v10] < 0) {
            __asm { BR              X9 }
          }
        }

        Swift::Int scalarLength = 1LL;
      }

      v10 += scalarLength;
      switch(value)
      {
        case '""':
          unint64_t v16 = 0xE200000000000000LL;
          uint64_t v17 = 8796LL;
          goto LABEL_22;
        case '\\':
          unint64_t v16 = 0xE200000000000000LL;
          uint64_t v17 = 23644LL;
          goto LABEL_22;
        case '\'':
          unint64_t v16 = 0xE200000000000000LL;
          uint64_t v17 = 10076LL;
          goto LABEL_22;
      }

      if (value - 127 <= 0xFFFFFFA0) {
        break;
      }
LABEL_84:
      uint64_t v242 = v10;
      uint64_t v89 = v248;
      unint64_t v90 = v249;
      if ((v11 & 1) != 0)
      {
        LODWORD(v246) = 0;
        swift_bridgeObjectRetain(v249, scalarLength, a3, a4);
        unint64_t v91 = specialized BidirectionalCollection.last.getter(v89, v90);
        swift_bridgeObjectRelease(v90);
        if ((v91 & 0x100000000LL) != 0)
        {
          unint64_t v235 = 816LL;
          goto LABEL_265;
        }

        if (!_GraphemeBreakingState.shouldBreak(between:and:)( (Swift::Unicode::Scalar)v91,  (Swift::Unicode::Scalar)value))
        {
          Swift::String_optional v119 = Unicode.Scalar._escaped(asASCII:)(1);
          unint64_t v116 = (unint64_t)v119.value._object;
          if (v119.value._object) {
            uint64_t v120 = v119.value._countAndFlagsBits;
          }
          else {
            uint64_t v120 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
          }
          unint64_t v121 = v116;
          uint64_t v141 = HIBYTE(v90) & 0xF;
          if ((v90 & 0x2000000000000000LL) == 0) {
            uint64_t v141 = v89 & 0xFFFFFFFFFFFFLL;
          }
          if (!v141 && (v89 & ~v90 & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease(v90);
            uint64_t v248 = v120;
            unint64_t v249 = v121;
            goto LABEL_58;
          }

          if ((v90 & 0x2000000000000000LL) != 0)
          {
            if ((v116 & 0x2000000000000000LL) != 0)
            {
              unint64_t v148 = specialized _SmallString.init(_:appending:)(v89, v90, v120, v116);
              if ((v117 & 1) != 0) {
                goto LABEL_162;
              }
              uint64_t v149 = v148;
              unint64_t v150 = v116;
              swift_bridgeObjectRelease(v90);
              swift_bridgeObjectRelease(v121);
              uint64_t v248 = v149;
              unint64_t v249 = v150;
              goto LABEL_58;
            }
          }

          else if ((v116 & 0x2000000000000000LL) != 0)
          {
LABEL_162:
            uint64_t v142 = HIBYTE(v121) & 0xF;
LABEL_163:
            swift_bridgeObjectRetain(v121, v116, v117, v118);
            _StringGuts.append(_:)(v120, v121, 0LL, v142);
            swift_bridgeObjectRelease_n(v121, 2LL);
LABEL_58:
            uint64_t v10 = v242;
            goto LABEL_6;
          }

          uint64_t v142 = v120 & 0xFFFFFFFFFFFFLL;
          goto LABEL_163;
        }
      }

      uint64_t v246 = v89;
      uint64_t v247 = v90;
      uint64_t v248 = 0LL;
      unint64_t v249 = 0xE000000000000000LL;
      uint64_t v95 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
      unint64_t v96 = v92;
      uint64_t v97 = v92 & 0x2000000000000000LL;
      uint64_t v98 = HIBYTE(v92) & 0xF;
      uint64_t v99 = HIBYTE(v90) & 0xF;
      if ((v90 & 0x2000000000000000LL) != 0 && v97)
      {
        if ((unint64_t)(v98 + v99) <= 0xF)
        {
          swift_bridgeObjectRelease(v92);
          if (v98)
          {
            char v129 = 0;
            unint64_t v130 = 0LL;
            unint64_t v131 = v90;
            do
            {
              unint64_t v132 = v99 + v130;
              unint64_t v133 = v130 + 1;
              if (v130 >= 8) {
                unint64_t v134 = v96;
              }
              else {
                unint64_t v134 = v95;
              }
              unint64_t v135 = v134 >> (v129 & 0x38);
              char v136 = (8 * v99 + v129) & 0x38;
              uint64_t v137 = (-255LL << v136) - 1;
              unint64_t v138 = (unint64_t)v135 << v136;
              unint64_t v139 = v138 | v137 & v131;
              unint64_t v140 = v138 | v137 & v89;
              if (v132 < 8) {
                uint64_t v89 = v140;
              }
              else {
                unint64_t v131 = v139;
              }
              v129 += 8;
              unint64_t v130 = v133;
            }

            while (v98 != v133);
          }

          else
          {
            unint64_t v131 = v90;
          }

          swift_bridgeObjectRelease(v90);
          unint64_t v177 = 0xA000000000000000LL;
          if (!(v89 & 0x8080808080808080LL | v131 & 0x80808080808080LL)) {
            unint64_t v177 = 0xE000000000000000LL;
          }
          uint64_t v246 = v89;
          uint64_t v247 = v177 & 0xFF00000000000000LL | ((v98 + v99) << 56) | v131 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_187;
        }

        uint64_t v97 = 1LL;
      }

      if (v97) {
        uint64_t v100 = HIBYTE(v92) & 0xF;
      }
      else {
        uint64_t v100 = v95 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain(v92, v92, v93, v94);
      if ((v96 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v96, 5LL, v101, v102);
        v184._Swift::UInt64 rawBits = 1LL;
        v185._Swift::UInt64 rawBits = (v100 << 16) | 1;
        v186._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v184, v185, v95, v96);
        if (v186._rawBits < 0x10000) {
          v186._rawBits |= 3;
        }
        Swift::Int v103 = specialized Collection.count.getter(v186, v187, v95, v96);
        swift_bridgeObjectRelease(v96);
        uint64_t v236 = v100;
        if ((v90 & 0x1000000000000000LL) != 0)
        {
LABEL_200:
          Swift::Int v188 = String.UTF8View._foreignCount()();
          Swift::Int v105 = v188 + v103;
          if (__OFADD__(v188, v103)) {
            goto LABEL_256;
          }
          goto LABEL_100;
        }
      }

      else
      {
        swift_bridgeObjectRetain_n(v96, 4LL, v101, v102);
        Swift::Int v103 = v100;
        uint64_t v236 = v100;
        if ((v90 & 0x1000000000000000LL) != 0) {
          goto LABEL_200;
        }
      }

      if ((v90 & 0x2000000000000000LL) != 0) {
        uint64_t v104 = HIBYTE(v90) & 0xF;
      }
      else {
        uint64_t v104 = v89 & 0xFFFFFFFFFFFFLL;
      }
      Swift::Int v105 = v104 + v103;
      if (__OFADD__(v104, v103))
      {
LABEL_256:
        __break(1u);
LABEL_257:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }

LABEL_100:
      if ((v89 & ~v90 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v90 & 0xFFFFFFFFFFFFFFFLL))
      {
        uint64_t v106 = v95 & 0xFFFFFFFFFFFFLL;
        uint64_t v108 = v246;
        uint64_t v107 = v247;
        int64_t v109 = _StringGuts.nativeUnusedCapacity.getter(v246, v247);
        if ((v110 & 1) != 0)
        {
LABEL_262:
          unint64_t v234 = 258LL;
LABEL_263:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v234,  0);
        }

        if (v105 > 15) {
          goto LABEL_109;
        }
        if ((v107 & 0x2000000000000000LL) != 0)
        {
          int v128 = 0;
          unint64_t v111 = v107;
          goto LABEL_165;
        }

        unint64_t v111 = v107;
        if (v109 >= v103) {
          goto LABEL_109;
        }
        goto LABEL_134;
      }

      if (v105 >= 16)
      {
        uint64_t v106 = v95 & 0xFFFFFFFFFFFFLL;
        uint64_t v108 = v246;
        uint64_t v107 = v247;
LABEL_109:
        int64_t v112 = _StringGuts.nativeUnusedCapacity.getter(v108, v107);
        BOOL v115 = (v113 & 1) == 0 && v112 >= v103;
        if ((v108 & ~v107 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v107 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v115)
          {
LABEL_129:
            swift_bridgeObjectRelease_n(v96, 4LL);
            if ((v96 & 0x1000000000000000LL) == 0)
            {
              uint64_t v10 = v242;
              if (v97)
              {
                swift_bridgeObjectRelease_n(v96, 2LL);
                uint64_t v244 = v95;
                unint64_t v245 = v96 & 0xFFFFFFFFFFFFFFLL;
                v126 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v98, (uint64_t)&v244, v98);
                _StringGuts.appendInPlace(_:isASCII:)(v126, v127, (v96 & 0x4000000000000000LL) != 0);
                uint64_t v9 = x1_0;
              }

              else
              {
                if ((v95 & 0x1000000000000000LL) != 0)
                {
                  swift_bridgeObjectRelease(v96);
                  id v143 = (id)((v96 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v144 = v106;
                  uint64_t v145 = v106;
                }

                else
                {
                  id v143 = _StringObject.sharedUTF8.getter(v95, v96);
                  uint64_t v145 = v194;
                  swift_bridgeObjectRelease(v96);
                  if (v145 < v106) {
                    goto LABEL_257;
                  }
                  uint64_t v144 = v106;
                }

                uint64_t v9 = x1_0;
                unint64_t v146 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v144, (uint64_t)v143, v145);
                _StringGuts.appendInPlace(_:isASCII:)(v146, v147, v95 < 0);
                swift_bridgeObjectRelease(v96);
              }

              goto LABEL_188;
            }

            swift_bridgeObjectRelease(v96);
            _StringGuts._foreignAppendInPlace(_:)(v95, v96, 0LL, v236);
            swift_bridgeObjectRelease(v96);
LABEL_187:
            uint64_t v9 = x1_0;
            uint64_t v10 = v242;
            goto LABEL_188;
          }

        unint64_t v207 = v198;
        v398 = (char *)((v234 - 1) & v234);
        unint64_t v208 = __clz(__rbit64(v234)) + (v209 << 6);
      }

      v211 = v204;
      uint64_t v212 = v404;
      uint64_t v213 = &v399->Kind;
      ((void (*)(char *, unint64_t, ValueMetadata *))v204[2])( v404,  *(void *)(v96 + 48) + (void)v204[9] * v208,  v399);
      v214 = *(void *)(v96 + 56) + *(void *)(v207 + 72) * v208;
      uint64_t v215 = v396;
      uint64_t v216 = v407;
      (*(void (**)(unint64_t, unint64_t, uint64_t *))(v207 + 16))(v396, v214, v407);
      Swift::String::Index v217 = &v210[*((int *)v406 + 12)];
      Swift::String::Index v218 = v211[4];
      uint64_t v198 = v207;
      TupleTypeMetadata2 = v406;
      ((void (*)(char *, char *, uint64_t *))v218)(v210, v212, v213);
      (*(void (**)(char *, uint64_t, uint64_t *))(v198 + 32))(v217, v215, v216);
      Swift::String::Index v219 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, void, uint64_t, unint64_t *))(v219 + 56))( v210,  0LL,  1LL,  TupleTypeMetadata2);
      goto LABEL_104;
    }

    v220 = v387;
    v221 = *((void *)v387 + 27);
    if (v221 < 0) {
      goto LABEL_103;
    }
    uint64_t v222 = (void *)*((void *)v387 + 26);
    if (v221 == *((void *)v387 + 28))
    {
      int v223 = objc_msgSend(*((id *)v387 + 26), sel_countByEnumeratingWithState_objects_count_, v382, v381, 16);
      v220 = v387;
      *((void *)v387 + 28) = v223;
      if (!v223)
      {
        *((void *)v220 + 27) = -1LL;
LABEL_103:
        Swift::String::Index v219 = *(TupleTypeMetadata2 - 1);
        uint64_t v210 = v390;
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v219 + 56))( v390,  1LL,  1LL,  TupleTypeMetadata2);
        uint64_t v209 = (uint64_t)v395;
        v398 = v397;
LABEL_104:
        v233 = v394;
        goto LABEL_105;
      }

      v221 = 0LL;
      *((void *)v220 + 27) = 0LL;
    }

    int v224 = *((void *)v220 + 3);
    if (!v224) {
      goto LABEL_232;
    }
    Swift::UInt64 v225 = (void **)(v224 + 8 * v221);
    unsigned int v226 = *v225;
    *((void *)v220 + 27) = v221 + 1;
    swift_unknownObjectRetain(v226, v199, v200, v201);
    Swift::String_optional v227 = (swift *)objc_msgSend(v222, sel_objectForKey_, v226);
    if (!v227) {
      goto LABEL_233;
    }
    unint64_t v228 = v227;
    Swift::String::Index v229 = (const char *)v399;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v399, &v399->Kind))
    {
      *(void *)&v412 = v226;
      uint64_t v210 = v390;
      swift_dynamicCast(v390, (uint64_t *)&v412, v384, v229, 7uLL);
    }

    else
    {
      Description[7](v206, 1LL, 1LL, (ValueMetadata *)v229);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v226, (uint64_t)v229, v206);
      swift_unknownObjectRelease(v226);
      v254 = v206;
      v255 = v378;
      v256 = v386;
      (*(void (**)(id *, uint64_t *, uint64_t))(v378 + 16))(v205, v254, v386);
      (*(void (**)(uint64_t *, uint64_t))(v255 + 8))(v254, v256);
      uint64_t v210 = v390;
      ((void (*)(char *, id *, const char *))Description[4])(v390, v205, v229);
    }

    unint64_t v230 = &v210[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v231 = (const char *)v407;
    unint64_t v232 = _swift_isClassOrObjCExistentialType((uint64_t)v407, v407);
    v233 = v394;
    if (v232)
    {
      *(void *)&v412 = v228;
      swift_dynamicCast(v230, (uint64_t *)&v412, (swift *)&unk_189B8D230, v231, 7uLL);
    }

    else
    {
      (*(void (**)(uint64_t *, uint64_t, uint64_t, const char *))(v198 + 56))(v203, 1LL, 1LL, v231);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v228, (uint64_t)v231, v203);
      swift_unknownObjectRelease(v228);
      v257 = v379;
      v258 = v203;
      v259 = v376;
      v260 = v377;
      (*(void (**)(char *, uint64_t *, uint64_t))(v379 + 16))(v376, v258, v377);
      (*(void (**)(uint64_t *, uint64_t))(v257 + 8))(v258, v260);
      (*(void (**)(char *, char *, const char *))(v198 + 32))(v230, v259, v231);
      uint64_t v210 = v390;
      v233 = v394;
    }

    Swift::String::Index v219 = *(TupleTypeMetadata2 - 1);
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v219 + 56))( v210,  0LL,  1LL,  TupleTypeMetadata2);
    uint64_t v209 = (uint64_t)v395;
    v398 = v397;
LABEL_105:
    (*(void (**)(char *, char *, uint64_t))(v401 + 32))(v233, v210, v402);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t *))(v219 + 48))( v233,  1LL,  TupleTypeMetadata2) == 1) {
      goto LABEL_121;
    }
    unint64_t v235 = v389;
    uint64_t v236 = v407;
    (*(void (**)(swift *, char *, uint64_t *))(v198 + 32))( v389,  &v233[*((int *)TupleTypeMetadata2 + 12)],  v407);
    uint64_t v237 = (uint64_t *)v404;
    uint64_t v238 = (swift *)v399;
    ((void (*)(char *, char *, ValueMetadata *))Description[4])(v404, v233, v399);
    v239 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CodingKeyRepresentable);
    swift_dynamicCast((char *)v409, v237, v238, v239, 7uLL);
    uint64_t v240 = v410;
    uint64_t v241 = v411;
    __swift_project_boxed_opaque_existential_0Tm(v409, v410);
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v241 + 8))(&v412, v240, v241);
    __swift_destroy_boxed_opaque_existential_1Tm(v409);
    outlined init with take of MirrorPath(&v412, (uint64_t)v409);
    uint64_t v242 = v410;
    char v243 = v411;
    __swift_project_boxed_opaque_existential_0Tm(v409, v410);
    uint64_t v244 = (*(uint64_t (**)(uint64_t, uint64_t))(v243 + 24))(v242, v243);
    uint64_t v246 = v245;
    uint64_t v247 = v198;
    unint64_t v249 = v410;
    uint64_t v248 = v411;
    __swift_project_boxed_opaque_existential_0Tm(v409, v410);
    Swift::String::Index v250 = (*(uint64_t (**)(uint64_t, uint64_t))(v248 + 40))(v249, v248);
    LOBYTE(v248) = v251;
    __swift_destroy_boxed_opaque_existential_1Tm(v409);
    v409[0] = v244;
    v409[1] = v246;
    v409[2] = v250;
    LOBYTE(v410) = v248 & 1;
    v252 = v405;
    (*(void (**)(swift *, uint64_t *, uint64_t *, ValueMetadata *, uint64_t, _UNKNOWN **))(*(void *)v416
                                                                                                 + 232LL))( v235,  v409,  v236,  &type metadata for _DictionaryCodingKey,  v400,  &protocol witness table for _DictionaryCodingKey);
    v405 = v252;
    if (v252) {
      break;
    }
    (*(void (**)(swift *, uint64_t *))(v247 + 8))(v235, v236);
    swift_bridgeObjectRelease(v246);
    Swift::String::Index v202 = v209;
    uint64_t v95 = (unint64_t)v398;
    uint64_t v198 = v247;
    uint64_t v204 = Description;
    TupleTypeMetadata2 = v406;
    unint64_t v203 = (uint64_t *)i;
    unint64_t v96 = (unint64_t)v388;
  }

  (*(void (**)(swift *, uint64_t *))(v247 + 8))(v235, v236);
  swift_bridgeObjectRelease(v246);
LABEL_121:
  outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v388);
  uint64_t v193 = v416;
  return swift_release(v193);
}

  (*(void (**)(char *, uint64_t))(v772 + 8))(v768, v237);
  ((void (*)(unint64_t, unint64_t *))v766)(v781, v245);
  v448 = v779;
  if (!(*(uint64_t (**)(uint64_t))(v771 + 136))(v779))
  {
LABEL_154:
    ((void (*)(char **, char **))v381)(v778, v388);
    if (((*(uint64_t (**)(uint64_t))(v764 + 168))(v448) & 1) != 0)
    {
      v670 = v705;
      v388 = v782;
      v675 = v703;
      v676 = swift_getAssociatedConformanceWitness( (uint64_t)v705,  (uint64_t)v782,  v703,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
      v673 = v704;
      (*(void (**)(unint64_t, unint64_t, double))(v676 + 8))(v675, v676, -0.0);
    }

    else
    {
      v670 = v729;
      v388 = v782;
      v671 = v727;
      v672 = swift_getAssociatedConformanceWitness( (uint64_t)v729,  (uint64_t)v782,  v727,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v673 = v728;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v672 + 8))( &unk_18180BE68,  256LL,  v671,  v672);
    }

    v449 = v678;
    (*((void (**)(char *, char **, const char *))v670 + 3))(v673, v388, v670);
    goto LABEL_161;
  }

  if (((*(uint64_t (**)(uint64_t))(v764 + 168))(v448) & 1) != 0)
  {
    v449 = v678;
    v674 = v778;
    (*(void (**)(char **, char **))(v702 + 16))(v778, v388);
    ((void (*)(char **, char **))v381)(v674, v388);
  }

  else
  {
    v449 = v678;
    (*(void (**)(char *, char **, char **))(v767 + 32))(v678, v778, v388);
  }

      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56))(v34, 1LL, 1LL, a2);
      v114 = v56;
    }

    else
    {
      size_t v127 = (unint64_t)v43;
      if (v40)
      {
        if (v126 < 0) {
          Swift::String::Index v45 = v126;
        }
        else {
          Swift::String::Index v45 = v126 & 0xFFFFFFFFFFFFFF8LL;
        }
        Swift::String::Index v46 = type metadata accessor for __CocoaSet.Iterator();
        unint64_t v47 = (unint64_t)swift_allocObject(v46, 0xE8uLL, 7uLL);
        uint64_t v124 = 0LL;
        unint64_t v48 = 0LL;
        unint64_t v49 = 0LL;
        *(void *)(v47 + 208) = v45;
        *(void *)(v47 + 216) = 0LL;
        *(_OWORD *)(v47 + 16) = 0u;
        *(_OWORD *)(v47 + 32) = 0u;
        *(_OWORD *)(v47 + 48) = 0u;
        *(_OWORD *)(v47 + 64) = 0u;
        *(_OWORD *)(v47 + 80) = 0u;
        *(_OWORD *)(v47 + 96) = 0u;
        *(_OWORD *)(v47 + 112) = 0u;
        *(_OWORD *)(v47 + 128) = 0u;
        *(_OWORD *)(v47 + 144) = 0u;
        *(_OWORD *)(v47 + 160) = 0u;
        *(_OWORD *)(v47 + 176) = 0u;
        *(_OWORD *)(v47 + 192) = 0u;
        *(void *)(v47 + 224) = 0LL;
        unint64_t v50 = v47 | 0x8000000000000000LL;
        Swift::String::Index v44 = v126;
        Swift::String::Index v43 = (unint64_t *)v127;
      }

      else
      {
        unint64_t v57 = -1LL << *(_BYTE *)(v126 + 32);
        unint64_t v48 = ~v57;
        uint64_t v58 = *(void *)(v126 + 56);
        uint64_t v124 = (void *)(v126 + 56);
        unint64_t v59 = -v57;
        if (v59 < 64) {
          unint64_t v60 = ~(-1LL << v59);
        }
        else {
          unint64_t v60 = -1LL;
        }
        unint64_t v49 = v60 & v58;
        unint64_t v50 = v126;
      }

      unint64_t v121 = (v50 & 0x7FFFFFFFFFFFFFFFLL) + 80;
      uint64_t v122 = (v50 & 0x7FFFFFFFFFFFFFFFLL) + 16;
      Swift::String_optional v119 = (char *)v48;
      char v123 = (unint64_t)(v48 + 64) >> 6;
      swift_bridgeObjectRetain(v44, v35, v36, v37);
      swift_retain(v43, v61, v62, v63);
      v126 = 0LL;
      uint64_t v125 = (uint64_t *)&unk_189B8D230;
      if ((v50 & 0x8000000000000000LL) == 0) {
        goto LABEL_42;
      }
LABEL_31:
      unint64_t v67 = *(void *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8);
      if ((v67 & 0x8000000000000000LL) == 0)
      {
        if (v67 != *(void *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0xE0))
        {
LABEL_35:
          unint64_t v69 = *(void *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0x18);
          if (!v69) {
            goto LABEL_110;
          }
          if ((unint64_t)(v67 - 0x1000000000000000LL) >> 61 == 7)
          {
            id v70 = (void **)(v69 + 8 * v67);
            if ((v70 & 7) == 0)
            {
              uint64_t v71 = *v70;
              *(void *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = v67 + 1;
              swift_unknownObjectRetain(v71, v64, v65, v66);
              if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
              {
                unint64_t v132 = v71;
                swift_dynamicCast(v32, &v132, v125, a2, 7LL);
                goto LABEL_57;
              }

              uint64_t v72 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
              v72(v120, 1LL, 1LL, a2);
              _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v71, (uint64_t)a2, v120);
              swift_unknownObjectRelease(v71);
              size_t v73 = v116;
              (*(void (**)(char *, uint64_t *, uint64_t))(v118 + 16))(v116, v120, v117);
              if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v8 + 48))(v73, 1LL, a2) != 1)
              {
                (*(void (**)(uint64_t *, uint64_t))(v118 + 8))(v120, v117);
                (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v32, v73, a2);
                while (1)
                {
                  v72((uint64_t *)v32, 0LL, 1LL, a2);
                  unint64_t v80 = v130;
                  (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v130, v32, a2);
                  swift_dynamicCast(v14, v80, a2, a3, 7LL);
                  unsigned int v81 = v128;
                  uint64_t v82 = *(void (**)(char *, char *, ValueMetadata *))(v129 + 32);
                  v82(v128, v14, a3);
                  v82(v14, v81, a3);
                  Swift::String::Index v43 = (unint64_t *)v127;
                  _NativeSet._unsafeInsertNew(_:)((uint64_t)v14, v127, (uint64_t)a3, v131);
                  if ((v50 & 0x8000000000000000LL) != 0) {
                    goto LABEL_31;
                  }
LABEL_42:
                  if (v49)
                  {
                    unint64_t v74 = __clz(__rbit64(v49));
                    v49 &= v49 - 1;
                    uint64_t v75 = v74 | (v126 << 6);
                  }

                  else
                  {
                    unint64_t v76 = v126 + 1;
                    if (__OFADD__(v126, 1LL)) {
                      goto LABEL_105;
                    }
                    if (v76 >= v123) {
                      goto LABEL_98;
                    }
                    uint64_t v77 = v124[v76];
                    unint64_t v78 = v126 + 1;
                    if (!v77)
                    {
                      unint64_t v78 = v126 + 2;
                      if (v126 + 2 >= v123) {
                        goto LABEL_98;
                      }
                      uint64_t v77 = v124[v78];
                      if (!v77)
                      {
                        unint64_t v79 = v126 + 3;
                        if (v126 + 3 >= v123) {
                          goto LABEL_98;
                        }
                        uint64_t v77 = v124[v79];
                        if (!v77)
                        {
                          while (1)
                          {
                            unint64_t v78 = v79 + 1;
                            if (__OFADD__(v79, 1LL)) {
                              break;
                            }
                            if (v78 >= v123) {
                              goto LABEL_98;
                            }
                            uint64_t v77 = v124[v78];
                            ++v79;
                            if (v77) {
                              goto LABEL_55;
                            }
                          }

  unint64_t v116 = v179;
  BOOL v115 = v180;
  swift_bridgeObjectRelease(v3[3]);
  v3[2] = v116;
  v3[3] = v115;
LABEL_115:
  uint64_t v125 = *v3;
  v126 = (unint64_t)*v3 >> 16;
  size_t v127 = v16 - v17 + ((unint64_t)v3[1] >> 16);
  int v128 = ((unint64_t)*v3 >> 8) & 0x3F;
  if (!v128)
  {
    if (v126 >= v16) {
      goto LABEL_120;
    }
LABEL_117:
    if (v16 == v17) {
      return;
    }
LABEL_140:
    v3[1] = (v127 << 16) | 5;
    return;
  }

  if (v128 + v126 < v16) {
    goto LABEL_117;
  }
LABEL_120:
  if (v126 == v127)
  {
    char v129 = 0LL;
    unint64_t v130 = v125 & 0xFFFFFFFFFFFF0000LL;
    goto LABEL_134;
  }

  if ((v115 & 0x1000000000000000LL) != 0) {
    goto LABEL_177;
  }
  if ((v115 & 0x2000000000000000LL) != 0)
  {
    Swift::String::Index v179 = v116;
    Swift::String::Index v180 = v115 & 0xFFFFFFFFFFFFFFLL;
    if (v126 + 1 != (HIBYTE(v115) & 0xF))
    {
      unint64_t v133 = *(unsigned __int16 *)((char *)&v179 + v126);
      goto LABEL_131;
    }

  unint64_t v150 = v443;
  unint64_t v159 = v145;
LABEL_130:
  v199 = v143;
LABEL_131:
  unint64_t v203 = v144;
  uint64_t v204 = v436;
  uint64_t v205 = v451;
  unint64_t v206 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    unint64_t v206 = v450 & 0xFFFFFFFFFFFFLL;
  }
  if (v206 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    if ((v451 & 0x2000000000000000LL) == 0
      || (unint64_t v207 = specialized _SmallString.init(_:appending:)(v450, v451, 0x202CuLL, 0xE200000000000000LL),
          (v171 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v170, v171, v172);
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      unint64_t v208 = v207;
      uint64_t v209 = v170;
      swift_bridgeObjectRelease(v205);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      v450 = v208;
      v451 = v209;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236LL;
    v451 = 0xE200000000000000LL;
  }

  v159(1LL, v199, v203);
  v445 = (uint64_t *)v1;
  uint64_t v210 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v210, v204, v2);
  v211 = v445;
  uint64_t v212 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  uint64_t v213 = (void *)swift_getDynamicType(v212, v211, 1);
  LODWORD(v211) = swift_isOptionalType(v213);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v211)
  {
    memcpy(v150, v204, v2);
    v214 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v214, 7uLL);
    uint64_t v215 = (uint64_t)v445;
    uint64_t v216 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    Swift::String::Index v218 = (*(uint64_t (**)(uint64_t, uint64_t))(v216 + 8))(v215, v216);
    Swift::String::Index v219 = v217;
    v220 = HIBYTE(v451) & 0xF;
    if ((v451 & 0x2000000000000000LL) == 0) {
      v220 = v450 & 0xFFFFFFFFFFFFLL;
    }
    if (v220 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v218, v217);
      swift_bridgeObjectRelease(v219);
    }

    else
    {
      swift_bridgeObjectRelease(v451);
      v450 = v218;
      v451 = v219;
    }

    goto LABEL_154;
  }

  v221 = v428;
  memcpy(v428, v204, v2);
  if ((swift_dynamicCast((char *)&v444, v221, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t v222 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v222);
    goto LABEL_155;
  }

  int v223 = v421;
  memcpy(v421, v204, v2);
  int v224 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v447, v223, v1, v224, 6uLL))
  {
    outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
    Swift::UInt64 v225 = (uint64_t)v445;
    unsigned int v226 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v226 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v225,  v226);
LABEL_154:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_155;
  }

  v449 = 0LL;
  v447 = 0u;
  v448 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
  Swift::String_optional v227 = v413;
  memcpy(v413, v204, v2);
  unint64_t v228 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v447, v227, v1, v228, 6uLL)
    || (v449 = 0LL,
        v447 = 0u,
        v448 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?),  Swift::String::Index v229 = v405,  memcpy(v405, v204, v2),  v230 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v447, v229, v1, v230, 6uLL)))
  {
    outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
    uint64_t v231 = (uint64_t)v445;
    unint64_t v232 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v233 = (*(uint64_t (**)(uint64_t, uint64_t))(v232 + 8))(v231, v232);
    unint64_t v235 = v234;
    specialized String.write<A>(to:)(&v450, v233, v234, v236);
    swift_bridgeObjectRelease(v235);
    goto LABEL_154;
  }

  v449 = 0LL;
  v447 = 0u;
  v448 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v448 + 1) = v1;
  v377 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
  memcpy(v377, v204, v2);
  Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
  v378 = v444._object;
  v379 = v446;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v204,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  swift_release(v379);
  swift_release((uint64_t)v378);
LABEL_155:
  uint64_t v237 = v438;
  uint64_t v238 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    uint64_t v238 = v450 & 0xFFFFFFFFFFFFLL;
  }
  if (v238 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236LL;
    v451 = 0xE200000000000000LL;
  }

  v159(2LL, v199, v203);
  v445 = (uint64_t *)v1;
  v239 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v239, v237, v2);
  uint64_t v240 = v445;
  uint64_t v241 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  uint64_t v242 = (void *)swift_getDynamicType(v241, v240, 1);
  LODWORD(v240) = swift_isOptionalType(v242);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v240)
  {
    memcpy(v150, v237, v2);
    char v243 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v243, 7uLL);
LABEL_162:
    uint64_t v244 = (uint64_t)v445;
    unint64_t v245 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    uint64_t v246 = (*(uint64_t (**)(uint64_t, uint64_t))(v245 + 8))(v244, v245);
    uint64_t v248 = v247;
    specialized String.write<A>(to:)(&v450, v246, v247, v249);
    swift_bridgeObjectRelease(v248);
LABEL_163:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_166;
  }

  Swift::String::Index v250 = v429;
  memcpy(v429, v237, v2);
  if ((swift_dynamicCast((char *)&v444, v250, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v251 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v251);
  }

  else
  {
    v329 = v422;
    memcpy(v422, v237, v2);
    v330 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v329, v1, v330, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v331 = (uint64_t)v445;
      v332 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v332 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v331,  v332);
      goto LABEL_163;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v353 = v414;
    memcpy(v414, v237, v2);
    v354 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v353, v1, v354, 6uLL)
      || (v449 = 0LL,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?),  v355 = v406,  memcpy(v406, v237, v2),  v356 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v447, v355, v1, v356, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_162;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v448 + 1) = v1;
    v380 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v380, v237, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v381 = v444._object;
    v382 = v237;
    v383 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v382,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v383);
    swift_release((uint64_t)v381);
  }

      abort();
    }

    if ((v11 & 0x1F) - 17 >= 2)
    {
      if ((v11 & 0x1F) != 0x10) {
        goto LABEL_100;
      }
      if ((v11 & 0x20000000) != 0)
      {
        unint64_t v57 = (int)v10[6];
        if ((_DWORD)v57) {
          uint64_t v58 = (unint64_t *)((char *)v10 + v57 + 24);
        }
        else {
          uint64_t v58 = 0LL;
        }
        unint64_t v59 = *v58;
        if (!*v58)
        {
          computeMetadataBoundsFromSuperclass(v10, (uint64_t)v58, v4, v5);
          unint64_t v59 = v60;
        }

        unsigned int v13 = v59 >> 3;
      }

      else
      {
        if ((v11 & 0x10000000) != 0)
        {
          unint64_t v36 = 0;
          uint64_t v37 = v10 + 6;
        }

        else
        {
          unint64_t v36 = v10[7];
          uint64_t v37 = v10 + 8;
        }

        LODWORD(v13) = v36 - *v37;
      }
    }

    else
    {
      LODWORD(v13) = 2;
    }

    unint64_t v14 = &v3[(int)v13];
    Cache = getCache(v10);
    unint64_t v16 = (uint64_t)Cache;
    uint64_t v17 = *((unsigned __int16 *)Cache + 28);
    uint64_t v18 = *((unsigned __int16 *)Cache + 30);
    unint64_t v19 = *((unsigned __int16 *)Cache + 31);
    unint64_t v20 = Cache[8];
    unint64_t v21 = (1455063249 * v17);
    if (*((_WORD *)Cache + 28))
    {
      uint64_t v22 = 0LL;
      unint64_t v23 = *((unsigned __int16 *)Cache + 31);
      do
      {
        if (v22 >= v18 || *(_WORD *)(v20 + 8 * v22) || (unint64_t v24 = v20 + 8 * v22, v23 != *(unsigned __int16 *)(v24 + 2)))
        {
          unint64_t v21 = __ROR8__(v21, 10) ^ (v14[v23] >> 19) ^ v14[v23];
        }

        else
        {
          uint64_t v25 = v14[*(unsigned __int16 *)(v24 + 4)];
          ++v22;
          if (v25)
          {
            uint64_t v26 = 0LL;
            do
            {
              uint64_t v27 = *(void *)((v14[v23] & 0xFFFFFFFFFFFFFFFELL) + 8 * v26);
              unint64_t v21 = __ROR8__(v21, 10) ^ (v27 >> 19) ^ v27;
              ++v26;
            }

            while (v25 > v26);
          }
        }

        ++v23;
      }

      while (v23 != v19 + v17);
    }

    do
      Swift::Int v28 = __ldaxr((unsigned int *)v16);
    while (__stxr(v28 + 1, (unsigned int *)v16));
    do
    {
      BOOL v29 = atomic_load((unint64_t *)(v16 + 8));
      int64_t v30 = atomic_load((unint64_t *)(v16 + 16));
      unint64_t v31 = atomic_load((unsigned int *)(v16 + 4));
      int64_t v32 = atomic_load((unint64_t *)(v16 + 8));
    }

    while (v29 != v32);
    if (v29) {
      char v33 = v29 + 8;
    }
    else {
      char v33 = 0LL;
    }
    v65[0] = v16;
    v65[1] = v30;
    v65[2] = v33;
    v65[3] = v31;
    if (v34) {
      uint64_t v34 = (unint64_t *)*v34;
    }
    do
      size_t v35 = __ldxr((unsigned int *)v16);
    while (__stlxr(v35 - 1, (unsigned int *)v16));
  }

  return v3;
}

LABEL_122:
          uint64_t v122 = _StringGuts.nativeCapacity.getter(v108, v107);
          if ((v123 & 1) != 0) {
            uint64_t v124 = 0LL;
          }
          else {
            uint64_t v124 = v122;
          }
          if (v124 + 0x4000000000000000LL < 0)
          {
            __break(1u);
LABEL_259:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
          }

          uint64_t v125 = 2 * v124;
          if (v125 > v105) {
            Swift::Int v105 = v125;
          }
        }

        else if (!v115)
        {
          goto LABEL_122;
        }

        _StringGuts.grow(_:)(v105);
        goto LABEL_129;
      }

      unint64_t v111 = v247;
      if ((v247 & 0x2000000000000000LL) != 0)
      {
        int v128 = 0;
        uint64_t v107 = v247;
        goto LABEL_165;
      }

      uint64_t v107 = v247;
LABEL_134:
      int v128 = 1;
LABEL_165:
      uint64_t v9 = x1_0;
      uint64_t v10 = v242;
      swift_bridgeObjectRelease_n(v96, 5LL);
      unint64_t v154 = v246;
      if (v128)
      {
        if ((v111 & 0x1000000000000000LL) != 0)
        {
          unint64_t v154 = _StringGuts._foreignConvertedToSmall()(v246, v107);
          unint64_t v111 = v195;
        }

        else
        {
          if ((v246 & 0x1000000000000000LL) != 0)
          {
            v190 = (unsigned __int8 *)((v111 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v191 = v246 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            v190 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v246, v107);
            uint64_t v191 = v151;
          }

          swift_bridgeObjectRetain(v107, v151, v152, v153);
          closure #1 in _StringGuts._convertedToSmall()(v190, v191, &v244);
          swift_bridgeObjectRelease(v107);
          unint64_t v154 = v244;
          unint64_t v111 = v245;
        }
      }

      v155._Swift::UInt64 rawBits = (v236 << 16) | 1;
      v156._Swift::UInt64 rawBits = 1LL;
      v157._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v156, v155, v95, v96);
      if (v157._rawBits < 0x10000) {
        v157._rawBits |= 3;
      }
      unint64_t v159 = specialized String.init(_:)(v157, v158, v95, v96);
      unint64_t v161 = v160;
      swift_bridgeObjectRelease(v96);
      if ((v161 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v161);
      }

      else if ((v161 & 0x1000000000000000LL) != 0)
      {
        unint64_t v159 = _StringGuts._foreignConvertedToSmall()(v159, v161);
        unint64_t v197 = v196;
        swift_bridgeObjectRelease(v161);
        unint64_t v161 = v197;
      }

      else
      {
        if ((v159 & 0x1000000000000000LL) != 0)
        {
          v192 = (unsigned __int8 *)((v161 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v193 = v159 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v192 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v159, v161);
        }

        closure #1 in _StringGuts._convertedToSmall()(v192, v193, &v244);
        swift_bridgeObjectRelease(v161);
        unint64_t v159 = v244;
        unint64_t v161 = v245;
      }

      uint64_t v162 = HIBYTE(v111) & 0xF;
      uint64_t v163 = HIBYTE(v161) & 0xF;
      uint64_t v164 = v163 + v162;
      if ((unint64_t)(v163 + v162) > 0xF)
      {
LABEL_261:
        unint64_t v234 = 266LL;
        goto LABEL_263;
      }

      if (v163)
      {
        char v165 = 0;
        unint64_t v166 = 0LL;
        do
        {
          unint64_t v167 = v162 + v166;
          unint64_t v168 = v166 + 1;
          if (v166 >= 8) {
            unint64_t v169 = v161;
          }
          else {
            unint64_t v169 = v159;
          }
          unint64_t v170 = v169 >> (v165 & 0x38);
          char v171 = (8 * v162 + v165) & 0x38;
          uint64_t v172 = (-255LL << v171) - 1;
          unint64_t v173 = (unint64_t)v170 << v171;
          unint64_t v174 = v173 | v172 & v111;
          unint64_t v175 = v173 | v172 & v154;
          if (v167 < 8) {
            unint64_t v154 = v175;
          }
          else {
            unint64_t v111 = v174;
          }
          v165 += 8;
          unint64_t v166 = v168;
        }

        while (v163 != v168);
      }

      swift_bridgeObjectRelease(v107);
      unint64_t v176 = 0xA000000000000000LL;
      if (!(v154 & 0x8080808080808080LL | v111 & 0x80808080808080LL)) {
        unint64_t v176 = 0xE000000000000000LL;
      }
      uint64_t v246 = v154;
      uint64_t v247 = v176 & 0xFF00000000000000LL | (v164 << 56) | v111 & 0xFFFFFFFFFFFFFFLL;
LABEL_188:
      uint64_t v5 = v246;
      unint64_t v178 = v247;
      swift_bridgeObjectRelease(v249);
      char v11 = 0;
      uint64_t v248 = v5;
      unint64_t v249 = v178;
      if (v10 >= v240) {
        goto LABEL_220;
      }
    }

    unint64_t v16 = 0xE200000000000000LL;
    uint64_t v17 = 29788LL;
    switch(value)
    {
      case 0u:
        uint64_t v17 = 12380LL;
        break;
      case 9u:
        break;
      case 0xAu:
        uint64_t v17 = 28252LL;
        break;
      case 0xDu:
        uint64_t v17 = 29276LL;
        break;
      default:
        if (value > 0x7F) {
          goto LABEL_84;
        }
        uint64_t v75 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)((value >> 4) | 0x30);
        uint64_t v77 = v76;
        unint64_t v78 = specialized static String.+ infix(_:_:)(0x7B755CuLL, 0xE300000000000000LL, v75, v76);
        unint64_t v80 = v79;
        swift_bridgeObjectRelease(0xE300000000000000LL);
        swift_bridgeObjectRelease(v77);
        if ((value & 0xF) >= 0xA) {
          unsigned int v81 = (value & 0xF) + 55;
        }
        else {
          unsigned int v81 = value & 0xF | 0x30;
        }
        uint64_t v82 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v81);
        uint64_t v84 = v83;
        unint64_t v85 = specialized static String.+ infix(_:_:)(v78, v80, v82, v83);
        unint64_t v87 = v86;
        swift_bridgeObjectRelease(v80);
        swift_bridgeObjectRelease(v84);
        uint64_t v17 = specialized static String.+ infix(_:_:)(v85, v87, 125LL, 0xE100000000000000LL);
        unint64_t v16 = v88;
        swift_bridgeObjectRelease(v87);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        break;
    }

        unint64_t v121 = (v140 - 1) & v140;
        unint64_t v134 = __clz(__rbit64(v140)) + (v139 << 6);
        Swift::UInt64 v225 = v139;
      }

      (*(void (**)(int64_t, unint64_t, uint64_t))(v51 + 16))( v4,  *(void *)(v41 + 56) + *(void *)(v51 + 72) * v134,  v3);
    }

    (*(void (**)(int64_t, void, uint64_t, uint64_t))(v51 + 56))(v4, 0LL, 1LL, v3);
    uint64_t v17 = *(void *)(v51 + 32);
    ((void (*)(char *, int64_t, uint64_t))v17)(v6, v4, v3);
    if ((v50 & 1) == 0) {
      break;
    }
LABEL_107:
    unint64_t v130 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v130, v229);
    *((_OWORD *)inited + 1) = v226;
    inited[7] = v3;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    ((void (*)(void *, char *, uint64_t))v17)(boxed_opaque_existential_0Tm, v6, v3);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  (uint64_t *)&v231);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    unint64_t v50 = 0LL;
  }

  unint64_t v49 = (unint64_t)v6;
  unint64_t v41 = v231;
  uint64_t v144 = v232;
  uint64_t v145 = HIBYTE(v232) & 0xF;
  if ((v232 & 0x2000000000000000LL) != 0) {
    unint64_t v146 = HIBYTE(v232) & 0xF;
  }
  else {
    unint64_t v146 = v231 & 0xFFFFFFFFFFFFLL;
  }
  if (!v146 && (v231 & ~v232 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v232);
    uint64_t v231 = 8236LL;
    unint64_t v232 = 0xE200000000000000LL;
    goto LABEL_105;
  }

  if ((v232 & 0x2000000000000000LL) != 0 && v145 <= 0xD)
  {
    size_t v147 = 8 * (HIBYTE(v232) & 7);
    unint64_t v148 = (-255LL << v147) - 1;
    uint64_t v149 = 44LL << v147;
    unint64_t v150 = v145 + 1;
    if (v145 >= 8)
    {
      uint64_t v151 = v149 | v148 & v232;
      uint64_t v6 = (char *)v49;
    }

    else
    {
      unint64_t v41 = v149 | v148 & v231;
      uint64_t v6 = (char *)v49;
      if (v145 != 7)
      {
        unint64_t v41 = (32LL << (8 * (v150 & 7u))) | ((-255LL << (8 * (v150 & 7u))) - 1) & v41;
        unint64_t v178 = v232;
        goto LABEL_158;
      }

      unint64_t v150 = 8;
      uint64_t v151 = v232;
    }

    unint64_t v178 = (32LL << (8 * (v150 & 7u))) | ((-255LL << (8 * (v150 & 7u))) - 1) & v151;
LABEL_158:
    swift_bridgeObjectRelease(v232);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    Swift::String::Index v179 = 0xE000000000000000LL;
    if (v41 & 0x8080808080808080LL | v178 & 0x80808080808080LL) {
      Swift::String::Index v179 = 0xA000000000000000LL;
    }
    uint64_t v231 = v41;
    unint64_t v232 = (v179 & 0xFF00000000000000LL | (v145 << 56) | v178 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
    uint64_t v4 = (int64_t)v222;
    goto LABEL_106;
  }

  swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v142, v143);
  if ((v144 & 0x1000000000000000LL) == 0)
  {
    char v55 = __OFADD__(v146, 2LL);
    uint64_t v152 = v146 + 2;
    if (v55) {
      goto LABEL_163;
    }
LABEL_137:
    if ((v41 & ~v144 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v144 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v153 = _StringGuts.nativeUnusedCapacity.getter(v41, v144);
      if ((v154 & 1) != 0) {
        goto LABEL_211;
      }
      Swift::String::Index v156 = (v144 & 0x2000000000000000LL) == 0 && v153 > 1;
      if (v152 > 15 || v156) {
        goto LABEL_104;
      }
    }

    else if (v152 > 15)
    {
LABEL_104:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v152, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
      unint64_t v230 = v218;
      int v128 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v230, 2LL);
      _StringGuts.appendInPlace(_:isASCII:)(v128, v129, 1);
      swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_105:
      uint64_t v6 = (char *)v49;
LABEL_106:
      unint64_t v41 = v224;
      goto LABEL_107;
    }

    swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
    swift_bridgeObjectRetain(v144, v157, v158, v159);
    unint64_t v160 = _StringGuts._convertedToSmall()(v41, v144);
    uint64_t v162 = v161;
    swift_bridgeObjectRelease(v144);
    v163._Swift::UInt64 rawBits = 1LL;
    v164._Swift::UInt64 rawBits = 131073LL;
    v165._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v163, v164, 0x202CuLL, 0xE200000000000000LL);
    if (v165._rawBits < 0x10000) {
      v165._rawBits |= 3;
    }
    unint64_t v167 = specialized String.init(_:)(v165, v166, 0x202CuLL, 0xE200000000000000LL);
    unint64_t v169 = v168;
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v170 = _StringGuts._convertedToSmall()(v167, v169);
    uint64_t v172 = v171;
    swift_bridgeObjectRelease(v169);
    unint64_t v173 = specialized _SmallString.init(_:appending:)(v160, v162, v170, v172);
    if ((v175 & 1) != 0) {
      goto LABEL_210;
    }
    unint64_t v176 = v173;
    unint64_t v177 = v174;
    swift_bridgeObjectRelease(v144);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    uint64_t v231 = v176;
    unint64_t v232 = v177;
    unint64_t v51 = v219;
    uint64_t v4 = (int64_t)v222;
    goto LABEL_105;
  }

  Swift::String::Index v180 = String.UTF8View._foreignCount()();
  uint64_t v152 = v180 + 2;
  if (!__OFADD__(v180, 2LL)) {
    goto LABEL_137;
  }
LABEL_163:
  __break(1u);
LABEL_164:
  (*(void (**)(int64_t, uint64_t, uint64_t, uint64_t))(v51 + 56))(v4, 1LL, 1LL, v3);
  outlined consume of [A : B].Iterator._Variant<A, B>(v41);
  uint64_t v3 = v231;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = v232;
  Swift::Int v183 = HIBYTE(v232) & 0xF;
  if ((v232 & 0x2000000000000000LL) != 0) {
    Swift::String::Index v184 = HIBYTE(v232) & 0xF;
  }
  else {
    Swift::String::Index v184 = v231 & 0xFFFFFFFFFFFFLL;
  }
  if (v184 || (v231 & ~v232 & 0x2000000000000000LL) != 0)
  {
    if ((v232 & 0x2000000000000000LL) == 0 || v183 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v181, v182);
      if ((v15 & 0x1000000000000000LL) != 0) {
        goto LABEL_208;
      }
      goto LABEL_175;
    }

    if (v183 < 8)
    {
      uint64_t v3 = (93LL << (8 * (HIBYTE(v232) & 7u))) | ((-255LL << (8 * (HIBYTE(v232) & 7u))) - 1) & v231;
      if (v183 != 7) {
        uint64_t v3 = (41LL << (8 * ((v183 + 1) & 7))) | ((-255LL << (8 * ((v183 + 1) & 7))) - 1) & v3;
      }
    }

    swift_bridgeObjectRelease(v232);
    swift_bridgeObjectRelease(0x80000001818B6150LL | 0x8000000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v232);
    swift_bridgeObjectRelease(0x80000001818B6150LL | 0x8000000000000000LL);
    return 10589LL;
  }

  return v3;
}

    unint64_t v94 = _StringGuts.nativeUnusedCapacity.getter(v91, v8);
    char v11 = (v95 & 1) == 0 && v94 >= (uint64_t)v12;
    if ((v91 & ~v8 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v11 & 1) != 0) {
        goto LABEL_140;
      }
    }

    else if ((v11 & 1) != 0)
    {
      goto LABEL_139;
    }

    uint64_t v97 = _StringGuts.nativeCapacity.getter(v91, v8);
    if ((v98 & 1) != 0) {
      uint64_t v99 = 0LL;
    }
    else {
      uint64_t v99 = v97;
    }
    if (v99 + 0x4000000000000000LL >= 0)
    {
      uint64_t v100 = 2 * v99;
      if (v100 > v14) {
        unint64_t v14 = v100;
      }
LABEL_139:
      _StringGuts.grow(_:)(v14);
LABEL_140:
      swift_bridgeObjectRelease_n(a1, 4LL);
      if ((a1 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(a1);
        _StringGuts._foreignAppendInPlace(_:)(v7, a1, 0LL, v1);
      }

      else
      {
        if (v15)
        {
          swift_bridgeObjectRelease_n(a1, 2LL);
          *(void *)&Swift::String::Index v202 = v7;
          *((void *)&v202 + 1) = a1 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v101 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, i, (uint64_t)&v202, i);
          _StringGuts.appendInPlace(_:isASCII:)(v101, v102, (a1 & 0x4000000000000000LL) != 0);
          swift_bridgeObjectRelease(a1);
          goto LABEL_187;
        }

        if ((v7 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(a1);
          Swift::String_optional v119 = (id)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v120 = v201;
          unint64_t v121 = v201;
        }

        else
        {
          Swift::String_optional v119 = _StringObject.sharedUTF8.getter(v7, a1);
          unint64_t v121 = v194;
          swift_bridgeObjectRelease(a1);
          if (v121 < v201) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
          }
          uint64_t v120 = v201;
        }

        uint64_t v122 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v120, (uint64_t)v119, v121);
        _StringGuts.appendInPlace(_:isASCII:)(v122, v123, v7 < 0);
      }

      swift_bridgeObjectRelease_n(a1, 2LL);
      goto LABEL_187;
    }

    __break(1u);
LABEL_249:
    __break(1u);
LABEL_250:
    uint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, v8);
  }

  if (v14 >= 16)
  {
    Swift::String::Index v201 = v7 & 0xFFFFFFFFFFFFLL;
    unint64_t v91 = v203;
    uint64_t v8 = v204;
    goto LABEL_122;
  }

  char v11 = v204;
  if ((v204 & 0x2000000000000000LL) != 0)
  {
    Swift::Int v105 = 0;
    uint64_t v8 = v204;
  }

  else
  {
    uint64_t v8 = v204;
LABEL_145:
    Swift::Int v105 = 1;
  }

    swift_bridgeObjectRetain_n(v27, 3LL, v30, (char *)v31);
    v159._Swift::UInt64 rawBits = a2 & 0xFFFFFFFFFFFF0000LL | 1;
    v160._Swift::UInt64 rawBits = v34 & 0xFFFFFFFFFFFF0000LL | 1;
    uint64_t v95 = v170;
    v161._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v159, v160, v25, v27);
    if (v161._rawBits < 0x10000) {
      v161._rawBits |= 3;
    }
    uint64_t v98 = specialized Collection.count.getter(v161, v162, v25, v27);
    swift_bridgeObjectRelease(v32);
    swift_bridgeObjectRelease(v27);
    if ((v32 & 0x1000000000000000LL) == 0) {
      goto LABEL_65;
    }
    goto LABEL_125;
  }

  unint64_t v14 = *(void *)(a3 + 16);
  if (v14)
  {
    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = 0LL;
    unint64_t v16 = (void *)(a3 + 40);
    uint64_t v17 = 15LL;
    while (1)
    {
      uint64_t v18 = *(v16 - 1) & 0xFFFFFFFFFFFFLL;
      if ((*v16 & 0x2000000000000000LL) != 0) {
        uint64_t v18 = HIBYTE(*v16) & 0xFLL;
      }
      unint64_t v19 = v18 == 0;
      if (v18) {
        break;
      }
      v16 += 2;
      if (v14 == ++v15)
      {
        uint64_t v17 = 0LL;
        Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = *(void *)(a3 + 16);
        break;
      }
    }
  }

  else
  {
    uint64_t v17 = 0LL;
    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = 0LL;
    unint64_t v19 = 1;
  }

  swift_bridgeObjectRetain(a3, v11, v12, v13);
  unint64_t v76 = specialized FlattenSequence<>.distance(from:to:)( v15,  v17,  v19,  v14,  0LL,  1,  a3,  (void (*)(unint64_t *__return_ptr, uint64_t *))closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL);
  uint64_t v77 = a1 >> 16;
  unint64_t v78 = v77 + v76;
  if (__OFADD__(v77, v76))
  {
    __break(1u);
LABEL_129:
    __break(1u);
    goto LABEL_130;
  }

  uint64_t v17 = a2 >> 16;
  unint64_t v79 = v9 & 0xFFFFFFFFFFFFLL;
  if ((v8 & 0x2000000000000000LL) != 0) {
    unint64_t v79 = HIBYTE(v8) & 0xF;
  }
  unint64_t v80 = v79 - v17;
  unsigned int v81 = v78 + v80;
  if (__OFADD__(v78, v80)) {
    goto LABEL_129;
  }
  uint64_t v82 = v76;
  if (v81 >= 16)
  {
    unint64_t v83 = v76;
    uint64_t v84 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v85 & 1) != 0 || (uint64_t v82 = v83, v84 < v81))
    {
      unint64_t v86 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v87 & 1) != 0)
      {
        uint64_t v145 = v4[1];
        if ((v145 & 0x1000000000000000LL) != 0)
        {
          unint64_t v88 = String.UTF8View._foreignCount()();
        }

        else if ((v145 & 0x2000000000000000LL) != 0)
        {
          unint64_t v88 = HIBYTE(v145) & 0xF;
        }

        else
        {
          unint64_t v88 = *v4 & 0xFFFFFFFFFFFFLL;
        }
      }

      else
      {
        unint64_t v88 = 2 * v86;
      }

      if (v88 > v81) {
        unsigned int v81 = v88;
      }
      unint64_t v146 = v4[1];
      if ((v146 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignGrow(_:)(v81);
      }

      else
      {
        size_t v147 = *v4;
        if ((v146 & 0x2000000000000000LL) != 0)
        {
          unint64_t v150 = (v146 >> 62) & 1;
          unint64_t v173 = *v4;
          unint64_t v174 = v146 & 0xFFFFFFFFFFFFFFLL;
          unint64_t v148 = (char *)&v173;
          uint64_t v149 = HIBYTE(v146) & 0xF;
        }

        else
        {
          if ((v147 & 0x1000000000000000LL) != 0)
          {
            unint64_t v148 = (char *)((v146 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v149 = v147 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            unint64_t v148 = (char *)_StringObject.sharedUTF8.getter(*v4, v146);
          }

          unint64_t v150 = v147 >> 63;
        }

        uint64_t v151 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v148,  v149,  v81,  v150);
        uint64_t v152 = *(void *)(v151 + 24);
        swift_bridgeObjectRelease(v4[1]);
        uint64_t *v4 = v152;
        v4[1] = v151;
      }

      uint64_t v82 = v83;
    }
  }

  uint64_t v153 = v4[1];
  specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( v77,  a2 >> 16,  a3,  (uint64_t)closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL,  v82);
  swift_bridgeObjectRelease(a3);
  uint64_t *v4 = *(void *)(v153 + 24);
  return v77;
}

        uint64_t v162 = &TypeName->u8[v124];
        uint64_t v163 = v123 - v124;
        do
        {
          uint64_t v164 = *v162++;
          countAndFlagsBits |= (unint64_t)v164 << (v125 & 0x38);
          v125 += 8LL;
          --v163;
        }

        while (v163);
        goto LABEL_124;
      }

              if (v77 == v245)
              {
                v263 = &v260;
                (*(void (**)(void *, uint64_t *))(v245[0] + 24LL))(v245, &v260);
              }

              else
              {
                v263 = (uint64_t *)(*(uint64_t (**)(void *))(*v77 + 16LL))(v77);
              }

        int64_t v32 = 0LL;
        break;
      case 'l':
        uint64_t v8 = 0LL;
        uint64_t v10 = 4;
        goto LABEL_7;
      case 'm':
        uint64_t v9 = 4;
        goto LABEL_35;
      case 'p':
        uint64_t v9 = 0;
        goto LABEL_35;
      case 's':
        uint64_t v8 = 0LL;
        uint64_t v10 = 2;
        goto LABEL_7;
      case 't':
        uint64_t v9 = 2;
LABEL_35:
        uint64_t v27 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleGenericParamIndex( this,  a2,  a3,  a4,  a5);
        uint64_t v25 = swift::Demangle::__runtime::Demangler::demangleAssociatedTypeSimple(this, v27, v28, v29, v30);
LABEL_36:
        unint64_t v14 = v25;
        unint64_t v83 = v25;
        if (v25) {
          swift::Demangle::__runtime::Vector<swift::Demangle::__runtime::Node *>::push_back( (const void **)this + 13,  (uint64_t *)&v83,  this);
        }
        uint64_t v8 = 0LL;
LABEL_39:
        uint64_t v10 = v9;
        goto LABEL_40;
      case 'v':
        goto LABEL_7;
      default:
        goto LABEL_6;
    }
  }

  return v32;
}

  if (v53 <= v52) {
    goto LABEL_143;
  }
  if (v54 >= 2) {
    unint64_t v51 = (uint64_t **)*v51;
  }
  char v55 = v51[v52];
  operator delete(v39);
  uint64_t v56 = *((unsigned __int8 *)v55 + 18);
  if (v56 == 5 && *((_DWORD *)v55 + 2))
  {
    char v55 = (uint64_t *)*v55;
LABEL_131:
    unint64_t v57 = (uint64_t *)*v55;
    goto LABEL_133;
  }

  unint64_t v57 = 0LL;
LABEL_133:
  uint64_t v58 = *((unsigned __int8 *)v57 + 18);
  if (v58 == 2)
  {
LABEL_137:
    unint64_t v59 = (void *)v57[1];
    goto LABEL_139;
  }

  if (v58 == 5 && *((_DWORD *)v57 + 2) >= 2u)
  {
    unint64_t v57 = (uint64_t *)*v57;
    goto LABEL_137;
  }

  unint64_t v59 = 0LL;
LABEL_139:
  swift::Demangle::__runtime::keyPathSourceString(char const*,unsigned long)::$_1::operator()(v59, (char *)&__p);
  unint64_t v60 = v155;
  if (v155 < v156)
  {
    unint64_t v61 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *((void *)v155 + 2) = __p.__r_.__value_.__l.__cap_;
    *unint64_t v60 = v61;
    Swift::String::Index v155 = (char *)v60 + 24;
    goto LABEL_144;
  }

  Swift::String::Index v155 = std::vector<std::string>::__push_back_slow_path<std::string>(&v154, (uint64_t)&__p);
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    uint64_t v39 = (unsigned __int16 *)__p.__r_.__value_.__r.__words[0];
    goto LABEL_143;
  }

LABEL_22:
    uint64_t v18 = v248;
    unint64_t v19 = v249;
    unint64_t v20 = HIBYTE(v249) & 0xF;
    unint64_t v21 = (v249 & 0x2000000000000000LL) != 0 ? HIBYTE(v249) & 0xF : v248 & 0xFFFFFFFFFFFFLL;
    if (v21 || (v248 & ~v249 & 0x2000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRelease(v249);
    uint64_t v248 = v17;
    unint64_t v249 = v16;
LABEL_6:
    char v11 = 1;
    if (v10 >= v240)
    {
      uint64_t v5 = v248;
      unint64_t v178 = v249;
LABEL_220:
      uint64_t v6 = 0xE100000000000000LL;
      goto LABEL_221;
    }
  }

  uint64_t v22 = v16 & 0x2000000000000000LL;
  unint64_t v23 = HIBYTE(v16) & 0xF;
  if ((v249 & 0x2000000000000000LL) != 0 && v22)
  {
    unint64_t v24 = v20 + v23;
    if (v20 + v23 <= 0xF)
    {
      if (v23)
      {
        uint64_t v58 = 0LL;
        unint64_t v59 = 0LL;
        unint64_t v60 = v249;
        do
        {
          unint64_t v61 = v20 + v59;
          unint64_t v62 = v59 + 1;
          if (v59 >= 8) {
            unint64_t v63 = v16;
          }
          else {
            unint64_t v63 = v17;
          }
          unint64_t v64 = v63 >> (v58 & 0x38);
          char v65 = (8 * v20 + v58) & 0x38;
          uint64_t v66 = (-255LL << v65) - 1;
          unint64_t v67 = (unint64_t)v64 << v65;
          unint64_t v68 = v67 | v66 & v60;
          unint64_t v69 = v67 | v66 & v18;
          if (v61 < 8) {
            uint64_t v18 = v69;
          }
          else {
            unint64_t v60 = v68;
          }
          v58 += 8LL;
          unint64_t v59 = v62;
        }

        while (v23 != v62);
      }

      else
      {
        unint64_t v60 = v249;
      }

      swift_bridgeObjectRelease(v249);
      swift_bridgeObjectRelease(v16);
      unint64_t v74 = 0xA000000000000000LL;
      if (!(v18 & 0x8080808080808080LL | v60 & 0x80808080808080LL)) {
        unint64_t v74 = 0xE000000000000000LL;
      }
      uint64_t v248 = v18;
      unint64_t v249 = v74 & 0xFF00000000000000LL | (v24 << 56) | v60 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_6;
    }

    uint64_t v22 = 1LL;
  }

  uint64_t v242 = v10;
  if (v22) {
    uint64_t v25 = HIBYTE(v16) & 0xF;
  }
  else {
    uint64_t v25 = v17 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v16, 2LL, a3, a4);
  if ((v16 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain_n(v16, 5LL, v26, v27);
    v179._Swift::UInt64 rawBits = 1LL;
    v180._Swift::UInt64 rawBits = (v25 << 16) | 1;
    v181._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v179, v180, v17, v16);
    if (v181._rawBits < 0x10000) {
      v181._rawBits |= 3;
    }
    Swift::Int v28 = specialized Collection.count.getter(v181, v182, v17, v16);
    swift_bridgeObjectRelease(v16);
    if ((v19 & 0x1000000000000000LL) == 0) {
      goto LABEL_36;
    }
  }

  else
  {
    swift_bridgeObjectRetain_n(v16, 4LL, v26, v27);
    Swift::Int v28 = v25;
    if ((v19 & 0x1000000000000000LL) == 0)
    {
LABEL_36:
      BOOL v29 = __OFADD__(v21, v28);
      int64_t v30 = v21 + v28;
      if (v29) {
        goto LABEL_251;
      }
LABEL_37:
      if ((v18 & ~v19 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v19 & 0xFFFFFFFFFFFFFFFLL))
      {
        unint64_t v31 = v249;
        int64_t v32 = _StringGuts.nativeUnusedCapacity.getter(v248, v249);
        if ((v33 & 1) != 0) {
          goto LABEL_262;
        }
        if (v30 <= 15 && ((v31 & 0x2000000000000000LL) != 0 || v32 < v28))
        {
LABEL_52:
          swift_bridgeObjectRelease_n(v16, 5LL);
          unint64_t v36 = v248;
          swift_bridgeObjectRetain(v31, v37, v38, v39);
          unint64_t v40 = _StringGuts._convertedToSmall()(v36, v31);
          unint64_t v42 = v41;
          swift_bridgeObjectRelease(v31);
          v43._Swift::UInt64 rawBits = (v25 << 16) | 1;
          v44._Swift::UInt64 rawBits = 1LL;
          v45._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v44, v43, v17, v16);
          if (v45._rawBits < 0x10000) {
            v45._rawBits |= 3;
          }
          unint64_t v47 = specialized String.init(_:)(v45, v46, v17, v16);
          unint64_t v49 = v48;
          swift_bridgeObjectRelease(v16);
          unint64_t v50 = _StringGuts._convertedToSmall()(v47, v49);
          unint64_t v52 = v51;
          swift_bridgeObjectRelease(v49);
          unint64_t v53 = specialized _SmallString.init(_:appending:)(v40, v42, v50, v52);
          uint64_t v10 = v242;
          if ((v55 & 1) != 0) {
            goto LABEL_261;
          }
          uint64_t v56 = v53;
          unint64_t v57 = v54;
          swift_bridgeObjectRelease(v31);
          swift_bridgeObjectRelease(v16);
          uint64_t v248 = v56;
          unint64_t v249 = v57;
LABEL_56:
          uint64_t v9 = x1_0;
          goto LABEL_6;
        }
      }

      else if (v30 <= 15)
      {
        unint64_t v31 = v249;
        goto LABEL_52;
      }

      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v30, v28);
      swift_bridgeObjectRelease_n(v16, 4LL);
      if ((v16 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v16);
        _StringGuts._foreignAppendInPlace(_:)(v17, v16, 0LL, v25);
        swift_bridgeObjectRelease_n(v16, 2LL);
        uint64_t v9 = x1_0;
        goto LABEL_58;
      }

      uint64_t v10 = v242;
      if (!v22)
      {
        if ((v17 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v16);
          id v70 = (id)((v16 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v71 = v17 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          id v70 = _StringObject.sharedUTF8.getter(v17, v16);
          uint64_t v71 = v189;
          swift_bridgeObjectRelease(v16);
          if (v71 < (v17 & 0xFFFFFFFFFFFFLL)) {
            goto LABEL_257;
          }
        }

        uint64_t v9 = x1_0;
        uint64_t v72 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v17 & 0xFFFFFFFFFFFFLL, (uint64_t)v70, v71);
        _StringGuts.appendInPlace(_:isASCII:)(v72, v73, v17 < 0);
        swift_bridgeObjectRelease_n(v16, 2LL);
        goto LABEL_6;
      }

      swift_bridgeObjectRelease_n(v16, 2LL);
      uint64_t v246 = v17;
      uint64_t v247 = v16 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v34 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v16) & 0xF,  (uint64_t)&v246,  HIBYTE(v16) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v34, v35, (v16 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v16);
      goto LABEL_56;
    }
  }

  Swift::Int v183 = String.UTF8View._foreignCount()();
  int64_t v30 = v183 + v28;
  if (!__OFADD__(v183, v28)) {
    goto LABEL_37;
  }
LABEL_251:
  __break(1u);
LABEL_252:
  v229._Swift::UInt64 rawBits = specialized Collection.dropFirst(_:)(1LL, v246, v247);
  uint64_t v231 = v230;
  uint64_t v244 = v18;
  unint64_t v245 = v23;
  uint64_t v248 = 0LL;
  unint64_t v249 = 0xE000000000000000LL;
  specialized String.UnicodeScalarView.append<A>(contentsOf:)(v229, v250, v232, v230);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRelease(v231);
  return v244;
}

    __break(1u);
    goto LABEL_23;
  }

  if (v14 < 0) {
    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = (void *)*v6;
  }
  else {
    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = (void *)(v14 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v16 = objc_msgSend(v15, sel_count);
  if (__OFADD__(v16, 1LL))
  {
    __break(1u);
    goto LABEL_21;
  }

  uint64_t v7 = *(void *)(v7 + 32);
  uint64_t v17 = _NativeDictionary.init(_:capacity:)(v15, (uint64_t)v16 + 1, v11, v13, v7);
  Swift::String::Index v44 = (uint64_t)v17;
  uint64_t v18 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v11, v7);
  uint64_t v22 = v17[2];
  unint64_t v23 = (v19 & 1) == 0;
  unint64_t v24 = (Swift::Int)v22 + v23;
  if (__OFADD__(v22, v23))
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }

  unint64_t v12 = v18;
  uint64_t v25 = v19;
  type metadata accessor for _NativeDictionary(0LL, (uint64_t)v11, (uint64_t)v13, v7);
  _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v24, 1);
  uint64_t v26 = __RawDictionaryStorage.find<A>(_:)(v43, (uint64_t)v11, v7);
  if ((v25 & 1) != (v19 & 1)) {
LABEL_24:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v11);
  unint64_t v12 = v26;
LABEL_10:
  *uint64_t v6 = (uint64_t)v17;
  if ((v25 & 1) == 0) {
    goto LABEL_18;
  }
LABEL_11:
  swift_bridgeObjectRetain((unint64_t)v17, v19, v20, v21);
LABEL_19:
  swift_bridgeObjectRelease((uint64_t)v17);
  return Dictionary.subscript.modify;
}

    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v9);
  }

    __break(1u);
    goto LABEL_23;
  }

  if (v16 < 0) {
    uint64_t v22 = (void *)v16;
  }
  else {
    uint64_t v22 = (void *)(v16 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v23 = objc_msgSend(v22, sel_count, v47, v48, v49);
  if (__OFADD__(v23, 1LL))
  {
    __break(1u);
    goto LABEL_21;
  }

  uint64_t v7 = *(void *)(v7 + 32);
  unint64_t v24 = _NativeDictionary.init(_:capacity:)(v22, (uint64_t)v23 + 1, v18, v12, v7);
  unint64_t v52 = v24;
  uint64_t v25 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v18, v7);
  BOOL v29 = v24[2];
  int64_t v30 = (v26 & 1) == 0;
  a3 = (Swift::Int)v29 + v30;
  if (__OFADD__(v29, v30))
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }

  a4 = v25;
  unint64_t v31 = v26;
  type metadata accessor for _NativeDictionary(0LL, (uint64_t)v18, (uint64_t)v12, v7);
  _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(a3, 1);
  unint64_t v24 = v52;
  int64_t v32 = __RawDictionaryStorage.find<A>(_:)(v51, (uint64_t)v18, v7);
  if ((v31 & 1) != (v26 & 1)) {
LABEL_24:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v18);
  a4 = v32;
LABEL_10:
  *uint64_t v6 = (uint64_t)v24;
  a3 = v50;
  if ((v31 & 1) == 0) {
    goto LABEL_18;
  }
LABEL_11:
  char v33 = *(void (**)(uint64_t, char *))(*((void *)v18 - 1) + 8LL);
  swift_bridgeObjectRetain((unint64_t)v24, v26, v27, v28);
  v33(v51, v18);
LABEL_19:
  Swift::String::Index v45 = v24[7];
  swift_bridgeObjectRelease((uint64_t)v24);
  return (*(uint64_t (**)(unint64_t, Swift::Int, uint64_t *))(v13 + 40))( (unint64_t)v45 + *(void *)(v13 + 72) * a4,  a3,  v12);
}

      (*(void (**)(char *, uint64_t, char *))(v12 + 16))( a6,  *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10,  a4);
      return;
    }

    if (v10 >= 0) {
      uint64_t v25 = v10 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v25 = v10;
    }
    uint64_t v26 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v10, v27, v28, v29);
    if (swift_dynamicCastClass(v25, v26))
    {
      if (swift_dynamicCastClass(v25, v26))
      {
        char v33 = *(void *)(v25 + 24);
        if (*(void *)(v33 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        uint64_t v34 = *(void **)(v33 + 8 * a2 + 24);
        swift_unknownObjectRetain(v34, v30, v31, v32);
        outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v34, a4, v35, v15);
        swift_unknownObjectRelease(v34);
        uint64_t v10 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, (uint64_t)a4, a5);
        uint64_t v37 = v36;
        (*(void (**)(char *, char *))(v12 + 8))(v15, a4);
        if ((v37 & 1) != 0) {
          goto LABEL_22;
        }
LABEL_26:
        unint64_t v24 = 303LL;
LABEL_13:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v24,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if ((v13 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  if (a3 < 0) {
    uint64_t v17 = a3;
  }
  else {
    uint64_t v17 = a3 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v18 = (void *)specialized __CocoaDictionary.key(at:)(v10, a2, v17);
  uint64_t v22 = swift_unknownObjectRetain(v18, v19, v20, v21);
  _forceBridgeFromObjectiveC<A>(_:_:)(v22, a4, v23, a6);
  swift_unknownObjectRelease(v18);
}

      (*(void (**)(char *, uint64_t, char *))(v12 + 16))( a6,  *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10,  a4);
      return;
    }

    if (v10 >= 0) {
      uint64_t v25 = v10 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v25 = v10;
    }
    uint64_t v26 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v10, v27, v28, v29);
    if (swift_dynamicCastClass(v25, v26))
    {
      if (swift_dynamicCastClass(v25, v26))
      {
        char v33 = *(void *)(v25 + 24);
        if (*(void *)(v33 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        uint64_t v34 = *(void **)(v33 + 8 * a2 + 24);
        swift_unknownObjectRetain(v34, v30, v31, v32);
        outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v34, a4, v35, v15);
        swift_unknownObjectRelease(v34);
        uint64_t v10 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, (uint64_t)a4, a5);
        uint64_t v37 = v36;
        (*(void (**)(char *, char *))(v12 + 8))(v15, a4);
        if ((v37 & 1) != 0) {
          goto LABEL_22;
        }
LABEL_26:
        unint64_t v24 = 303LL;
LABEL_13:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v24,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if ((v13 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  if (a3 < 0) {
    uint64_t v17 = a3;
  }
  else {
    uint64_t v17 = a3 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v18 = (void *)specialized __CocoaDictionary.key(at:)(v10, a2, v17);
  uint64_t v22 = swift_unknownObjectRetain(v18, v19, v20, v21);
  _forceBridgeFromObjectiveC<A>(_:_:)(v22, a4, v23, a6);
  swift_unknownObjectRelease(v18);
}

    unint64_t v24 = (v30 - 1) & v30;
    Swift::Int v28 = __clz(__rbit64(v30)) + (v26 << 6);
LABEL_23:
    (*(void (**)(id *, unint64_t, uint64_t *))(v3 + 16))( v7,  *(void *)(v1[4] + 48) + *(void *)(v3 + 72) * v28,  v2);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
    {
      if (v4 != 8) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
      size_t v35 = *v7;
      swift_unknownObjectRetain(*v7, v32, v33, v34);
      (*(void (**)(id *, uint64_t *))(v3 + 8))(v7, v2);
      *(void *)(v58 + 8 * v28) = v35;
    }

    else
    {
      unint64_t v36 = v52;
      (*(void (**)(id *, id *, uint64_t *))(v3 + 32))(v52, v7, v2);
      uint64_t v39 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v36, v2, v37, v38);
      *(void *)(v58 + 8 * v28) = v39;
    }
  }

    unint64_t v24 = (v30 - 1) & v30;
    Swift::Int v28 = __clz(__rbit64(v30)) + (v26 << 6);
LABEL_23:
    (*(void (**)(id *, unint64_t, uint64_t *))(v3 + 16))( v7,  *(void *)(v1[4] + 56) + *(void *)(v3 + 72) * v28,  v2);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
    {
      if (v4 != 8) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
      size_t v35 = *v7;
      swift_unknownObjectRetain(*v7, v32, v33, v34);
      (*(void (**)(id *, uint64_t *))(v3 + 8))(v7, v2);
      *(void *)(v58 + 8 * v28) = v35;
    }

    else
    {
      unint64_t v36 = v52;
      (*(void (**)(id *, id *, uint64_t *))(v3 + 32))(v52, v7, v2);
      uint64_t v39 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v36, v2, v37, v38);
      *(void *)(v58 + 8 * v28) = v39;
    }
  }

      Swift::String::Index v45 = (v48 - 1) & v48;
      Swift::String::Index v46 = __clz(__rbit64(v48)) + (v41 << 6);
    }

    char v136 = v45;
    if (v132)
    {
      unint64_t v50 = *(void **)(v128 + 8 * v46);
      swift_unknownObjectRetain(v50, v37, v38, v39);
      if (v40 == (id *)0x1000000000000000LL) {
        goto LABEL_93;
      }
    }

    else
    {
      (*(void (**)(id *, unint64_t, uint64_t))(v134 + 16))( v26,  *(void *)(*(void *)(v135 + 32) + 48LL) + *(void *)(v134 + 72) * v46,  v16);
      if (_swift_isClassOrObjCExistentialType(v16, (uint64_t *)v16))
      {
        if (v130 != 8) {
          goto LABEL_92;
        }
        unint64_t v50 = *v26;
        swift_unknownObjectRetain(*v26, v51, v52, v53);
        (*(void (**)(id *, uint64_t))(v134 + 8))(v26, v16);
        if (v40 == (id *)0x1000000000000000LL)
        {
LABEL_93:
          __break(1u);
          goto LABEL_94;
        }
      }

      else
      {
        unint64_t v67 = v125;
        (*(void (**)(id *, id *, uint64_t))(v134 + 32))(v125, v26, v16);
        unint64_t v50 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v67, (uint64_t *)v16, v68, v69);
        if (v40 == (id *)0x1000000000000000LL) {
          goto LABEL_93;
        }
      }
    }

    v138[(void)v40] = v50;
    swift_unknownObjectRelease(v50);
    if (v139)
    {
      unint64_t v42 = *(char **)&v127[8 * v46];
      swift_unknownObjectRetain(v42, v54, v55, v56);
LABEL_9:
      Swift::String::Index v43 = v140;
      goto LABEL_10;
    }

    (*(void (**)(id *, unint64_t, uint64_t *))(v133 + 16))( v131,  *(void *)(*(void *)(v135 + 32) + 56LL) + *(void *)(v133 + 72) * v46,  v5);
    if (!_swift_isClassOrObjCExistentialType((uint64_t)v5, v5))
    {
      id v70 = v124;
      (*(void (**)(id *, id *, uint64_t *))(v133 + 32))(v124, v131, v5);
      unint64_t v42 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v70, v5, v71, v72);
      goto LABEL_9;
    }

    Swift::String::Index v43 = v140;
    if (v129 != 8) {
      goto LABEL_92;
    }
    unint64_t v60 = v16;
    unint64_t v61 = v33;
    unint64_t v62 = v26;
    unint64_t v63 = v5;
    unint64_t v64 = v36;
    char v65 = v131;
    unint64_t v42 = (char *)*v131;
    swift_unknownObjectRetain(*v131, v57, v58, v59);
    uint64_t v66 = v65;
    unint64_t v36 = v64;
    uint64_t v5 = v63;
    uint64_t v26 = v62;
    char v33 = v61;
    unint64_t v16 = v60;
    (*(void (**)(id *, uint64_t *))(v133 + 8))(v66, v5);
LABEL_10:
    *(void *)(v137 + 8LL * (void)v40) = v42;
    swift_unknownObjectRelease(v42);
    unint64_t v40 = (id *)((char *)v40 + 1);
    size_t v35 = v136;
  }

  while (v40 != v43);
  swift_release((uint64_t)v139);
  swift_release(v132);
  uint64_t v122 = v126;
LABEL_90:
  swift_release_n(v122, 2LL);
}

              unint64_t v23 = __clz(__rbit64(v41)) + (v40 << 6);
            }
          }

  swift_release((uint64_t)v4);
  uint64_t v2 = v34;
  if ((a2 & 1) != 0)
  {
    char v33 = 1LL << v4[2].i8[0];
    if (v33 > 63) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v33 + 63) >> 6, v4 + 4);
    }
    else {
      v9->i64[0] = -1LL << v33;
    }
    v4[1].i64[0] = 0LL;
  }

  swift_release((uint64_t)v4);
  if ((a2 & 1) != 0)
  {
    uint64_t v27 = 1LL << v4[2].i8[0];
    if (v27 > 63) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v27 + 63) >> 6, v4 + 4);
    }
    else {
      v9->i64[0] = -1LL << v27;
    }
    v4[1].i64[0] = 0LL;
  }

        unint64_t v49 = (v22 - 1) & v22;
        unint64_t v50 = v23;
        unint64_t v20 = __clz(__rbit64(v22)) + (v23 << 6);
      }

      uint64_t v25 = v46;
      uint64_t v26 = v47;
      uint64_t v27 = *(void *)(v47 + 72);
      (*(void (**)(char *, unint64_t, unint64_t))(v47 + 16))(v46, a4[6] + v27 * v20, v18);
      Swift::Int v28 = a4;
      BOOL v29 = a4[7] + 16 * v20;
      int64_t v30 = *(void *)v29;
      unint64_t v31 = *(_BYTE *)(v29 + 8);
      int64_t v32 = *(void (**)(uint64_t, char *, unint64_t))(v26 + 32);
      v32(v19, v25, v18);
      char v33 = (void *)v45;
      uint64_t v34 = (*(uint64_t (**)(void, unint64_t, uint64_t))(v48 + 32))(*(void *)(v45 + 40), v18, v48);
      size_t v35 = __RawDictionaryStorage.find<A>(_:hashValue:)(v19, v34, v18);
      if ((v36 & 1) != 0) {
        goto LABEL_31;
      }
      uint64_t v37 = v35;
      *(void *)(v42 + ((v35 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v35;
      v32(v33[6] + v35 * v27, (char *)v19, v18);
      uint64_t v38 = v33[7] + 16 * v37;
      *(void *)uint64_t v38 = v30;
      *(_BYTE *)(v38 + 8) = v31;
      ++v33[2];
      a3 = v51 - 1;
      if (__OFSUB__(v51, 1LL))
      {
        __break(1u);
LABEL_29:
        __break(1u);
        goto LABEL_30;
      }

      a4 = v28;
      unint64_t v16 = v49;
      uint64_t v17 = v50;
      if (v51 == 1) {
        return (__objc2_class **)v45;
      }
    }
  }

  swift_retain(a4, v12, v13, v14);
  return (__objc2_class **)a4;
}

  swift_release(v2);
  unint64_t v20 = 1LL << *(_BYTE *)(v2 + 32);
  if (v20 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)( 0LL,  (unint64_t)(v20 + 63) >> 6,  (int64x2_t *)(v2 + 56));
  }
  else {
    id *v9 = -1LL << v20;
  }
  *(void *)(v2 + 16) = 0LL;
LABEL_26:
  uint64_t result = swift_release(v2);
  uint64_t *v1 = (uint64_t)v7;
  return result;
}

  swift_release(v2);
  unint64_t v21 = 1LL << *(_BYTE *)(v2 + 32);
  if (v21 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)( 0LL,  (unint64_t)(v21 + 63) >> 6,  (int64x2_t *)(v2 + 56));
  }
  else {
    id *v9 = -1LL << v21;
  }
  *(void *)(v2 + 16) = 0LL;
LABEL_26:
  swift_release(v2);
  uint64_t *v1 = (uint64_t)v7;
}

  swift_release(v6);
  unint64_t v24 = 1LL << *(_BYTE *)(v6 + 32);
  if (v24 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)( 0LL,  (unint64_t)(v24 + 63) >> 6,  (int64x2_t *)(v6 + 56));
  }
  else {
    *unsigned int v13 = -1LL << v24;
  }
  *(void *)(v6 + 16) = 0LL;
LABEL_26:
  uint64_t result = swift_release(v6);
  void *v3 = (uint64_t)v11;
  return result;
}

      if ((v10 & 0x1000000000000000LL) != 0) {
        goto LABEL_61;
      }
      goto LABEL_23;
    }

    if (v13 == v14) {
      v6._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v6)._rawBits;
    }
    if (v6._rawBits >> 14 < v9 >> 14 || v6._rawBits >> 14 >= v7 >> 14)
    {
      unint64_t v42 = 43LL;
LABEL_81:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v42,  0);
    }

    if ((v6._rawBits & 1) != 0) {
      goto LABEL_22;
    }
    v6._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v6)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
    if ((v10 & 0x1000000000000000LL) != 0)
    {
LABEL_61:
      Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v6._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
      if (value < 0xC0) {
        goto LABEL_31;
      }
      goto LABEL_62;
    }

    Unicode._NormDataBuffer.sort()();
    int64_t v32 = *(void *)(*(void *)v2 + 16LL);
    if (!v32)
    {
      *(_BYTE *)(v2 + 8) = 0;
      unint64_t v31 = 1;
      goto LABEL_26;
    }
  }

  if ((*(_BYTE *)(v2 + 8) & 1) == 0)
  {
    specialized MutableCollection<>.reverse()();
    *(_BYTE *)(v2 + 8) = 1;
  }

  BOOL v29 = specialized RangeReplaceableCollection<>.removeLast()();
  unint64_t v31 = 0;
  int64_t v32 = v29 & 0xFFFFFFFFFFFFLL;
LABEL_26:
  LOBYTE(v38[0]) = v31;
  int64_t v30 = v32 | ((unint64_t)v31 << 48);
  result.Swift::UInt32 value = (Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData)v30;
  result.is_nil = v22;
  return result;
}

      if ((v20 & ~v19 & 0x2000000000000000LL) != 0
        && (isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v19 & 0xFFFFFFFFFFFFFFFLL),
            unint64_t v20 = *a6,
            unint64_t v19 = a6[1],
            isUniquelyReferenced_nonNull_native))
      {
        unint64_t v31 = _StringGuts.nativeUnusedCapacity.getter(*a6, a6[1]);
        if ((v32 & 1) != 0)
        {
          uint64_t v125 = 258LL;
LABEL_164:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v125,  0);
        }

        if (v29 <= 15 && ((v19 & 0x2000000000000000LL) != 0 || v31 < v27))
        {
LABEL_39:
          if ((v19 & 0x2000000000000000LL) != 0)
          {
            uint64_t v38 = v19;
            uint64_t v9 = a3;
          }

          else
          {
            uint64_t v9 = a3;
            if ((v19 & 0x1000000000000000LL) != 0)
            {
              unint64_t v20 = _StringGuts._foreignConvertedToSmall()(v20, v19);
              uint64_t v38 = v117;
            }

            else
            {
              if ((v20 & 0x1000000000000000LL) != 0)
              {
                unint64_t v111 = (unsigned __int8 *)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
                int64_t v112 = v20 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                unint64_t v111 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v20, v19);
              }

              closure #1 in _StringGuts._convertedToSmall()(v111, v112, &__src);
              unint64_t v20 = __src;
              uint64_t v38 = v135;
            }
          }

          if (v133)
          {
            swift_bridgeObjectRelease(v12);
            uint64_t v39 = v12;
          }

          else if ((v12 & 0x1000000000000000LL) != 0)
          {
            char v11 = _StringGuts._foreignConvertedToSmall()(v11, v12);
            uint64_t v39 = v118;
            swift_bridgeObjectRelease(v12);
          }

          else
          {
            if ((v11 & 0x1000000000000000LL) != 0)
            {
              char v113 = (unsigned __int8 *)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }

            else
            {
              char v113 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v12);
              uint64_t v26 = v119;
            }

            closure #1 in _StringGuts._convertedToSmall()(v113, v26, &__src);
            swift_bridgeObjectRelease(v12);
            char v11 = __src;
            uint64_t v39 = v135;
          }

          unint64_t v40 = HIBYTE(v38) & 0xF;
          unint64_t v41 = HIBYTE(v39) & 0xF;
          unint64_t v42 = v41 + v40;
          if ((unint64_t)(v41 + v40) > 0xF)
          {
            uint64_t v125 = 266LL;
            goto LABEL_164;
          }

          if (v41)
          {
            Swift::String::Index v43 = 0;
            Swift::String::Index v44 = 0LL;
            do
            {
              Swift::String::Index v45 = v40 + v44;
              Swift::String::Index v46 = v44 + 1;
              if (v44 >= 8) {
                unint64_t v47 = v39;
              }
              else {
                unint64_t v47 = v11;
              }
              unint64_t v48 = v47 >> (v43 & 0x38);
              unint64_t v49 = (8 * v40 + v43) & 0x38;
              unint64_t v50 = (-255LL << v49) - 1;
              unint64_t v51 = (unint64_t)v48 << v49;
              unint64_t v52 = v51 | v50 & v38;
              unint64_t v53 = v51 | v50 & v20;
              if (v45 < 8) {
                unint64_t v20 = v53;
              }
              else {
                uint64_t v38 = v52;
              }
              v43 += 8;
              Swift::String::Index v44 = v46;
            }

            while (v41 != v46);
          }

          swift_bridgeObjectRelease(v19);
          swift_bridgeObjectRelease(v12);
          unint64_t v54 = 0xE000000000000000LL;
          if (v20 & 0x8080808080808080LL | v38 & 0x80808080808080LL) {
            unint64_t v54 = 0xA000000000000000LL;
          }
          char v55 = v54 & 0xFF00000000000000LL | (v42 << 56) | v38 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_122;
        }
      }

      else if (v29 <= 15)
      {
        goto LABEL_39;
      }

      char v33 = _StringGuts.nativeUnusedCapacity.getter(v20, v19);
      unint64_t v36 = (v34 & 1) == 0 && v33 >= v27;
      if ((v20 & ~v19 & 0x2000000000000000LL) != 0)
      {
        uint64_t v37 = swift_isUniquelyReferenced_nonNull_native(v19 & 0xFFFFFFFFFFFFFFFLL);
        unint64_t v20 = *a6;
        unint64_t v19 = a6[1];
        if (v37)
        {
          if (v36) {
            goto LABEL_90;
          }
LABEL_57:
          uint64_t v56 = 2 * _StringGuts.nativeCapacity.getter(v20, v19);
          if ((v57 & 1) != 0) {
            uint64_t v56 = 0LL;
          }
          if (v56 > v29) {
            BOOL v29 = v56;
          }
          goto LABEL_61;
        }
      }

      if (!v36) {
        goto LABEL_57;
      }
LABEL_61:
      uint64_t v58 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v59 & 1) != 0)
      {
        unint64_t v61 = a6[1];
        if ((v61 & 0x1000000000000000LL) != 0)
        {
          unint64_t v60 = String.UTF8View._foreignCount()();
        }

        else if ((v61 & 0x2000000000000000LL) != 0)
        {
          unint64_t v60 = HIBYTE(v61) & 0xF;
        }

        else
        {
          unint64_t v60 = *a6 & 0xFFFFFFFFFFFFLL;
        }
      }

      else
      {
        unint64_t v60 = 2 * v58;
      }

      if (v60 <= v29) {
        unint64_t v62 = v29;
      }
      else {
        unint64_t v62 = v60;
      }
      unint64_t v63 = a6[1];
      if ((v63 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignGrow(_:)(v62);
        if ((v12 & 0x1000000000000000LL) == 0)
        {
LABEL_91:
          swift_bridgeObjectRelease(v12);
          uint64_t v9 = a3;
          if (v133)
          {
            __src = v11;
            unint64_t v135 = v12 & 0xFFFFFFFFFFFFFFLL;
            uint64_t v77 = a6[1];
            unint64_t v78 = v77 & 0xFFFFFFFFFFFFFFFLL;
            unint64_t v79 = (v77 & 0xFFFFFFFFFFFFFFFLL) + 32;
            unint64_t v80 = (char *)(v79 + (*(void *)(v77 + 24) & 0xFFFFFFFFFFFFLL));
            memcpy(v80, &__src, HIBYTE(v12) & 0xF);
            unsigned int v81 = *(void *)(v78 + 24);
            uint64_t v82 = (v81 & 0xFFFFFFFFFFFFLL) + v23;
            unint64_t v83 = v81 > -1 || (v12 & 0x4000000000000000LL) == 0;
            uint64_t v84 = v82 | 0xC000000000000000LL;
            if (v83) {
              uint64_t v84 = v82;
            }
            unint64_t v85 = v84 | 0x3000000000000000LL;
            *(void *)(v78 + 24) = v84 | 0x3000000000000000LL;
            *(_BYTE *)(v79 + (v84 & 0xFFFFFFFFFFFFLL)) = 0;
            unint64_t v86 = *(void *)(v78 + 16);
            if (v86 < 0)
            {
              unint64_t v87 = (uint64_t *)((v79 + (v86 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
              unint64_t v88 = *v87;
              char *v87 = 0LL;
              swift_release(v88);
              unint64_t v85 = *(void *)(v78 + 24);
            }

            swift_bridgeObjectRelease(v12);
            *a6 = v85;
          }

          else
          {
            if ((v11 & 0x1000000000000000LL) != 0)
            {
              uint64_t v101 = (char *)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }

            else
            {
              BOOL v115 = (char *)_StringObject.sharedUTF8.getter(v11, v12);
              if (v116 < v26) {
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
              }
              uint64_t v101 = v115;
              if (v26)
              {
                uint64_t v9 = a3;
                if (!v115) {
                  _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
                }
              }

              else
              {
                uint64_t v9 = a3;
                uint64_t v26 = 0LL;
              }
            }

            uint64_t v102 = a6[1];
            Swift::Int v103 = v102 & 0xFFFFFFFFFFFFFFFLL;
            uint64_t v104 = (char *)((v102 & 0xFFFFFFFFFFFFFFFLL) + (*(void *)(v102 + 24) & 0xFFFFFFFFFFFFLL) + 32);
            if (&v104[v26] > v101 && v104 < &v101[v26]) {
              goto LABEL_160;
            }
            memcpy(v104, v101, v26);
            __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( (*(void *)(v103 + 24) & 0xFFFFFFFFFFFFLL) + v26,  (*(void *)(v103 + 24) & v11 & 0x8000000000000000LL) != 0LL);
            *a6 = *(void *)(v103 + 24);
            swift_bridgeObjectRelease(v12);
          }

          goto LABEL_4;
        }

        goto LABEL_3;
      }

      unint64_t v64 = *a6;
      if ((v63 & 0x2000000000000000LL) != 0)
      {
        size_t v73 = HIBYTE(v63) & 0xF;
        __src = *a6;
        unint64_t v135 = v63 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v74 = v73 | 0xC000000000000000LL;
        if ((v63 & 0x4000000000000000LL) == 0) {
          unint64_t v74 = HIBYTE(v63) & 0xF;
        }
        uint64_t v72 = v74 | 0x3000000000000000LL;
        id v70 = _allocateStringStorage(codeUnitCapacity:)(v62);
        *(void *)(v70 + 16) = v75;
        *(void *)(v70 + 24) = v72;
        if (v75 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
          uint64_t v72 = *(void *)(v70 + 24);
        }

        unint64_t v76 = (char *)(v70 + 32);
        *(_BYTE *)(v70 + 32 + (v72 & 0xFFFFFFFFFFFFLL)) = 0;
        memcpy(v76, &__src, v73);
      }

      else
      {
        if ((v64 & 0x1000000000000000LL) != 0)
        {
          char v65 = (char *)((v63 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v66 = v64 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          char v65 = (char *)_StringObject.sharedUTF8.getter(v64, v63);
          uint64_t v66 = v114;
        }

        if (v64 >= 0) {
          unint64_t v67 = v66;
        }
        else {
          unint64_t v67 = v66 | 0xC000000000000000LL;
        }
        unint64_t v68 = _allocateStringStorage(codeUnitCapacity:)(v62);
        id v70 = v68;
        *(void *)(v68 + 16) = v69;
        *(void *)(v68 + 24) = v67 | 0x3000000000000000LL;
        if (v69 < 0) {
          *(void *)((v68 + (v69 & 0xFFFFFFFFFFFFLL) + 39) & 0xFFFFFFFFFFFFF8LL) = 0LL;
        }
        uint64_t v71 = (char *)(v68 + 32);
        *(_BYTE *)(v70 + 32 + (v67 & 0xFFFFFFFFFFFFLL)) = 0;
        uint64_t v26 = v11 & 0xFFFFFFFFFFFFLL;
        memcpy(v71, v65, v66);
        uint64_t v72 = *(void *)(v70 + 24);
      }

      swift_bridgeObjectRelease(a6[1]);
      *a6 = v72;
      a6[1] = v70;
LABEL_90:
      if ((v12 & 0x1000000000000000LL) == 0) {
        goto LABEL_91;
      }
LABEL_3:
      _StringGuts._foreignAppendInPlace(_:)(v11, v12, 0LL, v129);
      swift_bridgeObjectRelease_n(v12, 2LL);
      uint64_t v9 = a3;
LABEL_4:
      ++v10;
      _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)v136,  (uint64_t)a6,  (swift *)&unk_189B8D218,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
      __swift_destroy_boxed_opaque_existential_1Tm(v136);
      swift_bridgeObjectRetain(v9, v13, v14, v15);
      unint64_t v12 = v9;
      char v11 = a2;
      if (v10 == v131)
      {
        uint64_t v8 = a4;
        uint64_t v7 = a5;
        goto LABEL_152;
      }
    }
  }

  uint64_t v9 = 0xE000000000000000LL;
LABEL_152:
  swift_bridgeObjectRelease(v9);
  char v123 = a6[1];
  uint64_t v124 = HIBYTE(v123) & 0xF;
  if ((v123 & 0x2000000000000000LL) == 0) {
    uint64_t v124 = *a6 & 0xFFFFFFFFFFFFLL;
  }
  if (v124 || (*a6 & ~v123 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(v8, v7);
  }

  else
  {
    swift_bridgeObjectRetain(v7, v120, v121, v122);
    swift_bridgeObjectRelease(v123);
    *a6 = v8;
    a6[1] = v7;
  }

  *a1 = a4;
  a1[1] = a5;
  a1[2] = v12;
  a1[3] = v8;
  return v9;
}

  unint64_t v12 = v5 + v6;
  unsigned int v13 = *v1;
  unint64_t v14 = v1[1];
  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = (v5 + v6) & 0xFFFFFFFFFFFFLL;
  if ((v14 & 0x1000000000000000LL) != 0)
  {
    uint64_t v26 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v4._rawBits >> 16, v15);
    unint64_t object = v26._object;
    uint64_t countAndFlagsBits = v26._countAndFlagsBits;
    goto LABEL_32;
  }

  if (v15 < v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if ((v14 & 0x2000000000000000LL) != 0)
  {
    BOOL v29 = *v1;
    int64_t v30 = v14 & 0xFFFFFFFFFFFFFFLL;
    if ((HIBYTE(v14) & 0xF) >= (unint64_t)v15)
    {
      unint64_t v19 = v15 - v6;
      if ((uint64_t)(v15 - v6) < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      uint64_t v18 = (uint8x16_t *)((char *)&v29 + v6);
      goto LABEL_31;
    }

    goto LABEL_36;
  }

  if ((v13 & 0x1000000000000000LL) == 0)
  {
    unint64_t v16 = _StringObject.sharedUTF8.getter(v13, v14);
    uint64_t v17 = v27;
    if (v27 >= v15) {
      goto LABEL_27;
    }
LABEL_36:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  unint64_t v16 = (id)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v17 = v13 & 0xFFFFFFFFFFFFLL;
  if ((v13 & 0xFFFFFFFFFFFFLL) < v15) {
    goto LABEL_36;
  }
LABEL_27:
  uint64_t v18 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v4._rawBits >> 16, v15, (uint64_t)v16, v17);
LABEL_31:
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v18, v19);
LABEL_32:
  uint64_t v22 = countAndFlagsBits;
  unint64_t v23 = object;
  _StringGuts.remove(from:to:)(v4, (Swift::String::Index)((v12 << 16) | 1));
  unint64_t v24 = v22;
  uint64_t v25 = v23;
  result._unint64_t object = v25;
  result._uint64_t countAndFlagsBits = v24;
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xC0uLL,  0);
  }

  v15.value._Swift::UInt64 rawBits = 0LL;
  is_nil = 1;
LABEL_18:
  *(void *)a4 = v15.value._rawBits;
  *(_BYTE *)(a4 + 8) = is_nil;
  return v15.value._rawBits;
}

      if (v6 <= v10 >> 16)
      {
        uint64_t v22 = 144LL;
LABEL_34:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v22,  0);
      }

      uint64_t v10 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v10)._rawBits;
LABEL_24:
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v7))
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v7[2]->isa + 1,  1);
        uint64_t v7 = v24;
      }

      uint64_t v17 = v7[2];
      unint64_t v16 = (unint64_t)v7[3];
      if ((unint64_t)v17 >= v16 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v16 > 1),  (int64_t)&v17->isa + 1,  1);
        uint64_t v7 = v24;
      }

      v7[2] = (__objc2_class *)((char *)&v17->isa + 1);
      *((_BYTE *)&v17->info + (void)v7) = v15;
    }

    while (4 * v6 != v10 >> 14);
  }

  swift_bridgeObjectRelease(a2);
  unint64_t v24 = v7;
  unint64_t v19 = v7[2];
  uint64_t v18 = (unint64_t)v7[3];
  unint64_t v20 = (int64_t)&v19->isa + 1;
  if ((unint64_t)v19 >= v18 >> 1)
  {
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v18 > 1),  v20,  1);
    uint64_t v7 = v24;
  }

  v7[2] = (__objc2_class *)v20;
  *((_BYTE *)&v19->info + (void)v7) = 0;
  return v7;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xC0uLL,  0);
  }

  v15.value._Swift::UInt64 rawBits = 0LL;
  is_nil = 1;
LABEL_18:
  *(void *)a4 = v15.value._rawBits;
  *(_BYTE *)(a4 + 8) = is_nil;
  return v15.value._rawBits;
}

    __break(1u);
    goto LABEL_23;
  }

  uint64_t v66 = v14;
  int64_t v32 = v29 - *a2;
  if (__OFSUB__(v29, *a2))
  {
    __break(1u);
    goto LABEL_22;
  }

  unint64_t v60 = (char *)v31;
  char v33 = v70;
  uint64_t v34 = v71;
  size_t v35 = v67;
  append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)(v68, v69, v70, v32, v71, a9);
  if (!v35)
  {
    unint64_t v67 = a2;
    unint64_t v68 = 0LL;
    unint64_t v36 = v61;
    unint64_t v59 = *(void (**)(char *, uint64_t, unint64_t))(v64 + 16);
    v59(v61, v33, v19);
    uint64_t v38 = v62;
    uint64_t v37 = v63;
    (*(void (**)(uint64_t, uint64_t))(v63 + 72))(v34, v63);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v37,  v34,  v19,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    unint64_t v40 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                      + 8LL))( v36,  v38,  v19);
    unint64_t v41 = *(void (**)(char *, unint64_t))(v64 + 8);
    v41(v38, v19);
    uint64_t result = (unint64_t *)((uint64_t (*)(char *, unint64_t))v41)(v36, v19);
    if ((v40 & 1) != 0)
    {
      swift_allocError((uint64_t)&unk_189B897A8, (uint64_t)&protocol witness table for _ApplicationError, 0LL, 0);
      swift_willThrow();
      goto LABEL_6;
    }

    unint64_t v54 = v32 + 1;
    if (!__OFADD__(v32, 1LL))
    {
      Swift::String::Index v46 = __OFADD__(*v67, v54);
      char v55 = *v67 + v54;
      if (!v46)
      {
        *unint64_t v67 = v55;
        uint64_t v56 = v62;
        unint64_t v57 = v70;
        v59(v62, v70, v19);
        uint64_t v58 = v61;
        (*(void (**)(char *, uint64_t))(v63 + 184))(v56, v71);
        v41(v56, v19);
        uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t, char *, unint64_t))(v64 + 40))( v57,  v58,  v19);
        if (!__OFADD__(*v65, 1LL))
        {
          ++*v65;
          return (unint64_t *)((uint64_t (*)(char *, unint64_t))v66[1])( v60,  AssociatedTypeWitness);
        }

        goto LABEL_29;
      }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if ((v5 & 0x8000000000000000LL) != 0) {
    goto LABEL_22;
  }
  uint64_t v6 = v3[2];
  if (v5 <= v6) {
    goto LABEL_13;
  }
  Swift::Int v28 = (void *)v3[14];
  BOOL v29 = (void *)v3[15];
  uint64_t v7 = (void *)v3[11];
  uint64_t v26 = (void *)v3[12];
  uint64_t v27 = (void *)v3[13];
  unint64_t v19 = v3[9];
  uint64_t v9 = (void *)v3[10];
  unint64_t v20 = v3[7];
  char v11 = (void *)v3[8];
  unint64_t v12 = v3[5];
  unint64_t v21 = v3[4];
  uint64_t v25 = v3[6];
  uint64_t v22 = swift_getAssociatedConformanceWitness( v21,  v19,  v20,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v4) {
    unint64_t v23 = 257LL;
  }
  else {
    unint64_t v23 = 256LL;
  }
  if (v4) {
    unint64_t v24 = &unk_18180BE78;
  }
  else {
    unint64_t v24 = &unk_18180BE68;
  }
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v22 + 8))(v24, v23, v20, v22);
  (*(void (**)(void *, uint64_t, uint64_t))(v21 + 24))(v11, v19, v21);
  uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
  uint64_t v18 = v7;
LABEL_21:
  v17(v18, v6, v25, v12);
  free(v29);
  free(v28);
  free(v27);
  free(v26);
  free(v7);
  free(v9);
  free(v11);
  free(v3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if ((v5 & 0x8000000000000000LL) != 0) {
    goto LABEL_22;
  }
  uint64_t v6 = v3[2];
  if (v5 <= v6) {
    goto LABEL_13;
  }
  Swift::Int v28 = (void *)v3[14];
  BOOL v29 = (void *)v3[15];
  uint64_t v7 = (void *)v3[12];
  uint64_t v8 = (void *)v3[11];
  uint64_t v26 = (void *)v3[10];
  uint64_t v27 = (void *)v3[13];
  uint64_t v10 = (void *)v3[8];
  unint64_t v19 = v3[9];
  unint64_t v20 = v3[7];
  unint64_t v21 = v3[4];
  unint64_t v12 = v3[5];
  uint64_t v25 = v3[6];
  uint64_t v22 = swift_getAssociatedConformanceWitness( v21,  v19,  v20,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v4) {
    unint64_t v23 = 257LL;
  }
  else {
    unint64_t v23 = 256LL;
  }
  if (v4) {
    unint64_t v24 = &unk_18180BE78;
  }
  else {
    unint64_t v24 = &unk_18180BE68;
  }
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v22 + 8))(v24, v23, v20, v22);
  (*(void (**)(void *, uint64_t, uint64_t))(v21 + 24))(v10, v19, v21);
  uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
  uint64_t v18 = v7;
LABEL_21:
  v17(v18, v6, v25, v12);
  free(v29);
  free(v28);
  free(v27);
  free(v7);
  free(v8);
  free(v26);
  free(v10);
  free(v3);
}

    uint64_t v5 = 0;
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v5);
  }

  unsigned int v13 = 0LL;
  unint64_t v14 = &v8[v7];
  unint64_t v12 = 1;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = (unsigned __int8 *)(v4 + 4);
  unint64_t v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    uint64_t v18 = (char)*v16++;
    uint64_t v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      unint64_t v19 = 1LL;
      goto LABEL_25;
    }

    if (v17 < 0xE0u)
    {
      unint64_t v12 = 0;
      unint64_t v16 = v15 + 2;
      unint64_t v19 = 2LL;
      goto LABEL_25;
    }

    if (v17 == 224) {
      break;
    }
    if (v17 <= 0xECu) {
      goto LABEL_50;
    }
    if (v17 == 237)
    {
      uint64_t v22 = v15[1];
      if (v22 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v22 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v20 = (char *)(v15 + 2);
LABEL_54:
      if ((*v20 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v12 = 0;
      unint64_t v16 = v15 + 3;
      unint64_t v19 = 3LL;
      goto LABEL_25;
    }

    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }

    if (v17 == 240)
    {
    }

    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        LOBYTE(v23) = v15[1];
      }

      else
      {
        unint64_t v23 = v15[1];
        if (v23 > 0x8F) {
          goto LABEL_68;
        }
      }

      if ((v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }

    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }

    unint64_t v12 = 0;
    unint64_t v16 = v15 + 4;
    unint64_t v19 = 4LL;
LABEL_25:
    v13 += v19;
    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = v16;
  }

  if (v16 != (unsigned __int8 *)v14)
  {
    unint64_t v20 = (char *)(v15 + 2);
  }

        if (_swift_stdlib_isLinkingConsonant(v12))
        {
          unint64_t v19 = v15;
          return v19 & 1;
        }

        if (v16 == 2)
        {
          if (v12 < 0x300) {
            break;
          }
          unint64_t v19 = _swift_stdlib_getNormData(v12) >> 3;
          if (!v19) {
            return v19 & 1;
          }
          HIDWORD(v22) = v12 - 2381;
          LODWORD(v22) = v12 - 2381;
          unint64_t v21 = v22 >> 7;
          unint64_t v23 = v21 > 8;
          unint64_t v24 = (0x15Bu >> v21) | v15;
          if (!v23) {
            Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = v24;
          }
        }

        else if (v16 != 12)
        {
          break;
        }

        unint64_t v12 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v13, a2, a3);
        unsigned int v13 = v18;
        unint64_t v19 = 0;
        if ((v20 & 1) != 0) {
          return v19 & 1;
        }
      }
    }
  }

  unint64_t v19 = 0;
  return v19 & 1;
}

  if (a2 >= 9)
  {
    unint64_t v51 = 0LL;
    unint64_t v52 = 0LL;
    unint64_t v53 = &a1->u8[8];
    do
    {
      unint64_t v54 = *v53++;
      v51 |= (unint64_t)v54 << v52;
      v52 += 8LL;
      --v8;
    }

    while (v8);
  }

  return result;
}

  unint64_t v16 = 0LL;
  uint64_t v17 = &v11[v10];
  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = 1;
  uint64_t v18 = (unsigned __int8 *)(v7 + 4);
  unint64_t v19 = (unsigned __int8 *)(v7 + 4);
  while (1)
  {
    unint64_t v21 = (char)*v19++;
    unint64_t v20 = v21;
    if ((v21 & 0x80000000) == 0)
    {
      uint64_t v22 = 1LL;
      goto LABEL_25;
    }

    if (v20 < 0xE0u)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = 0;
      unint64_t v19 = v18 + 2;
      uint64_t v22 = 2LL;
      goto LABEL_25;
    }

    if (v20 == 224) {
      break;
    }
    if (v20 <= 0xECu) {
      goto LABEL_50;
    }
    if (v20 == 237)
    {
      uint64_t v25 = v18[1];
      if (v25 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v25 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v23 = (char *)(v18 + 2);
LABEL_54:
      if ((*v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = 0;
      unint64_t v19 = v18 + 3;
      uint64_t v22 = 3LL;
      goto LABEL_25;
    }

    if ((v20 + 16) >= 0xFEu)
    {
LABEL_50:
      LOBYTE(v25) = v18[1];
      goto LABEL_52;
    }

    if (v20 == 240)
    {
    }

    else
    {
      if ((v20 + 12) >= 0xFDu)
      {
        LOBYTE(v26) = v18[1];
      }

      else
      {
        uint64_t v26 = v18[1];
        if (v26 > 0x8F) {
          goto LABEL_68;
        }
      }

      if ((v26 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }

    if (v18 + 2 == (unsigned __int8 *)v17
      || (v18[2] & 0xC0) != 0x80
      || v18 + 3 == (unsigned __int8 *)v17
      || (v18[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }

    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = 0;
    unint64_t v19 = v18 + 4;
    uint64_t v22 = 4LL;
LABEL_25:
    v16 += v22;
    uint64_t v18 = v19;
  }

  if (v19 != (unsigned __int8 *)v17)
  {
    unint64_t v23 = (char *)(v18 + 2);
  }

  unsigned int v13 = 0LL;
  unint64_t v14 = &v8[v7];
  unint64_t v12 = 1;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = (unsigned __int8 *)(v4 + 4);
  unint64_t v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    uint64_t v18 = (char)*v16++;
    uint64_t v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      unint64_t v19 = 1LL;
      goto LABEL_25;
    }

    if (v17 <= 0xDFu)
    {
      unint64_t v12 = 0;
      unint64_t v16 = v15 + 2;
      unint64_t v19 = 2LL;
      goto LABEL_25;
    }

    if (v17 == 224) {
      break;
    }
    if (v17 <= 0xECu) {
      goto LABEL_50;
    }
    if (v17 == 237)
    {
      uint64_t v22 = v15[1];
      if (v22 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v22 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v20 = (char *)(v15 + 2);
LABEL_54:
      if ((*v20 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v12 = 0;
      unint64_t v16 = v15 + 3;
      unint64_t v19 = 3LL;
      goto LABEL_25;
    }

    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }

    if (v17 == 240)
    {
    }

    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        LOBYTE(v23) = v15[1];
      }

      else
      {
        unint64_t v23 = v15[1];
        if (v23 > 0x8F) {
          goto LABEL_68;
        }
      }

      if ((v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }

    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }

    unint64_t v12 = 0;
    unint64_t v16 = v15 + 4;
    unint64_t v19 = 4LL;
LABEL_25:
    v13 += v19;
    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = v16;
  }

  if (v16 != (unsigned __int8 *)v14)
  {
    unint64_t v20 = (char *)(v15 + 2);
  }

  uint64_t v18 = 0LL;
  unint64_t v19 = &v13[v12];
  uint64_t v17 = 1;
  unint64_t v20 = (unsigned __int8 *)(v9 + 4);
  unint64_t v21 = (unsigned __int8 *)(v9 + 4);
  while (1)
  {
    unint64_t v23 = (char)*v21++;
    uint64_t v22 = v23;
    if ((v23 & 0x80000000) == 0)
    {
      unint64_t v24 = 1LL;
      goto LABEL_25;
    }

    if (v22 < 0xE0u)
    {
      uint64_t v17 = 0;
      unint64_t v21 = v20 + 2;
      unint64_t v24 = 2LL;
      goto LABEL_25;
    }

    if (v22 == 224) {
      break;
    }
    if (v22 <= 0xECu) {
      goto LABEL_50;
    }
    if (v22 == 237)
    {
      uint64_t v27 = v20[1];
      if (v27 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v27 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      uint64_t v25 = (char *)(v20 + 2);
LABEL_54:
      if ((*v25 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      uint64_t v17 = 0;
      unint64_t v21 = v20 + 3;
      unint64_t v24 = 3LL;
      goto LABEL_25;
    }

    if ((v22 + 16) >= 0xFEu)
    {
LABEL_50:
      LOBYTE(v27) = v20[1];
      goto LABEL_52;
    }

    if (v22 == 240)
    {
    }

    else
    {
      if ((v22 + 12) >= 0xFDu)
      {
        LOBYTE(v28) = v20[1];
      }

      else
      {
        Swift::Int v28 = v20[1];
        if (v28 > 0x8F) {
          goto LABEL_68;
        }
      }

      if ((v28 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }

    if (v20 + 2 == (unsigned __int8 *)v19
      || (v20[2] & 0xC0) != 0x80
      || v20 + 3 == (unsigned __int8 *)v19
      || (v20[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }

    uint64_t v17 = 0;
    unint64_t v21 = v20 + 4;
    unint64_t v24 = 4LL;
LABEL_25:
    v18 += v24;
    unint64_t v20 = v21;
  }

  if (v21 != (unsigned __int8 *)v19)
  {
    uint64_t v25 = (char *)(v20 + 2);
  }

  unsigned int v13 = 0LL;
  unint64_t v14 = &v8[v7];
  unint64_t v12 = 1;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = (unsigned __int8 *)(v4 + 4);
  unint64_t v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    uint64_t v18 = (char)*v16++;
    uint64_t v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      unint64_t v19 = 1LL;
      goto LABEL_25;
    }

    if (v17 < 0xE0u)
    {
      unint64_t v12 = 0;
      unint64_t v16 = v15 + 2;
      unint64_t v19 = 2LL;
      goto LABEL_25;
    }

    if (v17 == 224) {
      break;
    }
    if (v17 <= 0xECu) {
      goto LABEL_50;
    }
    if (v17 == 237)
    {
      uint64_t v22 = v15[1];
      if (v22 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v22 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v20 = (char *)(v15 + 2);
LABEL_54:
      if ((*v20 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v12 = 0;
      unint64_t v16 = v15 + 3;
      unint64_t v19 = 3LL;
      goto LABEL_25;
    }

    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }

    if (v17 == 240)
    {
    }

    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        LOBYTE(v23) = v15[1];
      }

      else
      {
        unint64_t v23 = v15[1];
        if (v23 > 0x8F) {
          goto LABEL_68;
        }
      }

      if ((v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }

    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }

    unint64_t v12 = 0;
    unint64_t v16 = v15 + 4;
    unint64_t v19 = 4LL;
LABEL_25:
    v13 += v19;
    Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = v16;
  }

  if (v16 != (unsigned __int8 *)v14)
  {
    unint64_t v20 = (char *)(v15 + 2);
  }

  if (v6 < 2) {
    return 0LL;
  }
  unint64_t v14 = (*(uint64_t (**)(uint64_t))(v5 + 48))(a1);
  if (v14 >= 2) {
    return v14 - 1;
  }
  else {
    return 0LL;
  }
}

  uint64_t v5 = swift_dynamicCastForeignClassMetatype((uint64_t)a1, (uint64_t)a2);
LABEL_23:
  if (!v5) {
    return 0LL;
  }
  return v2;
}

  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = (uint64_t *)((char *)a3 + 8);
  if ((v7 & 1) != 0) {
    goto LABEL_62;
  }
  unint64_t v16 = (unint64_t *)&self[2];
  uint64_t v17 = atomic_load((unint64_t *)&self[2]);
  if (!v17)
  {
    uint64_t v18 = swift_conformsToProtocolCommon(*v5, (uint64_t)&protocol descriptor for Hashable);
    if (v18)
    {
      unint64_t v19 = v18;
      unint64_t v20 = (unint64_t)swift::hashable_support::findHashableBaseType(*v5);
    }

    else
    {
      unint64_t v21 = swift_conformsToProtocolCommon(*v5, (uint64_t)&protocol descriptor for Equatable);
      unint64_t v19 = v21 | 1;
      if (v21) {
        unint64_t v20 = (unint64_t)swift::findConformingSuperclass(*v5, *(void *)v21) | 1;
      }
      else {
        unint64_t v20 = 1LL;
      }
    }

    do
    {
      if (__ldaxr(v6))
      {
        __clrex();
        break;
      }
    }

    while (__stlxr(v19, v6));
    while (!__ldaxr(v16))
    {
      if (!__stlxr(v20, v16)) {
        goto LABEL_37;
      }
    }

    __clrex();
LABEL_37:
    uint64_t v17 = atomic_load(v16);
  }

  if (!v17 || (v17 & 1) != 0) {
    goto LABEL_62;
  }
  uint64_t v25 = (unint64_t *)((char *)a3 + 16);
  uint64_t v26 = atomic_load((unint64_t *)a3 + 2);
  if (!v26)
  {
    uint64_t v27 = swift_conformsToProtocolCommon(*v15, (uint64_t)&protocol descriptor for Hashable);
    if (v27)
    {
      Swift::Int v28 = v27;
      BOOL v29 = (unint64_t)swift::hashable_support::findHashableBaseType(*v15);
    }

    else
    {
      int64_t v30 = swift_conformsToProtocolCommon(*v15, (uint64_t)&protocol descriptor for Equatable);
      Swift::Int v28 = v30 | 1;
      if (v30) {
        BOOL v29 = (unint64_t)swift::findConformingSuperclass(*v15, *(void *)v30) | 1;
      }
      else {
        BOOL v29 = 1LL;
      }
    }

    unint64_t v31 = (unint64_t *)((char *)a3 + 24);
    do
    {
      if (__ldaxr(v31))
      {
        __clrex();
        break;
      }
    }

    while (__stlxr(v28, v31));
    while (!__ldaxr(v25))
    {
      if (!__stlxr(v29, v25)) {
        goto LABEL_58;
      }
    }

    __clrex();
LABEL_58:
    uint64_t v26 = atomic_load(v25);
  }

  if ((v26 & 1) != 0) {
    uint64_t v26 = 0LL;
  }
  if (v26 != v17)
  {
LABEL_62:
    uint64_t v34 = atomic_load(v6);
    if (!v34)
    {
      size_t v35 = swift_conformsToProtocolCommon(*v5, (uint64_t)&protocol descriptor for Hashable);
      if (v35)
      {
        uint64_t v34 = v35;
        unint64_t v36 = (unint64_t)swift::hashable_support::findHashableBaseType(*v5);
      }

      else
      {
        uint64_t v37 = swift_conformsToProtocolCommon(*v5, (uint64_t)&protocol descriptor for Equatable);
        uint64_t v34 = v37 | 1;
        if (v37) {
          unint64_t v36 = (unint64_t)swift::findConformingSuperclass(*v5, *(void *)v37) | 1;
        }
        else {
          unint64_t v36 = 1LL;
        }
      }

      while (!__ldaxr(v6))
      {
        if (!__stlxr(v34, v6)) {
          goto LABEL_73;
        }
      }

      __clrex();
LABEL_73:
      Swift::String::Index v43 = (unint64_t *)&self[2];
      while (!__ldaxr(v43))
      {
        if (!__stlxr(v36, v43)) {
          goto LABEL_78;
        }
      }

      __clrex();
    }

    uint64_t v8 = 0LL;
    goto LABEL_23;
  }

  if (((1LL << (v9 + 83)) & 0x100000010000000DLL) == 0)
  {
    if (v10 == 8) {
      goto LABEL_20;
    }
    if (v10 == 59)
    {
      *((_DWORD *)this + 24) = v7;
      char v11 = *((unsigned __int8 *)v8 + 18);
      unint64_t v12 = 232;
      unsigned int v13 = v8;
      while (v12 == 232)
      {
        unsigned int v13 = (uint64_t *)*v13;
        unint64_t v12 = *((_WORD *)v13 + 8);
      }

      return (unint64_t)v8;
    }

    goto LABEL_14;
  }

  if (*(_DWORD *)a4) {
    return this;
  }
  this = (uint64_t *)swift::Demangle::__runtime::CharVector::append((char **)v5 + 1591, "XSD", 3uLL, (void *)v5[1593]);
  unint64_t v14 = 0;
  uint64_t v9 = 0LL;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v15 = 0;
LABEL_25:
  *(_DWORD *)a4 = v14;
  *(void *)(a4 + 8) = v9;
  *(_DWORD *)(a4 + 16) = v15;
  return this;
}

  v2[3184] = v4 + 1;
  v6[v4] = 95;
  return this;
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Character( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return String.debugDescription.getter(*(void *)v4, *(void *)(v4 + 8), a3, a4);
}

uint64_t static Character.== infix(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a1 == a3 && a2 == a4) {
    return 1LL;
  }
  if ((~a2 & 0x6000000000000000LL) == 0 && (a4 & 0x2000000000000000LL) != 0 && (a4 & 0x4000000000000000LL) != 0) {
    return 0LL;
  }
  return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, 0);
}

uint64_t static Character.< infix(_:_:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a1 == a3 && a2 == a4) {
    return 0LL;
  }
  if ((~a2 & 0x6000000000000000LL) != 0 || (a4 & 0x2000000000000000LL) == 0 || (a4 & 0x4000000000000000LL) == 0) {
    return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, 1);
  }
  BOOL v5 = bswap64(a1) < bswap64(a3);
  BOOL v6 = bswap64(a2) < bswap64(a4);
  if (a1 == a3) {
    return v6;
  }
  else {
    return v5;
  }
}

uint64_t static String.< infix(_:_:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a1 == a3 && a2 == a4) {
    return 0LL;
  }
  if ((~a2 & 0x6000000000000000LL) != 0 || (a4 & 0x2000000000000000LL) == 0 || (a4 & 0x4000000000000000LL) == 0) {
    return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, 1);
  }
  BOOL v5 = bswap64(a1) < bswap64(a3);
  BOOL v6 = bswap64(a2) < bswap64(a4);
  if (a1 == a3) {
    return v6;
  }
  else {
    return v5;
  }
}

void String.hash(into:)(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  if ((a3 & 0x2000000000000000LL) != 0) {
    unint64_t v3 = a3;
  }
  else {
    unint64_t v3 = a2;
  }
  if ((a3 & 0x1000000000000000LL) != 0 || (v3 & 0x4000000000000000LL) == 0)
  {
    if ((a3 & 0x2000000000000000LL) != 0) {
      uint64_t v8 = HIBYTE(a3) & 0xF;
    }
    else {
      uint64_t v8 = a2 & 0xFFFFFFFFFFFFLL;
    }
    _StringGutsSlice._normalizedHash(into:)(a1, a2, a3, 0LL, v8);
  }

  else
  {
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      v9[0] = a2;
      v9[1] = a3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v7 = (char *)v9 + (HIBYTE(a3) & 0xF);
      BOOL v6 = v9;
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0)
      {
        id v4 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v5 = a2 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        id v4 = _StringObject.sharedUTF8.getter(a2, a3);
      }

      BOOL v6 = (void *)specialized UnsafeRawBufferPointer.init<A>(_:)((uint64_t)v4, v5);
    }

    Hasher.combine(bytes:)(*(Swift::UnsafeRawBufferPointer *)&v6);
    Hasher._combine(_:)(0xFFu);
  }

Swift::Int Character.hashValue.getter(unint64_t a1, unint64_t a2)
{
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  String.hash(into:)(v3, a1, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Character()
{
  unint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  String.hash(into:)(v4, v1, v2);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Character(unint64_t *a1)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Character(uint64_t a1)
{
  unint64_t v2 = *v1;
  unint64_t v3 = v1[1];
  v5[0] = 0LL;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v5[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v5[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  String.hash(into:)(v5, v2, v3);
  return Hasher._finalize()();
}

uint64_t Character._isSmall.getter(uint64_t a1, unint64_t a2)
{
  return (a2 >> 61) & 1;
}

uint64_t _StringGuts.isSmall.getter(uint64_t a1, unint64_t a2)
{
  return (a2 >> 61) & 1;
}

void _CocoaArrayWrapper.buffer.setter(void *a1)
{
  id *v1 = a1;
}

uint64_t (*_CocoaArrayWrapper.buffer.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _CocoaArrayWrapper.startIndex.getter()
{
  return 0LL;
}

uint64_t _CocoaArrayWrapper.contiguousStorage(_:)(uint64_t a1, uint64_t a2, id a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  id v5 = objc_msgSend(a3, sel_countByEnumeratingWithState_objects_count_, v7, 0, 0);
  uint64_t result = 0LL;
  if ((uint64_t)v5 >= a2)
  {
    if (!*((void *)&v7[0] + 1)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CocoaArray.swift",  22LL,  2,  0x7BuLL,  0);
    }
    return *((void *)&v7[0] + 1) + 8 * a1;
  }

  return result;
}

void _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
}

uint64_t Range.isEmpty.getter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) + 8LL) + 8LL))( v1,  v1 + *(int *)(a1 + 36)) & 1;
}

double _makeSwiftNSFastEnumerationState()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _CocoaArrayWrapper@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2);
  *a2 = result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance _CocoaArrayWrapper( uint64_t *a1)
{
  uint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v1);
  *a1 = result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _CocoaArrayWrapper@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3);
  *a3 = result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _CocoaArrayWrapper( uint64_t *a1, uint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2);
}

id protocol witness for Collection.endIndex.getter in conformance _CocoaArrayWrapper@<X0>(void *a1@<X8>)
{
  id result = objc_msgSend(*v1, sel_count);
  *a1 = result;
  return result;
}

void (*protocol witness for Collection.subscript.read in conformance _CocoaArrayWrapper( void *a1, void *a2))(uint64_t a1)
{
  id v4 = objc_msgSend(*v2, sel_objectAtIndex_, *a2);
  *a1 = v4;
  a1[1] = v4;
  return protocol witness for Collection.subscript.read in conformance _CocoaArrayWrapper;
}

void protocol witness for Collection.subscript.read in conformance _CocoaArrayWrapper(uint64_t a1)
{
}

uint64_t protocol witness for Collection.subscript.getter in conformance _CocoaArrayWrapper@<X0>( uint64_t *a1@<X0>, char *a2@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = _CocoaArrayWrapper.subscript.getter(*a1, a1[1], *v3, a2);
  *a3 = result;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

unint64_t protocol witness for Collection.indices.getter in conformance _CocoaArrayWrapper@<X0>( void *a1@<X8>)
{
  unint64_t result = (unint64_t)objc_msgSend(*v1, sel_count);
  if ((result & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  *a1 = 0LL;
  a1[1] = result;
  return result;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance _CocoaArrayWrapper()
{
  return objc_msgSend(*v0, sel_count) == 0;
}

uint64_t protocol witness for Collection.count.getter in conformance _CocoaArrayWrapper()
{
  return specialized RandomAccessCollection<>.distance(from:to:)(0, (uint64_t)objc_msgSend(*v0, sel_count), *v0);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance _CocoaArrayWrapper@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *a1;
  id v8 = *v4;
  uint64_t v9 = specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a3, *v4);
  if (a2 < 1)
  {
    if (v9 <= 0 && v9 > a2) {
      goto LABEL_4;
    }
LABEL_10:
    uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(v7, a2, v8);
    char v11 = 0;
    goto LABEL_11;
  }

uint64_t protocol witness for Collection.index(after:) in conformance _CocoaArrayWrapper@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2);
  *a2 = result;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance _CocoaArrayWrapper(uint64_t *a1)
{
  uint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v1);
  *a1 = result;
  return result;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance _CocoaArrayWrapper()
{
  uint64_t v1 = *v0;
  unint64_t v2 = specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
  swift_unknownObjectRelease(v1);
  return v2;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _CocoaArrayWrapper( id *a1, void **a2, uint64_t a3)
{
  *a1 = _CocoaArrayWrapper._copyContents(initializing:)(a2, a3, *v3);
  a1[1] = v5;
  return v6;
}

uint64_t specialized CodingKey.description.getter( unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  if ((a4 & 1) != 0)
  {
    unint64_t v7 = 0xE300000000000000LL;
    uint64_t v369 = 7104878LL;
  }

  else
  {
    uint64_t v369 = _int64ToString(_:radix:uppercase:)( a3,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    unint64_t v7 = v6;
  }

  uint64_t v8 = specialized static String._createEmpty(withInitialCapacity:)(35LL);
  unint64_t v12 = v8;
  unint64_t v13 = v9;
  v372._uint64_t countAndFlagsBits = v8;
  v372._unint64_t object = (void *)v9;
  uint64_t v14 = HIBYTE(v9) & 0xF;
  int64_t v15 = v8 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0x2000000000000000LL) != 0) {
    uint64_t v16 = HIBYTE(v9) & 0xF;
  }
  else {
    uint64_t v16 = v8 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v368 = a2;
  if (!v16 && (v8 & ~v9 & 0x2000000000000000LL) == 0)
  {
    v372._uint64_t countAndFlagsBits = 0LL;
    v372._unint64_t object = (void *)0xE000000000000000LL;
LABEL_24:
    uint64_t v41 = v13;
LABEL_28:
    swift_bridgeObjectRelease(v41);
    goto LABEL_29;
  }

  if ((v9 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v10, v11);
    if ((v13 & 0x1000000000000000LL) != 0)
    {
      int64_t v15 = String.UTF8View._foreignCount()();
      if ((v12 & ~v13 & 0x2000000000000000LL) == 0) {
        goto LABEL_26;
      }
    }

    else if ((v12 & ~v13 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_26;
    }

    if (swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v17 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
      if ((v18 & 1) != 0) {
        goto LABEL_346;
      }
      if (v15 <= 15 && (v17 & 0x8000000000000000LL) != 0) {
        goto LABEL_16;
      }
      goto LABEL_27;
    }

LABEL_111:
      unint64_t v130 = &v46->u8[v92];
      unint64_t v131 = v91 - v92;
      do
      {
        unsigned int v132 = *v130++;
        v52 |= (unint64_t)v132 << (v93 & 0x38);
        v93 += 8LL;
        --v131;
      }

      while (v131);
      goto LABEL_113;
    }

      unint64_t v130 = &v46->u8[v92];
      unint64_t v131 = v91 - v92;
      do
      {
        unsigned int v132 = *v130++;
        v52 |= (unint64_t)v132 << (v93 & 0x38);
        v93 += 8LL;
        --v131;
      }

      while (v131);
      goto LABEL_113;
    }

        uint32x4_t v114 = (v134 - 1) & v134;
        int8x16_t v129 = __clz(__rbit64(v134)) + (v133 << 6);
        unint64_t v218 = v133;
      }

      (*(void (**)(int64_t, unint64_t, unint64_t))(v109 + 16))( v3,  *(void *)(v42 + 48) + *(void *)(v109 + 72) * v129,  v2);
    }

    (*(void (**)(int64_t, void, uint64_t, unint64_t))(v109 + 56))(v3, 0LL, 1LL, v2);
    unsigned int v136 = *(void (**)(char *, int64_t, unint64_t))(v109 + 32);
    v136(v5, v3, v2);
    if ((v49 & 1) == 0) {
      break;
    }
LABEL_96:
    uint64x2_t v125 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v125, v221);
    *((_OWORD *)inited + 1) = v219;
    inited[7] = v2;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v136(boxed_opaque_existential_0Tm, (int64_t)v5, v2);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  (uint64_t *)&v223);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    unint64_t v49 = 0LL;
  }

  unint64_t v139 = v5;
  unint64_t v42 = v223;
  unint64_t v140 = v224;
  unint64_t v141 = HIBYTE(v224) & 0xF;
  if ((v224 & 0x2000000000000000LL) != 0) {
    uint64_t v142 = HIBYTE(v224) & 0xF;
  }
  else {
    uint64_t v142 = v223 & 0xFFFFFFFFFFFFLL;
  }
  if (!v142 && (v223 & ~v224 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v224);
    unint64_t v223 = 8236LL;
    unint64_t v224 = 0xE200000000000000LL;
    goto LABEL_94;
  }

  if ((v224 & 0x2000000000000000LL) != 0 && v141 <= 0xD)
  {
    unint64_t v143 = 8 * (HIBYTE(v224) & 7);
    uint64_t v144 = (-255LL << v143) - 1;
    uint64_t v145 = 44LL << v143;
    unint64_t v146 = v141 + 1;
    if (v141 >= 8)
    {
      uint64_t v147 = v145 | v144 & v224;
      id v5 = v139;
    }

    else
    {
      unint64_t v42 = v145 | v144 & v223;
      id v5 = v139;
      if (v141 != 7)
      {
        unint64_t v42 = (32LL << (8 * (v146 & 7u))) | ((-255LL << (8 * (v146 & 7u))) - 1) & v42;
        unint64_t v174 = v224;
        goto LABEL_147;
      }

      unint64_t v146 = 8;
      uint64_t v147 = v224;
    }

    unint64_t v174 = (32LL << (8 * (v146 & 7u))) | ((-255LL << (8 * (v146 & 7u))) - 1) & v147;
LABEL_147:
    swift_bridgeObjectRelease(v224);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v175 = 0xE000000000000000LL;
    if (v42 & 0x8080808080808080LL | v174 & 0x80808080808080LL) {
      unint64_t v175 = 0xA000000000000000LL;
    }
    unint64_t v223 = v42;
    unint64_t v224 = (v175 & 0xFF00000000000000LL | (v141 << 56) | v174 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
    unint64_t v3 = (int64_t)v215;
    goto LABEL_95;
  }

  swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v137, v138);
  if ((v140 & 0x1000000000000000LL) == 0)
  {
    unsigned int v57 = __OFADD__(v142, 2LL);
    unint64_t v148 = v142 + 2;
    if (v57) {
      goto LABEL_152;
    }
LABEL_126:
    if ((v42 & ~v140 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v140 & 0xFFFFFFFFFFFFFFFLL))
    {
      Swift::Int v149 = _StringGuts.nativeUnusedCapacity.getter(v42, v140);
      if ((v150 & 1) != 0) {
        goto LABEL_201;
      }
      unint64_t v152 = (v140 & 0x2000000000000000LL) == 0 && v149 > 1;
      if (v148 > 15 || v152) {
        goto LABEL_93;
      }
    }

    else if (v148 > 15)
    {
LABEL_93:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v148, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
      unint64_t v222 = v211;
      int8x16_t v123 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v222, 2LL);
      _StringGuts.appendInPlace(_:isASCII:)(v123, v124, 1);
      swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_94:
      id v5 = v139;
LABEL_95:
      unint64_t v42 = v217;
      goto LABEL_96;
    }

    swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
    swift_bridgeObjectRetain(v140, v153, v154, v155);
    size_t v156 = _StringGuts._convertedToSmall()(v42, v140);
    Swift::String::Index v158 = v157;
    swift_bridgeObjectRelease(v140);
    v159._Swift::UInt64 rawBits = 1LL;
    v160._Swift::UInt64 rawBits = 131073LL;
    v161._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v159, v160, 0x202CuLL, 0xE200000000000000LL);
    if (v161._rawBits < 0x10000) {
      v161._rawBits |= 3;
    }
    unint64_t v163 = specialized String.init(_:)(v161, v162, 0x202CuLL, 0xE200000000000000LL);
    Swift::String::Index v165 = v164;
    swift_bridgeObjectRelease(0xE200000000000000LL);
    Swift::String::Index v166 = _StringGuts._convertedToSmall()(v163, v165);
    Swift::String::Index v168 = v167;
    swift_bridgeObjectRelease(v165);
    unint64_t v169 = specialized _SmallString.init(_:appending:)(v156, v158, v166, v168);
    if ((v171 & 1) != 0) {
      goto LABEL_200;
    }
    unint64_t v172 = v169;
    unint64_t v173 = v170;
    swift_bridgeObjectRelease(v140);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v223 = v172;
    unint64_t v224 = v173;
    uint16x8_t v109 = v212;
    unint64_t v3 = (int64_t)v215;
    goto LABEL_94;
  }

  unint64_t v176 = String.UTF8View._foreignCount()();
  unint64_t v148 = v176 + 2;
  if (!__OFADD__(v176, 2LL)) {
    goto LABEL_126;
  }
LABEL_152:
  __break(1u);
LABEL_153:
  (*(void (**)(int64_t, uint64_t, uint64_t, unint64_t))(v109 + 56))(v3, 1LL, 1LL, v2);
  outlined consume of [A : B].Iterator._Variant<A, B>(v42);
  int64_t v15 = v223;
  unint64_t v2 = v224;
  Swift::String::Index v179 = HIBYTE(v224) & 0xF;
  if ((v224 & 0x2000000000000000LL) != 0) {
    uint64_t v180 = HIBYTE(v224) & 0xF;
  }
  else {
    uint64_t v180 = v223 & 0xFFFFFFFFFFFFLL;
  }
  if (!v180 && (v223 & ~v224 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v224);
    swift_bridgeObjectRelease(0xE300000000000000LL);
    return 10589LL;
  }

  if ((v224 & 0x2000000000000000LL) == 0 || v179 > 0xD)
  {
    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v177, v178);
    if ((v2 & 0x1000000000000000LL) != 0) {
      goto LABEL_197;
    }
    unsigned int v57 = __OFADD__(v180, 2LL);
    uint64_t v181 = v180 + 2;
    if (!v57) {
      goto LABEL_165;
    }
    goto LABEL_199;
  }

  if (v179 < 8)
  {
    int64_t v15 = (93LL << (8 * (HIBYTE(v224) & 7u))) | ((-255LL << (8 * (HIBYTE(v224) & 7u))) - 1) & v223;
    if (v179 != 7) {
      int64_t v15 = (41LL << (8 * ((v179 + 1) & 7))) | ((-255LL << (8 * ((v179 + 1) & 7))) - 1) & v15;
    }
  }

  swift_bridgeObjectRelease(v224);
  swift_bridgeObjectRelease(0xE300000000000000LL);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  return v15;
}

            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
          }

LABEL_338:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v53 = 0LL;
  unint64_t v54 = &v46->u8[v47];
  if (!v46) {
    unint64_t v54 = 0LL;
  }
  char v50 = 1;
  for (i = v46; ; i = (uint8x16_t *)((char *)i + 3))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unsigned int v57 = i->u8[0];
          i = (uint8x16_t *)((char *)i + 1);
          unsigned int v56 = v57;
          if ((v56 & 0x80) != 0) {
            break;
          }
          ++v53;
        }

        if (v56 > 0xDF) {
          break;
        }
        char v50 = 0;
        i = (uint8x16_t *)((char *)i + 1);
        v53 += 2LL;
      }

      if (v56 != 224) {
        break;
      }
      if (!i) {
        goto LABEL_86;
      }
      uint64_t v58 = &i->u8[1];
      if ((i->i8[0] & 0xE0) != 0xA0) {
        goto LABEL_86;
      }
LABEL_64:
      if (v58 == v54 || (*v58 & 0xC0) != 0x80) {
        goto LABEL_86;
      }
      char v50 = 0;
      i = (uint8x16_t *)((char *)i + 2);
      v53 += 3LL;
    }

    if (v56 <= 0xEC)
    {
LABEL_56:
      uint64_t v58 = &i->u8[1];
      LOBYTE(v59) = i->i8[0];
LABEL_63:
      if ((v59 & 0xC0) != 0x80) {
        goto LABEL_86;
      }
      goto LABEL_64;
    }

    if (v56 == 237)
    {
      if (!i) {
        goto LABEL_86;
      }
      uint64_t v58 = &i->u8[1];
      unsigned int v59 = i->u8[0];
      if (v59 > 0x9F) {
        goto LABEL_86;
      }
      goto LABEL_63;
    }

    if (v56 <= 0xEF) {
      goto LABEL_56;
    }
    if (v56 != 240) {
      break;
    }
    if (!i) {
      goto LABEL_86;
    }
    unint64_t v60 = &i->u8[1];
LABEL_81:
    char v50 = 0;
    v53 += 4LL;
  }

  if ((v56 + 15) <= 2u)
  {
    unint64_t v60 = &i->u8[1];
    LOBYTE(v61) = i->i8[0];
    goto LABEL_80;
  }

  if (i)
  {
    if (i != (uint8x16_t *)v54)
    {
      unint64_t v60 = &i->u8[1];
      unsigned int v61 = i->u8[0];
      if (v61 <= 0x8F)
      {
LABEL_80:
        if ((v61 & 0xC0) != 0x80) {
          goto LABEL_86;
        }
        goto LABEL_81;
      }
    }
  }

    uint64_t v370 = 266LL;
    goto LABEL_340;
  }

            BOOL v75 = 0LL;
          }

          uint64_t v249 = 278;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChild( this,  v249,  (swift::Demangle::__runtime::Node *)v75,  (uint64_t)v75,  a5);
        default:
          return (unsigned int *)v8;
      }

    case 'P':
      uint64_t v79 = swift::Demangle::__runtime::Demangler::popProtocolConformance(this, a2, a3, a4, a5);
      if (!v79) {
        return 0LL;
      }
      size_t v43 = (unsigned __int16 *)v79;
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        uint64_t v80 = 2LL * *((void *)v7 + 4);
        if (v80 <= 0x20) {
          uint64_t v80 = 32LL;
        }
        *((void *)v7 + 4) = v80;
        unsigned int v81 = v80 + 8;
        size_t v82 = malloc(v80 + 8);
        uint64_t v83 = (char *)v82 + v81;
        char *v82 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v82 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v83;
        *((void *)v7 + 3) = v82;
      }

      *((void *)v7 + 1) = v8 + 24;
      unint64_t v49 = 197;
      goto LABEL_152;
    case 'S':
      uint64_t v84 = swift::Demangle::__runtime::Demangler::popProtocol(this, a2, a3, a4, a5);
      if (!v84) {
        return 0LL;
      }
      size_t v43 = (unsigned __int16 *)v84;
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        uint64_t v85 = 2LL * *((void *)v7 + 4);
        if (v85 <= 0x20) {
          uint64_t v85 = 32LL;
        }
        *((void *)v7 + 4) = v85;
        uint64_t v86 = v85 + 8;
        uint64_t v87 = malloc(v85 + 8);
        uint64_t v88 = (char *)v87 + v86;
        char *v87 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v87 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v88;
        *((void *)v7 + 3) = v87;
      }

      *((void *)v7 + 1) = v8 + 24;
      unint64_t v49 = 195;
      goto LABEL_152;
    case 'T':
      uint64_t v89 = *((_DWORD *)this + 24);
      if (v89 && (uint64_t v90 = v89 - 1, v91 = *(void *)(*((void *)this + 11) + 8LL * v90), *(_WORD *)(v91 + 16) == 232)) {
        *((_DWORD *)this + 24) = v90;
      }
      else {
        unint64_t v91 = 0LL;
      }
      int8x16_t v129 = swift::Demangle::__runtime::Demangler::popAssocTypePath(this, a2, a3, a4, a5);
      uint64_t v134 = swift::Demangle::__runtime::Demangler::popProtocolConformance(v7, v130, v131, v132, v133);
      unint64_t v135 = v7;
      unsigned int v136 = 9;
      unint64_t v137 = (unsigned __int16 *)v129;
      a5 = (char *)v91;
      return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( v135,  v136,  (swift::Demangle::__runtime::Node *)v134,  (swift::Demangle::__runtime::Node *)v137,  a5);
    case 'V':
      unint64_t v92 = *((_DWORD *)this + 24);
      if (!v92) {
        return 0LL;
      }
      unint64_t v93 = v92 - 1;
      size_t v43 = *(unsigned __int16 **)(*((void *)this + 11) + 8LL * v93);
      if (v43[8] != 232) {
        return 0LL;
      }
      *((_DWORD *)this + 24) = v93;
      uint64_t v8 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)this + 2))
      {
        unint64_t v94 = 2LL * *((void *)this + 4);
        if (v94 <= 0x20) {
          unint64_t v94 = 32LL;
        }
        *((void *)this + 4) = v94;
        int64x2_t v95 = v94 + 8;
        int8x16_t v96 = malloc(v94 + 8);
        int8x16_t v97 = (char *)v96 + v95;
        char *v96 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v96 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v97;
        *((void *)v7 + 3) = v96;
      }

      *((void *)v7 + 1) = v8 + 24;
      unint64_t v49 = 253;
      goto LABEL_152;
    case 'Z':
    case 'z':
      unint64_t v12 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v12 || v12 + 24 > *((void *)this + 2))
      {
        unint64_t v13 = 2LL * *((void *)this + 4);
        if (v13 <= 0x20) {
          unint64_t v13 = 32LL;
        }
        *((void *)this + 4) = v13;
        uint64_t v14 = v13 + 8;
        int64_t v15 = malloc(v13 + 8);
        *int64_t v15 = *((void *)v7 + 3);
        unint64_t v12 = ((unint64_t)v15 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = (char *)v15 + v14;
        *((void *)v7 + 3) = v15;
      }

      *((void *)v7 + 1) = v12 + 24;
      *(_WORD *)(v12 + 16) = 317;
      *(_BYTE *)(v12 + 18) = 0;
      uint64_t v16 = *((_DWORD *)v7 + 24);
      if (!v16)
      {
        unint64_t v17 = 0LL;
        goto LABEL_202;
      }

      unint64_t v251 = v11;
      unint64_t v252 = (unsigned int *)v12;
      unint64_t v17 = 0LL;
      char v18 = 0LL;
      uint64_t v19 = 0LL;
      while (2)
      {
        unint64_t v21 = *((void *)v7 + 11);
        if (*(_WORD *)(*(void *)(v21 + 8LL * (v16 - 1)) + 16LL) == 275)
        {
          *((_DWORD *)v7 + 24) = v16 - 1;
          if (v16 == 1) {
            goto LABEL_214;
          }
          v16 -= 2;
          unint64_t v22 = *(void *)(v21 + 8LL * v16);
          unint64_t v23 = *(unsigned __int16 *)(v22 + 16);
          if ((v23 - 173) > 0x3C || ((1LL << (v23 + 83)) & 0x100000010000010DLL) == 0)
          {
            Swift::String::Index v25 = (v23 - 101) > 0x24 || ((1LL << (v23 - 101)) & 0x1000800001LL) == 0;
            if (v25 && v23 != 347) {
              goto LABEL_214;
            }
          }

          *((_DWORD *)v7 + 24) = v16;
          if (v18 < v19)
          {
            *(void *)char v18 = v22;
            uint64_t v20 = v18 + 8;
            v18 += 8;
            if (!v16) {
              goto LABEL_196;
            }
            continue;
          }

          Swift::String::Index v26 = (v18 - v17) >> 3;
          Swift::String::Index v27 = v26 + 1;
          if ((v19 - v17) >> 2 > v27) {
            Swift::String::Index v27 = (v19 - v17) >> 2;
          }
          else {
            Swift::String::Index v28 = v27;
          }
          if (v28)
          {
            if (v28 >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unint64_t v29 = operator new(8 * v28);
          }

          else
          {
            unint64_t v29 = 0LL;
          }

          unint64_t v30 = &v29[8 * v26];
          *(void *)unint64_t v30 = v22;
          uint64_t v20 = v30 + 8;
          if (v18 == v17) {
            goto LABEL_39;
          }
          unint64_t v31 = v18 - v17 - 8;
          if (v31 < 0x168)
          {
            unint64_t v32 = v18;
            goto LABEL_38;
          }

          unint64_t v34 = (v18 - 8 - v17) & 0xFFFFFFFFFFFFFFF8LL;
          if (&v29[v18 - v17 - 8 - v34] > &v29[v18 - v17 - 8])
          {
            unint64_t v32 = v18;
          }

          else
          {
            if (&v18[-v34 - 8] <= v18 - 8)
            {
              if ((unint64_t)(v17 - v29) < 0x20)
              {
                unint64_t v32 = v18;
                goto LABEL_38;
              }

              unint64_t v35 = (v31 >> 3) + 1;
              unint64_t v36 = 8 * (v35 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v32 = &v18[-v36];
              v30 -= v36;
              char v37 = &v29[8 * v26 - 16];
              uint64_t v38 = v18 - 16;
              uint64_t v39 = v35 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                unint64_t v40 = *(_OWORD *)v38;
                *(v37 - 1) = *((_OWORD *)v38 - 1);
                *char v37 = v40;
                v37 -= 2;
                v38 -= 32;
                v39 -= 4LL;
              }

              while (v39);
              if (v35 != (v35 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_38;
              }
LABEL_39:
              uint64_t v19 = &v29[8 * v28];
              if (v17)
              {
                operator delete(v17);
                uint64_t v16 = *((_DWORD *)v7 + 24);
              }

              unint64_t v17 = v30;
              char v18 = v20;
              if (!v16) {
                goto LABEL_196;
              }
              continue;
            }

            unint64_t v32 = v18;
          }

          do
          {
LABEL_38:
            unint64_t v33 = *((void *)v32 - 1);
            v32 -= 8;
            *((void *)v30 - 1) = v33;
            v30 -= 8;
          }

          while (v32 != v17);
          goto LABEL_39;
        }

        break;
      }

      uint64_t v20 = v18;
LABEL_196:
      if (v20 == v17)
      {
        unint64_t v12 = (unint64_t)v252;
      }

      else
      {
        unint64_t v12 = (unint64_t)v252;
        do
        {
          uint64_t v150 = (swift::Demangle::__runtime::Node *)*((void *)v20 - 1);
          v20 -= 8;
          swift::Demangle::__runtime::Node::addChild(v252, v150, v7, a4, a5);
        }

        while (v20 != v17);
      }

      char v11 = v251;
LABEL_202:
      int64_t v151 = swift::Demangle::__runtime::Demangler::popContext(v7, a2, a3, a4, a5);
      if (v151 && (v11 == 90 ? (char v154 = 315) : (char v154 = 316), v12))
      {
        Swift::String::Index v155 = v151;
        uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v8 || v8 + 24 > *((void *)v7 + 2))
        {
          size_t v156 = 2LL * *((void *)v7 + 4);
          if (v156 <= 0x20) {
            size_t v156 = 32LL;
          }
          *((void *)v7 + 4) = v156;
          unint64_t v157 = v156 + 8;
          Swift::String::Index v158 = malloc(v156 + 8);
          uint64_t v159 = (char *)v158 + v157;
          *Swift::String::Index v158 = *((void *)v7 + 3);
          uint64_t v8 = ((unint64_t)v158 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)v7 + 2) = v159;
          *((void *)v7 + 3) = v158;
        }

        *((void *)v7 + 1) = v8 + 24;
        *(_WORD *)(v8 + 16) = v154;
        *(_BYTE *)(v8 + 18) = 0;
        swift::Demangle::__runtime::Node::addChild((unsigned int *)v8, v155, v7, v152, v153);
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v8,  (swift::Demangle::__runtime::Node *)v12,  v7,  v160,  v161);
        if (!v17) {
          return (unsigned int *)v8;
        }
      }

      else
      {
LABEL_214:
        uint64_t v8 = 0LL;
        if (!v17) {
          return (unsigned int *)v8;
        }
      }

      operator delete(v17);
      return (unsigned int *)v8;
    case 'a':
      int64x2_t v98 = swift::Demangle::__runtime::Demangler::popProtocolConformance(this, a2, a3, a4, a5);
      if (!v98) {
        return 0LL;
      }
      size_t v43 = (unsigned __int16 *)v98;
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        int64x2_t v99 = 2LL * *((void *)v7 + 4);
        if (v99 <= 0x20) {
          int64x2_t v99 = 32LL;
        }
        *((void *)v7 + 4) = v99;
        int64x2_t v100 = v99 + 8;
        int64x2_t v101 = malloc(v99 + 8);
        uint64_t v102 = (char *)v101 + v100;
        *int64x2_t v101 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v101 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v102;
        *((void *)v7 + 3) = v101;
      }

      *((void *)v7 + 1) = v8 + 24;
      unint64_t v49 = 198;
      goto LABEL_152;
    case 'b':
      int8x16_t v103 = *((_DWORD *)this + 24);
      else {
        size_t v43 = 0LL;
      }
      unint64_t v138 = swift::Demangle::__runtime::Demangler::popProtocolConformance(this, a2, a3, a4, a5);
      uint64_t v8 = 0LL;
      if (!v43) {
        return (unsigned int *)v8;
      }
      uint64_t v66 = v138;
      if (!v138) {
        return (unsigned int *)v8;
      }
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        unint64_t v139 = 2LL * *((void *)v7 + 4);
        if (v139 <= 0x20) {
          unint64_t v139 = 32LL;
        }
        *((void *)v7 + 4) = v139;
        unint64_t v140 = v139 + 8;
        unint64_t v141 = malloc(v139 + 8);
        uint64_t v142 = (char *)v141 + v140;
        *unint64_t v141 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v141 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v142;
        *((void *)v7 + 3) = v141;
      }

      *((void *)v7 + 1) = v8 + 24;
      uint64_t v71 = 10;
      goto LABEL_192;
    case 'l':
      int64x2_t v105 = swift::Demangle::__runtime::Demangler::popProtocolConformance(this, a2, a3, a4, a5);
      int8x16_t v106 = *((_DWORD *)v7 + 24);
      if (!v106) {
        return 0LL;
      }
      int8x16_t v107 = v106 - 1;
      uint64_t v66 = *(unsigned int **)(*((void *)v7 + 11) + 8LL * v107);
      if (*((_WORD *)v66 + 8) != 232) {
        return 0LL;
      }
      size_t v43 = (unsigned __int16 *)v105;
      *((_DWORD *)v7 + 24) = v107;
      if (!v105) {
        return 0LL;
      }
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        uint8x8_t v108 = 2LL * *((void *)v7 + 4);
        if (v108 <= 0x20) {
          uint8x8_t v108 = 32LL;
        }
        *((void *)v7 + 4) = v108;
        uint16x8_t v109 = v108 + 8;
        uint32x4_t v110 = malloc(v108 + 8);
        uint64x2_t v111 = (char *)v110 + v109;
        *uint32x4_t v110 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v110 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v111;
        *((void *)v7 + 3) = v110;
      }

      *((void *)v7 + 1) = v8 + 24;
      uint64_t v71 = 135;
      goto LABEL_192;
    case 'p':
      uint64x2_t v112 = swift::Demangle::__runtime::Demangler::popProtocolConformance(this, a2, a3, a4, a5);
      if (!v112) {
        return 0LL;
      }
      size_t v43 = (unsigned __int16 *)v112;
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        uint64x2_t v113 = 2LL * *((void *)v7 + 4);
        if (v113 <= 0x20) {
          uint64x2_t v113 = 32LL;
        }
        *((void *)v7 + 4) = v113;
        uint32x4_t v114 = v113 + 8;
        uint64x2_t v115 = malloc(v113 + 8);
        int8x16_t v116 = (char *)v115 + v114;
        *uint64x2_t v115 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v115 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v116;
        *((void *)v7 + 3) = v115;
      }

      *((void *)v7 + 1) = v8 + 24;
      unint64_t v49 = 199;
      goto LABEL_152;
    case 'r':
      uint16x8_t v117 = swift::Demangle::__runtime::Demangler::popProtocolConformance(this, a2, a3, a4, a5);
      if (!v117) {
        return 0LL;
      }
      size_t v43 = (unsigned __int16 *)v117;
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        int8x16_t v118 = 2LL * *((void *)v7 + 4);
        if (v118 <= 0x20) {
          int8x16_t v118 = 32LL;
        }
        *((void *)v7 + 4) = v118;
        uint16x8_t v119 = v118 + 8;
        int8x16_t v120 = malloc(v118 + 8);
        int8x16_t v121 = (char *)v120 + v119;
        *int8x16_t v120 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v120 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v121;
        *((void *)v7 + 3) = v120;
      }

      *((void *)v7 + 1) = v8 + 24;
      unint64_t v49 = 90;
LABEL_152:
      *(_WORD *)(v8 + 16) = v49;
      *(_BYTE *)(v8 + 18) = 0;
      goto LABEL_193;
    case 't':
      int8x8_t v122 = *((_DWORD *)this + 24);
      if (!v122
        || ((int8x16_t v123 = v122 - 1,
             size_t v43 = *(unsigned __int16 **)(*((void *)this + 11) + 8LL * v123),
             int8x8_t v124 = v43[8],
             (v124 - 173) <= 0x3C)
          ? (uint64x2_t v125 = ((1LL << (v124 + 83)) & 0x100000010000010DLL) == 0)
          : (uint64x2_t v125 = 1),
            v125
         && ((v124 - 101) <= 0x24
           ? (int8x16_t v126 = ((1LL << (v124 - 101)) & 0x1000800001LL) == 0)
           : (int8x16_t v126 = 1),
             v126 && v124 != 347)))
      {
        size_t v43 = 0LL;
      }

      else
      {
        *((_DWORD *)this + 24) = v123;
      }

      unint64_t v143 = swift::Demangle::__runtime::Demangler::popProtocolConformance(this, a2, a3, a4, a5);
      uint64_t v8 = 0LL;
      if (!v43) {
        return (unsigned int *)v8;
      }
      uint64_t v66 = v143;
      if (!v143) {
        return (unsigned int *)v8;
      }
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        uint64_t v144 = 2LL * *((void *)v7 + 4);
        if (v144 <= 0x20) {
          uint64_t v144 = 32LL;
        }
        *((void *)v7 + 4) = v144;
        uint64_t v145 = v144 + 8;
        unint64_t v146 = malloc(v144 + 8);
        uint64_t v147 = (char *)v146 + v145;
        *unint64_t v146 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v146 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v147;
        *((void *)v7 + 3) = v146;
      }

      *((void *)v7 + 1) = v8 + 24;
      uint64_t v71 = 6;
LABEL_192:
      *(_WORD *)(v8 + 16) = v71;
      *(_BYTE *)(v8 + 18) = 0;
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v8,  (swift::Demangle::__runtime::Node *)v66,  v7,  v62,  v63);
LABEL_193:
      unint64_t v148 = (unsigned int *)v8;
      Swift::Int v149 = (swift::Demangle::__runtime::Node *)v43;
      goto LABEL_194;
    case 'v':
      if (v9 >= v6) {
        return 0LL;
      }
      *((void *)this + 9) = v5 + 2;
      int8x16_t v127 = *(char *)(v10 + v9);
      if (v127 == 100)
      {
        int8x16_t v128 = 0LL;
      }

      else
      {
        uint64_t v8 = 0LL;
        if (v127 != 105) {
          return (unsigned int *)v8;
        }
        int8x16_t v128 = 1LL;
      }

      unint64_t v162 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v162 || v162 + 24 > *((void *)this + 2))
      {
        unint64_t v163 = 2LL * *((void *)this + 4);
        if (v163 <= 0x20) {
          unint64_t v163 = 32LL;
        }
        *((void *)this + 4) = v163;
        unint64_t v164 = v163 + 8;
        Swift::String::Index v165 = malloc(v163 + 8);
        char *v165 = *((void *)v7 + 3);
        unint64_t v162 = ((unint64_t)v165 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = (char *)v165 + v164;
        *((void *)v7 + 3) = v165;
      }

      *((void *)v7 + 1) = v162 + 24;
      *(_WORD *)(v162 + 16) = 52;
      *(_BYTE *)(v162 + 18) = 4;
      *(void *)unint64_t v162 = v128;
      Swift::String::Index v166 = *((_DWORD *)v7 + 24);
      if (!v166) {
        return 0LL;
      }
      Swift::String::Index v167 = v166 - 1;
      Swift::String::Index v168 = *(unsigned __int16 **)(*((void *)v7 + 11) + 8LL * (v166 - 1));
      unint64_t v169 = v168[8];
      *((_DWORD *)v7 + 24) = v167;
      uint64_t v8 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v8 || v8 + 24 > *((void *)v7 + 2))
      {
        unint64_t v170 = 2LL * *((void *)v7 + 4);
        if (v170 <= 0x20) {
          unint64_t v170 = 32LL;
        }
        *((void *)v7 + 4) = v170;
        unint64_t v171 = v170 + 8;
        unint64_t v172 = malloc(v170 + 8);
        unint64_t v173 = (char *)v172 + v171;
        const char *v172 = *((void *)v7 + 3);
        uint64_t v8 = ((unint64_t)v172 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v173;
        *((void *)v7 + 3) = v172;
      }

      *((void *)v7 + 1) = v8 + 24;
      *(_WORD *)(v8 + 16) = 73;
      *(_BYTE *)(v8 + 18) = 0;
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v8,  (swift::Demangle::__runtime::Node *)v162,  v7,  a4,  a5);
      unint64_t v148 = (unsigned int *)v8;
      Swift::Int v149 = (swift::Demangle::__runtime::Node *)v168;
LABEL_194:
      swift::Demangle::__runtime::Node::addChild(v148, v149, v7, a4, a5);
      return (unsigned int *)v8;
    default:
      return (unsigned int *)v8;
  }

LABEL_164:
    uint64_t v186 = v183._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_168;
  }

      uint64_t v65 = v56;
      uint64_t v66 = (__int128 *)v65[v62];
LABEL_169:
      if (*((_WORD *)v66 + 8) == 225) {
        break;
      }
      ++v62;
      ++v63;
      if (v61 == v62) {
        goto LABEL_171;
      }
    }

    if (v60 == 5)
    {
      uint64_t v67 = *((_DWORD *)v56 + 2);
      if ((_DWORD)v62 - v67 == -1)
      {
        *((_DWORD *)v56 + 2) = v62;
      }

      else
      {
        do
        {
          *(void *)(*v56 + 8LL * (v63 - 1)) = *(void *)(*v56 + 8LL * v63);
          ++v63;
        }

        while (v67 != v63);
        --*((_DWORD *)v56 + 2);
      }
    }

    else if (v60 == 2)
    {
      if (!(_DWORD)v62) {
        char *v56 = v56[1];
      }
      *((_BYTE *)v56 + 18) = 1;
    }

    else
    {
      *((_BYTE *)v56 + 18) = 0;
    }

    uint64_t v68 = *v66;
    uint64_t v52 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    if (!v52 || v52 + 24 > *((void *)this + 2))
    {
      uint64_t v69 = 2LL * *((void *)this + 4);
      if (v69 <= 0x20) {
        uint64_t v69 = 32LL;
      }
      *((void *)this + 4) = v69;
      uint64_t v70 = v69 + 8;
      uint64_t v74 = v68;
      uint64_t v71 = malloc(v69 + 8);
      uint64_t v68 = v74;
      uint64_t v72 = (char *)v71 + v70;
      char *v71 = *((void *)this + 3);
      uint64_t v52 = ((unint64_t)v71 + 15) & 0xFFFFFFFFFFFFFFF8LL;
      *((void *)this + 2) = v72;
      *((void *)this + 3) = v71;
    }

    *((void *)this + 1) = v52 + 24;
    *(_WORD *)(v52 + 16) = 101;
    *(_BYTE *)(v52 + 18) = 3;
    *(_OWORD *)uint64_t v52 = v68;
LABEL_136:
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v11,  (swift::Demangle::__runtime::Node *)v52,  this,  a4,  a5);
    v47 |= *(unsigned __int16 *)(v52 + 16) != 275;
    ++v46;
  }

  while (v46 != v37);
  if ((v47 & 1) == 0) {
    return swift::Demangle::__runtime::NodeFactory::createNode(this, 290);
  }
  if (!*((_BYTE *)this + 80)) {
    swift::Demangle::__runtime::Node::reverseChildren(v11, 0LL);
  }
  return (unint64_t)v11;
}

LABEL_167:
  uint64_t v186 = ((unint64_t)v183._object >> 56) & 0xF;
LABEL_168:
  swift_bridgeObjectRetain((unint64_t)v183._object, (uint64_t)v184, v181, v182);
  _StringGuts.append(_:)(v183._countAndFlagsBits, (unint64_t)v183._object, 0LL, v186);
  swift_bridgeObjectRelease_n((uint64_t)v183._object, 2LL);
LABEL_169:
  uint64_t v193 = v372._countAndFlagsBits;
  unint64_t v194 = (unint64_t)v372._object;
  unint64_t v195 = ((unint64_t)v372._object >> 56) & 0xF;
  unint64_t v196 = v372._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v196 && (v372._countAndFlagsBits & ~(uint64_t)v372._object & 0x2000000000000000LL) == 0)
  {
    v372._uint64_t countAndFlagsBits = v367;
    v372._unint64_t object = (void *)object;
    swift_bridgeObjectRetain(object, v190, v191, v192);
LABEL_204:
    uint64_t v229 = v194;
    goto LABEL_205;
  }

  int64_t v151 = object & 0x2000000000000000LL;
  unint64_t v51 = HIBYTE(object) & 0xF;
  unint64_t v197 = v195 + v51;
  if (v195 + v51 <= 0xF)
  {
    if (v51)
    {
      char v241 = 0;
      unint64_t v242 = 0LL;
      unint64_t v243 = (unint64_t)v372._object;
      do
      {
        unint64_t v244 = v195 + v242;
        unint64_t v245 = v242 + 1;
        if (v242 >= 8) {
          unint64_t v246 = object;
        }
        else {
          unint64_t v246 = v367;
        }
        unint64_t v247 = v246 >> (v241 & 0x38);
        char v248 = (8 * v195 + v241) & 0x38;
        uint64_t v249 = (-255LL << v248) - 1;
        unint64_t v250 = (unint64_t)v247 << v248;
        unint64_t v251 = v250 | v249 & v243;
        unint64_t v252 = v250 | v249 & v193;
        if (v244 < 8) {
          uint64_t v193 = v252;
        }
        else {
          unint64_t v243 = v251;
        }
        v241 += 8;
        unint64_t v242 = v245;
      }

      while (v51 != v245);
    }

    else
    {
      unint64_t v243 = (unint64_t)v372._object;
    }

    swift_bridgeObjectRelease((uint64_t)v372._object);
    unint64_t v265 = 0xA000000000000000LL;
    if (!(v193 & 0x8080808080808080LL | v243 & 0x80808080808080LL)) {
      unint64_t v265 = 0xE000000000000000LL;
    }
    v372._uint64_t countAndFlagsBits = v193;
    v372._unint64_t object = (void *)(v265 & 0xFF00000000000000LL | (v197 << 56) | v243 & 0xFFFFFFFFFFFFFFLL);
    goto LABEL_241;
  }

  int64_t v151 = 1LL;
LABEL_177:
  uint64_t v142 = v367 & 0xFFFFFFFFFFFFLL;
  if (v151) {
    uint64_t v52 = HIBYTE(object) & 0xF;
  }
  else {
    uint64_t v52 = v367 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(object, 3LL, v191, v192);
  if ((object & 0x1000000000000000LL) != 0) {
    goto LABEL_325;
  }
  swift_bridgeObjectRetain_n(object, 4LL, v147, v148);
  int64_t v198 = v52;
  if ((v194 & 0x1000000000000000LL) == 0) {
    goto LABEL_182;
  }
LABEL_328:
  Swift::Int v356 = String.UTF8View._foreignCount()();
  int64_t v199 = v356 + v198;
  if (__OFADD__(v356, v198)) {
    goto LABEL_185;
  }
LABEL_187:
  if ((v193 & ~v194 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v194 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v199 > 15) {
      goto LABEL_193;
    }
    goto LABEL_197;
  }

  unint64_t v201 = (unint64_t)v372._object;
  int64_t v202 = _StringGuts.nativeUnusedCapacity.getter(v372._countAndFlagsBits, (uint64_t)v372._object);
  if ((v203 & 1) != 0) {
    goto LABEL_346;
  }
  if (v199 <= 15 && ((v201 & 0x2000000000000000LL) != 0 || v202 < v198))
  {
LABEL_197:
    swift_bridgeObjectRelease_n(v368, 5LL);
    unint64_t v206 = v372._countAndFlagsBits;
    unint64_t v207 = v372._object;
    swift_bridgeObjectRetain((unint64_t)v372._object, v208, v209, v210);
    unint64_t v211 = _StringGuts._convertedToSmall()(v206, (unint64_t)v207);
    unint64_t v213 = v212;
    swift_bridgeObjectRelease((uint64_t)v207);
    v214._Swift::UInt64 rawBits = (v52 << 16) | 1;
    v215._Swift::UInt64 rawBits = 1LL;
    v216._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v215, v214, v367, v368);
    if (v216._rawBits < 0x10000) {
      v216._rawBits |= 3;
    }
    unint64_t v218 = specialized String.init(_:)(v216, v217, v367, v368);
    unint64_t v220 = v219;
    swift_bridgeObjectRelease(v368);
    unint64_t v221 = _StringGuts._convertedToSmall()(v218, v220);
    unint64_t v223 = v222;
    swift_bridgeObjectRelease(v220);
    unint64_t v224 = specialized _SmallString.init(_:appending:)(v211, v213, v221, v223);
    if ((v226 & 1) == 0)
    {
      uint64_t v227 = v224;
      unint64_t v228 = v225;
      swift_bridgeObjectRelease(v368);
      uint64_t v229 = (uint64_t)v372._object;
      v372._uint64_t countAndFlagsBits = v227;
      v372._unint64_t object = v228;
LABEL_205:
      swift_bridgeObjectRelease(v229);
      goto LABEL_241;
    }

LABEL_345:
    unint64_t v365 = 266LL;
    goto LABEL_347;
  }

LABEL_193:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v199, v198);
  unint64_t v194 = v368;
  swift_bridgeObjectRelease_n(v368, 4LL);
  if ((v368 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v368);
    _StringGuts._foreignAppendInPlace(_:)(v367, v368, 0LL, v52);
    goto LABEL_232;
  }

  if (v151)
  {
    swift_bridgeObjectRelease_n(v368, 2LL);
    uint64_t v370 = v367;
    unint64_t v371 = v368 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v204 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v51, (uint64_t)&v370, v51);
    _StringGuts.appendInPlace(_:isASCII:)(v204, v205, (v368 & 0x4000000000000000LL) != 0);
    goto LABEL_204;
  }

  uint64_t v258 = v367;
  if ((v367 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v368);
    id v259 = (id)((v368 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v260 = v142;
    goto LABEL_231;
  }

  id v259 = _StringObject.sharedUTF8.getter(v367, v368);
  uint64_t v260 = v363;
  swift_bridgeObjectRelease(v368);
  if (v260 < v142) {
    goto LABEL_344;
  }
  unint64_t v7 = v366;
  uint64_t v258 = v367;
  unint64_t v194 = v368;
LABEL_231:
  v261 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v142, (uint64_t)v259, v260);
  _StringGuts.appendInPlace(_:isASCII:)(v261, v262, v258 < 0);
LABEL_232:
  swift_bridgeObjectRelease_n(v194, 2LL);
LABEL_241:
  Swift::String v268 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", intValue: ", 0xDuLL, 1);
  v269 = v372._object;
  unint64_t v270 = ((unint64_t)v372._object >> 56) & 0xF;
  if (!v270 && (v372._countAndFlagsBits & ~(uint64_t)v372._object & 0x2000000000000000LL) == 0)
  {
    Swift::String v372 = v268;
    swift_bridgeObjectRelease((uint64_t)v269);
    goto LABEL_254;
  }

  if (((uint64_t)v372._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v268._object & 0x2000000000000000LL) != 0)
    {
      unint64_t v272 = specialized _SmallString.init(_:appending:)( v372._countAndFlagsBits,  (unint64_t)v372._object,  v268._countAndFlagsBits,  (unint64_t)v268._object);
      if ((v266 & 1) != 0) {
        goto LABEL_252;
      }
      uint64_t v273 = v272;
      v274 = v269;
      swift_bridgeObjectRelease((uint64_t)v268._object);
      swift_bridgeObjectRelease((uint64_t)v372._object);
      v372._uint64_t countAndFlagsBits = v273;
      v372._unint64_t object = v274;
      goto LABEL_254;
    }

                _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v188, 2LL);
                swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
                unint64_t v239 = xmmword_1817FFD00;
                unint64_t v211 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v239, 2LL);
                _StringGuts.appendInPlace(_:isASCII:)(v211, v212, 1);
                swift_bridgeObjectRelease(v12);
                swift_bridgeObjectRelease(0xE200000000000000LL);
                return v240;
              }

  (*(void (**)(char *, uint64_t))(v365 + 8))(v186, v59);
  (*(void (**)(char *, uint64_t))(v368 + 8))(v228, v369);
  return v390;
}

    swift_bridgeObjectRelease(a1);
    unint64_t v174 = v249;
    unint64_t v175 = a2;
LABEL_194:
    v176._Swift::UInt64 rawBits = v38 & 0xFFFFFFFFFFFF0000LL | 1;
    v177._Swift::UInt64 rawBits = v43 & 0xFFFFFFFFFFFF0000LL | 1;
    v178._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v176, v177, a3, a1);
    if (v178._rawBits < 0x10000) {
      v178._rawBits |= 3;
    }
    uint64_t v180 = specialized String.init(_:)(v178, v179, a3, a1);
    Swift::String::Index v182 = v181;
    swift_bridgeObjectRelease(a1);
    if ((v182 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v182);
      int64_t v15 = v245;
    }

    else
    {
      int64_t v15 = v245;
      if ((v182 & 0x1000000000000000LL) != 0)
      {
        uint64_t v180 = _StringGuts._foreignConvertedToSmall()(v180, v182);
        unint64_t v238 = v237;
        swift_bridgeObjectRelease(v182);
        Swift::String::Index v182 = v238;
      }

      else
      {
        if ((v180 & 0x1000000000000000LL) != 0)
        {
          Swift::UInt64 v225 = (unsigned __int8 *)((v182 & 0xFFFFFFFFFFFFFFFLL) + 32);
          char v226 = v180 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          Swift::UInt64 v225 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v180, v182);
        }

        closure #1 in _StringGuts._convertedToSmall()(v225, v226, &v247);
        swift_bridgeObjectRelease(v182);
        uint64_t v180 = v247;
        Swift::String::Index v182 = v248;
      }
    }

    Swift::String v183 = HIBYTE(v175) & 0xF;
    Swift::String::Index v184 = HIBYTE(v182) & 0xF;
    unint64_t v185 = v184 + v183;
    if ((unint64_t)(v184 + v183) <= 0xF)
    {
      if (v184)
      {
        uint64_t v186 = 0;
        unint64_t v187 = 0LL;
        do
        {
          uint64_t v188 = v183 + v187;
          uint64_t v189 = v187 + 1;
          if (v187 >= 8) {
            uint64_t v190 = v182;
          }
          else {
            uint64_t v190 = v180;
          }
          uint64_t v191 = v190 >> (v186 & 0x38);
          v192 = (8 * v183 + v186) & 0x38;
          uint64_t v193 = (-255LL << v192) - 1;
          unint64_t v194 = (unint64_t)v191 << v192;
          unint64_t v195 = v194 | v193 & v175;
          unint64_t v196 = v194 | v193 & v174;
          if (v188 < 8) {
            unint64_t v174 = v196;
          }
          else {
            unint64_t v175 = v195;
          }
          v186 += 8;
          unint64_t v187 = v189;
        }

        while (v184 != v189);
      }

      swift_bridgeObjectRelease(a2);
      unint64_t v197 = 0xA000000000000000LL;
      if (!(v174 & 0x8080808080808080LL | v175 & 0x80808080808080LL)) {
        unint64_t v197 = 0xE000000000000000LL;
      }
      uint64_t v249 = v174;
      unint64_t v250 = v197 & 0xFF00000000000000LL | (v185 << 56) | v175 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_213;
    }

  uint64_t result = 0LL;
  uint64_t v8 = 0;
LABEL_229:
  Swift::String::Index v158 = v8;
LABEL_230:
  LOBYTE(v157[0]) = (a2 & 0x1000000000000000LL) != 0;
  return result;
}

      uint64_t v142 = 0LL;
LABEL_199:
      Foreignuint64_t WitnessTable = _getForeignWitnessTable(ForeignWitnessTable, v140, (uint64_t)v142);
      return ForeignWitnessTable | 1;
    }

    do
      unint64_t v62 = __ldaxr((unsigned int *)v24);
    while (__stxr(v62 + 1, (unsigned int *)v24));
    do
    {
      uint64_t v63 = atomic_load(v24 + 1);
      uint64_t v64 = atomic_load(v24 + 2);
      uint64_t v65 = atomic_load((unsigned int *)v24 + 1);
      uint64_t v66 = atomic_load(v24 + 1);
    }

    while (v63 != v66);
    if (v63) {
      uint64_t v67 = v64 == 0;
    }
    else {
      uint64_t v67 = 1;
    }
    if (!v67 && v65 != 0)
    {
      if (v69)
      {
        v24[5] = *v69;
        unsigned int v61 = *v69;
        do
          uint64_t v70 = __ldxr((unsigned int *)v24);
        while (__stlxr(v70 - 1, (unsigned int *)v24));
        goto LABEL_173;
      }
    }

    do
      uint64_t v71 = __ldxr((unsigned int *)v24);
    while (__stlxr(v71 - 1, (unsigned int *)v24));
    size_t v156 = v155;
    lock = (os_unfair_lock_s *)(v24 + 3);
    os_unfair_lock_lock((os_unfair_lock_t)v24 + 6);
    uint64_t v72 = v24[2];
    uint64_t v73 = (v72 & 3) == 0;
    if ((v72 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      uint64_t v73 = 1;
    }
    int64_t v151 = v72 & 0xFFFFFFFFFFFFFFFCLL;
    Swift::Int v149 = v73;
    if (v73) {
      uint64_t v74 = 4;
    }
    else {
      uint64_t v74 = *(unsigned __int8 *)(v72 & 0xFFFFFFFFFFFFFFFCLL);
    }
    BOOL v75 = *((unsigned int *)v24 + 1);
    uint64_t v76 = (_DWORD *)v24[1];
    if (v77)
    {
      unsigned int v61 = *v77;
      __dmb(0xBu);
      if (*(_DWORD *)v24)
      {
        os_unfair_lock_unlock(lock);
        v24[5] = v61;
        unint64_t v60 = (os_unfair_lock_s *)(v24 + 6);
      }

      else
      {
        uint64_t v83 = (void **)v24[4];
        if (v83)
        {
          do
          {
            uint64_t v84 = (void **)*v83;
            free(v83[1]);
            free(v83);
            uint64_t v83 = v84;
          }

          while (v84);
        }

        unint64_t v60 = (os_unfair_lock_s *)(v24 + 6);
        v24[4] = 0LL;
        os_unfair_lock_unlock(lock);
        v24[5] = v61;
      }

      goto LABEL_173;
    }

    unint64_t v143 = v76 + 2;
    uint64_t v147 = v72;
    uint64_t v145 = (v75 + 1);
    char v154 = v8;
    if ((1LL << v74) / (unint64_t)((1LL << v74) - v145) < 4)
    {
      uint64_t v85 = v76;
      LOBYTE(v86) = v72;
      if (v76) {
        goto LABEL_147;
      }
    }

    else
    {
      uint64_t v79 = (v74 + 1);
      if (v79 >= 0x11) {
        uint64_t v80 = 4;
      }
      else {
        uint64_t v80 = 2;
      }
      if (v79 < 9) {
        unsigned int v81 = 1LL;
      }
      else {
        unsigned int v81 = v80;
      }
      size_t v82 = (unint64_t)calloc(2LL << v74, v81);
      if (!v82) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      if ((_DWORD)v81 != 1)
      {
        if ((_DWORD)v81 == 4) {
          unsigned int v81 = 3LL;
        }
        else {
          unsigned int v81 = 2LL;
        }
      }

      uint64_t v86 = v81 | v82;
      *(_BYTE *)size_t v82 = v74 + 1;
      if (v74) {
        __asm { BR              X8 }
      }

      atomic_store(v86, v24 + 2);
      if (!v149)
      {
        uint64_t v87 = malloc(0x10uLL);
        char *v87 = v24[4];
        v87[1] = v151;
        v24[4] = v87;
      }

      uint64_t v85 = v76;
      if (v76)
      {
LABEL_147:
        uint64_t v88 = (unint64_t)v85;
      }
    }

    uint64_t v89 = v75 + (v75 >> 2);
    if (v89 <= v75 + 1) {
      uint64_t v89 = v75 + 1;
    }
    uint64_t v90 = malloc_good_size(8 * v89 + 8);
    unint64_t v91 = malloc(v90);
    if (!v91) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    uint64_t v88 = (unint64_t)v91;
    *unint64_t v91 = (v90 + 0x7FFFFFFF8LL) >> 3;
    if (v85)
    {
      memcpy(v91 + 2, v143, 8 * v75);
      unint64_t v92 = malloc(0x10uLL);
      *unint64_t v92 = v24[4];
      v92[1] = v85;
      v24[4] = v92;
    }

    atomic_store(v88, v24 + 1);
LABEL_154:
    unint64_t v93 = a1[3];
    unint64_t v94 = (unsigned int *)(((unint64_t)&v154[3 * BYTE1(v93) + ((v93 >> 6) & 1)] + ((v93 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFFCLL);
    if ((v93 & 0x10000) != 0) {
      int64x2_t v95 = *v94;
    }
    else {
      int64x2_t v95 = 0LL;
    }
    int8x16_t v96 = HIWORD(v94[2 * v95 + ((v93 >> 16) & 1)]);
    int8x16_t v97 = *a1;
    int64x2_t v98 = (char *)a1 + (v97 & 0xFFFFFFFFFFFFFFFELL);
    if ((v97 & 1) != 0) {
      int64x2_t v98 = *(char **)v98;
    }
    int64x2_t v99 = v88 + 8;
    int64x2_t v100 = *((unsigned int *)v98 + 4);
    if ((_DWORD)v100)
    {
      int64x2_t v101 = *((_DWORD *)v98 + 3);
      uint64_t v102 = (uint64_t)&v98[12 * v101 + 24];
      int8x16_t v103 = (v100 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v103 >= 8)
      {
        int8x16_t v107 = v103 + 1;
        uint8x8_t v108 = v107 & 7;
        if ((v107 & 7) == 0) {
          uint8x8_t v108 = 8LL;
        }
        uint16x8_t v109 = v107 - v108;
        int64x2_t v105 = (char *)(v102 + 8 * v109);
        uint32x4_t v110 = (const float *)&v98[12 * v101 + 56];
        uint64x2_t v111 = 0uLL;
        v112.i64[0] = 0xF0000000FLL;
        v112.i64[1] = 0xF0000000FLL;
        uint64x2_t v113 = (int8x16_t)vdupq_n_s64(1uLL);
        uint32x4_t v114 = 0uLL;
        uint64x2_t v115 = 0uLL;
        int8x16_t v116 = 0uLL;
        do
        {
          uint16x8_t v117 = v110 - 8;
          int8x16_t v118 = (unsigned __int128)vld2q_f32(v117);
          uint16x8_t v119 = (unsigned __int128)vld2q_f32(v110);
          int8x16_t v120 = (int32x4_t)vandq_s8((int8x16_t)v119, v112);
          int8x16_t v121 = vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)v118, v112));
          v122.i64[0] = v121.u32[0];
          v122.i64[1] = v121.u32[1];
          int8x16_t v123 = (int64x2_t)vandq_s8(v122, v113);
          v122.i64[0] = v121.u32[2];
          v122.i64[1] = v121.u32[3];
          int8x8_t v124 = (int64x2_t)vandq_s8(v122, v113);
          uint64x2_t v125 = vceqzq_s32(v120);
          v122.i64[0] = v125.u32[0];
          v122.i64[1] = v125.u32[1];
          int8x16_t v126 = (int64x2_t)vandq_s8(v122, v113);
          v122.i64[0] = v125.u32[2];
          v122.i64[1] = v125.u32[3];
          uint32x4_t v114 = vaddq_s64(v114, v124);
          uint64x2_t v111 = vaddq_s64(v111, v123);
          int8x16_t v116 = vaddq_s64(v116, (int64x2_t)vandq_s8(v122, v113));
          uint64x2_t v115 = vaddq_s64(v115, v126);
          v110 += 16;
          v109 -= 8LL;
        }

        while (v109);
        unint64_t v104 = vaddvq_s64(vaddq_s64(vaddq_s64(v115, v111), vaddq_s64(v116, v114)));
      }

      else
      {
        unint64_t v104 = 0LL;
        int64x2_t v105 = &v98[12 * v101 + 24];
      }

      int8x16_t v106 = v75;
      int8x16_t v127 = (char *)(v102 + 8 * v100);
      do
      {
        int8x16_t v128 = *v105;
        v105 += 8;
        if ((v128 & 0xF) == 0) {
          ++v104;
        }
      }

      while (v105 != v127);
    }

    else
    {
      int8x16_t v106 = v75;
      unint64_t v104 = 0LL;
    }

    v157[0] = 16;
    int8x16_t v129 = swift::MetadataAllocator::Allocate( (swift::MetadataAllocator *)v157,  8 * (v104 + (v96 >> 1)) + 32,  (const char *)8,  v78);
    unint64_t v130 = v155;
    unint64_t v131 = (os_unfair_lock_s *)swift_slowAlloc(0x10uLL, 7uLL);
    *(_OWORD *)&v131->_os_unfair_lock_opaque = xmmword_1817FFD30;
    os_unfair_lock_lock(v131 + 2);
    *(void *)int8x16_t v129 = (unint64_t)v131 | 1;
    *((void *)v129 + 1) = v130;
    *((void *)v129 + 2) = a1;
    *(void *)(v99 + 8 * v106) = v129;
    atomic_store(v145, (unsigned int *)v24 + 1);
    __asm { BR              X11 }
  }

LABEL_249:
    uint64_t v271 = v268._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_253;
  }

        __break(1u);
LABEL_250:
        if ((v39 & 0x1000000000000000LL) != 0)
        {
          int64x2_t v101 = _StringGuts._foreignConvertedToSmall()(v101, v34);
          uint64_t v39 = v255;
        }

        else
        {
          if ((v101 & 0x1000000000000000LL) != 0)
          {
            unint64_t v246 = (unsigned __int8 *)((v39 & 0xFFFFFFFFFFFFFFFLL) + 32);
            unint64_t v247 = v101 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            unint64_t v246 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v101, v34);
            unint64_t v247 = v104;
          }

          swift_bridgeObjectRetain(v34, v104, v105, v106);
          closure #1 in _StringGuts._convertedToSmall()(v246, v247, &v264);
          swift_bridgeObjectRelease(v34);
          uint64_t v39 = *((void *)&v264 + 1);
          int64x2_t v101 = v264;
        }

LABEL_252:
  uint64_t v271 = ((unint64_t)v268._object >> 56) & 0xF;
LABEL_253:
  swift_bridgeObjectRetain((unint64_t)v268._object, (uint64_t)v269, v266, v267);
  _StringGuts.append(_:)(v268._countAndFlagsBits, (unint64_t)v268._object, 0LL, v271);
  swift_bridgeObjectRelease_n((uint64_t)v268._object, 2LL);
LABEL_254:
  uint64_t v277 = v372._countAndFlagsBits;
  unint64_t v278 = (unint64_t)v372._object;
  unint64_t v279 = ((unint64_t)v372._object >> 56) & 0xF;
  unint64_t v280 = v372._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v280 && (v372._countAndFlagsBits & ~(uint64_t)v372._object & 0x2000000000000000LL) == 0)
  {
    v372._uint64_t countAndFlagsBits = v369;
    v372._unint64_t object = (void *)v7;
    uint64_t v296 = v278;
    goto LABEL_289;
  }

  uint64_t v281 = v7 & 0x2000000000000000LL;
  uint64_t v282 = HIBYTE(v7) & 0xF;
  unint64_t v283 = v279 + v282;
  if (v279 + v282 <= 0xF)
  {
    if (v282)
    {
      char v322 = 0;
      unint64_t v323 = 0LL;
      do
      {
        unint64_t v324 = v279 + v323;
        unint64_t v325 = v323 + 1;
        if (v323 >= 8) {
          unint64_t v326 = v7;
        }
        else {
          unint64_t v326 = v369;
        }
        unint64_t v327 = v326 >> (v322 & 0x38);
        char v328 = (8 * v279 + v322) & 0x38;
        uint64_t v329 = (-255LL << v328) - 1;
        unint64_t v330 = (unint64_t)v327 << v328;
        unint64_t v331 = v330 | v329 & v278;
        unint64_t v332 = v330 | v329 & v277;
        if (v324 < 8) {
          uint64_t v277 = v332;
        }
        else {
          unint64_t v278 = v331;
        }
        v322 += 8;
        unint64_t v323 = v325;
      }

      while (v282 != v325);
    }

    swift_bridgeObjectRelease(v7);
    unint64_t v333 = 0xA000000000000000LL;
    if (!(v277 & 0x8080808080808080LL | v278 & 0x80808080808080LL)) {
      unint64_t v333 = 0xE000000000000000LL;
    }
    v334 = (void *)(v333 & 0xFF00000000000000LL | (v283 << 56) | v278 & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v372._object);
    v372._uint64_t countAndFlagsBits = v277;
    v372._unint64_t object = v334;
    goto LABEL_306;
  }

  uint64_t v281 = 1LL;
LABEL_262:
  uint64_t v284 = v369 & 0xFFFFFFFFFFFFLL;
  if (v281) {
    uint64_t v285 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v285 = v369 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v7, 2LL, v275, v276);
  if ((v7 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(v7, 4LL, v286, v287);
    Swift::Int v288 = v285;
    if ((v278 & 0x1000000000000000LL) == 0) {
      goto LABEL_267;
    }
LABEL_334:
    Swift::Int v361 = String.UTF8View._foreignCount()();
    int64_t v289 = v361 + v288;
    if (!__OFADD__(v361, v288)) {
      goto LABEL_272;
    }
    do
    {
LABEL_270:
      __break(1u);
LABEL_271:
      uint64_t v290 = HIBYTE(v278) & 0xF;
      int64_t v289 = v290 + v288;
    }

    while (__OFADD__(v290, v288));
    goto LABEL_272;
  }

  swift_bridgeObjectRetain_n(v7, 5LL, v286, v287);
  v357._Swift::UInt64 rawBits = 1LL;
  v358._Swift::UInt64 rawBits = (v285 << 16) | 1;
  v359._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v357, v358, v369, v7);
  if (v359._rawBits < 0x10000) {
    v359._rawBits |= 3;
  }
  Swift::Int v288 = specialized Collection.count.getter(v359, v360, v369, v7);
  swift_bridgeObjectRelease(v7);
  uint64_t v277 = v372._countAndFlagsBits;
  unint64_t v278 = (unint64_t)v372._object;
LABEL_267:
  if ((v278 & 0x2000000000000000LL) != 0) {
    goto LABEL_271;
  }
  int64_t v289 = (v277 & 0xFFFFFFFFFFFFLL) + v288;
  if (__OFADD__(v277 & 0xFFFFFFFFFFFFLL, v288)) {
    goto LABEL_270;
  }
LABEL_272:
  if ((v277 & ~v278 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v278 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v289 > 15) {
      goto LABEL_278;
    }
LABEL_282:
    swift_bridgeObjectRelease_n(v7, 5LL);
    unint64_t v297 = v372._countAndFlagsBits;
    v298 = v372._object;
    swift_bridgeObjectRetain((unint64_t)v372._object, v299, v300, v301);
    unint64_t v302 = _StringGuts._convertedToSmall()(v297, (unint64_t)v298);
    unint64_t v304 = v303;
    swift_bridgeObjectRelease((uint64_t)v298);
    v305._Swift::UInt64 rawBits = (v285 << 16) | 1;
    v306._Swift::UInt64 rawBits = 1LL;
    v307._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v306, v305, v369, v7);
    if (v307._rawBits < 0x10000) {
      v307._rawBits |= 3;
    }
    unint64_t v309 = specialized String.init(_:)(v307, v308, v369, v7);
    unint64_t v311 = v310;
    swift_bridgeObjectRelease(v7);
    unint64_t v312 = _StringGuts._convertedToSmall()(v309, v311);
    unint64_t v314 = v313;
    swift_bridgeObjectRelease(v311);
    unint64_t v315 = specialized _SmallString.init(_:appending:)(v302, v304, v312, v314);
    if ((v317 & 1) == 0)
    {
      uint64_t v318 = v315;
      v319 = v316;
      swift_bridgeObjectRelease(v7);
      uint64_t v296 = (uint64_t)v372._object;
      v372._uint64_t countAndFlagsBits = v318;
      v372._unint64_t object = v319;
LABEL_289:
      swift_bridgeObjectRelease(v296);
      goto LABEL_306;
    }

    goto LABEL_345;
  }

  unint64_t v291 = (unint64_t)v372._object;
  int64_t v292 = _StringGuts.nativeUnusedCapacity.getter(v372._countAndFlagsBits, (uint64_t)v372._object);
  if ((v293 & 1) != 0)
  {
LABEL_346:
    unint64_t v365 = 258LL;
LABEL_347:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v365,  0);
  }

  if (v289 <= 15 && ((v291 & 0x2000000000000000LL) != 0 || v292 < v288)) {
    goto LABEL_282;
  }
LABEL_278:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v289, v288);
  swift_bridgeObjectRelease_n(v7, 4LL);
  if ((v7 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v7);
    _StringGuts._foreignAppendInPlace(_:)(v369, v7, 0LL, v285);
  }

  else
  {
    if (v281)
    {
      swift_bridgeObjectRelease_n(v7, 2LL);
      uint64_t v370 = v369;
      unint64_t v371 = v7 & 0xFFFFFFFFFFFFFFLL;
      v294 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v7) & 0xF,  (uint64_t)&v370,  HIBYTE(v7) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v294, v295, (v7 & 0x4000000000000000LL) != 0);
      uint64_t v296 = v7;
      goto LABEL_289;
    }

    if ((v369 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v7);
      id v335 = (id)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v336 = v369 & 0xFFFFFFFFFFFFLL;
      goto LABEL_304;
    }

    id v335 = _StringObject.sharedUTF8.getter(v369, v7);
    uint64_t v336 = v364;
    swift_bridgeObjectRelease(v7);
    if (v336 < v284) {
LABEL_344:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    unint64_t v7 = v366;
LABEL_304:
    v337 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v284, (uint64_t)v335, v336);
    _StringGuts.appendInPlace(_:isASCII:)(v337, v338, v369 < 0);
  }

  swift_bridgeObjectRelease_n(v7, 2LL);
LABEL_306:
  v339 = v372._object;
  unint64_t v340 = ((unint64_t)v372._object >> 56) & 0xF;
  if (v340 || (v372._countAndFlagsBits & ~(uint64_t)v372._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v372._object & 0x2000000000000000LL) == 0
      || (unint64_t v341 = specialized _SmallString.init(_:appending:)( v372._countAndFlagsBits,  (unint64_t)v372._object,  0x29uLL,  0xE100000000000000LL),  (v320 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, (uint64_t)v339, v320, v321);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
    }

    else
    {
      uint64_t v342 = v341;
      v343 = v339;
      swift_bridgeObjectRelease(0xE100000000000000LL);
      swift_bridgeObjectRelease((uint64_t)v372._object);
      v372._uint64_t countAndFlagsBits = v342;
      v372._unint64_t object = v343;
    }
  }

  else
  {
    v372._uint64_t countAndFlagsBits = 41LL;
    v372._unint64_t object = (void *)0xE100000000000000LL;
    swift_bridgeObjectRelease((uint64_t)v339);
  }

  return v372._countAndFlagsBits;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  unint64_t v33 = HIBYTE(a2) & 0xF;
  v139[0] = a1;
  v139[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v33) {
    goto LABEL_252;
  }
  if (a1 == 43)
  {
    uint64_t v8 = 1;
    uint64_t v88 = specialized Collection.subscript.getter(1LL, (uint64_t)v139, v33);
    unint64_t v92 = specialized UnsafeBufferPointer.init(rebasing:)(v88, v89, v90, v91);
    if (v93)
    {
      unint64_t v94 = (unsigned __int8 *)v92;
      int64x2_t v95 = a3 + 48;
      int8x16_t v96 = a3 + 55;
      int8x16_t v97 = a3 + 87;
      if (a3 > 10)
      {
        int64x2_t v95 = 58;
      }

      else
      {
        int8x16_t v97 = 97;
        int8x16_t v96 = 65;
      }

      if (v92)
      {
        int64x2_t v98 = v93;
        uint64_t v68 = 0LL;
        int64x2_t v99 = 0LL;
        int64x2_t v100 = a3 >> 63;
        while (1)
        {
          int8x16_t v128 = *v94;
          if (v128 < 0x30 || v128 >= v95)
          {
            if (v128 < 0x41 || v128 >= v96)
            {
              uint64_t result = 0LL;
              uint64_t v8 = 1;
              if (v128 < 0x61 || v128 >= v97) {
                goto LABEL_248;
              }
              int8x16_t v129 = -87;
            }

            else
            {
              int8x16_t v129 = -55;
            }
          }

          else
          {
            int8x16_t v129 = -48;
          }

          uint64_t result = 0LL;
          unint64_t v130 = !is_mul_ok(v99, a3);
          unint64_t v131 = !is_mul_ok(v68, v100);
          unsigned int v132 = __CFADD__(v99 * a3, v68 * v100);
          uint64_t v133 = (a3 * __PAIR128__(v99, v68)) >> 64;
          uint64_t v134 = __CFADD__(v99 * a3 + v68 * v100, (v68 * (unsigned __int128)(unint64_t)a3) >> 64);
          unint64_t v135 = a3 >= 0 || v99 == 0;
          uint64_t v8 = 1;
          if (!v135 || v130 || v131 || v132) {
            goto LABEL_248;
          }
          unsigned int v136 = v68 * a3;
          uint64_t v86 = __CFADD__(v136, (v128 + v129));
          uint64_t v68 = v136 + (v128 + v129);
          unint64_t v137 = v86;
          if (v133 == -1LL)
          {
            if (((v137 | v134) & 1) != 0)
            {
LABEL_244:
              uint64_t result = 0LL;
              uint64_t v8 = 1;
              goto LABEL_248;
            }

            int64x2_t v99 = -1LL;
          }

          else if (v137)
          {
            if (v134) {
              goto LABEL_244;
            }
            int64x2_t v99 = v133 + 1;
          }

          else
          {
            int64x2_t v99 = v133;
            if (v134) {
              goto LABEL_244;
            }
          }

          ++v94;
          if (!--v98)
          {
LABEL_245:
            uint64_t v8 = 0;
            uint64_t result = v68;
            goto LABEL_248;
          }
        }
      }

      goto LABEL_136;
    }

    goto LABEL_254;
  }

  if (a1 != 45)
  {
    int64x2_t v101 = 0LL;
    uint64_t v102 = 0LL;
    int8x16_t v103 = a3 + 48;
    unint64_t v104 = a3 + 55;
    int64x2_t v105 = a3 + 87;
    if (a3 > 10)
    {
      int8x16_t v103 = 58;
    }

    else
    {
      int64x2_t v105 = 97;
      unint64_t v104 = 65;
    }

    int8x16_t v106 = a3 >> 63;
    int8x16_t v107 = (unsigned __int8 *)v139;
    while (1)
    {
      uint8x8_t v108 = *v107;
      if (v108 < 0x30 || v108 >= v103)
      {
        if (v108 < 0x41 || v108 >= v104)
        {
          uint64_t result = 0LL;
          uint64_t v8 = 1;
          if (v108 < 0x61 || v108 >= v105) {
            goto LABEL_248;
          }
          uint16x8_t v109 = -87;
        }

        else
        {
          uint16x8_t v109 = -55;
        }
      }

      else
      {
        uint16x8_t v109 = -48;
      }

      uint64_t result = 0LL;
      uint32x4_t v110 = !is_mul_ok(v102, a3);
      uint64x2_t v111 = !is_mul_ok(v101, v106);
      uint64x2_t v112 = __CFADD__(v102 * a3, v101 * v106);
      uint64x2_t v113 = (a3 * __PAIR128__(v102, v101)) >> 64;
      uint32x4_t v114 = __CFADD__(v102 * a3 + v101 * v106, (v101 * (unsigned __int128)(unint64_t)a3) >> 64);
      uint64x2_t v115 = a3 >= 0 || v102 == 0;
      uint64_t v8 = 1;
      if (!v115 || v110 || v111 || v112) {
        goto LABEL_248;
      }
      int8x16_t v116 = v101 * a3;
      uint64_t v86 = __CFADD__(v116, (v108 + v109));
      int64x2_t v101 = v116 + (v108 + v109);
      uint16x8_t v117 = v86;
      if (v113 == -1LL)
      {
        if (((v117 | v114) & 1) != 0) {
          goto LABEL_244;
        }
        uint64_t v102 = -1LL;
      }

      else if (v117)
      {
        if (v114) {
          goto LABEL_244;
        }
        uint64_t v102 = v113 + 1;
      }

      else
      {
        uint64_t v102 = v113;
        if (v114) {
          goto LABEL_244;
        }
      }

      ++v107;
      if (!--v33)
      {
        uint64_t v8 = 0;
        uint64_t result = v101;
        goto LABEL_248;
      }
    }
  }

  uint64_t v8 = 1;
  unint64_t v34 = specialized Collection.subscript.getter(1LL, (uint64_t)v139, v33);
  uint64_t v38 = specialized UnsafeBufferPointer.init(rebasing:)(v34, v35, v36, v37);
  if (!v39) {
    goto LABEL_253;
  }
  unint64_t v40 = (unsigned __int8 *)v38;
  uint64_t v41 = a3 + 48;
  unint64_t v42 = a3 + 55;
  size_t v43 = a3 + 87;
  if (a3 > 10)
  {
    uint64_t v41 = 58;
  }

  else
  {
    size_t v43 = 97;
    unint64_t v42 = 65;
  }

  if (v38)
  {
    Swift::String::Index v44 = v39;
    uint64_t v45 = 0LL;
    Swift::String::Index v46 = 0LL;
    uint64_t v47 = a3 >> 63;
    while (1)
    {
      uint64_t v48 = *v40;
      if (v48 < 0x30 || v48 >= v41)
      {
        if (v48 < 0x41 || v48 >= v42)
        {
          uint64_t result = 0LL;
          uint64_t v8 = 1;
          if (v48 < 0x61 || v48 >= v43) {
            goto LABEL_248;
          }
          unint64_t v49 = -87;
        }

        else
        {
          unint64_t v49 = -55;
        }
      }

      else
      {
        unint64_t v49 = -48;
      }

      uint64_t result = 0LL;
      char v50 = !is_mul_ok(v46, a3);
      unint64_t v51 = !is_mul_ok(v45, v47);
      uint64_t v52 = __CFADD__(v46 * a3, v45 * v47);
      uint64_t v53 = (a3 * __PAIR128__(v46, v45)) >> 64;
      unint64_t v54 = __CFADD__(v46 * a3 + v45 * v47, (v45 * (unsigned __int128)(unint64_t)a3) >> 64);
      char v55 = a3 >= 0 || v46 == 0;
      uint64_t v8 = 1;
      if (!v55 || v50 || v51 || v52) {
        goto LABEL_248;
      }
      unsigned int v56 = v45 * a3;
      uint64_t result = v56 - (v48 + v49);
      if (v53) {
        goto LABEL_81;
      }
      if (v54)
      {
LABEL_85:
        uint64_t v8 = 1;
        uint64_t result = 0LL;
        goto LABEL_248;
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    goto LABEL_47;
  }

  if ((v81->i16[0] & 0x8080) == 0)
  {
    unsigned int v81 = (uint8x16_t *)((char *)v81 + 2);
    goto LABEL_43;
  }

                *(_BYTE *)a9 = 0;
                *(_BYTE *)(a9 + 16) = 0;
                goto LABEL_350;
              }

              unint64_t v12 = a5;
              if ((v137 & 2) != 0)
              {
                uint64_t v142 = (unint64_t)v40 + (v137 & 0xFFFFFFFFFFFFFFFCLL);
                if ((v137 & 1) != 0) {
                  uint64_t v142 = *(void *)v142;
                }
                unint64_t v141 = v142 | 1;
                goto LABEL_261;
              }

              if ((v137 & 0xFFFFFFFD) == 0) {
                goto LABEL_370;
              }
              unint64_t v141 = (uint64_t)v40 + (v137 & 0xFFFFFFFFFFFFFFFCLL);
              if ((v137 & 1) != 0)
              {
                unint64_t v141 = *(void *)v141;
                if (!v141)
                {
LABEL_370:
                  uint64_t v144 = "<null>";
LABEL_371:
                  swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v18 + *v18, a2);
                  unint64_t v207 = (int)v206;
                  uint64_t v208 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v18 + *v18, v206);
                  unint64_t v36 = operator new(0x20uLL);
                  *(void *)unint64_t v36 = "subject type %.*s does not conform to protocol %s";
                  v36[2] = v207;
                  *((void *)v36 + 2) = v208;
                  *((void *)v36 + 3) = v144;
                  *(void *)(a9 + 8) = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,char const*>(char const*,int,char const*,char const*)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,char const*>(char const*,int,char const*,char const*)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
                  goto LABEL_64;
                }
              }

              else if (!v141)
              {
                goto LABEL_370;
              }

uint64_t specialized CodingKey.description.getter(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  v363._unint64_t object = a2;
  if ((a4 & 1) != 0)
  {
    unint64_t v7 = 0xE300000000000000LL;
    unint64_t v5 = 7104878LL;
  }

  else
  {
    unint64_t v5 = _int64ToString(_:radix:uppercase:)( a3,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    unint64_t v7 = v6;
  }

  unint64_t v362 = v5;
  uint64_t v8 = specialized static String._createEmpty(withInitialCapacity:)(35LL);
  unint64_t v12 = v8;
  unint64_t v13 = v9;
  v366._uint64_t countAndFlagsBits = v8;
  v366._unint64_t object = (void *)v9;
  uint64_t v14 = HIBYTE(v9) & 0xF;
  int64_t v15 = v8 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0x2000000000000000LL) != 0) {
    uint64_t v16 = HIBYTE(v9) & 0xF;
  }
  else {
    uint64_t v16 = v8 & 0xFFFFFFFFFFFFLL;
  }
  if (!v16 && (v8 & ~v9 & 0x2000000000000000LL) == 0)
  {
    v366._uint64_t countAndFlagsBits = 0LL;
    v366._unint64_t object = (void *)0xE000000000000000LL;
LABEL_24:
    uint64_t v41 = v13;
LABEL_28:
    swift_bridgeObjectRelease(v41);
    goto LABEL_29;
  }

  if ((v9 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v10, v11);
    if ((v13 & 0x1000000000000000LL) != 0)
    {
      int64_t v15 = String.UTF8View._foreignCount()();
      if ((v12 & ~v13 & 0x2000000000000000LL) == 0) {
        goto LABEL_26;
      }
    }

    else if ((v12 & ~v13 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_26;
    }

    if (swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v17 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
      if ((v18 & 1) != 0) {
        goto LABEL_344;
      }
      if (v15 <= 15 && (v17 & 0x8000000000000000LL) != 0) {
        goto LABEL_16;
      }
      goto LABEL_27;
    }

LABEL_336:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v53 = 0LL;
  unint64_t v54 = &v46->u8[v47];
  if (!v46) {
    unint64_t v54 = 0LL;
  }
  char v50 = 1;
  for (i = v46; ; i = (uint8x16_t *)((char *)i + 3))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unsigned int v57 = i->u8[0];
          i = (uint8x16_t *)((char *)i + 1);
          unsigned int v56 = v57;
          if ((v56 & 0x80) != 0) {
            break;
          }
          ++v53;
        }

        if (v56 > 0xDF) {
          break;
        }
        char v50 = 0;
        i = (uint8x16_t *)((char *)i + 1);
        v53 += 2LL;
      }

      if (v56 != 224) {
        break;
      }
      if (!i) {
        goto LABEL_86;
      }
      uint64_t v58 = &i->u8[1];
      if ((i->i8[0] & 0xE0) != 0xA0) {
        goto LABEL_86;
      }
LABEL_64:
      if (v58 == v54 || (*v58 & 0xC0) != 0x80) {
        goto LABEL_86;
      }
      char v50 = 0;
      i = (uint8x16_t *)((char *)i + 2);
      v53 += 3LL;
    }

    if (v56 < 0xED)
    {
LABEL_56:
      uint64_t v58 = &i->u8[1];
      LOBYTE(v59) = i->i8[0];
LABEL_63:
      if ((v59 & 0xC0) != 0x80) {
        goto LABEL_86;
      }
      goto LABEL_64;
    }

    if (v56 == 237)
    {
      if (!i) {
        goto LABEL_86;
      }
      uint64_t v58 = &i->u8[1];
      unsigned int v59 = i->u8[0];
      if (v59 > 0x9F) {
        goto LABEL_86;
      }
      goto LABEL_63;
    }

    if (v56 < 0xF0) {
      goto LABEL_56;
    }
    if (v56 != 240) {
      break;
    }
    if (!i) {
      goto LABEL_86;
    }
    unint64_t v60 = &i->u8[1];
LABEL_81:
    char v50 = 0;
    v53 += 4LL;
  }

  if ((v56 + 15) < 3u)
  {
    unint64_t v60 = &i->u8[1];
    LOBYTE(v61) = i->i8[0];
    goto LABEL_80;
  }

  if (i)
  {
    if (i != (uint8x16_t *)v54)
    {
      unint64_t v60 = &i->u8[1];
      unsigned int v61 = i->u8[0];
      if (v61 <= 0x8F)
      {
LABEL_80:
        if ((v61 & 0xC0) != 0x80) {
          goto LABEL_86;
        }
        goto LABEL_81;
      }
    }
  }

    if ((v88 & 0x1000000000000000LL) != 0)
    {
      int8x16_t v106 = _StringGuts._foreignConvertedToSmall()(v106, v96);
      uint64_t v88 = v360;
    }

    else
    {
      if ((v106 & 0x1000000000000000LL) != 0)
      {
        Swift::String::Index v353 = (unsigned __int8 *)((v88 & 0xFFFFFFFFFFFFFFFLL) + 32);
        Swift::String::Index v354 = v106 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        Swift::String::Index v353 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v106, v96);
        Swift::String::Index v354 = v170;
      }

      swift_bridgeObjectRetain(v96, v170, v171, v172);
      closure #1 in _StringGuts._convertedToSmall()(v353, v354, &v388);
      swift_bridgeObjectRelease(v96);
      int8x16_t v106 = v388;
      uint64_t v88 = v389;
    }

    unint64_t v62 = (uint64_t)v386;
    unsigned int v59 = v387;
    uint64_t v89 = (unint64_t)v378;
    goto LABEL_170;
  }

  Swift::String v366 = (Swift::UInt64 *)v108;
  unint64_t v175 = v390;
  int8x16_t v96 = v391;
  unint64_t v176 = _StringGuts.nativeUnusedCapacity.getter(v390, v391);
  if ((v177 & 1) != 0)
  {
LABEL_350:
    uint64_t v359 = 258LL;
    goto LABEL_351;
  }

  if (v174 >= 16) {
    goto LABEL_127;
  }
  if ((v96 & 0x2000000000000000LL) != 0)
  {
    uint64_t v189 = 0;
    uint64_t v88 = v96;
    goto LABEL_169;
  }

  uint64_t v88 = v96;
  if (v176 < v173)
  {
LABEL_150:
    uint64_t v189 = 1;
    goto LABEL_169;
  }

            BOOL v75 = 0LL;
          }

          uint64_t v249 = 280;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChild( this,  v249,  (swift::Demangle::__runtime::Node *)v75,  (uint64_t)v75,  a5);
        case 's':
          unint64_t v239 = *((_DWORD *)this + 24);
          if (!v239) {
            goto LABEL_337;
          }
          uint64_t v240 = v239 - 1;
          char v241 = *((void *)this + 11);
          BOOL v75 = *(unsigned __int16 **)(v241 + 8LL * (v239 - 1));
          uint64_t v242 = v75[8];
          if (v242 == 232)
          {
            *((_DWORD *)this + 24) = v240;
          }

          else
          {
            if (v242 == 43)
            {
              *((_DWORD *)this + 24) = v240;
              else {
                *((_DWORD *)this + 24) = v243;
              }
              uint64_t v250 = 281;
              return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v250,  (swift::Demangle::__runtime::Node *)v78,  (swift::Demangle::__runtime::Node *)v75,  a5);
            }

LABEL_343:
    unint64_t v360 = 266LL;
    goto LABEL_345;
  }

LABEL_144:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v151, v149);
  swift_bridgeObjectRelease_n(v51, 4LL);
  if ((v51 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v51);
    _StringGuts._foreignAppendInPlace(_:)(v52, v51, 0LL, v144);
    swift_bridgeObjectRelease_n(v51, 2LL);
    unint64_t v7 = v361;
    goto LABEL_155;
  }

  if (v7)
  {
    swift_bridgeObjectRelease_n(v51, 2LL);
    uint64_t v364 = v52;
    unint64_t v365 = v51 & 0xFFFFFFFFFFFFFFLL;
    Swift::String::Index v155 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v51) & 0xF,  (uint64_t)&v364,  HIBYTE(v51) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v155, v156, (v51 & 0x4000000000000000LL) != 0);
    unint64_t v7 = v361;
    uint64_t v157 = v51;
    goto LABEL_154;
  }

  if ((v52 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v51);
    id v318 = (id)((v51 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v319 = v52 & 0xFFFFFFFFFFFFLL;
    unint64_t v7 = v361;
    uint64_t v320 = v52 & 0xFFFFFFFFFFFFLL;
    goto LABEL_288;
  }

  id v318 = _StringObject.sharedUTF8.getter(v52, v51);
  uint64_t v320 = v357;
  swift_bridgeObjectRelease(v51);
  if (v320 < (v52 & 0xFFFFFFFFFFFFLL)) {
    goto LABEL_342;
  }
  uint64_t v319 = v52 & 0xFFFFFFFFFFFFLL;
  unint64_t v7 = v361;
LABEL_288:
  v321 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v319, (uint64_t)v318, v320);
  _StringGuts.appendInPlace(_:isASCII:)(v321, v322, v52 < 0);
  swift_bridgeObjectRelease_n(v51, 2LL);
LABEL_155:
  Swift::String v183 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("(stringValue: ", 0xFuLL, 1);
  Swift::String::Index v184 = v366._object;
  unint64_t v185 = ((unint64_t)v366._object >> 56) & 0xF;
  if (!v185 && (v366._countAndFlagsBits & ~(uint64_t)v366._object & 0x2000000000000000LL) == 0)
  {
    Swift::String v366 = v183;
    swift_bridgeObjectRelease((uint64_t)v184);
    goto LABEL_168;
  }

  if (((uint64_t)v366._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v183._object & 0x2000000000000000LL) != 0)
    {
      unint64_t v187 = specialized _SmallString.init(_:appending:)( v366._countAndFlagsBits,  (unint64_t)v366._object,  v183._countAndFlagsBits,  (unint64_t)v183._object);
      if ((v181 & 1) != 0) {
        goto LABEL_166;
      }
      uint64_t v188 = v187;
      uint64_t v189 = v184;
      swift_bridgeObjectRelease((uint64_t)v183._object);
      swift_bridgeObjectRelease((uint64_t)v366._object);
      v366._uint64_t countAndFlagsBits = v188;
      v366._unint64_t object = v189;
      goto LABEL_168;
    }

              swift_bridgeObjectRelease(v15);
              swift_bridgeObjectRelease(v14);
              uint64x2_t v125 = 0xA000000000000000LL;
              if (!(v20 & 0x8080808080808080LL | v16 & 0x80808080808080LL)) {
                uint64x2_t v125 = 0xE000000000000000LL;
              }
              Swift::String v233 = v20;
              unint64_t v234 = v125 & 0xFF00000000000000LL | (v114 << 56) | v16 & 0xFFFFFFFFFFFFFFLL;
              goto LABEL_176;
            }

            goto LABEL_249;
          }
        }

        else
        {
          swift_bridgeObjectRetain_n(v14, 4LL, v23, v24);
          Swift::String::Index v28 = v22;
          if ((v16 & 0x1000000000000000LL) == 0) {
            goto LABEL_16;
          }
        }

        Swift::Int v198 = String.UTF8View._foreignCount()();
        unint64_t v30 = v198 + v28;
        if (!__OFADD__(v198, v28)) {
          goto LABEL_17;
        }
        goto LABEL_215;
      }

      if (v20)
      {
        uint64_t v89 = 0LL;
        uint64_t v90 = 0LL;
        unint64_t v91 = 8 * v20;
        unint64_t v92 = v234;
        do
        {
          unint64_t v93 = v17 + v90;
          unint64_t v94 = v90++ >= 8;
          if (v94) {
            int64x2_t v95 = v10;
          }
          else {
            int64x2_t v95 = v9;
          }
          int8x16_t v96 = (8 * v17 + v89) & 0x38;
          int8x16_t v97 = (-255LL << v96) - 1;
          int64x2_t v98 = (unint64_t)(v95 >> (v89 & 0x38)) << v96;
          int64x2_t v99 = v98 | v97 & v92;
          int64x2_t v100 = v98 | v97 & v15;
          if (v93 < 8) {
            int64_t v15 = v100;
          }
          else {
            unint64_t v92 = v99;
          }
          v89 += 8LL;
        }

        while (v91 != v89);
        goto LABEL_172;
      }

        uint64_t v10 = 0LL;
        uint64x2_t v111 = (_BYTE *)(v16 + a1);
        uint64_t v80 = 1;
        uint64x2_t v112 = (_BYTE *)v16;
        uint64x2_t v113 = (_BYTE *)v16;
        while (1)
        {
          int8x16_t v116 = (char)*v113++;
          uint64x2_t v115 = v116;
          if (v116 < 0) {
            break;
          }
          uint32x4_t v114 = 1LL;
LABEL_146:
          v10 += v114;
          uint64x2_t v112 = v113;
          if (v113 == v111)
          {
            if (a1 > 15) {
              goto LABEL_111;
            }
            goto LABEL_267;
          }
        }

        if (v115 <= 0xDFu)
        {
          if (v113 == v111 || (*v113 & 0xC0) != 0x80) {
            goto LABEL_183;
          }
          uint64_t v80 = 0;
          uint64x2_t v113 = v112 + 2;
          uint32x4_t v114 = 2LL;
          goto LABEL_146;
        }

        if (v115 == 224)
        {
          if (v113 == v111 || (v112[1] & 0xE0) != 0xA0) {
            goto LABEL_183;
          }
          goto LABEL_164;
        }

        if (v115 <= 0xECu)
        {
LABEL_158:
          if (v113 == v111) {
            goto LABEL_183;
          }
          LOBYTE(v117) = v112[1];
LABEL_163:
          if ((v117 & 0xC0) != 0x80) {
            goto LABEL_183;
          }
LABEL_164:
          if (v112 + 2 == v111 || (v112[2] & 0xC0) != 0x80) {
            goto LABEL_183;
          }
          uint64_t v80 = 0;
          uint64x2_t v113 = v112 + 3;
          uint32x4_t v114 = 3LL;
          goto LABEL_146;
        }

        if (v115 == 237)
        {
          if (v113 == v111) {
            goto LABEL_183;
          }
          uint16x8_t v117 = v112[1];
          if (v117 > 0x9F) {
            goto LABEL_183;
          }
          goto LABEL_163;
        }

        if (v115 <= 0xEFu) {
          goto LABEL_158;
        }
        if (v115 == 240)
        {
          goto LABEL_178;
        }

        if ((v115 + 15) <= 2u)
        {
          if (v113 == v111) {
            goto LABEL_183;
          }
          LOBYTE(v118) = v112[1];
LABEL_177:
          if ((v118 & 0xC0) != 0x80) {
            goto LABEL_183;
          }
LABEL_178:
          if (v112 + 2 == v111 || (v112[2] & 0xC0) != 0x80 || v112 + 3 == v111 || (v112[3] & 0xC0) != 0x80) {
            goto LABEL_183;
          }
          uint64_t v80 = 0;
          uint64x2_t v113 = v112 + 4;
          uint32x4_t v114 = 4LL;
          goto LABEL_146;
        }

        if (v113 != v111)
        {
          int8x16_t v118 = v112[1];
          if (v118 <= 0x8F) {
            goto LABEL_177;
          }
        }

        unint64_t v21 = 0;
        goto LABEL_118;
      }
    }

        unint64_t v21 = 0;
        goto LABEL_118;
      }
    }

        uint64_t result = 0LL;
        goto LABEL_118;
      }
    }

        uint64_t result = 0LL;
        goto LABEL_118;
      }
    }

        if (v93 == v249)
        {
          unint64_t v267 = &v264;
          (*(void (**)(void *, uint64_t *))(v249[0] + 24LL))(v249, &v264);
        }

        else
        {
          unint64_t v267 = (uint64_t *)(*(uint64_t (**)(void *))(*v93 + 16LL))(v93);
        }

  unint64_t v62 = *((unsigned __int8 *)v11 + 18);
  if (v62 != 2)
  {
    if (v62 != 5 || v11[2] < 2)
    {
LABEL_154:
      if (v155 == v154)
      {
        v151.__r_.__value_.__s.__size_ = 9;
        strcpy((char *)&v151, "<unknown>");
      }

      else if (*((char *)v154 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v151, *(const std::string::value_type **)v154, *((void *)v154 + 1));
      }

      else
      {
        uint64_t v65 = *(_OWORD *)v154;
        v151.__r_.__value_.__l.__cap_ = *((void *)v154 + 2);
        *(_OWORD *)&v151.__r_.__value_.__l.__data_ = v65;
      }

      if (v161 >= 0) {
        uint64_t v66 = (const std::string::value_type *)&v159;
      }
      else {
        uint64_t v66 = v159;
      }
      if (v161 >= 0) {
        uint64_t v67 = v161;
      }
      else {
        uint64_t v67 = v160;
      }
      uint64_t v68 = std::string::insert(&v151, 0LL, v66, v67);
      cap = v68->__r_.__value_.__l.__cap_;
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__l.__cap_ = cap;
      v68->__r_.__value_.__l.__size_ = 0LL;
      v68->__r_.__value_.__l.__cap_ = 0LL;
      v68->__r_.__value_.__r.__words[0] = 0LL;
      size = __p.__r_.__value_.__s.__size_;
      uint64_t v71 = __p.__r_.__value_.__l.__size_;
      uint64_t v72 = (__p.__r_.__value_.__s.__size_ & 0x80u) != 0;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      goto LABEL_168;
    }

    char v11 = *(unsigned int **)v11;
  }

  uint64_t v63 = (uint64_t *)*((void *)v11 + 1);
  if (!v63) {
    goto LABEL_154;
  }
  if (*((_WORD *)v63 + 8) != 290) {
    goto LABEL_175;
  }
  uint64_t v64 = *((unsigned __int8 *)v63 + 18);
  switch((_DWORD)v64)
  {
    case 1:
LABEL_200:
      uint64_t v85 = 0LL;
      uint64_t v86 = 0LL;
      uint64_t v87 = &v154;
      while (1)
      {
        uint64_t v88 = *((unsigned __int8 *)v63 + 18);
        uint64_t v89 = v88 - 1;
        if ((_DWORD)v88 == 1) {
          goto LABEL_206;
        }
        if ((_DWORD)v88 != 5) {
          break;
        }
        if (*((unsigned int *)v63 + 2) <= v86)
        {
LABEL_211:
          unint64_t v91 = 0LL;
          goto LABEL_212;
        }

          uint64_t v86 = *(unsigned int *)(v56 + 8);
          if ((v86 & 0x80000000) != 0) {
            goto LABEL_94;
          }
          uint64_t v133 = v38;
          v52 += v5[1595][2 * v86 + 1];
          uint64_t v87 = v5[1593];
          uint64_t v88 = *((_DWORD *)v5 + 3184);
          uint64_t v89 = *((unsigned int *)v5 + 3185);
          unint64_t v54 = (char *)v5[1591];
          if (v126 < v123 - 2)
          {
            uint64_t v90 = v86 + 97;
            if (v88 >= v89)
            {
              unint64_t v91 = (char *)v87[1];
              if (&v54[v89] != v91)
              {
                unint64_t v92 = v87[2];
                goto LABEL_153;
              }

              int64x2_t v95 = (unint64_t)&v54[v89 + 1];
              unint64_t v92 = v87[2];
              if (v95 <= v92)
              {
                v87[1] = v95;
                LODWORD(v96) = 1;
                unint64_t v91 = v54;
              }

              else
              {
LABEL_153:
                else {
                  int8x16_t v96 = (2 * v89);
                }
                int8x16_t v97 = v96 + v89;
                if (!v91 || (unint64_t)&v91[v97] > v92)
                {
                  int64x2_t v98 = 2LL * v87[4];
                  if (v98 <= v97 + 1) {
                    int64x2_t v98 = v97 + 1;
                  }
                  v87[4] = v98;
                  int8x16_t v120 = v98 + 8;
                  int64x2_t v99 = malloc(v98 + 8);
                  *int64x2_t v99 = v87[3];
                  unint64_t v91 = (char *)(v99 + 1);
                  v87[2] = (char *)v99 + v120;
                  v87[3] = v99;
                }

                v87[1] = &v91[v97];
                if ((_DWORD)v89)
                {
                  memcpy(v91, v5[1591], v89);
                  LODWORD(v89) = *((_DWORD *)v5 + 3185);
                  uint64_t v88 = *((_DWORD *)v5 + 3184);
                }

                *(void *)int8x16_t v128 = v91;
              }

              uint64_t v53 = v89 + v96;
LABEL_92:
              *((_DWORD *)v5 + 3185) = v53;
              unint64_t v54 = v91;
            }

LABEL_163:
    uint64_t v186 = v183._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_167;
  }

    if (v127 > 15) {
      goto LABEL_164;
    }
LABEL_140:
    unint64_t v131 = v3;
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
    swift_bridgeObjectRetain(v12, v132, v133, v134);
    unint64_t v135 = _StringGuts._convertedToSmall()(v2, v12);
    unint64_t v137 = v136;
    swift_bridgeObjectRelease(v12);
    v138._Swift::UInt64 rawBits = 1LL;
    v139._Swift::UInt64 rawBits = 1LL;
    v140._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v138, v139, 0LL, 0xE000000000000000LL);
    if (v140._rawBits < 0x10000) {
      v140._rawBits |= 3;
    }
    uint64_t v142 = specialized String.init(_:)(v140, v141, 0LL, 0xE000000000000000LL);
    uint64_t v144 = v143;
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v145 = _StringGuts._convertedToSmall()(v142, v144);
    uint64_t v147 = v146;
    swift_bridgeObjectRelease(v144);
    unint64_t v148 = specialized _SmallString.init(_:appending:)(v135, v137, v145, v147);
    if ((v150 & 1) != 0) {
      goto LABEL_254;
    }
    unint64_t v2 = v148;
    int64_t v151 = v149;
    swift_bridgeObjectRelease(v12);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    Swift::Int v253 = v2;
    unint64_t v3 = v131;
LABEL_165:
    uint64_t v161 = specialized static String._createEmpty(withInitialCapacity:)(6LL);
    unint64_t v165 = v162;
    Swift::Int v253 = v161;
    int64_t v254 = v162;
    Swift::String::Index v166 = HIBYTE(v162) & 0xF;
    if ((v162 & 0x2000000000000000LL) == 0) {
      Swift::String::Index v166 = v161 & 0xFFFFFFFFFFFFLL;
    }
    if (v166 || (v161 & ~v162 & 0x2000000000000000LL) != 0)
    {
      if ((v162 & 0x2000000000000000LL) == 0
        || (Swift::String::Index v167 = specialized _SmallString.init(_:appending:)(v161, v162, 0x3C2E2EuLL, 0xE300000000000000LL),
            (v163 & 1) != 0))
      {
        swift_bridgeObjectRetain(0xE300000000000000LL, v162, v163, v164);
        _StringGuts.append(_:)(3943982LL, 0xE300000000000000LL, 0LL, 3LL);
        swift_bridgeObjectRelease_n(0xE300000000000000LL, 2LL);
        size_t v82 = v253;
        unint64_t v12 = v254;
        goto LABEL_175;
      }

      size_t v82 = v167;
      unint64_t v12 = v162;
      swift_bridgeObjectRelease(v165);
      swift_bridgeObjectRelease(0xE300000000000000LL);
    }

    else
    {
      size_t v82 = 3943982LL;
      swift_bridgeObjectRelease(v162);
      unint64_t v12 = 0xE300000000000000LL;
    }

    Swift::Int v253 = v82;
    int64_t v254 = v12;
LABEL_175:
    v249(v7, v3 + *(int *)(v250 + 36), v4);
    *(void *)&unint64_t v252 = 0LL;
    *((void *)&v252 + 1) = 0xE000000000000000LL;
    _debugPrint_unlocked<A, B>(_:_:)( v7,  (uint64_t)&v252,  (swift *)v4,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
    v248(v7, v4);
    unint64_t v170 = *((void *)&v252 + 1);
    unint64_t v171 = v252;
    unint64_t v172 = HIBYTE(v12) & 0xF;
    if ((v12 & 0x2000000000000000LL) != 0) {
      unint64_t v173 = HIBYTE(v12) & 0xF;
    }
    else {
      unint64_t v173 = v82 & 0xFFFFFFFFFFFFLL;
    }
    if (!v173 && (v82 & ~v12 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v12);
      Swift::Int v253 = v171;
      int64_t v254 = v170;
      goto LABEL_225;
    }

    uint64_t v251 = v151;
    unint64_t v13 = *((void *)&v252 + 1) & 0x2000000000000000LL;
    uint64_t v77 = HIBYTE(*((void *)&v252 + 1)) & 0xFLL;
    uint64_t v247 = v2;
    if ((v12 & 0x2000000000000000LL) != 0 && v13)
    {
      unint64_t v174 = v172 + v77;
      if (v172 + v77 <= 0xF)
      {
        if (v77)
        {
          unint64_t v206 = 0;
          unint64_t v207 = 0LL;
          uint64_t v208 = v12;
          do
          {
            uint64_t v209 = v172 + v207;
            uint64_t v210 = v207 + 1;
            if (v207 >= 8) {
              unint64_t v211 = *((void *)&v252 + 1);
            }
            else {
              unint64_t v211 = v252;
            }
            unint64_t v212 = v211 >> (v206 & 0x38);
            unint64_t v213 = (8 * v172 + v206) & 0x38;
            Swift::String::Index v214 = (-255LL << v213) - 1;
            Swift::String::Index v215 = (unint64_t)v212 << v213;
            Swift::String::Index v216 = v215 | v214 & v208;
            Swift::String::Index v217 = v215 | v214 & v82;
            if (v209 < 8) {
              size_t v82 = v217;
            }
            else {
              uint64_t v208 = v216;
            }
            v206 += 8;
            unint64_t v207 = v210;
          }

          while (v77 != v210);
        }

        else
        {
          uint64_t v208 = v12;
        }

        swift_bridgeObjectRelease(v12);
        swift_bridgeObjectRelease(v170);
        unint64_t v222 = 0xA000000000000000LL;
        if (!(v82 & 0x8080808080808080LL | v208 & 0x80808080808080LL)) {
          unint64_t v222 = 0xE000000000000000LL;
        }
        Swift::Int v253 = v82;
        int64_t v254 = v222 & 0xFF00000000000000LL | (v174 << 56) | v208 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_224;
      }

      unint64_t v13 = 1LL;
    }

    uint64_t v84 = v252 & 0xFFFFFFFFFFFFLL;
    Swift::String::Index v46 = v13 ? HIBYTE(*((void *)&v252 + 1)) & 0xFLL : v252 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(*((uint64_t *)&v252 + 1), 2LL, v168, v169);
    if ((v170 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v170, 4LL, v175, v176);
    id v4 = v46;
    if ((v12 & 0x1000000000000000LL) != 0) {
      goto LABEL_238;
    }
LABEL_189:
    unint64_t v21 = __OFADD__(v173, v4);
    unint64_t v7 = v173 + v4;
    if (!v21) {
      goto LABEL_190;
    }
LABEL_240:
    __break(1u);
LABEL_241:
    if ((v84 & 0x1000000000000000LL) != 0)
    {
      size_t v82 = _StringGuts._foreignConvertedToSmall()(v82, v84);
      uint64_t v242 = v241;
      swift_bridgeObjectRelease(v84);
      uint64_t v84 = v242;
    }

    else
    {
      if ((v82 & 0x1000000000000000LL) != 0)
      {
        unint64_t v235 = (unsigned __int8 *)((v84 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v236 = v82 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v235 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v82, v84);
      }

      closure #1 in _StringGuts._convertedToSmall()(v235, v236, &v252);
      swift_bridgeObjectRelease(v84);
      uint64_t v84 = *((void *)&v252 + 1);
      size_t v82 = v252;
    }

          uint64_t v8 = 0LL;
          *__dst = 0;
          return v8;
        }

        if ((v5 & 0x8000000000000000LL) == 0)
        {
          if (a3 < 4) {
            goto LABEL_163;
          }
          Swift::String::Index v25 = 6712937;
          goto LABEL_27;
        }

        if (a3 < 5) {
          goto LABEL_163;
        }
        __dst[4] = 0;
        int64x2_t v95 = 1718511917;
        goto LABEL_126;
      }

      uint64_t v10 = v6 - 1022;
      unint64_t v9 = (v7 << 11) | 0x8000000000000000LL;
    }

    else
    {
      if (!v7)
      {
        if ((v5 & 0x8000000000000000LL) == 0)
        {
          if (a3 < 4) {
            goto LABEL_163;
          }
          Swift::String::Index v25 = 3157552;
LABEL_27:
          *(_DWORD *)__dst = v25;
          return 3LL;
        }

        if (a3 < 5) {
          goto LABEL_163;
        }
        __dst[4] = 0;
        int64x2_t v95 = 808333357;
LABEL_126:
        *(_DWORD *)__dst = v95;
        return 4LL;
      }

      unint64_t v9 = v7 << 11;
      uint64_t v10 = -1021;
    }

    if (v7) {
      char v11 = -1024LL;
    }
    else {
      char v11 = -512LL;
    }
    unint64_t v12 = (unint64_t)(20201781LL * v10) >> 26;
    unint64_t v13 = 6 - v12;
    if ((6 - v12) > 0x37)
    {
      char v18 = (406 - (int)v12) / 0x1Cu;
      int64_t v15 = powersOf10_Binary64[2 * v18];
      uint64_t v14 = powersOf10_Binary64[2 * v18 + 1];
      uint64_t v19 = (406 - (int)v12) % 0x1Cu;
      unint64_t v13 = ((unint64_t)(55732705LL * (v13 - v19)) >> 24) + 1;
      if (v19)
      {
        uint64_t v20 = powersOf10_Exact128[2 * v19 + 1];
        v13 += ((unint64_t)(55732705LL * v19) >> 24) + 1;
        unint64_t v21 = (v20 * (unsigned __int128)v14) >> 64;
        unint64_t v22 = v20 * v14;
        unint64_t v23 = (v20 * (unsigned __int128)v15) >> 64;
        unint64_t v24 = __CFADD__(v23, v22);
        int64_t v15 = v23 + v22;
        if (v24) {
          uint64_t v14 = v21 + 1;
        }
        else {
          uint64_t v14 = v21;
        }
        unint64_t v24 = __CFADD__(v15, 2LL);
        uint64_t v16 = v15 + 2;
      }

      else
      {
        unint64_t v24 = __CFADD__(v15, 1LL);
        uint64_t v16 = v15 + 1;
      }

      if (v24) {
        unint64_t v17 = v14 + 1;
      }
      else {
        unint64_t v17 = v14;
      }
    }

    else
    {
      uint64_t v14 = powersOf10_Exact128[(2 * v13) | 1u];
      int64_t v15 = powersOf10_Exact128[2 * v13];
      LOBYTE(v13) = ((55732705 * v13) >> 24) + 1;
      uint64_t v16 = v15;
      unint64_t v17 = v14;
    }

    Swift::String::Index v26 = v9 + 1024;
    Swift::String::Index v27 = v9 + v11;
    Swift::String::Index v28 = v13 + v10;
    if ((v5 & 1) != 0)
    {
      unint64_t v49 = (v14 * (unsigned __int128)v26) >> 64;
      char v50 = v14 * v26;
      unint64_t v51 = (v15 * (unsigned __int128)v26) >> 64;
      unint64_t v24 = __CFADD__(v51, v50);
      uint64_t v52 = v51 + v50;
      if (v24) {
        uint64_t v53 = v49 + 1;
      }
      else {
        uint64_t v53 = v49;
      }
      unint64_t v54 = 32 - v28;
      char v55 = ((2 * v53) << ~v54) | (v52 >> v54);
      unsigned int v56 = v53 >> v54;
      unsigned int v57 = (v17 * (unsigned __int128)v27) >> 64;
      uint64_t v58 = v17 * v27;
      if (v16 * v27) {
        unsigned int v59 = ((v16 * (unsigned __int128)v27) >> 64) + 1;
      }
      else {
        unsigned int v59 = (v16 * (unsigned __int128)v27) >> 64;
      }
      unint64_t v24 = __CFADD__(v59, v58);
      unint64_t v60 = v59 + v58;
      if (v24) {
        ++v57;
      }
      unsigned int v61 = ~(-1LL << v54);
      unint64_t v24 = __CFADD__(v60, v61);
      unint64_t v62 = v60 + v61;
      if (v24) {
        ++v57;
      }
      uint64_t v63 = (v54 & 0x40) == 0LL;
      if ((v54 & 0x40) != 0) {
        size_t v43 = v56;
      }
      else {
        size_t v43 = v55;
      }
      if ((v54 & 0x40) != 0) {
        Swift::String::Index v44 = 0LL;
      }
      else {
        Swift::String::Index v44 = v56;
      }
      uint64_t v64 = v57 >> v54;
      uint64_t v47 = ((2 * v57) << ~v54) | (v62 >> v54);
      if (v63)
      {
        uint64_t v48 = v64;
      }

      else
      {
        uint64_t v47 = v64;
        uint64_t v48 = 0LL;
      }
    }

    else
    {
      unint64_t v29 = (v17 * (unsigned __int128)v26) >> 64;
      unint64_t v30 = v17 * v26;
      if (v16 * v26) {
        unint64_t v31 = ((v16 * (unsigned __int128)v26) >> 64) + 1;
      }
      else {
        unint64_t v31 = (v16 * (unsigned __int128)v26) >> 64;
      }
      unint64_t v24 = __CFADD__(v31, v30);
      unint64_t v32 = v31 + v30;
      if (v24) {
        ++v29;
      }
      unint64_t v33 = 32 - v28;
      unint64_t v34 = ~(-1LL << v33);
      unint64_t v24 = __CFADD__(v32, v34);
      unint64_t v35 = v32 + v34;
      if (v24) {
        ++v29;
      }
      unint64_t v36 = v29 >> v33;
      char v37 = ((2 * v29) << ~v33) | (v35 >> v33);
      uint64_t v38 = (v14 * (unsigned __int128)v27) >> 64;
      uint64_t v39 = v14 * v27;
      unint64_t v40 = (v15 * (unsigned __int128)v27) >> 64;
      unint64_t v24 = __CFADD__(v40, v39);
      uint64_t v41 = v40 + v39;
      if (v24) {
        ++v38;
      }
      unint64_t v42 = (v33 & 0x40) == 0LL;
      if ((v33 & 0x40) != 0) {
        size_t v43 = v36;
      }
      else {
        size_t v43 = v37;
      }
      if ((v33 & 0x40) != 0) {
        Swift::String::Index v44 = 0LL;
      }
      else {
        Swift::String::Index v44 = v36;
      }
      uint64_t v45 = ((2 * v38) << ~v33) | (v41 >> v33);
      Swift::String::Index v46 = v38 >> v33;
      if ((v33 & 0x40) != 0) {
        uint64_t v47 = v38 >> v33;
      }
      else {
        uint64_t v47 = v45;
      }
      if (v42) {
        uint64_t v48 = v46;
      }
      else {
        uint64_t v48 = 0LL;
      }
    }

    if (v44 > 0xF423FFFFFFFFFLL)
    {
      uint64_t v65 = v44;
    }

    else
    {
      do
      {
        LODWORD(v12) = v12 - 1;
        uint64_t v48 = (__PAIR128__(v48, v47) * 0xA) >> 64;
        v47 *= 10LL;
        uint64_t v65 = (__PAIR128__(v44, v43) * 0xA) >> 64;
        v43 *= 10LL;
        uint64_t v66 = v44 >> 37;
        Swift::String::Index v44 = v65;
      }

      while (v66 < 0xC35);
    }

    uint64_t v68 = (__PAIR128__(v65, v43) - __PAIR128__(v48, v47)) >> 64;
    uint64_t v67 = v43 - v47;
    uint64_t v69 = __dst;
    if (v5 < 0)
    {
      *__dst = 45;
      uint64_t v69 = __dst + 1;
    }

    uint64_t v70 = HIDWORD(v65);
    uint64_t v71 = v65;
    if (__PAIR128__(v68, v67) >= __PAIR128__(v65, v43))
    {
      if (v47) {
        unsigned int v81 = v48 + 1;
      }
      else {
        unsigned int v81 = v48;
      }
      size_t v82 = (v65 + 2 * v81) / 3;
      if (v7) {
        size_t v82 = (v81 + v65) >> 1;
      }
      uint64_t v83 = HIDWORD(v81);
      if ((_DWORD)v81) {
        LODWORD(v83) = HIDWORD(v81) + 1;
      }
      uint64_t v84 = (v43 | v65) == 0;
      uint64_t v85 = (5 * v82) >> 31;
      uint64_t v86 = 9LL;
      uint64_t v87 = HIDWORD(v82);
      while (1)
      {
        uint64_t v88 = v85 % 0xA;
        LODWORD(v70) = v70 / 0xA;
        LODWORD(v83) = ((int)v83 + 9) / 0xAu;
        uint64_t v84 = v84 & (v88 == 0);
        uint64_t v85 = v87;
        LODWORD(v87) = v87 / 0xA;
        --v86;
      }

      if (v88 > 5 || (v88 == 5 ? (uint64_t v89 = v84 == 0) : (uint64_t v89 = 0), v89))
      {
        LODWORD(v87) = v87 + 1;
      }

      else if (v88 == 5 && v84 != 0)
      {
        LODWORD(v87) = (v87 + 1) & 0xFFFFFFFE;
      }

      if (v69 > &__dst[a3 - v86]) {
        goto LABEL_163;
      }
      unint64_t v91 = v86 - 1;
      if ((int)v86 - 1 > 1)
      {
        unint64_t v92 = v86 + 1;
        do
        {
          unint64_t v93 = v87;
          LODWORD(v87) = v87 / 0x64;
          *(_WORD *)&v69[v92 - 4] = *(_WORD *)&asciiDigitTable[2 * (v93 - 100 * v87)];
          v92 -= 2;
        }

        while (v92 > 3);
        unint64_t v91 = v92 - 2;
      }

      if (v91 == 1) {
        *uint64_t v69 = v87 + 48;
      }
      uint64_t v73 = &v69[v86 - 1];
    }

    else
    {
      uint64_t v72 = &__dst[a3 - 9];
      if (v69 > v72) {
        goto LABEL_163;
      }
      *((_WORD *)v69 + 3) = *(_WORD *)&asciiDigitTable[2 * (v70 % 0x2710 % 0x64)];
      *((_WORD *)v69 + 2) = *(_WORD *)&asciiDigitTable[2 * (v70 % 0x2710 / 0x64)];
      *((_WORD *)v69 + 1) = *(_WORD *)&asciiDigitTable[2
                                                     * (v70 / 0x2710
                                                                    - 100
                                                                    * ((42949673
                                                                      * (unint64_t)(v70 / 0x2710)) >> 32))];
      *(_WORD *)uint64_t v69 = *(_WORD *)&asciiDigitTable[(v70 / 0x7A120uLL) & 0x3FFE];
      uint64_t v73 = v69 + 8;
      uint64_t v74 = (__PAIR128__(v68, v67) * 0x5F5E100) >> 64;
      BOOL v75 = (__PAIR128__(v71, v43) * 0x5F5E100) >> 64;
      if (__PAIR128__(v68, v67) * 0x5F5E100 < __PAIR128__(v75, 100000000 * v43))
      {
        if (v73 > v72) {
          goto LABEL_163;
        }
        uint64_t v76 = HIDWORD(v75) % 0x2710;
        *((_WORD *)v69 + 7) = *(_WORD *)&asciiDigitTable[2 * (v76 % 0x64u)];
        *((_WORD *)v69 + 6) = *(_WORD *)&asciiDigitTable[2 * (v76 / 0x64u)];
        *((_WORD *)v69 + 5) = *(_WORD *)&asciiDigitTable[2 * ((unsigned __int16)(HIDWORD(v75) / 0x2710) % 0x64u)];
        uint64_t v73 = v69 + 16;
        *((_WORD *)v69 + 4) = *(_WORD *)&asciiDigitTable[2 * (HIDWORD(v75) / 0xF4240)];
        v43 *= 100000000LL;
        uint64_t v71 = v75;
        v67 *= 100000000LL;
        uint64_t v68 = v74;
      }

      if (__PAIR128__(v68, v67) < __PAIR128__(v71, v43))
      {
        while (v73 <= &__dst[a3 - 2])
        {
          uint64_t v68 = (__PAIR128__(v68, v67) * 0xA) >> 64;
          v67 *= 10LL;
          uint64_t v71 = (__PAIR128__(v71, v43) * 0xA) >> 64;
          v43 *= 10LL;
          uint64_t v77 = HIDWORD(v71);
          uint64_t v71 = v71;
          *v73++ = v77 + 48;
          if (__PAIR128__(v68, v67) >= __PAIR128__(v71, v43))
          {
            *((void *)&v79 + 1) = v68;
            *(void *)&uint64_t v79 = v67;
            uint64_t v78 = v79 >> 36;
            *((void *)&v79 + 1) = v71;
            *(void *)&uint64_t v79 = v43;
            uint64_t v80 = v79 >> 36;
            goto LABEL_128;
          }
        }

        goto LABEL_163;
      }

      *((void *)&v96 + 1) = v71;
      *(void *)&int8x16_t v96 = v43;
      uint64_t v80 = v96 >> 36;
      *((void *)&v96 + 1) = v68;
      *(void *)&int8x16_t v96 = v67;
      uint64_t v78 = v96 >> 36;
LABEL_128:
      if (v80 + 0x1000000000000000LL <= v78)
      {
        int8x16_t v97 = v78 >> 1;
        int64x2_t v98 = v78 - v78 / 3;
        if (!v7) {
          int8x16_t v97 = v98;
        }
        int64x2_t v99 = v97 - v80;
        if ((v99 & 0xFFFFFFFFFFFFFFFLL) == 0x800000000000000LL) {
          int64x2_t v100 = (*(v73 - 1) - (v99 >> 60)) & 0xFE;
        }
        else {
          int64x2_t v100 = *(v73 - 1) - ((v99 + 0x800000000000000LL) >> 60);
        }
        *(v73 - 1) = v100;
      }
    }

    int64x2_t v101 = v10 == 54;
    if (!v7) {
      int64x2_t v101 = 0;
    }
    uint64_t v102 = v73 - v69 - 1;
    if (v10 > 54 || v101 || (int)v12 <= -5)
    {
      *uint64_t v69 = v69[1];
      else {
        v69[1] = 46;
      }
      int64x2_t v105 = &__dst[a3 - 5];
      if (v73 > v105) {
        goto LABEL_163;
      }
      *uint64_t v73 = 101;
      if ((v12 & 0x80000000) == 0LL) {
        int8x16_t v106 = 43;
      }
      else {
        int8x16_t v106 = 45;
      }
      if ((v12 & 0x80000000) == 0LL) {
        int8x16_t v107 = v12;
      }
      else {
        int8x16_t v107 = -(int)v12;
      }
      v73[1] = v106;
      uint8x8_t v108 = (unint64_t)(v73 + 2);
      if (v107 < 0x64)
      {
        uint16x8_t v109 = (__int16 *)(v73 + 2);
      }

      else
      {
        if (v107 < 0x3E8)
        {
          v73[2] = (unsigned __int16)v107 / 0x64u + 48;
          uint16x8_t v109 = (__int16 *)(v73 + 3);
        }

        else
        {
          *((_WORD *)v73 + 1) = *(_WORD *)&asciiDigitTable[(v107 / 0x32uLL) & 0x7FFFFFE];
          uint16x8_t v109 = (__int16 *)(v73 + 4);
        }

        v107 %= 0x64u;
      }

      uint32x4_t v110 = *(_WORD *)&asciiDigitTable[2 * v107];
    }

    else
    {
      if ((v12 & 0x80000000) != 0)
      {
        memmove(&v69[-(int)v12], v69, v73 - v69);
        memset(v69, 48, -(int)v12);
        v69[1] = 46;
        v73 += -(int)v12;
LABEL_169:
        *uint64_t v73 = 0;
        return (int)v73 - (int)__dst;
      }

      int8x16_t v103 = v12 + 1LL;
      unint64_t v104 = v103 - v102;
      if ((int)v103 < (int)v102)
      {
        memmove(v69, v69 + 1, v12 + 1LL);
        v69[v103] = 46;
        goto LABEL_169;
      }

      memmove(v69, v69 + 1, v102);
      memset(v73 - 1, 48, v104);
      uint16x8_t v109 = (__int16 *)&v73[v104 - 1];
      uint32x4_t v110 = 12334;
    }

    *uint16x8_t v109 = v110;
    uint64_t v73 = (char *)(v109 + 1);
    goto LABEL_169;
  }

  return 0LL;
}

LABEL_166:
  uint64_t v186 = ((unint64_t)v183._object >> 56) & 0xF;
LABEL_167:
  swift_bridgeObjectRetain((unint64_t)v183._object, (uint64_t)v184, v181, v182);
  _StringGuts.append(_:)(v183._countAndFlagsBits, (unint64_t)v183._object, 0LL, v186);
  swift_bridgeObjectRelease_n((uint64_t)v183._object, 2LL);
LABEL_168:
  uint64_t v193 = v366._countAndFlagsBits;
  unint64_t v194 = (unint64_t)v366._object;
  unint64_t v195 = ((unint64_t)v366._object >> 56) & 0xF;
  unint64_t v196 = v366._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v196 && (v366._countAndFlagsBits & ~(uint64_t)v366._object & 0x2000000000000000LL) == 0)
  {
    Swift::String v366 = v363;
    swift_bridgeObjectRetain((unint64_t)v363._object, v190, v191, v192);
LABEL_203:
    swift_bridgeObjectRelease(v194);
    goto LABEL_204;
  }

  int64_t v151 = (uint64_t)v363._object & 0x2000000000000000LL;
  unint64_t v51 = ((unint64_t)v363._object >> 56) & 0xF;
  unint64_t v197 = v195 + v51;
  if (v195 + v51 <= 0xF)
  {
    if (v51)
    {
      uint64_t v297 = 0LL;
      unint64_t v298 = 0LL;
      unint64_t v299 = (unint64_t)v366._object;
      uint64_t v226 = v362;
      do
      {
        unint64_t v300 = v195 + v298;
        BOOL v290 = v298++ >= 8;
        if (v290) {
          unint64_t v301 = (unint64_t)v363._object;
        }
        else {
          unint64_t v301 = v363._countAndFlagsBits;
        }
        char v302 = (8 * v195 + v297) & 0x38;
        uint64_t v303 = (-255LL << v302) - 1;
        unint64_t v304 = (unint64_t)(v301 >> (v297 & 0x38)) << v302;
        unint64_t v305 = v304 | v303 & v299;
        unint64_t v306 = v304 | v303 & v193;
        if (v300 < 8) {
          uint64_t v193 = v306;
        }
        else {
          unint64_t v299 = v305;
        }
        v297 += 8LL;
      }

      while (8 * v51 != v297);
    }

    else
    {
      unint64_t v299 = (unint64_t)v366._object;
      uint64_t v226 = v362;
    }

    swift_bridgeObjectRelease((uint64_t)v366._object);
    unint64_t v341 = 0xA000000000000000LL;
    if (!(v193 & 0x8080808080808080LL | v299 & 0x80808080808080LL)) {
      unint64_t v341 = 0xE000000000000000LL;
    }
    v366._uint64_t countAndFlagsBits = v193;
    v366._unint64_t object = (void *)(v341 & 0xFF00000000000000LL | (v197 << 56) | v299 & 0xFFFFFFFFFFFFFFLL);
    goto LABEL_205;
  }

  int64_t v151 = 1LL;
LABEL_176:
  uint64_t v142 = v363._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v151) {
    uint64_t v52 = ((unint64_t)v363._object >> 56) & 0xF;
  }
  else {
    uint64_t v52 = v363._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n((uint64_t)v363._object, 3LL, v191, v192);
  Swift::Int v150 = (Swift::Int)v363._object;
  swift_bridgeObjectRetain_n((uint64_t)v363._object, 4LL, v147, v148);
  Swift::Int v198 = v52;
  if ((v194 & 0x1000000000000000LL) == 0) {
    goto LABEL_181;
  }
LABEL_326:
  Swift::Int v351 = String.UTF8View._foreignCount()();
  int64_t v199 = v351 + v198;
  if (__OFADD__(v351, v198)) {
    goto LABEL_184;
  }
LABEL_186:
  if ((v193 & ~v194 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v194 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v199 > 15) {
      goto LABEL_192;
    }
LABEL_196:
    swift_bridgeObjectRelease_n((uint64_t)v363._object, 5LL);
    unint64_t v206 = v366._countAndFlagsBits;
    unint64_t v207 = v366._object;
    swift_bridgeObjectRetain((unint64_t)v366._object, v208, v209, v210);
    unint64_t v211 = _StringGuts._convertedToSmall()(v206, (unint64_t)v207);
    unint64_t v213 = v212;
    swift_bridgeObjectRelease((uint64_t)v207);
    v214._Swift::UInt64 rawBits = (v52 << 16) | 1;
    v215._Swift::UInt64 rawBits = 1LL;
    v216._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v215,  v214,  v363._countAndFlagsBits,  (unint64_t)v363._object);
    if (v216._rawBits < 0x10000) {
      v216._rawBits |= 3;
    }
    unint64_t v218 = specialized String.init(_:)(v216, v217, v363._countAndFlagsBits, (unint64_t)v363._object);
    unint64_t v220 = v219;
    swift_bridgeObjectRelease((uint64_t)v363._object);
    unint64_t v221 = _StringGuts._convertedToSmall()(v218, v220);
    unint64_t v223 = v222;
    swift_bridgeObjectRelease(v220);
    unint64_t v224 = specialized _SmallString.init(_:appending:)(v211, v213, v221, v223);
    uint64_t v226 = v362;
    if ((v227 & 1) == 0)
    {
      uint64_t v228 = v224;
      uint64_t v229 = v225;
      swift_bridgeObjectRelease((uint64_t)v363._object);
      char v230 = v366._object;
      v366._uint64_t countAndFlagsBits = v228;
      v366._unint64_t object = v229;
      swift_bridgeObjectRelease((uint64_t)v230);
      goto LABEL_205;
    }

    goto LABEL_343;
  }

  unint64_t v201 = (unint64_t)v366._object;
  int64_t v202 = _StringGuts.nativeUnusedCapacity.getter(v366._countAndFlagsBits, (uint64_t)v366._object);
  if ((v203 & 1) != 0) {
    goto LABEL_344;
  }
  if (v199 < 16 && ((v201 & 0x2000000000000000LL) != 0 || v202 < v198)) {
    goto LABEL_196;
  }
LABEL_192:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v199, v198);
  unint64_t v194 = (unint64_t)v363._object;
  swift_bridgeObjectRelease_n((uint64_t)v363._object, 4LL);
  if (((uint64_t)v363._object & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v363._object);
    _StringGuts._foreignAppendInPlace(_:)(v363._countAndFlagsBits, (unint64_t)v363._object, 0LL, v52);
    swift_bridgeObjectRelease_n((uint64_t)v363._object, 2LL);
LABEL_204:
    uint64_t v226 = v362;
    goto LABEL_205;
  }

  if (v151)
  {
    swift_bridgeObjectRelease_n((uint64_t)v363._object, 2LL);
    uint64_t v364 = v363._countAndFlagsBits;
    unint64_t v365 = (uint64_t)v363._object & 0xFFFFFFFFFFFFFFLL;
    uint64_t v204 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v51, (uint64_t)&v364, v51);
    _StringGuts.appendInPlace(_:isASCII:)(v204, v205, ((uint64_t)v363._object & 0x4000000000000000LL) != 0);
    goto LABEL_203;
  }

  uint64_t v323 = v363._countAndFlagsBits;
  if ((v363._countAndFlagsBits & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v363._object);
    id v324 = (id)(((uint64_t)v363._object & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v325 = v142;
    uint64_t v226 = v362;
    goto LABEL_291;
  }

  id v324 = _StringObject.sharedUTF8.getter(v363._countAndFlagsBits, (uint64_t)v363._object);
  uint64_t v325 = v358;
  swift_bridgeObjectRelease((uint64_t)v363._object);
  if (v325 < v142) {
    goto LABEL_342;
  }
  unint64_t v7 = v361;
  uint64_t v226 = v362;
  uint64_t v323 = v363._countAndFlagsBits;
LABEL_291:
  unint64_t v326 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v142, (uint64_t)v324, v325);
  _StringGuts.appendInPlace(_:isASCII:)(v326, v327, v323 < 0);
  swift_bridgeObjectRelease_n((uint64_t)v363._object, 2LL);
LABEL_205:
  Swift::String v233 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", intValue: ", 0xDuLL, 1);
  unint64_t v234 = v366._object;
  unint64_t v235 = ((unint64_t)v366._object >> 56) & 0xF;
  if (!v235 && (v366._countAndFlagsBits & ~(uint64_t)v366._object & 0x2000000000000000LL) == 0)
  {
    Swift::String v366 = v233;
    swift_bridgeObjectRelease((uint64_t)v234);
    goto LABEL_218;
  }

  if (((uint64_t)v366._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v233._object & 0x2000000000000000LL) != 0)
    {
      unint64_t v237 = specialized _SmallString.init(_:appending:)( v366._countAndFlagsBits,  (unint64_t)v366._object,  v233._countAndFlagsBits,  (unint64_t)v233._object);
      if ((v231 & 1) != 0) {
        goto LABEL_216;
      }
      uint64_t v238 = v237;
      unint64_t v239 = v234;
      swift_bridgeObjectRelease((uint64_t)v233._object);
      swift_bridgeObjectRelease((uint64_t)v366._object);
      v366._uint64_t countAndFlagsBits = v238;
      v366._unint64_t object = v239;
      goto LABEL_218;
    }

  unint64_t v252 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    unint64_t v252 = v450 & 0xFFFFFFFFFFFFLL;
  }
  Swift::Int v253 = v439;
  if (v252 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236LL;
    v451 = 0xE200000000000000LL;
  }

  v159(3LL, v199, v203);
  v445 = (uint64_t *)v1;
  int64_t v254 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v254, v253, v2);
  uint64_t v255 = v445;
  unint64_t v256 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  int64_t v257 = (void *)swift_getDynamicType(v256, v255, 1);
  LODWORD(v255) = swift_isOptionalType(v257);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v255)
  {
    memcpy(v150, v253, v2);
    char v258 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v258, 7uLL);
LABEL_173:
    id v259 = (uint64_t)v445;
    size_t v260 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    uint64_t v261 = (*(uint64_t (**)(uint64_t, uint64_t))(v260 + 8))(v259, v260);
    unint64_t v263 = v262;
    specialized String.write<A>(to:)(&v450, v261, v262, v264);
    swift_bridgeObjectRelease(v263);
LABEL_174:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_177;
  }

  uint64_t v265 = v430;
  memcpy(v430, v253, v2);
  if ((swift_dynamicCast((char *)&v444, v265, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t v266 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v266);
  }

  else
  {
    unint64_t v333 = v423;
    memcpy(v423, v253, v2);
    unint64_t v334 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v333, v1, v334, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      unint64_t v335 = (uint64_t)v445;
      uint64_t v336 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v336 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v335,  v336);
      goto LABEL_174;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v357 = v415;
    memcpy(v415, v253, v2);
    uint64_t v358 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v357, v1, v358, 6uLL)
      || (v449 = 0LL,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?),  uint64_t v359 = v407,  memcpy(v407, v253, v2),  v360 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v447, v359, v1, v360, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_173;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v448 + 1) = v1;
    v384 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v384, v253, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v385 = v444._object;
    v386 = v253;
    v387 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v386,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v387);
    swift_release((uint64_t)v385);
  }

LABEL_213:
    uint64_t v236 = v233._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_217;
  }

  unint64_t v201 = v249;
  int64_t v202 = v250;
  swift_bridgeObjectRelease(v241[1]);
  *char v241 = v201;
  v241[1] = v202;
  return v15;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }

  while (1)
  {
    uint64_t v16 = v4._rawBits >> 16;
    startingAt = a2._rawBits;
    unint64_t v17 = a2._rawBits >> 16;
    if ((v6 & ~v8 & 0x2000000000000000LL) != 0)
    {
      isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL);
      unint64_t v6 = v3[2];
      uint64_t v8 = v3[3];
      if (isUniquelyReferenced_nonNull_native)
      {
        uint64_t v19 = v6 & 0xFFFFFFFFFFFFLL;
        if ((v8 & 0x2000000000000000LL) != 0) {
          uint64_t v19 = HIBYTE(v8) & 0xF;
        }
        uint64_t v20 = v19 - v17 + v16;
        if (v20 >= 16)
        {
          unint64_t v21 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v22 & 1) != 0 || v21 < v20)
          {
            unint64_t v23 = _StringGuts.uniqueNativeCapacity.getter();
            if ((v24 & 1) != 0)
            {
              uint16x8_t v117 = v3[3];
              if ((v117 & 0x1000000000000000LL) != 0)
              {
                Swift::String::Index v25 = String.UTF8View._foreignCount()();
              }

              else if ((v117 & 0x2000000000000000LL) != 0)
              {
                Swift::String::Index v25 = HIBYTE(v117) & 0xF;
              }

              else
              {
                Swift::String::Index v25 = v3[2] & 0xFFFFFFFFFFFFLL;
              }
            }

            else
            {
              Swift::String::Index v25 = 2 * v23;
            }

            if (v25 > v20) {
              uint64_t v20 = v25;
            }
            int8x16_t v118 = v3[3];
            if ((v118 & 0x1000000000000000LL) != 0)
            {
              _StringGuts._foreignGrow(_:)(v20);
            }

            else
            {
              uint16x8_t v119 = *(void *)v5;
              if ((v118 & 0x2000000000000000LL) != 0)
              {
                int8x8_t v122 = (v118 >> 62) & 1;
                uint64_t v179 = v119;
                uint64_t v180 = v118 & 0xFFFFFFFFFFFFFFLL;
                int8x16_t v120 = (char *)&v179;
                int8x16_t v121 = HIBYTE(v118) & 0xF;
              }

              else
              {
                if ((v119 & 0x1000000000000000LL) != 0)
                {
                  int8x16_t v120 = (char *)((v118 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  int8x16_t v121 = v119 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  int8x16_t v120 = (char *)_StringObject.sharedUTF8.getter(v119, v118);
                }

                int8x8_t v122 = v119 >> 63;
              }

              int8x16_t v123 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v120,  v121,  v20,  v122);
              int8x8_t v124 = *(void *)(v123 + 24);
              swift_bridgeObjectRelease(v3[3]);
              v3[2] = v124;
              v3[3] = v123;
            }
          }
        }

        uint64x2_t v115 = v3[3];
        specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( v4._rawBits >> 16,  v17,  (uint64_t)closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL,  0LL);
        int8x16_t v116 = *(void *)(v115 + 24);
        v3[2] = v116;
        goto LABEL_115;
      }
    }

    unint64_t v5 = 0xE000000000000000LL;
    uint64_t v179 = 0LL;
    uint64_t v180 = 0xE000000000000000LL;
    Swift::String::Index v26 = _StringGuts.nativeCapacity.getter(v6, v8);
    unint64_t v6 = 0LL;
    if ((v27 & 1) == 0)
    {
      Swift::String::Index v28 = v26;
      if (v26 >= 16)
      {
        unint64_t v29 = _StringGuts.uniqueNativeCapacity.getter();
        if ((v30 & 1) != 0 || v29 < v28)
        {
          unint64_t v32 = 2 * _StringGuts.uniqueNativeCapacity.getter();
          if (v32 <= v28) {
            unint64_t v32 = v28;
          }
          if ((v31 & 1) != 0) {
            unint64_t v33 = v28;
          }
          else {
            unint64_t v33 = v32;
          }
          char v177 = 0LL;
          char v178 = 0LL;
          unint64_t v5 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v177,  0LL,  v33,  1);
          unint64_t v6 = *(void *)(v5 + 24);
          swift_bridgeObjectRelease(0xE000000000000000LL);
          uint64_t v179 = v6;
          uint64_t v180 = v5;
        }

        else
        {
          unint64_t v6 = 0LL;
          unint64_t v5 = 0xE000000000000000LL;
        }
      }
    }

    unint64_t v171 = v17;
    unint64_t v172 = v4._rawBits >> 16;
    v34._Swift::UInt64 rawBits = v4._rawBits;
    unint64_t v173 = v3[2];
    unint64_t v174 = v3[3];
    uint64_t v8 = specialized Collection.subscript.getter(v34, v173, v174);
    unint64_t v12 = v37;
    uint64_t v38 = v35;
    uint64_t v39 = v36;
    unint64_t v40 = v37 >> 16;
    unint64_t v170 = v8 >> 16;
    if ((v36 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v36, 3LL, v35, (char *)v36);
      v137._Swift::UInt64 rawBits = v8 & 0xFFFFFFFFFFFF0000LL | 1;
      v138._Swift::UInt64 rawBits = v12 & 0xFFFFFFFFFFFF0000LL | 1;
      v139._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v137, v138, v38, v39);
      if (v139._rawBits < 0x10000) {
        v139._rawBits |= 3;
      }
      uint64_t v41 = v38;
      uint64_t v10 = specialized Collection.count.getter(v139, v140, v38, v39);
      swift_bridgeObjectRelease(v39);
      unint64_t v6 = v179;
      unint64_t v5 = v180;
      if ((v180 & 0x1000000000000000LL) == 0)
      {
LABEL_42:
        if ((v5 & 0x2000000000000000LL) != 0)
        {
          Swift::String::Index v44 = HIBYTE(v5) & 0xF;
          unint64_t v9 = v44 + v10;
          if (__OFADD__(v44, v10)) {
            goto LABEL_149;
          }
        }

        else
        {
          unint64_t v9 = (v6 & 0xFFFFFFFFFFFFLL) + v10;
          if (__OFADD__(v6 & 0xFFFFFFFFFFFFLL, v10)) {
            goto LABEL_149;
          }
        }

        goto LABEL_47;
      }
    }

    else
    {
      uint64_t v41 = v35;
      uint64_t v10 = v40 - (v8 >> 16);
      swift_bridgeObjectRetain_n(v36, 2LL, v35, (char *)v36);
      if ((v5 & 0x1000000000000000LL) == 0) {
        goto LABEL_42;
      }
    }

    unint64_t v141 = String.UTF8View._foreignCount()();
    unint64_t v9 = v141 + v10;
    if (__OFADD__(v141, v10))
    {
LABEL_149:
      __break(1u);
      goto LABEL_150;
    }

                LOBYTE(v24) = 10;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 8u:
              if (v11 < 0xA)
              {
                unint64_t v24 = 13;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                Swift::String::Index v25 = 13;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_216;
                }
                goto LABEL_226;
              }

              Swift::String::Index v25 = 13;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  char v18 = 13;
                  goto LABEL_9;
                }

  *((_DWORD *)v5 + 3184) = v12 + 1;
  *((_BYTE *)v14 + v12) = 95;
LABEL_214:
  swift::Demangle::__runtime::CharVector::append((char **)v5 + 1591, p_p, size, v5[1593]);
}

LABEL_216:
  uint64_t v236 = ((unint64_t)v233._object >> 56) & 0xF;
LABEL_217:
  swift_bridgeObjectRetain((unint64_t)v233._object, (uint64_t)v234, v231, v232);
  _StringGuts.append(_:)(v233._countAndFlagsBits, (unint64_t)v233._object, 0LL, v236);
  swift_bridgeObjectRelease_n((uint64_t)v233._object, 2LL);
LABEL_218:
  uint64_t v242 = v366._countAndFlagsBits;
  unint64_t v243 = (unint64_t)v366._object;
  unint64_t v244 = ((unint64_t)v366._object >> 56) & 0xF;
  unint64_t v245 = v366._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v245 && (v366._countAndFlagsBits & ~(uint64_t)v366._object & 0x2000000000000000LL) == 0)
  {
    v366._uint64_t countAndFlagsBits = v226;
    v366._unint64_t object = (void *)v7;
    uint64_t v261 = v243;
    goto LABEL_253;
  }

  uint64_t v246 = v7 & 0x2000000000000000LL;
  uint64_t v247 = HIBYTE(v7) & 0xF;
  unint64_t v248 = v244 + v247;
  if (v244 + v247 <= 0xF)
  {
    if (v247)
    {
      uint64_t v307 = 0LL;
      unint64_t v308 = 0LL;
      do
      {
        unint64_t v309 = v244 + v308;
        BOOL v290 = v308++ >= 8;
        if (v290) {
          unint64_t v310 = v7;
        }
        else {
          unint64_t v310 = v226;
        }
        char v311 = (8 * v244 + v307) & 0x38;
        uint64_t v312 = (-255LL << v311) - 1;
        unint64_t v313 = (unint64_t)(v310 >> (v307 & 0x38)) << v311;
        unint64_t v314 = v313 | v312 & v243;
        unint64_t v315 = v313 | v312 & v242;
        if (v309 < 8) {
          uint64_t v242 = v315;
        }
        else {
          unint64_t v243 = v314;
        }
        v307 += 8LL;
      }

      while (8 * v247 != v307);
    }

    swift_bridgeObjectRelease(v7);
    unint64_t v316 = 0xA000000000000000LL;
    if (!(v242 & 0x8080808080808080LL | v243 & 0x80808080808080LL)) {
      unint64_t v316 = 0xE000000000000000LL;
    }
    char v317 = (void *)(v316 & 0xFF00000000000000LL | (v248 << 56) | v243 & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v366._object);
    v366._uint64_t countAndFlagsBits = v242;
    v366._unint64_t object = v317;
    goto LABEL_296;
  }

  uint64_t v246 = 1LL;
LABEL_226:
  uint64_t v249 = v226 & 0xFFFFFFFFFFFFLL;
  if (v246) {
    uint64_t v250 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v250 = v249;
  }
  swift_bridgeObjectRetain_n(v7, 2LL, v240, v241);
  if ((v7 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(v7, 4LL, v251, v252);
    Swift::Int v253 = v250;
    if ((v243 & 0x1000000000000000LL) == 0) {
      goto LABEL_231;
    }
LABEL_332:
    Swift::Int v356 = String.UTF8View._foreignCount()();
    int64_t v254 = v356 + v253;
    if (!__OFADD__(v356, v253)) {
      goto LABEL_236;
    }
    do
    {
LABEL_234:
      __break(1u);
LABEL_235:
      uint64_t v255 = HIBYTE(v243) & 0xF;
      int64_t v254 = v255 + v253;
    }

    while (__OFADD__(v255, v253));
    goto LABEL_236;
  }

  swift_bridgeObjectRetain_n(v7, 5LL, v251, v252);
  v352._Swift::UInt64 rawBits = 1LL;
  v353._Swift::UInt64 rawBits = (v250 << 16) | 1;
  v354._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v352, v353, v362, v7);
  if (v354._rawBits < 0x10000) {
    v354._rawBits |= 3;
  }
  Swift::Int v253 = specialized Collection.count.getter(v354, v355, v362, v7);
  swift_bridgeObjectRelease(v7);
  uint64_t v242 = v366._countAndFlagsBits;
  unint64_t v243 = (unint64_t)v366._object;
LABEL_231:
  if ((v243 & 0x2000000000000000LL) != 0) {
    goto LABEL_235;
  }
  int64_t v254 = (v242 & 0xFFFFFFFFFFFFLL) + v253;
  if (__OFADD__(v242 & 0xFFFFFFFFFFFFLL, v253)) {
    goto LABEL_234;
  }
LABEL_236:
  if ((v242 & ~v243 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v243 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v254 > 15) {
      goto LABEL_242;
    }
LABEL_246:
    swift_bridgeObjectRelease_n(v7, 5LL);
    unint64_t v262 = v366._countAndFlagsBits;
    unint64_t v263 = v366._object;
    swift_bridgeObjectRetain((unint64_t)v366._object, v264, v265, v266);
    unint64_t v267 = _StringGuts._convertedToSmall()(v262, (unint64_t)v263);
    unint64_t v269 = v268;
    swift_bridgeObjectRelease((uint64_t)v263);
    v270._Swift::UInt64 rawBits = (v250 << 16) | 1;
    v271._Swift::UInt64 rawBits = 1LL;
    v272._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v271, v270, v362, v7);
    if (v272._rawBits < 0x10000) {
      v272._rawBits |= 3;
    }
    unint64_t v274 = specialized String.init(_:)(v272, v273, v362, v7);
    unint64_t v276 = v275;
    swift_bridgeObjectRelease(v7);
    unint64_t v277 = _StringGuts._convertedToSmall()(v274, v276);
    unint64_t v279 = v278;
    swift_bridgeObjectRelease(v276);
    unint64_t v280 = specialized _SmallString.init(_:appending:)(v267, v269, v277, v279);
    if ((v282 & 1) == 0)
    {
      uint64_t v283 = v280;
      uint64_t v284 = v281;
      swift_bridgeObjectRelease(v7);
      uint64_t v261 = (uint64_t)v366._object;
      v366._uint64_t countAndFlagsBits = v283;
      v366._unint64_t object = v284;
LABEL_253:
      swift_bridgeObjectRelease(v261);
      goto LABEL_296;
    }

    goto LABEL_343;
  }

  unint64_t v256 = (unint64_t)v366._object;
  int64_t v257 = _StringGuts.nativeUnusedCapacity.getter(v366._countAndFlagsBits, (uint64_t)v366._object);
  if ((v258 & 1) != 0)
  {
LABEL_344:
    unint64_t v360 = 258LL;
LABEL_345:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v360,  0);
  }

  if (v254 < 16 && ((v256 & 0x2000000000000000LL) != 0 || v257 < v253)) {
    goto LABEL_246;
  }
LABEL_242:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v254, v253);
  swift_bridgeObjectRelease_n(v7, 4LL);
  if ((v7 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v7);
    _StringGuts._foreignAppendInPlace(_:)(v362, v7, 0LL, v250);
  }

  else
  {
    if (v246)
    {
      swift_bridgeObjectRelease_n(v7, 2LL);
      uint64_t v364 = v362;
      unint64_t v365 = v7 & 0xFFFFFFFFFFFFFFLL;
      id v259 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v7) & 0xF,  (uint64_t)&v364,  HIBYTE(v7) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v259, v260, (v7 & 0x4000000000000000LL) != 0);
      uint64_t v261 = v7;
      goto LABEL_253;
    }

    uint64_t v328 = v362;
    if ((v362 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v7);
      id v329 = (id)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v330 = v249;
      goto LABEL_294;
    }

    id v329 = _StringObject.sharedUTF8.getter(v362, v7);
    uint64_t v330 = v359;
    swift_bridgeObjectRelease(v7);
    if (v330 < v249) {
LABEL_342:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    unint64_t v7 = v361;
    uint64_t v328 = v362;
LABEL_294:
    unint64_t v331 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v249, (uint64_t)v329, v330);
    _StringGuts.appendInPlace(_:isASCII:)(v331, v332, v328 < 0);
  }

  swift_bridgeObjectRelease_n(v7, 2LL);
LABEL_296:
  unint64_t v333 = v366._object;
  unint64_t v334 = ((unint64_t)v366._object >> 56) & 0xF;
  if (v334 || (v366._countAndFlagsBits & ~(uint64_t)v366._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v366._object & 0x2000000000000000LL) == 0
      || (unint64_t v335 = specialized _SmallString.init(_:appending:)( v366._countAndFlagsBits,  (unint64_t)v366._object,  0x29uLL,  0xE100000000000000LL),  (v285 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, (uint64_t)v333, v285, v286);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
    }

    else
    {
      uint64_t v336 = v335;
      v337 = v333;
      swift_bridgeObjectRelease(0xE100000000000000LL);
      swift_bridgeObjectRelease((uint64_t)v366._object);
      v366._uint64_t countAndFlagsBits = v336;
      v366._unint64_t object = v337;
    }
  }

  else
  {
    v366._uint64_t countAndFlagsBits = 41LL;
    v366._unint64_t object = (void *)0xE100000000000000LL;
    swift_bridgeObjectRelease((uint64_t)v333);
  }

  return v366._countAndFlagsBits;
}

                LOBYTE(v24) = 13;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 9u:
              if (v11 < 0xA)
              {
                unint64_t v24 = 5;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                Swift::String::Index v25 = 5;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_219;
                }
                goto LABEL_226;
              }

              Swift::String::Index v25 = 5;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  char v18 = 5;
                  goto LABEL_9;
                }

                uint64_t v160 = 0LL;
LABEL_217:
                unint64_t v164 = 213;
                goto LABEL_218;
              }

              uint64_t v160 = *(void *)v160;
            }

            unint64_t v163 = *(swift::Demangle::__runtime::Node **)v160;
            goto LABEL_205;
          }

          unint64_t v164 = 214;
LABEL_218:
          char v154 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
          if (!v154 || v154 + 24 > *((void *)this + 2))
          {
            Swift::Int v150 = 2LL * *((void *)this + 4);
            if (v150 <= 0x20) {
              Swift::Int v150 = 32LL;
            }
            *((void *)this + 4) = v150;
            int64_t v151 = v150 + 8;
            unint64_t v152 = malloc(v150 + 8);
            int64_t v153 = (char *)v152 + v151;
            *unint64_t v152 = *((void *)this + 3);
            char v154 = ((unint64_t)v152 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *((void *)this + 2) = v153;
            *((void *)this + 3) = v152;
          }

          *((void *)this + 1) = v154 + 24;
          *(_WORD *)(v154 + 16) = v164;
          *(_BYTE *)(v154 + 18) = 0;
          swift::Demangle::__runtime::Node::addChild( (unsigned int *)v154,  (swift::Demangle::__runtime::Node *)v160,  this,  v115,  v116);
          swift::Demangle::__runtime::Node::addChild( (unsigned int *)v118,  (swift::Demangle::__runtime::Node *)v154,  this,  v155,  v156);
        }

        int8x16_t v123 = *((void *)this + 1);
        unint64_t v17 = v195;
LABEL_222:
        unint64_t v171 = (v123 + 7) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v171 || v171 + 24 > *((void *)this + 2))
        {
          unint64_t v172 = 2LL * *((void *)this + 4);
          if (v172 <= 0x20) {
            unint64_t v172 = 32LL;
          }
          *((void *)this + 4) = v172;
          unint64_t v173 = v172 + 8;
          unint64_t v174 = malloc(v172 + 8);
          unint64_t v175 = (char *)v174 + v173;
          *unint64_t v174 = *((void *)this + 3);
          unint64_t v171 = ((unint64_t)v174 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v175;
          *((void *)this + 3) = v174;
        }

        *((void *)this + 1) = v171 + 24;
        *(_WORD *)(v171 + 16) = 211;
        *(_BYTE *)(v171 + 18) = 0;
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v171,  (swift::Demangle::__runtime::Node *)v118,  this,  v115,  v116);
        if (v15)
        {
          swift::Demangle::__runtime::Node::addChild((unsigned int *)v171, v15, this, a4, a5);
          swift::Demangle::__runtime::Node::addChild((unsigned int *)v171, v17, this, v176, v177);
        }

        uint64_t v8 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v8 || v8 + 24 > *((void *)this + 2))
        {
          char v178 = 2LL * *((void *)this + 4);
          if (v178 <= 0x20) {
            char v178 = 32LL;
          }
          *((void *)this + 4) = v178;
          uint64_t v179 = v178 + 8;
          uint64_t v180 = malloc(v178 + 8);
          uint64_t v181 = (char *)v180 + v179;
          *uint64_t v180 = *((void *)this + 3);
          uint64_t v8 = ((unint64_t)v180 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v181;
          *((void *)this + 3) = v180;
        }

        *((void *)this + 1) = v8 + 24;
        *(_WORD *)(v8 + 16) = 232;
        *(_BYTE *)(v8 + 18) = 0;
        uint64_t v145 = (unsigned int *)v8;
        unint64_t v146 = (swift::Demangle::__runtime::Node *)v171;
LABEL_173:
        swift::Demangle::__runtime::Node::addChild(v145, v146, this, a4, a5);
        return (int8x16_t *)v8;
      case 'Y':
        return (int8x16_t *)swift::Demangle::__runtime::Demangler::demangleAnyGenericType(this, 167LL, a3, a4, a5);
      case 'Z':
        unsigned int v56 = swift::Demangle::__runtime::Demangler::popTypeList(this, a2, a3, a4, a5);
        unsigned int v57 = *((_DWORD *)this + 24);
        if (v57
          && (uint64_t v58 = v57 - 1,
              unsigned int v59 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v58),
              *((_WORD *)v59 + 8) == 101))
        {
          *((_DWORD *)this + 24) = v58;
        }

        else
        {
          unsigned int v59 = 0LL;
        }

        int8x16_t v127 = swift::Demangle::__runtime::Demangler::popContext(this, v52, v53, v54, v55);
        int8x16_t v128 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v128 || v128 + 24 > *((void *)this + 2))
        {
          int8x16_t v129 = 2LL * *((void *)this + 4);
          if (v129 <= 0x20) {
            int8x16_t v129 = 32LL;
          }
          *((void *)this + 4) = v129;
          unint64_t v130 = v129 + 8;
          unint64_t v131 = malloc(v129 + 8);
          *unint64_t v131 = *((void *)this + 3);
          int8x16_t v128 = ((unint64_t)v131 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v131 + v130;
          *((void *)this + 3) = v131;
        }

        uint64_t v8 = 0LL;
        *((void *)this + 1) = v128 + 24;
        *(_WORD *)(v128 + 16) = 1;
        *(_BYTE *)(v128 + 18) = 0;
        if (!v59 || !v128) {
          return (int8x16_t *)v8;
        }
        swift::Demangle::__runtime::Node::addChild((unsigned int *)v128, v59, this, v125, v126);
        if (!v127) {
          return 0LL;
        }
        swift::Demangle::__runtime::Node::addChild((unsigned int *)v128, v127, this, v132, v133);
        if (!v56) {
          return 0LL;
        }
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v128,  (swift::Demangle::__runtime::Node *)v56,  this,  v134,  v135);
        return (int8x16_t *)v128;
      case 'b':
        unint64_t v60 = *((_DWORD *)this + 24);
        if (!v60) {
          return 0LL;
        }
        unsigned int v61 = v60 - 1;
        uint64_t v8 = *(void *)(*((void *)this + 11) + 8LL * v61);
        if (*(_WORD *)(v8 + 16) != 232) {
          return 0LL;
        }
        *((_DWORD *)this + 24) = v61;
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          unint64_t v62 = 2LL * *((void *)this + 4);
          if (v62 <= 0x20) {
            unint64_t v62 = 32LL;
          }
          *((void *)this + 4) = v62;
          uint64_t v63 = v62 + 8;
          uint64_t v64 = malloc(v62 + 8);
          uint64_t v65 = (char *)v64 + v63;
          *uint64_t v64 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v64 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v65;
          *((void *)this + 3) = v64;
        }

        *((void *)this + 1) = v21 + 24;
        Swift::String::Index v26 = 210;
        goto LABEL_127;
      case 'c':
        uint64_t v66 = *((_DWORD *)this + 24);
        if (v66
          && (uint64_t v67 = v66 - 1,
              unint64_t v32 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v67),
              *((_WORD *)v32 + 8) == 232))
        {
          *((_DWORD *)this + 24) = v67;
        }

        else
        {
          unint64_t v32 = 0LL;
        }

        unsigned int v136 = swift::Demangle::__runtime::Demangler::demangleProtocolList(this, a2, a3, a4, a5);
        uint64_t v8 = 0LL;
        if (!v32) {
          return (int8x16_t *)v8;
        }
        unint64_t v137 = (swift::Demangle::__runtime::Node *)v136;
        if (!v136) {
          return (int8x16_t *)v8;
        }
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          unint64_t v138 = 2LL * *((void *)this + 4);
          if (v138 <= 0x20) {
            unint64_t v138 = 32LL;
          }
          *((void *)this + 4) = v138;
          unint64_t v139 = v138 + 8;
          unint64_t v140 = malloc(v138 + 8);
          const char *v140 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v140 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v140 + v139;
          *((void *)this + 3) = v140;
        }

        *((void *)this + 1) = v21 + 24;
        *(_WORD *)(v21 + 16) = 191;
        *(_BYTE *)(v21 + 18) = 0;
        uint64_t v85 = (unsigned int *)v21;
        uint64_t v86 = v137;
        goto LABEL_166;
      case 'e':
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || (uint64_t v68 = *((void *)this + 2), v21 + 24 > v68))
        {
          uint64_t v69 = 2LL * *((void *)this + 4);
          if (v69 <= 0x20) {
            uint64_t v69 = 32LL;
          }
          *((void *)this + 4) = v69;
          uint64_t v70 = v69 + 8;
          uint64_t v71 = malloc(v69 + 8);
          uint64_t v68 = (unint64_t)v71 + v70;
          char *v71 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v71 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v71 + v70;
          *((void *)this + 3) = v71;
        }

        *(_WORD *)(v21 + 16) = 63;
        *(_BYTE *)(v21 + 18) = 0;
        uint64_t v8 = (v21 + 31) & 0xFFFFFFFFFFFFFFF8LL;
        if (v8) {
          uint64_t v72 = v8 + 24 > v68;
        }
        else {
          uint64_t v72 = 1;
        }
        if (!v72) {
          goto LABEL_172;
        }
        goto LABEL_169;
      case 'f':
        char v18 = 222;
LABEL_75:
        uint64_t v73 = 0LL;
        return (int8x16_t *)swift::Demangle::__runtime::Demangler::popFunctionType(this, v18, v73, a4, a5);
      case 'j':
        return swift::Demangle::__runtime::Demangler::demangleSymbolicExtendedExistentialType(this, a2, a3, a4, a5);
      case 'l':
        uint64_t v8 = swift::Demangle::__runtime::Demangler::demangleProtocolList(this, a2, a3, a4, a5);
        if (!v8) {
          return (int8x16_t *)v8;
        }
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          uint64_t v74 = 2LL * *((void *)this + 4);
          if (v74 <= 0x20) {
            uint64_t v74 = 32LL;
          }
          *((void *)this + 4) = v74;
          BOOL v75 = v74 + 8;
          uint64_t v76 = malloc(v74 + 8);
          uint64_t v77 = (char *)v76 + v75;
          *uint64_t v76 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v76 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v77;
          *((void *)this + 3) = v76;
        }

        *((void *)this + 1) = v21 + 24;
        Swift::String::Index v26 = 192;
        goto LABEL_127;
      case 'm':
        uint64_t v78 = swift::Demangle::__runtime::Demangler::demangleMetatypeRepresentation(this);
        uint64_t v79 = *((_DWORD *)this + 24);
        if (!v79) {
          return 0LL;
        }
        uint64_t v80 = v79 - 1;
        unint64_t v32 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v80);
        if (*((_WORD *)v32 + 8) != 232) {
          return 0LL;
        }
        uint64_t v8 = v78;
        *((_DWORD *)this + 24) = v80;
        if (!v78) {
          return (int8x16_t *)v8;
        }
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          unsigned int v81 = 2LL * *((void *)this + 4);
          if (v81 <= 0x20) {
            unsigned int v81 = 32LL;
          }
          *((void *)this + 4) = v81;
          size_t v82 = v81 + 8;
          uint64_t v83 = malloc(v81 + 8);
          uint64_t v84 = (char *)v83 + v82;
          *uint64_t v83 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v83 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v84;
          *((void *)this + 3) = v83;
        }

        *((void *)this + 1) = v21 + 24;
        char v37 = 69;
LABEL_94:
        *(_WORD *)(v21 + 16) = v37;
        *(_BYTE *)(v21 + 18) = 0;
        uint64_t v85 = (unsigned int *)v21;
        uint64_t v86 = (swift::Demangle::__runtime::Node *)v8;
LABEL_166:
        swift::Demangle::__runtime::Node::addChild(v85, v86, this, v28, v29);
        uint64x2_t v111 = (unsigned int *)v21;
        uint64x2_t v112 = v32;
        goto LABEL_167;
      case 'o':
        uint64_t v87 = *((_DWORD *)this + 24);
        if (!v87) {
          return 0LL;
        }
        uint64_t v88 = v87 - 1;
        uint64_t v8 = *(void *)(*((void *)this + 11) + 8LL * v88);
        if (*(_WORD *)(v8 + 16) != 232) {
          return 0LL;
        }
        *((_DWORD *)this + 24) = v88;
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          uint64_t v89 = 2LL * *((void *)this + 4);
          if (v89 <= 0x20) {
            uint64_t v89 = 32LL;
          }
          *((void *)this + 4) = v89;
          uint64_t v90 = v89 + 8;
          unint64_t v91 = malloc(v89 + 8);
          unint64_t v92 = (char *)v91 + v90;
          *unint64_t v91 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v91 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v92;
          *((void *)this + 3) = v91;
        }

        *((void *)this + 1) = v21 + 24;
        Swift::String::Index v26 = 248;
        goto LABEL_127;
      case 'p':
        unint64_t v93 = *((_DWORD *)this + 24);
        if (!v93) {
          return 0LL;
        }
        unint64_t v94 = v93 - 1;
        uint64_t v8 = *(void *)(*((void *)this + 11) + 8LL * v94);
        if (*(_WORD *)(v8 + 16) != 232) {
          return 0LL;
        }
        *((_DWORD *)this + 24) = v94;
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          int64x2_t v95 = 2LL * *((void *)this + 4);
          if (v95 <= 0x20) {
            int64x2_t v95 = 32LL;
          }
          *((void *)this + 4) = v95;
          int8x16_t v96 = v95 + 8;
          int8x16_t v97 = malloc(v95 + 8);
          int64x2_t v98 = (char *)v97 + v96;
          *int8x16_t v97 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v97 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v98;
          *((void *)this + 3) = v97;
        }

        *((void *)this + 1) = v21 + 24;
        Swift::String::Index v26 = 69;
        goto LABEL_127;
      case 'u':
        int64x2_t v99 = *((_DWORD *)this + 24);
        if (!v99) {
          return 0LL;
        }
        int64x2_t v100 = v99 - 1;
        uint64_t v8 = *(void *)(*((void *)this + 11) + 8LL * v100);
        if (*(_WORD *)(v8 + 16) != 232) {
          return 0LL;
        }
        *((_DWORD *)this + 24) = v100;
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          int64x2_t v101 = 2LL * *((void *)this + 4);
          if (v101 <= 0x20) {
            int64x2_t v101 = 32LL;
          }
          *((void *)this + 4) = v101;
          uint64_t v102 = v101 + 8;
          int8x16_t v103 = malloc(v101 + 8);
          unint64_t v104 = (char *)v103 + v102;
          *int8x16_t v103 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v103 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v104;
          *((void *)this + 3) = v103;
        }

        *((void *)this + 1) = v21 + 24;
        Swift::String::Index v26 = 249;
        goto LABEL_127;
      case 'w':
        int64x2_t v105 = *((_DWORD *)this + 24);
        if (!v105) {
          return 0LL;
        }
        int8x16_t v106 = v105 - 1;
        uint64_t v8 = *(void *)(*((void *)this + 11) + 8LL * v106);
        if (*(_WORD *)(v8 + 16) != 232) {
          return 0LL;
        }
        *((_DWORD *)this + 24) = v106;
        unint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v21 || v21 + 24 > *((void *)this + 2))
        {
          int8x16_t v107 = 2LL * *((void *)this + 4);
          if (v107 <= 0x20) {
            int8x16_t v107 = 32LL;
          }
          *((void *)this + 4) = v107;
          uint8x8_t v108 = v107 + 8;
          uint16x8_t v109 = malloc(v107 + 8);
          uint32x4_t v110 = (char *)v109 + v108;
          *uint16x8_t v109 = *((void *)this + 3);
          unint64_t v21 = ((unint64_t)v109 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v110;
          *((void *)this + 3) = v109;
        }

        *((void *)this + 1) = v21 + 24;
        Swift::String::Index v26 = 247;
LABEL_127:
        *(_WORD *)(v21 + 16) = v26;
        *(_BYTE *)(v21 + 18) = 0;
LABEL_128:
        uint64x2_t v111 = (unsigned int *)v21;
        uint64x2_t v112 = (swift::Demangle::__runtime::Node *)v8;
LABEL_167:
        swift::Demangle::__runtime::Node::addChild(v111, v112, this, a4, a5);
        uint64_t v8 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v8 || v8 + 24 > *((void *)this + 2))
        {
LABEL_169:
          unint64_t v141 = 2LL * *((void *)this + 4);
          if (v141 <= 0x20) {
            unint64_t v141 = 32LL;
          }
          *((void *)this + 4) = v141;
          uint64_t v142 = v141 + 8;
          unint64_t v143 = malloc(v141 + 8);
          uint64_t v144 = (char *)v143 + v142;
          *unint64_t v143 = *((void *)this + 3);
          uint64_t v8 = ((unint64_t)v143 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v144;
          *((void *)this + 3) = v143;
        }

uint64_t CodingKey.description.getter(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = v2;
  uint64_t v6 = (*(uint64_t (**)(void))(a2 + 40))();
  if ((v7 & 1) != 0)
  {
    unint64_t v9 = 0xE300000000000000LL;
    uint64_t v374 = 7104878LL;
  }

  else
  {
    uint64_t v374 = _int64ToString(_:radix:uppercase:)( v6,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    unint64_t v9 = v8;
  }

  uint64_t v10 = specialized static String._createEmpty(withInitialCapacity:)(35LL);
  unint64_t v14 = v10;
  unint64_t v15 = v11;
  v377._uint64_t countAndFlagsBits = v10;
  v377._unint64_t object = (void *)v11;
  uint64_t v16 = HIBYTE(v11) & 0xF;
  int64_t v17 = v10 & 0xFFFFFFFFFFFFLL;
  if ((v11 & 0x2000000000000000LL) != 0) {
    uint64_t v18 = HIBYTE(v11) & 0xF;
  }
  else {
    uint64_t v18 = v10 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v372 = (uint64_t)a1;
  if (!v18 && (v10 & ~v11 & 0x2000000000000000LL) == 0)
  {
    v377._uint64_t countAndFlagsBits = 0LL;
    v377._unint64_t object = (void *)0xE000000000000000LL;
    uint64_t v43 = v11;
LABEL_27:
    swift_bridgeObjectRelease(v43);
    goto LABEL_28;
  }

  if ((v11 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v42 = 0xA000000000000000LL;
    if (!(v15 & 0x80808080808080LL | v14 & 0x8080808080808080LL)) {
      unint64_t v42 = 0xE000000000000000LL;
    }
    v377._uint64_t countAndFlagsBits = v14;
    v377._unint64_t object = (void *)(v42 & 0xFF00000000000000LL | (v16 << 56) | v15 & 0xFFFFFFFFFFFFFFLL);
    goto LABEL_28;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v12, v13);
  if ((v15 & 0x1000000000000000LL) != 0)
  {
    int64_t v17 = String.UTF8View._foreignCount()();
    if ((v14 & ~v15 & 0x2000000000000000LL) == 0) {
      goto LABEL_25;
    }
  }

  else if ((v14 & ~v15 & 0x2000000000000000LL) == 0)
  {
    goto LABEL_25;
  }

  if (swift_isUniquelyReferenced_nonNull_native(v15 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v19 = _StringGuts.nativeUnusedCapacity.getter(v14, v15);
    if ((v20 & 1) != 0) {
      goto LABEL_339;
    }
    if (v17 <= 15 && (v19 & 0x8000000000000000LL) != 0) {
      goto LABEL_16;
    }
    goto LABEL_26;
  }

LABEL_110:
      uint64_t v133 = &v49->u8[v95];
      unint64_t v134 = v94 - v95;
      do
      {
        unsigned int v135 = *v133++;
        v55 |= (unint64_t)v135 << (v96 & 0x38);
        v96 += 8LL;
        --v134;
      }

      while (v134);
      goto LABEL_112;
    }

  if ((v70 & 0x1000000000000000LL) != 0)
  {
    uint64_t v67 = _StringGuts._foreignConvertedToSmall()(v67, v70);
    uint16x8_t v112 = v111;
    swift_bridgeObjectRelease(v70);
    uint64_t v70 = v112;
  }

  else
  {
    if ((v67 & 0x1000000000000000LL) != 0)
    {
      unint64_t v107 = (unsigned __int8 *)((v70 & 0xFFFFFFFFFFFFFFFLL) + 32);
      int64x2_t v108 = v67 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      unint64_t v107 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v67, v70);
    }

    closure #1 in _StringGuts._convertedToSmall()(v107, v108, &v123);
    swift_bridgeObjectRelease(v70);
    uint64_t v70 = *((void *)&v123 + 1);
    uint64_t v67 = v123;
  }

                (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v162 + 56))(v247, 1LL, 1LL, v158);
                uint64_t v228 = v84;
                goto LABEL_111;
              }

              unint64_t v193 = v253 + 3;
            }
          }

      uint64_t v83 = *(unsigned __int16 *)(v32 + 16);
      if (v83 > 0x11 || ((1 << v83) & 0x2E000) == 0) {
        goto LABEL_134;
      }
      if (v46)
      {
        size_t v85 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, v83);
        uint64_t v88 = v85;
        uint64_t v89 = *(unsigned __int8 *)(v32 + 18);
        if ((v89 - 1) >= 2)
        {
          if (v89 != 5 || !*(_DWORD *)(v32 + 8))
          {
            uint64_t v90 = 0LL;
            goto LABEL_126;
          }

          unint64_t v32 = *(void *)v32;
        }

        uint64_t v90 = *(swift::Demangle::__runtime::Node **)v32;
LABEL_126:
        swift::Demangle::__runtime::Node::addChild(v85, v90, a4, v86, v87);
        swift::Demangle::__runtime::Node::addChild(v88, (swift::Demangle::__runtime::Node *)v46, a4, v93, v94);
        unint64_t v32 = (unint64_t)v88;
        goto LABEL_134;
      }

      uint64_t v91 = *(unsigned __int8 *)(v32 + 18);
      if ((v91 - 1) >= 2)
      {
        if (v91 != 5 || !*(_DWORD *)(v32 + 8))
        {
          uint64_t v92 = 0LL;
          goto LABEL_128;
        }

        unint64_t v32 = *(void *)v32;
      }

      uint64_t v92 = *(void *)v32;
LABEL_128:
      unint64_t v95 = *(unsigned __int8 *)(v92 + 18);
      if ((v95 - 1) >= 2)
      {
        if (v95 != 5 || !*(_DWORD *)(v92 + 8))
        {
          unint64_t v32 = 0LL;
          goto LABEL_134;
        }

        uint64_t v92 = *(void *)v92;
      }

      unint64_t v32 = *(void *)v92;
LABEL_134:
      Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 71);
      swift::Demangle::__runtime::Node::addChild(Node, v12, a4, v96, v97);
      uint64_t v22 = Node;
      unint64_t v19 = (swift::Demangle::__runtime::Node *)v32;
      goto LABEL_12;
    }
  }

  Node = 0LL;
LABEL_155:
  uint64x2_t v114 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 232);
  swift::Demangle::__runtime::Node::addChild(v114, (swift::Demangle::__runtime::Node *)Node, a4, v115, v116);
  if (v133 != v135) {
    free(v133);
  }
  return v114;
}

          if (++v72 == v74) {
            goto LABEL_486;
          }
          continue;
        }

        if (!v155) {
          goto LABEL_457;
        }
LABEL_514:
        if (v150 == 5 && *((_DWORD *)v4 + 2))
        {
          id v4 = *(swift::Demangle::__runtime::Node **)v4;
LABEL_518:
          id v4 = *(swift::Demangle::__runtime::Node **)v4;
        }

        else
        {
          id v4 = 0LL;
        }

        uint64_t v48 = 2103;
        LODWORD(v14) = 18;
LABEL_506:
        *(_DWORD *)a4 = v14;
        *(void *)(a4 + 8) = v4;
        *(_DWORD *)(a4 + 16) = v48;
        return this;
      case 0xBuLL:
        unint64_t v152 = 103;
        goto LABEL_457;
      case 0xCuLL:
        if (*this != 0x736E6F635F6E6940LL || *((_DWORD *)this + 2) != 1953390964) {
          goto LABEL_514;
        }
        unint64_t v152 = 99;
        goto LABEL_457;
      case 0xDuLL:
        unint64_t v152 = 101;
        goto LABEL_457;
      case 0xEuLL:
        unint64_t v152 = 110;
        goto LABEL_457;
      case 0x10uLL:
        if (*this != 0x615F74756F6E6940LL || this[1] != 0x656C62617361696CLL) {
          goto LABEL_429;
        }
        unint64_t v152 = 98;
        goto LABEL_457;
      default:
        goto LABEL_420;
    }
  }

LABEL_331:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v56 = 0LL;
  unsigned int v57 = &v49->u8[v50];
  if (!v49) {
    unsigned int v57 = 0LL;
  }
  char v53 = 1;
  for (i = v49; ; i = (uint8x16_t *)((char *)i + 3))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unsigned int v60 = i->u8[0];
          i = (uint8x16_t *)((char *)i + 1);
          unsigned int v59 = v60;
          if ((v59 & 0x80) != 0) {
            break;
          }
          ++v56;
        }

        if (v59 > 0xDF) {
          break;
        }
        char v53 = 0;
        i = (uint8x16_t *)((char *)i + 1);
        v56 += 2LL;
      }

      if (v59 != 224) {
        break;
      }
      if (!i) {
        goto LABEL_85;
      }
      unsigned int v61 = &i->u8[1];
      if ((i->i8[0] & 0xE0) != 0xA0) {
        goto LABEL_85;
      }
LABEL_63:
      if (v61 == v57 || (*v61 & 0xC0) != 0x80) {
        goto LABEL_85;
      }
      char v53 = 0;
      i = (uint8x16_t *)((char *)i + 2);
      v56 += 3LL;
    }

    if (v59 <= 0xEC)
    {
LABEL_55:
      unsigned int v61 = &i->u8[1];
      LOBYTE(v62) = i->i8[0];
LABEL_62:
      if ((v62 & 0xC0) != 0x80) {
        goto LABEL_85;
      }
      goto LABEL_63;
    }

    if (v59 == 237)
    {
      if (!i) {
        goto LABEL_85;
      }
      unsigned int v61 = &i->u8[1];
      unsigned int v62 = i->u8[0];
      if (v62 > 0x9F) {
        goto LABEL_85;
      }
      goto LABEL_62;
    }

    if (v59 <= 0xEF) {
      goto LABEL_55;
    }
    if (v59 != 240) {
      break;
    }
    if (!i) {
      goto LABEL_85;
    }
    uint64_t v63 = &i->u8[1];
LABEL_80:
    char v53 = 0;
    v56 += 4LL;
  }

  if ((v59 + 15) <= 2u)
  {
    uint64_t v63 = &i->u8[1];
    LOBYTE(v64) = i->i8[0];
    goto LABEL_79;
  }

  if (i)
  {
    if (i != (uint8x16_t *)v57)
    {
      uint64_t v63 = &i->u8[1];
      unsigned int v64 = i->u8[0];
      if (v64 <= 0x8F)
      {
LABEL_79:
        if ((v64 & 0xC0) != 0x80) {
          goto LABEL_85;
        }
        goto LABEL_80;
      }
    }
  }

            uint64_t v75 = 0LL;
          }

          unint64_t v249 = 285;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChild( this,  v249,  (swift::Demangle::__runtime::Node *)v75,  (uint64_t)v75,  a5);
        case 'g':
          unint64_t v214 = *((_DWORD *)this + 24);
          if (!v214) {
            goto LABEL_332;
          }
          uint64_t v215 = v214 - 1;
          Swift::String::Index v216 = *((void *)this + 11);
          uint64_t v75 = *(unsigned __int16 **)(v216 + 8LL * (v214 - 1));
          uint64_t v217 = v75[8];
          if (v217 == 232)
          {
            *((_DWORD *)this + 24) = v215;
          }

          else
          {
            if (v217 == 43)
            {
              *((_DWORD *)this + 24) = v215;
              else {
                *((_DWORD *)this + 24) = v218;
              }
              uint64_t v250 = 345;
              return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v250,  (swift::Demangle::__runtime::Node *)v78,  (swift::Demangle::__runtime::Node *)v75,  a5);
            }

LABEL_85:
  uint64_t v65 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v65);
  uint64_t v66 = specialized Collection.subscript.getter(v56, (uint64_t)v49, v50);
  uint64_t v71 = findInvalidRange #1 (_:) in validateUTF8(_:)(v66, v67, v68, v69);
  uint64_t v375 = 0LL;
  unint64_t v376 = 0xE000000000000000LL;
  if (__OFADD__(v50, 15LL))
  {
    __break(1u);
    goto LABEL_331;
  }

  uint64_t v72 = v70;
  _StringGuts.reserveCapacity(_:)(v50 + 15);
  while (2)
  {
    uint64_t v73 = specialized Collection.subscript.getter(v71, (uint64_t)v49, v50);
    uint64_t v77 = v375 & 0xFFFFFFFFFFFFLL;
    if ((v376 & 0x2000000000000000LL) != 0) {
      uint64_t v77 = HIBYTE(v376) & 0xF;
    }
    BOOL v78 = __OFADD__(v77, v50);
    uint64_t v79 = v77 + v50;
    if (v78)
    {
      __break(1u);
LABEL_310:
      __break(1u);
LABEL_311:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }

    uint64_t v80 = v73;
    if (__OFADD__(v79, 3LL)) {
      goto LABEL_310;
    }
    uint64_t v81 = v74;
    uint64_t v82 = v75;
    uint64_t v83 = v76;
    _StringGuts.reserveCapacity(_:)(v79 + 3);
    uint64_t v84 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v80, v81, v82, v83);
    _StringGuts.appendInPlace(_:isASCII:)(v84, v85, 0);
    size_t v378 = 3LL;
    uint64_t v379 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v379, &v378, &v375);
    uint64_t v86 = specialized Collection.subscript.getter(v72, (uint64_t)v49, v50);
    unint64_t v49 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v86, v87, v88, v89);
    uint64_t v50 = v90;
    uint64_t v91 = validateUTF8(_:)(v49->i64, v90);
    if ((v51 & 1) != 0)
    {
      uint64_t v71 = v91;
      uint64_t v72 = v92;
      if (!v50) {
        goto LABEL_101;
      }
      continue;
    }

    break;
  }

  _StringGuts.appendInPlace(_:isASCII:)(v49->i8, v50, 0);
LABEL_101:
  uint64_t v55 = v375;
  unint64_t v54 = v376;
LABEL_120:
  uint64_t countAndFlagsBits = v377._countAndFlagsBits;
  unint64_t object = (unint64_t)v377._object;
  unint64_t v143 = ((unint64_t)v377._object >> 56) & 0xF;
  unint64_t v144 = v377._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v144 && (v377._countAndFlagsBits & ~(uint64_t)v377._object & 0x2000000000000000LL) == 0)
  {
    v377._uint64_t countAndFlagsBits = v55;
    v377._unint64_t object = (void *)v54;
    uint64_t v161 = object;
    goto LABEL_153;
  }

  uint64_t v145 = v54 & 0x2000000000000000LL;
  uint64_t v146 = HIBYTE(v54) & 0xF;
  unint64_t v147 = v143 + v146;
  if (v143 + v146 <= 0xF)
  {
    if (v146)
    {
      char v185 = 0;
      unint64_t v186 = 0LL;
      do
      {
        unint64_t v187 = v143 + v186;
        unint64_t v188 = v186 + 1;
        if (v186 >= 8) {
          unint64_t v189 = v54;
        }
        else {
          unint64_t v189 = v55;
        }
        unint64_t v190 = v189 >> (v185 & 0x38);
        char v191 = (8 * v143 + v185) & 0x38;
        uint64_t v192 = (-255LL << v191) - 1;
        unint64_t v193 = (unint64_t)v190 << v191;
        unint64_t v194 = v193 | v192 & object;
        unint64_t v195 = v193 | v192 & countAndFlagsBits;
        if (v187 < 8) {
          uint64_t countAndFlagsBits = v195;
        }
        else {
          unint64_t object = v194;
        }
        v185 += 8;
        unint64_t v186 = v188;
      }

      while (v146 != v188);
    }

    swift_bridgeObjectRelease(v54);
    unint64_t v196 = 0xA000000000000000LL;
    if (!(countAndFlagsBits & 0x8080808080808080LL | object & 0x80808080808080LL)) {
      unint64_t v196 = 0xE000000000000000LL;
    }
    unint64_t v197 = (void *)(v196 & 0xFF00000000000000LL | (v147 << 56) | object & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v377._object);
    v377._uint64_t countAndFlagsBits = countAndFlagsBits;
    v377._unint64_t object = v197;
    goto LABEL_170;
  }

  uint64_t v145 = 1LL;
LABEL_128:
  if (v145) {
    uint64_t v148 = HIBYTE(v54) & 0xF;
  }
  else {
    uint64_t v148 = v55 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v54, 2LL, v51, v52);
  if ((v54 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(v54, 4LL, v149, v150);
    Swift::Int v153 = v148;
    if ((object & 0x1000000000000000LL) == 0) {
      goto LABEL_133;
    }
LABEL_315:
    Swift::Int v356 = String.UTF8View._foreignCount()();
    int64_t v155 = v356 + v153;
    if (!__OFADD__(v356, v153)) {
      goto LABEL_137;
    }
LABEL_317:
    __break(1u);
LABEL_318:
    swift_bridgeObjectRetain_n(v148, 5LL, v151, v152);
    v357._Swift::UInt64 rawBits = 1LL;
    v358._Swift::UInt64 rawBits = (v145 << 16) | 1;
    v359._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v357, v358, v153, v148);
    if (v359._rawBits < 0x10000) {
      v359._rawBits |= 3;
    }
    Swift::Int v222 = specialized Collection.count.getter(v359, v360, v153, v148);
    swift_bridgeObjectRelease(v148);
    uint64_t v217 = v377._countAndFlagsBits;
    unint64_t v218 = (unint64_t)v377._object;
LABEL_196:
    if ((v218 & 0x2000000000000000LL) != 0) {
      goto LABEL_200;
    }
    int64_t v223 = (v217 & 0xFFFFFFFFFFFFLL) + v222;
    if (!__OFADD__(v217 & 0xFFFFFFFFFFFFLL, v222)) {
      goto LABEL_201;
    }
    do
    {
LABEL_199:
      __break(1u);
LABEL_200:
      uint64_t v224 = HIBYTE(v218) & 0xF;
      int64_t v223 = v224 + v222;
    }

    while (__OFADD__(v224, v222));
    goto LABEL_201;
  }

  swift_bridgeObjectRetain_n(v54, 5LL, v149, v150);
  v352._Swift::UInt64 rawBits = 1LL;
  v353._Swift::UInt64 rawBits = (v148 << 16) | 1;
  v354._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v352, v353, v55, v54);
  if (v354._rawBits < 0x10000) {
    v354._rawBits |= 3;
  }
  Swift::Int v153 = specialized Collection.count.getter(v354, v355, v55, v54);
  swift_bridgeObjectRelease(v54);
  uint64_t countAndFlagsBits = v377._countAndFlagsBits;
  unint64_t object = (unint64_t)v377._object;
LABEL_133:
  if ((object & 0x2000000000000000LL) != 0) {
    uint64_t v154 = HIBYTE(object) & 0xF;
  }
  else {
    uint64_t v154 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  int64_t v155 = v154 + v153;
  if (__OFADD__(v154, v153)) {
    goto LABEL_317;
  }
LABEL_137:
  if ((countAndFlagsBits & ~object & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v155 > 15) {
      goto LABEL_143;
    }
LABEL_147:
    swift_bridgeObjectRelease_n(v54, 5LL);
    unint64_t v162 = v377._countAndFlagsBits;
    unint64_t v163 = v377._object;
    swift_bridgeObjectRetain((unint64_t)v377._object, v164, v165, v166);
    unint64_t v167 = _StringGuts._convertedToSmall()(v162, (unint64_t)v163);
    unint64_t v169 = v168;
    swift_bridgeObjectRelease((uint64_t)v163);
    v170._Swift::UInt64 rawBits = (v148 << 16) | 1;
    v171._Swift::UInt64 rawBits = 1LL;
    v172._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v171, v170, v55, v54);
    if (v172._rawBits < 0x10000) {
      v172._rawBits |= 3;
    }
    unint64_t v174 = specialized String.init(_:)(v172, v173, v55, v54);
    unint64_t v176 = v175;
    swift_bridgeObjectRelease(v54);
    unint64_t v177 = _StringGuts._convertedToSmall()(v174, v176);
    unint64_t v179 = v178;
    swift_bridgeObjectRelease(v176);
    unint64_t v180 = specialized _SmallString.init(_:appending:)(v167, v169, v177, v179);
    if ((v182 & 1) != 0) {
      goto LABEL_338;
    }
    uint64_t v183 = v180;
    Swift::String::Index v184 = v181;
    swift_bridgeObjectRelease(v54);
    uint64_t v161 = (uint64_t)v377._object;
    v377._uint64_t countAndFlagsBits = v183;
    v377._unint64_t object = v184;
LABEL_153:
    swift_bridgeObjectRelease(v161);
    goto LABEL_170;
  }

  unint64_t v156 = (unint64_t)v377._object;
  int64_t v157 = _StringGuts.nativeUnusedCapacity.getter(v377._countAndFlagsBits, (uint64_t)v377._object);
  if ((v158 & 1) != 0) {
    goto LABEL_339;
  }
  if (v155 <= 15 && ((v156 & 0x2000000000000000LL) != 0 || v157 < v153)) {
    goto LABEL_147;
  }
LABEL_143:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v155, v153);
  swift_bridgeObjectRelease_n(v54, 4LL);
  if ((v54 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v54);
    _StringGuts._foreignAppendInPlace(_:)(v55, v54, 0LL, v148);
    goto LABEL_169;
  }

  if (v145)
  {
    swift_bridgeObjectRelease_n(v54, 2LL);
    uint64_t v375 = v55;
    unint64_t v376 = v54 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v159 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v54) & 0xF,  (uint64_t)&v375,  HIBYTE(v54) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v159, v160, (v54 & 0x4000000000000000LL) != 0);
    uint64_t v161 = v54;
    goto LABEL_153;
  }

  if ((v55 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v54);
    id v198 = (id)((v54 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v199 = v55 & 0xFFFFFFFFFFFFLL;
    uint64_t v200 = v55 & 0xFFFFFFFFFFFFLL;
    goto LABEL_168;
  }

  id v198 = _StringObject.sharedUTF8.getter(v55, v54);
  uint64_t v200 = v367;
  swift_bridgeObjectRelease(v54);
  if (v200 < (v55 & 0xFFFFFFFFFFFFLL)) {
    goto LABEL_337;
  }
  uint64_t v199 = v55 & 0xFFFFFFFFFFFFLL;
LABEL_168:
  unint64_t v201 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v199, (uint64_t)v198, v200);
  _StringGuts.appendInPlace(_:isASCII:)(v201, v202, v55 < 0);
LABEL_169:
  swift_bridgeObjectRelease_n(v54, 2LL);
LABEL_170:
  unint64_t v203 = v373;
  Swift::String v206 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("(stringValue: ", 0xFuLL, 1);
  unint64_t v207 = v377._object;
  unint64_t v208 = ((unint64_t)v377._object >> 56) & 0xF;
  if (!v208 && (v377._countAndFlagsBits & ~(uint64_t)v377._object & 0x2000000000000000LL) == 0)
  {
    Swift::String v377 = v206;
    swift_bridgeObjectRelease((uint64_t)v207);
    goto LABEL_183;
  }

  if (((uint64_t)v377._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v206._object & 0x2000000000000000LL) != 0)
    {
      unint64_t v210 = specialized _SmallString.init(_:appending:)( v377._countAndFlagsBits,  (unint64_t)v377._object,  v206._countAndFlagsBits,  (unint64_t)v206._object);
      if ((v204 & 1) != 0) {
        goto LABEL_181;
      }
      uint64_t v211 = v210;
      unint64_t v212 = v207;
      swift_bridgeObjectRelease((uint64_t)v206._object);
      swift_bridgeObjectRelease((uint64_t)v377._object);
      v377._uint64_t countAndFlagsBits = v211;
      v377._unint64_t object = v212;
      goto LABEL_183;
    }

                    v256((char *)v292, a2);
                    ((void (*)(char *, uint64_t))v291)(v168, v78);
                    goto LABEL_3;
                  }
                }

                uint64_t v192 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                unint64_t v193 = lazy protocol witness table accessor for type Int and conformance Int(v169, v170, v171);
                v192(&v294, &type metadata for Int, v193, v78, v68);
                unint64_t v168 = v290;
                unint64_t v194 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL)
                                                                          + 16LL))( v290,  v83,  v78);
                ((void (*)(char *, uint64_t))v291)(v83, v78);
                if ((v194 & 1) == 0) {
                  goto LABEL_73;
                }
                goto LABEL_85;
              }
            }

            else
            {
              int8x16_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
              unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              uint64_t v83 = v288;
              v106(&v294, &type metadata for Int, v107, v78, v68);
              int64x2_t v108 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v290,  v83,  v78);
              uint64_t v84 = v287;
              unint64_t v291 = *(void *)(v287 + 8);
              ((void (*)(char *, uint64_t))v291)(v83, v78);
              uint64_t v77 = v258;
              if ((v108 & 1) != 0) {
                goto LABEL_48;
              }
            }
          }

          else
          {
            uint64_t v84 = v287;
            uint32x4_t v113 = *(void (**)(char *, char *, uint64_t))(v287 + 16);
            if (v103 >= 64)
            {
              v113(v17, v290, v78);
              unint64_t v291 = *(void *)(v84 + 8);
              ((void (*)(char *, uint64_t))v291)(v17, v78);
              uint64_t v83 = v288;
              uint64_t v77 = v258;
              goto LABEL_51;
            }

            uint64_t v83 = v288;
            v113(v288, v290, v78);
            uint64x2_t v114 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
            unint64_t v291 = *(void *)(v84 + 8);
            ((void (*)(char *, uint64_t))v291)(v83, v78);
            uint64_t v77 = v258;
            if (v114 < v294) {
              goto LABEL_48;
            }
          }
        }

      v251((char *)v287, a2);
      ((void (*)(char *, uint64_t))v286)(v164, v77);
      return 0LL;
    }

            uint16x8_t v112 = 0LL;
LABEL_86:
            unint64_t v31 = 1LL;
            (*(void (**)(char *, uint64_t, uint64_t, char *))(v8 + 56))(v23, 1LL, 1LL, v5);
            swift_bridgeObjectRelease(v120);
LABEL_88:
            outlined consume of [A : B].Iterator._Variant<A, B>(v39);
            return v31;
          }

          __break(1u);
        }

        break;
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
    }
  }

  else if (*(void *)(a1 + 16))
  {
    goto LABEL_13;
  }

  return 1LL;
}

        size_t v45 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(startingAt);
        Swift::String::Index v46 = startingAt << 16;
        if (v45 <= 63) {
          goto LABEL_70;
        }
LABEL_71:
        *a3 = v46 | 5;
        uint64_t result = _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v46 | 5));
        if ((result & 1) != 0) {
          *a3 = v46 | 7;
        }
        a2 = (Swift::UInt64)v8 + startingAt;
        if (!__OFADD__(startingAt, v8)) {
          goto LABEL_33;
        }
        __break(1u);
LABEL_76:
        unint64_t v31 = _StringGuts._slowEnsureMatchingEncoding(_:)(v30)._rawBits;
      }

      __break(1u);
LABEL_83:
      __break(1u);
LABEL_84:
      __break(1u);
      goto LABEL_85;
    }
  }

  uint64_t result = a5(v5);
  if (__OFSUB__(v15, result))
  {
    __break(1u);
    goto LABEL_36;
  }

  uint64_t v16 = a1 >> 16;
  int64_t v17 = *a3;
  uint64_t v18 = (unint64_t)*a3 >> 16;
  unint64_t v19 = v15 - result + (a1 >> 16) - (a2 >> 16);
  a2 = v19 + (*a4 >> 16);
  char v20 = ((unint64_t)*a3 >> 8) & 0x3F;
  if (v20)
  {
    if (v20 + v18 < v16) {
      goto LABEL_32;
    }
  }

  else if (v18 < v16)
  {
    goto LABEL_32;
  }

  if (v18 == a2)
  {
    uint64_t result = 0LL;
    uint64_t v21 = v17 & 0xFFFFFFFFFFFF0000LL;
LABEL_26:
    v21 |= result << 8;
    goto LABEL_27;
  }

  uint64_t v22 = *v7;
  unint64_t v23 = v7[1];
  if ((v23 & 0x1000000000000000LL) == 0)
  {
    if ((v23 & 0x2000000000000000LL) != 0)
    {
      uint64_t v56 = *v7;
      unsigned int v57 = v23 & 0xFFFFFFFFFFFFFFLL;
      if (v18 + 1 != (HIBYTE(v23) & 0xF))
      {
        Swift::String::Index v27 = *(unsigned __int16 *)((char *)&v56 + v18);
        if (v27 == 2573 || (v27 & 0x80808080) != 0) {
          goto LABEL_55;
        }
      }
    }

    else
    {
      if ((v22 & 0x1000000000000000LL) != 0)
      {
        unint64_t v24 = (char *)((v23 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v25 = v22 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v24 = (char *)_StringObject.sharedUTF8.getter(*v7, v7[1]);
      }

      if (v18 + 1 != v25)
      {
        if (!v24) {
LABEL_81:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        unint64_t v26 = *(unsigned __int16 *)&v24[v18];
        if (v26 == 2573 || (v26 & 0x80808080) != 0) {
          goto LABEL_55;
        }
      }
    }

    uint64_t v21 = v17 & 0xFFFFFFFFFFFF0000LL;
    uint64_t result = 1LL;
    goto LABEL_26;
  }

      uint64_t v55 = v44;
      uint64_t v56 = v45;
      unsigned int v57 = (unint64_t)(v43 + 0x7FFFFFFFFFFFFFE0LL);
LABEL_86:
      swift_bridgeObjectRelease(v57 | 0x8000000000000000LL);
      swift_bridgeObjectRelease(v41);
LABEL_135:
      v88._uint64_t countAndFlagsBits = v55;
      v88._unint64_t object = (void *)v56;
LABEL_136:
      uint64_t v79 = HIBYTE(v56) & 0xF;
      if ((v56 & 0x2000000000000000LL) == 0) {
        uint64_t v79 = v55 & 0xFFFFFFFFFFFFLL;
      }
      if (!v79 && (v55 & ~v56 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v56);
        uint64_t v88 = v2;
LABEL_149:
        uint64_t v86 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000LL) == 0) {
          uint64_t v86 = v4 & 0xFFFFFFFFFFFFLL;
        }
        if (v86 || (v4 & ~object & 0x2000000000000000LL) != 0)
        {
          _StringGuts.append(_:)(0LL, 0xE000000000000000LL);
          goto LABEL_117;
        }

        goto LABEL_154;
      }

      if ((v56 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v2._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v81 = specialized _SmallString.init(_:appending:)( v55,  v56,  v2._countAndFlagsBits,  (unint64_t)v2._object);
          if ((v83 & 1) == 0)
          {
            uint64_t v84 = v81;
            size_t v85 = v82;
            swift_bridgeObjectRelease(v56);
            swift_bridgeObjectRelease((uint64_t)v2._object);
            v88._uint64_t countAndFlagsBits = v84;
            v88._unint64_t object = v85;
            unint64_t object = (unint64_t)v85;
            id v4 = v84;
            goto LABEL_149;
          }

          goto LABEL_147;
        }
      }

      else if (((uint64_t)v2._object & 0x2000000000000000LL) != 0)
      {
LABEL_147:
        uint64_t v80 = ((unint64_t)v2._object >> 56) & 0xF;
        goto LABEL_148;
      }

      uint64_t v80 = v2._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_148:
      _StringGuts.append(_:)(v2._countAndFlagsBits, (unint64_t)v2._object, 0LL, v80);
      swift_bridgeObjectRelease((uint64_t)v2._object);
      unint64_t object = (unint64_t)v88._object;
      id v4 = v88._countAndFlagsBits;
      goto LABEL_149;
    }

    swift_bridgeObjectRelease(v52);
    uint64_t v71 = "KHITAN SMALL SCRIPT CHARACTER-";
    uint64_t v55 = 0xD00000000000001ELL;
    goto LABEL_133;
  }

  if (v1 >= 0x1B170 && v1 <= 0x1B2FB)
  {
    uint64_t v72 = specialized static String._createEmpty(withInitialCapacity:)(18LL);
    uint64_t v41 = v73;
    v88._uint64_t countAndFlagsBits = v72;
    v88._unint64_t object = (void *)v73;
    uint64_t v74 = HIBYTE(v73) & 0xF;
    if ((v73 & 0x2000000000000000LL) == 0) {
      uint64_t v74 = v72 & 0xFFFFFFFFFFFFLL;
    }
    if (v74 || (v72 & ~v73 & 0x2000000000000000LL) != 0)
    {
      if ((v73 & 0x2000000000000000LL) != 0 && (0x80000001818BB030LL & 0x2000000000000000LL) != 0)
      {
        uint64_t v75 = specialized _SmallString.init(_:appending:)( v72,  v73,  0xD000000000000010LL,  0x80000001818BB030LL | 0x8000000000000000LL);
        if ((v77 & 1) == 0)
        {
          uint64_t v55 = v75;
          uint64_t v56 = v76;
          unsigned int v57 = 0x80000001818BB030LL;
          goto LABEL_86;
        }
      }

      uint64_t v47 = 0x80000001818BB030LL | 0x8000000000000000LL;
      if ((0x80000001818BB030LL & 0x2000000000000000LL) != 0) {
        uint64_t v48 = (0x80000001818BB030LL >> 56) & 0xF;
      }
      else {
        uint64_t v48 = 16LL;
      }
      unint64_t v49 = 0xD000000000000010LL;
LABEL_91:
      _StringGuts.append(_:)(v49, v47, 0LL, v48);
      swift_bridgeObjectRelease(v47);
      uint64_t v56 = (unint64_t)v88._object;
      uint64_t v55 = v88._countAndFlagsBits;
      goto LABEL_136;
    }

    uint64_t v55 = 0xD000000000000010LL;
    swift_bridgeObjectRelease(v73);
    BOOL v78 = 0x80000001818BB030LL;
LABEL_134:
    uint64_t v56 = v78 | 0x8000000000000000LL;
    goto LABEL_135;
  }

  swift_bridgeObjectRelease((uint64_t)v2._object);
  uint64_t countAndFlagsBits = 0LL;
  char v7 = 0LL;
LABEL_118:
  uint64_t v69 = countAndFlagsBits;
  uint64_t v70 = v7;
  result.value._unint64_t object = v70;
  result.value._uint64_t countAndFlagsBits = v69;
  return result;
}

        Swift::String::Index v44 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v44 || v44 + 24 > *((void *)this + 2))
        {
          size_t v45 = 2LL * *((void *)this + 4);
          if (v45 <= 0x20) {
            size_t v45 = 32LL;
          }
          *((void *)this + 4) = v45;
          Swift::String::Index v46 = v45 + 8;
          uint64_t v47 = malloc(v45 + 8);
          uint64_t v48 = (char *)v47 + v46;
          *uint64_t v47 = *((void *)this + 3);
          Swift::String::Index v44 = ((unint64_t)v47 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v48;
          *((void *)this + 3) = v47;
        }

        *((void *)this + 1) = v44 + 24;
        *(_WORD *)(v44 + 16) = 102;
        *(_BYTE *)(v44 + 18) = 4;
        *(void *)Swift::String::Index v44 = v14;
        unint64_t v49 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v49 || v49 + 24 > *((void *)this + 2))
        {
          uint64_t v50 = 2LL * *((void *)this + 4);
          if (v50 <= 0x20) {
            uint64_t v50 = 32LL;
          }
          *((void *)this + 4) = v50;
          uint64_t v51 = v50 + 8;
          uint64_t v52 = malloc(v50 + 8);
          *uint64_t v52 = *((void *)this + 3);
          unint64_t v49 = ((unint64_t)v52 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v52 + v51;
          *((void *)this + 3) = v52;
        }

        *((void *)this + 1) = v49 + 24;
        *(_WORD *)(v49 + 16) = 102;
        *(_BYTE *)(v49 + 18) = 4;
        *(void *)unint64_t v49 = v40;
        char v53 = *((_DWORD *)this + 24);
        if (v53)
        {
          unint64_t v54 = v53 - 1;
          uint64_t v55 = *((void *)this + 11);
          uint64_t v56 = *(swift::Demangle::__runtime::Node **)(v55 + 8LL * (v53 - 1));
          if (*((_WORD *)v56 + 8) == 101)
          {
            *((_DWORD *)this + 24) = v54;
            if (v53 == 1) {
              goto LABEL_103;
            }
          }

          else
          {
            uint64_t v56 = 0LL;
            unint64_t v54 = *((_DWORD *)this + 24);
          }

          unsigned int v57 = v54 - 1;
          uint64_t v58 = *(swift::Demangle::__runtime::Node **)(v55 + 8LL * v57);
          if (*((_WORD *)v58 + 8) == 101)
          {
            *((_DWORD *)this + 24) = v57;
            return swift::Demangle::__runtime::Demangler::createWithChildren( this,  139,  v58,  v56,  (char *)v44,  (swift::Demangle::__runtime::Node *)v49);
          }
        }

        else
        {
          uint64_t v56 = 0LL;
        }
}

  swift::Demangle::__runtime::CharVector::append(v12, "Qo", 2uLL, this[1593]);
  if (*((_BYTE *)v5 + 18) == 5) {
    unint64_t v5 = (swift::Demangle::__runtime::Node **)*v5;
  }
  Swift::String::Index v46 = (unint64_t)this[1585];
  if (v46 > 0xF)
  {
    uint64_t v48 = *((_DWORD *)this + 3178) + 16;
    uint64_t v55 = v53;
    uint64_t v56 = v54;
    unsigned int v57 = v48;
    uint64_t result = (uint64_t *)std::__hash_table<std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,std::__unordered_map_hasher<swift::Demangle::__runtime::SubstitutionEntry,std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,swift::Demangle::__runtime::SubstitutionEntry::Hasher,std::equal_to<swift::Demangle::__runtime::SubstitutionEntry>,true>,std::__unordered_map_equal<swift::Demangle::__runtime::SubstitutionEntry,std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,std::equal_to<swift::Demangle::__runtime::SubstitutionEntry>,swift::Demangle::__runtime::SubstitutionEntry::Hasher,true>,std::allocator<std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>>>::__emplace_unique_key_args<swift::Demangle::__runtime::SubstitutionEntry,std::pair<swift::Demangle::__runtime::SubstitutionEntry const,unsigned int>>( (uint64_t)(this + 1586),  (uint64_t)&v55,  &v55);
  }

  else
  {
    this[1585] = (const void *)(v46 + 1);
    uint64_t v47 = &this[3 * v46 + 1537];
    *(_OWORD *)uint64_t v47 = v53;
    *((_BYTE *)v47 + 16) = v54;
  }

LABEL_178:
    uint64_t v209 = v206._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_182;
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  Swift::String::Index v46 = v270;
  if ((v270 & 0x1000000000000000LL) != 0) {
    goto LABEL_140;
  }
  uint64_t v47 = __src;
  if ((v270 & 0x2000000000000000LL) == 0)
  {
    unint64_t v15 = v266;
    if ((__src & 0x1000000000000000LL) != 0)
    {
      uint64_t v48 = (char *)((v270 & 0xFFFFFFFFFFFFFFFLL) + 32);
      unint64_t v49 = __src & 0xFFFFFFFFFFFFLL;
      goto LABEL_8;
    }

                uint64_t v164 = v246;
                uint64_t v165 = (void *)v247;
                swift_bridgeObjectRelease(*((uint64_t *)&v248 + 1));
                unint64_t v14 = 0;
                *(void *)&unint64_t v248 = v164;
                *((void *)&v248 + 1) = v165;
                goto LABEL_16;
              }

              uint16x8_t v112 = 0;
              uint64_t v79 = v75;
            }

            else
            {
              if (v74 >= 16)
              {
                uint64_t v76 = v246;
                uint64_t v75 = v247;
                goto LABEL_82;
              }

              uint64_t v79 = v247;
              if ((v247 & 0x2000000000000000LL) == 0)
              {
                uint64_t v75 = v247;
                goto LABEL_119;
              }

              uint16x8_t v112 = 0;
              uint64_t v75 = v247;
            }

                uint64_t v91 = 0LL;
LABEL_179:
                LODWORD(v7) = v7 + 4;
                std::string::append(this, ">]", 2uLL);
                goto LABEL_10;
              }

LABEL_181:
  uint64_t v209 = ((unint64_t)v206._object >> 56) & 0xF;
LABEL_182:
  swift_bridgeObjectRetain((unint64_t)v206._object, (uint64_t)v207, v204, v205);
  _StringGuts.append(_:)(v206._countAndFlagsBits, (unint64_t)v206._object, 0LL, v209);
  swift_bridgeObjectRelease_n((uint64_t)v206._object, 2LL);
LABEL_183:
  uint64_t v213 = (*(uint64_t (**)(uint64_t))(v371 + 24))(v372);
  Swift::Int v153 = v213;
  uint64_t v148 = v214;
  uint64_t v217 = v377._countAndFlagsBits;
  unint64_t v218 = (unint64_t)v377._object;
  unint64_t v219 = ((unint64_t)v377._object >> 56) & 0xF;
  unint64_t v220 = v377._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v220 && (v377._countAndFlagsBits & ~(uint64_t)v377._object & 0x2000000000000000LL) == 0)
  {
    v377._uint64_t countAndFlagsBits = v213;
    v377._unint64_t object = (void *)v214;
    uint64_t v230 = v218;
    goto LABEL_218;
  }

  unint64_t v54 = v214 & 0x2000000000000000LL;
  unint64_t object = HIBYTE(v214) & 0xF;
  unint64_t v221 = v219 + object;
  if (v219 + object <= 0xF)
  {
    if (object)
    {
      char v310 = 0;
      unint64_t v311 = 0LL;
      do
      {
        unint64_t v312 = v219 + v311;
        unint64_t v313 = v311 + 1;
        if (v311 >= 8) {
          unint64_t v314 = v214;
        }
        else {
          unint64_t v314 = v213;
        }
        unint64_t v315 = v314 >> (v310 & 0x38);
        char v316 = (8 * v219 + v310) & 0x38;
        uint64_t v317 = (-255LL << v316) - 1;
        unint64_t v318 = (unint64_t)v315 << v316;
        unint64_t v319 = v318 | v317 & v218;
        unint64_t v320 = v318 | v317 & v217;
        if (v312 < 8) {
          uint64_t v217 = v320;
        }
        else {
          unint64_t v218 = v319;
        }
        v310 += 8;
        unint64_t v311 = v313;
      }

      while (object != v313);
    }

    swift_bridgeObjectRelease(v214);
    unint64_t v321 = 0xA000000000000000LL;
    if (!(v217 & 0x8080808080808080LL | v218 & 0x80808080808080LL)) {
      unint64_t v321 = 0xE000000000000000LL;
    }
    size_t v322 = (void *)(v321 & 0xFF00000000000000LL | (v221 << 56) | v218 & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v377._object);
    v377._uint64_t countAndFlagsBits = v217;
    v377._unint64_t object = v322;
    goto LABEL_219;
  }

  unint64_t v54 = 1LL;
LABEL_191:
  uint64_t v372 = v213 & 0xFFFFFFFFFFFFLL;
  if (v54) {
    uint64_t v145 = HIBYTE(v214) & 0xF;
  }
  else {
    uint64_t v145 = v213 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v214, 2LL, v215, v216);
  if ((v148 & 0x1000000000000000LL) != 0) {
    goto LABEL_318;
  }
  swift_bridgeObjectRetain_n(v148, 4LL, v151, v152);
  Swift::Int v222 = v145;
  if ((v218 & 0x1000000000000000LL) == 0) {
    goto LABEL_196;
  }
LABEL_321:
  Swift::Int v361 = String.UTF8View._foreignCount()();
  int64_t v223 = v361 + v222;
  if (__OFADD__(v361, v222)) {
    goto LABEL_199;
  }
LABEL_201:
  if ((v217 & ~v218 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v218 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v223 > 15) {
      goto LABEL_207;
    }
    goto LABEL_211;
  }

  unint64_t v225 = (unint64_t)v377._object;
  int64_t v226 = _StringGuts.nativeUnusedCapacity.getter(v377._countAndFlagsBits, (uint64_t)v377._object);
  if ((v227 & 1) != 0) {
    goto LABEL_339;
  }
  if (v223 <= 15 && ((v225 & 0x2000000000000000LL) != 0 || v226 < v222))
  {
LABEL_211:
    swift_bridgeObjectRelease_n(v148, 5LL);
    unint64_t v231 = v377._countAndFlagsBits;
    unint64_t v232 = v377._object;
    swift_bridgeObjectRetain((unint64_t)v377._object, v233, v234, v235);
    unint64_t v236 = _StringGuts._convertedToSmall()(v231, (unint64_t)v232);
    unint64_t v238 = v237;
    swift_bridgeObjectRelease((uint64_t)v232);
    v239._Swift::UInt64 rawBits = (v145 << 16) | 1;
    v240._Swift::UInt64 rawBits = 1LL;
    v241._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v240, v239, v153, v148);
    if (v241._rawBits < 0x10000) {
      v241._rawBits |= 3;
    }
    unint64_t v243 = specialized String.init(_:)(v241, v242, v153, v148);
    unint64_t v245 = v244;
    swift_bridgeObjectRelease(v148);
    unint64_t v246 = _StringGuts._convertedToSmall()(v243, v245);
    unint64_t v248 = v247;
    swift_bridgeObjectRelease(v245);
    unint64_t v249 = specialized _SmallString.init(_:appending:)(v236, v238, v246, v248);
    unint64_t v203 = v373;
    if ((v251 & 1) == 0)
    {
      uint64_t v252 = v249;
      Swift::Int v253 = v250;
      swift_bridgeObjectRelease(v148);
      uint64_t v230 = (uint64_t)v377._object;
      v377._uint64_t countAndFlagsBits = v252;
      v377._unint64_t object = v253;
LABEL_218:
      swift_bridgeObjectRelease(v230);
      goto LABEL_219;
    }

      v163._Swift::UInt64 rawBits = (v19 << 16) | 1;
      v164._Swift::UInt64 rawBits = 1LL;
      v165._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v164, v163, v13, v14);
      if (v165._rawBits < 0x10000) {
        v165._rawBits |= 3;
      }
      unint64_t v167 = specialized String.init(_:)(v165, v166, v13, v14);
      unint64_t v169 = v168;
      swift_bridgeObjectRelease(v14);
      if ((v169 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v169);
      }

      else if ((v169 & 0x1000000000000000LL) != 0)
      {
        unint64_t v167 = _StringGuts._foreignConvertedToSmall()(v167, v169);
        unint64_t v225 = v224;
        swift_bridgeObjectRelease(v169);
        unint64_t v169 = v225;
      }

      else
      {
        if ((v167 & 0x1000000000000000LL) != 0)
        {
          uint64_t v215 = (unsigned __int8 *)((v169 & 0xFFFFFFFFFFFFFFFLL) + 32);
          Swift::String::Index v216 = v167 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v215 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v167, v169);
        }

        closure #1 in _StringGuts._convertedToSmall()(v215, v216, &v229);
        swift_bridgeObjectRelease(v169);
        unint64_t v169 = *((void *)&v229 + 1);
        unint64_t v167 = v229;
      }

      Swift::String::Index v170 = HIBYTE(v16) & 0xF;
      Swift::String::Index v171 = HIBYTE(v169) & 0xF;
      uint64x2_t v114 = v171 + v170;
      if ((unint64_t)(v171 + v170) <= 0xF)
      {
        if (v171)
        {
          Swift::String::Index v172 = 0LL;
          Swift::String::Index v173 = 0LL;
          unint64_t v174 = 8 * v171;
          do
          {
            unint64_t v175 = v170 + v173;
            unint64_t v94 = v173++ >= 8;
            if (v94) {
              unint64_t v176 = v169;
            }
            else {
              unint64_t v176 = v167;
            }
            unint64_t v177 = (8 * v170 + v172) & 0x38;
            unint64_t v178 = (-255LL << v177) - 1;
            unint64_t v179 = (unint64_t)(v176 >> (v172 & 0x38)) << v177;
            unint64_t v180 = v179 | v178 & v16;
            uint64_t v181 = v179 | v178 & v20;
            if (v175 < 8) {
              char v20 = v181;
            }
            else {
              uint64_t v16 = v180;
            }
            v172 += 8LL;
          }

          while (v174 != v172);
        }

        goto LABEL_144;
      }

      goto LABEL_249;
    }

    uint64_t v84 = v234;
LABEL_100:
    swift_bridgeObjectRelease(v84);
    uint64_t v233 = v13;
    uint64_t v234 = v14;
    goto LABEL_176;
  }

  unint64_t v231 = 0LL;
  size_t v229 = 0u;
  uint64_t v230 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v229,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v230 + 1) = v2;
  *(void *)&size_t v229 = a1;
  Mirror.init(reflecting:)((uint64_t *)&v229, (uint64_t)v226);
  uint64_t v87 = v226[1];
  uint64_t v88 = v228;
  ((void (*)(uint64_t *, uint64_t *, uint64_t *, void, uint64_t *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( &v235,  v226,  &v233,  0LL,  v2,  &type metadata for String,  &protocol witness table for String);
  swift_release(v88);
  swift_release(v87);
  return v233;
}

                _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v181, 2LL);
                swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
                Swift::Int v222 = xmmword_1817FFD00;
                uint64_t v204 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v222, 2LL);
                _StringGuts.appendInPlace(_:isASCII:)(v204, v205, 1);
                swift_bridgeObjectRelease(0xE300000000000000LL);
                swift_bridgeObjectRelease(0xE200000000000000LL);
                return v223;
              }

  swift_bridgeObjectRelease(a1);
  if ((a1 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(a3, a1, a4, v5);
    goto LABEL_192;
  }

  if ((a1 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(a1);
    id v198 = HIBYTE(a1) & 0xF;
    unint64_t v247 = a3;
    unint64_t v248 = a1 & 0xFFFFFFFFFFFFFFLL;
    if (v198 < v5) {
      goto LABEL_253;
    }
    uint64_t v199 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a4, v5, (uint64_t)&v247, v198);
    _StringGuts.appendInPlace(_:isASCII:)(v199, v200, (a1 & 0x4000000000000000LL) != 0);
  }

  else
  {
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      uint64_t v165 = (id)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
      Swift::String::Index v166 = a3 & 0xFFFFFFFFFFFFLL;
      if ((a3 & 0xFFFFFFFFFFFFLL) >= v5) {
        goto LABEL_185;
      }
LABEL_253:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    uint64_t v165 = _StringObject.sharedUTF8.getter(a3, a1);
    Swift::String::Index v166 = v231;
    if (v231 < v5) {
      goto LABEL_253;
    }
LABEL_185:
    unint64_t v167 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a4, v5, (uint64_t)v165, v166);
    _StringGuts.appendInPlace(_:isASCII:)(v167, v168, a3 < 0);
LABEL_192:
    swift_bridgeObjectRelease(a1);
  }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    swift_bridgeObjectRelease(v8);
    uint16x8_t v112 = HIBYTE(v8) & 0xF;
    unint64_t v177 = startingAt;
    unint64_t v178 = v8 & 0xFFFFFFFFFFFFFFLL;
    int64_t v17 = v171;
    uint64_t v16 = v172;
    if (v112 < v9) {
      goto LABEL_181;
    }
    uint32x4_t v113 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v174, v9, (uint64_t)&v177, v112);
    _StringGuts.appendInPlace(_:isASCII:)(v113, v114, (v8 & 0x4000000000000000LL) != 0);
  }

      if (v96 == v98)
      {
LABEL_26:
        unint64_t v8 = 0;
        char v7 = 0LL;
        unint64_t v14 = 0;
LABEL_75:
        *(_DWORD *)a6 = v8;
        *(void *)(a6 + 8) = v7;
        *(_DWORD *)(a6 + 16) = v14;
      }

      else
      {
        while (1)
        {
          if (*(_DWORD *)a6) {
            break;
          }
          unint64_t v8 = 0;
          char v7 = 0LL;
          unint64_t v14 = 0;
          if (++v96 == v98) {
            goto LABEL_75;
          }
        }
      }

      return this;
    default:
      unint64_t v14 = 0;
      goto LABEL_75;
  }

              unint64_t v134 = 0;
              goto LABEL_182;
            }

            if (v72 == 103)
            {
              __src = (char *)v57 + 1;
              __len = v58 - 1;
              if (!v73 || !__len || *(_BYTE *)__src != 95) {
                goto LABEL_3;
              }
              uint64_t v74 = v73;
              uint64_t v75 = v13;
              __src = (char *)__src + 1;
              --__len;
              uint64_t v76 = v185;
              uint64_t v77 = 1LL;
              goto LABEL_154;
            }

            if (v58 < 2 || *v57 != 27750)
            {
              if (v72 != 115) {
                goto LABEL_3;
              }
              __src = (char *)v57 + 1;
              __len = v58 - 1;
              if (v58 == 1) {
                goto LABEL_3;
              }
              if (*((_BYTE *)v57 + 1) != 101) {
                goto LABEL_3;
              }
              __src = v57 + 1;
              __len = v58 - 2;
              if (v58 == 2) {
                goto LABEL_3;
              }
              uint64_t v81 = *((unsigned __int8 *)v57 + 2);
              memset(&v186, 0, sizeof(v186));
              if (v81 == 48) {
                uint64_t v82 = "u8";
              }
              else {
                uint64_t v82 = v13;
              }
              std::string::append(&v186, v82);
              uint64_t v83 = __src;
              if (__len) {
                uint64_t v83 = (char *)__src + 1;
              }
              uint64_t v84 = __len - (__len != 0);
              __src = v83;
              __len = v84;
              if (v84)
              {
                if (*v83 == 118)
                {
                  __src = v83 + 1;
                  __len = v84 - 1;
                  if (v85)
                  {
                    if (__len && *(_BYTE *)__src == 95)
                    {
                      uint64_t v86 = v85;
                      __src = (char *)__src + 1;
                      --__len;
                      uint64_t v87 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  4LL);
                      swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v87, v185, v88, v89);
                      unint64_t v178 = v185;
                      if ((v186.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                        uint64_t v90 = &v186;
                      }
                      else {
                        uint64_t v90 = (std::string *)v186.__r_.__value_.__r.__words[0];
                      }
                      if ((v186.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                        uint64_t v91 = v186.__r_.__value_.__s.__size_;
                      }
                      else {
                        uint64_t v91 = v186.__r_.__value_.__l.__size_;
                      }
                      if (v91)
                      {
                        uint64_t v92 = v185;
                        uint64_t v93 = (char *)*((void *)v185 + 1);
                        if (!v93 || (unint64_t)&v93[v91] > *((void *)v185 + 2))
                        {
                          unint64_t v94 = 2LL * *((void *)v185 + 4);
                          if (v94 <= v91 + 1) {
                            unint64_t v94 = v91 + 1;
                          }
                          *((void *)v185 + 4) = v94;
                          unint64_t v95 = v94 + 8;
                          unint64_t v96 = malloc(v94 + 8);
                          uint64_t v92 = v178;
                          char *v96 = *((void *)v178 + 3);
                          uint64_t v93 = (char *)(v96 + 1);
                          *((void *)v178 + 2) = (char *)v96 + v95;
                          *((void *)v178 + 3) = v96;
                        }

                        *((void *)v92 + 1) = &v93[v91];
                        unint64_t v97 = (uint64_t)v93;
                        memmove(v93, v90, v91);
                      }

                      else
                      {
                        unint64_t v97 = 0LL;
                      }

                      Swift::Int v150 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v178,  81,  v97,  v91);
                      swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v150, v185, v151, v152);
                      unint64_t v179 = v185;
                      unint64_t v143 = *(void *)(v86 + 8);
                      if (v143)
                      {
                        Swift::Int v153 = *(const void **)v86;
                        uint64_t v154 = (char *)*((void *)v185 + 1);
                        if (!v154 || (unint64_t)&v154[v143] > *((void *)v185 + 2))
                        {
                          int64_t v155 = 2LL * *((void *)v185 + 4);
                          if (v155 <= v143 + 1) {
                            int64_t v155 = v143 + 1;
                          }
                          *((void *)v185 + 4) = v155;
                          unint64_t v156 = v155 + 8;
                          int64_t v157 = malloc(v155 + 8);
                          *int64_t v157 = *((void *)v179 + 3);
                          uint64_t v154 = (char *)(v157 + 1);
                          *((void *)v179 + 2) = (char *)v157 + v156;
                          *((void *)v179 + 3) = v157;
                        }

                        *((void *)v179 + 1) = &v154[v143];
                        memmove(v154, v153, v143);
                      }

                      else
                      {
                        uint64_t v154 = 0LL;
                      }

                      uint64_t v148 = v179;
                      uint64_t v149 = (uint64_t)v154;
LABEL_215:
                      char v158 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v148,  81,  v149,  v143);
                      swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v158, v185, v159, v160);
                      unint64_t v134 = 1;
                      unint64_t v13 = "u16";
                      goto LABEL_182;
                    }
                  }
                }
              }

              goto LABEL_181;
            }

            int8x16_t v131 = (unsigned __int8 *)(v57 + 1);
            int8x16_t v132 = v58 - 2;
            __src = v131;
            __len = v58 - 2;
            memset(&v186, 0, sizeof(v186));
            if (v58 < 3) {
              goto LABEL_181;
            }
            while (1)
            {
              uint64_t v133 = *v131;
              if (v133 == 95) {
                break;
              }
              std::string::push_back(&v186, v133);
              int8x16_t v131 = (unsigned __int8 *)__src;
              if (__len) {
                int8x16_t v131 = (unsigned __int8 *)__src + 1;
              }
              int8x16_t v132 = __len - (__len != 0);
              __src = v131;
              __len = v132;
              if (!v132) {
                goto LABEL_181;
              }
            }

            if (v132)
            {
              __src = v131 + 1;
              __len = v132 - 1;
              unint64_t v138 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  3LL);
              swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v138, v185, v139, v140);
              unint64_t v141 = v185;
              if ((v186.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                uint64_t v142 = &v186;
              }
              else {
                uint64_t v142 = (std::string *)v186.__r_.__value_.__r.__words[0];
              }
              if ((v186.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                unint64_t v143 = v186.__r_.__value_.__s.__size_;
              }
              else {
                unint64_t v143 = v186.__r_.__value_.__l.__size_;
              }
              if (v143)
              {
                unint64_t v144 = (char *)*((void *)v185 + 1);
                if (!v144 || (unint64_t)&v144[v143] > *((void *)v185 + 2))
                {
                  uint64_t v145 = 2LL * *((void *)v185 + 4);
                  if (v145 <= v143 + 1) {
                    uint64_t v145 = v143 + 1;
                  }
                  *((void *)v185 + 4) = v145;
                  uint64_t v146 = v145 + 8;
                  unint64_t v147 = malloc(v145 + 8);
                  *unint64_t v147 = *((void *)v141 + 3);
                  unint64_t v144 = (char *)(v147 + 1);
                  *((void *)v141 + 2) = (char *)v147 + v146;
                  *((void *)v141 + 3) = v147;
                }

                *((void *)v141 + 1) = &v144[v143];
                memmove(v144, v142, v143);
              }

              else
              {
                unint64_t v144 = 0LL;
              }

              uint64_t v148 = v141;
              uint64_t v149 = (uint64_t)v144;
              goto LABEL_215;
            }

            unint64_t v134 = 0;
LABEL_182:
            unint64_t v3 = 0LL;
            if ((v134 & 1) == 0) {
              goto LABEL_4;
            }
          }
        }

      case 'g':
        unint64_t v15 = 91;
        break;
      case 'r':
        unint64_t v15 = 92;
        break;
      default:
        goto LABEL_3;
    }

    __src = v11 + 1;
    __len = v12 - 1;
    uint64_t v16 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(v185, v15);
    unint64_t v24 = __len;
    if (!__len)
    {
      Swift::String::Index v30 = v185;
      unint64_t v31 = 4294967294LL;
      goto LABEL_33;
    }

    unint64_t v25 = (char *)__src;
    unint64_t v26 = *(unsigned __int8 *)__src;
    if (v26 != 113)
    {
      Swift::String::Index v30 = v185;
      goto LABEL_32;
    }

    __src = (char *)__src + 1;
    --__len;
    Swift::String::Index v27 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v185, 217);
    swift::Demangle::__runtime::Node::addChild(v16, v27, v185, v28, v29);
    unint64_t v24 = __len;
    Swift::String::Index v30 = v185;
    if (__len)
    {
      unint64_t v25 = (char *)__src;
      LOBYTE(v26) = *(_BYTE *)__src;
LABEL_32:
      __src = v25 + 1;
      __len = v24 - 1;
      unint64_t v31 = ((char)v26 - 48);
      goto LABEL_33;
    }

    unint64_t v31 = 4294967294LL;
LABEL_33:
    unint64_t v34 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v30, 216, v31);
    while (1)
    {
      swift::Demangle::__runtime::Node::addChild(v16, v34, v185, v32, v33);
      unint64_t v37 = __len;
      if (__len)
      {
        uint64_t v38 = (char *)__src;
        if (*(_BYTE *)__src == 95) {
          break;
        }
      }

      unint64_t v34 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v185, 94);
      if (!v3) {
        goto LABEL_4;
      }
      char v39 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(v185, 232);
      swift::Demangle::__runtime::Node::addChild(v39, (swift::Demangle::__runtime::Node *)v3, v185, v40, v41);
      if (!v39) {
        goto LABEL_3;
      }
      while (1)
      {
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v34,  (swift::Demangle::__runtime::Node *)v39,  v185,  v42,  v43);
        if (__len)
        {
          if (*(_BYTE *)__src == 95) {
            break;
          }
        }

        unint64_t v3 = 0LL;
        if (!v39) {
          goto LABEL_4;
        }
      }

      __src = (char *)__src + 1;
      --__len;
    }

LABEL_207:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v223, v222);
  swift_bridgeObjectRelease_n(v148, 4LL);
  if ((v148 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v148);
    _StringGuts._foreignAppendInPlace(_:)(v153, v148, 0LL, v145);
    swift_bridgeObjectRelease_n(v148, 2LL);
    unint64_t v203 = v373;
    goto LABEL_219;
  }

  unint64_t v203 = v373;
  if (v54)
  {
    swift_bridgeObjectRelease_n(v148, 2LL);
    uint64_t v375 = v153;
    unint64_t v376 = v148 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v228 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, object, (uint64_t)&v375, object);
    _StringGuts.appendInPlace(_:isASCII:)(v228, v229, (v148 & 0x4000000000000000LL) != 0);
    uint64_t v230 = v148;
    goto LABEL_218;
  }

  if ((v153 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v148);
    id v336 = (id)((v148 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v337 = v372;
    uint64_t v338 = v372;
    goto LABEL_294;
  }

  id v336 = _StringObject.sharedUTF8.getter(v153, v148);
  uint64_t v338 = v368;
  swift_bridgeObjectRelease(v148);
  if (v338 < v372) {
    goto LABEL_337;
  }
  uint64_t v337 = v372;
  unint64_t v203 = v373;
LABEL_294:
  unint64_t v339 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v337, (uint64_t)v336, v338);
  _StringGuts.appendInPlace(_:isASCII:)(v339, v340, v153 < 0);
  swift_bridgeObjectRelease_n(v148, 2LL);
LABEL_219:
  Swift::String v256 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", intValue: ", 0xDuLL, 1);
  int64_t v257 = v377._object;
  unint64_t v258 = ((unint64_t)v377._object >> 56) & 0xF;
  if (!v258 && (v377._countAndFlagsBits & ~(uint64_t)v377._object & 0x2000000000000000LL) == 0)
  {
    Swift::String v377 = v256;
    swift_bridgeObjectRelease((uint64_t)v257);
    goto LABEL_232;
  }

  if (((uint64_t)v377._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v256._object & 0x2000000000000000LL) != 0)
    {
      unint64_t v260 = specialized _SmallString.init(_:appending:)( v377._countAndFlagsBits,  (unint64_t)v377._object,  v256._countAndFlagsBits,  (unint64_t)v256._object);
      if ((v254 & 1) != 0) {
        goto LABEL_230;
      }
      uint64_t v261 = v260;
      unint64_t v262 = v257;
      swift_bridgeObjectRelease((uint64_t)v256._object);
      swift_bridgeObjectRelease((uint64_t)v377._object);
      v377._uint64_t countAndFlagsBits = v261;
      v377._unint64_t object = v262;
      goto LABEL_232;
    }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v13, v14);
          swift_bridgeObjectRelease_n(v183, 4LL);
          if ((v183 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v183);
            _StringGuts._foreignAppendInPlace(_:)(v184, v183, 0LL, countAndFlagsBits);
            swift_bridgeObjectRelease_n(v183, 2LL);
LABEL_213:
            uint64_t countAndFlagsBits = (unint64_t)v265;
          }

          else
          {
            if (object)
            {
              swift_bridgeObjectRelease_n(v183, 2LL);
              unint64_t v266 = v184;
              unint64_t v267 = v183 & 0xFFFFFFFFFFFFFFLL;
              Swift::String::Index v216 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v183) & 0xF,  (uint64_t)&v266,  HIBYTE(v183) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v216, v217, (v183 & 0x4000000000000000LL) != 0);
              swift_bridgeObjectRelease(v183);
              goto LABEL_213;
            }

            if ((v184 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v183);
              unint64_t v238 = (id)((v183 & 0xFFFFFFFFFFFFFFFLL) + 32);
              Swift::String::Index v239 = v184 & 0xFFFFFFFFFFFFLL;
              goto LABEL_238;
            }

            unint64_t v238 = _StringObject.sharedUTF8.getter(v184, v183);
            Swift::String::Index v239 = v253;
            swift_bridgeObjectRelease(v183);
            if (v239 < v92) {
LABEL_263:
            }
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
LABEL_238:
            uint64_t countAndFlagsBits = (unint64_t)v265;
            Swift::String::Index v240 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v184 & 0xFFFFFFFFFFFFLL,  (uint64_t)v238,  v239);
            _StringGuts.appendInPlace(_:isASCII:)(v240, v241, v184 < 0);
            swift_bridgeObjectRelease_n(v183, 2LL);
          }

    Swift::String::Index v170 = 266LL;
LABEL_209:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v170,  0);
  }

  while (1)
  {
    unint64_t v143 = v45;
    swift_bridgeObjectRetain_n(v7._rawBits, 3LL, v45, (char *)v46);
    v144._Swift::UInt64 rawBits = v11 & 0xFFFFFFFFFFFF0000LL | 1;
    v145._Swift::UInt64 rawBits = v15 & 0xFFFFFFFFFFFF0000LL | 1;
    v146._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v144, v145, v143, v7._rawBits);
    if (v146._rawBits < 0x10000) {
      v146._rawBits |= 3;
    }
    unint64_t v13 = specialized Collection.count.getter(v146, v147, v143, v7._rawBits);
    swift_bridgeObjectRelease(v7._rawBits);
    unint64_t v9 = v182;
    unint64_t v8 = v183;
    if ((v183 & 0x1000000000000000LL) == 0) {
      goto LABEL_44;
    }
LABEL_149:
    uint64_t v148 = String.UTF8View._foreignCount()();
    uint64_t v50 = v148 + v13;
    if (!__OFADD__(v148, v13)) {
      goto LABEL_49;
    }
LABEL_151:
    __break(1u);
LABEL_152:
    swift_bridgeObjectRetain_n(v15, 3LL, v48, (char *)v49);
    v149._Swift::UInt64 rawBits = v11 & 0xFFFFFFFFFFFF0000LL | 1;
    v150._Swift::UInt64 rawBits = v8 & 0xFFFFFFFFFFFF0000LL | 1;
    v151._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v149, v150, v179, v15);
    if (v151._rawBits < 0x10000) {
      v151._rawBits |= 3;
    }
    v7._Swift::UInt64 rawBits = specialized Collection.count.getter(v151, v152, v179, v15);
    swift_bridgeObjectRelease(v9);
    uint64_t v93 = v15;
LABEL_75:
    swift_bridgeObjectRelease(v9);
    swift_bridgeObjectRelease(v93);
    unint64_t v94 = startingAt;
    if ((v9 & 0x1000000000000000LL) != 0) {
      unint64_t v94 = String.UTF8View._foreignCount()();
    }
    swift_bridgeObjectRelease(v9);
    unint64_t v95 = __OFADD__(v94, v7._rawBits);
    unint64_t v96 = v94 + v7._rawBits;
    if (v95)
    {
      __break(1u);
LABEL_156:
      v6._Swift::UInt64 rawBits = v6._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v6)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v7._rawBits & 1) != 0) {
        goto LABEL_18;
      }
LABEL_157:
      v7._Swift::UInt64 rawBits = v7._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v7)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if (!(_DWORD)v15) {
        goto LABEL_158;
      }
      goto LABEL_19;
    }

    if ((v13 & ~v9 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v97 = v183;
      int64x2_t v98 = _StringGuts.nativeUnusedCapacity.getter(v182, v183);
      char v20 = v173;
      if ((v99 & 1) != 0) {
        goto LABEL_208;
      }
      if (v96 >= 16 || (v97 & 0x2000000000000000LL) == 0 && v98 >= (uint64_t)v7._rawBits)
      {
LABEL_86:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v96, v7._rawBits);
        swift_bridgeObjectRelease(v15);
        unint64_t v11 = a4;
        if ((v15 & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v179, v15, v6._rawBits, v12);
          swift_bridgeObjectRelease(v15);
          uint64_t v21 = v172;
        }

        else if ((v15 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v15);
          int8x8_t v125 = HIBYTE(v15) & 0xF;
          unint64_t v180 = v179;
          uint64_t v181 = v15 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v21 = v172;
          if (v125 < v12) {
            goto LABEL_185;
          }
          int8x16_t v126 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v6._rawBits, v12, (uint64_t)&v180, v125);
          _StringGuts.appendInPlace(_:isASCII:)(v126, v127, (v15 & 0x4000000000000000LL) != 0);
        }

        else
        {
          if ((v179 & 0x1000000000000000LL) != 0)
          {
            int8x16_t v100 = (id)((v15 & 0xFFFFFFFFFFFFFFFLL) + 32);
            int64x2_t v101 = v179 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            int8x16_t v100 = _StringObject.sharedUTF8.getter(v179, v15);
            int64x2_t v101 = v166;
          }

          uint64_t v21 = v172;
          int64x2_t v102 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v6._rawBits, v12, (uint64_t)v100, v101);
          _StringGuts.appendInPlace(_:isASCII:)(v102, v103, v179 < 0);
          swift_bridgeObjectRelease(v15);
        }

        goto LABEL_100;
      }
    }

    else
    {
      char v20 = v173;
      if (v96 > 15) {
        goto LABEL_86;
      }
      unint64_t v97 = v183;
    }

    swift_bridgeObjectRelease(v15);
    int64x2_t v104 = v182;
    swift_bridgeObjectRetain(v97, v105, v106, v107);
    int64x2_t v108 = _StringGuts._convertedToSmall()(v104, v97);
    int8x16_t v110 = v109;
    swift_bridgeObjectRelease(v97);
    v111._Swift::UInt64 rawBits = v11 & 0xFFFFFFFFFFFF0000LL | 1;
    v112._Swift::UInt64 rawBits = v8 & 0xFFFFFFFFFFFF0000LL | 1;
    v113._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v111, v112, v179, v15);
    if (v113._rawBits < 0x10000) {
      v113._rawBits |= 3;
    }
    uint64x2_t v115 = specialized String.init(_:)(v113, v114, v179, v15);
    v6._Swift::UInt64 rawBits = v116;
    swift_bridgeObjectRelease(v15);
    uint32x4_t v117 = _StringGuts._convertedToSmall()(v115, v6._rawBits);
    int8x16_t v119 = v118;
    swift_bridgeObjectRelease(v6._rawBits);
    uint16x8_t v120 = specialized _SmallString.init(_:appending:)(v108, v110, v117, v119);
    if ((v122 & 1) != 0) {
      goto LABEL_207;
    }
    int8x16_t v123 = v120;
    int8x16_t v124 = v121;
    swift_bridgeObjectRelease(v97);
    char v182 = v123;
    uint64_t v183 = v124;
    uint64_t v21 = v172;
    unint64_t v11 = a4;
LABEL_100:
    uint64_t v12 = v182;
    unint64_t v15 = v183;
    swift_bridgeObjectRelease(v19[3]._rawBits);
    v19[2]._Swift::UInt64 rawBits = v12;
    v19[3]._Swift::UInt64 rawBits = v15;
LABEL_115:
    if (!__OFSUB__(startingAt, v11)) {
      break;
    }
    __break(1u);
  }

  v7._Swift::UInt64 rawBits = v19->_rawBits;
  unint64_t v8 = v19->_rawBits >> 16;
  v6._Swift::UInt64 rawBits = startingAt - v11 + v20 - v21;
  uint64_t v21 = v6._rawBits + (v19[1]._rawBits >> 16);
  uint64_t v136 = (v19->_rawBits >> 8) & 0x3F;
  if (v136)
  {
    if (v136 + v8 < v20) {
      goto LABEL_140;
    }
  }

  else if (v8 < v20)
  {
    goto LABEL_140;
  }

  if (v8 == v21)
  {
    uint64_t v137 = 0LL;
    unint64_t v138 = v7._rawBits & 0xFFFFFFFFFFFF0000LL;
    goto LABEL_134;
  }

  if ((v15 & 0x1000000000000000LL) != 0) {
    goto LABEL_179;
  }
  if ((v15 & 0x2000000000000000LL) != 0)
  {
    char v182 = v12;
    uint64_t v183 = v15 & 0xFFFFFFFFFFFFFFLL;
    if (v8 + 1 != (HIBYTE(v15) & 0xF))
    {
      unint64_t v141 = *(unsigned __int16 *)((char *)&v182 + v8);
      goto LABEL_131;
    }

      unint64_t v169 = 266LL;
LABEL_209:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v169,  0);
    }
  }

  else if (v82 <= 15)
  {
    uint64_t v83 = v180;
    goto LABEL_93;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v82, v4._rawBits);
  swift_bridgeObjectRelease(v8);
  if ((v8 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(startingAt, v8, v174, v9);
    swift_bridgeObjectRelease(v8);
    int64_t v17 = v171;
    uint64_t v16 = v172;
  }

  else
  {
    if ((v8 & 0x2000000000000000LL) == 0)
    {
      if ((startingAt & 0x1000000000000000LL) != 0)
      {
        uint64_t v86 = (id)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v87 = startingAt & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v86 = _StringObject.sharedUTF8.getter(startingAt, v8);
        uint64_t v87 = v163;
      }

      int64_t v17 = v171;
      uint64_t v16 = v172;
      if (v87 >= (uint64_t)v9)
      {
        uint64_t v88 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v174, v9, (uint64_t)v86, v87);
        _StringGuts.appendInPlace(_:isASCII:)(v88, v89, startingAt < 0);
        swift_bridgeObjectRelease(v8);
        goto LABEL_100;
      }

                LOBYTE(v24) = 11;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 6u:
              if (v11 < 0xA)
              {
                unint64_t v24 = 9;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                unint64_t v25 = 9;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_210;
                }
                goto LABEL_226;
              }

              unint64_t v25 = 9;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  uint64_t v18 = 9;
                  goto LABEL_9;
                }

        uint64_t v90 = v63;
        if (v89 >= 2) {
          uint64_t v90 = (uint64_t *)*v63;
        }
        uint64_t v91 = v90[v86];
LABEL_212:
        uint64_t v92 = *(unsigned __int16 *)(v91 + 16);
        if ((v92 - 275) >= 2)
        {
          if (v92 == 101)
          {
            unint64_t v95 = *(void *)(v91 + 8);
            if (v95 > 0x7FFFFFFFFFFFFFF7LL) {
              goto LABEL_352;
            }
            unint64_t v96 = *(const void **)v91;
            if (v95 >= 0x17)
            {
              int64x2_t v98 = (v95 & 0xFFFFFFFFFFFFFFF8LL) + 8;
              if ((v95 | 7) != 0x17) {
                int64x2_t v98 = v95 | 7;
              }
              int8x16_t v99 = v98 + 1;
              p_dst = (std::string *)operator new(v98 + 1);
              __dst.__r_.__value_.__l.__size_ = v95;
              __dst.__r_.__value_.__l.__cap_ = v99 | 0x8000000000000000LL;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
            }

            else
            {
              __dst.__r_.__value_.__s.__size_ = *(void *)(v91 + 8);
              p_dst = &__dst;
              if (!v95)
              {
LABEL_226:
                p_dst->__r_.__value_.__s.__data_[v95] = 0;
                int8x16_t v100 = std::string::append(&__dst, ": ");
                int64x2_t v101 = v100->__r_.__value_.__l.__cap_;
                *(_OWORD *)&v151.__r_.__value_.__l.__data_ = *(_OWORD *)&v100->__r_.__value_.__l.__data_;
                v151.__r_.__value_.__l.__cap_ = v101;
                v100->__r_.__value_.__l.__size_ = 0LL;
                v100->__r_.__value_.__l.__cap_ = 0LL;
                v100->__r_.__value_.__r.__words[0] = 0LL;
                uint64_t v87 = v153;
                if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)v153[1] - (_BYTE *)*v153) >> 3) <= v86)
                {
                  v149.__r_.__value_.__s.__size_ = 9;
                  strcpy((char *)&v149, "<unknown>");
                }

                else
                {
                  int64x2_t v102 = (char *)*v153 + v85;
                  if (v102[23] < 0)
                  {
                    std::string::__init_copy_ctor_external( &v149,  *(const std::string::value_type **)v102,  *((void *)v102 + 1));
                  }

                  else
                  {
                    int64x2_t v103 = *(_OWORD *)v102;
                    v149.__r_.__value_.__l.__cap_ = *((void *)v102 + 2);
                    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v103;
                  }
                }

                if ((v149.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  int8x16_t v110 = &v149;
                }
                else {
                  int8x16_t v110 = (std::string *)v149.__r_.__value_.__r.__words[0];
                }
                if ((v149.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  uint8x8_t v111 = v149.__r_.__value_.__s.__size_;
                }
                else {
                  uint8x8_t v111 = v149.__r_.__value_.__l.__size_;
                }
                uint16x8_t v112 = std::string::append(&v151, (const std::string::value_type *)v110, v111);
                uint32x4_t v113 = v112->__r_.__value_.__l.__cap_;
                *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
                __p.__r_.__value_.__l.__cap_ = v113;
                v112->__r_.__value_.__l.__size_ = 0LL;
                v112->__r_.__value_.__l.__cap_ = 0LL;
                v112->__r_.__value_.__r.__words[0] = 0LL;
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  uint64x2_t v114 = &__p;
                }
                else {
                  uint64x2_t v114 = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  uint64x2_t v115 = __p.__r_.__value_.__s.__size_;
                }
                else {
                  uint64x2_t v115 = __p.__r_.__value_.__l.__size_;
                }
                std::string::append(&v157, (const std::string::value_type *)v114, v115);
                if ((char)__p.__r_.__value_.__s.__size_ < 0)
                {
                  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_262:
LABEL_268:
                  operator delete(v151.__r_.__value_.__l.__data_);
                  if (((char)__dst.__r_.__value_.__s.__size_ & 0x80000000) == 0)
                  {
LABEL_264:
                    if (v64 - 1 != v86) {
                      std::string::append(&v157, ", ");
                    }
                    goto LABEL_201;
                  }
                }

                else
                {
LABEL_267:
                  operator delete(v149.__r_.__value_.__l.__data_);
LABEL_263:
                }

                operator delete(__dst.__r_.__value_.__l.__data_);
                goto LABEL_264;
              }
            }

            memmove(p_dst, v96, v95);
            goto LABEL_226;
          }
        }

        else
        {
          if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)v87[1] - (_BYTE *)*v87) >> 3) <= v86)
          {
            v151.__r_.__value_.__s.__size_ = 9;
            strcpy((char *)&v151, "<unknown>");
          }

          else
          {
            uint64_t v93 = (char *)*v87 + v85;
            if (v93[23] < 0)
            {
              std::string::__init_copy_ctor_external( &v151,  *(const std::string::value_type **)v93,  *((void *)v93 + 1));
            }

            else
            {
              unint64_t v94 = *(_OWORD *)v93;
              v151.__r_.__value_.__l.__cap_ = *((void *)v93 + 2);
              *(_OWORD *)&v151.__r_.__value_.__l.__data_ = v94;
            }
          }

          if (v161 >= 0) {
            int64x2_t v104 = (const std::string::value_type *)&v159;
          }
          else {
            int64x2_t v104 = v159;
          }
          if (v161 >= 0) {
            int64x2_t v105 = v161;
          }
          else {
            int64x2_t v105 = v160;
          }
          int8x16_t v106 = std::string::insert(&v151, 0LL, v104, v105);
          unint64_t v107 = v106->__r_.__value_.__l.__cap_;
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__l.__cap_ = v107;
          v106->__r_.__value_.__l.__size_ = 0LL;
          v106->__r_.__value_.__l.__cap_ = 0LL;
          v106->__r_.__value_.__r.__words[0] = 0LL;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int64x2_t v108 = &__p;
          }
          else {
            int64x2_t v108 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int8x16_t v109 = __p.__r_.__value_.__s.__size_;
          }
          else {
            int8x16_t v109 = __p.__r_.__value_.__l.__size_;
          }
          std::string::append(&v157, (const std::string::value_type *)v108, v109);
        }

  if ((v86 & 1) != 0 || !v34 || v84 && !*(_BYTE *)(a1 + 33)) {
    return v34;
  }
  uint64_t v80 = *((unsigned __int16 *)v17 + 8);
  uint64_t v81 = " of ";
  if (((v80 - 125) > 0x36 || ((1LL << (v80 - 125)) & 0x60000000000001LL) == 0)
    && v80 != 33)
  {
    uint64_t v81 = " in ";
  }

  std::string::append((std::string *)a1, v81, 4uLL);
  return 0LL;
}

LABEL_227:
    uint64_t v259 = v256._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_231;
  }

            v211 |= v210 << 8;
            while (1)
            {
              void *v274 = v211 | 5;
              if (_StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v211 | 5))) {
                void *v274 = v211 | 7;
              }
              unint64_t v35 = v197 + v204;
              if (!__OFADD__(v197, v204)) {
                break;
              }
              __break(1u);
LABEL_249:
              char v251 = (char *)_StringObject.sharedUTF8.getter(v211, v205);
LABEL_217:
              if (v197 + 1 == v252) {
                goto LABEL_226;
              }
              if (!v251) {
                goto LABEL_242;
              }
              Swift::Int v253 = *(unsigned __int16 *)&v251[v197];
LABEL_224:
              if (v253 != 2573 && (v253 & 0x80808080) == 0) {
                goto LABEL_226;
              }
LABEL_246:
              unint64_t v210 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v197);
              uint64_t v211 = v197 << 16;
              if (v210 <= 63) {
                goto LABEL_227;
              }
            }

            uint64_t v43 = v274;
            goto LABEL_200;
          }

          uint64_t result = (int8x16_t *)v29;
          break;
        case 0xFF:
          continue;
        default:
          goto LABEL_8;
      }
    }

    return result;
  }

LABEL_230:
  uint64_t v259 = ((unint64_t)v256._object >> 56) & 0xF;
LABEL_231:
  swift_bridgeObjectRetain((unint64_t)v256._object, (uint64_t)v257, v254, v255);
  _StringGuts.append(_:)(v256._countAndFlagsBits, (unint64_t)v256._object, 0LL, v259);
  swift_bridgeObjectRelease_n((uint64_t)v256._object, 2LL);
LABEL_232:
  uint64_t v265 = v377._countAndFlagsBits;
  unint64_t v266 = (unint64_t)v377._object;
  unint64_t v267 = ((unint64_t)v377._object >> 56) & 0xF;
  unint64_t v268 = v377._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v268 && (v377._countAndFlagsBits & ~(uint64_t)v377._object & 0x2000000000000000LL) == 0)
  {
    v377._uint64_t countAndFlagsBits = v374;
    v377._unint64_t object = (void *)v203;
    uint64_t v284 = v266;
    goto LABEL_267;
  }

  uint64_t v269 = v203 & 0x2000000000000000LL;
  uint64_t v270 = HIBYTE(v203) & 0xF;
  unint64_t v271 = v267 + v270;
  if (v267 + v270 <= 0xF)
  {
    if (v270)
    {
      char v323 = 0;
      unint64_t v324 = 0LL;
      do
      {
        unint64_t v325 = v267 + v324;
        unint64_t v326 = v324 + 1;
        if (v324 >= 8) {
          unint64_t v327 = v203;
        }
        else {
          unint64_t v327 = v374;
        }
        unint64_t v328 = v327 >> (v323 & 0x38);
        char v329 = (8 * v267 + v323) & 0x38;
        uint64_t v330 = (-255LL << v329) - 1;
        unint64_t v331 = (unint64_t)v328 << v329;
        unint64_t v332 = v331 | v330 & v266;
        unint64_t v333 = v331 | v330 & v265;
        if (v325 < 8) {
          uint64_t v265 = v333;
        }
        else {
          unint64_t v266 = v332;
        }
        v323 += 8;
        unint64_t v324 = v326;
      }

      while (v270 != v326);
    }

    swift_bridgeObjectRelease(v203);
    unint64_t v334 = 0xA000000000000000LL;
    if (!(v265 & 0x8080808080808080LL | v266 & 0x80808080808080LL)) {
      unint64_t v334 = 0xE000000000000000LL;
    }
    unint64_t v335 = (void *)(v334 & 0xFF00000000000000LL | (v271 << 56) | v266 & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v377._object);
    v377._uint64_t countAndFlagsBits = v265;
    v377._unint64_t object = v335;
    goto LABEL_299;
  }

  uint64_t v269 = 1LL;
LABEL_240:
  uint64_t v272 = v374 & 0xFFFFFFFFFFFFLL;
  if (v269) {
    uint64_t v273 = HIBYTE(v203) & 0xF;
  }
  else {
    uint64_t v273 = v374 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v203, 2LL, v263, v264);
  if ((v203 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(v203, 4LL, v274, v275);
    Swift::Int v276 = v273;
    if ((v266 & 0x1000000000000000LL) == 0) {
      goto LABEL_245;
    }
LABEL_327:
    Swift::Int v366 = String.UTF8View._foreignCount()();
    int64_t v277 = v366 + v276;
    if (!__OFADD__(v366, v276)) {
      goto LABEL_250;
    }
    do
    {
LABEL_248:
      __break(1u);
LABEL_249:
      uint64_t v278 = HIBYTE(v266) & 0xF;
      int64_t v277 = v278 + v276;
    }

    while (__OFADD__(v278, v276));
    goto LABEL_250;
  }

  swift_bridgeObjectRetain_n(v203, 5LL, v274, v275);
  v362._Swift::UInt64 rawBits = 1LL;
  v363._Swift::UInt64 rawBits = (v273 << 16) | 1;
  v364._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v362, v363, v374, v203);
  if (v364._rawBits < 0x10000) {
    v364._rawBits |= 3;
  }
  Swift::Int v276 = specialized Collection.count.getter(v364, v365, v374, v203);
  swift_bridgeObjectRelease(v203);
  uint64_t v265 = v377._countAndFlagsBits;
  unint64_t v266 = (unint64_t)v377._object;
LABEL_245:
  if ((v266 & 0x2000000000000000LL) != 0) {
    goto LABEL_249;
  }
  int64_t v277 = (v265 & 0xFFFFFFFFFFFFLL) + v276;
  if (__OFADD__(v265 & 0xFFFFFFFFFFFFLL, v276)) {
    goto LABEL_248;
  }
LABEL_250:
  if ((v265 & ~v266 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v266 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v277 > 15) {
      goto LABEL_256;
    }
LABEL_260:
    swift_bridgeObjectRelease_n(v203, 5LL);
    unint64_t v285 = v377._countAndFlagsBits;
    uint64_t v286 = v377._object;
    swift_bridgeObjectRetain((unint64_t)v377._object, v287, v288, v289);
    unint64_t v290 = _StringGuts._convertedToSmall()(v285, (unint64_t)v286);
    unint64_t v292 = v291;
    swift_bridgeObjectRelease((uint64_t)v286);
    v293._Swift::UInt64 rawBits = (v273 << 16) | 1;
    v294._Swift::UInt64 rawBits = 1LL;
    v295._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v294, v293, v374, v203);
    if (v295._rawBits < 0x10000) {
      v295._rawBits |= 3;
    }
    unint64_t v297 = specialized String.init(_:)(v295, v296, v374, v203);
    unint64_t v299 = v298;
    swift_bridgeObjectRelease(v203);
    unint64_t v300 = _StringGuts._convertedToSmall()(v297, v299);
    unint64_t v302 = v301;
    swift_bridgeObjectRelease(v299);
    unint64_t v303 = specialized _SmallString.init(_:appending:)(v290, v292, v300, v302);
    if ((v305 & 1) == 0)
    {
      uint64_t v306 = v303;
      uint64_t v307 = v304;
      swift_bridgeObjectRelease(v203);
      uint64_t v284 = (uint64_t)v377._object;
      v377._uint64_t countAndFlagsBits = v306;
      v377._unint64_t object = v307;
LABEL_267:
      swift_bridgeObjectRelease(v284);
      goto LABEL_299;
    }

    goto LABEL_338;
  }

  unint64_t v279 = (unint64_t)v377._object;
  int64_t v280 = _StringGuts.nativeUnusedCapacity.getter(v377._countAndFlagsBits, (uint64_t)v377._object);
  if ((v281 & 1) != 0)
  {
LABEL_339:
    unint64_t v370 = 258LL;
LABEL_340:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v370,  0);
  }

  if (v277 <= 15 && ((v279 & 0x2000000000000000LL) != 0 || v280 < v276)) {
    goto LABEL_260;
  }
LABEL_256:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v277, v276);
  swift_bridgeObjectRelease_n(v203, 4LL);
  if ((v203 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v203);
    _StringGuts._foreignAppendInPlace(_:)(v374, v203, 0LL, v273);
  }

  else
  {
    if (v269)
    {
      swift_bridgeObjectRelease_n(v203, 2LL);
      uint64_t v375 = v374;
      unint64_t v376 = v203 & 0xFFFFFFFFFFFFFFLL;
      char v282 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v203) & 0xF,  (uint64_t)&v375,  HIBYTE(v203) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v282, v283, (v203 & 0x4000000000000000LL) != 0);
      uint64_t v284 = v203;
      goto LABEL_267;
    }

    uint64_t v341 = v374;
    if ((v374 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v203);
      id v342 = (id)((v203 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v343 = v374 & 0xFFFFFFFFFFFFLL;
      goto LABEL_297;
    }

    id v342 = _StringObject.sharedUTF8.getter(v374, v203);
    uint64_t v343 = v369;
    swift_bridgeObjectRelease(v203);
    if (v343 < v272) {
LABEL_337:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    unint64_t v203 = v373;
    uint64_t v341 = v374;
LABEL_297:
    Swift::String::Index v344 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v272, (uint64_t)v342, v343);
    _StringGuts.appendInPlace(_:isASCII:)(v344, v345, v341 < 0);
  }

  swift_bridgeObjectRelease_n(v203, 2LL);
LABEL_299:
  unint64_t v346 = v377._object;
  unint64_t v347 = ((unint64_t)v377._object >> 56) & 0xF;
  if (v347 || (v377._countAndFlagsBits & ~(uint64_t)v377._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v377._object & 0x2000000000000000LL) == 0
      || (unint64_t v348 = specialized _SmallString.init(_:appending:)( v377._countAndFlagsBits,  (unint64_t)v377._object,  0x29uLL,  0xE100000000000000LL),  (v308 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, (uint64_t)v346, v308, v309);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
    }

    else
    {
      uint64_t v349 = v348;
      Swift::String::Index v350 = v346;
      swift_bridgeObjectRelease(0xE100000000000000LL);
      swift_bridgeObjectRelease((uint64_t)v377._object);
      v377._uint64_t countAndFlagsBits = v349;
      v377._unint64_t object = v350;
    }
  }

  else
  {
    v377._uint64_t countAndFlagsBits = 41LL;
    v377._unint64_t object = (void *)0xE100000000000000LL;
    swift_bridgeObjectRelease((uint64_t)v346);
  }

  return v377._countAndFlagsBits;
}

      unint64_t v26 = 0;
      Swift::String::Index v27 = 0;
      Swift::String::Index v28 = 15;
      goto LABEL_231;
    }

uint64_t BinaryInteger.description.getter()
{
  return BinaryInteger._description(radix:uppercase:)(10LL, 0)._countAndFlagsBits;
}

uint64_t CodingKey.debugDescription.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 8LL))();
}

uint64_t KeyedEncodingContainerProtocol.encode(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainerProtocol.encode(_:forKey:)(a1, a2, a3, a4, a5);
}

{
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *inited;
  unint64_t AssociatedTypeWitness;
  void *boxed_opaque_existential_0Tm;
  void v19[9];
  uint64_t v20;
  swift_allocError( (uint64_t)&type metadata for EncodingError,  (uint64_t)&protocol witness table for EncodingError,  0LL,  0);
  uint64_t v10 = v9;
  v9[3] = &type metadata for Int128;
  unint64_t v11 = swift_allocObject((uint64_t)&unk_189B78168, 0x20uLL, 0xFuLL);
  *uint64_t v10 = v11;
  v11[2] = a1;
  v11[3] = a2;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 24))(a4, a5);
  unint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>);
  inited = swift_initStackObject(v13, v19);
  *((_OWORD *)inited + 1) = xmmword_1817FFC60;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  inited[7] = AssociatedTypeWitness;
  inited[8] = swift_getAssociatedConformanceWitness( a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  (uint64_t)&associated conformance descriptor for KeyedEncodingContainerProtocol.KeyedEncodingContainerProtocol.Key: CodingKey);
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  (*(void (**)(void *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( boxed_opaque_existential_0Tm,  a3,  AssociatedTypeWitness);
  char v20 = v12;
  specialized Array.append<A>(contentsOf:)( (unint64_t)inited,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
  v10[4] = v20;
  v10[5] = 0xD00000000000002ELL;
  v10[6] = 0x80000001818B56D0LL;
  v10[7] = 0LL;
  return swift_willThrow();
}

{
  return KeyedEncodingContainerProtocol.encode(_:forKey:)(a1, a2, a3, a4, a5);
}

{
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *inited;
  unint64_t AssociatedTypeWitness;
  void *boxed_opaque_existential_0Tm;
  void v19[9];
  uint64_t v20;
  swift_allocError( (uint64_t)&type metadata for EncodingError,  (uint64_t)&protocol witness table for EncodingError,  0LL,  0);
  uint64_t v10 = v9;
  v9[3] = &type metadata for UInt128;
  unint64_t v11 = swift_allocObject((uint64_t)&unk_189B78168, 0x20uLL, 0xFuLL);
  *uint64_t v10 = v11;
  v11[2] = a1;
  v11[3] = a2;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 24))(a4, a5);
  unint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>);
  inited = swift_initStackObject(v13, v19);
  *((_OWORD *)inited + 1) = xmmword_1817FFC60;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  inited[7] = AssociatedTypeWitness;
  inited[8] = swift_getAssociatedConformanceWitness( a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  (uint64_t)&associated conformance descriptor for KeyedEncodingContainerProtocol.KeyedEncodingContainerProtocol.Key: CodingKey);
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  (*(void (**)(void *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( boxed_opaque_existential_0Tm,  a3,  AssociatedTypeWitness);
  char v20 = v12;
  specialized Array.append<A>(contentsOf:)( (unint64_t)inited,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
  v10[4] = v20;
  v10[5] = 0xD00000000000002FLL;
  v10[6] = 0x80000001818B5700LL;
  v10[7] = 0LL;
  return swift_willThrow();
}

uint64_t KeyedEncodingContainerProtocol.encodeConditional<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return KeyedEncodingContainerProtocol.encodeConditional<A>(_:forKey:)(a1, a2, a5, a3, a6, a4);
}

{
  uint64_t v7;
  char v7 = a1;
  return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 168))( &v7,  a2,  a4,  a6,  a3,  a5);
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2, a3, a4);
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return result;
}

{
  if ((result & 0x100000000LL) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, float))(a4 + 64))(a2, a3, a4, *(float *)&result);
  }
  return result;
}

{
  if ((result & 0x100) == 0) {
    return (*(uint64_t (**)(void))(a4 + 80))();
  }
  return result;
}

{
  if ((result & 0x10000) == 0) {
    return (*(uint64_t (**)(void))(a4 + 88))();
  }
  return result;
}

{
  if ((result & 0x100000000LL) == 0) {
    return (*(uint64_t (**)(void))(a4 + 96))();
  }
  return result;
}

{
  if ((result & 0x100) == 0) {
    return (*(uint64_t (**)(void))(a4 + 128))();
  }
  return result;
}

{
  if ((result & 0x10000) == 0) {
    return (*(uint64_t (**)(void))(a4 + 136))();
  }
  return result;
}

{
  if ((result & 0x100000000LL) == 0) {
    return (*(uint64_t (**)(void))(a4 + 144))();
  }
  return result;
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2, a3, a4, a5);
}

{
  uint64_t result;
  if (a2) {
    return (*(uint64_t (**)(void))(a5 + 48))();
  }
  return result;
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4, a5);
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4, a5);
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4, a5);
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4, a5);
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4, a5);
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double))(a5 + 56))(a3, a4, a5, *(double *)&result);
  }
  return result;
}

{
  if ((a2 & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 72))(result, a3, a4, a5);
  }
  return result;
}

{
  if ((a2 & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 104))(result, a3, a4, a5);
  }
  return result;
}

{
  if ((a2 & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 120))(result, a3, a4, a5);
  }
  return result;
}

{
  if ((a2 & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 152))(result, a3, a4, a5);
  }
  return result;
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t))KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t))KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t))KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:));
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( __int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:));
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:));
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2, a3 & 1, a4, a5, a6);
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(a1, a2, a3 & 1, a4, a5, a6);
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t result, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((a3 & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 112))(result, a2, a4, a5, a6);
  }
  return result;
}

{
  if ((a3 & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 160))(result, a2, a4, a5, a6);
  }
  return result;
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( __int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  return a5(a1 & 0x1FF);
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  return a5(a1 & 0x1FFFF);
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t))
{
  return a5(a1 | ((HIDWORD(a1) & 1) << 32));
}

uint64_t KeyedEncodingContainerProtocol.encodeIfPresent<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent<A>(_:forKey:)(a1, a2, a5, a3, a6, a4);
}

{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v20 = a6;
  uint64_t v21 = a3;
  unint64_t v19 = a2;
  unint64_t v9 = type metadata accessor for Optional(0LL, a4, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  unint64_t v11 = MEMORY[0x1895F8858](v9);
  unint64_t v13 = (char *)&v18 - v12;
  unint64_t v14 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v18 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v13, a1, v9);
  (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v16, v13, a4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 168))(v16, v19, a4, v20, v21, a5);
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, a4);
}

uint64_t KeyedEncodingContainer.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, char **a4@<X8>)
{
  uint64_t v7 = type metadata accessor for _KeyedEncodingContainerBox(0LL, a2, a3, a3);
  unint64_t v8 = (char *)swift_allocObject(v7, *(unsigned int *)(v7 + 48), *(unsigned __int16 *)(v7 + 52));
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))( &v8[*(void *)(*(void *)v8 + 432LL)],  a1,  a2);
  *a4 = v8;
  return result;
}

uint64_t KeyedEncodingContainer.encodeNil(forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 96LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t KeyedEncodingContainer.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 104LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 136LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 144LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 152LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 160LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 168LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 184LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 192LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 200LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 208LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 216LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(**(void **)v4 + 112LL))( a1,  a2,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

{
  uint64_t v4;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(**(void **)v4 + 176LL))( a1,  a2,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

{
  uint64_t v4;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(**(void **)v4 + 224LL))( a1,  a2,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

uint64_t KeyedEncodingContainer.encode(_:forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 120LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 128LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t KeyedEncodingContainer.encode<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void))(**(void **)v5 + 232LL))( a1,  a2,  a4,  *(void *)(a3 + 16),  a5,  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.encodeConditional<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void))(**(void **)v5 + 240LL))( a1,  a2,  a4,  *(void *)(a3 + 16),  a5,  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void))(**(void **)v3 + 248LL))( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(**(void **)v4 + 256LL))( a1,  a2,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent(_:forKey:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void, void))(**(void **)v4 + 264LL))( a1,  a2 & 1,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

{
  uint64_t v4;
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void, void))(**(void **)v4 + 280LL))( a1,  a2 & 1,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

{
  uint64_t v4;
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void, void))(**(void **)v4 + 312LL))( a1,  a2 & 1,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

{
  uint64_t v4;
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void, void))(**(void **)v4 + 328LL))( a1,  a2 & 1,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

{
  uint64_t v4;
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void, void))(**(void **)v4 + 360LL))( a1,  a2 & 1,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent(_:forKey:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(unint64_t, uint64_t, void, void))(**(void **)v3 + 272LL))( a1 | ((HIDWORD(a1) & 1) << 32),  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(unint64_t, uint64_t, void, void))(**(void **)v3 + 304LL))( a1 | ((HIDWORD(a1) & 1) << 32),  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(unint64_t, uint64_t, void, void))(**(void **)v3 + 352LL))( a1 | ((HIDWORD(a1) & 1) << 32),  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent(_:forKey:)(__int16 a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, void, void))(**(void **)v3 + 288LL))( a1 & 0x1FF,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(void, uint64_t, void, void))(**(void **)v3 + 336LL))( a1 & 0x1FF,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent(_:forKey:)(int a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, void, void))(**(void **)v3 + 296LL))( a1 & 0x1FFFF,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

{
  uint64_t v3;
  return (*(uint64_t (**)(void, uint64_t, void, void))(**(void **)v3 + 344LL))( a1 & 0x1FFFF,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, void))(**(void **)v5 + 320LL))( a1,  a2,  a3 & 1,  a4,  *(void *)(a5 + 16),  *(void *)(a5 + 24));
}

{
  uint64_t v5;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, void))(**(void **)v5 + 368LL))( a1,  a2,  a3 & 1,  a4,  *(void *)(a5 + 16),  *(void *)(a5 + 24));
}

uint64_t KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void))(**(void **)v5 + 376LL))( a1,  a2,  a4,  *(void *)(a3 + 16),  a5,  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void))(**(void **)v5 + 384LL))( a4,  a2,  a4,  *(void *)(a3 + 16),  a5,  *(void *)(a3 + 24));
}

uint64_t KeyedEncodingContainer.nestedUnkeyedContainer(forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 392LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t KeyedEncodingContainer.superEncoder()()
{
  return (*(uint64_t (**)(void))(**(void **)v0 + 400LL))();
}

uint64_t KeyedEncodingContainer.superEncoder(forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 408LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeNil(forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2)
{
  return KeyedEncodingContainer.encodeNil(forKey:)(a1, a2);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encode(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encode(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3, a4);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3, a4);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2, a3, a4);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encode(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2)
{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2);
}

{
  return KeyedEncodingContainer.encode(_:forKey:)(a1, a2);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encode<A>(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainer.encode<A>(_:forKey:)(a1, a2, a5, a3, a4);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeConditional<A>(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainer.encodeConditional<A>(_:forKey:)(a1, a2, a5, a3, a4);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2, a3);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2, a3, a4);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4);
}

{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4);
}

{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4);
}

{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4);
}

{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2 & 1, a3, a4);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:) in conformance KeyedEncodingContainer<A>( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t))KeyedEncodingContainer.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t))KeyedEncodingContainer.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t))KeyedEncodingContainer.encodeIfPresent(_:forKey:));
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:) in conformance KeyedEncodingContainer<A>( __int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainer.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainer.encodeIfPresent(_:forKey:));
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:) in conformance KeyedEncodingContainer<A>( int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainer.encodeIfPresent(_:forKey:));
}

{
  return KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))KeyedEncodingContainer.encodeIfPresent(_:forKey:));
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2, a3 & 1, a4, a5);
}

{
  return KeyedEncodingContainer.encodeIfPresent(_:forKey:)(a1, a2, a3 & 1, a4, a5);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.encodeIfPresent<A>(_:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)(a1, a2, a5, a3, a4);
}

uint64_t protocol witness for KeyedEncodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:) in conformance KeyedEncodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)(a1, a2, a5, a3, a4);
}

uint64_t KeyedDecodingContainerProtocol.decode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)( a1,  a2,  a3,  (uint64_t)&type metadata for Int128,  0xD00000000000002ELL,  0x80000001818B5730LL);
}

{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)(a1, a2, a3);
}

{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)( a1,  a2,  a3,  (uint64_t)&type metadata for UInt128,  0xD00000000000002FLL,  0x80000001818B5760LL);
}

uint64_t KeyedDecodingContainerProtocol.decode(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = v8;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>);
  inited = swift_initStackObject(v11, v21);
  *((_OWORD *)inited + 1) = xmmword_1817FFC60;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  inited[7] = AssociatedTypeWitness;
  inited[8] = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  (uint64_t)&associated conformance descriptor for KeyedDecodingContainerProtocol.KeyedDecodingContainerProtocol.Key: CodingKey);
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  (*(void (**)(void *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( boxed_opaque_existential_0Tm,  a1,  AssociatedTypeWitness);
  uint64_t v22 = v10;
  specialized Array.append<A>(contentsOf:)( (unint64_t)inited,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
  uint64_t v15 = v22;
  *(void *)uint64_t v9 = a4;
  *(void *)(v9 + 8) = v15;
  *(void *)(v9 + 16) = a5;
  *(void *)(v9 + 24) = a6;
  *(void *)(v9 + 32) = 0LL;
  *(_BYTE *)(v9 + 72) = 0;
  return swift_willThrow();
}

uint64_t KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  uint64_t result;
  char v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  unint64_t AssociatedTypeWitness;
  uint64_t v35;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v31 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  unint64_t v31 = v4;
  unint64_t v32 = v14;
  unint64_t v33 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v32, v33);
    return 2LL;
  }

  char v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v32;
  unint64_t v24 = v33;
  unint64_t v26 = v35;
  Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v33, a3);
  unint64_t v35 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  Swift::String::Index v29 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v29 & 1) != 0) {
    return 2LL;
  }
  Swift::String::Index v30 = v35;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))(v21, v24, a3);
  if (!v30) {
    return result & 1;
  }
  return result;
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t AssociatedTypeWitness;
  uint64_t v34;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  Swift::String::Index v30 = v4;
  unint64_t v31 = v14;
  unint64_t v32 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    char v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    unint64_t v24 = v32;
    unint64_t v26 = v34;
    Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    unint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    Swift::String::Index v29 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    if ((v29 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 64))(v21, v24, a3);
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return 0LL;
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(a1, a2, a3);
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t AssociatedTypeWitness;
  uint64_t v34;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  Swift::String::Index v30 = v4;
  unint64_t v31 = v14;
  unint64_t v32 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    char v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    unint64_t v24 = v32;
    unint64_t v26 = v34;
    Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    unint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    Swift::String::Index v29 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    if ((v29 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 88))(v21, v24, a3);
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return 0LL;
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  uint64_t result;
  int v29;
  char v30;
  uint64_t v31;
  void v32[2];
  char *v33;
  uint64_t v34;
  unint64_t AssociatedTypeWitness;
  uint64_t v36;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v32 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v32[1] = v4;
  unint64_t v33 = v14;
  unint64_t v34 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v33, v34);
LABEL_6:
    LOBYTE(result) = 0;
    Swift::String::Index v29 = 1;
    return result | (v29 << 8);
  }

  char v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v33;
  unint64_t v24 = v34;
  unint64_t v26 = v36;
  Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v34, a3);
  unint64_t v36 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  Swift::String::Index v30 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v30 & 1) != 0) {
    goto LABEL_6;
  }
  unint64_t v31 = v36;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 96))(v21, v24, a3);
  if (v31) {
    return result;
  }
  Swift::String::Index v29 = 0;
  return result | (v29 << 8);
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  uint64_t result;
  int v29;
  char v30;
  uint64_t v31;
  void v32[2];
  char *v33;
  uint64_t v34;
  unint64_t AssociatedTypeWitness;
  uint64_t v36;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v32 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v32[1] = v4;
  unint64_t v33 = v14;
  unint64_t v34 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v33, v34);
LABEL_6:
    LOWORD(result) = 0;
    Swift::String::Index v29 = 1;
    return (unsigned __int16)result | (v29 << 16);
  }

  char v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v33;
  unint64_t v24 = v34;
  unint64_t v26 = v36;
  Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v34, a3);
  unint64_t v36 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  Swift::String::Index v30 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v30 & 1) != 0) {
    goto LABEL_6;
  }
  unint64_t v31 = v36;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 104))(v21, v24, a3);
  if (v31) {
    return result;
  }
  Swift::String::Index v29 = 0;
  return (unsigned __int16)result | (v29 << 16);
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(a1, a2, a3);
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t AssociatedTypeWitness;
  uint64_t v34;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  Swift::String::Index v30 = v4;
  unint64_t v31 = v14;
  unint64_t v32 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    char v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    unint64_t v24 = v32;
    unint64_t v26 = v34;
    Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    unint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    Swift::String::Index v29 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    if ((v29 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 120))(v21, v24, a3);
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return 0LL;
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t AssociatedTypeWitness;
  uint64_t v34;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  Swift::String::Index v30 = v4;
  unint64_t v31 = v14;
  unint64_t v32 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    char v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    unint64_t v24 = v32;
    unint64_t v26 = v34;
    Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    unint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    Swift::String::Index v29 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    if ((v29 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 128))(v21, v24, a3);
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return 0LL;
}

{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(a1, a2, a3);
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t AssociatedTypeWitness;
  uint64_t v34;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  Swift::String::Index v30 = v4;
  unint64_t v31 = v14;
  unint64_t v32 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    char v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    unint64_t v24 = v32;
    unint64_t v26 = v34;
    Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    unint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    Swift::String::Index v29 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    if ((v29 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 136))(v21, v24, a3);
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return 0LL;
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  uint64_t result;
  int v29;
  char v30;
  uint64_t v31;
  void v32[2];
  char *v33;
  uint64_t v34;
  unint64_t AssociatedTypeWitness;
  uint64_t v36;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v32 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v32[1] = v4;
  unint64_t v33 = v14;
  unint64_t v34 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v33, v34);
LABEL_6:
    LOBYTE(result) = 0;
    Swift::String::Index v29 = 1;
    return result | (v29 << 8);
  }

  char v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v33;
  unint64_t v24 = v34;
  unint64_t v26 = v36;
  Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v34, a3);
  unint64_t v36 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  Swift::String::Index v30 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v30 & 1) != 0) {
    goto LABEL_6;
  }
  unint64_t v31 = v36;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 144))(v21, v24, a3);
  if (v31) {
    return result;
  }
  Swift::String::Index v29 = 0;
  return result | (v29 << 8);
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  uint64_t result;
  int v29;
  char v30;
  uint64_t v31;
  void v32[2];
  char *v33;
  uint64_t v34;
  unint64_t AssociatedTypeWitness;
  uint64_t v36;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v32 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v32[1] = v4;
  unint64_t v33 = v14;
  unint64_t v34 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v33, v34);
LABEL_6:
    LOWORD(result) = 0;
    Swift::String::Index v29 = 1;
    return (unsigned __int16)result | (v29 << 16);
  }

  char v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v33;
  unint64_t v24 = v34;
  unint64_t v26 = v36;
  Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v34, a3);
  unint64_t v36 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  Swift::String::Index v30 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v30 & 1) != 0) {
    goto LABEL_6;
  }
  unint64_t v31 = v36;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 152))(v21, v24, a3);
  if (v31) {
    return result;
  }
  Swift::String::Index v29 = 0;
  return (unsigned __int16)result | (v29 << 16);
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(a1, a2, a3);
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t AssociatedTypeWitness;
  uint64_t v34;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  Swift::String::Index v30 = v4;
  unint64_t v31 = v14;
  unint64_t v32 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    char v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    unint64_t v24 = v32;
    unint64_t v26 = v34;
    Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    unint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    Swift::String::Index v29 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    if ((v29 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 168))(v21, v24, a3);
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return 0LL;
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t AssociatedTypeWitness;
  uint64_t v34;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  Swift::String::Index v30 = v4;
  unint64_t v31 = v14;
  unint64_t v32 = a2;
  int64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    char v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    unint64_t v24 = v32;
    unint64_t v26 = v34;
    Swift::String::Index v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    unint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    Swift::String::Index v29 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    if ((v29 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 176))(v21, v24, a3);
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return 0LL;
}

void KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

double KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v30 = v4;
  unint64_t v31 = v14;
  uint64_t v32 = a2;
  uint64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) != 0)
  {
    uint64_t v20 = v12;
    uint64_t v21 = a1;
    uint64_t v22 = v18;
    unint64_t v23 = v18;
    unint64_t v25 = v31;
    uint64_t v24 = v32;
    uint64_t v26 = v34;
    char v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v32, a3);
    uint64_t v34 = v26;
    if (v26)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
    }

    else
    {
      char v29 = v27;
      (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
      (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
      if ((v29 & 1) == 0) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 72))(v21, v24, a3);
      }
    }
  }

  else
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v31, v32);
  }

  return result;
}

unint64_t KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v34 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v34[1] = v4;
  unint64_t v35 = v14;
  uint64_t v36 = a2;
  uint64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v35, v36);
LABEL_6:
    uint64_t v29 = 0LL;
    unsigned __int8 v30 = 1;
    goto LABEL_7;
  }

  uint64_t v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v35;
  uint64_t v24 = v36;
  uint64_t v26 = v38;
  char v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v36, a3);
  uint64_t v38 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  char v31 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v31 & 1) != 0) {
    goto LABEL_6;
  }
  uint64_t v32 = v38;
  unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 80))(v21, v24, a3);
  if (v32) {
    return result;
  }
  unsigned __int8 v30 = 0;
  uint64_t v29 = v33;
LABEL_7:
  unsigned __int8 v39 = v30;
  return v29 | ((unint64_t)v30 << 32);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  unint64_t result;
  unsigned __int8 v29;
  char v30;
  uint64_t v31;
  void v32[2];
  char *v33;
  uint64_t v34;
  unint64_t AssociatedTypeWitness;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v32 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v32[1] = v4;
  unsigned int v33 = v14;
  uint64_t v34 = a2;
  uint64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v33, v34);
LABEL_6:
    LODWORD(result) = 0;
    uint64_t v29 = 1;
    goto LABEL_7;
  }

  uint64_t v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v33;
  uint64_t v24 = v34;
  uint64_t v26 = v36;
  char v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v34, a3);
  uint64_t v36 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  unsigned __int8 v30 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v30 & 1) != 0) {
    goto LABEL_6;
  }
  char v31 = v36;
  unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 112))(v21, v24, a3);
  if (v31) {
    return result;
  }
  uint64_t v29 = 0;
LABEL_7:
  unint64_t v37 = v29;
  return result | ((unint64_t)v29 << 32);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char v27;
  unint64_t result;
  unsigned __int8 v29;
  char v30;
  uint64_t v31;
  void v32[2];
  char *v33;
  uint64_t v34;
  unint64_t AssociatedTypeWitness;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v32 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 40))(a1, a2, a3);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v32[1] = v4;
  unsigned int v33 = v14;
  uint64_t v34 = a2;
  uint64_t v17 = a2;
  uint64_t v18 = v11;
  unint64_t v19 = AssociatedTypeWitness;
  v16(v14, v4, v17);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))(v18, a1, v19);
  if ((v15 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v18, v19);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v33, v34);
LABEL_6:
    LODWORD(result) = 0;
    uint64_t v29 = 1;
    goto LABEL_7;
  }

  uint64_t v20 = v12;
  uint64_t v21 = a1;
  uint64_t v22 = v18;
  unint64_t v23 = v18;
  unint64_t v25 = v33;
  uint64_t v24 = v34;
  uint64_t v26 = v36;
  char v27 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 48))(v23, v34, a3);
  uint64_t v36 = v26;
  if (v26)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  }

  unsigned __int8 v30 = v27;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v22, v19);
  (*(void (**)(char *, uint64_t))(v20 + 8))(v25, v24);
  if ((v30 & 1) != 0) {
    goto LABEL_6;
  }
  char v31 = v36;
  unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 160))(v21, v24, a3);
  if (v31) {
    return result;
  }
  uint64_t v29 = 0;
LABEL_7:
  unint64_t v37 = v29;
  return result | ((unint64_t)v29 << 32);
}

uint64_t KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4() & 0x1FF;
}

{
  return a4() & 0x1FFFF;
}

{
  unint64_t v4;
  uint64_t v4 = a4();
  return v4 | ((HIDWORD(v4) & 1) << 32);
}

{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  unint64_t result = a4();
  if (v4) {
    return v6;
  }
  return result;
}

uint64_t KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  return KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:)(a1, a4, a2, a5, a3, a6);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char v18;
  void (*v19)(char *, uint64_t, uint64_t);
  uint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  char v24;
  uint64_t result;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  unint64_t AssociatedTypeWitness;
  uint64_t v37;
  uint64_t v7 = v6;
  uint64_t v32 = a5;
  unsigned int v33 = a6;
  uint64_t v34 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a2,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v14 = (char *)&v31 - v13;
  char v15 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 40))(a1, a2, a4);
  unint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(v15 + 16);
  unint64_t v35 = v17;
  char v31 = v7;
  uint64_t v20 = v7;
  uint64_t v21 = AssociatedTypeWitness;
  v19(v17, v20, a2);
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))(v14, a1, v21);
  if ((v18 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t))(v11 + 8))(v14, v21);
    (*(void (**)(char *, uint64_t))(v15 + 8))(v35, a2);
LABEL_5:
    uint64_t v26 = 1LL;
    Swift::String::Index v28 = v33;
    char v27 = v34;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v27 - 8) + 56LL))( v28,  v26,  1LL,  v27);
  }

  uint64_t v22 = v35;
  unint64_t v23 = v37;
  uint64_t v24 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(a4 + 48))(v14, a2, a4);
  unint64_t v37 = v23;
  if (v23)
  {
    (*(void (**)(char *, unint64_t))(v11 + 8))(v14, v21);
    return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v22, a2);
  }

  uint64_t v29 = v24;
  (*(void (**)(char *, unint64_t))(v11 + 8))(v14, v21);
  (*(void (**)(char *, uint64_t))(v15 + 8))(v22, a2);
  if ((v29 & 1) != 0) {
    goto LABEL_5;
  }
  Swift::String::Index v28 = v33;
  char v27 = v34;
  unsigned __int8 v30 = v37;
  unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 184))( v34,  a1,  v34,  v32,  a2,  a4);
  if (!v30)
  {
    uint64_t v26 = 0LL;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v27 - 8) + 56LL))( v28,  v26,  1LL,  v27);
  }

  return result;
}

uint64_t KeyedDecodingContainer.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, char **a4@<X8>)
{
  uint64_t v7 = type metadata accessor for _KeyedDecodingContainerBox(0LL, a2, a3, a3);
  uint64_t v8 = (char *)swift_allocObject(v7, *(unsigned int *)(v7 + 48), *(unsigned __int16 *)(v7 + 52));
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))( &v8[*(void *)(*(void *)v8 + 440LL)],  a1,  a2);
  *a4 = v8;
  return result;
}

uint64_t KeyedDecodingContainer.codingPath.getter()
{
  return (*(uint64_t (**)(void))(**(void **)v0 + 88LL))();
}

__objc2_class **KeyedDecodingContainer.allKeys.getter(uint64_t a1)
{
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)v1 + 96LL))();
  uint64_t v4 = specialized _arrayForceCast<A, B>(_:)(v3, *(char **)(a1 + 16));
  swift_bridgeObjectRelease(v3);
  return v4;
}

uint64_t KeyedDecodingContainer.contains(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 104LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24)) & 1;
}

uint64_t KeyedDecodingContainer.decodeNil(forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 112LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24)) & 1;
}

uint64_t KeyedDecodingContainer.decode(_:forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 120LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24)) & 1;
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 128LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 136LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 144LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 152LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 160LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 168LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 176LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 184LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 192LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 200LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 208LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 216LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 224LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 232LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 240LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t KeyedDecodingContainer.decode<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void))(**(void **)v5 + 248LL))( a4,  a2,  a4,  *(void *)(a3 + 16),  a5,  *(void *)(a3 + 24));
}

uint64_t KeyedDecodingContainer.decodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 256LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 264LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 272LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v2;
  unint64_t v3;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 280LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 288LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 296LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24)) & 0x1FF;
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 304LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24)) & 0x1FFFF;
}

{
  uint64_t v2;
  unint64_t v3;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 312LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 320LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 328LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 336LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 344LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24)) & 0x1FF;
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 352LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24)) & 0x1FFFF;
}

{
  uint64_t v2;
  unint64_t v3;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 360LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 368LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  if (v3) {
    return v5;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 376LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
  if (v3) {
    return v5;
  }
  return result;
}

uint64_t KeyedDecodingContainer.decodeIfPresent<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void))(**(void **)v5 + 384LL))( a4,  a2,  a4,  *(void *)(a3 + 16),  a5,  *(void *)(a3 + 24));
}

uint64_t KeyedDecodingContainer.nestedContainer<A>(keyedBy:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void))(**(void **)v5 + 392LL))( a4,  a2,  a4,  *(void *)(a3 + 16),  a5,  *(void *)(a3 + 24));
}

uint64_t KeyedDecodingContainer.nestedUnkeyedContainer(forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 400LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t KeyedDecodingContainer.superDecoder()()
{
  return (*(uint64_t (**)(void))(**(void **)v0 + 408LL))();
}

uint64_t KeyedDecodingContainer.superDecoder(forKey:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(**(void **)v2 + 416LL))( a1,  *(void *)(a2 + 16),  *(void *)(a2 + 24));
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.decodeNil(forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2)
{
  return KeyedDecodingContainer.decodeNil(forKey:)(a1, a2) & 1;
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.decode(_:forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2)
{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2) & 1;
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decode(_:forKey:)(a1, a2);
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.decode<A>(_:forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedDecodingContainer.decode<A>(_:forKey:)(a1, a2, a5, a3, a4);
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2)
{
  return KeyedDecodingContainer.decodeIfPresent(_:forKey:)(a1, a2);
}

{
  return KeyedDecodingContainer.decodeIfPresent(_:forKey:)(a1, a2);
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = KeyedDecodingContainer.decodeIfPresent(_:forKey:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = KeyedDecodingContainer.decodeIfPresent(_:forKey:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = KeyedDecodingContainer.decodeIfPresent(_:forKey:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = KeyedDecodingContainer.decodeIfPresent(_:forKey:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = KeyedDecodingContainer.decodeIfPresent(_:forKey:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( a1,  a2,  a3,  (uint64_t (*)(void))KeyedDecodingContainer.decodeIfPresent(_:forKey:));
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedDecodingContainer.decodeIfPresent<A>(_:forKey:)(a1, a2, a5, a3, a4);
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return KeyedDecodingContainer.nestedContainer<A>(keyedBy:forKey:)(a1, a2, a5, a3, a4);
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.nestedUnkeyedContainer(forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2)
{
  return KeyedDecodingContainer.nestedUnkeyedContainer(forKey:)(a1, a2);
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.superDecoder() in conformance KeyedDecodingContainer<A>()
{
  return KeyedDecodingContainer.superDecoder()();
}

uint64_t protocol witness for KeyedDecodingContainerProtocol.superDecoder(forKey:) in conformance KeyedDecodingContainer<A>( uint64_t a1, uint64_t a2)
{
  return KeyedDecodingContainer.superDecoder(forKey:)(a1, a2);
}

uint64_t UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnkeyedEncodingContainer.encode(_:)(a1, a2, a3, a4);
}

{
  return UnkeyedEncodingContainer.encode(_:)(a1, a2, a3, a4);
}

{
  return UnkeyedEncodingContainer.encode(_:)(a1, a2, a3, a4);
}

{
  return UnkeyedEncodingContainer.encode(_:)(a1, a2, a3, a4);
}

{
  void *v8;
  void *v9;
  void *v10;
  swift_allocError( (uint64_t)&type metadata for EncodingError,  (uint64_t)&protocol witness table for EncodingError,  0LL,  0);
  uint64_t v9 = v8;
  v8[3] = &type metadata for Int128;
  uint64_t v10 = swift_allocObject((uint64_t)&unk_189B78168, 0x20uLL, 0xFuLL);
  id *v9 = v10;
  v10[2] = a1;
  v10[3] = a2;
  v9[4] = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 8))(a3, a4);
  v9[5] = 0xD00000000000002ELL;
  v9[6] = 0x80000001818B56D0LL;
  v9[7] = 0LL;
  return swift_willThrow();
}

{
  void *v8;
  void *v9;
  void *v10;
  swift_allocError( (uint64_t)&type metadata for EncodingError,  (uint64_t)&protocol witness table for EncodingError,  0LL,  0);
  uint64_t v9 = v8;
  v8[3] = &type metadata for UInt128;
  uint64_t v10 = swift_allocObject((uint64_t)&unk_189B78168, 0x20uLL, 0xFuLL);
  id *v9 = v10;
  v10[2] = a1;
  v10[3] = a2;
  v9[4] = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 8))(a3, a4);
  v9[5] = 0xD00000000000002FLL;
  v9[6] = 0x80000001818B5700LL;
  v9[7] = 0LL;
  return swift_willThrow();
}

uint64_t UnkeyedEncodingContainer.encodeConditional<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnkeyedEncodingContainer.encodeConditional<A>(_:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v6;
  uint64_t v6 = a1;
  return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 160))(&v6, a3, a5, a2, a4);
}

uint64_t UnkeyedEncodingContainer.encode<A>(contentsOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 32))(v23 & 1, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(double *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  double v21;
  char v22;
  uint64_t v23;
  unint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v11, v20, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(double *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 16);
  do
  {
    v17(&v21, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v22 & 1) != 0) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t, double))(a4 + 48))(a2, a4, v21);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v23 & 0x100000000LL) != 0) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t, float))(a4 + 56))(a2, a4, *(float *)&v23);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  unint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v11, v20, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v21, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v22 & 1) != 0) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 64))(v21, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v23 & 0x100) != 0) {
      break;
    }
    (*(void (**)(void, uint64_t, uint64_t))(a4 + 72))(v23, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v23 & 0x10000) != 0) {
      break;
    }
    (*(void (**)(void, uint64_t, uint64_t))(a4 + 80))((unsigned __int16)v23, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v23 & 0x100000000LL) != 0) {
      break;
    }
    (*(void (**)(void, uint64_t, uint64_t))(a4 + 88))(v23, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  unint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v11, v20, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v21, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v22 & 1) != 0) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 96))(v21, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(void *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  void v21[2];
  char v22;
  uint64_t v23;
  unint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v11, v20, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(void *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 16);
  do
  {
    v17(v21, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v22 & 1) != 0) {
      break;
    }
    (*(void (**)(void, void, uint64_t, uint64_t))(a4 + 104))(v21[0], v21[1], a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  unint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v11, v20, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v21, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v22 & 1) != 0) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 112))(v21, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v23 & 0x100) != 0) {
      break;
    }
    (*(void (**)(void, uint64_t, uint64_t))(a4 + 120))(v23, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v23 & 0x10000) != 0) {
      break;
    }
    (*(void (**)(void, uint64_t, uint64_t))(a4 + 128))((unsigned __int16)v23, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v20 = *(void *)(a3 - 8);
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v20 + 16))(v11, v21, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v23, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v23 & 0x100000000LL) != 0) {
      break;
    }
    (*(void (**)(void, uint64_t, uint64_t))(a4 + 136))(v23, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  unint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v11, v20, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  do
  {
    v17(&v21, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v22 & 1) != 0) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 144))(v21, a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v15, AssociatedTypeWitness);
}

{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  uint64_t v5;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  unint64_t AssociatedConformanceWitness;
  void (*v17)(void *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  void v21[2];
  char v22;
  uint64_t v23;
  unint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v11, v20, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v17 = *(void (**)(void *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 16);
  do
  {
    v17(v21, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v22 & 1) != 0) {
      break;
    }
    (*(void (**)(void, void, uint64_t, uint64_t))(a4 + 152))(v21[0], v21[1], a2, a4);
  }

  while (!v5);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v15, AssociatedTypeWitness);
}

void UnkeyedEncodingContainer.encode<A>(contentsOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  unint64_t AssociatedConformanceWitness;
  void (*v18)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v25 = a2;
  unint64_t v23 = a1;
  uint64_t v9 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v16 = (char *)&v22 - v15;
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v23, a3);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v18 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v18(&v26, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v19 = v27;
  uint64_t v24 = v14;
  if (v27)
  {
    uint64_t v20 = v26;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 40);
    while (1)
    {
      v21(v20, v19, v25, a4);
      if (v5) {
        break;
      }
      swift_bridgeObjectRelease(v19);
      v18(&v26, AssociatedTypeWitness, AssociatedConformanceWitness);
      uint64_t v20 = v26;
      unint64_t v19 = v27;
      if (!v27) {
        goto LABEL_5;
      }
    }

    (*(void (**)(char *, unint64_t))(v24 + 8))(v16, AssociatedTypeWitness);
    swift_bridgeObjectRelease(v19);
  }

  else
  {
LABEL_5:
    (*(void (**)(char *, unint64_t))(v24 + 8))(v16, AssociatedTypeWitness);
  }

uint64_t UnkeyedEncodingContainer.encode<A>(contentsOf:)( unint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return UnkeyedEncodingContainer.encode<A>(contentsOf:)(a1, a5, a2, a6, a3, a4);
}

uint64_t UnkeyedEncodingContainer.encode<A>(contentsOf:)( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6)
{
  uint64_t v34 = a4;
  uint64_t v35 = a2;
  uint64_t v36 = a6;
  unint64_t v37 = a5;
  unint64_t v38 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v39 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v32 - v10;
  uint64_t v14 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v12, v13);
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  uint64_t v17 = (char *)&v32 - v16;
  uint64_t v18 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v32 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v33 = *(void *)(v21 - 8);
  MEMORY[0x1895F8858](v21);
  unint64_t v23 = (char *)&v32 - v22;
  (*(void (**)(char *, unint64_t, uint64_t))(v18 + 16))(v20, v38, a3);
  uint64_t v24 = (uint64_t)v37;
  (*((void (**)(uint64_t, const char *))v37 + 4))(a3, v37);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v24,  a3,  v21,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v26 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v37 = v23;
  unint64_t v38 = v21;
  v26(v21, AssociatedConformanceWitness);
  char v27 = v26;
  uint64_t v28 = v39;
  uint64_t v29 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v39 + 48);
  if (v29(v17, 1LL, AssociatedTypeWitness) != 1)
  {
    unsigned __int8 v30 = *(void (**)(char *, char *, unint64_t))(v28 + 32);
    while (1)
    {
      v30(v11, v17, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v34 + 160))( v11,  AssociatedTypeWitness,  v36,  v35);
      if (v6) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v39 + 8))(v11, AssociatedTypeWitness);
      v27(v38, AssociatedConformanceWitness);
      if (v29(v17, 1LL, AssociatedTypeWitness) == 1) {
        return (*(uint64_t (**)(const char *, unint64_t))(v33 + 8))(v37, v38);
      }
    }

    (*(void (**)(char *, unint64_t))(v39 + 8))(v11, AssociatedTypeWitness);
  }

  return (*(uint64_t (**)(const char *, unint64_t))(v33 + 8))(v37, v38);
}

uint64_t UnkeyedDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return UnkeyedDecodingContainer.decode(_:)(a1, a2);
}

{
  return UnkeyedDecodingContainer.decode(_:)( a1,  a2,  (uint64_t)&type metadata for Int128,  0xD00000000000002ELL,  0x80000001818B5730LL);
}

{
  return UnkeyedDecodingContainer.decode(_:)(a1, a2);
}

{
  return UnkeyedDecodingContainer.decode(_:)( a1,  a2,  (uint64_t)&type metadata for UInt128,  0xD00000000000002FLL,  0x80000001818B5760LL);
}

uint64_t UnkeyedDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = v10;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 8))(a1, a2);
  *(void *)uint64_t v11 = a3;
  *(void *)(v11 + 8) = v12;
  *(void *)(v11 + 16) = a4;
  *(void *)(v11 + 24) = a5;
  *(void *)(v11 + 32) = 0LL;
  *(_BYTE *)(v11 + 72) = 0;
  return swift_willThrow();
}

uint64_t UnkeyedDecodingContainer.decodeIfPresent(_:)(uint64_t a1, uint64_t a2)
{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)(a1, a2);
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 2LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 48))(a1, a2) & 1;
  }

  return result;
}

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)(a1, a2);
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, a2);
  }

  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v6;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
    return v6;
  }

  return result;
}

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  uint64_t v5;
  unsigned __int8 v6;
  uint64_t result;
  unsigned int v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) == 0)
    {
      (*(void (**)(uint64_t, uint64_t))(a2 + 72))(a1, a2);
      uint64_t v6 = 0;
      uint64_t v5 = v8;
      return v5 | ((unint64_t)v6 << 32);
    }

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 80))(a1, a2);
  }

  return result;
}

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  unsigned __int8 v5;
  int v6;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) == 0)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 88))(a1, a2);
      uint64_t v6 = 0;
      return v5 | (v6 << 8);
    }

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  unsigned __int16 v5;
  int v6;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) == 0)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 96))(a1, a2);
      uint64_t v6 = 0;
      return v5 | (v6 << 16);
    }

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  unsigned int v5;
  unsigned __int8 v6;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) == 0)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 104))(a1, a2);
      uint64_t v6 = 0;
      return v5 | ((unint64_t)v6 << 32);
    }

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 112))(a1, a2);
  }

  return result;
}

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 120))(a1, a2);
  }

  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 128))(a1, a2);
  }

  return result;
}

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  unsigned __int8 v5;
  int v6;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) == 0)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 136))(a1, a2);
      uint64_t v6 = 0;
      return v5 | (v6 << 8);
    }

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  unsigned __int16 v5;
  int v6;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) == 0)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 144))(a1, a2);
      uint64_t v6 = 0;
      return v5 | (v6 << 16);
    }

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  unsigned int v5;
  unsigned __int8 v6;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) == 0)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 152))(a1, a2);
      uint64_t v6 = 0;
      return v5 | ((unint64_t)v6 << 32);
    }

{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)(a1, a2);
  if (v2) {
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 160))(a1, a2);
  }

  return result;
}

{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)( a1,  a2,  (uint64_t (*)(void))UnkeyedDecodingContainer.decodeIfPresent(_:));
}

{
  uint64_t v2;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, a2);
  if (!v2)
  {
    if ((result & 1) != 0) {
      return 0LL;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a1, a2);
  }

  return result;
}

LABEL_2:
    uint64_t v5 = 0LL;
    uint64_t v6 = 1;
    return v5 | ((unint64_t)v6 << 32);
  }

  return result;
}

    uint64_t v5 = 0;
    uint64_t v6 = 1;
    return v5 | (v6 << 8);
  }

  return result;
}

    uint64_t v5 = 0;
    uint64_t v6 = 1;
    return v5 | (v6 << 16);
  }

  return result;
}

    uint64_t v5 = 0;
    uint64_t v6 = 1;
    return v5 | ((unint64_t)v6 << 32);
  }

  return result;
}

    uint64_t v5 = 0;
    uint64_t v6 = 1;
    return v5 | (v6 << 8);
  }

  return result;
}

    uint64_t v5 = 0;
    uint64_t v6 = 1;
    return v5 | (v6 << 16);
  }

  return result;
}

    uint64_t v5 = 0;
    uint64_t v6 = 1;
    return v5 | ((unint64_t)v6 << 32);
  }

  return result;
}

  (*(void (**)(char *, uint64_t))(v52 + 8))(v19, v53);
  swift_retain((unint64_t *)v14, v32, v33, v34);
  uint64_t result = _NativeSet.extractSubset(using:count:)(v56, v54, v57, v14, a6, a8);
LABEL_3:
  *uint64_t v55 = result;
  return result;
}

  BOOL v78 = v17;
  unint64_t v23 = 3 * a2;
  if ((unsigned __int128)(a2 * (__int128)3LL) >> 64 != (3 * a2) >> 63)
  {
    __break(1u);
LABEL_63:
    __break(1u);
LABEL_64:
    uint64_t v71 = 613LL;
LABEL_67:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v71,  0);
  }

  uint64_t v24 = (char *)swift_slowAlloc(3 * a2, 0xFFFFFFFFFFFFFFFFLL);
  if ((v23 & 0x8000000000000000LL) != 0) {
LABEL_60:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  unint64_t v25 = v24;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v83,  a4,  v18,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v18,  AssociatedConformanceWitness);
  if (a1) {
    uint64_t v29 = &a1->i8[*((void *)v22[-1].Description + 9) * a2];
  }
  else {
    uint64_t v29 = 0LL;
  }
  v85[0] = a1;
  v85[1] = v29;
  char v31 = *(void (**)(void *, uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                              + 32);
  uint64_t v33 = type metadata accessor for UnsafeBufferPointer.Iterator(0LL, (uint64_t)v22, v27, v28);
  uint64_t v34 = 0LL;
  uint64_t v79 = 1;
  uint64_t v75 = v33;
  while (1)
  {
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>.Iterator, v33, v32);
    uint64_t v36 = v78;
    v31(v85, v33, WitnessTable, v18, AssociatedConformanceWitness);
    EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v36, v15);
    if (EnumCaseMultiPayload) {
      break;
    }
    uint64_t v74 = v31;
    uint64_t v77 = AssociatedConformanceWitness;
    unint64_t v38 = v18;
    uint64_t v39 = v25;
    uint64_t v40 = v15;
    unint64_t v42 = v80;
    uint64_t v41 = v81;
    uint64_t v43 = v36;
    Swift::String::Index v44 = v82;
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v81 + 32))(v80, v43, v82);
    size_t v45 = (*((uint64_t (**)(char *, uint64_t))v83 + 11))(v42, a4);
    (*(void (**)(char *, uint64_t))(v41 + 8))(v42, v44);
    if (v45 >= 0x80)
    {
      uint64_t v58 = (v45 & 0x3F) << 8;
      if (v45 >= 0x800)
      {
        unsigned int v59 = (v58 | (v45 >> 6) & 0x3F) << 8;
        unsigned int v60 = (((v59 | (v45 >> 12) & 0x3F) << 8) | (v45 >> 18)) - 2122219023;
        unsigned int v61 = (v59 | (v45 >> 12)) + 8487393;
        if (HIWORD(v45)) {
          Swift::String::Index v46 = v60;
        }
        else {
          Swift::String::Index v46 = v61;
        }
      }

      else
      {
        Swift::String::Index v46 = (v58 | (v45 >> 6)) + 33217;
      }
    }

    else
    {
      Swift::String::Index v46 = v45 + 1;
    }

    uint64_t v15 = v40;
    uint64_t v47 = 4 - (__clz(v46) >> 3);
    uint64_t v48 = __OFADD__(v34, v47);
    unint64_t v49 = v34 + v47;
    if (v48) {
      goto LABEL_63;
    }
    unint64_t v25 = v39;
    if ((uint64_t)v23 >= v49)
    {
      uint64_t v50 = v23;
      uint64_t v18 = v38;
      unint64_t AssociatedConformanceWitness = v77;
      char v53 = v79;
    }

    else
    {
      uint64_t v50 = v23 + (v23 >> 1);
      if (__OFADD__(v23, v23 >> 1))
      {
        __break(1u);
LABEL_66:
        uint64_t v71 = 614LL;
        goto LABEL_67;
      }

      uint64_t v18 = v38;
      uint64_t v51 = (char *)swift_slowAlloc(v23 + (v23 >> 1), 0xFFFFFFFFFFFFFFFFLL);
      if (v50 < 0) {
        goto LABEL_60;
      }
      if (v34 < 0) {
LABEL_61:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      uint64_t v52 = v51;
      unint64_t AssociatedConformanceWitness = v77;
      char v53 = v79;
      if (v34)
      {
        if (v50 < (unint64_t)v34)
        {
          uint64_t v72 = 986LL;
          goto LABEL_70;
        }

        if (v51 != v25 || v51 >= &v25[v34]) {
          memmove(v51, v25, v34);
        }
      }

      swift_slowDealloc(v25);
      unint64_t v25 = v52;
    }

    unint64_t v54 = v53 & (v46 < 0x100);
    if (v50 < v34) {
      goto LABEL_61;
    }
    if (v34 < 0) {
      goto LABEL_64;
    }
    uint64_t v55 = v50 - v34;
    if (v50 - v34 < 0) {
      goto LABEL_60;
    }
    if (!v55) {
      goto LABEL_71;
    }
    for (i = 0LL; i != v55; ++i)
    {
      if (v55 == i) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
      }
      unsigned int v57 = v46;
      if (!v46)
      {
        uint64_t v55 = i;
        goto LABEL_40;
      }

      v25[v34 + i] = v46 - 1;
      v46 >>= 8;
    }

    if (v57 > 0xFF)
    {
LABEL_71:
      uint64_t v72 = 827LL;
LABEL_70:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "buffer cannot contain every element from source.",  48LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v72,  0);
    }

  if ((*(void *)(v4 + 16) & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return v2(v4 + 24);
}

  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)a1 + v4 + 8;
  if ((_DWORD)v4) {
    uint64_t v6 = result == 0;
  }
  else {
    uint64_t v6 = 1;
  }
  if (v6) {
    return 0LL;
  }
  if ((v3 & 0x80) != 0)
  {
    uint64_t v11 = a1 + 1;
    uint64_t v12 = (v3 >> 3) & 7;
    if (v12 == 1)
    {
      uint64_t v15 = *(void *)((char *)v11 + *v11);
      uint64_t v16 = *a1;
      if ((_DWORD)v16) {
        goto LABEL_61;
      }
    }

    else
    {
      if (!v12)
      {
        uint64_t v13 = *v11;
        uint64_t v14 = (char *)v11 + v13;
        if ((_DWORD)v13) {
          uint64_t v15 = (uint64_t)v14;
        }
        else {
          uint64_t v15 = 0LL;
        }
        uint64_t v16 = *a1;
        if (!(_DWORD)v16) {
          goto LABEL_18;
        }
LABEL_61:
        uint64_t v17 = (void *)((char *)a1 + (v16 & 0xFFFFFFFFFFFFFFFELL));
        if ((v16 & 1) != 0) {
          uint64_t v17 = (void *)*v17;
        }
        return _getForeignWitnessTable(result, v15, (uint64_t)v17);
      }

      uint64_t v15 = 0LL;
      uint64_t v16 = *a1;
      if ((_DWORD)v16) {
        goto LABEL_61;
      }
    }

          *(_DWORD *)a4 = 0;
          *(void *)(a4 + 8) = 0LL;
          *(_DWORD *)(a4 + 16) = 0;
          return result;
        }
      }

      else
      {
        uint64_t v15 = v13[2];
      }

      else {
        uint64_t v17 = (2 * v11);
      }
      uint64_t v18 = v17 + v11;
      if (!v14 || (unint64_t)&v14[v18] > v15)
      {
        uint64_t v19 = 2LL * v13[4];
        if (v19 <= v18 + 1) {
          uint64_t v19 = v18 + 1;
        }
        v13[4] = v19;
        uint64_t v20 = v19 + 8;
        uint64_t result = malloc(v19 + 8);
        *uint64_t result = v13[3];
        uint64_t v14 = (char *)(result + 1);
        v13[2] = (char *)result + v20;
        v13[3] = result;
      }

      v13[1] = &v14[v18];
      if ((_DWORD)v11)
      {
        uint64_t result = memcpy(v14, this[1591], v11);
        LODWORD(v11) = *((_DWORD *)this + 3185);
        uint64_t v10 = *((_DWORD *)this + 3184);
      }

      this[1591] = v14;
      uint64_t v12 = v14;
      goto LABEL_23;
    }
  }

  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

uint64_t UnkeyedDecodingContainer.decodeIfPresent(_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  return a3() & 0x1FF;
}

{
  return a3() & 0x1FFFF;
}

{
  unint64_t v3;
  uint64_t v3 = a3();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t result = a3();
  if (v3) {
    return v5;
  }
  return result;
}

uint64_t UnkeyedDecodingContainer.decodeIfPresent<A>(_:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  return UnkeyedDecodingContainer.decodeIfPresent<A>(_:)(a3, a1, a4, a2, a5);
}

{
  uint64_t v5;
  uint64_t result;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a1, a3) & 1) != 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))( a5,  1LL,  1LL,  a2);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 40))(a1, a3);
  if (!v5)
  {
    if ((result & 1) != 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))( a5,  1LL,  1LL,  a2);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 176))(a2, a2, a4, a1, a3);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))(a5, 0LL, 1LL, a2);
  }

  return result;
}

uint64_t SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnkeyedEncodingContainer.encode(_:)(a1, a2, a3, a4);
}

{
  return UnkeyedEncodingContainer.encode(_:)(a1, a2, a3, a4);
}

uint64_t SingleValueDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return SingleValueDecodingContainer.decode(_:)(a1, a2);
}

{
  return UnkeyedDecodingContainer.decode(_:)( a1,  a2,  (uint64_t)&type metadata for Int128,  0xD00000000000002ELL,  0x80000001818B5730LL);
}

{
  return SingleValueDecodingContainer.decode(_:)(a1, a2);
}

{
  return UnkeyedDecodingContainer.decode(_:)( a1,  a2,  (uint64_t)&type metadata for UInt128,  0xD00000000000002FLL,  0x80000001818B5760LL);
}

uint64_t CodingUserInfoKey.rawValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *v4;
  swift_bridgeObjectRetain(v4[1], a2, a3, a4);
  return v5;
}

Swift::CodingUserInfoKey_optional __swiftcall CodingUserInfoKey.init(rawValue:)( Swift::CodingUserInfoKey_optional rawValue)
{
  Swift::CodingUserInfoKey_optional *v1 = rawValue;
  return rawValue;
}

uint64_t static CodingUserInfoKey.== infix(_:_:)(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = a2[1];
  if (v4 == *a2 && v5 == v6) {
    return 1LL;
  }
  if ((~v5 & 0x6000000000000000LL) != 0 || (v6 & 0x2000000000000000LL) == 0 || (v6 & 0x4000000000000000LL) == 0) {
    return _stringCompareInternal(_:_:expecting:)(v4, v5, *a2, v6, 0);
  }
  else {
    return 0LL;
  }
}

Swift::Int CodingUserInfoKey.hashValue.getter()
{
  unint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  String.hash(into:)(v4, v1, v2);
  return Hasher._finalize()();
}

Swift::Int String.hashValue.getter(unint64_t a1, unint64_t a2)
{
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  String.hash(into:)(v3, a1, a2);
  return Hasher._finalize()();
}

void CodingUserInfoKey.hash(into:)(unint64_t *a1)
{
  unint64_t v2 = *v1;
  unint64_t v3 = v1[1];
  if ((v3 & 0x2000000000000000LL) != 0) {
    uint64_t v4 = v1[1];
  }
  else {
    uint64_t v4 = *v1;
  }
  if ((v3 & 0x1000000000000000LL) != 0 || (v4 & 0x4000000000000000LL) == 0)
  {
    if ((v3 & 0x2000000000000000LL) != 0) {
      uint64_t v9 = HIBYTE(v3) & 0xF;
    }
    else {
      uint64_t v9 = v2 & 0xFFFFFFFFFFFFLL;
    }
    _StringGutsSlice._normalizedHash(into:)(a1, v2, v3, 0LL, v9);
  }

  else
  {
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      v10[0] = *v1;
      v10[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v8 = (char *)v10 + (HIBYTE(v3) & 0xF);
      uint64_t v7 = v10;
    }

    else
    {
      if ((v2 & 0x1000000000000000LL) != 0)
      {
        id v5 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v6 = v2 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        id v5 = _StringObject.sharedUTF8.getter(*v1, v1[1]);
      }

      uint64_t v7 = (void *)specialized UnsafeRawBufferPointer.init<A>(_:)((uint64_t)v5, v6);
    }

    Hasher.combine(bytes:)(*(Swift::UnsafeRawBufferPointer *)&v7);
    Hasher._combine(_:)(0xFFu);
  }

unint64_t protocol witness for RawRepresentable.rawValue.getter in conformance CodingUserInfoKey@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, void *a4@<X8>)
{
  unint64_t v5 = v4[1];
  *a4 = *v4;
  a4[1] = v5;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance CodingUserInfoKey( uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = a2[1];
  if (v4 == *a2 && v5 == v6) {
    return 1LL;
  }
  if ((~v5 & 0x6000000000000000LL) != 0 || (v6 & 0x2000000000000000LL) == 0 || (v6 & 0x4000000000000000LL) == 0) {
    return _stringCompareInternal(_:_:expecting:)(v4, v5, *a2, v6, 0);
  }
  else {
    return 0LL;
  }
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance CodingUserInfoKey(uint64_t a1)
{
  uint64_t v2 = v1[1];
  uint64_t v7 = *v1;
  uint64_t v8 = v2;
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  CodingUserInfoKey.hash(into:)(v4);
  return Hasher._finalize()();
}

Swift::Int RawRepresentable<>._rawHashValue(seed:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  (*(void (**)(void *))(a3 + 24))(v4);
  return Hasher._finalize()();
}

unint64_t EncodingError._domain.getter()
{
  return 0xD000000000000012LL;
}

uint64_t EncodingError._code.getter()
{
  uint64_t v1 = v4[4];
  uint64_t v2 = (void *)v4[7];
  swift_bridgeObjectRelease(v4[6]);
  swift_bridgeObjectRelease(v1);
  swift_errorRelease(v2);
  __swift_destroy_boxed_opaque_existential_1Tm(v4);
  return 4866LL;
}

char *EncodingError._userInfo.getter()
{
  uint64_t v1 = v32;
  uint64_t v2 = v33;
  unint64_t v4 = v34;
  unint64_t v3 = v35;
  swift_bridgeObjectRetain(v32, v5, v6, v7);
  swift_bridgeObjectRetain(v4, v8, v9, v10);
  swift_errorRetain(v3);
  swift_bridgeObjectRelease(v4);
  swift_bridgeObjectRelease(v1);
  swift_errorRelease(v3);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v30);
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  inited = swift_initStackObject(v11, v29);
  *((_OWORD *)inited + 1) = xmmword_1817FFCF0;
  strcpy((char *)inited + 32, "NSCodingPath");
  *((_BYTE *)inited + 45) = 0;
  *((_WORD *)inited + 23) = -5120;
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [CodingKey]);
  inited[6] = v1;
  inited[9] = v13;
  inited[10] = 0xD000000000000012LL;
  inited[15] = &type metadata for String;
  inited[11] = 0x80000001818B57B0LL;
  inited[12] = v2;
  inited[13] = v4;
  uint64_t v19 = specialized Dictionary.init(dictionaryLiteral:)((uint64_t)inited, v14, v15, v16);
  if (v3)
  {
    swift_getErrorValue(v3, &v28, &v26);
    unint64_t v20 = v26;
    uint64_t v21 = v27;
    uint64_t v31 = v27;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v30);
    (*(void (**)(void *, unint64_t, uint64_t))(*(void *)(v21 - 8) + 16LL))( boxed_opaque_existential_0Tm,  v20,  v21);
    outlined init with take of Any(v30, v25);
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v19);
    specialized _NativeDictionary.setValue(_:forKey:isUnique:)( v25,  0xD000000000000011LL,  0x80000001818B57D0LL,  isUniquelyReferenced_nonNull_native);
    swift_errorRelease(v3);
    swift_bridgeObjectRelease(0x8000000000000000LL);
  }

  v30[0] = v19;
  return _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v30, qword_189B88C48, v17, v18);
}

unint64_t *specialized Dictionary.init(dictionaryLiteral:)( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5)
  {
    uint64_t v6 = (unint64_t *)&_swiftEmptyDictionarySingleton;
    swift_retain((unint64_t *)&_swiftEmptyDictionarySingleton, a2, a3, a4);
    goto LABEL_10;
  }

  uint64_t v6 = (unint64_t *)specialized static _DictionaryStorage.allocate(capacity:)(v5);
  uint64_t v7 = *(void *)(a1 + 16);
  swift_retain(v6, v8, v9, v10);
  if (!v7)
  {
LABEL_10:
    swift_release((uint64_t)v6);
    swift_bridgeObjectRelease(a1);
    return v6;
  }

  unint64_t v11 = 0LL;
  uint64_t v12 = a1 + 32;
  while (1)
  {
    if (v11 >= *(void *)(a1 + 16)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }
    outlined init with copy of (String, Any)(v12, (uint64_t)v20);
    v20[3] = v20[0];
    v21[0] = v20[1];
    v21[1] = v20[2];
    __int128 v13 = v20[0];
    outlined init with take of Any(v21, v20);
    unint64_t v14 = specialized __RawDictionaryStorage.find<A>(_:)(v13, *((unint64_t *)&v13 + 1));
    if ((v15 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Dictionary literal contains duplicate keys",  42LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x33EuLL,  0);
    }
    *(unint64_t *)((char *)v6 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8LL) + 64) |= 1LL << v14;
    *(_OWORD *)(v6[6] + 16 * v14) = v13;
    uint64_t result = (unint64_t *)outlined init with take of Any(v20, (_OWORD *)(v6[7] + 32 * v14));
    unint64_t v17 = v6[2];
    BOOL v18 = __OFADD__(v17, 1LL);
    unint64_t v19 = v17 + 1;
    if (v18) {
      break;
    }
    ++v11;
    v6[2] = v19;
    v12 += 48LL;
    if (v7 == v11) {
      goto LABEL_10;
    }
  }

  __break(1u);
  return result;
}

unint64_t *Dictionary.init(dictionaryLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = a1;
  uint64_t v57 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  unsigned int v59 = (char *)&v49 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v58 = (char *)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v13, v14, 0LL, 0LL);
  uint64_t v16 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v19 = (char *)&v49 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v49 = v18;
  MEMORY[0x1895F8858](v17);
  unsigned int v62 = (char *)&v49 - v20;
  Swift::Int v21 = Array._getCount()();
  uint64_t v60 = a2;
  uint64_t v61 = a4;
  if (v21)
  {
    uint64_t v25 = v21;
    type metadata accessor for _DictionaryStorage(0LL, a2, v5, a4);
    unint64_t v26 = (unint64_t *)static _DictionaryStorage.allocate(capacity:)(v25);
  }

  else
  {
    unint64_t v26 = (unint64_t *)&_swiftEmptyDictionarySingleton;
  }

  swift_retain(v26, v22, v23, v24);
  Swift::Int v27 = Array._getCount()();
  uint64_t v28 = v62;
  Swift::Int v56 = v27;
  if (v27)
  {
    unint64_t v29 = 0LL;
    unint64_t v54 = v26 + 8;
    unint64_t v55 = v7 & 0xC000000000000001LL;
    uint64_t v52 = TupleTypeMetadata2;
    uint64_t v53 = v7;
    uint64_t v50 = v19;
    uint64_t v51 = v16;
    do
    {
      BOOL v30 = v55 == 0;
      char v31 = v30 | ~_swift_isClassOrObjCExistentialType((uint64_t)TupleTypeMetadata2, (uint64_t *)TupleTypeMetadata2);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v29, v31 & 1);
      if ((v31 & 1) != 0)
      {
        (*(void (**)(char *, unint64_t, unint64_t *))(v16 + 16))( v19,  v7 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80))
        + *(void *)(v16 + 72) * v29,
          TupleTypeMetadata2);
      }

      else
      {
        uint64_t v65 = v5;
        id v47 = _ArrayBuffer._getElementSlowPath(_:)(v29, v7, (uint64_t *)TupleTypeMetadata2);
        unint64_t v42 = (unint64_t)v47;
        if (v49 != 8) {
          goto LABEL_19;
        }
        id v66 = v47;
        (*(void (**)(char *, id *, unint64_t *))(v16 + 16))(v19, &v66, TupleTypeMetadata2);
        swift_unknownObjectRelease((id)v42);
        uint64_t v5 = v65;
      }

      (*(void (**)(char *, char *, unint64_t *))(v16 + 32))(v28, v19, TupleTypeMetadata2);
      if (__OFADD__(v29, 1LL))
      {
        __break(1u);
LABEL_17:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Dictionary literal contains duplicate keys",  42LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x33EuLL,  0);
      }

      unint64_t v64 = v29 + 1;
      uint64_t v65 = v29;
      uint64_t v32 = v5;
      uint64_t v33 = &v28[*((int *)TupleTypeMetadata2 + 12)];
      unint64_t v34 = *(void (**)(char *, char *, uint64_t))(v11 + 32);
      uint64_t v36 = v57;
      uint64_t v35 = (uint64_t)v58;
      uint64_t v37 = v60;
      v34(v58, v28, v60);
      unint64_t v38 = *(void (**)(char *, char *, uint64_t))(v36 + 32);
      uint64_t v39 = v59;
      v38(v59, v33, v32);
      unint64_t v40 = __RawDictionaryStorage.find<A>(_:)(v35, v37, v61);
      if ((v41 & 1) != 0) {
        goto LABEL_17;
      }
      unint64_t v42 = v40;
      *(unint64_t *)((char *)v54 + ((v40 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v40;
      unint64_t v43 = v26[6];
      uint64_t v63 = (void (*)(unint64_t, char *, uint64_t))v38;
      v34((char *)(v43 + *(void *)(v11 + 72) * v40), (char *)v35, v37);
      v63(v26[7] + *(void *)(v36 + 72) * v42, v39, v32);
      unint64_t v44 = v26[2];
      BOOL v45 = __OFADD__(v44, 1LL);
      unint64_t v46 = v44 + 1;
      if (v45)
      {
        __break(1u);
LABEL_19:
        swift_unknownObjectRelease((id)v42);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

      uint64_t v5 = v32;
      v26[2] = v46;
      unint64_t v29 = v65 + 1;
      TupleTypeMetadata2 = v52;
      uint64_t v7 = v53;
      unint64_t v19 = v50;
      uint64_t v16 = v51;
      uint64_t v28 = v62;
    }

    while (v64 != v56);
  }

  swift_release((uint64_t)v26);
  swift_bridgeObjectRelease(v7);
  return v26;
}

uint64_t Dictionary.subscript.setter(uint64_t a1, id *a2, void *a3, uint64_t a4)
{
  uint64_t v7 = a3[3];
  uint64_t v8 = type metadata accessor for Optional(0LL, v7, (uint64_t)a3, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v22 - v11;
  uint64_t v13 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v10);
  char v15 = (char *)&v22 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v13 + 48))(a1, 1LL, v7) == 1)
  {
    uint64_t v16 = *(void (**)(uint64_t, uint64_t))(v9 + 8);
    v16(a1, v8);
    uint64_t v17 = a3[2];
    uint64_t v18 = type metadata accessor for Dictionary._Variant(0LL, v17, v7, a3[4]);
    Dictionary._Variant.removeValue(forKey:)(a2, v18, v12);
    (*(void (**)(id *, uint64_t))(*(void *)(v17 - 8) + 8LL))(a2, v17);
    return ((uint64_t (*)(char *, uint64_t))v16)(v12, v8);
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v13 + 32))(v15, a1, v7);
    uint64_t v20 = a3[2];
    Swift::Int v21 = (void *)type metadata accessor for Dictionary._Variant(0LL, v20, v7, a3[4]);
    Dictionary._Variant.setValue(_:forKey:)((uint64_t)v15, (uint64_t)a2, v21);
    return (*(uint64_t (**)(id *, uint64_t))(*(void *)(v20 - 8) + 8LL))(a2, v20);
  }

unint64_t protocol witness for Error._domain.getter in conformance EncodingError()
{
  return 0xD000000000000012LL;
}

uint64_t protocol witness for Error._code.getter in conformance EncodingError()
{
  uint64_t v1 = v4[4];
  uint64_t v2 = (void *)v4[7];
  swift_bridgeObjectRelease(v4[6]);
  swift_bridgeObjectRelease(v1);
  swift_errorRelease(v2);
  __swift_destroy_boxed_opaque_existential_1Tm(v4);
  return 4866LL;
}

uint64_t Error._getEmbeddedNSError()()
{
  return 0LL;
}

unint64_t DecodingError.Context.codingPath.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_bridgeObjectRetain(*v4, a2, a3, a4);
}

uint64_t DecodingError.Context.debugDescription.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void *)(v4 + 8);
  swift_bridgeObjectRetain(*(void *)(v4 + 16), a2, a3, a4);
  return v5;
}

void *DecodingError.Context.underlyingError.getter()
{
  uint64_t v1 = *(void **)(v0 + 24);
  swift_errorRetain(v1);
  return v1;
}

uint64_t DecodingError.Context.init(codingPath:debugDescription:underlyingError:)@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

unint64_t DecodingError._domain.getter()
{
  return 0xD000000000000012LL;
}

void DecodingError._code.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  __asm { BR              X10 }

uint64_t sub_18148047C()
{
  return 4864LL;
}

void DecodingError._userInfo.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  __asm { BR              X10 }

char *sub_181480514()
{
  uint64_t v2 = *(void *)(v0 - 136);
  uint64_t v1 = *(void *)(v0 - 128);
  uint64_t v4 = *(void *)(v0 - 120);
  unint64_t v3 = *(void **)(v0 - 112);
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  inited = swift_initStackObject(v5, &v23);
  *((_OWORD *)inited + 1) = xmmword_1817FFCF0;
  strcpy((char *)inited + 32, "NSCodingPath");
  *((_BYTE *)inited + 45) = 0;
  *((_WORD *)inited + 23) = -5120;
  uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [CodingKey]);
  inited[6] = v2;
  inited[9] = v7;
  inited[10] = 0xD000000000000012LL;
  inited[15] = &type metadata for String;
  inited[11] = 0x80000001818B57B0LL;
  inited[12] = v1;
  inited[13] = v4;
  uint64_t v13 = specialized Dictionary.init(dictionaryLiteral:)((uint64_t)inited, v8, v9, v10);
  if (v3)
  {
    swift_getErrorValue(v3, &v22, &v20);
    unint64_t v14 = v20;
    uint64_t v15 = v21;
    *(void *)(v0 - 12swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v21;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm((void *)(v0 - 144));
    (*(void (**)(void *, unint64_t, uint64_t))(*(void *)(v15 - 8) + 16LL))( boxed_opaque_existential_0Tm,  v14,  v15);
    outlined init with take of Any((_OWORD *)(v0 - 144), v19);
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v13);
    specialized _NativeDictionary.setValue(_:forKey:isUnique:)( v19,  0xD000000000000011LL,  0x80000001818B57D0LL,  isUniquelyReferenced_nonNull_native);
    swift_errorRelease(v3);
    swift_bridgeObjectRelease(0x8000000000000000LL);
  }

  *(void *)(v0 - 144) = v13;
  return _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)((id *)(v0 - 144), qword_189B88C48, v11, v12);
}

void protocol witness for Error._code.getter in conformance DecodingError( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  __asm { BR              X10 }

uint64_t sub_1814806C4()
{
  return 4864LL;
}

void DefaultStringInterpolation.appendInterpolation<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3._uint64_t countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  unint64_t object = v3._object;
  String.append(_:)(v3);
  swift_bridgeObjectRelease((uint64_t)object);
}

void protocol witness for CodingKey.init(stringValue:) in conformance _GenericIndexKey( uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(_BYTE *)(a2 + 24) = 0;
  *(void *)(a2 + 16) = 0LL;
}

uint64_t protocol witness for CodingKey.intValue.getter in conformance _GenericIndexKey()
{
  return *(void *)(v0 + 16);
}

unint64_t protocol witness for CodingKey.init(intValue:) in conformance _GenericIndexKey@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = specialized _GenericIndexKey.init(intValue:)(a1);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 16) = v5;
  *(_BYTE *)(a2 + 24) = v6;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _GenericIndexKey()
{
  return specialized CodingKey.description.getter( *(void *)v0,  *(void **)(v0 + 8),  *(void *)(v0 + 16),  *(_BYTE *)(v0 + 24));
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance _GenericIndexKey( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance _GenericIndexKey( a1,  a2,  (uint64_t (*)(void, void, void, void))specialized CodingKey.description.getter);
}

unint64_t specialized static DecodingError.dataCorruptedError<A>(forKey:in:debugDescription:)@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v15 = (*(uint64_t (**)(void))(*(void *)a5 + 88LL))();
  uint64_t v16 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>);
  inited = swift_initStackObject(v16, v26);
  *((_OWORD *)inited + 1) = xmmword_1817FFC60;
  inited[7] = &type metadata for _DictionaryCodingKey;
  inited[8] = &protocol witness table for _DictionaryCodingKey;
  uint64_t v18 = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
  inited[4] = v18;
  v18[2] = a1;
  v18[3] = a2;
  v18[4] = a3;
  *((_BYTE *)v18 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = a4 & 1;
  swift_bridgeObjectRetain(a2, v19, v20, v21);
  specialized Array.append<A>(contentsOf:)( (unint64_t)inited,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
  *(void *)a8 = v15;
  *(void *)(a8 + 8) = a6;
  *(void *)(a8 + 16) = a7;
  *(void *)(a8 + 24) = 0LL;
  *(_BYTE *)(a8 + 72) = 3;
  return swift_bridgeObjectRetain(a7, v22, v23, v24);
}

unint64_t static DecodingError.dataCorruptedError<A>(forKey:in:debugDescription:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, unint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 24))(a4, a5);
  uint64_t v12 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>);
  inited = swift_initStackObject(v12, v21);
  *((_OWORD *)inited + 1) = xmmword_1817FFC60;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  inited[7] = AssociatedTypeWitness;
  inited[8] = swift_getAssociatedConformanceWitness( a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  (uint64_t)&associated conformance descriptor for KeyedDecodingContainerProtocol.KeyedDecodingContainerProtocol.Key: CodingKey);
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  (*(void (**)(void *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( boxed_opaque_existential_0Tm,  a1,  AssociatedTypeWitness);
  specialized Array.append<A>(contentsOf:)( (unint64_t)inited,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
  *(void *)a6 = v11;
  *(void *)(a6 + 8) = a2;
  *(void *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = 0LL;
  *(_BYTE *)(a6 + 72) = 3;
  return swift_bridgeObjectRetain(a3, v16, v17, v18);
}

unint64_t static DecodingError.dataCorruptedError(in:debugDescription:)@<X0>( void *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v8);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 8))(v8, v9);
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>);
  inited = swift_initStackObject(v11, v29);
  *((_OWORD *)inited + 1) = xmmword_1817FFC60;
  uint64_t v13 = a1[3];
  uint64_t v14 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v13);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 32))(v13, v14);
  unint64_t v16 = specialized _GenericIndexKey.init(intValue:)(v15);
  if (!v17) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Codable.swift",  19LL,  2,  0xEC8uLL,  0);
  }
  unint64_t v20 = v16;
  uint64_t v21 = v17;
  uint64_t v22 = v18;
  char v23 = v19;
  inited[7] = &type metadata for _GenericIndexKey;
  inited[8] = &protocol witness table for _GenericIndexKey;
  uint64_t v24 = swift_allocObject((uint64_t)&unk_189B78190, 0x29uLL, 7uLL);
  inited[4] = v24;
  v24[2] = v20;
  v24[3] = v21;
  v24[4] = v22;
  *((_BYTE *)v24 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v23 & 1;
  specialized Array.append<A>(contentsOf:)( (unint64_t)inited,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
  *(void *)a4 = v10;
  *(void *)(a4 + 8) = a2;
  *(void *)(a4 + 16) = a3;
  *(void *)(a4 + 24) = 0LL;
  *(_BYTE *)(a4 + 72) = 3;
  return swift_bridgeObjectRetain(a3, v25, v26, v27);
}

{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  *(void *)a4 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
  *(void *)(a4 + 8) = a2;
  *(void *)(a4 + 16) = a3;
  *(void *)(a4 + 24) = 0LL;
  *(_BYTE *)(a4 + 72) = 3;
  return swift_bridgeObjectRetain(a3, v9, v10, v11);
}

void _KeyedEncodingContainerBase.codingPath.getter()
{
}

void _KeyedEncodingContainerBase.encodeNil<A>(forKey:)()
{
}

void _KeyedEncodingContainerBase.encode<A>(_:forKey:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xEF9uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xEFDuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF01uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF05uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF09uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF0DuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF11uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF15uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF1AuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF1EuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF22uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF26uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF2AuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF2EuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF33uLL,  0);
}

void _KeyedEncodingContainerBase.encode<A, B>(_:forKey:)()
{
}

void _KeyedEncodingContainerBase.encodeConditional<A, B>(_:forKey:)()
{
}

void _KeyedEncodingContainerBase.encodeIfPresent<A>(_:forKey:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF46uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF4AuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF4EuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF52uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF56uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF5AuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF5EuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF62uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF67uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF6BuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF6FuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF73uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF77uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF7BuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAAB0LL,  "Swift/Codable.swift",  19LL,  2,  0xF80uLL,  0);
}

void _KeyedEncodingContainerBase.encodeIfPresent<A, B>(_:forKey:)()
{
}

void _KeyedEncodingContainerBase.nestedContainer<A, B>(keyedBy:forKey:)()
{
}

void _KeyedEncodingContainerBase.nestedUnkeyedContainer<A>(forKey:)()
{
}

void _KeyedEncodingContainerBase.superEncoder()()
{
}

void _KeyedEncodingContainerBase.superEncoder<A>(forKey:)()
{
}

uint64_t _KeyedEncodingContainerBox.codingPath.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 416);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  char v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 432), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 424) + 24LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

uint64_t _KeyedEncodingContainerBox.encodeNil<A>(forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(*(void *)v2 + 416LL);
  uint64_t v5 = *(void *)(*(void *)v2 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)v13 - v9;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v11) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))((char *)v13 - v9, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 32))(v10, v6, v5);
  return (*(uint64_t (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encode<A>(_:forKey:)(char a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(void, char *, uint64_t, uint64_t))(v7 + 40))(a1 & 1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encode<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = a2;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(v8 + 48))(a1, v17, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v17 = a2;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(v8 + 112))(a1, v17, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v17 = a2;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(v8 + 160))(a1, v17, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encode<A>(_:forKey:)(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t, double))(v7 + 56))(v12, v8, v7, a3);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encode<A>(_:forKey:)(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t, float))(v7 + 64))(v12, v8, v7, a3);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encode<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 72))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 80))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 88))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 96))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 104))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 120))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 128))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 136))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 144))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 152))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encode<A, B>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a3;
  uint64_t v18 = a5;
  uint64_t v10 = *(void *)(*(void *)v5 + 416LL);
  uint64_t v9 = *(void *)(*(void *)v5 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v17 - v13;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))((char *)&v17 - v13, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 168))(a1, v14, v17, v18, v10, v9);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeConditional<A, B>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a3;
  uint64_t v18 = a5;
  uint64_t v10 = *(void *)(*(void *)v5 + 416LL);
  uint64_t v9 = *(void *)(*(void *)v5 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v17 - v13;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))((char *)&v17 - v13, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 176))(a1, v14, v17, v18, v10, v9);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 184))(a1, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = a2;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(v8 + 192))(a1, v17, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A>(_:forKey:)( uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = a1;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, void, char *, uint64_t, uint64_t))(v8 + 200))(v17, a2 & 1, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v17 = a1;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, void, char *, uint64_t, uint64_t))(v8 + 216))(v17, a2 & 1, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v17 = a1;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, void, char *, uint64_t, uint64_t))(v8 + 248))(v17, a2 & 1, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v17 = a1;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, void, char *, uint64_t, uint64_t))(v8 + 264))(v17, a2 & 1, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v17 = a1;
  uint64_t v9 = *(void *)(*(void *)v4 + 416LL);
  uint64_t v8 = *(void *)(*(void *)v4 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v16 - v12, a3, AssociatedTypeWitness);
  (*(void (**)(uint64_t, void, char *, uint64_t, uint64_t))(v8 + 296))(v17, a2 & 1, v13, v9, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A>(_:forKey:)( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(unint64_t, char *, uint64_t, uint64_t))(v7 + 208))( a1 | ((HIDWORD(a1) & 1) << 32),  v12,  v8,  v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(unint64_t, char *, uint64_t, uint64_t))(v7 + 240))( a1 | ((HIDWORD(a1) & 1) << 32),  v12,  v8,  v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(unint64_t, char *, uint64_t, uint64_t))(v7 + 288))( a1 | ((HIDWORD(a1) & 1) << 32),  v12,  v8,  v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A>(_:forKey:)(__int16 a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(void, char *, uint64_t, uint64_t))(v7 + 224))(a1 & 0x1FF, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(void, char *, uint64_t, uint64_t))(v7 + 272))(a1 & 0x1FF, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A>(_:forKey:)(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(void, char *, uint64_t, uint64_t))(v7 + 232))(a1 & 0x1FFFF, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v8 = *(void *)(*(void *)v3 + 416LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  if (*(void *)(*(void *)(a3 - 8) + 64LL) != v13) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v15 - v11, a2, AssociatedTypeWitness);
  (*(void (**)(void, char *, uint64_t, uint64_t))(v7 + 280))(a1 & 0x1FFFF, v12, v8, v7);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A>(_:forKey:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a1;
  uint64_t v18 = a2;
  uint64_t v10 = *(void *)(*(void *)v5 + 416LL);
  uint64_t v9 = *(void *)(*(void *)v5 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v17 - v13;
  if (*(void *)(*(void *)(a5 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))((char *)&v17 - v13, a4, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t, void, char *, uint64_t, uint64_t))(v9 + 256))( v17,  v18,  a3 & 1,  v14,  v10,  v9);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  unint64_t AssociatedTypeWitness;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v17 = a1;
  uint64_t v18 = a2;
  uint64_t v10 = *(void *)(*(void *)v5 + 416LL);
  uint64_t v9 = *(void *)(*(void *)v5 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v17 - v13;
  if (*(void *)(*(void *)(a5 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))((char *)&v17 - v13, a4, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t, void, char *, uint64_t, uint64_t))(v9 + 304))( v17,  v18,  a3 & 1,  v14,  v10,  v9);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.encodeIfPresent<A, B>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a3;
  uint64_t v18 = a5;
  uint64_t v10 = *(void *)(*(void *)v5 + 416LL);
  uint64_t v9 = *(void *)(*(void *)v5 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v17 - v13;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))((char *)&v17 - v13, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 312))(a1, v14, v17, v18, v10, v9);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.nestedContainer<A, B>(keyedBy:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = a5;
  uint64_t v10 = *(void *)(*(void *)v5 + 416LL);
  uint64_t v9 = *(void *)(*(void *)v5 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v17 - v13;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))((char *)&v17 - v13, a2, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 320))(a3, v14, a3, v18, v10, v9);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.nestedUnkeyedContainer<A>(forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(*(void *)v2 + 416LL);
  uint64_t v5 = *(void *)(*(void *)v2 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v13 - v9;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v11) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))((char *)&v13 - v9, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 328))(v10, v6, v5);
  return (*(uint64_t (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.superEncoder()()
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)v0 + 424LL) + 336LL))(*(void *)(*(void *)v0 + 416LL));
}

uint64_t _KeyedEncodingContainerBox.superEncoder<A>(forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(*(void *)v2 + 416LL);
  uint64_t v5 = *(void *)(*(void *)v2 + 424LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for KeyedEncodingContainerProtocol,  associated type descriptor for KeyedEncodingContainerProtocol.Key);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v13 - v9;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v11) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))((char *)&v13 - v9, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 344))(v10, v6, v5);
  return (*(uint64_t (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
}

uint64_t _KeyedEncodingContainerBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 416LL) - 8LL) + 8LL))(v0 + *(void *)(*(void *)v0 + 432LL));
}

void _KeyedEncodingContainerBox.__deallocating_deinit()
{
}

void _KeyedDecodingContainerBase.codingPath.getter()
{
}

void _KeyedDecodingContainerBase.allKeys.getter()
{
}

void _KeyedDecodingContainerBase.contains<A>(_:)()
{
}

void _KeyedDecodingContainerBase.decodeNil<A>(forKey:)()
{
}

void _KeyedDecodingContainerBase.decode<A>(_:forKey:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1100uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1107uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x110EuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1115uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x111CuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1123uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x112AuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1131uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1139uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1140uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1147uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x114EuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1155uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x115CuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1164uLL,  0);
}

void _KeyedDecodingContainerBase.decode<A, B>(_:forKey:)()
{
}

void _KeyedDecodingContainerBase.decodeIfPresent<A>(_:forKey:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1179uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1180uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1187uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x118EuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x1195uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x119CuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11A3uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11AAuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11B2uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11B9uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11C0uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11C7uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11CEuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11D5uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11DDuLL,  0);
}

void _KeyedDecodingContainerBase.decodeIfPresent<A, B>(_:forKey:)()
{
}

void _KeyedDecodingContainerBase.nestedContainer<A, B>(keyedBy:forKey:)()
{
}

void _KeyedDecodingContainerBase.nestedUnkeyedContainer<A>(forKey:)()
{
}

void _KeyedDecodingContainerBase.superDecoder()()
{
}

void _KeyedDecodingContainerBase.superDecoder<A>(forKey:)()
{
}

uint64_t _KeyedDecodingContainerBox.codingPath.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 424);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 440), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 432) + 24LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_KeyedDecodingContainerBox.allKeys.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 424);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = &v17[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 440), v3);
  uint64_t v7 = *(void *)(v2 + 432);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  (*(void (**)(_BYTE *, uint64_t))(v4 + 8))(v6, v3);
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v3,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
  uint64_t v19 = v8;
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v12 = type metadata accessor for Array(0LL, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v12, v13);
  uint64_t v15 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOqd__Isgnrzr_xAbGSlRzAGRsd_0_r_0_lIetMgnozo_Tpq5xq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyAdGs9CodingKey_pIsgnrzr_xSaysAH_pGAGSlRzsAH_pRsd__AGRsd_0_r_0_lIetMgnozo_Tp5( (void (*)(__int128 *__return_ptr, char *))partial apply for specialized closure #1 in _arrayForceCast<A, B>(_:),  (uint64_t)v17,  v12,  WitnessTable);
  swift_bridgeObjectRelease(v8);
  return v15;
}

uint64_t _KeyedDecodingContainerBox.contains<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v9 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v5,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v18 - v13;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))((char *)&v18 - v13, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, v2 + *(void *)(*(void *)v2 + 440LL), v5);
  char v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v10 + 40))(v14, v5, v10);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  (*(void (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
  return v16 & 1;
}

uint64_t _KeyedDecodingContainerBox.decodeNil<A>(forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 48))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15 & 1;
}

uint64_t _KeyedDecodingContainerBox.decode<A>(_:forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 56))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15 & 1;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 64))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 88))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 96))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 104))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 112))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 120))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 128))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 136))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 144))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 152))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 160))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 168))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  char v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 176))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

double _KeyedDecodingContainerBox.decode<A>(_:forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v17, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  double v15 = (*(double (**)(char *, uint64_t, uint64_t))(v9 + 72))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

float _KeyedDecodingContainerBox.decode<A>(_:forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v17, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  float v15 = (*(float (**)(char *, uint64_t, uint64_t))(v9 + 80))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

uint64_t _KeyedDecodingContainerBox.decode<A, B>(_:forKey:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v21 = a3;
  uint64_t v22 = a5;
  v20[0] = a2;
  v20[1] = a6;
  uint64_t v8 = *(void *)(*(void *)v6 + 424LL);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)v20 - v16;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v15 + 16))( (char *)v20 - v16,  v20[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v6 + *(void *)(*(void *)v6 + 440LL), v8);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 184))(v21, v17, v21, v22, v8, v13);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v15 + 8))(v17, AssociatedTypeWitness);
}

uint64_t _KeyedDecodingContainerBox.decodeIfPresent<A>(_:forKey:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 192))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v18 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v17 - v12, v18, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 200))(v13, v4, v9);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v15;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v19 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v18 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v18 - v12, v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v20;
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 208))(v13, v4, v9);
  if (!v15) {
    a2 = v16;
  }
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return a2;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v18;
  void v19[2];
  v19[0] = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v11 + 16))( (char *)v19 - v12,  v19[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v19[1];
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 216))(v13, v4, v9);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v18 = v16;
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
    return v18 | ((HIDWORD(v18) & 1) << 32);
  }

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v19 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v18 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v18 - v12, v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v20;
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 224))(v13, v4, v9);
  if (!v15) {
    a2 = v16;
  }
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return a2;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  __int16 v18;
  void v19[2];
  v19[0] = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v11 + 16))( (char *)v19 - v12,  v19[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v19[1];
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 232))(v13, v4, v9);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v18 = v16;
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
    return v18 & 0x1FF;
  }

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v18;
  void v19[2];
  v19[0] = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v11 + 16))( (char *)v19 - v12,  v19[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v19[1];
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 240))(v13, v4, v9);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v18 = v16;
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
    return v18 & 0x1FFFF;
  }

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v18;
  void v19[2];
  v19[0] = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v11 + 16))( (char *)v19 - v12,  v19[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v19[1];
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 248))(v13, v4, v9);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v18 = v16;
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
    return v18 | ((HIDWORD(v18) & 1) << 32);
  }

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v19 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v18 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v18 - v12, v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v20;
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 256))(v13, v4, v9);
  if (!v15) {
    a2 = v16;
  }
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return a2;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v20 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v19 - v12, v20, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v21;
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 264))(v13, v4, v9);
  if (!v15)
  {
    a2 = v16;
    LODWORD(v21) = v17 & 1;
  }

  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return a2;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v19 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v18 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v18 - v12, v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v20;
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 272))(v13, v4, v9);
  if (!v15) {
    a2 = v16;
  }
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return a2;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  __int16 v18;
  void v19[2];
  v19[0] = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v11 + 16))( (char *)v19 - v12,  v19[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v19[1];
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 280))(v13, v4, v9);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v18 = v16;
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
    return v18 & 0x1FF;
  }

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v18;
  void v19[2];
  v19[0] = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v11 + 16))( (char *)v19 - v12,  v19[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v19[1];
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 288))(v13, v4, v9);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v18 = v16;
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
    return v18 & 0x1FFFF;
  }

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v18;
  void v19[2];
  v19[0] = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v11 + 16))( (char *)v19 - v12,  v19[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v19[1];
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 296))(v13, v4, v9);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    return (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v18 = v16;
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
    return v18 | ((HIDWORD(v18) & 1) << 32);
  }

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v19 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v18 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v18 - v12, v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v20;
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 304))(v13, v4, v9);
  if (!v15) {
    a2 = v16;
  }
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return a2;
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v20 = a1;
  uint64_t v4 = *(void *)(*(void *)v2 + 424LL);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v4,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v19 - v12, v20, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v2 + *(void *)(*(void *)v2 + 440LL), v4);
  uint64_t v15 = v21;
  uint64_t v16 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 312))(v13, v4, v9);
  if (!v15)
  {
    a2 = v16;
    LODWORD(v21) = v17 & 1;
  }

  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return a2;
}

uint64_t _KeyedDecodingContainerBox.decodeIfPresent<A, B>(_:forKey:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v21 = a3;
  uint64_t v22 = a5;
  v20[0] = a2;
  v20[1] = a6;
  uint64_t v8 = *(void *)(*(void *)v6 + 424LL);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)v20 - v16;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v15 + 16))( (char *)v20 - v16,  v20[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v6 + *(void *)(*(void *)v6 + 440LL), v8);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 320))(v21, v17, v21, v22, v8, v13);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v15 + 8))(v17, AssociatedTypeWitness);
}

uint64_t _KeyedDecodingContainerBox.nestedContainer<A, B>(keyedBy:forKey:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v21 = a3;
  uint64_t v22 = a5;
  v20[0] = a2;
  v20[1] = a6;
  uint64_t v8 = *(void *)(*(void *)v6 + 424LL);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  v8,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)v20 - v16;
  if (*(void *)(*(void *)(a4 - 8) + 64LL) != v18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v15 + 16))( (char *)v20 - v16,  v20[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v6 + *(void *)(*(void *)v6 + 440LL), v8);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 328))(v21, v17, v21, v22, v8, v13);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
  return (*(uint64_t (**)(char *, unint64_t))(v15 + 8))(v17, AssociatedTypeWitness);
}

uint64_t _KeyedDecodingContainerBox.nestedUnkeyedContainer<A>(forKey:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v17[0] = a1;
  v17[1] = a3;
  uint64_t v5 = *(void *)(*(void *)v3 + 424LL);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v9 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v5,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)v17 - v13;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v12 + 16))( (char *)v17 - v13,  v17[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, v3 + *(void *)(*(void *)v3 + 440LL), v5);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 336))(v14, v5, v10);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t _KeyedDecodingContainerBox.superDecoder()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 424);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v8 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 440), v3);
  (*(void (**)(uint64_t))(*(void *)(v2 + 432) + 344LL))(v3);
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t _KeyedDecodingContainerBox.superDecoder<A>(forKey:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v17[0] = a1;
  v17[1] = a3;
  uint64_t v5 = *(void *)(*(void *)v3 + 424LL);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v9 + 432);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v5,  (uint64_t)&protocol requirements base descriptor for KeyedDecodingContainerProtocol,  associated type descriptor for KeyedDecodingContainerProtocol.Key);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)v17 - v13;
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  (*(void (**)(char *, void, unint64_t))(v12 + 16))( (char *)v17 - v13,  v17[0],  AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, v3 + *(void *)(*(void *)v3 + 440LL), v5);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 352))(v14, v5, v10);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  return (*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
}

uint64_t _KeyedDecodingContainerBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 424LL) - 8LL) + 8LL))(v0 + *(void *)(*(void *)v0 + 440LL));
}

void _KeyedDecodingContainerBox.__deallocating_deinit()
{
}

uint64_t Bool.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  unsigned __int8 v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    unsigned __int8 v5 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 24))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5 & 1;
}

uint64_t Bool.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 24))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Bool(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 24))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Bool@<X0>( uint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  char v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 24))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9 & 1;
  return result;
}

uint64_t RawRepresentable<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v15;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 24))(v8, v9, v10);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void v13[2];
  uint64_t v14[3];
  uint64_t v15;
  uint64_t v16;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v14, v6, v7);
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v13, a2, a4);
  uint64_t v8 = v13[0];
  uint64_t v9 = v13[1];
  uint64_t v10 = v15;
  uint64_t v11 = v16;
  __swift_mutable_project_boxed_opaque_existential_1(v14, v15);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 32))(v8, v9, v10, v11);
  swift_bridgeObjectRelease(v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v14);
}

{
  uint64_t v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  double v12;
  uint64_t v13[3];
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v13, v6, v7);
  (*(void (**)(double *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v12, a2, a4);
  uint64_t v8 = v12;
  uint64_t v9 = v14;
  uint64_t v10 = v15;
  __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
  (*(void (**)(uint64_t, uint64_t, double))(v10 + 40))(v9, v10, v8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v13);
}

{
  uint64_t v6;
  uint64_t v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(char *__return_ptr, uint64_t, uint64_t))(v7 + 40))((char *)v12 + 4, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v12, a2, a4);
  uint64_t v8 = *(float *)v12;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1((uint64_t *)((char *)v12 + 4), v13);
  (*(void (**)(uint64_t, uint64_t, float))(v10 + 48))(v9, v10, v8);
  return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)((char *)v12 + 4));
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v15;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(v8, v9, v10);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v13;
  uint64_t v9 = v14;
  uint64_t v10 = v15;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 64))(v10, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v13;
  uint64_t v9 = v14;
  uint64_t v10 = (unsigned __int16)v15;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 72))(v10, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v15;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 80))(v8, v9, v10);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v15;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 88))(v8, v9, v10);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void v13[3];
  uint64_t v14[3];
  uint64_t v15;
  uint64_t v16;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v14, v6, v7);
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v13, a2, a4);
  uint64_t v9 = v13[0];
  uint64_t v8 = v13[1];
  uint64_t v10 = v15;
  uint64_t v11 = v16;
  __swift_mutable_project_boxed_opaque_existential_1(v14, v15);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 96))(v9, v8, v10, v11);
  return __swift_destroy_boxed_opaque_existential_1Tm(v14);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v15;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 104))(v8, v9, v10);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v13;
  uint64_t v9 = v14;
  uint64_t v10 = v15;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 112))(v10, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v13;
  uint64_t v9 = v14;
  uint64_t v10 = (unsigned __int16)v15;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 120))(v10, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v15;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 128))(v8, v9, v10);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v12, v6, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a4 + 24))(&v15, a2, a4);
  uint64_t v8 = v15;
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 136))(v8, v9, v10);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void v13[3];
  uint64_t v14[3];
  uint64_t v15;
  uint64_t v16;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 40))(v14, v6, v7);
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a4 + 24))(v13, a2, a4);
  uint64_t v9 = v13[0];
  uint64_t v8 = v13[1];
  uint64_t v10 = v15;
  uint64_t v11 = v16;
  __swift_mutable_project_boxed_opaque_existential_1(v14, v15);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 144))(v9, v8, v10, v11);
  return __swift_destroy_boxed_opaque_existential_1Tm(v14);
}

uint64_t RawRepresentable<>.init(from:)@<X0>( uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v104 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v102 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  int64x2_t v108 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v105, v14, v13);
  if (!v5)
  {
    uint64_t v103 = v9;
    uint64_t v15 = v104;
    uint64_t v16 = v106;
    uint64_t v17 = v107;
    __swift_project_boxed_opaque_existential_0Tm(&v105, v106);
    char v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 24))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v105._countAndFlagsBits);
    LOBYTE(v105._countAndFlagsBits) = v18 & 1;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v105, a2, v15);
    uint64_t v19 = *(void *)(a2 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v19 + 48))(v12, 1LL, a2) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v19 + 32))(a5, v12, a2);
      return __swift_destroy_boxed_opaque_existential_1Tm(v108);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v103);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v21 = v20;
    uint64_t v22 = v108[3];
    uint64_t v23 = v108[4];
    __swift_project_boxed_opaque_existential_0Tm(v108, v22);
    uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v23 + 8))(v22, v23);
    uint64_t v24 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v26 = v25;
    v105._uint64_t countAndFlagsBits = v24;
    v105._unint64_t object = (void *)v25;
    uint64_t v27 = HIBYTE(v25) & 0xF;
    if ((v25 & 0x2000000000000000LL) == 0) {
      uint64_t v27 = v24 & 0xFFFFFFFFFFFFLL;
    }
    if (v27 || (v24 & ~v25 & 0x2000000000000000LL) != 0)
    {
      if ((v25 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (unint64_t v28 = specialized _SmallString.init(_:appending:)( v24,  v25,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v30 & 1) == 0))
      {
        uint64_t v31 = v28;
        uint64_t v32 = v29;
        swift_bridgeObjectRelease(v26);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v105._uint64_t countAndFlagsBits = v31;
        v105._unint64_t object = v32;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v34 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v34 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v34);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v25);
      v105._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v105._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if (v36 < 0) {
      goto LABEL_102;
    }
    uint64_t v37 = (uint8x16_t *)TypeName;
    int64_t v38 = v36;
    int64_t v39 = validateUTF8(_:)(TypeName, v36);
    if ((v41 & 1) != 0) {
      unint64_t v42 = repairUTF8(_:firstKnownBrokenRange:)(v37->i8, v38, v39, v40);
    }
    else {
      unint64_t v42 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v37, v38, v39 & 1);
    }
    uint64_t v44 = v42;
    unint64_t v45 = v43;
    unint64_t object = v105._object;
    unint64_t v47 = ((unint64_t)v105._object >> 56) & 0xF;
    if (!v47 && (v105._countAndFlagsBits & ~(uint64_t)v105._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v105._object);
      v105._uint64_t countAndFlagsBits = v44;
      v105._unint64_t object = (void *)v45;
LABEL_33:
      Swift::String v54 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      uint64_t v55 = HIBYTE(v45) & 0xF;
      if ((v45 & 0x2000000000000000LL) == 0) {
        uint64_t v55 = v44 & 0xFFFFFFFFFFFFLL;
      }
      if (!v55 && (v44 & ~v45 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v45);
        Swift::String v105 = v54;
LABEL_46:
        unsigned int v62 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Bool, 0);
        if ((v63 & 0x8000000000000000LL) == 0)
        {
          unint64_t v64 = (uint8x16_t *)v62;
          int64_t v65 = v63;
          int64_t v66 = validateUTF8(_:)(v62, v63);
          if ((v68 & 1) != 0) {
            unint64_t v69 = repairUTF8(_:firstKnownBrokenRange:)(v64->i8, v65, v66, v67);
          }
          else {
            unint64_t v69 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v64, v65, v66 & 1);
          }
          uint64_t v71 = v69;
          unint64_t v72 = v70;
          uint64_t v73 = v105._object;
          unint64_t v74 = ((unint64_t)v105._object >> 56) & 0xF;
          if (!v74 && (v105._countAndFlagsBits & ~(uint64_t)v105._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v105._object);
            v105._uint64_t countAndFlagsBits = v71;
            v105._unint64_t object = (void *)v72;
            goto LABEL_63;
          }

          if (((uint64_t)v105._object & 0x2000000000000000LL) != 0)
          {
            if ((v70 & 0x2000000000000000LL) != 0)
            {
              unint64_t v76 = specialized _SmallString.init(_:appending:)( v105._countAndFlagsBits,  (unint64_t)v105._object,  v69,  v70);
              if ((v78 & 1) == 0)
              {
                uint64_t v79 = v76;
                uint64_t v80 = v77;
                swift_bridgeObjectRelease((uint64_t)v73);
                swift_bridgeObjectRelease(v72);
                v105._uint64_t countAndFlagsBits = v79;
                v105._unint64_t object = v80;
                unint64_t v72 = (unint64_t)v80;
                uint64_t v71 = v79;
LABEL_63:
                uint64_t v81 = HIBYTE(v72) & 0xF;
                if ((v72 & 0x2000000000000000LL) == 0) {
                  uint64_t v81 = v71 & 0xFFFFFFFFFFFFLL;
                }
                if (v81 || (v71 & ~v72 & 0x2000000000000000LL) != 0)
                {
                  if ((v72 & 0x2000000000000000LL) == 0
                    || (unint64_t v82 = specialized _SmallString.init(_:appending:)( v71,  v72,  0x2065756C617620uLL,  0xE700000000000000LL),  (v84 & 1) != 0))
                  {
                    _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                    swift_bridgeObjectRelease(0xE700000000000000LL);
                  }

                  else
                  {
                    uint64_t v85 = v82;
                    uint64_t v86 = v83;
                    swift_bridgeObjectRelease(v72);
                    swift_bridgeObjectRelease(0xE700000000000000LL);
                    v105._uint64_t countAndFlagsBits = v85;
                    v105._unint64_t object = v86;
                  }
                }

                else
                {
                  swift_bridgeObjectRelease(v72);
                  v105._uint64_t countAndFlagsBits = 0x2065756C617620LL;
                  v105._unint64_t object = (void *)0xE700000000000000LL;
                }

                if ((v18 & 1) != 0) {
                  uint64_t countAndFlagsBits = 1702195828LL;
                }
                else {
                  uint64_t countAndFlagsBits = 0x65736C6166LL;
                }
                if ((v18 & 1) != 0) {
                  unint64_t v88 = 0xE400000000000000LL;
                }
                else {
                  unint64_t v88 = 0xE500000000000000LL;
                }
                uint64_t v89 = v105._object;
                unint64_t v90 = ((unint64_t)v105._object >> 56) & 0xF;
                if (v90 || (v105._countAndFlagsBits & ~(uint64_t)v105._object & 0x2000000000000000LL) != 0)
                {
                  if (((uint64_t)v105._object & 0x2000000000000000LL) == 0
                    || (unint64_t v91 = specialized _SmallString.init(_:appending:)( v105._countAndFlagsBits,  (unint64_t)v105._object,  countAndFlagsBits,  v88),  (v93 & 1) != 0))
                  {
                    _StringGuts.append(_:)(countAndFlagsBits, v88, 0LL, HIBYTE(v88) & 5);
                    swift_bridgeObjectRelease(v88);
                    uint64_t countAndFlagsBits = v105._countAndFlagsBits;
                    unint64_t v88 = (unint64_t)v105._object;
                  }

                  else
                  {
                    uint64_t v94 = v91;
                    unint64_t v95 = v92;
                    swift_bridgeObjectRelease((uint64_t)v89);
                    swift_bridgeObjectRelease(v88);
                    v105._uint64_t countAndFlagsBits = v94;
                    v105._unint64_t object = v95;
                    unint64_t v88 = (unint64_t)v95;
                    uint64_t countAndFlagsBits = v94;
                  }
                }

                else
                {
                  swift_bridgeObjectRelease((uint64_t)v105._object);
                  v105._uint64_t countAndFlagsBits = countAndFlagsBits;
                  v105._unint64_t object = (void *)v88;
                }

                uint64_t v96 = HIBYTE(v88) & 0xF;
                if ((v88 & 0x2000000000000000LL) == 0) {
                  uint64_t v96 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
                }
                if (v96 || (countAndFlagsBits & ~v88 & 0x2000000000000000LL) != 0)
                {
                  if ((v88 & 0x2000000000000000LL) == 0
                    || (unint64_t v97 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v88,  0LL,  0xE000000000000000LL),  (v99 & 1) != 0))
                  {
                    _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                    swift_bridgeObjectRelease(0xE000000000000000LL);
                    uint64_t v100 = v105._countAndFlagsBits;
                    int64x2_t v101 = v105._object;
                  }

                  else
                  {
                    uint64_t v100 = v97;
                    int64x2_t v101 = v98;
                    swift_bridgeObjectRelease(v88);
                    swift_bridgeObjectRelease(0xE000000000000000LL);
                  }
                }

                else
                {
                  swift_bridgeObjectRelease(v88);
                  uint64_t v100 = 0LL;
                  int64x2_t v101 = (void *)0xE000000000000000LL;
                }

                *(void *)uint64_t v21 = v104;
                *(void *)(v21 + 8) = v100;
                *(void *)(v21 + 16) = v101;
                *(void *)(v21 + 24) = 0LL;
                *(_BYTE *)(v21 + 72) = 3;
                swift_willThrow();
                return __swift_destroy_boxed_opaque_existential_1Tm(v108);
              }

              goto LABEL_61;
            }
          }

          else if ((v70 & 0x2000000000000000LL) != 0)
          {
LABEL_61:
            uint64_t v75 = HIBYTE(v72) & 0xF;
            goto LABEL_62;
          }

          uint64_t v75 = v69 & 0xFFFFFFFFFFFFLL;
LABEL_62:
          _StringGuts.append(_:)(v71, v72, 0LL, v75);
          swift_bridgeObjectRelease(v72);
          uint64_t v71 = v105._countAndFlagsBits;
          unint64_t v72 = (unint64_t)v105._object;
          goto LABEL_63;
        }

LABEL_102:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v45 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v54._object & 0x2000000000000000LL) != 0)
        {
          unint64_t v57 = specialized _SmallString.init(_:appending:)( v44,  v45,  v54._countAndFlagsBits,  (unint64_t)v54._object);
          if ((v59 & 1) == 0)
          {
            uint64_t v60 = v57;
            uint64_t v61 = v58;
            swift_bridgeObjectRelease(v45);
            swift_bridgeObjectRelease((uint64_t)v54._object);
            v105._uint64_t countAndFlagsBits = v60;
            v105._unint64_t object = v61;
            goto LABEL_46;
          }

          goto LABEL_44;
        }
      }

      else if (((uint64_t)v54._object & 0x2000000000000000LL) != 0)
      {
LABEL_44:
        uint64_t v56 = ((unint64_t)v54._object >> 56) & 0xF;
        goto LABEL_45;
      }

      uint64_t v56 = v54._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_45:
      _StringGuts.append(_:)(v54._countAndFlagsBits, (unint64_t)v54._object, 0LL, v56);
      swift_bridgeObjectRelease((uint64_t)v54._object);
      goto LABEL_46;
    }

    if (((uint64_t)v105._object & 0x2000000000000000LL) != 0)
    {
      if ((v43 & 0x2000000000000000LL) != 0)
      {
        unint64_t v49 = specialized _SmallString.init(_:appending:)( v105._countAndFlagsBits,  (unint64_t)v105._object,  v42,  v43);
        if ((v51 & 1) == 0)
        {
          uint64_t v52 = v49;
          uint64_t v53 = v50;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v45);
          v105._uint64_t countAndFlagsBits = v52;
          v105._unint64_t object = v53;
          unint64_t v45 = (unint64_t)v53;
          uint64_t v44 = v52;
          goto LABEL_33;
        }

        goto LABEL_31;
      }
    }

    else if ((v43 & 0x2000000000000000LL) != 0)
    {
LABEL_31:
      uint64_t v48 = HIBYTE(v45) & 0xF;
      goto LABEL_32;
    }

    uint64_t v48 = v42 & 0xFFFFFFFFFFFFLL;
LABEL_32:
    _StringGuts.append(_:)(v44, v45, 0LL, v48);
    swift_bridgeObjectRelease(v45);
    uint64_t v44 = v105._countAndFlagsBits;
    unint64_t v45 = (unint64_t)v105._object;
    goto LABEL_33;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v108);
}

    uint64_t v261 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
    unint64_t v262 = lazy protocol witness table accessor for type Int and conformance Int(v257, v258, v259);
    v261(&v624, &type metadata for Int, v262, v69, v67);
    LOBYTE(v261) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v130,  v123,  v69);
    v202(v123, v69);
    goto LABEL_130;
  }

  if (v257 < 64)
  {
LABEL_120:
    ((void (*)(char *, char *, unint64_t *))v171)(v123, v130, v69);
    uint64_t v287 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
    v202(v123, v69);
    uint64_t v288 = v624;
LABEL_129:
    if (v287 >= v288) {
      goto LABEL_130;
    }
LABEL_281:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

                unsigned int v135 = (char *)_StringObject.sharedUTF8.getter(v134, v133);
                goto LABEL_74;
              }

              goto LABEL_103;
            }

            goto LABEL_135;
          }

          v197 &= 0xFFFFFFFFFFFFFFuLL;
          uint64_t v37 = v188 >> 16;
          int64x2_t v108 = v187 >> 16;
          int8x16_t v109 = v190[1];
          if ((v109 & 0x2000000000000000LL) != 0) {
            int8x16_t v110 = HIBYTE(v109) & 0xF;
          }
          else {
            int8x16_t v110 = *v190 & 0xFFFFFFFFFFFFLL;
          }
          uint8x8_t v111 = v110 - v108 + (HIBYTE(v35) & 0xF) + (v188 >> 16);
          if (v111 > 15)
          {
            uint16x8_t v112 = _StringGuts.uniqueNativeCapacity.getter();
            if ((v113 & 1) != 0 || v112 < v111)
            {
              uint64x2_t v114 = _StringGuts.uniqueNativeCapacity.getter();
              if ((v115 & 1) != 0)
              {
                int8x16_t v132 = v36[1];
                if ((v132 & 0x1000000000000000LL) != 0)
                {
                  uint64x2_t v116 = String.UTF8View._foreignCount()();
                }

                else if ((v132 & 0x2000000000000000LL) != 0)
                {
                  uint64x2_t v116 = HIBYTE(v132) & 0xF;
                }

                else
                {
                  uint64x2_t v116 = *v36 & 0xFFFFFFFFFFFFLL;
                }
              }

              else
              {
                uint64x2_t v116 = 2 * v114;
              }

              if (v116 > v111) {
                uint8x8_t v111 = v116;
              }
              unint64_t v138 = v36[1];
              if ((v138 & 0x1000000000000000LL) != 0)
              {
                _StringGuts._foreignGrow(_:)(v111);
              }

              else
              {
                unsigned int v139 = *v36;
                if ((v138 & 0x2000000000000000LL) != 0)
                {
                  unint64_t v143 = HIBYTE(v138) & 0xF;
                  __src = *v36;
                  uint64_t v192 = v138 & 0xFFFFFFFFFFFFFFLL;
                  unint64_t v144 = v143 | 0xC000000000000000LL;
                  if ((v138 & 0x4000000000000000LL) == 0) {
                    unint64_t v144 = HIBYTE(v138) & 0xF;
                  }
                  uint64_t v145 = v144 | 0x3000000000000000LL;
                  uint64_t v142 = _allocateStringStorage(codeUnitCapacity:)(v111);
                  *(void *)(v142 + 16) = v146;
                  *(void *)(v142 + 24) = v145;
                  if (v146 < 0)
                  {
                    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
                    uint64_t v145 = *(void *)(v142 + 24);
                  }

                  *(_BYTE *)(v142 + 32 + (v145 & 0xFFFFFFFFFFFFLL)) = 0;
                  specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v143, (char *)(v142 + 32));
                }

                else
                {
                  if ((v139 & 0x1000000000000000LL) != 0)
                  {
                    unint64_t v140 = (char *)((v138 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    unint64_t v141 = v139 & 0xFFFFFFFFFFFFLL;
                  }

                  else
                  {
                    unint64_t v140 = (char *)_StringObject.sharedUTF8.getter(*v36, v138);
                  }

                  uint64_t v142 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v140,  v141,  v111,  v139 < 0);
                }

                unint64_t v147 = *(void *)(v142 + 24);
                swift_bridgeObjectRelease(v36[1]);
                *uint64_t v36 = v147;
                v36[1] = v142;
              }
            }
          }

          uint64_t v148 = v36[1];
          uint64_t v149 = (char *)&v196;
          Swift::Int v150 = v37;
          uint64_t v151 = v108;
          unint64_t v152 = HIBYTE(v35) & 0xF;
LABEL_125:
          __StringStorage.replace(from:to:with:)(v150, v151, v149, v152);
          swift_bridgeObjectRelease(v35);
          *uint64_t v36 = *(void *)(v148 + 24);
          return v37;
        }

        goto LABEL_126;
      }

      v33(v25, v34, v6);
      uint64_t v92 = swift_dynamicCast( (char *)&v196,  v25,  (swift *)v6,  (const char *)&type metadata for Substring.UnicodeScalarView,  6uLL);
      uint64_t v36 = v190;
      if ((v92 & 1) == 0)
      {
LABEL_127:
        Swift::String::Index v171 = v185;
        v33((uint64_t *)v185, v34, v6);
        Swift::String::Index v172 = v182;
        (*(void (**)(uint64_t, char *, char *))(v22 + 32))(v182, v171, v6);
        Swift::String::Index v173 = (void *)(v172 + *(int *)(v10 + 44));
        *Swift::String::Index v173 = protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar;
        v173[1] = 0LL;
        unint64_t v195 = v186;
        unint64_t v174 = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v10, &v195);
        unint64_t v177 = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View( v174,  v175,  v176);
        v194[0] = v174;
        v194[1] = v177;
        unint64_t v193 = swift_getWitnessTable(&protocol conformance descriptor for <> FlattenSequence<A>, v16, v194);
        unint64_t v178 = v184;
        unint64_t v179 = swift_getWitnessTable(&protocol conformance descriptor for <> LazySequence<A>, v184, &v193);
        uint64_t v37 = _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)(v188, v187, v172, v178, v179);
        (*(void (**)(uint64_t, uint64_t))(v183 + 8))(v172, v178);
        return v37;
      }

      uint64_t v35 = v199;
      if ((v199 & 0x1000000000000000LL) != 0)
      {
LABEL_126:
        swift_bridgeObjectRelease(v35);
        goto LABEL_127;
      }

      char v93 = v197;
      int64_t v40 = v196 >> 16;
      uint64_t v94 = v197 >> 16;
      if ((v199 & 0x2000000000000000LL) != 0)
      {
        uint32x4_t v117 = HIBYTE(v199) & 0xF;
        unint64_t v196 = v198;
        unint64_t v197 = v199 & 0xFFFFFFFFFFFFFFLL;
        if (v117 >= v94)
        {
          uint64x2_t v118 = specialized UnsafeBufferPointer.init(rebasing:)(v40, v93 >> 16, (uint64_t)&v196, v117);
          uint64_t v37 = v188 >> 16;
          uint16x8_t v120 = (v188 >> 16) + v119;
          if (!__OFADD__(v188 >> 16, v119))
          {
            uint64_t v10 = v187 >> 16;
            int8x16_t v121 = v36[1];
            if ((v121 & 0x2000000000000000LL) != 0) {
              uint16x8_t v122 = HIBYTE(v121) & 0xF;
            }
            else {
              uint16x8_t v122 = *v36 & 0xFFFFFFFFFFFFLL;
            }
            int8x16_t v123 = v122 - v10;
            int64_t v40 = v120 + v123;
            if (!__OFADD__(v120, v123))
            {
              int8x16_t v124 = (char *)v118;
              int8x8_t v125 = v119;
              if (v40 >= 16)
              {
                int8x16_t v126 = _StringGuts.uniqueNativeCapacity.getter();
                if ((v127 & 1) != 0 || v126 < v40)
                {
                  uint64x2_t v128 = _StringGuts.uniqueNativeCapacity.getter();
                  if ((v129 & 1) != 0)
                  {
                    uint64_t v154 = v36[1];
                    if ((v154 & 0x1000000000000000LL) != 0)
                    {
                      int8x16_t v130 = String.UTF8View._foreignCount()();
                    }

                    else if ((v154 & 0x2000000000000000LL) != 0)
                    {
                      int8x16_t v130 = HIBYTE(v154) & 0xF;
                    }

                    else
                    {
                      int8x16_t v130 = *v36 & 0xFFFFFFFFFFFFLL;
                    }
                  }

                  else
                  {
                    int8x16_t v130 = 2 * v128;
                  }

                  if (v130 > v40) {
                    int64_t v40 = v130;
                  }
                  uint64_t v161 = v36[1];
                  if ((v161 & 0x1000000000000000LL) != 0)
                  {
                    _StringGuts._foreignGrow(_:)(v40);
                  }

                  else
                  {
                    unint64_t v162 = *v36;
                    if ((v161 & 0x2000000000000000LL) != 0)
                    {
                      Swift::String::Index v166 = HIBYTE(v161) & 0xF;
                      __src = *v36;
                      uint64_t v192 = v161 & 0xFFFFFFFFFFFFFFLL;
                      unint64_t v167 = v166 | 0xC000000000000000LL;
                      if ((v161 & 0x4000000000000000LL) == 0) {
                        unint64_t v167 = HIBYTE(v161) & 0xF;
                      }
                      unint64_t v168 = v167 | 0x3000000000000000LL;
                      uint64_t v165 = _allocateStringStorage(codeUnitCapacity:)(v40);
                      *(void *)(v165 + 16) = v169;
                      *(void *)(v165 + 24) = v168;
                      if (v169 < 0)
                      {
                        *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
                        unint64_t v168 = *(void *)(v165 + 24);
                      }

                      *(_BYTE *)(v165 + 32 + (v168 & 0xFFFFFFFFFFFFLL)) = 0;
                      specialized UnsafeMutablePointer.initialize(from:count:)( (char *)&__src,  v166,  (char *)(v165 + 32));
                      uint64_t v36 = v190;
                    }

                    else
                    {
                      if ((v162 & 0x1000000000000000LL) != 0)
                      {
                        unint64_t v163 = (char *)((v161 & 0xFFFFFFFFFFFFFFFLL) + 32);
                        uint64_t v164 = v162 & 0xFFFFFFFFFFFFLL;
                      }

                      else
                      {
                        unint64_t v163 = (char *)_StringObject.sharedUTF8.getter(*v36, v161);
                      }

                      uint64_t v165 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v163,  v164,  v40,  v162 < 0);
                    }

                    Swift::String::Index v170 = *(void *)(v165 + 24);
                    swift_bridgeObjectRelease(v36[1]);
                    *uint64_t v36 = v170;
                    v36[1] = v165;
                  }
                }
              }

              uint64_t v148 = v36[1];
              Swift::Int v150 = v37;
              uint64_t v151 = v10;
              uint64_t v149 = v124;
              unint64_t v152 = v125;
              goto LABEL_125;
            }

  uint64_t v21 = 0;
  uint64_t v8 = 0;
LABEL_103:
  uint64_t v83 = v8;
LABEL_104:
  LOBYTE(v82[0]) = (a2 & 0x1000000000000000LL) != 0;
  return v21 | (v83 << 8) | (LOBYTE(v82[0]) << 16);
}

  uint64_t v21 = 0;
  uint64_t v8 = 0;
LABEL_103:
  char v99 = v8;
LABEL_104:
  LOBYTE(v98[0]) = (a2 & 0x1000000000000000LL) != 0;
  return v21 | (v99 << 8) | (LOBYTE(v98[0]) << 16);
}

  uint64_t v21 = 0;
  uint64_t v8 = 0;
LABEL_103:
  uint64_t v83 = v8;
LABEL_104:
  LOBYTE(v82[0]) = (a2 & 0x1000000000000000LL) != 0;
  return v21 | (v83 << 16) | (LOBYTE(v82[0]) << 24);
}

  uint64_t v21 = 0;
  uint64_t v8 = 0;
LABEL_103:
  char v99 = v8;
LABEL_104:
  LOBYTE(v98[0]) = (a2 & 0x1000000000000000LL) != 0;
  return v21 | (v99 << 16) | (LOBYTE(v98[0]) << 24);
}

            char v59 = v4 & 0xFFFFFFFFFFFFLL;
LABEL_108:
            _StringGuts.append(_:)(v4, object, 0LL, v59);
            swift_bridgeObjectRelease(object);
            unint64_t object = (unint64_t)v88._object;
            uint64_t v4 = v88._countAndFlagsBits;
LABEL_109:
            int64_t v65 = HIBYTE(object) & 0xF;
            if ((object & 0x2000000000000000LL) == 0) {
              int64_t v65 = v4 & 0xFFFFFFFFFFFFLL;
            }
            if (v65 || (v4 & ~object & 0x2000000000000000LL) != 0)
            {
              if ((object & 0x2000000000000000LL) != 0)
              {
                int64_t v66 = specialized _SmallString.init(_:appending:)(v4, object, 0LL, 0xE000000000000000LL);
                if ((v68 & 1) == 0)
                {
                  uint64_t countAndFlagsBits = v66;
                  uint64_t v7 = v67;
                  swift_bridgeObjectRelease(0xE000000000000000LL);
                  swift_bridgeObjectRelease(object);
                  goto LABEL_118;
                }
              }

              _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
LABEL_117:
              swift_bridgeObjectRelease(0xE000000000000000LL);
              uint64_t v7 = v88._object;
              uint64_t countAndFlagsBits = v88._countAndFlagsBits;
              goto LABEL_118;
            }

        size_t v160 = v155 & 0xFFFFFFFFFFFFLL;
        goto LABEL_124;
      }

      if ((v154 & 0x2000000000000000LL) == 0) {
        goto LABEL_102;
      }
      uint64_t v181 = specialized _SmallString.init(_:appending:)(v450, v451, v155, v154);
      if ((v183 & 1) != 0)
      {
        size_t v160 = HIBYTE(v156) & 0xF;
        Swift::Int v150 = v443;
        uint64_t v159 = v145;
        goto LABEL_124;
      }

      Swift::String::Index v184 = v181;
      char v185 = v182;
      swift_bridgeObjectRelease(v156);
      swift_bridgeObjectRelease(v157);
      v450 = v184;
      v451 = v185;
      Swift::Int v150 = v443;
    }

    else
    {
      swift_bridgeObjectRelease(v451);
      v450 = v155;
      v451 = v156;
    }

    uint64_t v159 = v145;
LABEL_125:
    uint64_t v199 = v143;
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_131;
  }

  memcpy(v83, v87, v2);
  if ((swift_dynamicCast((char *)&v444, (uint64_t *)v83, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t countAndFlagsBits = v444._countAndFlagsBits;
    unint64_t object = (unint64_t)v444._object;
    unint64_t v163 = v451;
    uint64_t v164 = HIBYTE(v451) & 0xF;
    if ((v451 & 0x2000000000000000LL) == 0) {
      uint64_t v164 = v450 & 0xFFFFFFFFFFFFLL;
    }
    Swift::Int v150 = v443;
    uint64_t v159 = v145;
    if (!v164 && (v450 & ~v451 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v451);
      v450 = countAndFlagsBits;
      v451 = object;
      goto LABEL_130;
    }

    if ((v451 & 0x2000000000000000LL) == 0)
    {
      if (((uint64_t)v444._object & 0x2000000000000000LL) != 0)
      {
        uint64_t v165 = ((unint64_t)v444._object >> 56) & 0xF;
LABEL_129:
        _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v165);
        swift_bridgeObjectRelease(object);
        goto LABEL_130;
      }

    uint64_t v52 = v31;
    if ((_DWORD)v27)
    {
      unint64_t v42 = 0LL;
      do
      {
        unint64_t v43 = *v8;
        uint64_t v44 = *v8 & 0x1F;
        if ((v44 - 17) >= 2)
        {
          if (v44 != 16) {
            goto LABEL_130;
          }
          if ((v43 & 0x20000000) != 0)
          {
            unint64_t v45 = swift::getResilientImmediateMembersOffset((uint64_t)v8, a2, a3, a4);
            unint64_t v43 = *v8;
          }

          else
          {
            if ((v43 & 0x10000000) != 0)
            {
              unint64_t v46 = 0;
              unint64_t v47 = v8 + 6;
            }

            else
            {
              unint64_t v46 = v8[7];
              unint64_t v47 = v8 + 8;
            }

            unint64_t v45 = v46 - *v47;
          }
        }

        else
        {
          unint64_t v45 = 2;
        }

        uint64_t v48 = *(void *)(a1 + 8LL * v45 + 8 * v42);
        if ((v43 & 0x1Fu) - 17 >= 2)
        {
          if ((v43 & 0x1F) != 0x10) {
            goto LABEL_130;
          }
          if ((v43 & 0x20000000) != 0)
          {
            unint64_t v49 = swift::getResilientImmediateMembersOffset((uint64_t)v8, a2, a3, a4);
          }

          else
          {
            if ((v43 & 0x10000000) != 0)
            {
              uint64_t v50 = 0;
              char v51 = v8 + 6;
            }

            else
            {
              uint64_t v50 = v8[7];
              char v51 = v8 + 8;
            }

            unint64_t v49 = v50 - *v51;
          }
        }

        else
        {
          unint64_t v49 = 2;
        }

        if ((swift::compareGenericMetadata(v48, *(void *)(a2 + 8LL * v49 + 8 * v42)) & 1) == 0)
        {
          validationLog(1, "Generic argument %u does not match", v42);
          uint64_t v21 = 0;
        }

        ++v42;
      }

      while (v42 < *((unsigned __int16 *)v23 + 6));
    }

    if ((v21 & 1) == 0) {
      goto LABEL_30;
    }
    return 1LL;
  }

  validationLog(1, "Descriptor is not generic and pointers are not identical");
LABEL_30:
  validationLog(1, "Error: original and new metadata do not match!");
  validationLog(1, "Original metadata:");
  v56[0] = (void (*)(const char *, ...))printToStderr;
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpMetadata( v56,  (void *)a1,  (uint64_t)v53);
  uint64_t v13 = v55;
  if (v55 != -1)
  {
    ((void (*)(void (**)(const char *, ...), void *))off_189B8B2E0[v55])(v56, v53);
    if (v13 == 1)
    {
      if (v54 >= 0) {
        uint64_t v14 = (const char *)v53;
      }
      else {
        uint64_t v14 = (const char *)v53[0];
      }
      validationLog(1, "error dumping original metadata: %s", v14);
    }
  }

  validationLog(1, "New metadata builder:");
  v56[0] = (void (*)(const char *, ...))printToStderr;
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpMetadata( v56,  (void *)a2,  (uint64_t)v53);
  uint64_t v15 = v55;
  if (v55 != -1)
  {
    ((void (*)(void (**)(const char *, ...), void *))off_189B8B2E0[v55])(v56, v53);
    if (v15 == 1)
    {
      if (v54 >= 0) {
        uint64_t v16 = (const char *)v53;
      }
      else {
        uint64_t v16 = (const char *)v53[0];
      }
      validationLog(1, "error dumping new metadata: %s", v16);
    }
  }

  return 0LL;
}

void *String.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 32))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t String.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v10, v5, v6);
  uint64_t v7 = v11;
  uint64_t v8 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 32))(a2, a3, v7, v8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v10);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance String(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v9, v4, v5);
  uint64_t v6 = v10;
  uint64_t v7 = v11;
  __swift_mutable_project_boxed_opaque_existential_1(v9, v10);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 32))(v2, v3, v6, v7);
  return __swift_destroy_boxed_opaque_existential_1Tm(v9);
}

uint64_t protocol witness for Decodable.init(from:) in conformance String@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v13, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v14;
  uint64_t v8 = v15;
  __swift_project_boxed_opaque_existential_0Tm(v13, v14);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 32))(v7, v8);
  uint64_t v11 = v10;
  __swift_destroy_boxed_opaque_existential_1Tm(v13);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  a2[1] = v11;
  return result;
}

uint64_t RawRepresentable<>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v117 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v113 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  int8x16_t v121 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v118, v14, v13);
  if (!v5)
  {
    uint64_t v114 = v10;
    uint64x2_t v115 = v12;
    uint64_t v15 = v117;
    unint64_t v116 = a2;
    uint64_t v16 = v119;
    uint64_t v17 = v120;
    __swift_project_boxed_opaque_existential_0Tm(&v118, v119);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 32))(v16, v17);
    uint64_t v20 = v19;
    __swift_destroy_boxed_opaque_existential_1Tm(&v118._countAndFlagsBits);
    uint64_t v113 = v18;
    v118._uint64_t countAndFlagsBits = v18;
    v118._unint64_t object = v20;
    uint64_t v21 = v15;
    uint64_t v22 = *(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16);
    swift_bridgeObjectRetain((unint64_t)v20, v23, v24, v25);
    uint64_t v26 = v115;
    unint64_t v27 = v116;
    v22(&v118, v116, v21);
    uint64_t v28 = *(void *)(v27 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v28 + 48))(v26, 1LL, v27) != 1)
    {
      swift_bridgeObjectRelease((uint64_t)v20);
      (*(void (**)(uint64_t, char *, unint64_t))(v28 + 32))(a5, v26, v27);
      return __swift_destroy_boxed_opaque_existential_1Tm(v121);
    }

    unint64_t v29 = (unint64_t)v20;
    (*(void (**)(char *, uint64_t))(v114 + 8))(v26, v9);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v31 = v30;
    uint64_t v32 = v121[3];
    uint64_t v33 = v121[4];
    __swift_project_boxed_opaque_existential_0Tm(v121, v32);
    uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(v33 + 8))(v32, v33);
    uint64_t v35 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v37 = v36;
    v118._uint64_t countAndFlagsBits = v35;
    v118._unint64_t object = (void *)v36;
    uint64_t v38 = HIBYTE(v36) & 0xF;
    if ((v36 & 0x2000000000000000LL) == 0) {
      uint64_t v38 = v35 & 0xFFFFFFFFFFFFLL;
    }
    if (v38 || (v35 & ~v36 & 0x2000000000000000LL) != 0)
    {
      if ((v36 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (unint64_t v39 = specialized _SmallString.init(_:appending:)( v35,  v36,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v41 & 1) == 0))
      {
        uint64_t v42 = v39;
        unint64_t v43 = v40;
        swift_bridgeObjectRelease(v37);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v118._uint64_t countAndFlagsBits = v42;
        v118._unint64_t object = v43;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v45 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v45 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v45);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      unint64_t v27 = v116;
    }

    else
    {
      swift_bridgeObjectRelease(v36);
      v118._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v118._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v27, 0);
    if (v47 < 0) {
      goto LABEL_103;
    }
    uint64_t v48 = (uint8x16_t *)TypeName;
    int64_t v49 = v47;
    int64_t v50 = validateUTF8(_:)(TypeName, v47);
    if ((v52 & 1) != 0) {
      unint64_t v53 = repairUTF8(_:firstKnownBrokenRange:)(v48->i8, v49, v50, v51);
    }
    else {
      unint64_t v53 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v48, v49, v50 & 1);
    }
    uint64_t v55 = v53;
    unint64_t v56 = v54;
    unint64_t object = v118._object;
    unint64_t v58 = ((unint64_t)v118._object >> 56) & 0xF;
    if (!v58 && (v118._countAndFlagsBits & ~(uint64_t)v118._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v118._object);
      v118._uint64_t countAndFlagsBits = v55;
      v118._unint64_t object = (void *)v56;
LABEL_34:
      Swift::String v65 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      uint64_t v66 = HIBYTE(v56) & 0xF;
      if ((v56 & 0x2000000000000000LL) == 0) {
        uint64_t v66 = v55 & 0xFFFFFFFFFFFFLL;
      }
      if (!v66 && (v55 & ~v56 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v56);
        Swift::String v118 = v65;
LABEL_47:
        uint64_t v73 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for String, 0);
        if ((v74 & 0x8000000000000000LL) == 0)
        {
          uint64_t v75 = (uint8x16_t *)v73;
          int64_t v76 = v74;
          int64_t v77 = validateUTF8(_:)(v73, v74);
          if ((v79 & 1) != 0) {
            unint64_t v80 = repairUTF8(_:firstKnownBrokenRange:)(v75->i8, v76, v77, v78);
          }
          else {
            unint64_t v80 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v75, v76, v77 & 1);
          }
          uint64_t v82 = v80;
          unint64_t v83 = v81;
          char v84 = v118._object;
          unint64_t v85 = ((unint64_t)v118._object >> 56) & 0xF;
          if (!v85 && (v118._countAndFlagsBits & ~(uint64_t)v118._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v118._object);
            v118._uint64_t countAndFlagsBits = v82;
            v118._unint64_t object = (void *)v83;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            uint64_t v93 = HIBYTE(v83) & 0xF;
            if ((v83 & 0x2000000000000000LL) == 0) {
              uint64_t v93 = v82 & 0xFFFFFFFFFFFFLL;
            }
            if (v93 || (v82 & ~v83 & 0x2000000000000000LL) != 0)
            {
              if ((v83 & 0x2000000000000000LL) == 0
                || (unint64_t v94 = specialized _SmallString.init(_:appending:)( v82,  v83,  0x2065756C617620uLL,  0xE700000000000000LL),  (v96 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v118._countAndFlagsBits;
                unint64_t v97 = (unint64_t)v118._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v94;
              unint64_t v97 = v95;
              swift_bridgeObjectRelease(v83);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v83);
              unint64_t v97 = 0xE700000000000000LL;
            }

            v118._uint64_t countAndFlagsBits = countAndFlagsBits;
            v118._unint64_t object = (void *)v97;
LABEL_78:
            uint64_t v98 = HIBYTE(v97) & 0xF;
            if ((v97 & 0x2000000000000000LL) == 0) {
              uint64_t v98 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v98 && (countAndFlagsBits & ~v97 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v97);
              unint64_t v106 = v113;
              v118._uint64_t countAndFlagsBits = v113;
              v118._unint64_t object = (void *)v29;
              goto LABEL_91;
            }

            if ((v97 & 0x2000000000000000LL) != 0)
            {
              if ((v29 & 0x2000000000000000LL) != 0)
              {
                unint64_t v101 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v97, v113, v29);
                if ((v103 & 1) == 0)
                {
                  uint64_t v104 = v101;
                  Swift::String v105 = v102;
                  swift_bridgeObjectRelease(v97);
                  swift_bridgeObjectRelease(v29);
                  v118._uint64_t countAndFlagsBits = v104;
                  v118._unint64_t object = v105;
                  unint64_t v29 = (unint64_t)v105;
                  unint64_t v106 = v104;
LABEL_91:
                  uint64_t v107 = HIBYTE(v29) & 0xF;
                  if ((v29 & 0x2000000000000000LL) == 0) {
                    uint64_t v107 = v106 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v107 || (v106 & ~v29 & 0x2000000000000000LL) != 0)
                  {
                    if ((v29 & 0x2000000000000000LL) == 0
                      || (unint64_t v108 = specialized _SmallString.init(_:appending:)(v106, v29, 0LL, 0xE000000000000000LL),
                          (v110 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      uint64_t v111 = v118._countAndFlagsBits;
                      uint16x8_t v112 = v118._object;
                    }

                    else
                    {
                      uint64_t v111 = v108;
                      uint16x8_t v112 = v109;
                      swift_bridgeObjectRelease(v29);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v29);
                    uint64_t v111 = 0LL;
                    uint16x8_t v112 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v31 = v34;
                  *(void *)(v31 + 8) = v111;
                  *(void *)(v31 + 16) = v112;
                  *(void *)(v31 + 24) = 0LL;
                  *(_BYTE *)(v31 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v121);
                }

                goto LABEL_89;
              }
            }

            else if ((v29 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v100 = HIBYTE(v29) & 0xF;
              uint64_t v99 = v113;
              goto LABEL_90;
            }

            uint64_t v99 = v113;
            uint64_t v100 = v113 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v99, v29, 0LL, v100);
            swift_bridgeObjectRelease(v29);
            unint64_t v106 = v118._countAndFlagsBits;
            unint64_t v29 = (unint64_t)v118._object;
            goto LABEL_91;
          }

          if (((uint64_t)v118._object & 0x2000000000000000LL) != 0)
          {
            if ((v81 & 0x2000000000000000LL) != 0)
            {
              unint64_t v87 = specialized _SmallString.init(_:appending:)( v118._countAndFlagsBits,  (unint64_t)v118._object,  v80,  v81);
              if ((v89 & 1) == 0)
              {
                uint64_t v90 = v87;
                unint64_t v91 = v88;
                swift_bridgeObjectRelease((uint64_t)v84);
                swift_bridgeObjectRelease(v83);
                v118._uint64_t countAndFlagsBits = v90;
                v118._unint64_t object = v91;
                unint64_t v83 = (unint64_t)v91;
                uint64_t v82 = v90;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v81 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            uint64_t v86 = HIBYTE(v83) & 0xF;
            goto LABEL_63;
          }

          uint64_t v86 = v80 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v82, v83, 0LL, v86);
          swift_bridgeObjectRelease(v83);
          uint64_t v82 = v118._countAndFlagsBits;
          unint64_t v83 = (unint64_t)v118._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  void *v32;
  char v33;
  uint64_t v34;
  void *v35;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t countAndFlagsBits;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  unint64_t v84;
  void *v85;
  char v86;
  uint64_t v87;
  void *v88;
  void *v89;
  unint64_t v90;
  unint64_t v91;
  void *v92;
  char v93;
  uint64_t v94;
  void *v95;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  Swift::String v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v98 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v97 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v99 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v100, v14, v13);
  if (v5) {
    return __swift_destroy_boxed_opaque_existential_1Tm(v99);
  }
  unint64_t v97 = v9;
  uint64_t v15 = v98;
  uint64_t v16 = a5;
  uint64_t v17 = v101;
  uint64_t v18 = v102;
  __swift_project_boxed_opaque_existential_0Tm(&v100, v101);
  uint64_t v19 = (*(double (**)(uint64_t, uint64_t))(v18 + 40))(v17, v18);
  __swift_destroy_boxed_opaque_existential_1Tm(&v100._countAndFlagsBits);
  v100._uint64_t countAndFlagsBits = v19;
  uint64_t v20 = a2;
  (*(void (**)(Swift::String *, uint64_t, uint64_t))(v15 + 16))(&v100, a2, v15);
  uint64_t v21 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v21 + 48))(v12, 1LL, a2) != 1)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v21 + 32))(v16, v12, a2);
    return __swift_destroy_boxed_opaque_existential_1Tm(v99);
  }

  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v97);
  swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
  uint64_t v23 = v22;
  uint64_t v24 = v99[3];
  unint64_t v25 = v99[4];
  __swift_project_boxed_opaque_existential_0Tm(v99, v24);
  uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(v25 + 8))(v24, v25);
  unint64_t v27 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
  unint64_t v29 = v28;
  v100._uint64_t countAndFlagsBits = v27;
  v100._unint64_t object = (void *)v28;
  uint64_t v30 = HIBYTE(v28) & 0xF;
  if ((v28 & 0x2000000000000000LL) == 0) {
    uint64_t v30 = v27 & 0xFFFFFFFFFFFFLL;
  }
  if (v30 || (v27 & ~v28 & 0x2000000000000000LL) != 0)
  {
    if ((v28 & 0x2000000000000000LL) != 0
      && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
      && (uint64_t v31 = specialized _SmallString.init(_:appending:)( v27,  v28,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v33 & 1) == 0))
    {
      uint64_t v34 = v31;
      uint64_t v35 = v32;
      swift_bridgeObjectRelease(v29);
      swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      v100._uint64_t countAndFlagsBits = v34;
      v100._unint64_t object = v35;
    }

    else
    {
      if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
        unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
      }
      else {
        unint64_t v36 = 18LL;
      }
      _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
      swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v28);
    v100._uint64_t countAndFlagsBits = 0xD000000000000012LL;
    v100._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
  }

  TypeName = (uint64_t *)swift_getTypeName(v20, 0);
  if (v38 < 0) {
LABEL_88:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  unint64_t v39 = (uint8x16_t *)TypeName;
  int64_t v40 = v38;
  char v41 = validateUTF8(_:)(TypeName, v38);
  if ((v43 & 1) != 0) {
    uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
  }
  else {
    uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
  }
  uint64_t countAndFlagsBits = v44;
  uint64_t v47 = v45;
  unint64_t object = v100._object;
  int64_t v49 = ((unint64_t)v100._object >> 56) & 0xF;
  if (v49 || (v100._countAndFlagsBits & ~(uint64_t)v100._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v100._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v100._countAndFlagsBits,  (unint64_t)v100._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v100._uint64_t countAndFlagsBits = v54;
          v100._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          uint64_t countAndFlagsBits = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(countAndFlagsBits, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    uint64_t countAndFlagsBits = v100._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v100._object;
    goto LABEL_34;
  }

  swift_bridgeObjectRelease((uint64_t)v100._object);
  v100._uint64_t countAndFlagsBits = countAndFlagsBits;
  v100._unint64_t object = (void *)v47;
LABEL_34:
  unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
  unint64_t v57 = HIBYTE(v47) & 0xF;
  if ((v47 & 0x2000000000000000LL) == 0) {
    unint64_t v57 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v57 || (countAndFlagsBits & ~v47 & 0x2000000000000000LL) != 0)
  {
    if ((v47 & 0x2000000000000000LL) != 0)
    {
      if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
        uint64_t v59 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
        if ((v61 & 1) == 0)
        {
          char v62 = v59;
          uint64_t v63 = v60;
          swift_bridgeObjectRelease(v47);
          swift_bridgeObjectRelease((uint64_t)v56._object);
          v100._uint64_t countAndFlagsBits = v62;
          v100._unint64_t object = v63;
          goto LABEL_47;
        }

        goto LABEL_45;
      }
    }

    else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
    {
LABEL_45:
      unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
      goto LABEL_46;
    }

    unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
    _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
    swift_bridgeObjectRelease((uint64_t)v56._object);
    goto LABEL_47;
  }

  swift_bridgeObjectRelease(v47);
  uint64_t v100 = v56;
LABEL_47:
  unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Double, 0);
  if (v65 < 0) {
    goto LABEL_88;
  }
  uint64_t v66 = (uint8x16_t *)v64;
  uint64_t v67 = v65;
  unint64_t v68 = validateUTF8(_:)(v64, v65);
  if ((v70 & 1) != 0) {
    uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
  }
  else {
    uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
  }
  uint64_t v73 = v71;
  uint64_t v74 = v72;
  uint64_t v75 = v100._object;
  int64_t v76 = ((unint64_t)v100._object >> 56) & 0xF;
  if (v76 || (v100._countAndFlagsBits & ~(uint64_t)v100._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v100._object & 0x2000000000000000LL) == 0)
    {
      if ((v72 & 0x2000000000000000LL) != 0)
      {
        int64_t v77 = HIBYTE(v72) & 0xF;
LABEL_67:
        _StringGuts.append(_:)(v73, v74, 0LL, v77);
        swift_bridgeObjectRelease(v74);
        uint64_t v73 = v100._countAndFlagsBits;
        uint64_t v74 = (unint64_t)v100._object;
        goto LABEL_68;
      }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  void *v32;
  char v33;
  uint64_t v34;
  void *v35;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t countAndFlagsBits;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  unint64_t v84;
  void *v85;
  char v86;
  uint64_t v87;
  void *v88;
  void *v89;
  unint64_t v90;
  unint64_t v91;
  void *v92;
  char v93;
  uint64_t v94;
  void *v95;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  Swift::String v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v98 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v97 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v99 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v100, v14, v13);
  if (v5) {
    return __swift_destroy_boxed_opaque_existential_1Tm(v99);
  }
  unint64_t v97 = v9;
  uint64_t v15 = v98;
  uint64_t v16 = a5;
  uint64_t v17 = v101;
  uint64_t v18 = v102;
  __swift_project_boxed_opaque_existential_0Tm(&v100, v101);
  uint64_t v19 = (*(float (**)(uint64_t, uint64_t))(v18 + 48))(v17, v18);
  __swift_destroy_boxed_opaque_existential_1Tm(&v100._countAndFlagsBits);
  *(float *)&v100._uint64_t countAndFlagsBits = v19;
  uint64_t v20 = a2;
  (*(void (**)(Swift::String *, uint64_t, uint64_t))(v15 + 16))(&v100, a2, v15);
  uint64_t v21 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v21 + 48))(v12, 1LL, a2) != 1)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v21 + 32))(v16, v12, a2);
    return __swift_destroy_boxed_opaque_existential_1Tm(v99);
  }

  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v97);
  swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
  uint64_t v23 = v22;
  uint64_t v24 = v99[3];
  unint64_t v25 = v99[4];
  __swift_project_boxed_opaque_existential_0Tm(v99, v24);
  uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(v25 + 8))(v24, v25);
  unint64_t v27 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
  unint64_t v29 = v28;
  v100._uint64_t countAndFlagsBits = v27;
  v100._unint64_t object = (void *)v28;
  uint64_t v30 = HIBYTE(v28) & 0xF;
  if ((v28 & 0x2000000000000000LL) == 0) {
    uint64_t v30 = v27 & 0xFFFFFFFFFFFFLL;
  }
  if (v30 || (v27 & ~v28 & 0x2000000000000000LL) != 0)
  {
    if ((v28 & 0x2000000000000000LL) != 0
      && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
      && (uint64_t v31 = specialized _SmallString.init(_:appending:)( v27,  v28,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v33 & 1) == 0))
    {
      uint64_t v34 = v31;
      uint64_t v35 = v32;
      swift_bridgeObjectRelease(v29);
      swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      v100._uint64_t countAndFlagsBits = v34;
      v100._unint64_t object = v35;
    }

    else
    {
      if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
        unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
      }
      else {
        unint64_t v36 = 18LL;
      }
      _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
      swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v28);
    v100._uint64_t countAndFlagsBits = 0xD000000000000012LL;
    v100._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
  }

  TypeName = (uint64_t *)swift_getTypeName(v20, 0);
  if (v38 < 0) {
LABEL_88:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  unint64_t v39 = (uint8x16_t *)TypeName;
  int64_t v40 = v38;
  char v41 = validateUTF8(_:)(TypeName, v38);
  if ((v43 & 1) != 0) {
    uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
  }
  else {
    uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
  }
  uint64_t countAndFlagsBits = v44;
  uint64_t v47 = v45;
  unint64_t object = v100._object;
  int64_t v49 = ((unint64_t)v100._object >> 56) & 0xF;
  if (v49 || (v100._countAndFlagsBits & ~(uint64_t)v100._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v100._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v100._countAndFlagsBits,  (unint64_t)v100._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v100._uint64_t countAndFlagsBits = v54;
          v100._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          uint64_t countAndFlagsBits = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(countAndFlagsBits, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    uint64_t countAndFlagsBits = v100._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v100._object;
    goto LABEL_34;
  }

  swift_bridgeObjectRelease((uint64_t)v100._object);
  v100._uint64_t countAndFlagsBits = countAndFlagsBits;
  v100._unint64_t object = (void *)v47;
LABEL_34:
  unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
  unint64_t v57 = HIBYTE(v47) & 0xF;
  if ((v47 & 0x2000000000000000LL) == 0) {
    unint64_t v57 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v57 || (countAndFlagsBits & ~v47 & 0x2000000000000000LL) != 0)
  {
    if ((v47 & 0x2000000000000000LL) != 0)
    {
      if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
        uint64_t v59 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
        if ((v61 & 1) == 0)
        {
          char v62 = v59;
          uint64_t v63 = v60;
          swift_bridgeObjectRelease(v47);
          swift_bridgeObjectRelease((uint64_t)v56._object);
          v100._uint64_t countAndFlagsBits = v62;
          v100._unint64_t object = v63;
          goto LABEL_47;
        }

        goto LABEL_45;
      }
    }

    else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
    {
LABEL_45:
      unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
      goto LABEL_46;
    }

    unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
    _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
    swift_bridgeObjectRelease((uint64_t)v56._object);
    goto LABEL_47;
  }

  swift_bridgeObjectRelease(v47);
  uint64_t v100 = v56;
LABEL_47:
  unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Float, 0);
  if (v65 < 0) {
    goto LABEL_88;
  }
  uint64_t v66 = (uint8x16_t *)v64;
  uint64_t v67 = v65;
  unint64_t v68 = validateUTF8(_:)(v64, v65);
  if ((v70 & 1) != 0) {
    uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
  }
  else {
    uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
  }
  uint64_t v73 = v71;
  uint64_t v74 = v72;
  uint64_t v75 = v100._object;
  int64_t v76 = ((unint64_t)v100._object >> 56) & 0xF;
  if (v76 || (v100._countAndFlagsBits & ~(uint64_t)v100._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v100._object & 0x2000000000000000LL) == 0)
    {
      if ((v72 & 0x2000000000000000LL) != 0)
      {
        int64_t v77 = HIBYTE(v72) & 0xF;
LABEL_67:
        _StringGuts.append(_:)(v73, v74, 0LL, v77);
        swift_bridgeObjectRelease(v74);
        uint64_t v73 = v100._countAndFlagsBits;
        uint64_t v74 = (unint64_t)v100._object;
        goto LABEL_68;
      }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 56))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    v108._uint64_t countAndFlagsBits = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Int, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            uint64_t v90 = _int64ToString(_:radix:uppercase:)( v18,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
            unint64_t v91 = v89;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              v108._uint64_t countAndFlagsBits = v90;
              v108._unint64_t object = (void *)v91;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if ((v89 & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v88, v90, v89);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease(v91);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if ((v89 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = HIBYTE(v91) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v90 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v90, v91, 0LL, v93);
            swift_bridgeObjectRelease(v91);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 64))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    LOBYTE(v108._countAndFlagsBits) = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Int8, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            uint64_t v90 = _int64ToString(_:radix:uppercase:)( v18,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
            unint64_t v91 = v89;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              v108._uint64_t countAndFlagsBits = v90;
              v108._unint64_t object = (void *)v91;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if ((v89 & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v88, v90, v89);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease(v91);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if ((v89 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = HIBYTE(v91) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v90 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v90, v91, 0LL, v93);
            swift_bridgeObjectRelease(v91);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int16 v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 72))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    LOWORD(v108._countAndFlagsBits) = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Int16, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            uint64_t v90 = _int64ToString(_:radix:uppercase:)( v18,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
            unint64_t v91 = v89;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              v108._uint64_t countAndFlagsBits = v90;
              v108._unint64_t object = (void *)v91;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if ((v89 & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v88, v90, v89);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease(v91);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if ((v89 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = HIBYTE(v91) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v90 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v90, v91, 0LL, v93);
            swift_bridgeObjectRelease(v91);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 80))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    LODWORD(v108._countAndFlagsBits) = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Int32, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            uint64_t v90 = _int64ToString(_:radix:uppercase:)( v18,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
            unint64_t v91 = v89;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              v108._uint64_t countAndFlagsBits = v90;
              v108._unint64_t object = (void *)v91;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if ((v89 & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v88, v90, v89);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease(v91);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if ((v89 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = HIBYTE(v91) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v90 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v90, v91, 0LL, v93);
            swift_bridgeObjectRelease(v91);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 88))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    v108._uint64_t countAndFlagsBits = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Int64, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            uint64_t v90 = _int64ToString(_:radix:uppercase:)( v18,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
            unint64_t v91 = v89;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              v108._uint64_t countAndFlagsBits = v90;
              v108._unint64_t object = (void *)v91;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if ((v89 & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v88, v90, v89);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease(v91);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if ((v89 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = HIBYTE(v91) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v90 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v90, v91, 0LL, v93);
            swift_bridgeObjectRelease(v91);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  char v34;
  uint64_t v35;
  void *v36;
  unint64_t v38;
  uint64_t *TypeName;
  uint64_t v40;
  uint8x16_t *v41;
  int64_t v42;
  int64_t v43;
  int64_t v44;
  char v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  void *object;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  void *v54;
  char v55;
  uint64_t v56;
  void *v57;
  Swift::String v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  void *v62;
  char v63;
  uint64_t v64;
  void *v65;
  uint64_t *v66;
  uint64_t v67;
  uint8x16_t *v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  char v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  void *v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  void *v81;
  char v82;
  uint64_t v83;
  void *v84;
  uint64_t countAndFlagsBits;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  char v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  void *v97;
  char v98;
  uint64_t v99;
  void *v100;
  uint64_t v101;
  unint64_t v102;
  void *v103;
  char v104;
  uint64_t v105;
  void *v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  Swift::String v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t *v114;
  char v110 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v107 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v114 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v111, v14, v13);
  if (!v5)
  {
    unint64_t v108 = v9;
    int8x16_t v109 = a2;
    uint64_t v15 = v110;
    uint64_t v16 = v112;
    uint64_t v17 = v113;
    __swift_project_boxed_opaque_existential_0Tm(&v111, v112);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 96))(v16, v17);
    uint64_t v20 = v19;
    __swift_destroy_boxed_opaque_existential_1Tm(&v111._countAndFlagsBits);
    uint64_t v107 = v18;
    v111._uint64_t countAndFlagsBits = v18;
    v111._unint64_t object = v20;
    uint64_t v21 = v109;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v111, v109, v15);
    uint64_t v22 = *(void *)(v21 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v22 + 48))(v12, 1LL, v21) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v22 + 32))(a5, v12, v21);
      return __swift_destroy_boxed_opaque_existential_1Tm(v114);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v108);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v24 = v23;
    unint64_t v25 = v114[3];
    uint64_t v26 = v114[4];
    __swift_project_boxed_opaque_existential_0Tm(v114, v25);
    unint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 8))(v25, v26);
    uint64_t v28 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v30 = v29;
    v111._uint64_t countAndFlagsBits = v28;
    v111._unint64_t object = (void *)v29;
    uint64_t v31 = HIBYTE(v29) & 0xF;
    if ((v29 & 0x2000000000000000LL) == 0) {
      uint64_t v31 = v28 & 0xFFFFFFFFFFFFLL;
    }
    if (v31 || (v28 & ~v29 & 0x2000000000000000LL) != 0)
    {
      if ((v29 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v32 = specialized _SmallString.init(_:appending:)( v28,  v29,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v34 & 1) == 0))
      {
        uint64_t v35 = v32;
        unint64_t v36 = v33;
        swift_bridgeObjectRelease(v30);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v111._uint64_t countAndFlagsBits = v35;
        v111._unint64_t object = v36;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          uint64_t v38 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          uint64_t v38 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v38);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v21 = v109;
    }

    else
    {
      swift_bridgeObjectRelease(v29);
      v111._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v111._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v21, 0);
    if (v40 < 0) {
      goto LABEL_103;
    }
    char v41 = (uint8x16_t *)TypeName;
    uint64_t v42 = v40;
    unint64_t v43 = validateUTF8(_:)(TypeName, v40);
    if ((v45 & 1) != 0) {
      unint64_t v46 = repairUTF8(_:firstKnownBrokenRange:)(v41->i8, v42, v43, v44);
    }
    else {
      unint64_t v46 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v41, v42, v43 & 1);
    }
    uint64_t v48 = v46;
    int64_t v49 = v47;
    unint64_t object = v111._object;
    int64_t v51 = ((unint64_t)v111._object >> 56) & 0xF;
    if (!v51 && (v111._countAndFlagsBits & ~(uint64_t)v111._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v111._object);
      v111._uint64_t countAndFlagsBits = v48;
      v111._unint64_t object = (void *)v49;
LABEL_34:
      unint64_t v58 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      uint64_t v59 = HIBYTE(v49) & 0xF;
      if ((v49 & 0x2000000000000000LL) == 0) {
        uint64_t v59 = v48 & 0xFFFFFFFFFFFFLL;
      }
      if (!v59 && (v48 & ~v49 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v49);
        uint64_t v111 = v58;
LABEL_47:
        uint64_t v66 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Int128, 0);
        if ((v67 & 0x8000000000000000LL) == 0)
        {
          unint64_t v68 = (uint8x16_t *)v66;
          unint64_t v69 = v67;
          char v70 = validateUTF8(_:)(v66, v67);
          if ((v72 & 1) != 0) {
            uint64_t v73 = repairUTF8(_:firstKnownBrokenRange:)(v68->i8, v69, v70, v71);
          }
          else {
            uint64_t v73 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v68, v69, v70 & 1);
          }
          uint64_t v75 = v73;
          int64_t v76 = v74;
          int64_t v77 = v111._object;
          int64_t v78 = ((unint64_t)v111._object >> 56) & 0xF;
          if (!v78 && (v111._countAndFlagsBits & ~(uint64_t)v111._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v111._object);
            v111._uint64_t countAndFlagsBits = v75;
            v111._unint64_t object = (void *)v76;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            uint64_t v86 = HIBYTE(v76) & 0xF;
            if ((v76 & 0x2000000000000000LL) == 0) {
              uint64_t v86 = v75 & 0xFFFFFFFFFFFFLL;
            }
            if (v86 || (v75 & ~v76 & 0x2000000000000000LL) != 0)
            {
              if ((v76 & 0x2000000000000000LL) == 0
                || (unint64_t v87 = specialized _SmallString.init(_:appending:)( v75,  v76,  0x2065756C617620uLL,  0xE700000000000000LL),  (v89 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v111._countAndFlagsBits;
                uint64_t v90 = (unint64_t)v111._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v87;
              uint64_t v90 = v88;
              swift_bridgeObjectRelease(v76);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v76);
              uint64_t v90 = 0xE700000000000000LL;
            }

            v111._uint64_t countAndFlagsBits = countAndFlagsBits;
            v111._unint64_t object = (void *)v90;
LABEL_78:
            uint64_t v92 = specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, v107, (uint64_t)v20);
            uint64_t v93 = v91;
            unint64_t v94 = HIBYTE(v90) & 0xF;
            if ((v90 & 0x2000000000000000LL) == 0) {
              unint64_t v94 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v94 && (countAndFlagsBits & ~v90 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v90);
              v111._uint64_t countAndFlagsBits = v92;
              v111._unint64_t object = (void *)v93;
              goto LABEL_91;
            }

            if ((v90 & 0x2000000000000000LL) != 0)
            {
              if ((v91 & 0x2000000000000000LL) != 0)
              {
                char v96 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v90, v92, v91);
                if ((v98 & 1) == 0)
                {
                  uint64_t v99 = v96;
                  uint64_t v100 = v97;
                  swift_bridgeObjectRelease(v90);
                  swift_bridgeObjectRelease(v93);
                  v111._uint64_t countAndFlagsBits = v99;
                  v111._unint64_t object = v100;
                  uint64_t v93 = (unint64_t)v100;
                  uint64_t v92 = v99;
LABEL_91:
                  unint64_t v101 = HIBYTE(v93) & 0xF;
                  if ((v93 & 0x2000000000000000LL) == 0) {
                    unint64_t v101 = v92 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v101 || (v92 & ~v93 & 0x2000000000000000LL) != 0)
                  {
                    if ((v93 & 0x2000000000000000LL) == 0
                      || (uint64_t v102 = specialized _SmallString.init(_:appending:)(v92, v93, 0LL, 0xE000000000000000LL),
                          (v104 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      Swift::String v105 = v111._countAndFlagsBits;
                      unint64_t v106 = v111._object;
                    }

                    else
                    {
                      Swift::String v105 = v102;
                      unint64_t v106 = v103;
                      swift_bridgeObjectRelease(v93);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v93);
                    Swift::String v105 = 0LL;
                    unint64_t v106 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v24 = v27;
                  *(void *)(v24 + 8) = v105;
                  *(void *)(v24 + 16) = v106;
                  *(void *)(v24 + 24) = 0LL;
                  *(_BYTE *)(v24 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v114);
                }

                goto LABEL_89;
              }
            }

            else if ((v91 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              unint64_t v95 = HIBYTE(v93) & 0xF;
              goto LABEL_90;
            }

            unint64_t v95 = v92 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v92, v93, 0LL, v95);
            swift_bridgeObjectRelease(v93);
            uint64_t v92 = v111._countAndFlagsBits;
            uint64_t v93 = (unint64_t)v111._object;
            goto LABEL_91;
          }

          if (((uint64_t)v111._object & 0x2000000000000000LL) != 0)
          {
            if ((v74 & 0x2000000000000000LL) != 0)
            {
              unint64_t v80 = specialized _SmallString.init(_:appending:)( v111._countAndFlagsBits,  (unint64_t)v111._object,  v73,  v74);
              if ((v82 & 1) == 0)
              {
                unint64_t v83 = v80;
                char v84 = v81;
                swift_bridgeObjectRelease((uint64_t)v77);
                swift_bridgeObjectRelease(v76);
                v111._uint64_t countAndFlagsBits = v83;
                v111._unint64_t object = v84;
                int64_t v76 = (unint64_t)v84;
                uint64_t v75 = v83;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v74 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            char v79 = HIBYTE(v76) & 0xF;
            goto LABEL_63;
          }

          char v79 = v73 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v75, v76, 0LL, v79);
          swift_bridgeObjectRelease(v76);
          uint64_t v75 = v111._countAndFlagsBits;
          int64_t v76 = (unint64_t)v111._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  Swift::String v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 104))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    v108._uint64_t countAndFlagsBits = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for UInt, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            char v89 = _uint64ToString(_:radix:uppercase:)(v18, 10LL, 0);
            uint64_t v90 = v89._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v89._object;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              unint64_t v108 = v89;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v88,  v89._countAndFlagsBits,  (unint64_t)v89._object);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease((uint64_t)v89._object);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = ((unint64_t)v89._object >> 56) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v89._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v89._countAndFlagsBits, (unint64_t)v89._object, 0LL, v93);
            swift_bridgeObjectRelease((uint64_t)v89._object);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  Swift::String v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 112))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    LOBYTE(v108._countAndFlagsBits) = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for UInt8, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            char v89 = _uint64ToString(_:radix:uppercase:)(v18, 10LL, 0);
            uint64_t v90 = v89._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v89._object;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              unint64_t v108 = v89;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v88,  v89._countAndFlagsBits,  (unint64_t)v89._object);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease((uint64_t)v89._object);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = ((unint64_t)v89._object >> 56) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v89._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v89._countAndFlagsBits, (unint64_t)v89._object, 0LL, v93);
            swift_bridgeObjectRelease((uint64_t)v89._object);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  Swift::String v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 120))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    LOWORD(v108._countAndFlagsBits) = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for UInt16, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            char v89 = _uint64ToString(_:radix:uppercase:)(v18, 10LL, 0);
            uint64_t v90 = v89._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v89._object;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              unint64_t v108 = v89;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v88,  v89._countAndFlagsBits,  (unint64_t)v89._object);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease((uint64_t)v89._object);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = ((unint64_t)v89._object >> 56) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v89._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v89._countAndFlagsBits, (unint64_t)v89._object, 0LL, v93);
            swift_bridgeObjectRelease((uint64_t)v89._object);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  Swift::String v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 128))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    LODWORD(v108._countAndFlagsBits) = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for UInt32, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            char v89 = _uint64ToString(_:radix:uppercase:)(v18, 10LL, 0);
            uint64_t v90 = v89._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v89._object;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              unint64_t v108 = v89;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v88,  v89._countAndFlagsBits,  (unint64_t)v89._object);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease((uint64_t)v89._object);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = ((unint64_t)v89._object >> 56) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v89._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v89._countAndFlagsBits, (unint64_t)v89._object, 0LL, v93);
            swift_bridgeObjectRelease((uint64_t)v89._object);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  unint64_t v36;
  uint64_t *TypeName;
  uint64_t v38;
  uint8x16_t *v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *object;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  char v53;
  uint64_t v54;
  void *v55;
  Swift::String v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  void *v60;
  char v61;
  uint64_t v62;
  void *v63;
  uint64_t *v64;
  uint64_t v65;
  uint8x16_t *v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t countAndFlagsBits;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  Swift::String v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void *v95;
  char v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  void *v101;
  char v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  Swift::String v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v107 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v105 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v111 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v108, v14, v13);
  if (!v5)
  {
    Swift::String v105 = v9;
    unint64_t v106 = a2;
    uint64_t v15 = v107;
    uint64_t v16 = v109;
    uint64_t v17 = v110;
    __swift_project_boxed_opaque_existential_0Tm(&v108, v109);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 136))(v16, v17);
    __swift_destroy_boxed_opaque_existential_1Tm(&v108._countAndFlagsBits);
    v108._uint64_t countAndFlagsBits = v18;
    uint64_t v19 = v106;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v108, v106, v15);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v12, 1LL, v19) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v20 + 32))(a5, v12, v19);
      return __swift_destroy_boxed_opaque_existential_1Tm(v111);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v105);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v22 = v21;
    uint64_t v23 = v111[3];
    uint64_t v24 = v111[4];
    __swift_project_boxed_opaque_existential_0Tm(v111, v23);
    unint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v23, v24);
    uint64_t v26 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v28 = v27;
    v108._uint64_t countAndFlagsBits = v26;
    v108._unint64_t object = (void *)v27;
    unint64_t v29 = HIBYTE(v27) & 0xF;
    if ((v27 & 0x2000000000000000LL) == 0) {
      unint64_t v29 = v26 & 0xFFFFFFFFFFFFLL;
    }
    if (v29 || (v26 & ~v27 & 0x2000000000000000LL) != 0)
    {
      if ((v27 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v30 = specialized _SmallString.init(_:appending:)( v26,  v27,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v32 & 1) == 0))
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v108._uint64_t countAndFlagsBits = v33;
        v108._unint64_t object = v34;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v36 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v36 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v36);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v19 = v106;
    }

    else
    {
      swift_bridgeObjectRelease(v27);
      v108._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v108._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v19, 0);
    if (v38 < 0) {
      goto LABEL_103;
    }
    unint64_t v39 = (uint8x16_t *)TypeName;
    int64_t v40 = v38;
    char v41 = validateUTF8(_:)(TypeName, v38);
    if ((v43 & 1) != 0) {
      uint64_t v44 = repairUTF8(_:firstKnownBrokenRange:)(v39->i8, v40, v41, v42);
    }
    else {
      uint64_t v44 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v39, v40, v41 & 1);
    }
    unint64_t v46 = v44;
    uint64_t v47 = v45;
    unint64_t object = v108._object;
    int64_t v49 = ((unint64_t)v108._object >> 56) & 0xF;
    if (!v49 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v108._object);
      v108._uint64_t countAndFlagsBits = v46;
      v108._unint64_t object = (void *)v47;
LABEL_34:
      unint64_t v56 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      unint64_t v57 = HIBYTE(v47) & 0xF;
      if ((v47 & 0x2000000000000000LL) == 0) {
        unint64_t v57 = v46 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v47);
        unint64_t v108 = v56;
LABEL_47:
        unint64_t v64 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for UInt64, 0);
        if ((v65 & 0x8000000000000000LL) == 0)
        {
          uint64_t v66 = (uint8x16_t *)v64;
          uint64_t v67 = v65;
          unint64_t v68 = validateUTF8(_:)(v64, v65);
          if ((v70 & 1) != 0) {
            uint64_t v71 = repairUTF8(_:firstKnownBrokenRange:)(v66->i8, v67, v68, v69);
          }
          else {
            uint64_t v71 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v66, v67, v68 & 1);
          }
          uint64_t v73 = v71;
          uint64_t v74 = v72;
          uint64_t v75 = v108._object;
          int64_t v76 = ((unint64_t)v108._object >> 56) & 0xF;
          if (!v76 && (v108._countAndFlagsBits & ~(uint64_t)v108._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v108._object);
            v108._uint64_t countAndFlagsBits = v73;
            v108._unint64_t object = (void *)v74;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            char v84 = HIBYTE(v74) & 0xF;
            if ((v74 & 0x2000000000000000LL) == 0) {
              char v84 = v73 & 0xFFFFFFFFFFFFLL;
            }
            if (v84 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
            {
              if ((v74 & 0x2000000000000000LL) == 0
                || (unint64_t v85 = specialized _SmallString.init(_:appending:)( v73,  v74,  0x2065756C617620uLL,  0xE700000000000000LL),  (v87 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v108._countAndFlagsBits;
                unint64_t v88 = (unint64_t)v108._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v85;
              unint64_t v88 = v86;
              swift_bridgeObjectRelease(v74);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v74);
              unint64_t v88 = 0xE700000000000000LL;
            }

            v108._uint64_t countAndFlagsBits = countAndFlagsBits;
            v108._unint64_t object = (void *)v88;
LABEL_78:
            char v89 = _uint64ToString(_:radix:uppercase:)(v18, 10LL, 0);
            uint64_t v90 = v89._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v89._object;
            uint64_t v92 = HIBYTE(v88) & 0xF;
            if ((v88 & 0x2000000000000000LL) == 0) {
              uint64_t v92 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v92 && (countAndFlagsBits & ~v88 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v88);
              unint64_t v108 = v89;
              goto LABEL_91;
            }

            if ((v88 & 0x2000000000000000LL) != 0)
            {
              if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
              {
                unint64_t v94 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v88,  v89._countAndFlagsBits,  (unint64_t)v89._object);
                if ((v96 & 1) == 0)
                {
                  unint64_t v97 = v94;
                  uint64_t v98 = v95;
                  swift_bridgeObjectRelease(v88);
                  swift_bridgeObjectRelease((uint64_t)v89._object);
                  v108._uint64_t countAndFlagsBits = v97;
                  v108._unint64_t object = v98;
                  unint64_t v91 = (unint64_t)v98;
                  uint64_t v90 = v97;
LABEL_91:
                  uint64_t v99 = HIBYTE(v91) & 0xF;
                  if ((v91 & 0x2000000000000000LL) == 0) {
                    uint64_t v99 = v90 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v99 || (v90 & ~v91 & 0x2000000000000000LL) != 0)
                  {
                    if ((v91 & 0x2000000000000000LL) == 0
                      || (uint64_t v100 = specialized _SmallString.init(_:appending:)(v90, v91, 0LL, 0xE000000000000000LL),
                          (v102 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      char v103 = v108._countAndFlagsBits;
                      uint64_t v104 = v108._object;
                    }

                    else
                    {
                      char v103 = v100;
                      uint64_t v104 = v101;
                      swift_bridgeObjectRelease(v91);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v91);
                    char v103 = 0LL;
                    uint64_t v104 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v22 = v25;
                  *(void *)(v22 + 8) = v103;
                  *(void *)(v22 + 16) = v104;
                  *(void *)(v22 + 24) = 0LL;
                  *(_BYTE *)(v22 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
                }

                goto LABEL_89;
              }
            }

            else if (((uint64_t)v89._object & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              uint64_t v93 = ((unint64_t)v89._object >> 56) & 0xF;
              goto LABEL_90;
            }

            uint64_t v93 = v89._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v89._countAndFlagsBits, (unint64_t)v89._object, 0LL, v93);
            swift_bridgeObjectRelease((uint64_t)v89._object);
            uint64_t v90 = v108._countAndFlagsBits;
            unint64_t v91 = (unint64_t)v108._object;
            goto LABEL_91;
          }

          if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
          {
            if ((v72 & 0x2000000000000000LL) != 0)
            {
              int64_t v78 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v71,  v72);
              if ((v80 & 1) == 0)
              {
                unint64_t v81 = v78;
                uint64_t v82 = v79;
                swift_bridgeObjectRelease((uint64_t)v75);
                swift_bridgeObjectRelease(v74);
                v108._uint64_t countAndFlagsBits = v81;
                v108._unint64_t object = v82;
                uint64_t v74 = (unint64_t)v82;
                uint64_t v73 = v81;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v72 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            int64_t v77 = HIBYTE(v74) & 0xF;
            goto LABEL_63;
          }

          int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v73, v74, 0LL, v77);
          swift_bridgeObjectRelease(v74);
          uint64_t v73 = v108._countAndFlagsBits;
          uint64_t v74 = (unint64_t)v108._object;
          goto LABEL_64;
        }

{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  char v34;
  uint64_t v35;
  void *v36;
  unint64_t v38;
  uint64_t *TypeName;
  uint64_t v40;
  uint8x16_t *v41;
  int64_t v42;
  int64_t v43;
  int64_t v44;
  char v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  void *object;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  void *v54;
  char v55;
  uint64_t v56;
  void *v57;
  Swift::String v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  void *v62;
  char v63;
  uint64_t v64;
  void *v65;
  uint64_t *v66;
  uint64_t v67;
  uint8x16_t *v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  char v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  void *v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  void *v81;
  char v82;
  uint64_t v83;
  void *v84;
  uint64_t countAndFlagsBits;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  char v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  void *v97;
  char v98;
  uint64_t v99;
  void *v100;
  uint64_t v101;
  unint64_t v102;
  void *v103;
  char v104;
  uint64_t v105;
  void *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  Swift::String v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t *v114;
  char v110 = a4;
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v107 - v11;
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  uint64_t v114 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v14);
  (*(void (**)(Swift::String *__return_ptr, uint64_t, uint64_t))(v13 + 40))(&v111, v14, v13);
  if (!v5)
  {
    unint64_t v108 = v9;
    int8x16_t v109 = a2;
    uint64_t v15 = v110;
    uint64_t v16 = v112;
    uint64_t v17 = v113;
    __swift_project_boxed_opaque_existential_0Tm(&v111, v112);
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 144))(v16, v17);
    uint64_t v20 = v19;
    __swift_destroy_boxed_opaque_existential_1Tm(&v111._countAndFlagsBits);
    uint64_t v107 = v18;
    v111._uint64_t countAndFlagsBits = v18;
    v111._unint64_t object = v20;
    uint64_t v21 = v109;
    (*(void (**)(Swift::String *, unint64_t, uint64_t))(v15 + 16))(&v111, v109, v15);
    uint64_t v22 = *(void *)(v21 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v22 + 48))(v12, 1LL, v21) != 1)
    {
      (*(void (**)(uint64_t, char *, unint64_t))(v22 + 32))(a5, v12, v21);
      return __swift_destroy_boxed_opaque_existential_1Tm(v114);
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v108);
    swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v24 = v23;
    unint64_t v25 = v114[3];
    uint64_t v26 = v114[4];
    __swift_project_boxed_opaque_existential_0Tm(v114, v25);
    unint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 8))(v25, v26);
    uint64_t v28 = specialized static String._createEmpty(withInitialCapacity:)(45LL);
    uint64_t v30 = v29;
    v111._uint64_t countAndFlagsBits = v28;
    v111._unint64_t object = (void *)v29;
    uint64_t v31 = HIBYTE(v29) & 0xF;
    if ((v29 & 0x2000000000000000LL) == 0) {
      uint64_t v31 = v28 & 0xFFFFFFFFFFFFLL;
    }
    if (v31 || (v28 & ~v29 & 0x2000000000000000LL) != 0)
    {
      if ((v29 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (uint64_t v32 = specialized _SmallString.init(_:appending:)( v28,  v29,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v34 & 1) == 0))
      {
        uint64_t v35 = v32;
        unint64_t v36 = v33;
        swift_bridgeObjectRelease(v30);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        v111._uint64_t countAndFlagsBits = v35;
        v111._unint64_t object = v36;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          uint64_t v38 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          uint64_t v38 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v38);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }

      uint64_t v21 = v109;
    }

    else
    {
      swift_bridgeObjectRelease(v29);
      v111._uint64_t countAndFlagsBits = 0xD000000000000012LL;
      v111._unint64_t object = (void *)(0x80000001818B5860LL | 0x8000000000000000LL);
    }

    TypeName = (uint64_t *)swift_getTypeName(v21, 0);
    if (v40 < 0) {
      goto LABEL_103;
    }
    char v41 = (uint8x16_t *)TypeName;
    uint64_t v42 = v40;
    unint64_t v43 = validateUTF8(_:)(TypeName, v40);
    if ((v45 & 1) != 0) {
      unint64_t v46 = repairUTF8(_:firstKnownBrokenRange:)(v41->i8, v42, v43, v44);
    }
    else {
      unint64_t v46 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v41, v42, v43 & 1);
    }
    uint64_t v48 = v46;
    int64_t v49 = v47;
    unint64_t object = v111._object;
    int64_t v51 = ((unint64_t)v111._object >> 56) & 0xF;
    if (!v51 && (v111._countAndFlagsBits & ~(uint64_t)v111._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v111._object);
      v111._uint64_t countAndFlagsBits = v48;
      v111._unint64_t object = (void *)v49;
LABEL_34:
      unint64_t v58 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" from invalid ", 0xEuLL, 1);
      uint64_t v59 = HIBYTE(v49) & 0xF;
      if ((v49 & 0x2000000000000000LL) == 0) {
        uint64_t v59 = v48 & 0xFFFFFFFFFFFFLL;
      }
      if (!v59 && (v48 & ~v49 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v49);
        uint64_t v111 = v58;
LABEL_47:
        uint64_t v66 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for UInt128, 0);
        if ((v67 & 0x8000000000000000LL) == 0)
        {
          unint64_t v68 = (uint8x16_t *)v66;
          unint64_t v69 = v67;
          char v70 = validateUTF8(_:)(v66, v67);
          if ((v72 & 1) != 0) {
            uint64_t v73 = repairUTF8(_:firstKnownBrokenRange:)(v68->i8, v69, v70, v71);
          }
          else {
            uint64_t v73 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v68, v69, v70 & 1);
          }
          uint64_t v75 = v73;
          int64_t v76 = v74;
          int64_t v77 = v111._object;
          int64_t v78 = ((unint64_t)v111._object >> 56) & 0xF;
          if (!v78 && (v111._countAndFlagsBits & ~(uint64_t)v111._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)v111._object);
            v111._uint64_t countAndFlagsBits = v75;
            v111._unint64_t object = (void *)v76;
LABEL_64:
            uint64_t countAndFlagsBits = 0x2065756C617620LL;
            uint64_t v86 = HIBYTE(v76) & 0xF;
            if ((v76 & 0x2000000000000000LL) == 0) {
              uint64_t v86 = v75 & 0xFFFFFFFFFFFFLL;
            }
            if (v86 || (v75 & ~v76 & 0x2000000000000000LL) != 0)
            {
              if ((v76 & 0x2000000000000000LL) == 0
                || (unint64_t v87 = specialized _SmallString.init(_:appending:)( v75,  v76,  0x2065756C617620uLL,  0xE700000000000000LL),  (v89 & 1) != 0))
              {
                _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
                swift_bridgeObjectRelease(0xE700000000000000LL);
                uint64_t countAndFlagsBits = v111._countAndFlagsBits;
                uint64_t v90 = (unint64_t)v111._object;
                goto LABEL_78;
              }

              uint64_t countAndFlagsBits = v87;
              uint64_t v90 = v88;
              swift_bridgeObjectRelease(v76);
              swift_bridgeObjectRelease(0xE700000000000000LL);
            }

            else
            {
              swift_bridgeObjectRelease(v76);
              uint64_t v90 = 0xE700000000000000LL;
            }

            v111._uint64_t countAndFlagsBits = countAndFlagsBits;
            v111._unint64_t object = (void *)v90;
LABEL_78:
            uint64_t v92 = specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, v107, (unint64_t)v20);
            uint64_t v93 = v91;
            unint64_t v94 = HIBYTE(v90) & 0xF;
            if ((v90 & 0x2000000000000000LL) == 0) {
              unint64_t v94 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (!v94 && (countAndFlagsBits & ~v90 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v90);
              v111._uint64_t countAndFlagsBits = v92;
              v111._unint64_t object = (void *)v93;
              goto LABEL_91;
            }

            if ((v90 & 0x2000000000000000LL) != 0)
            {
              if ((v91 & 0x2000000000000000LL) != 0)
              {
                char v96 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, v90, v92, v91);
                if ((v98 & 1) == 0)
                {
                  uint64_t v99 = v96;
                  uint64_t v100 = v97;
                  swift_bridgeObjectRelease(v90);
                  swift_bridgeObjectRelease(v93);
                  v111._uint64_t countAndFlagsBits = v99;
                  v111._unint64_t object = v100;
                  uint64_t v93 = (unint64_t)v100;
                  uint64_t v92 = v99;
LABEL_91:
                  unint64_t v101 = HIBYTE(v93) & 0xF;
                  if ((v93 & 0x2000000000000000LL) == 0) {
                    unint64_t v101 = v92 & 0xFFFFFFFFFFFFLL;
                  }
                  if (v101 || (v92 & ~v93 & 0x2000000000000000LL) != 0)
                  {
                    if ((v93 & 0x2000000000000000LL) == 0
                      || (uint64_t v102 = specialized _SmallString.init(_:appending:)(v92, v93, 0LL, 0xE000000000000000LL),
                          (v104 & 1) != 0))
                    {
                      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                      Swift::String v105 = v111._countAndFlagsBits;
                      unint64_t v106 = v111._object;
                    }

                    else
                    {
                      Swift::String v105 = v102;
                      unint64_t v106 = v103;
                      swift_bridgeObjectRelease(v93);
                      swift_bridgeObjectRelease(0xE000000000000000LL);
                    }
                  }

                  else
                  {
                    swift_bridgeObjectRelease(v93);
                    Swift::String v105 = 0LL;
                    unint64_t v106 = (void *)0xE000000000000000LL;
                  }

                  *(void *)uint64_t v24 = v27;
                  *(void *)(v24 + 8) = v105;
                  *(void *)(v24 + 16) = v106;
                  *(void *)(v24 + 24) = 0LL;
                  *(_BYTE *)(v24 + 72) = 3;
                  swift_willThrow();
                  return __swift_destroy_boxed_opaque_existential_1Tm(v114);
                }

                goto LABEL_89;
              }
            }

            else if ((v91 & 0x2000000000000000LL) != 0)
            {
LABEL_89:
              unint64_t v95 = HIBYTE(v93) & 0xF;
              goto LABEL_90;
            }

            unint64_t v95 = v92 & 0xFFFFFFFFFFFFLL;
LABEL_90:
            _StringGuts.append(_:)(v92, v93, 0LL, v95);
            swift_bridgeObjectRelease(v93);
            uint64_t v92 = v111._countAndFlagsBits;
            uint64_t v93 = (unint64_t)v111._object;
            goto LABEL_91;
          }

          if (((uint64_t)v111._object & 0x2000000000000000LL) != 0)
          {
            if ((v74 & 0x2000000000000000LL) != 0)
            {
              unint64_t v80 = specialized _SmallString.init(_:appending:)( v111._countAndFlagsBits,  (unint64_t)v111._object,  v73,  v74);
              if ((v82 & 1) == 0)
              {
                unint64_t v83 = v80;
                char v84 = v81;
                swift_bridgeObjectRelease((uint64_t)v77);
                swift_bridgeObjectRelease(v76);
                v111._uint64_t countAndFlagsBits = v83;
                v111._unint64_t object = v84;
                int64_t v76 = (unint64_t)v84;
                uint64_t v75 = v83;
                goto LABEL_64;
              }

              goto LABEL_62;
            }
          }

          else if ((v74 & 0x2000000000000000LL) != 0)
          {
LABEL_62:
            char v79 = HIBYTE(v76) & 0xF;
            goto LABEL_63;
          }

          char v79 = v73 & 0xFFFFFFFFFFFFLL;
LABEL_63:
          _StringGuts.append(_:)(v75, v76, 0LL, v79);
          swift_bridgeObjectRelease(v76);
          uint64_t v75 = v111._countAndFlagsBits;
          int64_t v76 = (unint64_t)v111._object;
          goto LABEL_64;
        }

LABEL_103:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v56 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v65._object & 0x2000000000000000LL) != 0)
        {
          unint64_t v68 = specialized _SmallString.init(_:appending:)( v55,  v56,  v65._countAndFlagsBits,  (unint64_t)v65._object);
          if ((v70 & 1) == 0)
          {
            uint64_t v71 = v68;
            unint64_t v72 = v69;
            swift_bridgeObjectRelease(v56);
            swift_bridgeObjectRelease((uint64_t)v65._object);
            v118._uint64_t countAndFlagsBits = v71;
            v118._unint64_t object = v72;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v65._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        uint64_t v67 = ((unint64_t)v65._object >> 56) & 0xF;
        goto LABEL_46;
      }

      uint64_t v67 = v65._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v65._countAndFlagsBits, (unint64_t)v65._object, 0LL, v67);
      swift_bridgeObjectRelease((uint64_t)v65._object);
      goto LABEL_47;
    }

    if (((uint64_t)v118._object & 0x2000000000000000LL) != 0)
    {
      if ((v54 & 0x2000000000000000LL) != 0)
      {
        unint64_t v60 = specialized _SmallString.init(_:appending:)( v118._countAndFlagsBits,  (unint64_t)v118._object,  v53,  v54);
        if ((v62 & 1) == 0)
        {
          uint64_t v63 = v60;
          unint64_t v64 = v61;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v56);
          v118._uint64_t countAndFlagsBits = v63;
          v118._unint64_t object = v64;
          unint64_t v56 = (unint64_t)v64;
          uint64_t v55 = v63;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v54 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      uint64_t v59 = HIBYTE(v56) & 0xF;
      goto LABEL_33;
    }

    uint64_t v59 = v53 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v55, v56, 0LL, v59);
    swift_bridgeObjectRelease(v56);
    uint64_t v55 = v118._countAndFlagsBits;
    unint64_t v56 = (unint64_t)v118._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v121);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v49 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v58._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v61 = specialized _SmallString.init(_:appending:)( v48,  v49,  v58._countAndFlagsBits,  (unint64_t)v58._object);
          if ((v63 & 1) == 0)
          {
            unint64_t v64 = v61;
            Swift::String v65 = v62;
            swift_bridgeObjectRelease(v49);
            swift_bridgeObjectRelease((uint64_t)v58._object);
            v111._uint64_t countAndFlagsBits = v64;
            v111._unint64_t object = v65;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v58._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v60 = ((unint64_t)v58._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v60 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v58._countAndFlagsBits, (unint64_t)v58._object, 0LL, v60);
      swift_bridgeObjectRelease((uint64_t)v58._object);
      goto LABEL_47;
    }

    if (((uint64_t)v111._object & 0x2000000000000000LL) != 0)
    {
      if ((v47 & 0x2000000000000000LL) != 0)
      {
        unint64_t v53 = specialized _SmallString.init(_:appending:)( v111._countAndFlagsBits,  (unint64_t)v111._object,  v46,  v47);
        if ((v55 & 1) == 0)
        {
          unint64_t v56 = v53;
          unint64_t v57 = v54;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v49);
          v111._uint64_t countAndFlagsBits = v56;
          v111._unint64_t object = v57;
          int64_t v49 = (unint64_t)v57;
          uint64_t v48 = v56;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v47 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      char v52 = HIBYTE(v49) & 0xF;
      goto LABEL_33;
    }

    char v52 = v46 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v48, v49, 0LL, v52);
    swift_bridgeObjectRelease(v49);
    uint64_t v48 = v111._countAndFlagsBits;
    int64_t v49 = (unint64_t)v111._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v114);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v47 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v59 = specialized _SmallString.init(_:appending:)( v46,  v47,  v56._countAndFlagsBits,  (unint64_t)v56._object);
          if ((v61 & 1) == 0)
          {
            char v62 = v59;
            uint64_t v63 = v60;
            swift_bridgeObjectRelease(v47);
            swift_bridgeObjectRelease((uint64_t)v56._object);
            v108._uint64_t countAndFlagsBits = v62;
            v108._unint64_t object = v63;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v56._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v58 = ((unint64_t)v56._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v58 = v56._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v56._countAndFlagsBits, (unint64_t)v56._object, 0LL, v58);
      swift_bridgeObjectRelease((uint64_t)v56._object);
      goto LABEL_47;
    }

    if (((uint64_t)v108._object & 0x2000000000000000LL) != 0)
    {
      if ((v45 & 0x2000000000000000LL) != 0)
      {
        int64_t v51 = specialized _SmallString.init(_:appending:)( v108._countAndFlagsBits,  (unint64_t)v108._object,  v44,  v45);
        if ((v53 & 1) == 0)
        {
          unint64_t v54 = v51;
          uint64_t v55 = v52;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v47);
          v108._uint64_t countAndFlagsBits = v54;
          v108._unint64_t object = v55;
          uint64_t v47 = (unint64_t)v55;
          unint64_t v46 = v54;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v45 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      int64_t v50 = HIBYTE(v47) & 0xF;
      goto LABEL_33;
    }

    int64_t v50 = v44 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v46, v47, 0LL, v50);
    swift_bridgeObjectRelease(v47);
    unint64_t v46 = v108._countAndFlagsBits;
    uint64_t v47 = (unint64_t)v108._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v111);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      if ((v49 & 0x2000000000000000LL) != 0)
      {
        if (((uint64_t)v58._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v61 = specialized _SmallString.init(_:appending:)( v48,  v49,  v58._countAndFlagsBits,  (unint64_t)v58._object);
          if ((v63 & 1) == 0)
          {
            unint64_t v64 = v61;
            Swift::String v65 = v62;
            swift_bridgeObjectRelease(v49);
            swift_bridgeObjectRelease((uint64_t)v58._object);
            v111._uint64_t countAndFlagsBits = v64;
            v111._unint64_t object = v65;
            goto LABEL_47;
          }

          goto LABEL_45;
        }
      }

      else if (((uint64_t)v58._object & 0x2000000000000000LL) != 0)
      {
LABEL_45:
        unint64_t v60 = ((unint64_t)v58._object >> 56) & 0xF;
        goto LABEL_46;
      }

      unint64_t v60 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_46:
      _StringGuts.append(_:)(v58._countAndFlagsBits, (unint64_t)v58._object, 0LL, v60);
      swift_bridgeObjectRelease((uint64_t)v58._object);
      goto LABEL_47;
    }

    if (((uint64_t)v111._object & 0x2000000000000000LL) != 0)
    {
      if ((v47 & 0x2000000000000000LL) != 0)
      {
        unint64_t v53 = specialized _SmallString.init(_:appending:)( v111._countAndFlagsBits,  (unint64_t)v111._object,  v46,  v47);
        if ((v55 & 1) == 0)
        {
          unint64_t v56 = v53;
          unint64_t v57 = v54;
          swift_bridgeObjectRelease((uint64_t)object);
          swift_bridgeObjectRelease(v49);
          v111._uint64_t countAndFlagsBits = v56;
          v111._unint64_t object = v57;
          int64_t v49 = (unint64_t)v57;
          uint64_t v48 = v56;
          goto LABEL_34;
        }

        goto LABEL_32;
      }
    }

    else if ((v47 & 0x2000000000000000LL) != 0)
    {
LABEL_32:
      char v52 = HIBYTE(v49) & 0xF;
      goto LABEL_33;
    }

    char v52 = v46 & 0xFFFFFFFFFFFFLL;
LABEL_33:
    _StringGuts.append(_:)(v48, v49, 0LL, v52);
    swift_bridgeObjectRelease(v49);
    uint64_t v48 = v111._countAndFlagsBits;
    int64_t v49 = (unint64_t)v111._object;
    goto LABEL_34;
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v114);
}

          char v251 = (v188 - 1) & v188;
          uint64_t v161 = __clz(__rbit64(v188)) + ((void)v189 << 6);
          unint64_t v248 = v189;
        }

        char v185 = v261;
        unint64_t v186 = v252;
        Swift::String::Index v184 = v267;
        (*(void (**)(char *, unint64_t, uint64_t *))(v261 + 16))( v252,  *(void *)(v87 + 48) + *(void *)(v261 + 72) * v161,  v267);
        char v191 = *(void *)(v87 + 56) + *(void *)(v81 + 72) * v161;
        uint64_t v183 = v263;
        (*(void (**)(char *, unint64_t, uint64_t *))(v81 + 16))(v156, v191, v263);
        uint64_t v164 = v242;
        uint64_t v192 = &v242[*((int *)v60 + 12)];
        (*(void (**)(char *, char *, uint64_t *))(v185 + 32))(v242, v186, v184);
        (*(void (**)(char *, char *, uint64_t *))(v81 + 32))(v192, v156, v183);
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v160 + 56))(v164, 0LL, 1LL, v60);
        char v182 = v156;
      }

      unint64_t v193 = *(void (**)(char *, char *, unint64_t *))(v160 + 32);
      unint64_t v194 = v238;
      v193(v238, v164, v60);
      unint64_t v195 = &v194[*((int *)v60 + 12)];
      unint64_t v196 = v255;
      unint64_t v197 = &v255[*((int *)TupleTypeMetadata2 + 12)];
      (*(void (**)(char *, char *, uint64_t *))(v185 + 32))(v186, v194, v184);
      swift_dynamicCast(v196, v186, v184, &type metadata for String, 7LL);
      (*(void (**)(char *, char *, uint64_t *))(v268 + 32))(v182, v195, v183);
      id v198 = v259;
      swift_dynamicCast(v197, v182, v183, v259, 7LL);
      uint64_t v199 = v253;
      uint64_t v200 = &v253[*((int *)v254 + 12)];
      unint64_t v201 = v264;
      size_t v202 = (void (*)(char *, char *, ValueMetadata *))v264[4];
      v202(v253, v196, &type metadata for String);
      unint64_t v203 = v265;
      uint64_t v204 = *(void (**)(char *, char *, uint64_t *))(v265 + 32);
      v204(v200, v197, v198);
      size_t v205 = v239;
      Swift::String v206 = v199;
      unint64_t v207 = v198;
      v202(v239, v206, &type metadata for String);
      unint64_t v208 = v240;
      v204(v240, v200, v198);
      uint64_t v209 = (uint64_t)v250;
      v202((char *)v250, v205, &type metadata for String);
      unint64_t v210 = v241;
      v204((char *)v241, v208, v207);
      uint64_t v71 = (unint64_t *)v260;
      uint64_t v211 = __RawDictionaryStorage.find<A>(_:)(v209, (uint64_t)&type metadata for String, v258);
      unint64_t v212 = v211;
      if ((v213 & 1) != 0)
      {
        ((void (*)(unint64_t, uint64_t, ValueMetadata *))v201[5])( v71[6] + v201[9] * v211,  v209,  &type metadata for String);
        (*(void (**)(unint64_t, ValueMetadata *, uint64_t *))(v203 + 40))( v71[7] + *(void *)(v203 + 72) * v212,  v210,  v207);
      }

      else
      {
        if (v71[2] >= v71[3]) {
          goto LABEL_124;
        }
        *(void *)&v247[(v211 >> 3) & 0x1FFFFFFFFFFFFFF8LL] |= 1LL << v211;
        v202((char *)(v71[6] + v264[9] * v211), (char *)v209, &type metadata for String);
        v204((char *)(v71[7] + *(void *)(v265 + 72) * v212), (char *)v210, v207);
        unint64_t v214 = v71[2];
        uint64_t v215 = __OFADD__(v214, 1LL);
        Swift::String::Index v216 = v214 + 1;
        if (v215)
        {
          __break(1u);
LABEL_126:
          __break(1u);
LABEL_127:
          __break(1u);
          goto LABEL_128;
        }

        v71[2] = v216;
      }

      unint64_t v60 = v257;
      size_t v160 = v266;
      unint64_t v81 = v268;
      unint64_t v156 = v262;
      unint64_t v87 = (unint64_t)v249;
      uint64_t v86 = v251;
    }
  }

  uint64_t v71 = (unint64_t *)v260;
  if (v72)
  {
    if (a1 < 0) {
      int64_t v76 = a1;
    }
    else {
      int64_t v76 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    int64_t v77 = type metadata accessor for __CocoaDictionary.Iterator();
    int64_t v78 = (unint64_t)swift_allocObject(v77, 0xE8uLL, 7uLL);
    unint64_t v235 = 0LL;
    char v79 = 0LL;
    char v251 = 0LL;
    *(void *)(v78 + 208) = v76;
    *(void *)(v78 + 216) = 0LL;
    uint64_t v75 = a1;
    *(_OWORD *)(v78 + 16) = 0u;
    *(_OWORD *)(v78 + 32) = 0u;
    *(_OWORD *)(v78 + 48) = 0u;
    *(_OWORD *)(v78 + 64) = 0u;
    *(_OWORD *)(v78 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v78 + 96) = 0u;
    *(_OWORD *)(v78 + 112) = 0u;
    *(_OWORD *)(v78 + 128) = 0u;
    *(_OWORD *)(v78 + 144) = 0u;
    *(_OWORD *)(v78 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v78 + 176) = 0u;
    *(_OWORD *)(v78 + 192) = 0u;
    *(void *)(v78 + 224) = 0LL;
    unint64_t v80 = v78 | 0x8000000000000000LL;
  }

  else
  {
    unint64_t v88 = -1LL << *(_BYTE *)(a1 + 32);
    char v79 = ~v88;
    char v89 = *(void *)(a1 + 64);
    unint64_t v235 = (uint64_t *)(a1 + 64);
    uint64_t v90 = -v88;
    if (v90 < 64) {
      unint64_t v91 = ~(-1LL << v90);
    }
    else {
      unint64_t v91 = -1LL;
    }
    char v251 = v91 & v89;
    unint64_t v80 = a1;
  }

  uint64_t v92 = v249;
  uint64_t v93 = v250;
  uint64_t v233 = (char *)((v80 & 0x7FFFFFFFFFFFFFFFLL) + 16);
  Swift::String::Index v239 = (char *)(v80 & 0x7FFFFFFFFFFFFFFFLL);
  unint64_t v232 = (char *)((v80 & 0x7FFFFFFFFFFFFFFFLL) + 80);
  unint64_t v231 = v79;
  uint64_t v234 = (char *)((unint64_t)(v79 + 64) >> 6);
  swift_bridgeObjectRetain(v75, v67, v68, v69);
  swift_retain(v71, v94, v95, v96);
  Swift::String::Index v240 = 0LL;
  unint64_t v238 = (char *)&unk_189B8D230;
  Swift::String::Index v241 = a4;
  Swift::String::Index v242 = (char *)v80;
  while ((v80 & 0x8000000000000000LL) == 0)
  {
    int8x8_t v125 = v263;
    int8x16_t v126 = v257;
    int8x8_t v127 = v268;
    if (v251)
    {
      uint64_t v100 = __clz(__rbit64(v251));
      v251 &= v251 - 1;
      unint64_t v101 = v100 | ((void)v240 << 6);
      uint64_t v102 = v248;
    }

    else
    {
      uint64x2_t v128 = v240 + 1;
      uint64_t v102 = v248;
      if (__OFADD__(v240, 1LL)) {
        goto LABEL_126;
      }
      if ((uint64_t)v128 >= (uint64_t)v234)
      {
        int8x16_t v131 = v266;
        goto LABEL_116;
      }

      int8x16_t v129 = v235[(void)v128];
      int8x16_t v130 = v240 + 1;
      int8x16_t v131 = v266;
      if (!v129)
      {
        int8x16_t v130 = v240 + 2;
        int8x16_t v129 = v235[(void)v130];
        if (!v129)
        {
          int8x16_t v132 = v240 + 3;
          int8x16_t v129 = v235[(void)v132];
          if (!v129)
          {
            while (1)
            {
              int8x16_t v130 = v132 + 1;
              if (__OFADD__(v132, 1LL)) {
                break;
              }
              int8x16_t v129 = v235[(void)v130];
              ++v132;
              if (v129) {
                goto LABEL_62;
              }
            }

                        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
                      }

                      Swift::String v65 = (void (*)(char *, uint64_t, swift *))v271;
                      if (v219 >= 64) {
                        goto LABEL_91;
                      }
                    }

                    uint64_t v228 = v288;
                    ((void (*)(char *, char *, uint64_t))v290)(v288, v207, v78);
                    size_t v229 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                    ((void (*)(char *, uint64_t))v291)(v228, v78);
                    if (v229 < v294) {
                      goto LABEL_111;
                    }
                    goto LABEL_91;
                  }
                }

                else
                {
                  uint64_t v183 = v77((unint64_t *)v78, v68);
                  unint64_t v169 = v259(v78, v68);
                  uint64_t v66 = v257;
                  if ((v183 & 1) == 0)
                  {
                    unint64_t v195 = *(void (**)(char *, char *, uint64_t))(v84 + 16);
                    if (v169 >= 64)
                    {
                      unint64_t v203 = v262;
                      unint64_t v168 = v290;
                      v195(v262, v290, v78);
                      ((void (*)(char *, uint64_t))v291)(v203, v78);
                      goto LABEL_73;
                    }

                    unint64_t v168 = v290;
                    v195(v83, v290, v78);
                    goto LABEL_68;
                  }

                  if (v169 <= 64)
                  {
                    unint64_t v197 = v269;
                    id v198 = v268;
                    uint64_t v199 = swift_getAssociatedConformanceWitness( (uint64_t)v269,  v78,  v268,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    uint64_t v200 = v267;
                    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v199 + 8))( &qword_18180BE68,  256LL,  v198,  v199);
                    unint64_t v201 = v200;
                    char v84 = v287;
                    (*((void (**)(char *, uint64_t, const char *))v197 + 3))(v201, v78, v197);
                    unint64_t v168 = v290;
                    LOBYTE(v198) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                                  + 8LL)
                                                                                      + 16LL))( v290,  v83,  v78);
                    ((void (*)(char *, uint64_t))v291)(v83, v78);
                    size_t v202 = v263;
                    (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v263, v168, v78);
                    if ((v198 & 1) != 0)
                    {
                      ((void (*)(char *, uint64_t))v291)(v202, v78);
                    }

                    else
                    {
                      int64_t v226 = v294;
                      char v227 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                      ((void (*)(char *, uint64_t))v291)(v202, v78);
                      unint64_t v167 = v227 < v226;
                      unint64_t v168 = v290;
                      if (!v167) {
                        goto LABEL_73;
                      }
                    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

                    uint64_t v259 = v617;
                    (*(void (**)(char *, unint64_t *))(*(void *)(AssociatedConformanceWitness + 16)
                                                                       + 16LL))( v125,  v69);
                    v136(v125, v69);
                    if ((((uint64_t (*)(unint64_t *, uint64_t))v159)(v69, v67) & 1) != 0)
                    {
                      unint64_t v260 = v602;
                      (*((void (**)(char *, char *, unint64_t *))v164 + 2))(v602, v259, v69);
                      uint64_t v261 = (void (**)(char *, unint64_t *, const char *))v640;
                      unint64_t v262 = v638;
                      uint64_t v263 = swift_getAssociatedConformanceWitness( (uint64_t)v640,  (uint64_t)v69,  (uint64_t)v638,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                      uint64_t v264 = v639;
                      (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v263 + 8))( &qword_18180BE68,  256LL,  v262,  v263);
                      v261[3](v264, v69, (const char *)v261);
                      LOBYTE(v261) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL) + 32LL))( v260,  v123,  v69);
                      v136(v123, v69);
                      v136(v260, v69);
                      uint64_t v159 = v645;
                      uint64_t v259 = v617;
                    }

                    uint64_t v265 = v648;
                    if (((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67) < 64)
                    {
LABEL_195:
                      v400 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                      v401 = v259;
                      char v316 = v400;
                      v136(v401, v69);
                      uint64_t v287 = 15 - v316;
                      if (v316 > 0xF)
                      {
                        __break(1u);
                        goto LABEL_277;
                      }

          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
        }

      Swift::String v105 = 675LL;
      goto LABEL_104;
    }

  specialized UnsafeMutablePointer.initialize(from:count:)( (char *)v15,  v14,  (char *)(v12 + (*(void *)(v11 + 24) & 0xFFFFFFFFFFFFLL)));
  int64_t v49 = *(void *)(v11 + 24) & 0xFFFFFFFFFFFFLL;
  if (__OFADD__(v49, v14))
  {
LABEL_121:
    __break(1u);
LABEL_122:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
  }

  __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v49 + v14, 0);
  return *(void *)(v11 + 24);
}

              uint64_t v145 = v200;
              uint64_t v146 = v201;
              swift_bridgeObjectRelease(v107[1]);
              char *v107 = v145;
              v107[1] = v146;
              return v26;
            }

            goto LABEL_84;
          }

                int64_t v155 = HIBYTE(v133) & 0xF;
                unint64_t v196 = v134;
                unint64_t v197 = v133 & 0xFFFFFFFFFFFFFFLL;
                unint64_t v156 = v155 | 0xC000000000000000LL;
                if ((v133 & 0x4000000000000000LL) == 0) {
                  unint64_t v156 = HIBYTE(v133) & 0xF;
                }
                int64_t v157 = v156 | 0x3000000000000000LL;
                uint64_t v137 = _allocateStringStorage(codeUnitCapacity:)(v40);
                *(void *)(v137 + 16) = v158;
                *(void *)(v137 + 24) = v157;
                if (v158 < 0)
                {
                  *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
                  int64_t v157 = *(void *)(v137 + 24);
                }

                *(_BYTE *)(v137 + 32 + (v157 & 0xFFFFFFFFFFFFLL)) = 0;
                specialized UnsafeMutablePointer.initialize(from:count:)((char *)&v196, v155, (char *)(v137 + 32));
                unint64_t v36 = v190;
                goto LABEL_108;
              }

  v75._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v56)._rawBits;
  if (v33 < 0)
  {
    uint64_t v82 = 0LL;
    unint64_t v83 = (char *)&v97 + 6;
    while (1)
    {
      char v84 = v75._rawBits >> 16;
      if (!(v75._rawBits >> 16)) {
        break;
      }
      if ((v52 & 0x1000000000000000LL) != 0)
      {
        uint64_t v90 = v83;
        v91._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v75)._rawBits;
        unint64_t v83 = v90;
        v75._Swift::UInt64 rawBits = v91._rawBits;
      }

      else
      {
        if ((v52 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v50;
          uint64_t v99 = v52 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v98 + v84 - 1) & 0xC0) == 0x80)
          {
            unint64_t v87 = 0LL;
            do
              unint64_t v88 = v83[v84 + v87--] & 0xC0;
            while (v88 == 128);
            char v89 = 1 - v87;
          }

          else
          {
            char v89 = 1LL;
          }

          v84 -= v89;
        }

        else
        {
          unint64_t v85 = (char *)((v52 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v50 & 0x1000000000000000LL) == 0)
          {
            uint64_t v92 = v83;
            unint64_t v85 = (char *)_StringObject.sharedUTF8.getter(v50, v52);
            unint64_t v83 = v92;
          }

          do
            uint64_t v86 = v85[--v84] & 0xC0;
          while (v86 == 128);
        }

        v75._Swift::UInt64 rawBits = (v84 << 16) | 5;
      }

      if (v33 >= --v82) {
        goto LABEL_139;
      }
    }

        swift_bridgeObjectRelease(v17);
        v88._uint64_t countAndFlagsBits = v4;
        v88._unint64_t object = (void *)object;
        goto LABEL_109;
      }

      uint64_t v26 = v32;
      uint64_t v17 = v33;
      swift_bridgeObjectRelease(0x80000001818BAFD0LL | 0x8000000000000000LL);
      swift_bridgeObjectRelease(v30);
    }

    else
    {
      swift_bridgeObjectRelease(v29);
      uint64_t v26 = 0xD00000000000001CLL;
      uint64_t v17 = 0x80000001818BAFD0LL | 0x8000000000000000LL;
    }

    v88._uint64_t countAndFlagsBits = v26;
    v88._unint64_t object = (void *)v17;
    goto LABEL_94;
  }

  if (v1 - 100344 > 0xFFFFE807 || v1 - 101641 >= 0xFFFFFFF7)
  {
    unint64_t v39 = specialized static String._createEmpty(withInitialCapacity:)(19LL);
    char v41 = v40;
    v88._uint64_t countAndFlagsBits = v39;
    v88._unint64_t object = (void *)v40;
    uint64_t v42 = HIBYTE(v40) & 0xF;
    if ((v40 & 0x2000000000000000LL) == 0) {
      uint64_t v42 = v39 & 0xFFFFFFFFFFFFLL;
    }
    if (v42 || (v39 & ~v40 & 0x2000000000000000LL) != 0)
    {
      unint64_t v43 = "TANGUT IDEOGRAPH-";
      if ((v40 & 0x2000000000000000LL) == 0
        || (0x80000001818BAFF0LL & 0x2000000000000000LL) == 0
        || (uint64_t v44 = specialized _SmallString.init(_:appending:)( v39,  v40,  0xD000000000000011LL,  0x80000001818BAFF0LL | 0x8000000000000000LL),  (v46 & 1) != 0))
      {
        uint64_t v47 = 0x80000001818BAFF0LL | 0x8000000000000000LL;
        if ((0x80000001818BAFF0LL & 0x2000000000000000LL) != 0) {
          uint64_t v48 = (0x80000001818BAFF0LL >> 56) & 0xF;
        }
        else {
          uint64_t v48 = 17LL;
        }
        int64_t v49 = 0xD000000000000011LL;
        goto LABEL_91;
      }

      goto LABEL_85;
    }

    swift_bridgeObjectRelease(v40);
    uint64_t v71 = "TANGUT IDEOGRAPH-";
    uint64_t v55 = 0xD000000000000011LL;
LABEL_133:
    int64_t v78 = (unint64_t)(v71 + 0x7FFFFFFFFFFFFFE0LL);
    goto LABEL_134;
  }

  if (v1 - 101590 >= 0xFFFFFE2A)
  {
    int64_t v51 = specialized static String._createEmpty(withInitialCapacity:)(32LL);
    char v41 = v52;
    v88._uint64_t countAndFlagsBits = v51;
    v88._unint64_t object = (void *)v52;
    unint64_t v53 = HIBYTE(v52) & 0xF;
    if ((v52 & 0x2000000000000000LL) == 0) {
      unint64_t v53 = v51 & 0xFFFFFFFFFFFFLL;
    }
    if (v53 || (v51 & ~v52 & 0x2000000000000000LL) != 0)
    {
      unint64_t v43 = "KHITAN SMALL SCRIPT CHARACTER-";
      if ((v52 & 0x2000000000000000LL) == 0
        || (0x80000001818BB010LL & 0x2000000000000000LL) == 0
        || (uint64_t v44 = specialized _SmallString.init(_:appending:)( v51,  v52,  0xD00000000000001ELL,  0x80000001818BB010LL | 0x8000000000000000LL),  (v54 & 1) != 0))
      {
        uint64_t v47 = 0x80000001818BB010LL | 0x8000000000000000LL;
        if ((0x80000001818BB010LL & 0x2000000000000000LL) != 0) {
          uint64_t v48 = (0x80000001818BB010LL >> 56) & 0xF;
        }
        else {
          uint64_t v48 = 30LL;
        }
        int64_t v49 = 0xD00000000000001ELL;
        goto LABEL_91;
      }

  char v191 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000LL) == 0) {
    char v191 = v407 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v192 = v382;
  if (v191 || (v407 & ~v408 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236LL;
    v408 = 0xE200000000000000LL;
  }

  v145(3LL, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  unint64_t v193 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v193, v192, v3);
  unint64_t v194 = v402;
  unint64_t v195 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  unint64_t v196 = (void *)swift_getDynamicType(v195, v194, 1);
  LODWORD(v194) = swift_isOptionalType(v196);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v194)
  {
    memcpy(v101, v192, v3);
    unint64_t v197 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v197, 7uLL);
LABEL_110:
    id v198 = (uint64_t)v402;
    uint64_t v199 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    uint64_t v200 = (*(uint64_t (**)(uint64_t, uint64_t))(v199 + 8))(v198, v199);
    size_t v202 = v201;
    specialized String.write<A>(to:)(&v407, v200, v201, v203);
    swift_bridgeObjectRelease(v202);
LABEL_111:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_114;
  }

  uint64_t v204 = v374;
  memcpy(v374, v192, v3);
  if ((swift_dynamicCast((char *)&v401, v204, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    size_t v205 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v205);
  }

  else
  {
    Swift::String::Index v294 = v368;
    memcpy(v368, v192, v3);
    Swift::String::Index v295 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v294, v2, v295, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      Swift::String::Index v296 = (uint64_t)v402;
      unint64_t v297 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v297 + 8))( &v407,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v296,  v297);
      goto LABEL_111;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for TextOutputStreamable?);
    unint64_t v318 = v362;
    memcpy(v362, v192, v3);
    unint64_t v319 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v318, v2, v319, 6uLL)
      || (v406 = 0LL,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomStringConvertible?),  unint64_t v320 = v356,  memcpy(v356, v192, v3),  v321 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v404, v320, v2, v321, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_110;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v405 + 1) = v2;
    uint64_t v341 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v341, v192, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    id v342 = v401._object;
    uint64_t v343 = v192;
    Swift::String::Index v344 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v343,  &v401,  &v407,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v344);
    swift_release((uint64_t)v342);
  }

        unint64_t v58 = 0LL;
        return swift::Demangle::__runtime::Demangler::createWithChildren( this,  139,  v58,  v56,  (char *)v44,  (swift::Demangle::__runtime::Node *)v49);
      case 'a':
        goto LABEL_17;
      case 'b':
        uint64_t v11 = 12;
        goto LABEL_17;
      case 'c':
        uint64_t v11 = 28;
        goto LABEL_17;
      case 'e':
        uint64_t v11 = 72;
        goto LABEL_17;
      case 'f':
        uint64_t v12 = 0;
        uint64_t v15 = (_DWORD *)((char *)this + 96);
        uint64_t v16 = *((_DWORD *)this + 24);
        uint64_t v11 = 74;
        if (v16)
        {
          uint64_t v17 = 1;
          goto LABEL_19;
        }

        uint64_t v20 = 0LL;
        uint64_t v18 = 0LL;
        uint64_t v21 = 0LL;
        goto LABEL_63;
      case 'm':
        uint64_t v11 = 142;
        goto LABEL_17;
      case 'p':
        uint64_t v11 = 172;
        goto LABEL_17;
      case 'q':
        uint64_t v11 = 174;
        goto LABEL_17;
      case 'r':
        uint64_t v11 = 143;
        goto LABEL_17;
      case 'u':
        uint64_t v12 = 0;
        uint64_t v11 = 140;
LABEL_17:
        uint64_t v15 = (_DWORD *)((char *)this + 96);
        uint64_t v16 = *((_DWORD *)this + 24);
        if (v16)
        {
          uint64_t v17 = 0;
LABEL_19:
          uint64_t v18 = *(void *)(*((void *)this + 11) + 8LL * (v16 - 1));
          if (*(_WORD *)(v18 + 16) == 101)
          {
            *uint64_t v15 = --v16;
            if (!v17)
            {
LABEL_44:
              uint64_t v19 = v16;
              uint64_t v20 = 0LL;
              if (!v12)
              {
LABEL_45:
                uint64_t v21 = 0LL;
                if (!v19) {
                  goto LABEL_63;
                }
                goto LABEL_46;
              }

double Double.init(from:)(uint64_t *a1)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v9, v4, v5);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    double v2 = (*(double (**)(uint64_t, uint64_t))(v7 + 40))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v2;
}

uint64_t Double.encode(to:)(void *a1, double a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, double))(v6 + 40))(v5, v6, a2);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Double(void *a1)
{
  double v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, double))(v6 + 40))(v5, v6, v2);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Double@<X0>( uint64_t *a1@<X0>, double *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  double v9 = (*(double (**)(uint64_t, uint64_t))(v8 + 40))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

LABEL_59:
      int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
      goto LABEL_67;
    }

    if ((v72 & 0x2000000000000000LL) == 0) {
      goto LABEL_59;
    }
    int64_t v78 = specialized _SmallString.init(_:appending:)(v100._countAndFlagsBits, (unint64_t)v100._object, v71, v72);
    if ((v80 & 1) != 0)
    {
      int64_t v77 = HIBYTE(v74) & 0xF;
      goto LABEL_67;
    }

    unint64_t v81 = v78;
    uint64_t v82 = v79;
    swift_bridgeObjectRelease((uint64_t)v75);
    swift_bridgeObjectRelease(v74);
    v100._uint64_t countAndFlagsBits = v81;
    v100._unint64_t object = v82;
    uint64_t v74 = (unint64_t)v82;
    uint64_t v73 = v81;
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v100._object);
    v100._uint64_t countAndFlagsBits = v73;
    v100._unint64_t object = (void *)v74;
  }

      int64_t v77 = v71 & 0xFFFFFFFFFFFFLL;
      goto LABEL_67;
    }

    if ((v72 & 0x2000000000000000LL) == 0) {
      goto LABEL_59;
    }
    int64_t v78 = specialized _SmallString.init(_:appending:)(v100._countAndFlagsBits, (unint64_t)v100._object, v71, v72);
    if ((v80 & 1) != 0)
    {
      int64_t v77 = HIBYTE(v74) & 0xF;
      goto LABEL_67;
    }

    unint64_t v81 = v78;
    uint64_t v82 = v79;
    swift_bridgeObjectRelease((uint64_t)v75);
    swift_bridgeObjectRelease(v74);
    v100._uint64_t countAndFlagsBits = v81;
    v100._unint64_t object = v82;
    uint64_t v74 = (unint64_t)v82;
    uint64_t v73 = v81;
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v100._object);
    v100._uint64_t countAndFlagsBits = v73;
    v100._unint64_t object = (void *)v74;
  }

        uint64_t v159 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v159 + 56))( v154,  1LL,  1LL,  TupleTypeMetadata2);
        uint64_t v107 = 0LL;
      }
    }

    size_t v160 = v144;
    uint64_t v154 = v397;
    goto LABEL_59;
  }

  unint64_t v80 = v405;
  unint64_t v81 = v380;
  uint64_t v82 = v380 & 0xC000000000000001LL;
  if (a3 == &type metadata for Int)
  {
    int8x16_t v109 = v380;
    uint64_t v111 = a1[3];
    char v110 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v111);
    (*(void (**)(uint64_t *__return_ptr, ValueMetadata *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v110 + 24))( v409,  &type metadata for _DictionaryCodingKey,  &type metadata for _DictionaryCodingKey,  &protocol witness table for _DictionaryCodingKey,  v111,  v110);
    uint64x2_t v115 = Description;
    if (v82)
    {
      if (v109 < 0) {
        unint64_t v116 = v109;
      }
      else {
        unint64_t v116 = v109 & 0xFFFFFFFFFFFFFF8LL;
      }
      uint64_t v117 = type metadata accessor for __CocoaDictionary.Iterator();
      Swift::String v118 = (unint64_t)swift_allocObject(v117, 0xE8uLL, 7uLL);
      v391 = 0LL;
      uint64_t v119 = 0LL;
      uint64_t v120 = 0LL;
      *(void *)(v118 + 208) = v116;
      *(void *)(v118 + 216) = 0LL;
      *(_OWORD *)(v118 + 16) = 0u;
      *(_OWORD *)(v118 + 32) = 0u;
      *(_OWORD *)(v118 + 48) = 0u;
      *(_OWORD *)(v118 + 64) = 0u;
      *(_OWORD *)(v118 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
      *(_OWORD *)(v118 + 96) = 0u;
      *(_OWORD *)(v118 + 112) = 0u;
      *(_OWORD *)(v118 + 128) = 0u;
      *(_OWORD *)(v118 + 144) = 0u;
      *(_OWORD *)(v118 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
      *(_OWORD *)(v118 + 176) = 0u;
      *(_OWORD *)(v118 + 192) = 0u;
      *(void *)(v118 + 224) = 0LL;
      int8x16_t v121 = v118 | 0x8000000000000000LL;
    }

    else
    {
      unint64_t v262 = -1LL << *(_BYTE *)(v109 + 32);
      uint64_t v119 = ~v262;
      uint64_t v263 = *(void *)(v109 + 64);
      v391 = (uint64_t *)(v109 + 64);
      uint64_t v264 = -v262;
      if (v264 < 64) {
        uint64_t v265 = ~(-1LL << v264);
      }
      else {
        uint64_t v265 = -1LL;
      }
      uint64_t v120 = v265 & v263;
      int8x16_t v121 = v109;
    }

    p_Kind = &v399->Kind;
    v396 = v121;
    unint64_t v267 = v121 & 0x7FFFFFFFFFFFFFFFLL;
    v390 = (char *)(v267 + 16);
    v394 = (char *)v267;
    v389 = (swift *)(v267 + 80);
    v388 = (uint64_t *)v119;
    i = (unint64_t)(v119 + 64) >> 6;
    v387 = (char *)(i - 1);
    swift_bridgeObjectRetain(v109, v112, v113, v114);
    unint64_t v271 = 0LL;
    v392 = (id *)&unk_189B8D230;
    while (1)
    {
      uint64_t v272 = v398;
      v405 = (char *)v120;
      v397 = v271;
      if ((v396 & 0x8000000000000000LL) != 0)
      {
        char v281 = v394;
        char v282 = *((void *)v394 + 27);
        size_t v283 = (char *)v407;
        uint64_t v273 = v403;
        if (v282 < 0) {
          goto LABEL_152;
        }
        uint64_t v284 = (void *)*((void *)v394 + 26);
        if (v282 == *((void *)v394 + 28))
        {
          unint64_t v285 = v271;
          uint64_t v286 = objc_msgSend(*((id *)v394 + 26), sel_countByEnumeratingWithState_objects_count_, v390, v389, 16);
          char v281 = v394;
          *((void *)v394 + 28) = v286;
          if (!v286)
          {
            *((void *)v281 + 27) = -1LL;
            unint64_t v271 = v285;
LABEL_152:
            int64_t v280 = *(TupleTypeMetadata2 - 1);
            Swift::Int v276 = v271;
            (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v280 + 56))( v272,  1LL,  1LL,  TupleTypeMetadata2);
            unint64_t v279 = TupleTypeMetadata2;
            uint64_t v274 = (uint64_t)v405;
            uint64x2_t v115 = Description;
            goto LABEL_153;
          }

          char v282 = 0LL;
          *((void *)v281 + 27) = 0LL;
        }

        uint64_t v287 = *((void *)v281 + 3);
        if (!v287) {
          goto LABEL_232;
        }
        uint64_t v288 = (void **)(v287 + 8 * v282);
        unint64_t v289 = *v288;
        *((void *)v281 + 27) = v282 + 1;
        swift_unknownObjectRetain(v289, v268, v269, v270);
        unint64_t v290 = (swift *)objc_msgSend(v284, sel_objectForKey_, v289);
        if (!v290) {
          goto LABEL_233;
        }
        unint64_t v291 = v290;
        if (_swift_isClassOrObjCExistentialType((uint64_t)&type metadata for Int, &type metadata for Int.Kind))
        {
          *(void *)&v412 = v289;
          swift_dynamicCast(v272, (uint64_t *)&v412, (swift *)v392, (const char *)&type metadata for Int, 7uLL);
        }

        else
        {
          uint64_t v306 = v373;
          Description[7](v373, 1LL, 1LL, &type metadata for Int);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v289, (uint64_t)&type metadata for Int, v306);
          uint64_t v307 = v374;
          (*(void (**)(char *, uint64_t *, uint64_t))(v378 + 16))(v374, v306, v386);
          if (((unsigned int (*)(char *, uint64_t, ValueMetadata *))Description[6])( v307,  1LL,  &type metadata for Int) == 1) {
            goto LABEL_235;
          }
          (*(void (**)(uint64_t *, uint64_t))(v378 + 8))(v306, v386);
          ((void (*)(char *, char *, ValueMetadata *))Description[4])(v272, v307, &type metadata for Int);
          swift_unknownObjectRelease(v289);
          TupleTypeMetadata2 = v406;
          p_Kind = &v399->Kind;
        }

        unint64_t v292 = &v272[*((int *)TupleTypeMetadata2 + 12)];
        Swift::String::Index v293 = v283;
        if (_swift_isClassOrObjCExistentialType((uint64_t)v283, (uint64_t *)v283))
        {
          *(void *)&v412 = v291;
          swift_dynamicCast(v292, (uint64_t *)&v412, (swift *)&unk_189B8D230, v283, 7uLL);
          uint64x2_t v115 = Description;
        }

        else
        {
          uint64_t v308 = (uint64_t *)v375;
          (*(void (**)(char *, uint64_t, uint64_t, char *))(v403 + 56))(v375, 1LL, 1LL, v283);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v291, (uint64_t)v283, v308);
          unint64_t v309 = p_Kind;
          char v310 = p_Kind;
          unint64_t v311 = v377;
          (*(void (**)(uint64_t *, uint64_t *, uint64_t))(v379 + 16))(v309, v308, v377);
          unint64_t v312 = (*(uint64_t (**)(uint64_t *, uint64_t, char *))(v403 + 48))(v310, 1LL, v293);
          uint64x2_t v115 = Description;
          if (v312 == 1) {
            goto LABEL_235;
          }
          (*(void (**)(uint64_t *, uint64_t))(v379 + 8))(v308, v311);
          (*(void (**)(char *, ValueMetadata *, char *))(v403 + 32))(v292, v399, v293);
          swift_unknownObjectRelease(v291);
          TupleTypeMetadata2 = v406;
        }

        int64_t v280 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v280 + 56))( v272,  0LL,  1LL,  TupleTypeMetadata2);
        Swift::Int v276 = v397;
        unint64_t v279 = TupleTypeMetadata2;
        uint64_t v274 = (uint64_t)v405;
        uint64_t v273 = v403;
      }

      else
      {
        uint64_t v273 = v403;
        if (v120)
        {
          uint64_t v274 = (v120 - 1) & v120;
          unint64_t v275 = __clz(__rbit64(v120)) | ((void)v271 << 6);
          Swift::Int v276 = v271;
          goto LABEL_131;
        }

        Swift::Int v276 = v271 + 1;
        if (__OFADD__(v271, 1LL)) {
          goto LABEL_223;
        }
        if ((uint64_t)v276 >= i)
        {
          Swift::Int v276 = v271;
        }

        else
        {
          Swift::String::Index v294 = v391[(void)v276];
          if (v294) {
            goto LABEL_148;
          }
          char v305 = v271 + 2;
          if ((uint64_t)(v271 + 2) < i)
          {
            Swift::String::Index v294 = v391[(void)v305];
            if (v294)
            {
              Swift::Int v276 = v271 + 2;
LABEL_148:
              uint64_t v274 = (v294 - 1) & v294;
              unint64_t v275 = __clz(__rbit64(v294)) + ((void)v276 << 6);
LABEL_131:
              int64_t v277 = v396;
              ((void (*)(char *, unint64_t, ValueMetadata *))v115[2])( v398,  *(void *)(v396 + 48) + (void)v115[9] * v275,  &type metadata for Int);
              uint64_t v278 = *(void *)(v277 + 56) + *(void *)(v273 + 72) * v275;
              unint64_t v279 = v406;
              (*(void (**)(char *, unint64_t, uint64_t *))(v273 + 16))( &v272[*((int *)v406 + 12)],  v278,  v407);
              int64_t v280 = *(v279 - 1);
              (*(void (**)(char *, void, uint64_t, unint64_t *))(v280 + 56))(v272, 0LL, 1LL, v279);
              goto LABEL_153;
            }

            while (1)
            {
              Swift::Int v276 = v305 + 1;
              if (__OFADD__(v305, 1LL)) {
                goto LABEL_228;
              }
              Swift::String::Index v294 = v391[(void)v276];
              ++v305;
              if (v294) {
                goto LABEL_148;
              }
            }

            Swift::Int v276 = v387;
          }
        }

        int64_t v280 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v280 + 56))( v398,  1LL,  1LL,  TupleTypeMetadata2);
        unint64_t v279 = TupleTypeMetadata2;
        uint64_t v274 = 0LL;
      }

    uint64_t v12 = v335;
    *(void *)(v335 + 8 * (v163 >> 6) + 64) |= 1LL << v163;
    ((void (*)(unint64_t, char *, char *))v138)( *(void *)(v12 + 48) + (void)v164[9] * v163,  v326,  v160);
    v143((char *)(*(void *)(v12 + 56) + *(void *)(v331 + 72) * v163), (uint64_t)v325, v339);
    uint64_t v165 = *(void *)(v12 + 16);
    uint64_t v113 = __OFADD__(v165, 1LL);
    Swift::String::Index v166 = v165 + 1;
    if (v113) {
      goto LABEL_188;
    }
    *(void *)(v12 + 16) = v166;
LABEL_37:
    unint64_t v69 = (unint64_t)v319 + 1;
    swift_bridgeObjectRelease(0x8000000000000000LL);
    char v70 = v318 + 32;
    uint64_t v63 = v332;
    uint64_t v66 = v310;
    if (v309 == (__objc2_class *)v69) {
      goto LABEL_97;
    }
  }

  v136[1](v132, (ValueMetadata *)v134);
  swift_release(v312);
  swift_bridgeObjectRelease(v139);
  swift_bridgeObjectRelease(v12);
  unint64_t v219 = (uint64_t *)&v338;
LABEL_114:
  swift_bridgeObjectRelease(*(v219 - 32));
  a1 = v311;
LABEL_88:
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v12;
}

            swift_bridgeObjectRelease_n(0xE700000000000000LL, 5LL);
            int64_t v51 = object;
            goto LABEL_60;
          }

        unint64_t v195 = v311;
        unint64_t v196 = v181;
        unint64_t v197 = v178;
        id v198 = v341;
        uint64_t v199 = v312;
        id v336 = (void (**)(char *, void, unint64_t *))&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral;
        uint64_t v200 = swift_getAssociatedConformanceWitness( (uint64_t)v311,  (uint64_t)v341,  v312,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v201 = v313;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v200 + 8))( &qword_18180BE70,  512LL,  v199,  v200);
        size_t v202 = v309;
        unint64_t v203 = v198;
        (*((void (**)(char *, unint64_t *, const char *))v195 + 3))(v201, v198, v195);
        uint64_t v204 = v339;
        size_t v205 = v343;
        Swift::String v206 = swift_getAssociatedConformanceWitness( v339,  v343,  (uint64_t)v198,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
        unint64_t v207 = v327;
        unint64_t v208 = v205;
        uint64_t v209 = v342;
        (*(void (**)(char *, char *, unint64_t *, uint64_t, unint64_t *, unint64_t))(v206 + 256))( v202,  v342,  v45,  v197,  v203,  v206);
        unint64_t v210 = *(void (**)(char *, unint64_t *))(v328 + 8);
        v210(v202, v203);
        ((void (*)(char *, unint64_t *))v196)(v209, v45);
        uint64_t v211 = v310;
        unint64_t v212 = v332;
        (*(void (**)(char *, char *, unint64_t *, unint64_t))(v206 + 208))( v207,  v332,  v203,  v206);
        v210(v207, v203);
        uint64_t v213 = v212;
        unint64_t v214 = v208;
        v210(v213, v203);
        LOBYTE(v203) = ((uint64_t (*)(uint64_t, uint64_t))v331)(v208, v204);
        uint64_t v215 = v308;
        Swift::String::Index v216 = v334;
        v307(v308, v340, v334);
        if ((v203 & 1) != 0)
        {
          uint64_t v217 = v324;
          unint64_t v218 = v304;
          unint64_t v219 = swift_getAssociatedConformanceWitness( (uint64_t)v324,  v216,  v304,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)v336);
          unint64_t v220 = v322;
          (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v219 + 8))( &unk_18180BE68,  256LL,  v218,  v219);
          unint64_t v221 = v323;
          (*((void (**)(char *, uint64_t, const char *))v217 + 3))(v220, v216, v217);
          LOBYTE(v218) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v338 + 24) + 8LL)
                                                                            + 16LL))( v215,  v221,  v216);
          Swift::Int v222 = v306;
          ((void (*)(char *, uint64_t))v306)(v221, v216);
          ((void (*)(char *, uint64_t))v222)(v215, v216);
          int64_t v223 = v326;
          if ((v218 & 1) != 0)
          {
            uint64_t v224 = v302;
            unint64_t v225 = AssociatedTypeWitness;
            int64_t v226 = swift_getAssociatedConformanceWitness( (uint64_t)v302,  v214,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            char v227 = v301;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v226 + 8))( &unk_18180BE68,  256LL,  v225,  v226);
            uint64_t v228 = v297;
            (*((void (**)(char *, uint64_t, const char *))v224 + 3))(v227, v214, v224);
            size_t v229 = v298;
            (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v204 + 88))( v211,  v341,  v206,  v214,  v204);
            uint64_t v230 = v299;
            (*(void (**)(char *, char *, uint64_t))(v337 + 88))(v299, v229, v214);
            unint64_t v231 = v325;
            unint64_t v232 = *(void (**)(char *, uint64_t))(v325 + 8);
            v232(v229, v214);
            v232(v228, v214);
            (*(void (**)(uint64_t, char *, uint64_t))(v231 + 32))(v223, v230, v214);
LABEL_64:
            size_t v160 = v305;
            (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v231 + 56))(v223, 0LL, 1LL, v214);
            return v160 & 1;
          }
        }

        else
        {
          ((void (*)(char *, uint64_t))v306)(v215, v216);
          int64_t v223 = v326;
        }

        (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v204 + 88))( v211,  v341,  v206,  v214,  v204);
        unint64_t v231 = v325;
        goto LABEL_64;
      }

      char v182 = v234;
    }

    ((void (*)(char *, unint64_t *))v181)(v182, v45);
    goto LABEL_59;
  }

  unint64_t v80 = v16 & ~v17;
  if ((v80 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v79 <= 15) {
      goto LABEL_76;
    }
LABEL_65:
    unint64_t v83 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
    uint64_t v86 = (v84 & 1) == 0 && v83 > 0;
    if ((v80 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v86) {
        goto LABEL_101;
      }
    }

    else if (v86)
    {
LABEL_100:
      _StringGuts.grow(_:)(v79);
LABEL_101:
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
      unint64_t v134 = xmmword_1817FFC80;
      uint16x8_t v112 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v134, 1LL);
      _StringGuts.appendInPlace(_:isASCII:)(v112, v113, 1);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return v135;
    }

    unint64_t v108 = _StringGuts.nativeCapacity.getter(v16, v17);
    if ((v109 & 1) != 0) {
      char v110 = 0LL;
    }
    else {
      char v110 = v108;
    }
    if (v110 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_117;
    }

    uint64_t v111 = 2 * v110;
    if (v111 > v79) {
      char v79 = v111;
    }
    goto LABEL_100;
  }

  unint64_t v81 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
  if ((v82 & 1) != 0)
  {
LABEL_118:
    uint64_t v120 = 258LL;
LABEL_119:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v120,  0);
  }

  if (v79 > 15) {
    goto LABEL_65;
  }
  if ((v17 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    goto LABEL_77;
  }

  if (v81 > 0) {
    goto LABEL_65;
  }
LABEL_76:
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
  if ((v17 & 0x2000000000000000LL) != 0)
  {
LABEL_77:
    int64_t v77 = v17;
  }

  else if ((v17 & 0x1000000000000000LL) != 0)
  {
    uint64_t v16 = _StringGuts._foreignConvertedToSmall()(v16, v17);
    int64_t v77 = v123;
  }

  else
  {
    if ((v16 & 0x1000000000000000LL) != 0)
    {
      uint64_t v119 = (unsigned __int8 *)((v17 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v119 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v16, v17);
      int64_t v77 = v87;
    }

    swift_bridgeObjectRetain(v17, v87, v88, v89);
    closure #1 in _StringGuts._convertedToSmall()(v119, v77, &v134);
    swift_bridgeObjectRelease(v17);
    int64_t v77 = *((void *)&v134 + 1);
    uint64_t v16 = v134;
  }

  v90._Swift::UInt64 rawBits = 1LL;
  v91._Swift::UInt64 rawBits = 65537LL;
  v92._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v90, v91, 0x5DuLL, 0xE100000000000000LL);
  if (v92._rawBits < 0x10000) {
    v92._rawBits |= 3;
  }
  int64_t v76 = specialized String.init(_:)(v92, v93, 0x5DuLL, 0xE100000000000000LL);
  char v79 = v94;
  swift_bridgeObjectRelease(0xE100000000000000LL);
  if ((v79 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v79);
    goto LABEL_82;
  }

  int64_t v77 = v16 & ~v17;
  if ((v77 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v76 <= 15) {
      goto LABEL_76;
    }
LABEL_65:
    unint64_t v80 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
    unint64_t v83 = (v81 & 1) == 0 && v80 > 0;
    if ((v77 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v83) {
        goto LABEL_101;
      }
    }

    else if (v83)
    {
LABEL_100:
      _StringGuts.grow(_:)(v76);
LABEL_101:
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
      int8x16_t v130 = xmmword_1817FFC80;
      int8x16_t v109 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v130, 1LL);
      _StringGuts.appendInPlace(_:isASCII:)(v109, v110, 1);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return v131;
    }

    Swift::String v105 = _StringGuts.nativeCapacity.getter(v16, v17);
    if ((v106 & 1) != 0) {
      uint64_t v107 = 0LL;
    }
    else {
      uint64_t v107 = v105;
    }
    if (v107 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_117;
    }

    unint64_t v108 = 2 * v107;
    if (v108 > v76) {
      int64_t v76 = v108;
    }
    goto LABEL_100;
  }

  int64_t v78 = _StringGuts.nativeUnusedCapacity.getter(v16, v17);
  if ((v79 & 1) != 0)
  {
LABEL_118:
    unint64_t v116 = 258LL;
LABEL_119:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v116,  0);
  }

  if (v76 > 15) {
    goto LABEL_65;
  }
  if ((v17 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    goto LABEL_77;
  }

  if (v78 > 0) {
    goto LABEL_65;
  }
LABEL_76:
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
  if ((v17 & 0x2000000000000000LL) != 0)
  {
LABEL_77:
    uint64_t v74 = v17;
  }

  else if ((v17 & 0x1000000000000000LL) != 0)
  {
    uint64_t v16 = _StringGuts._foreignConvertedToSmall()(v16, v17);
    uint64_t v74 = v119;
  }

  else
  {
    if ((v16 & 0x1000000000000000LL) != 0)
    {
      uint64x2_t v115 = (unsigned __int8 *)((v17 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64x2_t v115 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v16, v17);
      uint64_t v74 = v84;
    }

    swift_bridgeObjectRetain(v17, v84, v85, v86);
    closure #1 in _StringGuts._convertedToSmall()(v115, v74, &v130);
    swift_bridgeObjectRelease(v17);
    uint64_t v74 = *((void *)&v130 + 1);
    uint64_t v16 = v130;
  }

  v87._Swift::UInt64 rawBits = 1LL;
  v88._Swift::UInt64 rawBits = 65537LL;
  v89._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v87, v88, 0x5DuLL, 0xE100000000000000LL);
  if (v89._rawBits < 0x10000) {
    v89._rawBits |= 3;
  }
  uint64_t v73 = specialized String.init(_:)(v89, v90, 0x5DuLL, 0xE100000000000000LL);
  int64_t v76 = v91;
  swift_bridgeObjectRelease(0xE100000000000000LL);
  if ((v76 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v76);
    goto LABEL_82;
  }

            if ((v56 & ~v55 & 0x2000000000000000LL) != 0
              && swift_isUniquelyReferenced_nonNull_native(v55 & 0xFFFFFFFFFFFFFFFLL))
            {
              unint64_t v72 = v242;
              uint64_t v71 = v243;
              uint64_t v73 = _StringGuts.nativeUnusedCapacity.getter(v242, v243);
              if ((v74 & 1) != 0)
              {
LABEL_264:
                unint64_t v231 = 258LL;
LABEL_265:
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v231,  0);
              }

              if (v70 > 15) {
                goto LABEL_74;
              }
              if ((v71 & 0x2000000000000000LL) == 0)
              {
                uint64_t v75 = v71;
                if (v73 < v66)
                {
LABEL_111:
                  unint64_t v108 = 1;
                  goto LABEL_147;
                }

  *unint64_t v39 = v61;
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

      if (v67[0] != v68) {
        free(v67[0]);
      }
      return v4;
    default:
      return v4;
  }

    if (foreign_type_protocol_conformance != 1) {
      goto LABEL_65;
    }
LABEL_6:
    if (v9)
    {
      uint64_t WitnessTable = v9;
      double v9 = 0LL;
      goto LABEL_75;
    }

LABEL_68:
  unint64_t v83 = HIBYTE(v74) & 0xF;
  if ((v74 & 0x2000000000000000LL) == 0) {
    unint64_t v83 = v73 & 0xFFFFFFFFFFFFLL;
  }
  if (v83 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
  {
    if ((v74 & 0x2000000000000000LL) == 0
      || (char v84 = specialized _SmallString.init(_:appending:)(v73, v74, 0x2065756C617620uLL, 0xE700000000000000LL),
          (v86 & 1) != 0))
    {
      _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
      swift_bridgeObjectRelease(0xE700000000000000LL);
    }

    else
    {
      unint64_t v87 = v84;
      unint64_t v88 = v85;
      swift_bridgeObjectRelease(v74);
      swift_bridgeObjectRelease(0xE700000000000000LL);
      v100._uint64_t countAndFlagsBits = v87;
      v100._unint64_t object = v88;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v74);
    v100._uint64_t countAndFlagsBits = 0x2065756C617620LL;
    v100._unint64_t object = (void *)0xE700000000000000LL;
  }

  specialized Double.write<A>(to:)();
  char v89 = v100._object;
  uint64_t v90 = ((unint64_t)v100._object >> 56) & 0xF;
  if (v90 || (v100._countAndFlagsBits & ~(uint64_t)v100._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v100._object & 0x2000000000000000LL) == 0
      || (unint64_t v91 = specialized _SmallString.init(_:appending:)( v100._countAndFlagsBits,  (unint64_t)v100._object,  0LL,  0xE000000000000000LL),  (v93 & 1) != 0))
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v94 = v100._countAndFlagsBits;
      unint64_t v95 = v100._object;
    }

    else
    {
      unint64_t v94 = v91;
      unint64_t v95 = v92;
      swift_bridgeObjectRelease((uint64_t)v89);
      swift_bridgeObjectRelease(0xE000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v100._object);
    unint64_t v94 = 0LL;
    unint64_t v95 = (void *)0xE000000000000000LL;
  }

  *(void *)uint64_t v23 = v26;
  *(void *)(v23 + 8) = v94;
  *(void *)(v23 + 16) = v95;
  *(void *)(v23 + 24) = 0LL;
  *(_BYTE *)(v23 + 72) = 3;
  swift_willThrow();
  return __swift_destroy_boxed_opaque_existential_1Tm(v99);
}

  unint64_t v83 = HIBYTE(v74) & 0xF;
  if ((v74 & 0x2000000000000000LL) == 0) {
    unint64_t v83 = v73 & 0xFFFFFFFFFFFFLL;
  }
  if (v83 || (v73 & ~v74 & 0x2000000000000000LL) != 0)
  {
    if ((v74 & 0x2000000000000000LL) == 0
      || (char v84 = specialized _SmallString.init(_:appending:)(v73, v74, 0x2065756C617620uLL, 0xE700000000000000LL),
          (v86 & 1) != 0))
    {
      _StringGuts.append(_:)(0x2065756C617620LL, 0xE700000000000000LL, 0LL, 7LL);
      swift_bridgeObjectRelease(0xE700000000000000LL);
    }

    else
    {
      unint64_t v87 = v84;
      unint64_t v88 = v85;
      swift_bridgeObjectRelease(v74);
      swift_bridgeObjectRelease(0xE700000000000000LL);
      v100._uint64_t countAndFlagsBits = v87;
      v100._unint64_t object = v88;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v74);
    v100._uint64_t countAndFlagsBits = 0x2065756C617620LL;
    v100._unint64_t object = (void *)0xE700000000000000LL;
  }

  specialized Float.write<A>(to:)();
  char v89 = v100._object;
  uint64_t v90 = ((unint64_t)v100._object >> 56) & 0xF;
  if (v90 || (v100._countAndFlagsBits & ~(uint64_t)v100._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v100._object & 0x2000000000000000LL) == 0
      || (unint64_t v91 = specialized _SmallString.init(_:appending:)( v100._countAndFlagsBits,  (unint64_t)v100._object,  0LL,  0xE000000000000000LL),  (v93 & 1) != 0))
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v94 = v100._countAndFlagsBits;
      unint64_t v95 = v100._object;
    }

    else
    {
      unint64_t v94 = v91;
      unint64_t v95 = v92;
      swift_bridgeObjectRelease((uint64_t)v89);
      swift_bridgeObjectRelease(0xE000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v100._object);
    unint64_t v94 = 0LL;
    unint64_t v95 = (void *)0xE000000000000000LL;
  }

  *(void *)uint64_t v23 = v26;
  *(void *)(v23 + 8) = v94;
  *(void *)(v23 + 16) = v95;
  *(void *)(v23 + 24) = 0LL;
  *(_BYTE *)(v23 + 72) = 3;
  swift_willThrow();
  return __swift_destroy_boxed_opaque_existential_1Tm(v99);
}

    unint64_t v27 = (v9._rawBits >> 8) & 0x3F;
    if (v27) {
      goto LABEL_71;
    }
    if (v5 == v9._rawBits >> 14)
    {
      unint64_t v27 = 0LL;
      goto LABEL_71;
    }

    uint64_t v34 = v9._rawBits >> 16;
    if ((a2 & 0x1000000000000000LL) != 0) {
      goto LABEL_112;
    }
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      int64_t v49 = a1;
      int64_t v50 = v44;
      if (v34 + 1 == v47) {
        goto LABEL_90;
      }
      uint64_t v37 = *(unsigned __int16 *)((char *)&v49 + v34);
    }

    else
    {
      uint64_t v35 = (char *)v45;
      unint64_t v36 = v48;
      if ((a1 & 0x1000000000000000LL) == 0) {
        uint64_t v35 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
      }
      if (v34 + 1 == v36) {
        goto LABEL_90;
      }
      if (!v35) {
LABEL_126:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      uint64_t v37 = *(unsigned __int16 *)&v35[v34];
    }

    if (v37 == 2573 || (v37 & 0x80808080) != 0)
    {
LABEL_112:
      unint64_t v27 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9._rawBits >> 16);
LABEL_71:
      uint64_t v28 = v9._rawBits + (v27 << 16);
      unint64_t v29 = v28 & 0xFFFFFFFFFFFF0000LL;
      if (v5 != (v28 & 0xFFFFFFFFFFFF0000LL) >> 14)
      {
        uint64_t v30 = v28 >> 16;
        if ((a2 & 0x1000000000000000LL) == 0)
        {
          if ((a2 & 0x2000000000000000LL) != 0) {
            goto LABEL_92;
          }
          goto LABEL_74;
        }

        goto LABEL_98;
      }

      goto LABEL_10;
    }

        __break(1u);
LABEL_69:
        __break(1u);
LABEL_70:
        __break(1u);
LABEL_71:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }

      ++v13;
    }

                Swift::String::Index v239 = v622;
                (*(void (**)(uint64_t, unint64_t *))(*(void *)(AssociatedConformanceWitness + 16)
                                                                    + 16LL))( v179,  v69);
                ((void (*)(uint64_t, unint64_t *))v149)(v179, v69);
                if ((((uint64_t (*)(unint64_t *, char *))v656)(v69, v67) & 1) != 0)
                {
                  Swift::String::Index v240 = v604;
                  (*(void (**)(char *, char *, unint64_t *))(v203 + 16))(v604, v239, v69);
                  Swift::String::Index v241 = v648;
                  Swift::String::Index v242 = v646;
                  unint64_t v243 = swift_getAssociatedConformanceWitness( (uint64_t)v648,  (uint64_t)v69,  (uint64_t)v646,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  unint64_t v244 = v647;
                  (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v243 + 8))( &qword_18180BE68,  256LL,  v242,  v243);
                  (*((void (**)(unsigned int (*)(void), unint64_t *, const char *))v241
                   + 3))( v244,  v69,  v241);
                  LOBYTE(v241) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                                + 32LL))( v240,  v169,  v69);
                  ((void (*)(float *, unint64_t *))v149)(v169, v69);
                  ((void (*)(char *, unint64_t *))v149)(v240, v69);
                  unint64_t v203 = v655;
                  Swift::String::Index v239 = v622;
                }

                if (v180(v69, v67) < 64)
                {
LABEL_200:
                  unint64_t v302 = v658;
                  v428 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                  v429 = v239;
                  id v336 = (unint64_t *)v428;
                  ((void (*)(char *, unint64_t *))v149)(v429, v69);
                  uint64_t v306 = (unsigned int (*)(void))(127LL - (void)v336);
                  if ((unint64_t)v336 > 0x7F)
                  {
                    __break(1u);
                    goto LABEL_282;
                  }

    uint64_t v35 = *(__objc2_class ***)v0;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*(void *)v0);
    *(void *)uint64_t v0 = v35;
    if (!isUniquelyReferenced_nonNull_native)
    {
      uint64_t v35 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v35[2]->isa + 1,  1,  (uint64_t)v35);
      *(void *)uint64_t v0 = v35;
    }

    uint64_t v38 = (unint64_t)v35[2];
    uint64_t v37 = (unint64_t)v35[3];
    unint64_t v39 = (__objc2_class *)(v38 + 1);
    if (v38 >= v37 >> 1)
    {
      char v41 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v37 > 1),  v38 + 1,  1,  (uint64_t)v35);
      unint64_t v39 = (__objc2_class *)(v38 + 1);
      uint64_t v35 = v41;
    }

    v35[2] = v39;
    int64_t v40 = &v35[v38];
    *((_DWORD *)v40 + 8) = value;
    *((_WORD *)v40 + 18) = v19;
    *(void *)uint64_t v0 = v35;
LABEL_73:
    uint64_t v7 = *(void *)(v0 + 32);
    uint64_t v8 = v6._rawBits >> 14;
  }

  while (v6._rawBits >> 14 < v7 >> 14);
  uint64_t v1 = *(void *)v0;
LABEL_82:
  unint64_t v43 = *(void *)(v1 + 16);
  if (v43 >= 2)
  {
    uint64_t v44 = 1LL;
    unint64_t v45 = 44LL;
    do
    {
      unint64_t v46 = *(void *)(v1 + 16);
      if (v44 >= v46)
      {
LABEL_100:
        unint64_t v56 = 675LL;
        goto LABEL_101;
      }

      if ((*(unsigned __int16 *)(v1 + 8 * v44 + 36) >> 3) < (*(unsigned __int16 *)(v1 + 8 * v44 + 28) >> 3))
      {
        uint64_t v47 = v44;
        uint64_t v48 = v45;
        while (1)
        {
          if (v47 >= v46) {
            goto LABEL_100;
          }
          int64_t v49 = v47 - 1;
          if (v47 - 1 >= v46) {
            goto LABEL_100;
          }
          unint64_t v58 = *(_DWORD *)(v1 + v48 - 4);
          int64_t v50 = *(_WORD *)(v1 + v48);
          int64_t v51 = *(_DWORD *)(v1 + v48 - 12);
          char v52 = *(_WORD *)(v1 + v48 - 8);
          unint64_t v53 = swift_isUniquelyReferenced_nonNull_native(v1);
          *(void *)uint64_t v0 = v1;
          if (!v53)
          {
            uint64_t v1 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew()(v1);
            *(void *)uint64_t v0 = v1;
          }

          if (v49 + 1 >= *(void *)(v1 + 16)) {
            break;
          }
          unint64_t v54 = (_WORD *)(v1 + v48);
          *((_DWORD *)v54 - 1) = v51;
          *unint64_t v54 = v52;
          *(void *)uint64_t v0 = v1;
          uint64_t v47 = v49;
          if (v49 >= *(void *)(v1 + 16)) {
            break;
          }
          *((_DWORD *)v54 - 3) = v58;
          *(v54 - 4) = v50;
          *(void *)uint64_t v0 = v1;
          if (!v49) {
            goto LABEL_86;
          }
          unint64_t v46 = *(void *)(v1 + 16);
          if (v49 >= v46) {
            goto LABEL_100;
          }
          uint64_t v55 = v1 + v48;
          v48 -= 8LL;
        }

        unint64_t v56 = 688LL;
LABEL_101:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  v56,  0);
      }

          if ((v69 & 1) != 0) {
            goto LABEL_113;
          }
          int64_t v77 = &v44[2 * v46];
          char v79 = *v77;
          int64_t v78 = v77[1];
          unint64_t v57 = __OFSUB__(v78, v79);
          unint64_t v80 = (char *)v78 - (char *)v79;
          if (v57) {
            goto LABEL_115;
          }
          if (v80 < v68) {
            goto LABEL_85;
          }
LABEL_76:
          unint64_t v85 = v46 - 1;
          if (v46 - 1 >= v43) {
            goto LABEL_103;
          }
          Swift::String v118 = (__objc2_class **)v36;
          if (!*v120) {
            goto LABEL_123;
          }
          uint64_t v86 = v20;
          unint64_t v87 = &v44[2 * v85];
          unint64_t v88 = (__objc2_class *)*v87;
          char v89 = v44;
          uint64_t v90 = &v44[2 * v46];
          unint64_t v91 = (__objc2_class *)v90[1];
          _merge<A>(low:mid:high:buffer:by:)( (char *)(*v120 + *(void *)(v114 + 72) * *v87),  (char *)(*v120 + *(void *)(v114 + 72) * *v90),  *v120 + *(void *)(v114 + 72) * (void)v91,  v112,  (uint64_t (*)(uint64_t, uint64_t))v115,  v116,  (uint64_t)v117);
          char *v87 = v88;
          v89[2 * v85 + 1] = v91;
          uint64_t v92 = (unint64_t)v86[2];
          if (v46 >= v92) {
LABEL_118:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Array.swift",  17LL,  2,  0x53BuLL,  0);
          unint64_t v43 = v92 - 1;
          if ((uint64_t)(v92 - 1 - v46) < 0) {
LABEL_119:
          }
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
          uint64_t v20 = v86;
          memmove(v90, v90 + 2, 16 * (v92 - 1 - v46));
          v86[2] = (__objc2_class *)v43;
          uint64_t v44 = v89;
          unint64_t v36 = (uint64_t)v118;
          if (v92 <= 2) {
            goto LABEL_85;
          }
        }
      }

      unint64_t v43 = 1LL;
LABEL_85:
      uint64_t v13 = v120[1];
      uint64_t v17 = v36;
      uint64_t v7 = v115;
      a2 = v116;
    }

    while (v36 < v13);
    if (v43 >= 2)
    {
      char v96 = *v120;
      while (1)
      {
        unint64_t v97 = v43 - 1;
        if (v43 <= 1) {
          break;
        }
        if (!v96) {
          goto LABEL_123;
        }
        uint64_t v98 = v43 - 2;
        uint64_t v99 = v20;
        uint64_t v100 = v20 + 4;
        unint64_t v101 = v20[2 * v43];
        uint64_t v102 = v20[2 * v97 + 5];
        _merge<A>(low:mid:high:buffer:by:)( (char *)(v96 + *(void *)(v114 + 72) * (void)v101),  (char *)(v96 + *(void *)(v114 + 72) * (void)v100[2 * v97]),  v96 + *(void *)(v114 + 72) * (void)v102,  v112,  (uint64_t (*)(uint64_t, uint64_t))v115,  v116,  (uint64_t)v117);
        char v103 = &v99[2 * v98 + 4];
        *char v103 = v101;
        v103[1] = v102;
        uint64_t v104 = (unint64_t)v99[2];
        if (v43 > v104) {
          goto LABEL_118;
        }
        uint64_t v20 = v99;
        memmove(&v99[2 * v97 + 4], &v99[2 * v43 + 4], 16 * (v104 - v43));
        v99[2] = (__objc2_class *)(v104 - 1);
        unint64_t v43 = v104 - 1;
        if (v104 <= 2) {
          goto LABEL_90;
        }
      }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  uint64_t v73 = v125(a3, a4);
  if (v73 < 64)
  {
    v67(v29, v71, a3);
    int64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63(v29, a3);
    int64_t v77 = v71;
    if (v76 < v127) {
      goto LABEL_68;
    }
    goto LABEL_33;
  }

  uint64_t v99 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  uint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v73, v74, v75);
  v99(&v127, &type metadata for Int, v100, a3, a4);
  uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v71,  v29,  a3);
LABEL_56:
  unint64_t v101 = v98;
  v63(v29, a3);
  int64_t v77 = v71;
  if ((v101 & 1) != 0) {
    goto LABEL_68;
  }
LABEL_33:
  v63(v77, a3);
LABEL_34:
  char v79 = v125;
  unint64_t v80 = v125(a3, a4);
  v67(v69, v70, a3);
  if (v80 >= 65)
  {
    v63(v69, a3);
    goto LABEL_36;
  }

  char v89 = v79(a3, a4);
  v63(v69, a3);
  if (v89 == 64 && (v124(a3, a4) & 1) == 0)
  {
LABEL_36:
    unint64_t v81 = v118;
    v67(v118, v70, a3);
    int8x8_t v127 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v82 = v124(a3, a4);
    unint64_t v83 = v125(a3, a4);
    if ((v82 & 1) != 0)
    {
      if (v83 > 64)
      {
        uint64_t v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
        unint64_t v88 = &v127;
        goto LABEL_45;
      }
    }

    else if (v83 > 63)
    {
      int8x16_t v126 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      unint64_t v88 = &v126;
LABEL_45:
      v86(v88, &type metadata for Int, v87, a3, a4);
      uint64_t v90 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v81,  a3);
      v63(v29, a3);
      if ((v90 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_46;
    }

    v67(v29, v81, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63(v29, a3);
LABEL_46:
    v63(v81, a3);
  }

  unint64_t v91 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v63(v70, a3);
  if ((v91 & 0x8000000000000000LL) == 0)
  {
    unint64_t v54 = v123;
    if (v91 >= 0x80)
    {
      uint64_t v55 = 0LL;
      unint64_t v56 = 0LL;
    }

    else
    {
      unint64_t v56 = (v122 << v91) | (v119 >> 1 >> ~(_BYTE)v91);
      uint64_t v55 = v119 << v91;
      if ((v91 & 0x40) != 0)
      {
        unint64_t v56 = v119 << v91;
        uint64_t v55 = 0LL;
      }
    }

    goto LABEL_51;
  }

  if (v91 <= 0xFFFFFFFFFFFFFF80LL)
  {
LABEL_19:
    unint64_t v54 = v123;
    uint64_t v55 = v122 >> 63;
    unint64_t v56 = v122 >> 63;
    goto LABEL_51;
  }

  unint64_t v56 = v122 >> 63;
  uint64_t v55 = ((2 * v122) << (v91 - 1)) | (v119 >> -(char)v91);
  unint64_t v54 = v123;
LABEL_51:
  *unint64_t v54 = v55;
  v54[1] = v56;
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  unint64_t v69 = v120(a3, a4);
  if (v69 < 64)
  {
    ((void (*)(char *, char *, uint64_t))v62)(v29, v67, a3);
    unint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
    uint64_t v73 = v67;
    if (v72 < v122) {
      goto LABEL_68;
    }
    goto LABEL_31;
  }

  char v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v69, v70, v71);
  v96(&v122, &type metadata for Int, v97, a3, a4);
  unint64_t v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v67,  v29,  a3);
LABEL_54:
  uint64_t v98 = v95;
  v61(v29, a3);
  uint64_t v73 = v67;
  if ((v98 & 1) != 0) {
    goto LABEL_68;
  }
LABEL_31:
  v61(v73, a3);
LABEL_32:
  uint64_t v75 = v120;
  int64_t v76 = v120(a3, a4);
  int64_t v77 = v115;
  ((void (*)(char *, char *, uint64_t))v62)(v115, v63, a3);
  if (v76 >= 65)
  {
    v61(v77, a3);
    goto LABEL_34;
  }

  unint64_t v85 = v75(a3, a4);
  v61(v77, a3);
  if (v85 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_34:
    ((void (*)(char *, char *, uint64_t))v62)(v66, v63, a3);
    uint16x8_t v122 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v78 = v119(a3, a4);
    char v79 = v120(a3, a4);
    if ((v78 & 1) != 0)
    {
      if (v79 > 64)
      {
        uint64_t v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        char v84 = &v122;
        goto LABEL_43;
      }
    }

    else if (v79 > 63)
    {
      int8x16_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
      char v84 = &v121;
LABEL_43:
      v82(v84, &type metadata for Int, v83, a3, a4);
      uint64_t v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v66,  a3);
      v61(v29, a3);
      if ((v86 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_44;
    }

    ((void (*)(char *, char *, uint64_t))v62)(v29, v66, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
LABEL_44:
    v61(v66, a3);
  }

  unint64_t v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v61(v63, a3);
  if ((v87 & 0x8000000000000000LL) == 0)
  {
    unint64_t v53 = v114 << v87;
    if (v87 >= 0x40) {
      unint64_t v53 = 0LL;
    }
    goto LABEL_48;
  }

  unint64_t v88 = v118;
  if (v87 <= 0xFFFFFFFFFFFFFFC0LL) {
    unint64_t v53 = 0LL;
  }
  else {
    unint64_t v53 = v114 >> -(char)v87;
  }
LABEL_49:
  *unint64_t v88 = v53;
  return result;
}

        Swift::String::Index v171 = v560._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        goto LABEL_85;
      }

      id v198 = specialized _SmallString.init(_:appending:)( v566,  v567,  v560._countAndFlagsBits,  (unint64_t)v560._object);
      if ((v200 & 1) != 0)
      {
        Swift::String::Index v171 = HIBYTE(object) & 0xF;
        unint64_t v162 = v558;
        uint64_t v151 = v559;
        goto LABEL_85;
      }

      unint64_t v201 = v198;
      size_t v202 = v199;
      swift_bridgeObjectRelease(v169);
      v566 = v201;
      v567 = v202;
      swift_bridgeObjectRelease(object);
    }

    else
    {
      memcpy(v99, v106, v2);
      Swift::String::Index v172 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
      if (!swift_dynamicCast((char *)&v563, (uint64_t *)v99, v1, v172, 6uLL))
      {
        v565 = 0LL;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
        unint64_t v175 = v522;
        memcpy(v522, v106, v2);
        unint64_t v176 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
        if (swift_dynamicCast((char *)&v563, v175, v1, v176, 6uLL))
        {
          outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
          unint64_t v177 = (uint64_t)v561;
          unint64_t v178 = v562;
          __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
          unint64_t v179 = (*(uint64_t (**)(uint64_t, uint64_t))(v178 + 8))(v177, v178);
          uint64_t v183 = v179;
          uint64_t v159 = v180;
          Swift::String::Index v184 = v567;
          char v185 = HIBYTE(v567) & 0xF;
          if ((v567 & 0x2000000000000000LL) == 0) {
            char v185 = v566 & 0xFFFFFFFFFFFFLL;
          }
          if (v185 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
          {
            _StringGuts.append(_:)(v179, v180);
            uint64_t v151 = v559;
          }

          else
          {
            swift_bridgeObjectRetain(v180, v180, v181, v182);
            swift_bridgeObjectRelease(v184);
            v566 = v183;
            v567 = v159;
            uint64_t v151 = v559;
          }

          goto LABEL_88;
        }

        v565 = 0LL;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?);
        char v191 = v512;
        memcpy(v512, v106, v2);
        uint64_t v192 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
        unint64_t v193 = swift_dynamicCast((char *)&v563, v191, v1, v192, 6uLL);
        uint64_t v151 = v559;
        if (v193)
        {
          outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
          unint64_t v194 = (uint64_t)v561;
          unint64_t v195 = v562;
          __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
          unint64_t v196 = (*(uint64_t (**)(uint64_t, uint64_t))(v195 + 8))(v194, v195);
          char v158 = v196;
          uint64_t v159 = v155;
          size_t v160 = v567;
          unint64_t v197 = HIBYTE(v567) & 0xF;
          if ((v567 & 0x2000000000000000LL) == 0) {
            unint64_t v197 = v566 & 0xFFFFFFFFFFFFLL;
          }
          if (v197 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
          {
            _StringGuts.append(_:)(v196, v155);
            goto LABEL_88;
          }

  uint64_t v24 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  unint64_t v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  unint64_t v29 = v25;
  uint64_t v30 = v26;
  uint64_t v31 = v27;
  uint64_t v32 = v28;
  uint64_t v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    uint64_t v33 = v29 + 1;
    if (__OFADD__(v29, 1LL))
    {
      uint64_t v73 = 1525LL;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v73,  0);
    }
  }

  uint64_t v34 = 0LL;
  uint64_t v35 = v30 + v29 - v33;
  if (v30 <= v33) {
    unint64_t v36 = v33;
  }
  else {
    unint64_t v36 = v30;
  }
  if (v32 <= v33) {
    uint64_t v37 = v33;
  }
  else {
    uint64_t v37 = v32;
  }
  uint64_t v38 = v37 - v33;
  unint64_t v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34) {
      goto LABEL_87;
    }
    if (v33 < v29)
    {
      uint64_t v73 = 1812LL;
      goto LABEL_168;
    }

    if (v39 == v34)
    {
      uint64_t v73 = 1813LL;
      goto LABEL_168;
    }

    if (v33 < 0)
    {
      uint64_t v73 = 1781LL;
      goto LABEL_168;
    }

    if (v38 == v34)
    {
      uint64_t v73 = 1782LL;
      goto LABEL_168;
    }

    if ((*(_BYTE *)(v31 + v33 + v34) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    int64_t v40 = v29 + v34++;
  }

  while (!__OFADD__(v40, 1LL));
  __break(1u);
LABEL_86:
  uint64_t v35 = v29 + v34;
LABEL_87:
  if (v35 < v29) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }
  char v41 = v35 + 1;
  if (__OFADD__(v35, 1LL))
  {
    __break(1u);
    goto LABEL_176;
  }

  if (v30 < v41)
  {
LABEL_176:
    uint64_t v73 = 1820LL;
    goto LABEL_168;
  }

  uint64_t v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  uint64_t v44 = v43;
  uint64_t v74 = (uint64_t)v5;
  uint64_t v75 = 0LL;
  unint64_t v45 = v5[3];
  int64_t v76 = 0xE000000000000000LL;
  unint64_t v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15) {
      _StringGuts.grow(_:)(v46 + 15);
    }
  }

  while (2)
  {
    if (v42 < 0) {
      goto LABEL_169;
    }
    uint64_t v55 = v46;
    if (v46 < v42)
    {
      uint64_t v73 = 1861LL;
      goto LABEL_168;
    }

    unint64_t v56 = v76;
    unint64_t v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000LL) != 0) {
      unint64_t v57 = HIBYTE(v76) & 0xF;
    }
    unint64_t v58 = v57 + v55;
    uint64_t v59 = v58 + 3;
    if (__OFADD__(v58, 3LL))
    {
      __break(1u);
      goto LABEL_172;
    }

    if (v59 >= 16)
    {
      unint64_t v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        unint64_t v56 = v76;
      }
    }

    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    uint64_t v75 = *(void *)(v56 + 24);
    int64_t v77 = 3LL;
    int64_t v78 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    if (v44 < 0)
    {
LABEL_172:
      uint64_t v73 = 1860LL;
      goto LABEL_168;
    }

    unint64_t v46 = v55 - v44;
    if (v55 - v44 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    char v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }

    uint64_t v63 = 0LL;
    unint64_t v64 = (unsigned __int8 *)&v8[v55];
    if (!v8) {
      unint64_t v64 = 0LL;
    }
    for (i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64) {
          goto LABEL_161;
        }
        uint64_t v67 = *i++;
        uint64_t v66 = v67;
        if ((v66 & 0x80) != 0) {
          break;
        }
        ++v63;
      }

      if (v66 > 0xDF) {
        break;
      }
      if (!i || i == v64 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v63 += 2LL;
    }

    if (v66 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }

    if (v66 < 0xED) {
      goto LABEL_136;
    }
    if (v66 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      unint64_t v69 = *i;
      if (v69 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }

    if (v66 < 0xF0)
    {
LABEL_136:
      if (!i || i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v63 += 3LL;
      goto LABEL_113;
    }

    if (v66 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      char v70 = i + 1;
      goto LABEL_156;
    }

    if ((v66 + 15) < 3u)
    {
      if (!i || i == v64) {
        goto LABEL_95;
      }
      char v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }

    if (i)
    {
      if (i != v64)
      {
        char v70 = i + 1;
        uint64_t v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v63 += 4LL;
          goto LABEL_113;
        }
      }
    }

  unint64_t v27 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v27);
  uint64_t v28 = specialized Collection.subscript.getter(v16, (uint64_t)(v8 + 4), v10);
  uint64_t v32 = v28;
  uint64_t v33 = v29;
  uint64_t v34 = v30;
  uint64_t v35 = v31;
  unint64_t v36 = v28;
  if (v28 != v29)
  {
    specialized Slice.subscript.getter(v28, v28, v29, v30, v31);
    unint64_t v36 = v32 + 1;
    if (__OFADD__(v32, 1LL))
    {
      int64_t v76 = 1525LL;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v76,  0);
    }
  }

  uint64_t v37 = 0LL;
  uint64_t v38 = v33 + v32 - v36;
  if (v33 <= v36) {
    unint64_t v39 = v36;
  }
  else {
    unint64_t v39 = v33;
  }
  if (v35 <= v36) {
    int64_t v40 = v36;
  }
  else {
    int64_t v40 = v35;
  }
  char v41 = v40 - v36;
  uint64_t v42 = v39 - v36;
  do
  {
    if (v33 - v36 == v37) {
      goto LABEL_87;
    }
    if (v36 < v32)
    {
      int64_t v76 = 1812LL;
      goto LABEL_168;
    }

    if (v42 == v37)
    {
      int64_t v76 = 1813LL;
      goto LABEL_168;
    }

    if (v36 < 0)
    {
      int64_t v76 = 1781LL;
      goto LABEL_168;
    }

    if (v41 == v37)
    {
      int64_t v76 = 1782LL;
      goto LABEL_168;
    }

    if ((*(_BYTE *)(v34 + v36 + v37) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    unint64_t v43 = v32 + v37++;
  }

  while (!__OFADD__(v43, 1LL));
  __break(1u);
LABEL_86:
  uint64_t v38 = v32 + v37;
LABEL_87:
  if (v38 < v32) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }
  uint64_t v44 = v38 + 1;
  if (__OFADD__(v38, 1LL))
  {
    __break(1u);
    goto LABEL_176;
  }

  if (v33 < v44)
  {
LABEL_176:
    int64_t v76 = 1820LL;
    goto LABEL_168;
  }

  unint64_t v45 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v32, v44, v34, v35);
  uint64_t v47 = v46;
  int64_t v77 = (uint64_t)v8;
  int64_t v78 = 0LL;
  uint64_t v48 = v8[3];
  char v79 = 0xE000000000000000LL;
  int64_t v49 = v48 & 0xFFFFFFFFFFFFLL;
  if ((v48 & 0xFFFFFFFFFFFFLL) != 0)
  {
    int64_t v50 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v51 & 1) != 0 || v50 < v49 + 15) {
      _StringGuts.grow(_:)(v49 + 15);
    }
  }

  while (2)
  {
    if (v45 < 0) {
      goto LABEL_169;
    }
    unint64_t v58 = v49;
    if (v49 < v45)
    {
      int64_t v76 = 1861LL;
      goto LABEL_168;
    }

    uint64_t v59 = v79;
    unint64_t v60 = v78 & 0xFFFFFFFFFFFFLL;
    if ((v79 & 0x2000000000000000LL) != 0) {
      unint64_t v60 = HIBYTE(v79) & 0xF;
    }
    uint64_t v61 = v60 + v58;
    char v62 = v61 + 3;
    if (__OFADD__(v61, 3LL))
    {
      __break(1u);
      goto LABEL_172;
    }

    if (v62 >= 16)
    {
      uint64_t v63 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v64 & 1) != 0 || v63 < v62)
      {
        _StringGuts.grow(_:)(v62);
        uint64_t v59 = v79;
      }
    }

    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v59 & 0xFFFFFFFFFFFFFFFLL, v11, v45, 0);
    int64_t v78 = *(void *)(v59 + 24);
    unint64_t v80 = 3LL;
    unint64_t v81 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v81, &v80, &v78);
    if (v58 < v47) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    if (v47 < 0)
    {
LABEL_172:
      int64_t v76 = 1860LL;
      goto LABEL_168;
    }

    int64_t v49 = v58 - v47;
    if (v58 - v47 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    Swift::String v65 = &v11[v47];
    if (_allASCII(_:)((uint64_t *)&v11[v47], v58 - v47))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v11[v47], v58 - v47, 0);
      break;
    }

    uint64_t v66 = 0LL;
    uint64_t v67 = (unsigned __int8 *)&v11[v58];
    if (!v11) {
      uint64_t v67 = 0LL;
    }
    for (i = (unsigned __int8 *)&v11[v47]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v67) {
          goto LABEL_161;
        }
        char v70 = *i++;
        unint64_t v69 = v70;
        if ((v69 & 0x80) != 0) {
          break;
        }
        ++v66;
      }

      if (v69 > 0xDF) {
        break;
      }
      if (!i || i == v67 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v66 += 2LL;
    }

    if (v69 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v67) {
        goto LABEL_95;
      }
      uint64_t v71 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }

    if (v69 < 0xED) {
      goto LABEL_136;
    }
    if (v69 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v67) {
        goto LABEL_95;
      }
      uint64_t v71 = i + 1;
      unint64_t v72 = *i;
      if (v72 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }

    if (v69 < 0xF0)
    {
LABEL_136:
      if (!i || i == v67) {
        goto LABEL_95;
      }
      uint64_t v71 = i + 1;
      LOBYTE(v72) = *i;
LABEL_139:
      if ((v72 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v71 == v67 || (*v71 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v66 += 3LL;
      goto LABEL_113;
    }

    if (v69 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v67) {
        goto LABEL_95;
      }
      uint64_t v73 = i + 1;
      goto LABEL_156;
    }

    if ((v69 + 15) < 3u)
    {
      if (!i || i == v67) {
        goto LABEL_95;
      }
      uint64_t v73 = i + 1;
      LOBYTE(v74) = *i;
      goto LABEL_155;
    }

    if (i)
    {
      if (i != v67)
      {
        uint64_t v73 = i + 1;
        uint64_t v74 = *i;
        if (v74 <= 0x8F)
        {
LABEL_155:
          if ((v74 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v73 == v67 || (i[1] & 0xC0) != 0x80 || i + 2 == v67 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v66 += 4LL;
          goto LABEL_113;
        }
      }
    }

  uint64_t v24 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  unint64_t v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  unint64_t v29 = v25;
  uint64_t v30 = v26;
  uint64_t v31 = v27;
  uint64_t v32 = v28;
  uint64_t v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    uint64_t v33 = v29 + 1;
    if (__OFADD__(v29, 1LL))
    {
      uint64_t v73 = 1525LL;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v73,  0);
    }
  }

  uint64_t v34 = 0LL;
  uint64_t v35 = v30 + v29 - v33;
  if (v30 <= v33) {
    unint64_t v36 = v33;
  }
  else {
    unint64_t v36 = v30;
  }
  if (v32 <= v33) {
    uint64_t v37 = v33;
  }
  else {
    uint64_t v37 = v32;
  }
  uint64_t v38 = v37 - v33;
  unint64_t v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34) {
      goto LABEL_87;
    }
    if (v33 < v29)
    {
      uint64_t v73 = 1812LL;
      goto LABEL_168;
    }

    if (v39 == v34)
    {
      uint64_t v73 = 1813LL;
      goto LABEL_168;
    }

    if (v33 < 0)
    {
      uint64_t v73 = 1781LL;
      goto LABEL_168;
    }

    if (v38 == v34)
    {
      uint64_t v73 = 1782LL;
      goto LABEL_168;
    }

    if ((*(_BYTE *)(v31 + v33 + v34) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    int64_t v40 = v29 + v34++;
  }

  while (!__OFADD__(v40, 1LL));
  __break(1u);
LABEL_86:
  uint64_t v35 = v29 + v34;
LABEL_87:
  if (v35 < v29) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }
  char v41 = v35 + 1;
  if (__OFADD__(v35, 1LL))
  {
    __break(1u);
    goto LABEL_176;
  }

  if (v30 < v41)
  {
LABEL_176:
    uint64_t v73 = 1820LL;
    goto LABEL_168;
  }

  uint64_t v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  uint64_t v44 = v43;
  uint64_t v74 = (uint64_t)v5;
  uint64_t v75 = 0LL;
  unint64_t v45 = v5[3];
  int64_t v76 = 0xE000000000000000LL;
  unint64_t v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15) {
      _StringGuts.grow(_:)(v46 + 15);
    }
  }

  while (2)
  {
    if (v42 < 0) {
      goto LABEL_169;
    }
    uint64_t v55 = v46;
    if (v46 < v42)
    {
      uint64_t v73 = 1861LL;
      goto LABEL_168;
    }

    unint64_t v56 = v76;
    unint64_t v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000LL) != 0) {
      unint64_t v57 = HIBYTE(v76) & 0xF;
    }
    unint64_t v58 = v57 + v55;
    uint64_t v59 = v58 + 3;
    if (__OFADD__(v58, 3LL))
    {
      __break(1u);
      goto LABEL_172;
    }

    if (v59 >= 16)
    {
      unint64_t v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        unint64_t v56 = v76;
      }
    }

    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    uint64_t v75 = *(void *)(v56 + 24);
    int64_t v77 = 3LL;
    int64_t v78 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    if (v44 < 0)
    {
LABEL_172:
      uint64_t v73 = 1860LL;
      goto LABEL_168;
    }

    unint64_t v46 = v55 - v44;
    if (v55 - v44 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    char v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }

    uint64_t v63 = 0LL;
    unint64_t v64 = (unsigned __int8 *)&v8[v55];
    if (!v8) {
      unint64_t v64 = 0LL;
    }
    for (i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64) {
          goto LABEL_161;
        }
        uint64_t v67 = *i++;
        uint64_t v66 = v67;
        if ((v66 & 0x80) != 0) {
          break;
        }
        ++v63;
      }

      if (v66 > 0xDF) {
        break;
      }
      if (!i || i == v64 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v63 += 2LL;
    }

    if (v66 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }

    if (v66 <= 0xEC) {
      goto LABEL_136;
    }
    if (v66 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      unint64_t v69 = *i;
      if (v69 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }

    if (v66 <= 0xEF)
    {
LABEL_136:
      if (!i || i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v63 += 3LL;
      goto LABEL_113;
    }

    if (v66 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      char v70 = i + 1;
      goto LABEL_156;
    }

    if ((v66 + 15) <= 2u)
    {
      if (!i || i == v64) {
        goto LABEL_95;
      }
      char v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }

    if (i)
    {
      if (i != v64)
      {
        char v70 = i + 1;
        uint64_t v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v63 += 4LL;
          goto LABEL_113;
        }
      }
    }

  unint64_t v29 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v29);
  uint64_t v30 = specialized Collection.subscript.getter(v18, (uint64_t)(v10 + 4), v12);
  uint64_t v34 = v30;
  uint64_t v35 = v31;
  unint64_t v36 = v32;
  uint64_t v37 = v33;
  uint64_t v38 = v30;
  if (v30 != v31)
  {
    specialized Slice.subscript.getter(v30, v30, v31, v32, v33);
    uint64_t v38 = v34 + 1;
    if (__OFADD__(v34, 1LL))
    {
      swift_bridgeObjectRelease(a5);
      int64_t v78 = 1525LL;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v78,  0);
    }
  }

  unint64_t v39 = 0LL;
  int64_t v40 = v35 + v34 - v38;
  if (v35 <= v38) {
    char v41 = v38;
  }
  else {
    char v41 = v35;
  }
  if (v37 <= v38) {
    uint64_t v42 = v38;
  }
  else {
    uint64_t v42 = v37;
  }
  unint64_t v43 = v42 - v38;
  uint64_t v44 = v41 - v38;
  do
  {
    if (v35 - v38 == v39) {
      goto LABEL_87;
    }
    if (v38 < v34)
    {
      swift_bridgeObjectRelease(a5);
      int64_t v78 = 1812LL;
      goto LABEL_168;
    }

    if (v44 == v39)
    {
      swift_bridgeObjectRelease(a5);
      int64_t v78 = 1813LL;
      goto LABEL_168;
    }

    if (v38 < 0)
    {
      swift_bridgeObjectRelease(a5);
      int64_t v78 = 1781LL;
      goto LABEL_168;
    }

    if (v43 == v39)
    {
      swift_bridgeObjectRelease(a5);
      int64_t v78 = 1782LL;
      goto LABEL_168;
    }

    if ((*(_BYTE *)(v36 + v38 + v39) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    unint64_t v45 = v34 + v39++;
  }

  while (!__OFADD__(v45, 1LL));
  __break(1u);
LABEL_86:
  int64_t v40 = v34 + v39;
LABEL_87:
  if (v40 < v34)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }

  unint64_t v46 = v40 + 1;
  if (__OFADD__(v40, 1LL))
  {
    __break(1u);
    goto LABEL_176;
  }

  if (v35 < v46)
  {
LABEL_176:
    int64_t v78 = 1820LL;
    goto LABEL_168;
  }

  char v79 = a5;
  uint64_t v47 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v34, v46, v36, v37);
  int64_t v49 = v48;
  unint64_t v80 = (uint64_t)v10;
  unint64_t v81 = 0LL;
  int64_t v50 = v10[3];
  uint64_t v82 = 0xE000000000000000LL;
  int64_t v51 = v50 & 0xFFFFFFFFFFFFLL;
  if ((v50 & 0xFFFFFFFFFFFFLL) != 0)
  {
    char v52 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v53 & 1) != 0 || v52 < v51 + 15) {
      _StringGuts.grow(_:)(v51 + 15);
    }
  }

  while (2)
  {
    if (v47 < 0) {
      goto LABEL_169;
    }
    unint64_t v60 = v51;
    if (v51 < v47)
    {
      swift_bridgeObjectRelease(v79);
      int64_t v78 = 1861LL;
      goto LABEL_168;
    }

    uint64_t v61 = v82;
    char v62 = v81 & 0xFFFFFFFFFFFFLL;
    if ((v82 & 0x2000000000000000LL) != 0) {
      char v62 = HIBYTE(v82) & 0xF;
    }
    uint64_t v63 = v62 + v60;
    unint64_t v64 = v63 + 3;
    if (__OFADD__(v63, 3LL))
    {
      __break(1u);
      goto LABEL_172;
    }

    if (v64 >= 16)
    {
      Swift::String v65 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v66 & 1) != 0 || v65 < v64)
      {
        _StringGuts.grow(_:)(v64);
        uint64_t v61 = v82;
      }
    }

    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v61 & 0xFFFFFFFFFFFFFFFLL, v13, v47, 0);
    unint64_t v81 = *(void *)(v61 + 24);
    unint64_t v83 = 3LL;
    char v84 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v84, &v83, &v81);
    if (v60 < v49)
    {
LABEL_169:
      swift_bridgeObjectRelease(v79);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    if (v49 < 0)
    {
LABEL_172:
      swift_bridgeObjectRelease(v79);
      int64_t v78 = 1860LL;
      goto LABEL_168;
    }

    int64_t v51 = v60 - v49;
    if (v60 - v49 < 0)
    {
      swift_bridgeObjectRelease(v79);
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }

    uint64_t v67 = &v13[v49];
    if (_allASCII(_:)((uint64_t *)&v13[v49], v60 - v49))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v13[v49], v60 - v49, 0);
      break;
    }

    unint64_t v68 = 0LL;
    unint64_t v69 = (unsigned __int8 *)&v13[v60];
    if (!v13) {
      unint64_t v69 = 0LL;
    }
    for (i = (unsigned __int8 *)&v13[v49]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v69) {
          goto LABEL_161;
        }
        unint64_t v72 = *i++;
        uint64_t v71 = v72;
        if ((v71 & 0x80) != 0) {
          break;
        }
        ++v68;
      }

      if (v71 > 0xDF) {
        break;
      }
      if (!i || i == v69 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v68 += 2LL;
    }

    if (v71 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v69) {
        goto LABEL_95;
      }
      uint64_t v73 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }

    if (v71 < 0xED) {
      goto LABEL_136;
    }
    if (v71 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v69) {
        goto LABEL_95;
      }
      uint64_t v73 = i + 1;
      uint64_t v74 = *i;
      if (v74 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }

    if (v71 < 0xF0)
    {
LABEL_136:
      if (!i || i == v69) {
        goto LABEL_95;
      }
      uint64_t v73 = i + 1;
      LOBYTE(v74) = *i;
LABEL_139:
      if ((v74 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v73 == v69 || (*v73 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v68 += 3LL;
      goto LABEL_113;
    }

    if (v71 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v69) {
        goto LABEL_95;
      }
      uint64_t v75 = i + 1;
      goto LABEL_156;
    }

    if ((v71 + 15) < 3u)
    {
      if (!i || i == v69) {
        goto LABEL_95;
      }
      uint64_t v75 = i + 1;
      LOBYTE(v76) = *i;
      goto LABEL_155;
    }

    if (i)
    {
      if (i != v69)
      {
        uint64_t v75 = i + 1;
        int64_t v76 = *i;
        if (v76 <= 0x8F)
        {
LABEL_155:
          if ((v76 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v75 == v69 || (i[1] & 0xC0) != 0x80 || i + 2 == v69 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v68 += 4LL;
          goto LABEL_113;
        }
      }
    }

  uint64_t v24 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  unint64_t v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  unint64_t v29 = v25;
  uint64_t v30 = v26;
  uint64_t v31 = v27;
  uint64_t v32 = v28;
  uint64_t v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    uint64_t v33 = v29 + 1;
    if (__OFADD__(v29, 1LL))
    {
      uint64_t v73 = 1525LL;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v73,  0);
    }
  }

  uint64_t v34 = 0LL;
  uint64_t v35 = v30 + v29 - v33;
  if (v30 <= v33) {
    unint64_t v36 = v33;
  }
  else {
    unint64_t v36 = v30;
  }
  if (v32 <= v33) {
    uint64_t v37 = v33;
  }
  else {
    uint64_t v37 = v32;
  }
  uint64_t v38 = v37 - v33;
  unint64_t v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34) {
      goto LABEL_87;
    }
    if (v33 < v29)
    {
      uint64_t v73 = 1812LL;
      goto LABEL_168;
    }

    if (v39 == v34)
    {
      uint64_t v73 = 1813LL;
      goto LABEL_168;
    }

    if (v33 < 0)
    {
      uint64_t v73 = 1781LL;
      goto LABEL_168;
    }

    if (v38 == v34)
    {
      uint64_t v73 = 1782LL;
      goto LABEL_168;
    }

    if ((*(_BYTE *)(v31 + v33 + v34) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    int64_t v40 = v29 + v34++;
  }

  while (!__OFADD__(v40, 1LL));
  __break(1u);
LABEL_86:
  uint64_t v35 = v29 + v34;
LABEL_87:
  if (v35 < v29) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }
  char v41 = v35 + 1;
  if (__OFADD__(v35, 1LL))
  {
    __break(1u);
    goto LABEL_176;
  }

  if (v30 < v41)
  {
LABEL_176:
    uint64_t v73 = 1820LL;
    goto LABEL_168;
  }

  uint64_t v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  uint64_t v44 = v43;
  uint64_t v74 = (uint64_t)v5;
  uint64_t v75 = 0LL;
  unint64_t v45 = v5[3];
  int64_t v76 = 0xE000000000000000LL;
  unint64_t v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15) {
      _StringGuts.grow(_:)(v46 + 15);
    }
  }

  while (2)
  {
    if (v42 < 0) {
      goto LABEL_169;
    }
    uint64_t v55 = v46;
    if (v46 < v42)
    {
      uint64_t v73 = 1861LL;
      goto LABEL_168;
    }

    unint64_t v56 = v76;
    unint64_t v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000LL) != 0) {
      unint64_t v57 = HIBYTE(v76) & 0xF;
    }
    unint64_t v58 = v57 + v55;
    uint64_t v59 = v58 + 3;
    if (__OFADD__(v58, 3LL))
    {
      __break(1u);
      goto LABEL_172;
    }

    if (v59 >= 16)
    {
      unint64_t v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        unint64_t v56 = v76;
      }
    }

    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    uint64_t v75 = *(void *)(v56 + 24);
    int64_t v77 = 3LL;
    int64_t v78 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    if (v44 < 0)
    {
LABEL_172:
      uint64_t v73 = 1860LL;
      goto LABEL_168;
    }

    unint64_t v46 = v55 - v44;
    if (v55 - v44 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    char v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }

    uint64_t v63 = 0LL;
    unint64_t v64 = (unsigned __int8 *)&v8[v55];
    if (!v8) {
      unint64_t v64 = 0LL;
    }
    for (i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64) {
          goto LABEL_161;
        }
        uint64_t v67 = *i++;
        uint64_t v66 = v67;
        if ((v66 & 0x80) != 0) {
          break;
        }
        ++v63;
      }

      if (v66 > 0xDF) {
        break;
      }
      if (!i || i == v64 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v63 += 2LL;
    }

    if (v66 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }

    if (v66 < 0xED) {
      goto LABEL_136;
    }
    if (v66 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      unint64_t v69 = *i;
      if (v69 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }

    if (v66 < 0xF0)
    {
LABEL_136:
      if (!i || i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v63 += 3LL;
      goto LABEL_113;
    }

    if (v66 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      char v70 = i + 1;
      goto LABEL_156;
    }

    if ((v66 + 15) < 3u)
    {
      if (!i || i == v64) {
        goto LABEL_95;
      }
      char v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }

    if (i)
    {
      if (i != v64)
      {
        char v70 = i + 1;
        uint64_t v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v63 += 4LL;
          goto LABEL_113;
        }
      }
    }

    if (((1LL << v24) & 0x20048) == 0) {
LABEL_69:
    }
      uint64_t v18 = v25;
LABEL_9:
    uint64_t v12 = v16;
    uint64_t v13 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(v16, a4, a5);
    uint64_t v16 = v21;
  }

  while ((v22 & 1) == 0);
LABEL_281:
  uint64_t v20 = v12;
  uint64_t v12 = v17;
  if ((v19 & 1) != 0) {
    return v20;
  }
  return v12;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t v67 = _Int128.multipliedReportingOverflow(by:)(a1);
  if (v67.overflow) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in multiplication",  26LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x30CuLL,  0);
  }
  low = v67.partialValue.low;
  high = v67.partialValue.high;
  uint64_t v7 = specialized FixedWidthInteger.init<A>(_:)(round((a2 - v4) * (double)a1));
  return specialized static Duration.+ infix(_:_:)(low, high, v7, v8);
}

                            unint64_t v29 = v21;
                            if (v23 != 2)
                            {
                              if (v23 != 5 || *((_DWORD *)v21 + 2) < 2u)
                              {
                                uint64_t v30 = 0LL;
LABEL_86:
                                if (*(_WORD *)(v30 + 16) != 101 || *(void *)(v30 + 8) != 27LL) {
                                uint64_t v37 = *(uint64_t **)v30;
                                }
                                uint64_t v38 = *v37;
                                unint64_t v39 = v37[1];
                                int64_t v40 = v37[2];
                                char v41 = *(uint64_t *)((char *)v37 + 19);
                                uint64_t v42 = v38 == 0x746963696C706D49LL && v39 == 0x706172776E55796CLL;
                                unint64_t v43 = v42 && v40 == 0x6F6974704F646570LL;
                                if (!v43 || v41 != 0x6C616E6F6974704FLL) {
                                unint64_t v45 = *(unsigned __int8 *)(v22 + 18);
                                }
                                if (v45 != 1 && (v45 != 5 || *(_DWORD *)(v22 + 8) != 1)) {
                                if ((v23 - 1) >= 2)
                                }
                                {
                                  if (v23 != 5 || !*((_DWORD *)v21 + 2))
                                  {
                                    unint64_t v46 = 0LL;
                                    goto LABEL_173;
                                  }

                                  uint64_t v21 = (uint64_t *)*v21;
                                }

                                unint64_t v46 = (uint64_t *)*v21;
LABEL_173:
                                if (*((_WORD *)v46 + 8) != 153 || v46[1] != 5) {
                                unint64_t v72 = (int *)*v46;
                                }
                                uint64_t v73 = *v72;
                                uint64_t v74 = *((unsigned __int8 *)v72 + 4);
                                if (v73 != 1718187859 || v74 != 116) {
                                uint64_t v66 = "!";
                                }
LABEL_181:
                                if (v6 != 2)
                                {
                                  if (*((_DWORD *)a2 + 2) < 2u)
                                  {
                                    int64_t v76 = 0LL;
LABEL_198:
                                    unint64_t v83 = *((unsigned __int8 *)v76 + 18);
                                    if ((v83 - 1) >= 2)
                                    {
                                      if (v83 != 5 || !*((_DWORD *)v76 + 2))
                                      {
                                        char v84 = 0LL;
                                        goto LABEL_204;
                                      }

                                      int64_t v76 = *(swift::Demangle::__runtime::Node **)v76;
                                    }

                                    char v84 = *(swift::Demangle::__runtime::Node **)v76;
LABEL_204:
                                    unint64_t v85 = v5;
                                    uint64_t v86 = v66;
                                    return std::string::append(v85, v86, 1uLL);
                                  }

                                  uint64_t v4 = *(swift::Demangle::__runtime::Node **)a2;
                                }

                                int64_t v76 = (swift::Demangle::__runtime::Node *)*((void *)v4 + 1);
                                goto LABEL_198;
                              }

                              unint64_t v29 = (uint64_t *)*v21;
                            }

                            uint64_t v30 = v29[1];
                            goto LABEL_86;
                          }

                          uint64_t v55 = (int ***)*v21;
                        }

                        unint64_t v56 = *v55;
                        goto LABEL_152;
                      }

                      uint64_t v26 = v21;
                      if (v23 != 2)
                      {
                        if (v23 != 5 || *((_DWORD *)v21 + 2) < 2u)
                        {
                          unint64_t v27 = 0LL;
LABEL_74:
                          if (*((_WORD *)v27 + 8) != 101
                            || v27[1] != 5
                            || ((uint64_t v31 = (int *)*v27, v32 = *v31, v33 = *((unsigned __int8 *)v31 + 4), v32 == 1634890305)
                              ? (uint64_t v34 = v33 == 121)
                              : (uint64_t v34 = 0),
                                !v34
                             || (unint64_t v57 = *(unsigned __int8 *)(v22 + 18), v57 != 1)
                             && (v57 != 5 || *(_DWORD *)(v22 + 8) != 1)))
                          {
LABEL_80:
                            uint64_t v35 = v21;
                            if (v23 != 2)
                            {
                              if (v23 != 5 || *((_DWORD *)v21 + 2) < 2u)
                              {
                                unint64_t v36 = 0LL;
LABEL_108:
                                uint64_t v47 = *v36;
                                uint64_t v48 = *v47;
                                int64_t v49 = *((unsigned __int16 *)v47 + 4);
                                if (v48 != 0x616E6F6974636944LL || v49 != 31090) {
                                unint64_t v60 = *(unsigned __int8 *)(v22 + 18);
                                }
                                if (v60 != 2 && (v60 != 5 || *(_DWORD *)(v22 + 8) != 2)) {
                                if ((v23 - 1) >= 2)
                                }
                                {
                                  if (v23 != 5 || !*((_DWORD *)v21 + 2))
                                  {
                                    uint64_t v61 = 0LL;
LABEL_186:
                                    if (*((_WORD *)v61 + 8) != 153 || v61[1] != 5) {
                                    int64_t v77 = (int *)*v61;
                                    }
                                    int64_t v78 = *v77;
                                    char v79 = *((unsigned __int8 *)v77 + 4);
                                    if (v78 != 1718187859 || v79 != 116) {
                                    unint64_t v81 = a2;
                                    }
                                    if (v6 != 2)
                                    {
                                      if (*((_DWORD *)a2 + 2) < 2u)
                                      {
                                        uint64_t v82 = 0LL;
LABEL_212:
                                        char v89 = *((unsigned __int8 *)v82 + 18);
                                        if ((v89 - 1) >= 2)
                                        {
                                          if (v89 != 5 || !*((_DWORD *)v82 + 2))
                                          {
                                            uint64_t v90 = 0LL;
LABEL_220:
                                            if (v6 != 2)
                                            {
                                              if (*((_DWORD *)a2 + 2) < 2u)
                                              {
                                                unint64_t v94 = 0LL;
LABEL_225:
                                                unint64_t v95 = *((unsigned __int8 *)v94 + 18);
                                                if (v95 != 2)
                                                {
                                                  if (v95 != 5 || *((_DWORD *)v94 + 2) < 2u)
                                                  {
                                                    char v96 = 0LL;
                                                    goto LABEL_231;
                                                  }

                                                  unint64_t v94 = (uint64_t *)*v94;
                                                }

                                                char v96 = (swift::Demangle::__runtime::Node *)v94[1];
LABEL_231:
                                                std::string::append(this, "[", 1uLL);
                                                unint64_t v97 = a3 + 1;
                                                std::string::append(v5, " : ", 3uLL);
                                                uint64_t v92 = (_anonymous_namespace_::NodePrinter *)v5;
                                                uint64_t v93 = v96;
                                                unint64_t v91 = v97;
                                                goto LABEL_232;
                                              }

                                              uint64_t v4 = *(swift::Demangle::__runtime::Node **)a2;
                                            }

                                            unint64_t v94 = (uint64_t *)*((void *)v4 + 1);
                                            goto LABEL_225;
                                          }

                                          uint64_t v82 = *(swift::Demangle::__runtime::Node **)v82;
                                        }

                                        uint64_t v90 = *(swift::Demangle::__runtime::Node **)v82;
                                        goto LABEL_220;
                                      }

                                      unint64_t v81 = *(swift::Demangle::__runtime::Node **)a2;
                                    }

                                    uint64_t v82 = (swift::Demangle::__runtime::Node *)*((void *)v81 + 1);
                                    goto LABEL_212;
                                  }

                                  uint64_t v21 = (uint64_t *)*v21;
                                }

                                uint64_t v61 = (uint64_t *)*v21;
                                goto LABEL_186;
                              }

                              uint64_t v35 = (uint64_t *)*v21;
                            }

                            unint64_t v36 = (uint64_t **)v35[1];
                            goto LABEL_108;
                          }

                          unint64_t v58 = (uint64_t **)v21;
                          if ((v23 - 1) >= 2)
                          {
                            if (v23 != 5 || !*((_DWORD *)v21 + 2))
                            {
                              uint64_t v59 = 0LL;
LABEL_161:
                              if (*((_WORD *)v59 + 8) != 153 || v59[1] != 5) {
                                goto LABEL_80;
                              }
                              uint64_t v67 = (int *)*v59;
                              unint64_t v68 = *v67;
                              unint64_t v69 = *((unsigned __int8 *)v67 + 4);
                              if (v68 != 1718187859 || v69 != 116) {
                                goto LABEL_80;
                              }
                              if (v6 != 2)
                              {
                                if (*((_DWORD *)a2 + 2) < 2u)
                                {
                                  uint64_t v71 = 0LL;
LABEL_206:
                                  unint64_t v87 = *((unsigned __int8 *)v71 + 18);
                                  if ((v87 - 1) >= 2)
                                  {
                                    if (v87 != 5 || !*((_DWORD *)v71 + 2))
                                    {
                                      unint64_t v88 = 0LL;
                                      goto LABEL_218;
                                    }

                                    uint64_t v71 = *(swift::Demangle::__runtime::Node **)v71;
                                  }

                                  unint64_t v88 = *(swift::Demangle::__runtime::Node **)v71;
LABEL_218:
                                  std::string::append(this, "[", 1uLL);
                                  unint64_t v91 = a3 + 1;
                                  uint64_t v92 = (_anonymous_namespace_::NodePrinter *)v5;
                                  uint64_t v93 = v88;
LABEL_232:
                                  uint64_t v86 = "]";
                                  unint64_t v85 = v5;
                                  return std::string::append(v85, v86, 1uLL);
                                }

                                uint64_t v4 = *(swift::Demangle::__runtime::Node **)a2;
                              }

                              uint64_t v71 = (swift::Demangle::__runtime::Node *)*((void *)v4 + 1);
                              goto LABEL_206;
                            }

                            unint64_t v58 = (uint64_t **)*v21;
                          }

                          uint64_t v59 = *v58;
                          goto LABEL_161;
                        }

                        uint64_t v26 = (uint64_t *)*v21;
                      }

                      unint64_t v27 = (uint64_t *)v26[1];
                      goto LABEL_74;
                    }

                    i = *(swift::Demangle::__runtime::Node **)i;
                  }

                  uint64_t v22 = *((void *)i + 1);
                  goto LABEL_47;
                }

                uint64_t v19 = (uint64_t *)*v19;
              }

              uint64_t v21 = (uint64_t *)*v19;
              goto LABEL_42;
            }

            uint64_t v18 = *(swift::Demangle::__runtime::Node **)i;
          }

          uint64_t v19 = *(uint64_t **)v18;
          goto LABEL_36;
        }
      }
    }
  }

  if (v6 == 5)
  {
    uint64_t v7 = *((_DWORD *)a2 + 2);
    if (v7 >= 2)
    {
      if (v7 != 2) {
      goto LABEL_6;
      }
    }
  }

  return this;
}

      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = 0LL;
      uint64_t v28 = (_DWORD *)(a4 + 16);
      goto LABEL_91;
    }

float Float.init(from:)(uint64_t *a1)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v9, v4, v5);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    float v2 = (*(float (**)(uint64_t, uint64_t))(v7 + 48))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v2;
}

uint64_t Float.encode(to:)(void *a1, float a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, float))(v6 + 48))(v5, v6, a2);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Float(void *a1)
{
  float v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, float))(v6 + 48))(v5, v6, v2);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Float@<X0>( uint64_t *a1@<X0>, float *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  float v9 = (*(float (**)(uint64_t, uint64_t))(v8 + 48))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

float Float16.init(from:)(uint64_t *a1)
{
  return specialized Float16.init(from:)(a1);
}

__int16 Float16.init(_:)@<H0>(float _S0@<S0>)
{
  __asm { FCVT            H0, S0 }

  return result;
}

BOOL Float16.isInfinite.getter(__n128 a1)
{
  return (a1.n128_u16[0] & 0x7FFF) == 31744;
}

BOOL Float.isFinite.getter(float a1)
{
  return (~LODWORD(a1) & 0x7F800000) != 0;
}

uint64_t Float16.encode(to:)(void *a1, __n128 _Q0)
{
  __asm { FCVT            S8, H0 }

  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 40))(v12, v7, v8);
  uint64_t v9 = v13;
  uint64_t v10 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, float))(v10 + 48))(v9, v10, _S8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

float Float.init(_:)(__n128 _Q0)
{
  __asm { FCVT            S0, H0 }

  return result;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Float16(void *a1)
{
  _H0 = *v1;
  __asm { FCVT            S8, H0 }

  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v8);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v9 + 40))(v13, v8, v9);
  uint64_t v10 = v14;
  uint64_t v11 = v15;
  __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
  (*(void (**)(uint64_t, uint64_t, float))(v11 + 48))(v10, v11, _S8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v13);
}

void protocol witness for Decodable.init(from:) in conformance Float16(uint64_t *a1@<X0>, _WORD *a2@<X8>)
{
  float v4 = specialized Float16.init(from:)(a1);
  if (!v2) {
    *a2 = LOWORD(v4);
  }
}

void *Int.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 56))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t Int.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Int(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Int@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 56))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *Int8.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 64))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t Int8.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 64))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Int8(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 64))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Int8@<X0>( uint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  char v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 64))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *Int16.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 72))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t Int16.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 72))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Int16(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 72))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Int16@<X0>( uint64_t *a1@<X0>, _WORD *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  __int16 v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 72))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *Int32.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 80))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t Int32.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 80))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Int32(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 80))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Int32@<X0>( uint64_t *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  int v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 80))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *Int64.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 88))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t Int64.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 88))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Int64(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 88))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Int64@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 88))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *Int128.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 96))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t Int128.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v10, v5, v6);
  uint64_t v7 = v11;
  uint64_t v8 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 96))(a2, a3, v7, v8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v10);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Int128(void *a1)
{
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v9, v4, v5);
  uint64_t v6 = v10;
  uint64_t v7 = v11;
  __swift_mutable_project_boxed_opaque_existential_1(v9, v10);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 96))(v3, v2, v6, v7);
  return __swift_destroy_boxed_opaque_existential_1Tm(v9);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Int128@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v13, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v14;
  uint64_t v8 = v15;
  __swift_project_boxed_opaque_existential_0Tm(v13, v14);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 96))(v7, v8);
  uint64_t v11 = v10;
  __swift_destroy_boxed_opaque_existential_1Tm(v13);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  a2[1] = v11;
  return result;
}

void *UInt.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 104))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t UInt.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 104))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance UInt(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 104))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance UInt@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 104))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *UInt8.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 112))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t UInt8.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 112))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance UInt8(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 112))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance UInt8@<X0>( uint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  char v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 112))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *UInt16.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t UInt16.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 120))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance UInt16(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 120))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance UInt16@<X0>( uint64_t *a1@<X0>, _WORD *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  __int16 v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 120))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *UInt32.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 128))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t UInt32.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 128))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance UInt32(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 128))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance UInt32@<X0>( uint64_t *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  int v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 128))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *UInt64.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 136))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t UInt64.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 136))(a2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance UInt64(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_mutable_project_boxed_opaque_existential_1(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 136))(v2, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Decodable.init(from:) in conformance UInt64@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v11, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 136))(v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  return result;
}

void *UInt128.init(from:)(uint64_t *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 40))(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    __swift_project_boxed_opaque_existential_0Tm(v9, v10);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v7 + 144))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v9);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v5;
}

uint64_t UInt128.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v10, v5, v6);
  uint64_t v7 = v11;
  uint64_t v8 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 144))(a2, a3, v7, v8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v10);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance UInt128(void *a1)
{
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v9, v4, v5);
  uint64_t v6 = v10;
  uint64_t v7 = v11;
  __swift_mutable_project_boxed_opaque_existential_1(v9, v10);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 144))(v3, v2, v6, v7);
  return __swift_destroy_boxed_opaque_existential_1Tm(v9);
}

uint64_t protocol witness for Decodable.init(from:) in conformance UInt128@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 40))(v13, v5, v6);
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  uint64_t v7 = v14;
  uint64_t v8 = v15;
  __swift_project_boxed_opaque_existential_0Tm(v13, v14);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 144))(v7, v8);
  uint64_t v11 = v10;
  __swift_destroy_boxed_opaque_existential_1Tm(v13);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *a2 = v9;
  a2[1] = v11;
  return result;
}

uint64_t Optional<A>.encode(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = a3;
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = (void *)MEMORY[0x1895F8858](v6);
  uint64_t v13 = (char *)&v21 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = v11[3];
  uint64_t v14 = v11[4];
  __swift_project_boxed_opaque_existential_0Tm(v11, v15);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 40))(v23, v15, v14);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v13, v26, a2);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v5 + 48))(v13, 1LL, v4) == 1)
  {
    uint64_t v16 = v24;
    uint64_t v17 = v25;
    __swift_mutable_project_boxed_opaque_existential_1(v23, v24);
    (*(void (**)(uint64_t, uint64_t))(v17 + 16))(v16, v17);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v8, v13, v4);
    uint64_t v18 = v24;
    uint64_t v19 = v25;
    __swift_mutable_project_boxed_opaque_existential_1(v23, v24);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 152))(v8, v4, v22, v18, v19);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v4);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v23);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <A> A?(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Optional<A>.encode(to:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t Optional<A>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v35 = a3;
  uint64_t v36 = a4;
  uint64_t v5 = a1;
  uint64_t v37 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v31 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = type metadata accessor for Optional(0LL, v8, v9, v10);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = v5[3];
  uint64_t v16 = v5[4];
  __swift_project_boxed_opaque_existential_0Tm(v5, v15);
  uint64_t v17 = v41;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v16 + 40))(v38, v15, v16);
  if (v17) {
    goto LABEL_2;
  }
  uint64_t v33 = v5;
  uint64_t v34 = 0LL;
  uint64_t v32 = v14;
  uint64_t v41 = v12;
  uint64_t v19 = v39;
  uint64_t v20 = v40;
  __swift_project_boxed_opaque_existential_0Tm(v38, v39);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v20 + 16))(v19, v20) & 1) != 0)
  {
    uint64_t v21 = 1LL;
    uint64_t v22 = v11;
    uint64_t v23 = v37;
    uint64_t v24 = v41;
    uint64_t v25 = v32;
LABEL_8:
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 56))(v25, v21, 1LL, a2);
    __swift_destroy_boxed_opaque_existential_1Tm(v38);
    (*(void (**)(uint64_t, char *, uint64_t))(v24 + 32))(v36, v25, v22);
    uint64_t v18 = v33;
    return __swift_destroy_boxed_opaque_existential_1Tm(v18);
  }

  uint64_t v26 = v39;
  uint64_t v27 = v40;
  __swift_project_boxed_opaque_existential_0Tm(v38, v39);
  uint64_t v28 = v7;
  uint64_t v29 = v34;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v27 + 152))(a2, a2, v35, v26, v27);
  uint64_t v22 = v11;
  uint64_t v24 = v41;
  if (!v29)
  {
    uint64_t v23 = v37;
    uint64_t v25 = v32;
    (*(void (**)(char *, char *, uint64_t))(v37 + 32))(v32, v28, a2);
    uint64_t v21 = 0LL;
    goto LABEL_8;
  }

  __swift_destroy_boxed_opaque_existential_1Tm(v38);
  uint64_t v5 = v33;
LABEL_2:
  uint64_t v18 = v5;
  return __swift_destroy_boxed_opaque_existential_1Tm(v18);
}

uint64_t protocol witness for Decodable.init(from:) in conformance <A> A?@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Optional<A>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a3 - 8), a4);
}

uint64_t Array<A>.encode(to:)(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v35 = a4;
  uint64_t v37 = *(a3 - 1);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v34 = (char *)&v30 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v30 - v9;
  uint64_t v31 = v11;
  uint64_t v12 = (void *)MEMORY[0x1895F8858](v8);
  uint64_t v36 = (char *)&v30 - v13;
  uint64_t v14 = v12[3];
  uint64_t v15 = v12[4];
  __swift_project_boxed_opaque_existential_0Tm(v12, v14);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v15 + 32))(v39, v14, v15);
  Swift::Int v33 = Array._getCount()();
  if (!v33) {
    return __swift_destroy_boxed_opaque_existential_1Tm(v39);
  }
  unint64_t v16 = 0LL;
  unint64_t v32 = a2 & 0xC000000000000001LL;
  uint64_t v17 = v37;
  uint64_t v18 = v34;
  while (1)
  {
    BOOL v19 = v32 == 0;
    char v20 = v19 | ~_swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v16, v20 & 1);
    if ((v20 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t, uint64_t *))(v17 + 16))( v10,  a2 + ((*(unsigned __int8 *)(v17 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v17 + 80))
      + *(void *)(v17 + 72) * v16,
        a3);
    }

    else
    {
      id v28 = _ArrayBuffer._getElementSlowPath(_:)(v16, a2, a3);
      uint64_t v21 = v28;
      if (v31 != 8) {
        goto LABEL_15;
      }
      id v42 = v28;
      (*(void (**)(char *, id *, uint64_t *))(v17 + 16))(v10, &v42, a3);
      swift_unknownObjectRelease(v21);
    }

    uint64_t v21 = *(void **)(v17 + 32);
    uint64_t v22 = v36;
    ((void (*)(char *, char *, uint64_t *))v21)(v36, v10, a3);
    unint64_t v23 = v16 + 1;
    if (__OFADD__(v16, 1LL))
    {
      __break(1u);
LABEL_15:
      swift_unknownObjectRelease(v21);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    ((void (*)(char *, char *, uint64_t *))v21)(v18, v22, a3);
    uint64_t v25 = v40;
    uint64_t v24 = v41;
    __swift_mutable_project_boxed_opaque_existential_1(v39, v40);
    uint64_t v26 = v25;
    uint64_t v17 = v37;
    uint64_t v27 = v38;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v24 + 160))(v18, a3, v35, v26, v24);
    (*(void (**)(char *, uint64_t *))(v17 + 8))(v18, a3);
    if (v27) {
      return __swift_destroy_boxed_opaque_existential_1Tm(v39);
    }
    uint64_t v38 = 0LL;
    ++v16;
    if (v23 == v33) {
      return __swift_destroy_boxed_opaque_existential_1Tm(v39);
    }
  }

uint64_t protocol witness for Encodable.encode(to:) in conformance <A> [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Array<A>.encode(to:)(a1, *v3, *(uint64_t **)(a2 + 16), *(void *)(a3 - 8));
}

__objc2_class **Array<A>.init(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v27[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = (uint64_t *)MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v27[-1] - v11;
  uint64_t v30 = &_swiftEmptyArrayStorage;
  uint64_t v13 = v10[3];
  uint64_t v14 = v10[4];
  uint64_t v26 = v10;
  uint64_t v15 = (__objc2_class **)__swift_project_boxed_opaque_existential_0Tm(v10, v13);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v27, v13, v14);
  if (v3)
  {
    swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
    __swift_destroy_boxed_opaque_existential_1Tm(v26);
  }

  else
  {
    uint64_t v16 = v28;
    uint64_t v17 = v29;
    __swift_project_boxed_opaque_existential_0Tm(v27, v28);
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v17 + 24))(v16, v17) & 1) != 0)
    {
      uint64_t v15 = &_swiftEmptyArrayStorage;
    }

    else
    {
      do
      {
        uint64_t v18 = v28;
        uint64_t v19 = v29;
        __swift_mutable_project_boxed_opaque_existential_1(v27, v28);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 176))(a2, a2, a3, v18, v19);
        (*(void (**)(char *, char *, uint64_t))(v6 + 32))(v9, v12, a2);
        uint64_t v22 = type metadata accessor for Array(0LL, a2, v20, v21);
        Array.append(_:)((uint64_t)v9, v22);
        uint64_t v23 = v28;
        uint64_t v24 = v29;
        __swift_project_boxed_opaque_existential_0Tm(v27, v28);
      }

      while (((*(uint64_t (**)(uint64_t, uint64_t))(v24 + 24))(v23, v24) & 1) == 0);
      uint64_t v15 = v30;
    }

    __swift_destroy_boxed_opaque_existential_1Tm(v27);
    __swift_destroy_boxed_opaque_existential_1Tm(v26);
  }

  return v15;
}

__objc2_class **protocol witness for Decodable.init(from:) in conformance <A> [A]@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, __objc2_class ***a4@<X8>)
{
  uint64_t result = Array<A>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a3 - 8));
  if (!v4) {
    *a4 = result;
  }
  return result;
}

uint64_t ContiguousArray<A>.encode(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = a4;
  uint64_t v27 = *(void *)(a3 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = (void *)MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v21 - v11;
  uint64_t v13 = v10[3];
  uint64_t v14 = v10[4];
  __swift_project_boxed_opaque_existential_0Tm(v10, v13);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v24, v13, v14);
  uint64_t v15 = *(void *)(a2 + 16);
  if (v15)
  {
    uint64_t v16 = a2 + ((*(unsigned __int8 *)(v27 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v27 + 80));
    uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(v27 + 16);
    uint64_t v21 = *(void *)(v27 + 72);
    uint64_t v22 = v17;
    while (1)
    {
      v22(v12, v16, a3);
      (*(void (**)(char *, char *, uint64_t))(v27 + 32))(v9, v12, a3);
      uint64_t v18 = v25;
      uint64_t v19 = v26;
      __swift_mutable_project_boxed_opaque_existential_1(v24, v25);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 160))(v9, a3, v23, v18, v19);
      if (v4) {
        break;
      }
      (*(void (**)(char *, uint64_t))(v27 + 8))(v9, a3);
      v16 += v21;
      if (!--v15) {
        return __swift_destroy_boxed_opaque_existential_1Tm(v24);
      }
    }

    (*(void (**)(char *, uint64_t))(v27 + 8))(v9, a3);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v24);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <A> ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ContiguousArray<A>.encode(to:)(a1, *v3, *(void *)(a2 + 16), *(void *)(a3 - 8));
}

__objc2_class **ContiguousArray<A>.init(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v27[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = (uint64_t *)MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v27[-1] - v11;
  uint64_t v30 = &_swiftEmptyArrayStorage;
  uint64_t v13 = v10[3];
  uint64_t v14 = v10[4];
  uint64_t v26 = v10;
  uint64_t v15 = (__objc2_class **)__swift_project_boxed_opaque_existential_0Tm(v10, v13);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v27, v13, v14);
  if (v3)
  {
    swift_release((uint64_t)&_swiftEmptyArrayStorage);
    __swift_destroy_boxed_opaque_existential_1Tm(v26);
  }

  else
  {
    uint64_t v16 = v28;
    uint64_t v17 = v29;
    __swift_project_boxed_opaque_existential_0Tm(v27, v28);
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v17 + 24))(v16, v17) & 1) != 0)
    {
      uint64_t v15 = &_swiftEmptyArrayStorage;
    }

    else
    {
      do
      {
        uint64_t v18 = v28;
        uint64_t v19 = v29;
        __swift_mutable_project_boxed_opaque_existential_1(v27, v28);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 176))(a2, a2, a3, v18, v19);
        (*(void (**)(char *, char *, uint64_t))(v6 + 32))(v9, v12, a2);
        uint64_t v22 = type metadata accessor for ContiguousArray(0LL, a2, v20, v21);
        ContiguousArray.append(_:)((uint64_t)v9, v22);
        uint64_t v23 = v28;
        uint64_t v24 = v29;
        __swift_project_boxed_opaque_existential_0Tm(v27, v28);
      }

      while (((*(uint64_t (**)(uint64_t, uint64_t))(v24 + 24))(v23, v24) & 1) == 0);
      uint64_t v15 = v30;
    }

    __swift_destroy_boxed_opaque_existential_1Tm(v27);
    __swift_destroy_boxed_opaque_existential_1Tm(v26);
  }

  return v15;
}

__objc2_class **protocol witness for Decodable.init(from:) in conformance <A> ContiguousArray<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, __objc2_class ***a4@<X8>)
{
  uint64_t result = ContiguousArray<A>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a3 - 8));
  if (!v4) {
    *a4 = result;
  }
  return result;
}

uint64_t Set<>.encode(to:)(void *a1, int64_t a2, char *a3, uint64_t a4)
{
  uint64_t v77 = a4;
  uint64_t v80 = *((void *)a3 - 1);
  MEMORY[0x1895F8858](a1);
  int64_t v76 = (char *)&v63 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = type metadata accessor for Optional(0LL, v9, v9, v10);
  uint64_t v65 = *(void *)(v11 - 8);
  uint64_t v66 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  unint64_t v64 = (char *)&v63 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v67 = (uint64_t *)((char *)&v63 - v15);
  MEMORY[0x1895F8858](v14);
  char v79 = (char *)&v63 - v16;
  uint64_t v17 = a1[3];
  uint64_t v18 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v17);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v18 + 32))(v81, v17, v18);
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v22 = a2;
    }
    else {
      uint64_t v22 = a2 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v23 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v24 = (unint64_t)swift_allocObject(v23, 0xE8uLL, 7uLL);
    int64_t v74 = 0LL;
    uint64_t v25 = 0LL;
    unint64_t v26 = 0LL;
    *(void *)(v24 + 208) = v22;
    *(void *)(v24 + 216) = 0LL;
    *(_OWORD *)(v24 + 16) = 0u;
    *(_OWORD *)(v24 + 32) = 0u;
    *(_OWORD *)(v24 + 48) = 0u;
    *(_OWORD *)(v24 + 64) = 0u;
    *(_OWORD *)(v24 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v24 + 96) = 0u;
    *(_OWORD *)(v24 + 112) = 0u;
    *(_OWORD *)(v24 + 128) = 0u;
    *(_OWORD *)(v24 + 144) = 0u;
    *(_OWORD *)(v24 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v24 + 176) = 0u;
    *(_OWORD *)(v24 + 192) = 0u;
    *(void *)(v24 + 224) = 0LL;
    unint64_t v27 = v24 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v28 = -1LL << *(_BYTE *)(a2 + 32);
    uint64_t v25 = ~v28;
    uint64_t v29 = *(void *)(a2 + 56);
    int64_t v74 = a2 + 56;
    uint64_t v30 = -v28;
    if (v30 < 64) {
      uint64_t v31 = ~(-1LL << v30);
    }
    else {
      uint64_t v31 = -1LL;
    }
    unint64_t v26 = v31 & v29;
    unint64_t v27 = a2;
  }

  uint64_t v73 = v27 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v69 = (v27 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v70 = (v27 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v68 = v25;
  int64_t v71 = (unint64_t)(v25 + 64) >> 6;
  swift_bridgeObjectRetain(a2, v19, v20, v21);
  int64_t v35 = 0LL;
  unint64_t v72 = (swift *)&unk_189B8D230;
  uint64_t v36 = v80;
  unint64_t v75 = v27;
  while (1)
  {
    unint64_t v43 = v26;
    int64_t v78 = v35;
    if ((v27 & 0x8000000000000000LL) == 0)
    {
      uint64_t v44 = v79;
      if (v26)
      {
        unint64_t v37 = __clz(__rbit64(v26));
        v26 &= v26 - 1;
        unint64_t v38 = v37 | (v35 << 6);
      }

      else
      {
        if (__OFADD__(v35++, 1LL))
        {
          __break(1u);
LABEL_46:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
        }

        if (v35 >= v71) {
          goto LABEL_39;
        }
        unint64_t v46 = *(void *)(v74 + 8 * v35);
        if (!v46)
        {
          int64_t v47 = v35 + 1;
          if (v35 + 1 >= v71) {
            goto LABEL_39;
          }
          unint64_t v46 = *(void *)(v74 + 8 * v47);
          if (!v46)
          {
            while (1)
            {
              int64_t v35 = v47 + 1;
              if (__OFADD__(v47, 1LL)) {
                break;
              }
              if (v35 >= v71) {
                goto LABEL_39;
              }
              unint64_t v46 = *(void *)(v74 + 8 * v35);
              ++v47;
              if (v46) {
                goto LABEL_25;
              }
            }

            __break(1u);
LABEL_43:
            __break(1u);
LABEL_44:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
          }

          ++v35;
        }

int64_t Set.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001LL) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v4 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0LL;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0LL;
    uint64_t result = v5 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v9 = -1LL;
    uint64_t v10 = -1LL << *(_BYTE *)(result + 32);
    int64_t v6 = result + 56;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1LL << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 56);
  }

  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0LL;
  a2[4] = v8;
  return result;
}

uint64_t Set.Iterator.next()@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v7 = *v5;
  if (*v5 < 0)
  {
    uint64_t v16 = *(char **)(result + 16);
    id v17 = __CocoaSet.Iterator.next()(result, a2, a3, a4);
    if (v17)
    {
      uint64_t v19 = v17;
      _forceBridgeFromObjectiveC<A>(_:_:)(v17, v16, v18, a5);
      swift_unknownObjectRelease(v19);
      uint64_t v20 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v16 - 1) + 56LL);
      uint64_t v21 = a5;
      uint64_t v22 = 0LL;
    }

    else
    {
      uint64_t v20 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v16 - 1) + 56LL);
      uint64_t v21 = a5;
      uint64_t v22 = 1LL;
    }

    return v20(v21, v22, 1LL, v16);
  }

  else
  {
    uint64_t v8 = v5[1];
    uint64_t v9 = v5[2];
    int64_t v11 = v5[3];
    unint64_t v10 = v5[4];
    if (v10)
    {
      uint64_t v12 = (v10 - 1) & v10;
      unint64_t v13 = __clz(__rbit64(v10)) | (v11 << 6);
LABEL_4:
      uint64_t v14 = *(void *)(result + 16);
      uint64_t v15 = *(void *)(v14 - 8);
      (*(void (**)(char *, unint64_t, uint64_t))(v15 + 16))( a5,  *(void *)(v7 + 48) + *(void *)(v15 + 72) * v13,  v14);
      uint64_t result = (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(a5, 0LL, 1LL, v14);
LABEL_19:
      *unint64_t v5 = v7;
      v5[1] = v8;
      v5[2] = v9;
      v5[3] = v11;
      v5[4] = v12;
      return result;
    }

    int64_t v23 = v11 + 1;
    if (!__OFADD__(v11, 1LL))
    {
      int64_t v24 = (unint64_t)(v9 + 64) >> 6;
      if (v23 < v24)
      {
        unint64_t v25 = *(void *)(v8 + 8 * v23);
        if (v25)
        {
LABEL_14:
          uint64_t v12 = (v25 - 1) & v25;
          unint64_t v13 = __clz(__rbit64(v25)) + (v23 << 6);
          int64_t v11 = v23;
          goto LABEL_4;
        }

        int64_t v26 = v11 + 2;
        while (v24 != v26)
        {
          unint64_t v25 = *(void *)(v8 + 8 * v26++);
          if (v25)
          {
            int64_t v23 = v26 - 1;
            goto LABEL_14;
          }
        }

        int64_t v11 = v24 - 1;
      }

      uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(result + 16) - 8LL) + 56LL))( a5,  1LL,  1LL);
      uint64_t v12 = 0LL;
      goto LABEL_19;
    }

    __break(1u);
  }

  return result;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> Set<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return Set<>.encode(to:)(a1, *v3, *(char **)(a2 + 16), *(void *)(a3 - 8));
}

__objc2_class **Set<>.init(from:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = a3;
  uint64_t v7 = *(void *)(a2 - 8);
  uint64_t v33 = a4;
  uint64_t v34 = v7;
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  unint64_t v10 = (id *)((char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v13 = (char *)&v31 - v12;
  uint64_t v14 = (void *)MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v31 - v15;
  uint64_t v39 = &_swiftEmptySetSingleton;
  uint64_t v17 = v14[3];
  uint64_t v18 = v14[4];
  uint64_t v19 = (__objc2_class **)__swift_project_boxed_opaque_existential_0Tm(v14, v17);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v18 + 32))(v36, v17, v18);
  if (v4)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }

  else
  {
    uint64_t v32 = a1;
    uint64_t v20 = v37;
    uint64_t v21 = v38;
    __swift_project_boxed_opaque_existential_0Tm(v36, v37);
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v21 + 24))(v20, v21) & 1) != 0)
    {
      uint64_t v19 = &_swiftEmptySetSingleton;
    }

    else
    {
      uint64_t v22 = v33;
      do
      {
        uint64_t v23 = v37;
        uint64_t v24 = v38;
        __swift_mutable_project_boxed_opaque_existential_1(v36, v37);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v24 + 176))(a2, a2, v35, v23, v24);
        uint64_t v25 = v34;
        (*(void (**)(id *, char *, uint64_t))(v34 + 32))(v10, v16, a2);
        uint64_t v27 = type metadata accessor for Set._Variant(0LL, a2, v22, v26);
        Set._Variant.insert(_:)(v13, v10, v27);
        (*(void (**)(char *, uint64_t))(v25 + 8))(v13, a2);
        uint64_t v28 = v37;
        uint64_t v29 = v38;
        __swift_project_boxed_opaque_existential_0Tm(v36, v37);
      }

      while (((*(uint64_t (**)(uint64_t, uint64_t))(v29 + 24))(v28, v29) & 1) == 0);
      uint64_t v19 = v39;
    }

    __swift_destroy_boxed_opaque_existential_1Tm(v36);
    __swift_destroy_boxed_opaque_existential_1Tm(v32);
  }

  return v19;
}

__objc2_class **Set.init()()
{
  return &_swiftEmptySetSingleton;
}

uint64_t Set.insert(_:)(char *a1, id *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for Set._Variant(0LL, *(void *)(a3 + 16), *(void *)(a3 + 24), a4);
  return Set._Variant.insert(_:)(a1, a2, v6);
}

__objc2_class **protocol witness for Decodable.init(from:) in conformance <> Set<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, __objc2_class ***a4@<X8>)
{
  uint64_t result = Set<>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a3 - 8), *(void *)(a2 + 24));
  if (!v4) {
    *a4 = result;
  }
  return result;
}

uint64_t FixedWidthInteger.init(_:)@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = (char *)a3;
  uint64_t v175 = a5;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v165 = (char *)&v159 - v10;
  uint64_t v179 = a4;
  uint64_t v169 = *(void *)(a4 + 8);
  uint64_t v11 = *(void *)(*(void *)(v169 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  (uint64_t)v6,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v159 - v14;
  uint64_t v182 = *((void *)v6 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  unint64_t v163 = (char *)&v159 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v159 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  unint64_t v168 = (char *)&v159 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v162 = (char *)&v159 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v159 - v26;
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  unint64_t v167 = (char *)&v159 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v164 = (char *)&v159 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v161 = (char *)&v159 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v159 - v35;
  MEMORY[0x1895F8858](v34);
  Swift::String::Index v166 = (char *)&v159 - v37;
  uint64_t v40 = type metadata accessor for Optional((const char *)0xFF, (uint64_t)v6, v38, v39);
  uint64_t v43 = type metadata accessor for Optional(0LL, v40, v41, v42);
  uint64_t v44 = *(void *)(v43 - 8);
  uint64_t v177 = v43;
  uint64_t v178 = v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  unint64_t v176 = (char *)&v159 - ((v46 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  unint64_t v180 = (char *)&v159 - v48;
  uint64_t v174 = v40;
  uint64_t v49 = *(void *)(v40 - 8);
  uint64_t v50 = MEMORY[0x1895F8858](v47);
  Swift::String::Index v171 = (char *)&v159 - ((v51 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  Swift::String::Index v172 = (char *)&v159 - v53;
  uint64_t v54 = (_BYTE *)MEMORY[0x1895F8858](v52);
  Swift::String::Index v173 = (char *)&v159 - v56;
  uint64_t v57 = HIBYTE(a2) & 0xF;
  uint64_t v181 = a1;
  uint64_t v58 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v59 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v59 = v58;
  }
  if (!v59)
  {
    swift_bridgeObjectRelease(a2);
    uint64_t v152 = v182;
    unint64_t v140 = v173;
    uint64_t v90 = v174;
    goto LABEL_54;
  }

  Swift::String::Index v170 = v6;
  if ((a2 & 0x1000000000000000LL) == 0)
  {
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      char v79 = v180;
      v183[0] = v181;
      v183[1] = a2 & 0xFFFFFFFFFFFFFFLL;
      specialized closure #1 in _parseInteger<A, B>(ascii:radix:)( (unsigned __int8 *)v183,  v57,  10LL,  (uint64_t)v6,  v179,  v180);
      uint64_t v90 = v174;
LABEL_47:
      unint64_t v140 = v173;
      unint64_t v141 = v171;
      uint64_t v107 = v176;
      uint64_t v108 = v177;
      uint64_t v78 = v178;
LABEL_48:
      (*(void (**)(char *, void, uint64_t, uint64_t))(v49 + 56))(v79, 0LL, 1LL, v90);
      goto LABEL_49;
    }

    uint64_t v160 = v49;
    if ((v181 & 0x1000000000000000LL) != 0)
    {
      uint64_t v60 = (_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (v58 > 0) {
        goto LABEL_9;
      }
    }

    else
    {
      uint64_t v54 = _StringObject.sharedUTF8.getter(v181, a2);
      uint64_t v60 = v54;
      uint64_t v58 = v57;
      if (v57 > 0)
      {
LABEL_9:
        int v61 = *v60;
        unint64_t v159 = a2;
        if (v61 == 43)
        {
          uint64_t v91 = specialized Collection.subscript.getter(1LL, (uint64_t)v60, v58);
          uint64_t v95 = specialized UnsafeBufferPointer.init(rebasing:)(v91, v92, v93, v94);
          if (!v96) {
            goto LABEL_64;
          }
          uint64_t v98 = (_BYTE *)v95;
          uint64_t v99 = v96;
          v183[0] = 10LL;
          uint64_t v100 = v169;
          unint64_t v101 = *(char **)(v169 + 96);
          unint64_t v102 = lazy protocol witness table accessor for type Int and conformance Int(v95, v96, v97);
          unint64_t v168 = v101;
          ((void (*)(void *, ValueMetadata *, unint64_t, char *, uint64_t))v101)( v183,  &type metadata for Int,  v102,  v6,  v100);
          unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  (uint64_t)v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
          uint64_t v104 = (*(uint64_t (**)(char *, char *, uint64_t))(v11 + 24))(v15, v6, v11);
          uint64_t v107 = v176;
          uint64_t v108 = v177;
          uint64_t v78 = v178;
          char v79 = v180;
          if (!v98)
          {
LABEL_27:
            uint64_t v118 = v182;
            (*(void (**)(char *, char *))(v182 + 8))(v167, v6);
            (*(void (**)(char *, char *, char *))(v118 + 32))(v79, v27, v6);
            (*(void (**)(char *, void, uint64_t, char *))(v118 + 56))(v79, 0LL, 1LL, v6);
LABEL_38:
            a2 = v159;
            unint64_t v140 = v173;
            uint64_t v90 = v174;
            uint64_t v49 = v160;
            unint64_t v141 = v171;
            goto LABEL_48;
          }

          int8x16_t v109 = v162;
          while (1)
          {
            if (*v98 - 48 >= 0xA)
            {
              uint64_t v142 = v79;
              uint64_t v143 = v182;
              unint64_t v144 = *(void (**)(char *, char *))(v182 + 8);
              v144(v27, v6);
              v144(v167, v6);
              uint64_t v145 = *(void (**)(char *, uint64_t, uint64_t, char *))(v143 + 56);
              char v79 = v142;
              v145(v142, 1LL, 1LL, v6);
              goto LABEL_38;
            }

            LOBYTE(v183[0]) = *v98 - 48;
            unint64_t v110 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v104, v105, v106);
            ((void (*)(void *, ValueMetadata *, unint64_t, char *, uint64_t))v168)( v183,  &type metadata for UInt8,  v110,  v6,  v169);
            uint64_t v111 = v179;
            uint16x8_t v112 = v164;
            LODWORD(v166) = (*(uint64_t (**)(char *, char *, char *, uint64_t))(v179 + 96))( v164,  v167,  v6,  v179);
            uint64_t v113 = v182;
            uint64_t v114 = *(void (**)(char *, char *))(v182 + 8);
            v114(v27, v6);
            uint64x2_t v115 = *(void (**)(char *, char *, char *))(v113 + 32);
            v115(v27, v112, v6);
            char v116 = (*(uint64_t (**)(char *, char *, char *, uint64_t))(v111 + 80))(v112, v109, v6, v111);
            v114(v109, v6);
            v114(v27, v6);
            uint64_t v117 = v165;
            v115(v165, v112, v6);
            uint64_t v104 = ((uint64_t (*)(char *, char *, char *))v115)(v27, v117, v6);
            ++v98;
            --v99;
            uint64_t v107 = v176;
            uint64_t v108 = v177;
            uint64_t v78 = v178;
            char v79 = v180;
            if (!v99) {
              goto LABEL_27;
            }
          }

          v114(v27, v6);
          uint64_t v146 = v167;
        }

        else
        {
          if (v61 == 45)
          {
            uint64_t v62 = specialized Collection.subscript.getter(1LL, (uint64_t)v60, v58);
            uint64_t v66 = specialized UnsafeBufferPointer.init(rebasing:)(v62, v63, v64, v65);
            if (v67)
            {
              uint64_t v69 = (_BYTE *)v66;
              uint64_t v70 = v67;
              v183[0] = 10LL;
              uint64_t v71 = v169;
              unint64_t v72 = *(char **)(v169 + 96);
              unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
              unint64_t v168 = v72;
              ((void (*)(void *, ValueMetadata *, unint64_t, char *, uint64_t))v72)( v183,  &type metadata for Int,  v73,  v6,  v71);
              unint64_t v74 = swift_getAssociatedConformanceWitness( v11,  (uint64_t)v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v74 + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  v74);
              uint64_t v75 = (*(uint64_t (**)(char *, char *, uint64_t))(v11 + 24))(v15, v6, v11);
              uint64_t v49 = v160;
              uint64_t v78 = v178;
              char v79 = v180;
              if (!v69)
              {
LABEL_18:
                uint64_t v89 = v182;
                (*(void (**)(char *, char *))(v182 + 8))(v166, v6);
                (*(void (**)(char *, char *, char *))(v89 + 32))(v79, v36, v6);
                (*(void (**)(char *, void, uint64_t, char *))(v89 + 56))(v79, 0LL, 1LL, v6);
LABEL_36:
                a2 = v159;
                unint64_t v140 = v173;
                uint64_t v90 = v174;
                unint64_t v141 = v171;
                uint64_t v107 = v176;
                uint64_t v108 = v177;
                goto LABEL_48;
              }

              uint64_t v80 = v161;
              while (1)
              {
                if (*v69 - 48 >= 0xA)
                {
                  uint64_t v136 = v79;
                  uint64_t v137 = v182;
                  unint64_t v138 = *(void (**)(char *, char *))(v182 + 8);
                  v138(v36, v6);
                  v138(v166, v6);
                  unsigned int v139 = *(void (**)(char *, uint64_t, uint64_t, char *))(v137 + 56);
                  char v79 = v136;
                  v139(v136, 1LL, 1LL, v6);
                  goto LABEL_36;
                }

                LOBYTE(v183[0]) = *v69 - 48;
                unint64_t v81 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v75, v76, v77);
                ((void (*)(void *, ValueMetadata *, unint64_t, char *, uint64_t))v168)( v183,  &type metadata for UInt8,  v81,  v6,  v169);
                uint64_t v82 = v179;
                uint64_t v83 = v164;
                LODWORD(v167) = (*(uint64_t (**)(char *, char *, char *, uint64_t))(v179 + 96))( v164,  v166,  v6,  v179);
                uint64_t v84 = v182;
                unint64_t v85 = *(void (**)(char *, char *))(v182 + 8);
                v85(v36, v6);
                uint64_t v86 = *(void (**)(char *, char *, char *))(v84 + 32);
                v86(v36, v83, v6);
                char v87 = (*(uint64_t (**)(char *, char *, char *, uint64_t))(v82 + 88))(v83, v80, v6, v82);
                v85(v80, v6);
                v85(v36, v6);
                unint64_t v88 = v165;
                v86(v165, v83, v6);
                uint64_t v75 = ((uint64_t (*)(char *, char *, char *))v86)(v36, v88, v6);
                ++v69;
                --v70;
                uint64_t v49 = v160;
                uint64_t v78 = v178;
                char v79 = v180;
                if (!v70) {
                  goto LABEL_18;
                }
              }

              v85(v36, v6);
              v85(v166, v6);
              goto LABEL_43;
            }

LABEL_64:
            char v79 = v180;
            (*(void (**)(char *, uint64_t, uint64_t, char *))(v182 + 56))(v180, 1LL, 1LL, v6);
LABEL_46:
            uint64_t v90 = v174;
            uint64_t v49 = v160;
            goto LABEL_47;
          }

          v183[0] = 10LL;
          uint64_t v119 = v169;
          uint64_t v120 = *(char **)(v169 + 96);
          unint64_t v121 = lazy protocol witness table accessor for type Int and conformance Int((uint64_t)v54, v57, v55);
          ((void (*)(void *, ValueMetadata *, unint64_t, char *, uint64_t))v120)( v183,  &type metadata for Int,  v121,  v6,  v119);
          unint64_t v122 = swift_getAssociatedConformanceWitness( v11,  (uint64_t)v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v122 + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  v122);
          uint64_t v123 = (*(uint64_t (**)(char *, char *, uint64_t))(v11 + 24))(v15, v6, v11);
          char v79 = v180;
          while (1)
          {
            if (*v60 - 48 >= 0xA)
            {
              uint64_t v134 = v182;
              unsigned int v135 = *(void (**)(char *, char *))(v182 + 8);
              v135(v20, v6);
              v135(v168, v6);
              (*(void (**)(char *, uint64_t, uint64_t, char *))(v134 + 56))(v79, 1LL, 1LL, v6);
              goto LABEL_45;
            }

            LOBYTE(v183[0]) = *v60 - 48;
            unint64_t v126 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v123, v124, v125);
            int8x8_t v127 = v163;
            Swift::String::Index v166 = v120;
            ((void (*)(void *, ValueMetadata *, unint64_t, char *, uint64_t))v120)( v183,  &type metadata for UInt8,  v126,  v6,  v169);
            uint64_t v128 = v179;
            int8x16_t v129 = v164;
            LODWORD(v167) = (*(uint64_t (**)(char *, char *, char *, uint64_t))(v179 + 96))( v164,  v168,  v6,  v179);
            uint64_t v130 = v182;
            uint64_t v114 = *(void (**)(char *, char *))(v182 + 8);
            v114(v20, v6);
            int8x16_t v131 = *(void (**)(char *, char *, char *))(v130 + 32);
            v131(v20, v129, v6);
            char v132 = (*(uint64_t (**)(char *, char *, char *, uint64_t))(v128 + 80))(v129, v127, v6, v128);
            v114(v127, v6);
            v114(v20, v6);
            uint64_t v133 = v165;
            v131(v165, v129, v6);
            uint64_t v123 = ((uint64_t (*)(char *, char *, char *))v131)(v20, v133, v6);
            ++v60;
            --v58;
            char v79 = v180;
            uint64_t v120 = v166;
            if (!v58)
            {
              v114(v168, v6);
              v131(v79, v20, v6);
              (*(void (**)(char *, void, uint64_t, char *))(v182 + 56))(v79, 0LL, 1LL, v6);
              goto LABEL_45;
            }
          }

          v114(v20, v6);
          uint64_t v146 = v168;
        }

        v114(v146, v6);
LABEL_43:
        char v79 = v180;
        (*(void (**)(char *, uint64_t, uint64_t, char *))(v182 + 56))(v180, 1LL, 1LL, v6);
LABEL_45:
        a2 = v159;
        goto LABEL_46;
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  char v79 = v180;
  uint64_t v90 = v174;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v49 + 56))(v180, 1LL, 1LL, v174);
  unint64_t v140 = v173;
  unint64_t v141 = v171;
  uint64_t v107 = v176;
  uint64_t v108 = v177;
  uint64_t v78 = v178;
LABEL_49:
  unint64_t v147 = v79;
  uint64_t v148 = v78;
  (*(void (**)(char *, char *, uint64_t))(v78 + 32))(v107, v147, v108);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v49 + 48))(v107, 1LL, v90) == 1)
  {
    uint64_t v149 = v172;
    uint64_t v6 = v170;
    specialized _parseInteger<A, B>(ascii:radix:)(v181, a2, 10LL, v170, v179, v172);
    swift_bridgeObjectRelease(a2);
    (*(void (**)(char *, uint64_t))(v148 + 8))(v107, v108);
    (*(void (**)(char *, char *, uint64_t))(v49 + 32))(v141, v149, v90);
  }

  else
  {
    swift_bridgeObjectRelease(a2);
    Swift::Int v150 = *(void (**)(char *, char *, uint64_t))(v49 + 32);
    uint64_t v151 = v172;
    v150(v172, v107, v90);
    uint64_t v6 = v170;
    v150(v141, v151, v90);
  }

  uint64_t v152 = v182;
  Swift::Int v153 = *(unsigned int (**)(char *, uint64_t, char *))(v182 + 48);
  if (v153(v141, 1LL, v6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v49 + 8))(v141, v90);
LABEL_54:
    uint64_t v154 = *(void (**)(char *, uint64_t, uint64_t, char *))(v152 + 56);
    v154(v140, 1LL, 1LL, v6);
    unsigned int v155 = (*(uint64_t (**)(char *, uint64_t, char *))(v152 + 48))(v140, 1LL, v6);
    goto LABEL_56;
  }

  (*(void (**)(char *, char *, char *))(v152 + 32))(v140, v141, v6);
  uint64_t v154 = *(void (**)(char *, uint64_t, uint64_t, char *))(v152 + 56);
  v154(v140, 0LL, 1LL, v6);
  unsigned int v155 = v153(v140, 1LL, v6);
LABEL_56:
  if (v155)
  {
    (*(void (**)(char *, uint64_t))(v49 + 8))(v140, v90);
    uint64_t v156 = 1LL;
    uint64_t v157 = v175;
  }

  else
  {
    uint64_t v157 = v175;
    (*(void (**)(uint64_t, char *, char *))(v152 + 32))(v175, v140, v6);
    uint64_t v156 = 0LL;
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, char *))v154)(v157, v156, 1LL, v6);
}

        uint64_t v40 = (v62 - 1) & v62;
        uint64_t v53 = __clz(__rbit64(v62)) + (v50 << 6);
      }

      (*(void (**)(char *, unint64_t, char *))(v8 + 16))( v27,  *(void *)(v41 + 48) + *(void *)(v8 + 72) * v53,  a3);
      uint64_t v60 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
      goto LABEL_66;
    }

    uint64_t v54 = (void *)v90;
    uint64_t v55 = *(void *)(v90 + 216);
    if (v55 < 0) {
      goto LABEL_85;
    }
    if (v55 == *(void *)(v90 + 224)) {
      break;
    }
LABEL_45:
    uint64_t v57 = v54[3];
    if (!v57) {
      goto LABEL_91;
    }
    if ((unint64_t)(v55 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_88:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    uint64_t v58 = (void **)(v57 + 8 * v55);
    uint64_t v59 = *v58;
    v54[27] = v55 + 1;
    swift_unknownObjectRetain(v59, v47, v48, v49);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      uint64_t v99 = v59;
      swift_dynamicCast(v27, (uint64_t *)&v99, v89, a3, 7uLL);
      uint64_t v60 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
    }

    else
    {
      uint64_t v60 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
      uint64_t v75 = v86;
      v60(v86, 1LL, 1LL, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v59, (uint64_t)a3, v75);
      swift_unknownObjectRelease(v59);
      uint64_t v77 = v82;
      uint64_t v76 = v83;
      uint64_t v78 = v84;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(v83 + 16))(v82, v86, v84);
      if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(v8 + 48))(v77, 1LL, a3) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v76 + 8))(v86, v78);
      (*(void (**)(char *, uint64_t, char *))(v8 + 32))(v27, v77, a3);
      uint64_t v50 = v97;
    }

    uint64_t v40 = v51;
LABEL_66:
    v60((uint64_t *)v27, 0LL, 1LL, a3);
    uint64_t v64 = *(void (**)(id *, char *, char *))(v8 + 32);
    v64(v13, v27, a3);
    if (v98)
    {
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
      {
        if (v95 != 8) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }
        uint64_t v68 = *v13;
        swift_unknownObjectRetain(*v13, v65, v66, v67);
        (*(void (**)(id *, char *))(v8 + 8))(v13, a3);
      }

      else
      {
        unint64_t v72 = v85;
        v64(v85, (char *)v13, a3);
        uint64_t v68 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v72, (uint64_t *)a3, v73, v74);
      }

      uint64_t v69 = objc_msgSend(v93, sel_objectForKey_, v68, v81);
      swift_unknownObjectRelease(v68);
      if (!v69)
      {
        char v79 = v96;
        goto LABEL_81;
      }

      swift_unknownObjectRelease(v69);
      uint64_t v41 = v96;
    }

    else
    {
      uint64_t v41 = v96;
      if (!*(void *)(a2 + 16))
      {
        outlined consume of [A : B].Iterator._Variant<A, B>(v96);
        (*(void (**)(id *, char *))(v8 + 8))(v13, a3);
        return 0LL;
      }

      __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, (uint64_t)a3, v94);
      uint64_t v71 = v70;
      (*(void (**)(id *, char *))(v8 + 8))(v13, a3);
      if ((v71 & 1) == 0)
      {
        char v79 = v41;
LABEL_81:
        outlined consume of [A : B].Iterator._Variant<A, B>(v79);
        return 0LL;
      }
    }
  }

  uint64_t v56 = objc_msgSend(*(id *)(v90 + 208), sel_countByEnumeratingWithState_objects_count_, v88, v87, 16, v81);
  v54[28] = v56;
  if (v56)
  {
    uint64_t v55 = 0LL;
    v54[27] = 0LL;
    goto LABEL_45;
  }

  v54[27] = -1LL;
LABEL_85:
  uint64_t v29 = 1LL;
  (*(void (**)(char *, uint64_t, uint64_t, char *))(v8 + 56))(v27, 1LL, 1LL, a3);
  outlined consume of [A : B].Iterator._Variant<A, B>(v41);
  return v29;
}

                  uint64_t v59 = HIBYTE(v51) & 0xF;
                  uint64_t v60 = HIBYTE(v58) & 0xF;
                  int v61 = v60 + v59;
                  if ((unint64_t)(v60 + v59) <= 0xF)
                  {
                    if (v60)
                    {
                      uint64_t v62 = 0;
                      uint64_t v63 = 0LL;
                      do
                      {
                        uint64_t v64 = v59 + v63;
                        uint64_t v65 = v63 + 1;
                        if (v63 >= 8) {
                          uint64_t v66 = v58;
                        }
                        else {
                          uint64_t v66 = v56;
                        }
                        uint64_t v67 = v66 >> (v62 & 0x38);
                        uint64_t v68 = (8 * v59 + v62) & 0x38;
                        uint64_t v69 = (-255LL << v68) - 1;
                        uint64_t v70 = (unint64_t)v67 << v68;
                        uint64_t v71 = v70 | v69 & v51;
                        unint64_t v72 = v70 | v69 & v10;
                        if (v64 < 8) {
                          uint64_t v10 = v72;
                        }
                        else {
                          uint64_t v51 = v71;
                        }
                        v62 += 8;
                        uint64_t v63 = v65;
                      }

                      while (v60 != v65);
                    }

                    swift_bridgeObjectRelease(object);
                    swift_bridgeObjectRelease(0xE700000000000000LL);
                    unint64_t v73 = 0xA000000000000000LL;
                    if (!(v10 & 0x8080808080808080LL | v51 & 0x80808080808080LL)) {
                      unint64_t v73 = 0xE000000000000000LL;
                    }
                    uint64_t v40 = (void *)(v73 & 0xFF00000000000000LL | (v61 << 56) | v51 & 0xFFFFFFFFFFFFFFLL);
                    goto LABEL_77;
                  }

    unint64_t v188 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
    unint64_t v189 = lazy protocol witness table accessor for type Int and conformance Int(v165, v166, v167);
    v188(&v289, &type metadata for Int, v189, v77, v67);
    uint64_t v164 = v285;
    unint64_t v190 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v285,  v82,  v77);
    ((void (*)(char *, uint64_t))v286)(v82, v77);
    if ((v190 & 1) == 0) {
      goto LABEL_73;
    }
    goto LABEL_85;
  }

  uint64_t v164 = v285;
  uint64_t v165 = v254(v77, v67);
  uint64_t v65 = v252;
  if (v165 >= 64) {
    goto LABEL_64;
  }
  (*(void (**)(char *, char *, uint64_t))(v83 + 16))(v82, v164, v77);
LABEL_68:
  uint64_t v192 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
  ((void (*)(char *, uint64_t))v286)(v82, v77);
  if (v192 < v289) {
    goto LABEL_85;
  }
LABEL_73:
  char v282 = (*(uint64_t (**)(swift *, uint64_t))(v62 + 136))(a2, v62);
  uint64_t v200 = v164;
  unint64_t v201 = v280;
  (*(void (**)(char *, char *, uint64_t))(v83 + 32))(v280, v200, v77);
  size_t v202 = v253((unint64_t *)v77, v67);
  unint64_t v203 = v266;
  unint64_t v285 = *(char **)(v83 + 16);
  ((void (*)(char *, char *, uint64_t))v285)(v266, v201, v77);
  if ((v202 & 1) == 0) {
    goto LABEL_91;
  }
  uint64_t v204 = v254;
  size_t v205 = v254(v77, v67);
  ((void (*)(char *, uint64_t))v286)(v203, v77);
  if (v205 <= 64) {
    goto LABEL_92;
  }
  unint64_t v203 = v259;
  ((void (*)(char *, char *, uint64_t))v285)(v259, v280, v77);
  unint64_t v289 = 0x8000000000000000LL;
  Swift::String v206 = (uint64_t (*)(uint64_t, uint64_t))v253;
  if ((v253((unint64_t *)v77, v67) & 1) != 0)
  {
    unint64_t v207 = v254(v77, v67);
    if (v207 >= 64)
    {
      unint64_t v266 = (char *)v64;
      unint64_t v210 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
      uint64_t v211 = lazy protocol witness table accessor for type Int and conformance Int(v207, v208, v209);
      unint64_t v212 = v283;
      v210(&v289, &type metadata for Int, v211, v77, v67);
      uint64_t v64 = (void (*)(char *, uint64_t, swift *))v266;
      uint64_t v213 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v203,  v212,  v77);
      ((void (*)(char *, uint64_t))v286)(v212, v77);
      if ((v213 & 1) != 0) {
        goto LABEL_111;
      }
      goto LABEL_91;
    }

  a1->_Swift::UInt64 rawBits = a4._rawBits;
  a1[1]._Swift::UInt64 rawBits = a5;
  a1[2]._Swift::UInt64 rawBits = a6;
  a1[3]._Swift::UInt64 rawBits = a7;
  a1[4]._Swift::UInt64 rawBits = rawBits;
  return v12;
}

    uint64_t v50 = v18;
    uint64_t v37 = v19;
    uint64_t v22 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v23);
    uint64_t v19 = v37;
    uint64_t v18 = v50;
    goto LABEL_40;
  }

  return v11;
}

  *(_OWORD *)(a1 + 16) = *(_OWORD *)&v16->initializeBufferWithCopyOfBuffer;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v16->initializeWithCopy;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)&v16->initializeWithTake;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v16->getEnumTagSinglePayload;
  if ((v13 & 1) != 0)
  {
    uint64_t v32 = 4;
    *(_BYTE *)(a2 + 17) = 4;
    goto LABEL_109;
  }

  if (v11)
  {
    uint64_t v32 = 3;
    *(_BYTE *)(a2 + 17) = 3;
    uint64_t v70 = 1LL;
    goto LABEL_72;
  }

  uint64_t v37 = v22[2];
  if ((_DWORD)v120 != (_DWORD)v37)
  {
    if (a3 < 0) {
      goto LABEL_162;
    }
    uint64_t v42 = *(unsigned int *)(a6 + 8);
    uint64_t v43 = operator new(0x30uLL);
    *uint64_t v43 = a1;
    v43[1] = v108;
    v43[2] = a3;
    v43[3] = a4;
    v43[4] = v42;
    *((_DWORD *)v43 + 1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = v37;
    uint64_t v44 = swift::TypeLookupError::TypeLookupError<_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_2>(_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_2 const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
    goto LABEL_154;
  }

  uint64_t v38 = (uint64_t)(v22 + 6);
  if ((v22[5] & 1) == 0 || (uint64_t v39 = (_WORD *)(((v38 + v37 + 3) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v22[3]), !*v39))
  {
    uint64_t v40 = 0LL;
    if (!v22[2]) {
      goto LABEL_68;
    }
LABEL_72:
    uint64_t v104 = v22;
    uint64_t v105 = a4;
    uint64_t v106 = a8;
    uint64_t v45 = 0LL;
    uint64_t v46 = 0;
    uint64_t v47 = (const void *)(a6 + 16);
    while (1)
    {
      uint64_t v48 = v119[v45];
      uint64_t v49 = *(char *)(v38 + v45);
      if ((*(_BYTE *)(v38 + v45) & 0x3F) == 1)
      {
        if ((v48 & 1) == 0)
        {
          if (a3 < 0) {
            goto LABEL_162;
          }
          uint64_t v43 = operator new(0x28uLL);
          *uint64_t v43 = a1;
          v43[1] = v108;
          v43[2] = a3;
          v43[3] = v105;
          *((_DWORD *)v43 + 8) = v45;
          uint64_t v44 = swift::TypeLookupError::TypeLookupError<_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_4>(_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_4 const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
LABEL_117:
          a8 = v106;
          goto LABEL_154;
        }

        if (v49 < 0)
        {
          uint64_t v52 = *(unsigned int *)(a6 + 8);
          if (v52 >= *(unsigned int *)(a6 + 12))
          {
            uint64_t v53 = v47;
            unint64_t v102 = v40;
            __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v47, v52 + 1, 8LL);
            uint64_t v47 = v53;
            uint64_t v40 = v102;
            uint64_t v52 = *(unsigned int *)(a6 + 8);
          }

          *(void *)(*(void *)a6 + 8 * v52) = v48;
          ++*(_DWORD *)(a6 + 8);
          ++v46;
        }
      }

      else
      {
        if ((*(_BYTE *)(v38 + v45) & 0x3F) != 0)
        {
          if ((a3 & 0x8000000000000000LL) == 0)
          {
            uint64_t v43 = operator new(0x28uLL);
            *uint64_t v43 = a1;
            v43[1] = v108;
            v43[2] = a3;
            v43[3] = v105;
            *((_DWORD *)v43 + 8) = v45;
            *((_BYTE *)v43 + 36) = v49;
            uint64_t v44 = swift::TypeLookupError::TypeLookupError<_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_5>(_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_5 const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
            goto LABEL_117;
          }

          goto LABEL_162;
        }

        if (v48) {
          uint64_t v50 = (v119[v45] & 1LL) == 0;
        }
        else {
          uint64_t v50 = 0;
        }
        if (!v50)
        {
          if ((a3 & 0x8000000000000000LL) == 0)
          {
            uint64_t v43 = operator new(0x28uLL);
            *uint64_t v43 = a1;
            v43[1] = v108;
            v43[2] = a3;
            v43[3] = v105;
            *((_DWORD *)v43 + 8) = v45;
            uint64_t v44 = swift::TypeLookupError::TypeLookupError<_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_3>(_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_3 const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
            goto LABEL_117;
          }

              if (!result) {
                return result;
              }
LABEL_65:
              uint64_t v64 = (swift::Demangle::__runtime::Node *)result;
              uint64_t v53 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*((void **)this + 5), 232);
              swift::Demangle::__runtime::Node::addChild( v53,  v64,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v65,  v66);
              if (!v53) {
                return 0LL;
              }
              goto LABEL_66;
            }

            uint64_t v92 = -1LL;
            uint64_t v93 = -1LL;
            *((void *)this + 3) = v49 + 1;
            *((void *)this + 4) = v48 - 1;
            if (v48 == 1)
            {
              uint64_t v62 = v3;
LABEL_99:
              int v61 = 0LL;
LABEL_100:
              uint64_t v3 = v62;
              if (!v61) {
                return 0LL;
              }
              goto LABEL_101;
            }

            int v61 = 0LL;
            uint64_t v62 = v3;
            uint64_t v63 = "U";
            switch(v49[1])
            {
              case 'B':
                uint64_t v63 = "B";
                goto LABEL_85;
              case 'C':
              case 'D':
              case 'F':
              case 'G':
              case 'H':
              case 'I':
              case 'J':
              case 'K':
              case 'L':
              case 'O':
              case 'P':
              case 'Q':
              case 'V':
              case 'W':
              case 'X':
              case 'Y':
              case 'Z':
              case '[':
              case '\\':
              case ']':
              case '^':
              case '_':
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'f':
              case 'g':
              case 'h':
              case 'i':
              case 'j':
              case 'k':
              case 'l':
                goto LABEL_100;
              case 'E':
                *((void *)this + 3) = v49 + 2;
                *((void *)this + 4) = v48 - 2;
                uint64_t v71 = *((void *)this + 4);
                if (!v71) {
                  goto LABEL_99;
                }
                unint64_t v72 = (_BYTE *)*((void *)this + 3);
                if (*v72 != 95) {
                  goto LABEL_99;
                }
                *((void *)this + 3) = v72 + 1;
                *((void *)this + 4) = v71 - 1;
                uint64_t v63 = "E";
                break;
              case 'M':
                *((void *)this + 3) = v49 + 2;
                *((void *)this + 4) = v48 - 2;
                unint64_t v73 = *((void *)this + 4);
                if (!v73) {
                  goto LABEL_99;
                }
                unint64_t v74 = (_BYTE *)*((void *)this + 3);
                if (*v74 != 95) {
                  goto LABEL_99;
                }
                *((void *)this + 3) = v74 + 1;
                *((void *)this + 4) = v73 - 1;
                uint64_t v63 = "M";
                break;
              case 'N':
                uint64_t v63 = "N";
                goto LABEL_85;
              case 'R':
                uint64_t v63 = "R";
                goto LABEL_85;
              case 'S':
                *((void *)this + 3) = v49 + 2;
                *((void *)this + 4) = v48 - 2;
                uint64_t v63 = "S";
                  goto LABEL_99;
                break;
              case 'T':
                uint64_t v63 = "T";
                goto LABEL_85;
              case 'U':
LABEL_85:
                *((void *)this + 3) = v49 + 2;
                *((void *)this + 4) = v48 - 2;
                break;
              case 'e':
                *((void *)this + 3) = v49 + 2;
                *((void *)this + 4) = v48 - 2;
                uint64_t v63 = "e";
                  goto LABEL_99;
                break;
              case 'm':
                *((void *)this + 3) = v49 + 2;
                *((void *)this + 4) = v48 - 2;
                uint64_t v63 = "m";
                  goto LABEL_99;
                break;
              default:
                return 0LL;
            }

            uint64_t v75 = (void *)*((void *)this + 5);
            uint64_t v76 = (char *)v75[1];
            if (!v76 || (unint64_t)(v76 + 1) > v75[2])
            {
              uint64_t v77 = 2LL * v75[4];
              if (v77 <= 2) {
                uint64_t v77 = 2LL;
              }
              v75[4] = v77;
              uint64_t v78 = v77 + 8;
              char v79 = malloc(v77 + 8);
              char *v79 = v75[3];
              uint64_t v76 = (char *)(v79 + 1);
              v75[2] = (char *)v79 + v78;
              v75[3] = v79;
            }

            v75[1] = v76 + 1;
            *uint64_t v76 = *v63;
            NodeWithAllocatedText = swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v75,  101,  (uint64_t)v76,  1LL);
            if (!NodeWithAllocatedText) {
              goto LABEL_99;
            }
            unint64_t v81 = (swift::Demangle::__runtime::Node *)NodeWithAllocatedText;
            int v61 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*((void **)this + 5), 41);
            swift::Demangle::__runtime::Node::addChild( v61,  (swift::Demangle::__runtime::Node *)v43,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v82,  v83);
            swift::Demangle::__runtime::Node::addChild( v61,  v81,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v84,  v85);
            if (v93 == -1LL) {
              goto LABEL_100;
            }
            uint64_t v86 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( *((void **)this + 5),  161,  v93);
            swift::Demangle::__runtime::Node::addChild( v61,  v86,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v87,  v88);
            if (v92 == -1) {
              goto LABEL_100;
            }
            uint64_t v89 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( *((void **)this + 5),  161,  v92);
            swift::Demangle::__runtime::Node::addChild( v61,  v89,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v90,  v91);
            uint64_t v3 = v62;
            if (!v61) {
              return 0LL;
            }
LABEL_101:
            swift::Demangle::__runtime::Node::addChild( v10,  (swift::Demangle::__runtime::Node *)v61,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v46,  v47);
            uint64_t v9 = *((void *)this + 4);
            if (!v9) {
              goto LABEL_42;
            }
LABEL_29:
            uint64_t v27 = (unsigned __int8 *)*((void *)this + 3);
            uint64_t v31 = *v27;
            switch(v31)
            {
              case 'W':
                *((void *)this + 3) = v27 + 1;
                *((void *)this + 4) = v9 - 1;
                if (!result) {
                  return result;
                }
                uint64_t v33 = (swift::Demangle::__runtime::Node *)result;
                while (1)
                {
                  uint64_t v37 = *((void *)this + 4);
                  if (v37)
                  {
                    uint64_t v38 = (_BYTE *)*((void *)this + 3);
                    if (*v38 == 95) {
                      break;
                    }
                  }

                  uint64_t v34 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*((void **)this + 5), 232);
                  swift::Demangle::__runtime::Node::addChild( v34,  v33,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v35,  v36);
                  uint64_t result = 0LL;
                  if (!v33) {
                    return result;
                  }
                }

                *((void *)this + 3) = v38 + 1;
                *((void *)this + 4) = v37 - 1;
                break;
              case 'w':
                *((void *)this + 3) = v27 + 1;
                *((void *)this + 4) = v9 - 1;
                if (!result) {
                  return result;
                }
                uint64_t v39 = (swift::Demangle::__runtime::Node *)result;
                uint64_t v40 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*((void **)this + 5), 232);
                swift::Demangle::__runtime::Node::addChild( v40,  v39,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v41,  v42);
                if (!v33) {
                  return 0LL;
                }
                break;
              case 'r':
                goto LABEL_105;
              default:
                goto LABEL_42;
            }
          }

          if (v50 == 67)
          {
            if (!result) {
              return result;
            }
            goto LABEL_65;
          }

          if (v50 != 83) {
            goto LABEL_64;
          }
          *((void *)this + 3) = v49 + 1;
          *((void *)this + 4) = v48 - 1;
          if (!result) {
            return result;
          }
          uint64_t v51 = (swift::Demangle::__runtime::Node *)result;
          uint64_t v52 = result[8];
          if (v52 != 24 && v52 != 180)
          {
            if (v52 != 153) {
              return 0LL;
            }
            uint64_t v51 = (swift::Demangle::__runtime::Node *)result;
            if (!result) {
              return result;
            }
          }

          uint64_t v53 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*((void **)this + 5), 232);
          swift::Demangle::__runtime::Node::addChild( v53,  v51,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v54,  v55);
LABEL_66:
          uint64_t v59 = (void *)*((void *)this + 5);
          uint64_t v60 = 36;
LABEL_67:
          int v61 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(v59, v60);
          swift::Demangle::__runtime::Node::addChild( v61,  (swift::Demangle::__runtime::Node *)v43,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v67,  v68);
          swift::Demangle::__runtime::Node::addChild( v61,  (swift::Demangle::__runtime::Node *)v53,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v69,  v70);
          if (!v61) {
            return 0LL;
          }
          goto LABEL_101;
        }
      }
    }
  }

  return 0LL;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance _DictionaryCodingKey@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result = specialized _DictionaryCodingKey.init(stringValue:)(a1, a2, a3, a4);
  *(void *)a5 = result;
  *(void *)(a5 + 8) = v7;
  *(void *)(a5 + 16) = v9;
  *(_BYTE *)(a5 + 24) = v8 & 1;
  return result;
}

unint64_t protocol witness for CodingKey.init(intValue:) in conformance _DictionaryCodingKey@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = specialized _DictionaryCodingKey.init(intValue:)(a1);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 16) = v6;
  *(_BYTE *)(a2 + 24) = v5 & 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _DictionaryCodingKey()
{
  return specialized CodingKey.description.getter( *(void *)v0,  *(void *)(v0 + 8),  *(void *)(v0 + 16),  *(_BYTE *)(v0 + 24));
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance _DictionaryCodingKey( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance _GenericIndexKey( a1,  a2,  (uint64_t (*)(void, void, void, void))specialized CodingKey.description.getter);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance _GenericIndexKey( uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, void))
{
  return a3(*(void *)v3, *(void *)(v3 + 8), *(void *)(v3 + 16), *(unsigned __int8 *)(v3 + 24));
}

void *RawRepresentable<>.codingKey.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, void *a3@<X8>)
{
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a2 + 24))(v14, a1, a2);
  uint64_t v6 = specialized _DictionaryCodingKey.init(stringValue:)(v14[0], v14[1], v4, v5);
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  char v12 = v11;
  a3[3] = &type metadata for _DictionaryCodingKey;
  a3[4] = &protocol witness table for _DictionaryCodingKey;
  unint64_t result = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
  *a3 = result;
  result[2] = v6;
  result[3] = v8;
  result[4] = v10;
  *((_BYTE *)result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = v12 & 1;
  return result;
}

{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  char v10;
  void *result;
  uint64_t v12;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a2 + 24))(&v12, a1, a2);
  uint64_t v4 = specialized _DictionaryCodingKey.init(intValue:)(v12);
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  a3[3] = &type metadata for _DictionaryCodingKey;
  a3[4] = &protocol witness table for _DictionaryCodingKey;
  unint64_t result = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
  *a3 = result;
  result[2] = v4;
  result[3] = v6;
  result[4] = v8;
  *((_BYTE *)result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = v10 & 1;
  return result;
}

uint64_t RawRepresentable<>.init<A>(codingKey:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v25 = a7;
  uint64_t v12 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v24 - v14;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 24))(a3, a6);
  uint64_t v18 = v17;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  v26[0] = v16;
  v26[1] = v18;
  (*(void (**)(void *, uint64_t, uint64_t))(a5 + 16))(v26, a2, a5);
  uint64_t v19 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v15, 1LL, a2))
  {
    (*(void (**)(char *, uint64_t))(v13 + 8))(v15, v12);
    uint64_t v20 = 1LL;
    uint64_t v21 = v25;
  }

  else
  {
    uint64_t v22 = v25;
    (*(void (**)(uint64_t, char *, uint64_t))(v19 + 32))(v25, v15, a2);
    uint64_t v20 = 0LL;
    uint64_t v21 = v22;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 56))(v21, v20, 1LL, a2);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v22 = a7;
  uint64_t v12 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v22 - v14;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 40))(a3, a6);
  LOBYTE(a6) = v17;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  if ((a6 & 1) != 0)
  {
    uint64_t v18 = *(void *)(a2 - 8);
  }

  else
  {
    uint64_t v23 = v16;
    (*(void (**)(uint64_t *, uint64_t, uint64_t))(a5 + 16))(&v23, a2, a5);
    uint64_t v18 = *(void *)(a2 - 8);
    if (!(*(unsigned int (**)(char *, uint64_t, uint64_t))(v18 + 48))(v15, 1LL, a2))
    {
      uint64_t v20 = v22;
      (*(void (**)(uint64_t, char *, uint64_t))(v18 + 32))(v22, v15, a2);
      uint64_t v19 = 0LL;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 56))(v20, v19, 1LL, a2);
    }

    (*(void (**)(char *, uint64_t))(v13 + 8))(v15, v12);
  }

  uint64_t v19 = 1LL;
  uint64_t v20 = v22;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 56))(v20, v19, 1LL, a2);
}

void *Int.codingKey.getter@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = specialized _DictionaryCodingKey.init(intValue:)(a1);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  char v9 = v8;
  a2[3] = &type metadata for _DictionaryCodingKey;
  a2[4] = &protocol witness table for _DictionaryCodingKey;
  unint64_t result = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
  *a2 = result;
  result[2] = v3;
  result[3] = v5;
  result[4] = v7;
  *((_BYTE *)result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = v9 & 1;
  return result;
}

uint64_t Int.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = specialized Int.init<A>(codingKey:)(a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v5;
}

void *protocol witness for CodingKeyRepresentable.codingKey.getter in conformance Int@<X0>( void *a1@<X8>)
{
  unint64_t v3 = specialized _DictionaryCodingKey.init(intValue:)(*v1);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  char v9 = v8;
  a1[3] = &type metadata for _DictionaryCodingKey;
  a1[4] = &protocol witness table for _DictionaryCodingKey;
  unint64_t result = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
  *a1 = result;
  result[2] = v3;
  result[3] = v5;
  result[4] = v7;
  *((_BYTE *)result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = v9 & 1;
  return result;
}

uint64_t protocol witness for CodingKeyRepresentable.init<A>(codingKey:) in conformance Int@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = specialized Int.init<A>(codingKey:)(a1, a2, a3);
  char v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *(void *)a4 = v7;
  *(_BYTE *)(a4 + 8) = v9 & 1;
  return result;
}

void *String.codingKey.getter@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = specialized _DictionaryCodingKey.init(stringValue:)(a1, a2, v8, v9);
  uint64_t v12 = v11;
  uint64_t v14 = v13;
  char v16 = v15;
  a5[3] = &type metadata for _DictionaryCodingKey;
  a5[4] = &protocol witness table for _DictionaryCodingKey;
  uint64_t result = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
  *a5 = result;
  result[2] = v10;
  result[3] = v12;
  result[4] = v14;
  *((_BYTE *)result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = v16 & 1;
  return result;
}

uint64_t String.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = specialized String.init<A>(codingKey:)(a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v5;
}

void *protocol witness for CodingKeyRepresentable.codingKey.getter in conformance String@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, void *a4@<X8>)
{
  uint64_t v7 = *v4;
  unint64_t v6 = v4[1];
  swift_bridgeObjectRetain(v6, a1, a2, a3);
  uint64_t v10 = specialized _DictionaryCodingKey.init(stringValue:)(v7, v6, v8, v9);
  uint64_t v12 = v11;
  uint64_t v14 = v13;
  char v16 = v15;
  a4[3] = &type metadata for _DictionaryCodingKey;
  a4[4] = &protocol witness table for _DictionaryCodingKey;
  uint64_t result = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
  *a4 = result;
  result[2] = v10;
  result[3] = v12;
  result[4] = v14;
  *((_BYTE *)result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = v16 & 1;
  return result;
}

uint64_t protocol witness for CodingKeyRepresentable.init<A>(codingKey:) in conformance String@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = specialized String.init<A>(codingKey:)(a1, a2, a3);
  uint64_t v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t Dictionary<>.encode(to:)( void *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4, swift *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v400 = a7;
  v384 = a5;
  uint64_t v7 = (uint64_t *)a4;
  uint64_t v380 = a2;
  uint64_t v377 = type metadata accessor for Optional(0LL, a4, (uint64_t)a3, a4);
  uint64_t v379 = *(void *)(v377 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v377);
  uint64_t v372 = (char *)&v370 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v371 = (uint64_t *)((char *)&v370 - v13);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unint64_t v376 = (char *)&v370 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t i = (uint64_t)&v370 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v399 = (ValueMetadata *)((char *)&v370 - v19);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v375 = (char *)&v370 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v381 = (char *)&v370 - v23;
  MEMORY[0x1895F8858](v22);
  v388 = (uint64_t *)((char *)&v370 - v24);
  uint64_t v386 = type metadata accessor for Optional(0LL, (uint64_t)a3, v25, v26);
  uint64_t v378 = *(void *)(v386 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v386);
  v397 = (char *)&v370 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v370 = (uint64_t *)((char *)&v370 - v30);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  v392 = (id *)((char *)&v370 - v32);
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  v391 = (uint64_t *)((char *)&v370 - v34);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v374 = (char *)&v370 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  unint64_t v373 = (uint64_t *)((char *)&v370 - v38);
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v41 = (char *)&v370 - v40;
  uint64_t v42 = MEMORY[0x1895F8858](v39);
  uint64_t v44 = (char *)&v370 - v43;
  uint64_t v403 = *(v7 - 1);
  uint64_t v45 = MEMORY[0x1895F8858](v42);
  v383 = (char *)&v370 - ((v46 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  v389 = (swift *)((char *)&v370 - v48);
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  v395 = (char *)&v370 - v50;
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  uint64_t v53 = (swift *)((char *)&v370 - v52);
  uint64_t v54 = MEMORY[0x1895F8858](v51);
  unint64_t v396 = (unint64_t)&v370 - v55;
  Description = (void (**)(uint64_t *, uint64_t, uint64_t, ValueMetadata *))a3[-1].Description;
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  v382 = (char *)&v370 - ((v57 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v56);
  v404 = (char *)&v370 - v58;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, (uint64_t)a3, (uint64_t)v7, "key value ", 0LL);
  uint64_t v62 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v60, v61);
  uint64_t v401 = *(void *)(v62 - 8);
  uint64_t v402 = v62;
  uint64_t v63 = MEMORY[0x1895F8858](v62);
  v387 = (char *)&v370 - ((v64 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v65 = MEMORY[0x1895F8858](v63);
  v385 = (swift *)((char *)&v370 - v66);
  uint64_t v67 = MEMORY[0x1895F8858](v65);
  v390 = (char *)&v370 - v68;
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  v394 = (char *)&v370 - v70;
  uint64_t v71 = MEMORY[0x1895F8858](v69);
  v398 = (char *)&v370 - v72;
  uint64_t v73 = MEMORY[0x1895F8858](v71);
  uint64_t v75 = (char *)&v370 - v74;
  uint64_t v76 = MEMORY[0x1895F8858](v73);
  MEMORY[0x1895F8858](v76);
  char v79 = (swift *)((char *)&v370 - v78);
  v406 = TupleTypeMetadata2;
  v407 = v7;
  if (a3 == &type metadata for String)
  {
    v397 = v77;
    v392 = (id *)v53;
    v394 = v44;
    v395 = v41;
    uint64_t v97 = a1[3];
    uint64_t v98 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v97);
    (*(void (**)(uint64_t *__return_ptr, ValueMetadata *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v98 + 24))( v409,  &type metadata for _DictionaryCodingKey,  &type metadata for _DictionaryCodingKey,  &protocol witness table for _DictionaryCodingKey,  v97,  v98);
    unint64_t v102 = v380;
    if ((v380 & 0xC000000000000001LL) != 0)
    {
      if (v380 < 0) {
        uint64_t v103 = v380;
      }
      else {
        uint64_t v103 = v380 & 0xFFFFFFFFFFFFFF8LL;
      }
      uint64_t v104 = type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v105 = (unint64_t)swift_allocObject(v104, 0xE8uLL, 7uLL);
      v384 = 0LL;
      uint64_t v106 = 0LL;
      unint64_t v107 = 0LL;
      *(void *)(v105 + 208) = v103;
      *(void *)(v105 + 216) = 0LL;
      *(_OWORD *)(v105 + 16) = 0u;
      *(_OWORD *)(v105 + 32) = 0u;
      *(_OWORD *)(v105 + 48) = 0u;
      *(_OWORD *)(v105 + 64) = 0u;
      *(_OWORD *)(v105 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
      *(_OWORD *)(v105 + 96) = 0u;
      *(_OWORD *)(v105 + 112) = 0u;
      *(_OWORD *)(v105 + 128) = 0u;
      *(_OWORD *)(v105 + 144) = 0u;
      *(_OWORD *)(v105 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
      *(_OWORD *)(v105 + 176) = 0u;
      *(_OWORD *)(v105 + 192) = 0u;
      *(void *)(v105 + 224) = 0LL;
      unint64_t v108 = v105 | 0x8000000000000000LL;
    }

    else
    {
      uint64_t v134 = -1LL << *(_BYTE *)(v380 + 32);
      uint64_t v106 = ~v134;
      uint64_t v135 = *(void *)(v380 + 64);
      v384 = (swift *)(v380 + 64);
      uint64_t v136 = -v134;
      if (v136 < 64) {
        uint64_t v137 = ~(-1LL << v136);
      }
      else {
        uint64_t v137 = -1LL;
      }
      unint64_t v107 = v137 & v135;
      unint64_t v108 = v380;
    }

    unint64_t v138 = v388;
    unsigned int v139 = v395;
    unint64_t v140 = (uint64_t *)v394;
    v383 = (char *)((v108 & 0x7FFFFFFFFFFFFFFFLL) + 16);
    v390 = (char *)(v108 & 0x7FFFFFFFFFFFFFFFLL);
    v382 = (char *)((v108 & 0x7FFFFFFFFFFFFFFFLL) + 80);
    unint64_t v376 = (char *)v106;
    v387 = (char *)((unint64_t)(v106 + 64) >> 6);
    uint64_t v375 = v387 - 1;
    swift_bridgeObjectRetain(v102, v99, v100, v101);
    uint64_t v144 = 0LL;
    v385 = (swift *)&unk_189B8D230;
    v389 = v79;
    uint64_t i = v108;
    v398 = (char *)v107;
    v399 = 0LL;
    if ((v108 & 0x8000000000000000LL) == 0) {
      goto LABEL_51;
    }
LABEL_32:
    uint64_t v145 = v390;
    uint64_t v146 = *((void *)v390 + 27);
    if ((v146 & 0x8000000000000000LL) == 0)
    {
      unint64_t v147 = (void *)*((void *)v390 + 26);
      if (v146 != *((void *)v390 + 28)) {
        goto LABEL_36;
      }
      id v148 = objc_msgSend(*((id *)v390 + 26), sel_countByEnumeratingWithState_objects_count_, v383, v382, 16);
      uint64_t v145 = v390;
      *((void *)v390 + 28) = v148;
      if (v148)
      {
        uint64_t v146 = 0LL;
        *((void *)v145 + 27) = 0LL;
LABEL_36:
        uint64_t v149 = *((void *)v145 + 3);
        if (v149)
        {
          if ((unint64_t)(v146 - 0x1000000000000000LL) >> 61 == 7)
          {
            Swift::Int v150 = (void **)(v149 + 8 * v146);
            if ((v150 & 7) != 0) {
LABEL_219:
            }
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
            uint64_t v151 = *v150;
            *((void *)v145 + 27) = v146 + 1;
            swift_unknownObjectRetain(v151, v141, v142, v143);
            uint64_t v152 = (swift *)objc_msgSend(v147, sel_objectForKey_, v151);
            if (v152)
            {
              Swift::Int v153 = v152;
              if (_swift_isClassOrObjCExistentialType( (uint64_t)&type metadata for String,  &type metadata for String.Kind))
              {
                *(void *)&__int128 v412 = v151;
                uint64_t v154 = v397;
                swift_dynamicCast(v397, (uint64_t *)&v412, v385, (const char *)&type metadata for String, 7uLL);
              }

              else
              {
                uint64_t v161 = Description;
                Description[7](v140, 1LL, 1LL, &type metadata for String);
                _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v151, (uint64_t)&type metadata for String, v140);
                swift_unknownObjectRelease(v151);
                uint64_t v162 = v378;
                unint64_t v163 = v140;
                uint64_t v164 = v140;
                uint64_t v165 = v386;
                (*(void (**)(char *, uint64_t *, uint64_t))(v378 + 16))(v139, v163, v386);
                if (((unsigned int (*)(char *, uint64_t, ValueMetadata *))v161[6])( v139,  1LL,  &type metadata for String) == 1) {
                  goto LABEL_235;
                }
                (*(void (**)(uint64_t *, uint64_t))(v162 + 8))(v164, v165);
                uint64_t v154 = v397;
                ((void (*)(char *, char *, ValueMetadata *))v161[4])(v397, v139, &type metadata for String);
              }

              unsigned int v155 = &v154[*((int *)TupleTypeMetadata2 + 12)];
              uint64_t v156 = (const char *)v407;
              BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v407, v407);
              char v158 = v381;
              if (isClassOrObjCExistentialType)
              {
                *(void *)&__int128 v412 = v153;
                swift_dynamicCast(v155, (uint64_t *)&v412, (swift *)&unk_189B8D230, v156, 7uLL);
LABEL_44:
                uint64_t v159 = *(TupleTypeMetadata2 - 1);
                (*(void (**)(char *, void, uint64_t, unint64_t *))(v159 + 56))( v154,  0LL,  1LL,  TupleTypeMetadata2);
                unint64_t v107 = (unint64_t)v398;
                uint64_t v160 = (uint64_t)v399;
                goto LABEL_60;
              }

              uint64_t v166 = v403;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, const char *))(v403 + 56))(v138, 1LL, 1LL, v156);
              _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v153, (uint64_t)v156, v138);
              swift_unknownObjectRelease(v153);
              uint64_t v167 = v379;
              uint64_t v168 = v377;
              (*(void (**)(char *, uint64_t *, uint64_t))(v379 + 16))(v158, v138, v377);
              if ((*(unsigned int (**)(char *, uint64_t, const char *))(v166 + 48))(v158, 1LL, v156) != 1)
              {
                (*(void (**)(uint64_t *, uint64_t))(v167 + 8))(v138, v168);
                (*(void (**)(char *, char *, const char *))(v166 + 32))(v155, v158, v156);
                TupleTypeMetadata2 = v406;
                uint64_t v154 = v397;
                goto LABEL_44;
              }

LABEL_235:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
            }

        uint64_t result = 0LL;
        goto LABEL_229;
      }
    }

      uint64_t v255 = 266LL;
LABEL_237:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v255,  0);
    }
  }

  else
  {
    uint64_t v49 = v270;
    if (v32 <= 15)
    {
      uint64_t v128 = v279;
      goto LABEL_97;
    }
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v32, v12);
  swift_bridgeObjectRelease(v34);
  if ((v34 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(v272, v34, v35, v18);
    swift_bridgeObjectRelease(v34);
    uint64_t v43 = v274;
LABEL_102:
    uint64_t v131 = v269;
  }

  else
  {
    uint64_t v43 = v274;
    uint64_t v131 = v269;
    unint64_t v132 = v272;
    if ((v34 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v34);
      uint64_t v161 = HIBYTE(v34) & 0xF;
      uint64_t v282 = v132;
      size_t v283 = v34 & 0xFFFFFFFFFFFFFFLL;
      if (v161 < v18) {
        goto LABEL_221;
      }
      uint64_t v162 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v35, v18, (uint64_t)&v282, v161);
      _StringGuts.appendInPlace(_:isASCII:)(v162, v163, (v34 & 0x4000000000000000LL) != 0);
    }

    else
    {
      if ((v272 & 0x1000000000000000LL) != 0)
      {
        unint64_t v133 = (id)((v34 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v134 = v272 & 0xFFFFFFFFFFFFLL;
        if ((v272 & 0xFFFFFFFFFFFFLL) >= v18) {
          goto LABEL_95;
        }
LABEL_221:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }

      unint64_t v133 = _StringObject.sharedUTF8.getter(v272, v34);
      uint64_t v134 = v249;
      if (v249 < v18) {
        goto LABEL_221;
      }
LABEL_95:
      uint64_t v135 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v35, v18, (uint64_t)v133, v134);
      _StringGuts.appendInPlace(_:isASCII:)(v135, v136, v132 < 0);
      swift_bridgeObjectRelease(v34);
    }
  }

  uint64_t v159 = v271;
  uint64_t v47 = v278;
  uint64_t v160 = v279;
  swift_bridgeObjectRelease(v43[3]);
  v43[2] = v47;
  v43[3] = v160;
LABEL_174:
  unint64_t v238 = (char *)v273 - v159;
  if (__OFSUB__(v273, v159))
  {
    __break(1u);
    goto LABEL_203;
  }

  uint64_t v159 = *v43;
  uint64_t v47 = (unint64_t)*v43 >> 16;
  uint64_t v32 = (uint64_t)&v238[v131 - v49];
  uint64_t v35 = v32 + ((unint64_t)v43[1] >> 16);
  Swift::String::Index v239 = ((unint64_t)*v43 >> 8) & 0x3F;
  if (v239)
  {
    if (v239 + v47 < v131) {
      goto LABEL_199;
    }
  }

  else if (v47 < v131)
  {
    goto LABEL_199;
  }

  if (v47 == v35)
  {
    uint64_t v240 = 0LL;
    uint64_t v241 = v159 & 0xFFFFFFFFFFFF0000LL;
    goto LABEL_193;
  }

  uint64_t v242 = v43[2];
  uint64_t v243 = v43[3];
  if ((v243 & 0x1000000000000000LL) != 0)
  {
LABEL_203:
    uint64_t v240 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v47);
    uint64_t v241 = v159 & 0xFFFFFFFFFFFF0000LL;
    if (v240 <= 63) {
      goto LABEL_193;
    }
  }

  else
  {
    if ((v243 & 0x2000000000000000LL) == 0)
    {
      if ((v242 & 0x1000000000000000LL) != 0)
      {
        uint64_t v244 = (char *)((v243 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v245 = v242 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v244 = (char *)_StringObject.sharedUTF8.getter(v43[2], v43[3]);
      }

      if (v47 + 1 == v245) {
        goto LABEL_192;
      }
      if (!v244) {
LABEL_242:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      uint64_t v246 = *(unsigned __int16 *)&v244[v47];
LABEL_190:
      if (v246 != 2573 && (v246 & 0x80808080) == 0) {
        goto LABEL_192;
      }
      goto LABEL_203;
    }

    unint64_t v278 = v43[2];
    unint64_t v279 = v243 & 0xFFFFFFFFFFFFFFLL;
    if (v47 + 1 != (HIBYTE(v243) & 0xF))
    {
      uint64_t v246 = *(unsigned __int16 *)((char *)&v278 + v47);
      goto LABEL_190;
    }

            char v190 = 266LL;
LABEL_237:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v190,  0);
          }

        unint64_t v101 = DWORD2(v538);
        if (DWORD2(v538) < 2)
        {
          *unint64_t v6 = (unint64_t)"unknown error";
          v6[1] = (unint64_t)swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
          *((_WORD *)v6 + 8) = 1;
          goto LABEL_1079;
        }

        uint64_t v188 = *((unsigned __int16 *)v10 + 8);
        if ((_DWORD)v67 == 3)
        {
          uint64_t v189 = *((_DWORD *)v10 + 2);
          char v190 = *(const char **)v10;
        }

        else
        {
          uint64_t v189 = 0;
          char v190 = "";
        }

        uint64_t v255 = operator new(0x28uLL);
        *(void *)uint64_t v255 = "TypeDecoder.h:%u: Node kind %u %.*s - got %zu errors";
        v255[2] = 1126;
        v255[3] = v188;
        v255[4] = v189;
        *((void *)v255 + 3) = v190;
        *((void *)v255 + 4) = v101;
        *((_WORD *)v6 + 8) = 1;
        uint64_t v256 = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
LABEL_1078:
        v6[1] = (unint64_t)v256;
        v441 = operator new(0x28uLL);
        v442 = *((_OWORD *)v255 + 1);
        *v441 = *(_OWORD *)v255;
        v441[1] = v442;
        *((void *)v441 + 4) = *((void *)v255 + 4);
        *unint64_t v6 = (unint64_t)v441;
        operator delete(v255);
LABEL_1079:
        if ((_WORD *)v538 != v539) {
          free((void *)v538);
        }
        if (v545 != v547) {
          free(v545);
        }
        char v251 = (void *)v541;
        goto LABEL_1084;
      case 0xB4:
      case 0xB5:
      case 0x15B:
        if ((void)v541)
        {
          return;
        }

        uint64_t v43 = *((unsigned __int16 *)v10 + 8);
        if (*((_BYTE *)v10 + 18) == 3)
        {
          uint64_t v44 = *((_DWORD *)v10 + 2);
          uint64_t v45 = *(const char **)v10;
        }

        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = "";
        }

        uint64_t v97 = operator new(0x28uLL);
        uint64_t v40 = v97;
        *uint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
        *((_DWORD *)v97 + 2) = 855;
        *((_DWORD *)v97 + 3) = v43;
        *((_DWORD *)v97 + 4) = v44;
        uint64_t v100 = "failed to decode protocol type";
        goto LABEL_459;
      case 0xBE:
      case 0xBF:
      case 0xC0:
        uint64_t v26 = 0;
        uint64_t v27 = "";
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
          case 2:
            *(void *)&v541 = &v542;
            *((void *)&v541 + 1) = 0x800000000LL;
            uint64_t v28 = (const char *)v10;
            goto LABEL_64;
          case 3:
            uint64_t v26 = *((_DWORD *)v10 + 2);
            uint64_t v27 = *(const char **)v10;
            goto LABEL_476;
          case 5:
            if (!*((_DWORD *)v10 + 2))
            {
              uint64_t v26 = 0;
LABEL_476:
              uint64_t v97 = operator new(0x28uLL);
              uint64_t v40 = v97;
              *uint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
              uint64_t v154 = 774;
              goto LABEL_477;
            }

            *(void *)&v541 = &v542;
            *((void *)&v541 + 1) = 0x800000000LL;
            if (*((_DWORD *)v10 + 2))
            {
              uint64_t v28 = *(const char **)v10;
LABEL_64:
              uint64_t v29 = *(int ***)v28;
            }

            else
            {
              uint64_t v29 = 0LL;
            }

            if (*((_WORD *)v29 + 8) == 190)
            {
              uint64_t v30 = *((unsigned __int8 *)v29 + 18);
              uint64_t v31 = (uint64_t *)v6;
              if ((v30 - 1) < 2)
              {
LABEL_70:
                uint64_t v29 = (int **)*v29;
                goto LABEL_196;
              }

              if (v30 == 5 && *((_DWORD *)v29 + 2))
              {
                uint64_t v29 = (int **)*v29;
                goto LABEL_70;
              }
            }

            else
            {
              uint64_t v31 = (uint64_t *)v6;
            }

LABEL_233:
            unint64_t v369 = 784LL;
LABEL_234:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v369,  0);
          }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  uint64_t v38 = HIBYTE(a2) & 0xF;
  v157[0] = a1;
  v157[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v38) {
    goto LABEL_233;
  }
  if (a1 == 43)
  {
    uint64_t v8 = 1;
    uint64_t v110 = specialized Collection.subscript.getter(1LL, (uint64_t)v157, v38);
    uint64_t v114 = specialized UnsafeBufferPointer.init(rebasing:)(v110, v111, v112, v113);
    if (!v115) {
      goto LABEL_235;
    }
    uint64_t v116 = (unsigned __int8 *)v114;
    uint64_t v117 = a3 + 55;
    unint64_t v118 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v119 = 58;
    }

    else
    {
      unint64_t v118 = 97;
      uint64_t v117 = 65;
      uint64_t v119 = a3 + 48;
    }

    if (v114)
    {
      unint64_t v120 = v115;
      uint64_t v20 = 0LL;
      unint64_t v121 = 0LL;
      uint64_t v122 = a3 >> 63;
      while (1)
      {
        uint64_t v123 = *v116;
        if (v123 < 0x30 || v123 >= v119)
        {
          if (v123 < 0x41 || v123 >= v117)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v123 < 0x61 || v123 >= v118) {
              goto LABEL_229;
            }
            uint64_t v124 = -87;
          }

          else
          {
            uint64_t v124 = -55;
          }
        }

        else
        {
          uint64_t v124 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v125 = v123 + v124;
        if (v121) {
          unint64_t v126 = a3 >= 0;
        }
        else {
          unint64_t v126 = 1;
        }
        uint64_t v129 = !v126
            || (v121 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
            || ((unint64_t)v122 * (unsigned __int128)v20) >> 64 != 0;
        unint64_t v130 = v122 * v20 + v121 * a3;
        uint64_t v131 = (v20 * (unsigned __int128)(unint64_t)a3) >> 64;
        uint64_t v33 = __CFADD__(v131, v130);
        unint64_t v132 = v131 + v130;
        if (v33) {
          uint64_t v129 = 1;
        }
        unint64_t v133 = v20 * a3;
        uint64_t v33 = __CFADD__(v133, v125);
        uint64_t v20 = v133 + v125;
        uint64_t v134 = v33;
        uint64_t v33 = __CFADD__(v33, v132);
        unint64_t v121 = v134 + v132;
        uint64_t v135 = v33;
        uint64_t v8 = 1;
        if ((v129 & 1) != 0 || v135) {
          goto LABEL_229;
        }
        ++v116;
        if (!--v120)
        {
LABEL_192:
          uint64_t v8 = 0;
          uint64_t result = v20;
          goto LABEL_229;
        }
      }
    }
  }

  else
  {
    if (a1 != 45)
    {
      uint64_t v136 = 0LL;
      uint64_t v137 = 0LL;
      unint64_t v138 = a3 + 48;
      unsigned int v139 = a3 + 55;
      unint64_t v140 = a3 + 87;
      if (a3 > 10)
      {
        unint64_t v138 = 58;
      }

      else
      {
        unint64_t v140 = 97;
        unsigned int v139 = 65;
      }

      uint64_t v141 = a3 >> 63;
      uint64_t v142 = (unsigned __int8 *)v157;
      while (1)
      {
        uint64_t v143 = *v142;
        if (v143 < 0x30 || v143 >= v138)
        {
          if (v143 < 0x41 || v143 >= v139)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v143 < 0x61 || v143 >= v140) {
              goto LABEL_229;
            }
            uint64_t v144 = -87;
          }

          else
          {
            uint64_t v144 = -55;
          }
        }

        else
        {
          uint64_t v144 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v145 = v143 + v144;
        if (v137) {
          uint64_t v146 = a3 >= 0;
        }
        else {
          uint64_t v146 = 1;
        }
        uint64_t v149 = !v146
            || (v137 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
            || ((unint64_t)v141 * (unsigned __int128)(unint64_t)v136) >> 64 != 0;
        Swift::Int v150 = v141 * v136 + v137 * a3;
        uint64_t v151 = ((unint64_t)v136 * (unsigned __int128)(unint64_t)a3) >> 64;
        uint64_t v33 = __CFADD__(v151, v150);
        uint64_t v152 = v151 + v150;
        if (v33) {
          uint64_t v149 = 1;
        }
        Swift::Int v153 = v136 * a3;
        uint64_t v33 = __CFADD__(v153, v145);
        uint64_t v136 = v153 + v145;
        uint64_t v154 = v33;
        uint64_t v33 = __CFADD__(v33, v152);
        uint64_t v137 = v154 + v152;
        unsigned int v155 = v33;
        uint64_t v8 = 1;
        if ((v149 & 1) != 0 || v155) {
          goto LABEL_229;
        }
        ++v142;
        if (!--v38)
        {
          uint64_t v8 = 0;
          uint64_t result = v136;
          goto LABEL_229;
        }
      }
    }

    uint64_t v8 = 1;
    uint64_t v39 = specialized Collection.subscript.getter(1LL, (uint64_t)v157, v38);
    uint64_t v43 = specialized UnsafeBufferPointer.init(rebasing:)(v39, v40, v41, v42);
    if (!v44) {
      goto LABEL_234;
    }
    uint64_t v45 = (unsigned __int8 *)v43;
    uint64_t v46 = a3 + 55;
    uint64_t v47 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v48 = 58;
    }

    else
    {
      uint64_t v47 = 97;
      uint64_t v46 = 65;
      uint64_t v48 = a3 + 48;
    }

    if (v43)
    {
      uint64_t v49 = v44;
      uint64_t v20 = 0LL;
      uint64_t v50 = 0LL;
      uint64_t v51 = a3 >> 63;
      while (1)
      {
        uint64_t v52 = *v45;
        if (v52 < 0x30 || v52 >= v48)
        {
          if (v52 < 0x41 || v52 >= v46)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v52 < 0x61 || v52 >= v47) {
              goto LABEL_229;
            }
            uint64_t v53 = -87;
          }

          else
          {
            uint64_t v53 = -55;
          }
        }

        else
        {
          uint64_t v53 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v54 = v52 + v53;
        if (v50) {
          uint64_t v55 = a3 >= 0;
        }
        else {
          uint64_t v55 = 1;
        }
        uint64_t v58 = !v55
           || (v50 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
           || ((unint64_t)v51 * (unsigned __int128)v20) >> 64 != 0;
        uint64_t v59 = v51 * v20 + v50 * a3;
        uint64_t v60 = (v20 * (unsigned __int128)(unint64_t)a3) >> 64;
        uint64_t v33 = __CFADD__(v60, v59);
        uint64_t v61 = v60 + v59;
        if (v33) {
          uint64_t v58 = 1;
        }
        uint64_t v62 = v20 * a3;
        uint64_t v33 = v62 >= v54;
        uint64_t v20 = v62 - v54;
        uint64_t v63 = v33;
        uint64_t v33 = v61 >= !v33;
        uint64_t v50 = v61 - !v63;
        uint64_t v64 = !v33;
        uint64_t v8 = 1;
        if ((v58 & 1) != 0 || v64) {
          goto LABEL_229;
        }
        ++v45;
        if (!--v49) {
          goto LABEL_192;
        }
      }
    }
  }

LABEL_221:
          __break(1u);
LABEL_222:
          __break(1u);
LABEL_223:
          __break(1u);
LABEL_224:
          __break(1u);
LABEL_225:
          __break(1u);
LABEL_226:
          __break(1u);
LABEL_227:
          __break(1u);
LABEL_228:
          __break(1u);
LABEL_229:
          __break(1u);
LABEL_230:
          __break(1u);
LABEL_231:
          __break(1u);
        }

    unint64_t v169 = 266LL;
LABEL_223:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v169,  0);
  }

  unint64_t v327 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    unint64_t v327 = v450 & 0xFFFFFFFFFFFFLL;
  }
  if (v327 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x29uLL, 0xE100000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    return v450;
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    return 41LL;
  }

LABEL_232:
        unint64_t v369 = 773LL;
        goto LABEL_234;
      }

      *((void *)v145 + 27) = -1LL;
    }

    uint64_t v159 = *(TupleTypeMetadata2 - 1);
    uint64_t v154 = v397;
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v159 + 56))( v397,  1LL,  1LL,  TupleTypeMetadata2);
    uint64_t v160 = (uint64_t)v399;
    while (1)
    {
LABEL_60:
      (*(void (**)(swift *, char *, uint64_t))(v401 + 32))(v79, v154, v402);
      if ((*(unsigned int (**)(swift *, uint64_t, unint64_t *))(v159 + 48))( v79,  1LL,  TupleTypeMetadata2) == 1) {
        goto LABEL_73;
      }
      uint64_t v179 = (char *)v79 + *((int *)TupleTypeMetadata2 + 12);
      uint64_t v180 = v403;
      uint64_t v181 = v392;
      uint64_t v182 = v407;
      (*(void (**)(id *, char *, uint64_t *))(v403 + 32))(v392, v179, v407);
      uint64_t v183 = (uint64_t *)v404;
      ((void (*)(char *, swift *, ValueMetadata *))Description[4])(v404, v79, &type metadata for String);
      swift_dynamicCast( (char *)&v412,  v183,  (swift *)&type metadata for String,  (const char *)&type metadata for String,  7uLL);
      uint64_t v186 = specialized _DictionaryCodingKey.init(stringValue:)(v412, *((uint64_t *)&v412 + 1), v184, v185);
      uint64_t v188 = v187;
      *(void *)&__int128 v412 = v186;
      *((void *)&v412 + 1) = v187;
      uint64_t v413 = v189;
      LOBYTE(v414) = v190 & 1;
      char v191 = v405;
      (*(void (**)(id *, __int128 *, uint64_t *, ValueMetadata *, uint64_t, _UNKNOWN **))(*(void *)v409[0]
                                                                                                 + 232LL))( v181,  &v412,  v182,  &type metadata for _DictionaryCodingKey,  v400,  &protocol witness table for _DictionaryCodingKey);
      v405 = v191;
      if (v191)
      {
        (*(void (**)(id *, uint64_t *))(v180 + 8))(v181, v182);
        swift_bridgeObjectRelease(v188);
LABEL_73:
        outlined consume of [A : B].Iterator._Variant<A, B>(i);
        uint64_t v193 = v409[0];
        return swift_release(v193);
      }

      (*(void (**)(id *, uint64_t *))(v180 + 8))(v181, v182);
      swift_bridgeObjectRelease(v188);
      uint64_t v144 = v160;
      TupleTypeMetadata2 = v406;
      unsigned int v139 = v395;
      unint64_t v140 = (uint64_t *)v394;
      unint64_t v108 = i;
      v398 = (char *)v107;
      v399 = (ValueMetadata *)v144;
      if (i < 0) {
        goto LABEL_32;
      }
LABEL_51:
      if (v107)
      {
        v391 = (uint64_t *)((v107 - 1) & v107);
        unint64_t v169 = __clz(__rbit64(v107)) | (v144 << 6);
        uint64_t v160 = v144;
        goto LABEL_53;
      }

      uint64_t v160 = v144 + 1;
      if (__OFADD__(v144, 1LL))
      {
        __break(1u);
        goto LABEL_221;
      }

      unint64_t v178 = *((void *)v384 + v160);
      uint64_t v154 = v397;
      if (v178)
      {
LABEL_57:
        v391 = (uint64_t *)((v178 - 1) & v178);
        unint64_t v169 = __clz(__rbit64(v178)) + (v160 << 6);
LABEL_53:
        Swift::String::Index v170 = Description;
        Swift::String::Index v171 = v404;
        ((void (*)(char *, unint64_t, ValueMetadata *))Description[2])( v404,  *(void *)(v108 + 48) + (void)Description[9] * v169,  &type metadata for String);
        uint64_t v172 = v403;
        unint64_t v173 = *(void *)(v108 + 56) + *(void *)(v403 + 72) * v169;
        uint64_t v174 = v396;
        uint64_t v175 = v407;
        (*(void (**)(unint64_t, unint64_t, uint64_t *))(v403 + 16))(v396, v173, v407);
        uint64_t v154 = v397;
        unint64_t v176 = &v397[*((int *)v406 + 12)];
        uint64_t v177 = v170[4];
        TupleTypeMetadata2 = v406;
        ((void (*)(char *, char *, ValueMetadata *))v177)(v397, v171, &type metadata for String);
        (*(void (**)(char *, uint64_t, uint64_t *))(v172 + 32))(v176, v174, v175);
        uint64_t v159 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v159 + 56))( v154,  0LL,  1LL,  TupleTypeMetadata2);
        unint64_t v138 = v388;
        char v79 = v389;
        unint64_t v107 = (unint64_t)v391;
      }

      else
      {
        uint64_t v192 = (char *)(v144 + 2);
        if (v144 + 2 < (uint64_t)v387)
        {
          unint64_t v178 = *((void *)v384 + (void)v192);
          if (v178)
          {
            uint64_t v160 = v144 + 2;
            goto LABEL_57;
          }

          while (1)
          {
            uint64_t v160 = (uint64_t)(v192 + 1);
            if (__OFADD__(v192, 1LL)) {
              goto LABEL_224;
            }
            unint64_t v178 = *((void *)v384 + v160);
            ++v192;
            if (v178) {
              goto LABEL_57;
            }
          }

          uint64_t v160 = (uint64_t)v375;
        }

          _StringGuts._foreignGrow(_:)(v160);
LABEL_213:
          uint64_t v18 = v7._rawBits;
LABEL_214:
          uint64_t v17 = (uint64_t *)v213;
          uint64_t v8 = *(void *)(v213 + 24);
          uint64_t v215 = v204;
          Swift::String::Index v216 = v208;
          uint64_t v217 = v200;
          unint64_t v218 = v201;
          uint64_t v219 = v156;
          unint64_t v220 = 0LL;
          uint64_t v39 = v12;
          uint64_t v195 = v12;
          uint64_t v12 = v9;
          specialized __StringStorage.replace<A>(from:to:with:replacementCount:)(v195, v9, (uint64_t)&v215, v121);
          swift_bridgeObjectRelease(v201);
          *(void *)(v213 + 16) = *(void *)(v8 + 24);
          goto LABEL_98;
        }
      }

      __break(1u);
      goto LABEL_222;
    }
  }

  uint64_t v25 = 0xE000000000000000LL;
  uint64_t v221 = 0LL;
  Swift::Int v222 = 0xE000000000000000LL;
  uint64_t v26 = _StringGuts.nativeCapacity.getter(v9, v10);
  uint64_t v27 = 0LL;
  if ((v28 & 1) == 0)
  {
    uint64_t v29 = v26;
    if (v26 >= 16)
    {
      uint64_t v30 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v31 & 1) != 0 || v30 < v29)
      {
        uint64_t v33 = 2 * _StringGuts.uniqueNativeCapacity.getter();
        if (v33 <= v29) {
          uint64_t v33 = v29;
        }
        if ((v32 & 1) != 0) {
          uint64_t v34 = v29;
        }
        else {
          uint64_t v34 = v33;
        }
        uint64_t v215 = 0LL;
        Swift::String::Index v216 = 0LL;
        uint64_t v25 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v215,  0LL,  v34,  1);
        uint64_t v27 = *(void *)(v25 + 24);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        uint64_t v221 = v27;
        Swift::Int v222 = v25;
      }

      else
      {
        uint64_t v27 = 0LL;
        uint64_t v25 = 0xE000000000000000LL;
      }
    }
  }

  uint64_t v198 = v7._rawBits >> 16;
  uint64_t v199 = v12;
  v35._Swift::UInt64 rawBits = v7._rawBits;
  startingAt = v17[3];
  uint64_t v213 = v17[2];
  uint64_t v8 = specialized Collection.subscript.getter(v35, v213, startingAt);
  uint64_t v39 = v38;
  v7._Swift::UInt64 rawBits = v36;
  uint64_t v9 = v37;
  uint64_t v12 = v38 >> 16;
  uint64_t v197 = v8 >> 16;
  if ((v37 & 0x1000000000000000LL) == 0)
  {
    uint64_t v11 = v36;
    v7._Swift::UInt64 rawBits = v12 - (v8 >> 16);
    swift_bridgeObjectRetain_n(v37, 2LL, v36, (char *)v37);
    if ((v25 & 0x1000000000000000LL) != 0) {
      goto LABEL_135;
    }
LABEL_40:
    if ((v25 & 0x2000000000000000LL) != 0)
    {
      uint64_t v43 = HIBYTE(v25) & 0xF;
      uint64_t v42 = v43 + v7._rawBits;
      if (__OFADD__(v43, v7._rawBits)) {
        goto LABEL_137;
      }
    }

    else
    {
      uint64_t v42 = (v27 & 0xFFFFFFFFFFFFLL) + v7._rawBits;
      if (__OFADD__(v27 & 0xFFFFFFFFFFFFLL, v7._rawBits)) {
        goto LABEL_137;
      }
    }

LABEL_153:
      (*(void (**)(char *, char *, uint64_t))(v401 + 32))(v75, v272, v402);
      Swift::String::Index v295 = &v75[*((int *)v279 + 12)];
      Swift::String::Index v296 = v395;
      unint64_t v297 = v407;
      (*(void (**)(char *, char *, uint64_t *))(v273 + 32))(v395, v295, v407);
      unint64_t v298 = (uint64_t *)v404;
      ((void (*)(char *, char *, ValueMetadata *))v115[4])(v404, v75, &type metadata for Int);
      swift_dynamicCast( (char *)&v412,  v298,  (swift *)&type metadata for Int,  (const char *)&type metadata for Int,  7uLL);
      unint64_t v299 = specialized _DictionaryCodingKey.init(intValue:)(v412);
      uint64_t v300 = v273;
      uint64_t v302 = v301;
      *(void *)&__int128 v412 = v299;
      *((void *)&v412 + 1) = v301;
      uint64_t v413 = v303;
      LOBYTE(v414) = v304 & 1;
      (*(void (**)(char *, __int128 *, uint64_t *, ValueMetadata *, uint64_t, _UNKNOWN **))(*(void *)v409[0] + 232LL))( v296,  &v412,  v297,  &type metadata for _DictionaryCodingKey,  v400,  &protocol witness table for _DictionaryCodingKey);
      if (v80)
      {
        (*(void (**)(char *, uint64_t *))(v300 + 8))(v296, v297);
        swift_bridgeObjectRelease(v302);
LABEL_169:
        outlined consume of [A : B].Iterator._Variant<A, B>(v396);
        return swift_release(v409[0]);
      }

      (*(void (**)(char *, uint64_t *))(v300 + 8))(v296, v297);
      swift_bridgeObjectRelease(v302);
      unint64_t v271 = v276;
      unint64_t v120 = v274;
      uint64x2_t v115 = Description;
      TupleTypeMetadata2 = v406;
      p_Kind = &v399->Kind;
    }
  }

  uint64_t v83 = swift_conformsToProtocol2((uint64_t)a3, (uint64_t)&protocol descriptor for CodingKeyRepresentable);
  v399 = a3;
  if (v83) {
    uint64_t v84 = a3;
  }
  else {
    uint64_t v84 = 0LL;
  }
  unint64_t v85 = Description;
  if (!v84)
  {
    uint64_t v122 = a1[3];
    uint64_t v123 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v122);
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v123 + 32))(&v412, v122, v123);
    unint64_t v127 = v81;
    if (v82)
    {
      if (v81 < 0) {
        uint64_t v128 = v81;
      }
      else {
        uint64_t v128 = v81 & 0xFFFFFFFFFFFFFF8LL;
      }
      uint64_t v129 = type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v130 = (unint64_t)swift_allocObject(v129, 0xE8uLL, 7uLL);
      v390 = 0LL;
      uint64_t v131 = 0LL;
      unint64_t v132 = 0LL;
      *(void *)(v130 + 208) = v128;
      *(void *)(v130 + 216) = 0LL;
      *(_OWORD *)(v130 + 16) = 0u;
      *(_OWORD *)(v130 + 32) = 0u;
      *(_OWORD *)(v130 + 48) = 0u;
      *(_OWORD *)(v130 + 64) = 0u;
      *(_OWORD *)(v130 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
      *(_OWORD *)(v130 + 96) = 0u;
      *(_OWORD *)(v130 + 112) = 0u;
      *(_OWORD *)(v130 + 128) = 0u;
      *(_OWORD *)(v130 + 144) = 0u;
      *(_OWORD *)(v130 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
      *(_OWORD *)(v130 + 176) = 0u;
      *(_OWORD *)(v130 + 192) = 0u;
      *(void *)(v130 + 224) = 0LL;
      unint64_t v133 = v130 | 0x8000000000000000LL;
    }

    else
    {
      uint64_t v313 = -1LL << *(_BYTE *)(v81 + 32);
      uint64_t v131 = ~v313;
      uint64_t v314 = *(void *)(v81 + 64);
      v390 = (char *)(v81 + 64);
      uint64_t v315 = -v313;
      if (v315 < 64) {
        uint64_t v316 = ~(-1LL << v315);
      }
      else {
        uint64_t v316 = -1LL;
      }
      unint64_t v132 = v316 & v314;
      unint64_t v133 = v81;
    }

    uint64_t v317 = v405;
    unint64_t v318 = (char *)v399;
    unint64_t v319 = v397;
    v388 = (uint64_t *)((v133 & 0x7FFFFFFFFFFFFFFFLL) + 16);
    v392 = (id *)(v133 & 0x7FFFFFFFFFFFFFFFLL);
    v381 = (char *)((v133 & 0x7FFFFFFFFFFFFFFFLL) + 80);
    uint64_t v380 = v131;
    v391 = (uint64_t *)((unint64_t)(v131 + 64) >> 6);
    unint64_t v376 = (char *)v391 - 1;
    swift_bridgeObjectRetain(v127, v124, v125, v126);
    char v323 = 0LL;
    v389 = (swift *)&unk_189B8D230;
    uint64_t v324 = v386;
    for (i = v133; ; unint64_t v133 = i)
    {
      v395 = (char *)v132;
      v394 = v323;
      if ((v133 & 0x8000000000000000LL) == 0) {
        break;
      }
      id v336 = v392;
      unint64_t v337 = (unint64_t)v392[27];
      if ((v337 & 0x8000000000000000LL) != 0) {
        goto LABEL_199;
      }
      id v338 = v392[26];
      if ((id)v337 == v392[28])
      {
        unint64_t v339 = v323;
        id v340 = objc_msgSend(v392[26], sel_countByEnumeratingWithState_objects_count_, v388, v381, 16);
        id v336 = v392;
        v392[28] = v340;
        if (!v340)
        {
          v336[27] = (id)-1LL;
          char v323 = v339;
LABEL_199:
          uint64_t v335 = *(TupleTypeMetadata2 - 1);
          unint64_t v326 = v387;
          Swift::Int v351 = v323;
          (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v335 + 56))( v387,  1LL,  1LL,  TupleTypeMetadata2);
          v405 = v351;
          v398 = v395;
LABEL_200:
          unint64_t v348 = v385;
          goto LABEL_201;
        }

        unint64_t v337 = 0LL;
        v336[27] = 0LL;
      }

      uint64_t v341 = (char *)v336[3];
      if (!v341) {
        goto LABEL_232;
      }
      if ((v337 - 0x1000000000000000LL) >> 61 != 7) {
        goto LABEL_230;
      }
      id v342 = (void **)&v341[8 * v337];
      uint64_t v343 = *v342;
      v336[27] = (id)(v337 + 1);
      swift_unknownObjectRetain(v343, v320, v321, v322);
      Swift::String::Index v344 = (swift *)objc_msgSend(v338, sel_objectForKey_, v343);
      if (!v344) {
        goto LABEL_233;
      }
      size_t v345 = v344;
      if (_swift_isClassOrObjCExistentialType((uint64_t)v318, (uint64_t *)v318))
      {
        v409[0] = (uint64_t)v343;
        unint64_t v326 = v387;
        swift_dynamicCast(v387, v409, v389, v318, 7uLL);
      }

      else
      {
        Swift::String::Index v362 = v370;
        Description[7](v370, 1LL, 1LL, (ValueMetadata *)v318);
        _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v343, (uint64_t)v318, v362);
        swift_unknownObjectRelease(v343);
        uint64_t v363 = v378;
        (*(void (**)(char *, uint64_t *, uint64_t))(v378 + 16))(v319, v362, v324);
        (*(void (**)(uint64_t *, uint64_t))(v363 + 8))(v362, v324);
        unint64_t v326 = v387;
        ((void (*)(void))Description[4])();
      }

      unint64_t v346 = &v326[*((int *)TupleTypeMetadata2 + 12)];
      BOOL v347 = _swift_isClassOrObjCExistentialType((uint64_t)v7, v7);
      unint64_t v348 = v385;
      if (v347)
      {
        v409[0] = (uint64_t)v345;
        swift_dynamicCast(v346, v409, (swift *)&unk_189B8D230, (const char *)v7, 7uLL);
      }

      else
      {
        Swift::String::Index v364 = v372;
        uint64_t v365 = v403;
        Swift::Int v366 = v371;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v403 + 56))(v371, 1LL, 1LL, v7);
        _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v345, (uint64_t)v7, v366);
        swift_unknownObjectRelease(v345);
        uint64_t v367 = v379;
        uint64_t v368 = v377;
        (*(void (**)(char *, uint64_t *, uint64_t))(v379 + 16))(v364, v366, v377);
        (*(void (**)(uint64_t *, uint64_t))(v367 + 8))(v366, v368);
        (*(void (**)(char *, char *, uint64_t *))(v365 + 32))(v346, v364, v7);
        unint64_t v326 = v387;
        unint64_t v348 = v385;
      }

      uint64_t v335 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, void, uint64_t, unint64_t *))(v335 + 56))( v326,  0LL,  1LL,  TupleTypeMetadata2);
      v405 = v394;
      v398 = v395;
LABEL_201:
      (*(void (**)(swift *, char *, uint64_t))(v401 + 32))(v348, v326, v402);
      if ((*(unsigned int (**)(swift *, uint64_t, unint64_t *))(v335 + 48))( v348,  1LL,  TupleTypeMetadata2) == 1) {
        goto LABEL_218;
      }
      Swift::String::Index v352 = (char *)v348 + *((int *)TupleTypeMetadata2 + 12);
      Swift::String::Index v353 = Description;
      Swift::String::Index v354 = v7;
      Swift::String::Index v355 = v382;
      unint64_t v318 = (char *)v399;
      ((void (*)(char *, swift *, ValueMetadata *))Description[4])(v382, v348, v399);
      Swift::Int v356 = v383;
      (*(void (**)(char *, char *, uint64_t *))(v403 + 32))(v383, v352, v354);
      uint64_t v358 = v414;
      uint64_t v357 = v415;
      __swift_mutable_project_boxed_opaque_existential_1((uint64_t *)&v412, v414);
      (*(void (**)(char *, char *, swift *, uint64_t, uint64_t))(v357 + 160))(v355, v318, v384, v358, v357);
      if (v317)
      {
        (*(void (**)(char *, uint64_t *))(v403 + 8))(v356, v354);
        ((void (*)(char *, char *))v353[1])(v355, v318);
LABEL_218:
        outlined consume of [A : B].Iterator._Variant<A, B>(i);
        return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v412);
      }

      ((void (*)(char *, char *))v353[1])(v355, v318);
      uint64_t v359 = v414;
      uint64_t v360 = v415;
      __swift_mutable_project_boxed_opaque_existential_1((uint64_t *)&v412, v414);
      (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t))(v360 + 160))(v356, v354, v400, v359, v360);
      uint64_t v7 = v354;
      (*(void (**)(char *, uint64_t *))(v403 + 8))(v356, v354);
      char v323 = v405;
      TupleTypeMetadata2 = v406;
      unint64_t v132 = (unint64_t)v398;
      uint64_t v324 = v386;
      unint64_t v319 = v397;
    }

    if (v132)
    {
      v398 = (char *)((v132 - 1) & v132);
      unint64_t v325 = __clz(__rbit64(v132)) | ((void)v323 << 6);
      v405 = v323;
      unint64_t v326 = v387;
LABEL_178:
      unint64_t v327 = Description;
      unint64_t v328 = v404;
      ((void (*)(char *, unint64_t, char *))Description[2])( v404,  *(void *)(v133 + 48) + (void)Description[9] * v325,  v318);
      uint64_t v329 = v403;
      unint64_t v330 = *(void *)(v133 + 56) + *(void *)(v403 + 72) * v325;
      unint64_t v331 = v318;
      uint64_t v332 = v396;
      uint64_t v7 = v407;
      (*(void (**)(unint64_t, unint64_t, uint64_t *))(v403 + 16))(v396, v330, v407);
      unint64_t v333 = &v326[*((int *)v406 + 12)];
      unint64_t v334 = v328;
      TupleTypeMetadata2 = v406;
      ((void (*)(char *, char *, char *))v327[4])(v326, v334, v331);
      (*(void (**)(char *, uint64_t, uint64_t *))(v329 + 32))(v333, v332, v7);
      uint64_t v335 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, void, uint64_t, unint64_t *))(v335 + 56))( v326,  0LL,  1LL,  TupleTypeMetadata2);
      goto LABEL_200;
    }

    uint64_t v349 = (uint64_t)(v323 + 1);
    if (__OFADD__(v323, 1LL)) {
      goto LABEL_229;
    }
    unint64_t v326 = v387;
    if (v349 >= (uint64_t)v391)
    {
      v405 = v323;
LABEL_197:
      uint64_t v335 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v335 + 56))( v387,  1LL,  1LL,  TupleTypeMetadata2);
      v398 = 0LL;
      goto LABEL_200;
    }

    unint64_t v350 = *(void *)&v390[8 * v349];
    if (!v350)
    {
      Swift::Int v361 = v323 + 2;
      if ((uint64_t)(v323 + 2) >= (uint64_t)v391)
      {
        v405 = v323 + 1;
        goto LABEL_197;
      }

      unint64_t v350 = *(void *)&v390[8 * (void)v361];
      if (!v350)
      {
        while (1)
        {
          uint64_t v349 = (uint64_t)(v361 + 1);
          if (__OFADD__(v361, 1LL)) {
            goto LABEL_231;
          }
          unint64_t v350 = *(void *)&v390[8 * v349];
          ++v361;
          if (v350) {
            goto LABEL_196;
          }
        }

        v405 = v376;
        goto LABEL_197;
      }

      uint64_t v349 = (uint64_t)(v323 + 2);
    }

    __break(1u);
    goto LABEL_154;
  }

            uint64_t v7 = a1;
            _StringGuts._foreignGrow(_:)(a3);
LABEL_147:
            uint64_t v180 = *(void *)(v7 + 8);
            uint64_t v194 = v189;
            uint64_t v195 = v158;
            uint64_t v196 = v191;
            uint64_t v197 = v193;
            uint64_t v198 = closure #3 in _StringGuts.replaceSubrange<A>(_:with:);
            uint64_t v199 = 0LL;
            uint64_t v181 = a4;
            uint64_t v26 = a6;
            specialized __StringStorage.replace<A>(from:to:with:replacementCount:)(a6, a2, (uint64_t)&v194, v181);
            swift_bridgeObjectRelease(v193);
            unint64_t v93 = *(void *)(v180 + 24);
            goto LABEL_60;
          }
        }

        __break(1u);
        goto LABEL_153;
      }

  unint64_t v102 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v102);
  uint64_t v103 = specialized Collection.subscript.getter(v93, (uint64_t)v88, v87);
  unint64_t v108 = findInvalidRange #1 (_:) in validateUTF8(_:)(v103, v104, v105, v106);
  uint64_t v332 = 0LL;
  unint64_t v333 = 0xE000000000000000LL;
  if (__OFADD__(v87, 15LL))
  {
    __break(1u);
LABEL_293:
    __break(1u);
    goto LABEL_294;
  }

  int64_t v109 = v107;
  _StringGuts.reserveCapacity(_:)(v87 + 15);
  unint64_t object = 0LL;
  while (1)
  {
    uint64_t v110 = specialized Collection.subscript.getter(v108, (uint64_t)v88, v87);
    uint64_t v114 = v332 & 0xFFFFFFFFFFFFLL;
    if ((v333 & 0x2000000000000000LL) != 0) {
      uint64_t v114 = HIBYTE(v333) & 0xF;
    }
    uint64_t v21 = __OFADD__(v114, v87);
    uint64x2_t v115 = v114 + v87;
    if (v21)
    {
      __break(1u);
LABEL_269:
      __break(1u);
LABEL_270:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }

    uint64_t v116 = v110;
    if (__OFADD__(v115, 3LL)) {
      goto LABEL_269;
    }
    uint64_t v117 = v111;
    unint64_t v118 = v112;
    uint64_t v119 = v113;
    _StringGuts.reserveCapacity(_:)(v115 + 3);
    unint64_t v120 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v116, v117, v118, v119);
    _StringGuts.appendInPlace(_:isASCII:)(v120, v121, 0);
    uint64_t v335 = 3LL;
    id v336 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v336, &v335, &v332);
    uint64_t v122 = specialized Collection.subscript.getter(v109, (uint64_t)v88, v87);
    uint64_t v88 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v122, v123, v124, v125);
    uint64_t v87 = v126;
    unint64_t v127 = validateUTF8(_:)(v88, v126);
    if ((v85 & 1) == 0) {
      break;
    }
    unint64_t v108 = v127;
    int64_t v109 = v128;
    if (!v87) {
      goto LABEL_168;
    }
  }

  _StringGuts.appendInPlace(_:isASCII:)((char *)v88, v87, 0);
LABEL_168:
  uint64_t countAndFlagsBits = v332;
  uint64_t v0 = v333;
LABEL_199:
  unint64_t v3 = v334._countAndFlagsBits;
  uint64_t v5 = (unint64_t)v334._object;
  unint64_t v238 = ((unint64_t)v334._object >> 56) & 0xF;
  else {
    uint64_t v12 = v334._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v12 && (v334._countAndFlagsBits & ~(uint64_t)v334._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v334._object);
    v334._uint64_t countAndFlagsBits = countAndFlagsBits;
    v334._unint64_t object = (void *)v0;
    goto LABEL_250;
  }

  uint64_t v16 = v0 & 0x2000000000000000LL;
  uint64_t v15 = HIBYTE(v0) & 0xF;
  if (((uint64_t)v334._object & 0x2000000000000000LL) != 0 && v16)
  {
    Swift::String::Index v239 = v238 + v15;
    if (v238 + v15 <= 0xF)
    {
      if (v15)
      {
        uint64_t v272 = 0;
        uint64_t v273 = 0LL;
        uint64_t v274 = (unint64_t)v334._object;
        do
        {
          unint64_t v275 = v238 + v273;
          Swift::Int v276 = v273 + 1;
          if (v273 >= 8) {
            uint64_t v277 = v0;
          }
          else {
            uint64_t v277 = countAndFlagsBits;
          }
          unint64_t v278 = v277 >> (v272 & 0x38);
          unint64_t v279 = (8 * v238 + v272) & 0x38;
          uint64_t v280 = (-255LL << v279) - 1;
          char v281 = (unint64_t)v278 << v279;
          uint64_t v282 = v281 | v280 & v274;
          size_t v283 = v281 | v280 & v3;
          if (v275 < 8) {
            unint64_t v3 = v283;
          }
          else {
            uint64_t v274 = v282;
          }
          v272 += 8;
          uint64_t v273 = v276;
        }

        while (v15 != v276);
      }

      else
      {
        uint64_t v274 = (unint64_t)v334._object;
      }

      swift_bridgeObjectRelease((uint64_t)v334._object);
      swift_bridgeObjectRelease(v0);
      uint64_t v287 = 0xA000000000000000LL;
      if (!(v3 & 0x8080808080808080LL | v274 & 0x80808080808080LL)) {
        uint64_t v287 = 0xE000000000000000LL;
      }
      v334._uint64_t countAndFlagsBits = v3;
      v334._unint64_t object = (void *)(v287 & 0xFF00000000000000LL | (v239 << 56) | v274 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_250;
    }

    uint64_t v16 = 1LL;
  }

  unint64_t v331 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v16) {
    uint64_t v14 = HIBYTE(v0) & 0xF;
  }
  else {
    uint64_t v14 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v0, 2LL, v85, v86);
  if ((v0 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(v0, 4LL, v19, v20);
    uint64_t v240 = v14;
    if ((v5 & 0x1000000000000000LL) == 0) {
      goto LABEL_213;
    }
LABEL_280:
    unint64_t v318 = String.UTF8View._foreignCount()();
    uint64_t v241 = v318 + v240;
    if (!__OFADD__(v318, v240)) {
      goto LABEL_214;
    }
LABEL_282:
    __break(1u);
    goto LABEL_283;
  }

LABEL_196:
    v398 = (char *)((v350 - 1) & v350);
    v405 = (char *)v349;
    unint64_t v325 = __clz(__rbit64(v350)) + (v349 << 6);
    goto LABEL_178;
  }

  uint64_t v86 = a1[3];
  uint64_t v87 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v86);
  (*(void (**)(uint64_t *__return_ptr, ValueMetadata *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v87 + 24))( &v416,  &type metadata for _DictionaryCodingKey,  &type metadata for _DictionaryCodingKey,  &protocol witness table for _DictionaryCodingKey,  v86,  v87);
  if (v82)
  {
    if (v81 < 0) {
      uint64_t v91 = v81;
    }
    else {
      uint64_t v91 = v81 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v92 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v93 = (unint64_t)swift_allocObject(v92, 0xE8uLL, 7uLL);
    v383 = 0LL;
    uint64_t v94 = 0LL;
    unint64_t v95 = 0LL;
    *(void *)(v93 + 208) = v91;
    *(void *)(v93 + 216) = 0LL;
    *(_OWORD *)(v93 + 16) = 0u;
    *(_OWORD *)(v93 + 32) = 0u;
    *(_OWORD *)(v93 + 48) = 0u;
    *(_OWORD *)(v93 + 64) = 0u;
    *(_OWORD *)(v93 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v93 + 96) = 0u;
    *(_OWORD *)(v93 + 112) = 0u;
    *(_OWORD *)(v93 + 128) = 0u;
    *(_OWORD *)(v93 + 144) = 0u;
    *(_OWORD *)(v93 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v93 + 176) = 0u;
    *(_OWORD *)(v93 + 192) = 0u;
    *(void *)(v93 + 224) = 0LL;
    unint64_t v96 = v93 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v194 = -1LL << *(_BYTE *)(v81 + 32);
    uint64_t v94 = ~v194;
    uint64_t v195 = *(void *)(v81 + 64);
    v383 = (char *)(v81 + 64);
    uint64_t v196 = -v194;
    if (v196 < 64) {
      uint64_t v197 = ~(-1LL << v196);
    }
    else {
      uint64_t v197 = -1LL;
    }
    unint64_t v95 = v197 & v195;
    unint64_t v96 = v81;
  }

  uint64_t v198 = v403;
  v382 = (char *)((v96 & 0x7FFFFFFFFFFFFFFFLL) + 16);
  v387 = (char *)(v96 & 0x7FFFFFFFFFFFFFFFLL);
  v381 = (char *)((v96 & 0x7FFFFFFFFFFFFFFFLL) + 80);
  uint64_t v375 = (char *)v94;
  v385 = (swift *)((unint64_t)(v94 + 64) >> 6);
  uint64_t v374 = (char *)v385 - 1;
  swift_bridgeObjectRetain(v81, v88, v89, v90);
  uint64_t v202 = 0LL;
  v384 = (swift *)&unk_189B8D230;
  unint64_t v203 = (uint64_t *)i;
  v388 = (uint64_t *)v96;
  uint64_t v204 = v85;
  while (1)
  {
    size_t v205 = v392;
    Swift::String v206 = v391;
    v397 = (char *)v95;
    v395 = (char *)v202;
    if ((v96 & 0x8000000000000000LL) == 0)
    {
      if (v95)
      {
        uint64_t v207 = v198;
        v398 = (char *)((v95 - 1) & v95);
        unint64_t v208 = __clz(__rbit64(v95)) | (v202 << 6);
        uint64_t v209 = v202;
        unint64_t v210 = v390;
      }

      else
      {
        uint64_t v209 = v202 + 1;
        if (__OFADD__(v202, 1LL)) {
          goto LABEL_222;
        }
        unint64_t v210 = v390;
        if (v209 >= (uint64_t)v385)
        {
          uint64_t v209 = v202;
          uint64_t v233 = v394;
LABEL_101:
          uint64_t v219 = *(TupleTypeMetadata2 - 1);
          (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v219 + 56))( v390,  1LL,  1LL,  TupleTypeMetadata2);
          v398 = 0LL;
          goto LABEL_105;
        }

        unint64_t v234 = *(void *)&v383[8 * v209];
        uint64_t v233 = v394;
        if (!v234)
        {
          uint64_t v253 = v202 + 2;
          unint64_t v234 = *(void *)&v383[8 * v253];
          if (!v234)
          {
            while (1)
            {
              uint64_t v209 = v253 + 1;
              if (__OFADD__(v253, 1LL)) {
                goto LABEL_227;
              }
              unint64_t v234 = *(void *)&v383[8 * v209];
              ++v253;
              if (v234) {
                goto LABEL_100;
              }
            }

            uint64_t v209 = (uint64_t)v374;
            goto LABEL_101;
          }

          uint64_t v209 = v202 + 2;
        }

              v610 = v291;
              uint64_t v402 = v621;
              Swift::String::Index v171 = v613;
              uint64_t v403 = v615;
              v404 = v618;
              v611 = *(const char **)(v618 + 136);
              v405 = ((uint64_t (*)(uint64_t, uint64_t))v611)(v621, v618);
              v406 = *(void (**)(uint64_t, uint64_t))(v404 + 120);
              v406(v402, v404);
              v605 = (uint64_t *)*((void *)v171 + 18);
              v407 = ((uint64_t (*)(uint64_t, char *))v605)(v236, v171);
              uint64_t v67 = *(void *)(*(void *)&v607 + 8LL);
              ((void (*)(char *, uint64_t))v67)(v403, v236);
              v617 = 52 - v405 - v407;
              LOBYTE(v405) = (*((uint64_t (**)(uint64_t))v616 + 49))(v402);
              v408 = v614;
              v409 = v612;
              uint64_t v410 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v411 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v410 + 8);
              v619 = (char *)v406;
              v620 = v67;
              if ((v405 & 1) != 0)
              {
                __int128 v412 = v608;
                v411(&qword_18180BE70, 512LL, v409, v410);
                uint64_t v67 = (unint64_t)v615;
                v609 = (void (*)(void, void, void))*((void *)v408 + 3);
                v609(v412, v236, v408);
                uint64_t v413 = ((uint64_t (*)(uint64_t, uint64_t))v611)(v402, v404);
                uint64_t v414 = v602;
                v406(v402, v404);
                uint64_t v415 = ((uint64_t (*)(uint64_t, char *))v605)(v236, v171);
                uint64_t v416 = (void (*)(unint64_t, uint64_t))v620;
                v417 = ((uint64_t (*)(char *, uint64_t))v620)(v414, v236);
                v624 = v415 + v413;
                v418 = (void (*)(unint64_t, unint64_t *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v171 + 32);
                v421 = lazy protocol witness table accessor for type Int and conformance Int(v417, v419, v420);
                v422 = v596;
                v418(v67, &v624, &type metadata for Int, v421, v236, v171);
                v416(v67, v236);
                uint64_t v123 = (char *)v67;
              }

              else
              {
                v423 = v608;
                v411(&qword_18180BE68, 256LL, v409, v410);
                v422 = v596;
                v609 = (void (*)(void, void, void))*((void *)v408 + 3);
                v609(v423, v236, v408);
                uint64_t v123 = v615;
              }

              v424 = v597;
              v425 = v617;
              if ((v617 & 0x8000000000000000LL) == 0)
              {
                ((void (*)(uint64_t, uint64_t))v619)(v621, v618);
                v426 = v590;
                (*((void (**)(char *, char *, uint64_t, char *))v171 + 28))(v422, v123, v236, v171);
                v427 = (void (*)(char *, uint64_t))v620;
                ((void (*)(char *, uint64_t))v620)(v123, v236);
                v427(v422, v236);
                v428 = (uint64_t (*)(uint64_t, char *))*((void *)v171 + 8);
                if ((v428(v236, v171) & 1) != 0)
                {
                  v429 = v580;
                  (*(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL))(v580, v426, v236);
                  v430 = v614;
                  v431 = v612;
                  v432 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v433 = v608;
                  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v432 + 8))( &qword_18180BE68,  256LL,  v431,  v432);
                  v434 = v433;
                  uint64_t v123 = v615;
                  v609(v434, v236, v430);
                  LOBYTE(v43_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v171 + 4)
                                                                                                + 8LL)
                                                                                    + 32LL))( v429,  v123,  v236);
                  v435 = (void (*)(char *, uint64_t))v620;
                  ((void (*)(char *, uint64_t))v620)(v123, v236);
                  v435(v429, v236);
                  Swift::String::Index v171 = v613;
                  v425 = v617;
                }

                v436 = (uint64_t (*)(uint64_t, char *))*((void *)v171 + 16);
                if (v436(v236, v171) < 64) {
                  goto LABEL_232;
                }
                v437 = *(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL);
                v438 = v582;
                v437(v582, v426, v236);
                v624 = -1LL;
                v439 = v428(v236, v171);
                v440 = v438;
                LOBYTE(v438) = v439;
                v441 = v436(v236, v171);
                if ((v438 & 1) != 0)
                {
                  if (v441 <= 64)
                  {
                    v444 = v614;
                    v445 = v612;
                    v446 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    v447 = v608;
                    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v446 + 8))( &qword_18180BE68,  256LL,  v445,  v446);
                    v448 = v447;
                    v440 = v582;
                    v609(v448, v236, v444);
                    LOBYTE(v444) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v171 + 4)
                                                                                                  + 8LL)
                                                                                      + 40LL))( v440,  v123,  v236);
                    v449 = (void (*)(char *, uint64_t))v620;
                    ((void (*)(char *, uint64_t))v620)(v123, v236);
                    v450 = v624;
                    v451 = v566;
                    v437(v566, v440, v236);
                    if ((v444 & 1) == 0)
                    {
                      v449(v451, v236);
                      v426 = v590;
                      v425 = v617;
LABEL_231:
                      v449(v440, v236);
                      Swift::String::Index v171 = v613;
LABEL_232:
                      v495 = (*((uint64_t (**)(uint64_t, char *))v171 + 15))(v236, v171);
                      v496 = v236;
                      ((void (*)(char *, uint64_t))v620)(v426, v236);
                      if (v425 >= 0x40) {
                        v497 = 0LL;
                      }
                      else {
                        v497 = v495 << v425;
                      }
                      goto LABEL_238;
                    }

                    v452 = (*((uint64_t (**)(uint64_t, char *))v171 + 15))(v236, v171);
                    v449(v451, v236);
                    v453 = v450 >= v452;
                    v426 = v590;
LABEL_225:
                    v425 = v617;
                    if (!v453) {
                      goto LABEL_228;
                    }
                    goto LABEL_231;
                  }
                }

                else if (v441 <= 64)
                {
                  v437(v123, v440, v236);
                  v493 = (*((uint64_t (**)(uint64_t, char *))v171 + 15))(v236, v171);
                  v449 = (void (*)(char *, uint64_t))v620;
                  ((void (*)(char *, uint64_t))v620)(v123, v236);
                  v453 = v624 >= v493;
                  goto LABEL_225;
                }

                v489 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v171 + 12);
                v490 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v441, v442, v443);
                v489(&v624, &type metadata for UInt64, v490, v236, v171);
                LOBYTE(v489) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v171 + 4)
                                                                                              + 8LL)
                                                                                  + 16LL))( v123,  v440,  v236);
                v449 = (void (*)(char *, uint64_t))v620;
                ((void (*)(char *, uint64_t))v620)(v123, v236);
                v425 = v617;
                goto LABEL_231;
              }

              v454 = v602;
              ((void (*)(uint64_t, uint64_t))v619)(v621, v618);
              (*((void (**)(char *, char *, uint64_t, char *))v171 + 28))(v422, v454, v236, v171);
              v455 = v454;
              v456 = v422;
              uint64_t v69 = (unint64_t *)v620;
              ((void (*)(char *, uint64_t))v620)(v455, v236);
              v457 = ((uint64_t (*)(char *, uint64_t))v69)(v456, v236);
              if (!__OFSUB__(0LL, v425))
              {
                v624 = -(uint64_t)v425;
                v460 = (void (*)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v171 + 30);
                v461 = lazy protocol witness table accessor for type Int and conformance Int(v457, v458, v459);
                v460(v123, &v624, &type metadata for Int, v461, v236, v171);
                ((void (*)(char *, uint64_t))v69)(v123, v236);
                v462 = (uint64_t (*)(uint64_t, char *))*((void *)v171 + 8);
                v463 = v462(v236, v171);
                v464 = v614;
                if ((v463 & 1) != 0)
                {
                  v465 = v571;
                  (*(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL))(v571, v424, v236);
                  v466 = v612;
                  v467 = swift_getAssociatedConformanceWitness( (uint64_t)v464,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v468 = v608;
                  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v467 + 8))( &qword_18180BE68,  256LL,  v466,  v467);
                  v469 = v468;
                  uint64_t v123 = v615;
                  v609(v469, v236, v464);
                  v470 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v171 + 4) + 8LL)
                                                                            + 32LL))( v465,  v123,  v236);
                  v471 = (void (*)(char *, uint64_t))v620;
                  ((void (*)(char *, uint64_t))v620)(v123, v236);
                  if ((v470 & 1) == 0) {
                    goto LABEL_266;
                  }
                  v471(v465, v236);
                  Swift::String::Index v171 = v613;
                }

                v472 = (uint64_t (*)(uint64_t, char *))*((void *)v171 + 16);
                if (v472(v236, v171) < 64) {
                  goto LABEL_237;
                }
                v473 = *(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL);
                v474 = v576;
                v473(v576, v424, v236);
                v624 = -1LL;
                v475 = v462(v236, v171);
                v476 = v474;
                LOBYTE(v474) = v475;
                v477 = v472(v236, v171);
                if ((v474 & 1) != 0)
                {
                  if (v477 <= 64)
                  {
                    v480 = v614;
                    v481 = v612;
                    v482 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    v483 = v608;
                    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v482 + 8))( &qword_18180BE68,  256LL,  v481,  v482);
                    v484 = v483;
                    v476 = v576;
                    v609(v484, v236, v480);
                    LOBYTE(v48_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v171 + 4)
                                                                                                  + 8LL)
                                                                                      + 40LL))( v476,  v123,  v236);
                    v485 = (void (*)(char *, uint64_t))v620;
                    ((void (*)(char *, uint64_t))v620)(v123, v236);
                    v486 = v624;
                    v487 = v562;
                    v473(v562, v476, v236);
                    if ((v480 & 1) != 0)
                    {
                      v488 = (*((uint64_t (**)(uint64_t, char *))v171 + 15))(v236, v171);
                      v485(v487, v236);
                      v453 = v486 >= v488;
                      v424 = v597;
                      if (!v453) {
                        goto LABEL_228;
                      }
                    }

                    else
                    {
                      v485(v487, v236);
                      v424 = v597;
                    }

                    goto LABEL_236;
                  }
                }

                else if (v477 <= 64)
                {
                  v473(v123, v476, v236);
                  v494 = (*((uint64_t (**)(uint64_t, char *))v171 + 15))(v236, v171);
                  v485 = (void (*)(char *, uint64_t))v620;
                  ((void (*)(char *, uint64_t))v620)(v123, v236);
                  if (v624 < v494)
                  {
LABEL_228:
                    uint64_t v307 = 3455LL;
LABEL_229:
                    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  v307,  0);
                  }

                  goto LABEL_236;
                }

                v491 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v171 + 12);
                v492 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v477, v478, v479);
                v491(&v624, &type metadata for UInt64, v492, v236, v171);
                LOBYTE(v491) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v171 + 4)
                                                                                              + 8LL)
                                                                                  + 16LL))( v123,  v476,  v236);
                v485 = (void (*)(char *, uint64_t))v620;
                ((void (*)(char *, uint64_t))v620)(v123, v236);
LABEL_236:
                v485(v476, v236);
                Swift::String::Index v171 = v613;
LABEL_237:
                v497 = (*((uint64_t (**)(uint64_t, char *))v171 + 15))(v236, v171);
                v496 = v236;
                ((void (*)(char *, uint64_t))v620)(v424, v236);
LABEL_238:
                v498 = 52LL;
                v500 = v611;
                v499 = v612;
                v501 = (__int16)v610;
LABEL_243:
                v502 = v621;
                v610 = (uint64_t (*)(void))*((void *)v616 + 21);
                v503 = ((unint64_t)(v501 & 0x7FF) << 52) | (v610(v621) << 63) | v497 & 0xFFFFFFFFFFFFFLL;
                if (v498 < ((uint64_t (*)(uint64_t, uint64_t))v500)(v502, v618))
                {
                  v504 = v614;
                  v505 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v496,  v499,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v506 = *(void (**)(uint64_t *, uint64_t, uint64_t))(v505 + 8);
                  v507 = v608;
                  v611 = (const char *)v505;
                  v506(&qword_18180BE70, 512LL, v499);
                  v508 = (uint64_t (*)(char *, uint64_t, const char *))*((void *)v504 + 3);
                  v509 = v508(v507, v496, v504);
                  if (!__OFSUB__(0LL, v617))
                  {
                    v607 = *(double *)&v503;
                    v605 = (uint64_t *)v497;
                    v624 = -v617;
                    v513 = (void (*)(uint64_t *, uint64_t, uint64_t, const char *))v506;
                    v609 = (void (*)(void, void, void))v506;
                    v514 = v613;
                    v515 = (void (*)(char *, uint64_t))v620;
                    v617 = (uint64_t)v508;
                    v516 = (void (*)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, char *))*((void *)v613 + 32);
                    v517 = lazy protocol witness table accessor for type Int and conformance Int(v509, v510, v511);
                    v516(v123, &v624, &type metadata for Int, v517, v496, v514);
                    v515(v123, v496);
                    v518 = v496;
                    ((void (*)(uint64_t, uint64_t))v619)(v621, v618);
                    v513(&qword_18180BE70, 512LL, v499, v611);
                    v519 = v595;
                    v520 = v507;
                    ((void (*)(char *, uint64_t, char *))v617)(v507, v518, v614);
                    v521 = v602;
                    v522 = v604;
                    (*(void (**)(char *, char *, uint64_t))(*(void *)(v594 + 8) + 40LL))(v604, v519, v518);
                    v515(v519, v518);
                    v523 = v600;
                    (*((void (**)(char *, char *, uint64_t, char *))v514 + 24))(v123, v521, v518, v514);
                    v515(v521, v518);
                    v515(v123, v518);
                    ((void (*)(void *, uint64_t, uint64_t, const char *))v609)( &unk_18180BE80,  768LL,  v499,  v611);
                    ((void (*)(char *, uint64_t, char *))v617)(v520, v518, v614);
                    v524 = (void (*)(char *, char *, uint64_t, char *))*((void *)v514 + 19);
                    v524(v522, v521, v518, v514);
                    v515(v521, v518);
                    v525 = *(void *)(*((void *)v514 + 4) + 8LL);
                    v526 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v525 + 16))( v523,  v123,  v518,  v525);
                    v515(v123, v518);
                    v527 = v608;
                    if ((v526 & 1) != 0)
                    {
                      v515(v523, v518);
                      v515(v604, v518);
                      uint64_t result = 0LL;
                      *(double *)v606 = v607;
                      return result;
                    }

                    uint64_t v4 = v607;
                    if ((((uint64_t (*)(uint64_t, char *))v610)(v621, v616) & 1) != 0)
                    {
                      v529 = 0.0 - v4;
                      v528 = v603;
                      if (0.0 - v4 < INFINITY) {
                        *(void *)&v529 += (*(uint64_t *)&v529 >> 63) | 1;
                      }
                      uint64_t v5 = -v529;
                    }

                    else
                    {
                      uint64_t v5 = v4 + 0.0;
                      v528 = v603;
                      if (v4 + 0.0 < INFINITY) {
                        *(void *)&v5 += (*(uint64_t *)&v5 >> 63) | 1;
                      }
                    }

                    ((void (*)(void *, uint64_t))v609)(&unk_18180BE80, 768LL);
                    v530 = v602;
                    ((void (*)(char *, unint64_t *, char *))v617)(v527, v528, v614);
                    v531 = v615;
                    v532 = v604;
                    v524(v604, v530, (uint64_t)v528, v613);
                    v515(v530, (uint64_t)v528);
                    v515(v532, (uint64_t)v528);
                    v533 = v600;
                    v534 = (*(uint64_t (**)(char *, char *, unint64_t *, uint64_t))(v525 + 40))( v600,  v531,  v528,  v525);
                    v515(v531, (uint64_t)v528);
                    v515(v533, (uint64_t)v528);
                    uint64_t result = 0LL;
                    if ((v534 & 1) != 0)
                    {
                      *(double *)v606 = v5;
                      return result;
                    }

                    goto LABEL_271;
                  }

                  __break(1u);
                  goto LABEL_268;
                }

                *v606 = v503;
                return 1LL;
              }

                      v639 = (char *)v287;
                      uint64_t v402 = v649;
                      uint64_t v403 = v642;
                      v404 = v644;
                      v640 = (char *)v644[17];
                      v405 = ((uint64_t (*)(uint64_t, unint64_t *))v640)(v649, v644);
                      v646 = v404[15];
                      ((void (*)(uint64_t, unint64_t *))v646)(v402, v404);
                      v406 = v651;
                      v407 = v634;
                      v631 = *(void *)(v651 + 144);
                      v408 = ((uint64_t (*)(unint64_t *, unint64_t))v631)(v634, v651);
                      uint64_t v164 = *(char **)(v636 + 8);
                      ((void (*)(char *, unint64_t *))v164)(v403, v407);
                      v645 = 10 - v405 - v408;
                      LOBYTE(v405) = v643[49](v402);
                      v409 = v637;
                      uint64_t v410 = v641;
                      uint64_t v411 = swift_getAssociatedConformanceWitness( (uint64_t)v637,  (uint64_t)v407,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                      __int128 v412 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v411 + 8);
                      v648 = v164;
                      if ((v405 & 1) != 0)
                      {
                        uint64_t v413 = v647;
                        v412(&qword_18180BE70, 512LL, v410, v411);
                        v638 = (void (*)(void, void, void))*((void *)v409 + 3);
                        v638(v413, v407, v409);
                        uint64_t v414 = v644;
                        uint64_t v415 = ((uint64_t (*)(uint64_t, unint64_t *))v640)(v402, v644);
                        uint64_t v164 = v633;
                        ((void (*)(uint64_t, unint64_t *))v646)(v402, v414);
                        uint64_t v416 = ((uint64_t (*)(unint64_t *, unint64_t))v631)(v407, v406);
                        v417 = (void (*)(char *, unint64_t *))v648;
                        v418 = ((uint64_t (*)(char *, unint64_t *))v648)(v164, v407);
                        v653 = v416 + v415;
                        v419 = *(void (**)(char *, int64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v406 + 256);
                        v422 = lazy protocol witness table accessor for type Int and conformance Int(v418, v420, v421);
                        v419(v403, &v653, &type metadata for Int, v422, v407, v406);
                        v417(v403, v407);
                      }

                      else
                      {
                        v423 = v647;
                        v412(&qword_18180BE68, 256LL, v410, v411);
                        v638 = (void (*)(void, void, void))*((void *)v409 + 3);
                        v638(v423, v407, v409);
                      }

                      uint64_t v265 = v409;
                      v424 = (char *)v627;
                      v425 = v645;
                      if ((v645 & 0x8000000000000000LL) == 0)
                      {
                        ((void (*)(uint64_t, unint64_t *))v646)(v649, v644);
                        v426 = v651;
                        v427 = v618;
                        v428 = v632;
                        (*(void (**)(char *, char *, unint64_t *, unint64_t))(v651 + 224))( v632,  v403,  v407,  v651);
                        v429 = v403;
                        v430 = v427;
                        v431 = (void (*)(char *, unint64_t *))v648;
                        ((void (*)(char *, unint64_t *))v648)(v429, v407);
                        v431(v428, v407);
                        v432 = *(uint64_t (**)(unint64_t *, unint64_t))(v426 + 64);
                        v433 = v432(v407, v426);
                        v434 = v647;
                        if ((v433 & 1) != 0)
                        {
                          v435 = v609;
                          (*(void (**)(char *, char *, unint64_t *))(v636 + 16))(v609, v427, v407);
                          v436 = v641;
                          v437 = swift_getAssociatedConformanceWitness( (uint64_t)v265,  (uint64_t)v407,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v437 + 8))( &qword_18180BE68,  256LL,  v436,  v437);
                          v438 = v642;
                          v638(v434, v407, v265);
                          v439 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v426 + 32) + 8LL)
                                                                                               + 32LL))( v435,  v438,  v407);
                          v440 = (void (*)(char *, unint64_t *))v648;
                          ((void (*)(char *, unint64_t *))v648)(v438, v407);
                          if ((v439 & 1) == 0) {
                            goto LABEL_268;
                          }
                          v440(v435, v407);
                          v426 = v651;
                        }

                        v441 = *(uint64_t (**)(unint64_t *, unint64_t))(v426 + 128);
                        if (v441(v407, v426) < 16)
                        {
LABEL_232:
                          v398 = v265;
                          v508 = (*(uint64_t (**)(unint64_t *, unint64_t))(v426 + 120))( v407,  v426);
                          ((void (*)(char *, unint64_t *))v648)(v430, v407);
                          uint64_t v329 = v641;
                          if (v425 < 0x10) {
                            v509 = (v508 << v425);
                          }
                          else {
                            v509 = 0LL;
                          }
                          v510 = 10LL;
                          v468 = v651;
                          unint64_t v396 = v643;
                          v511 = v644;
                          v474 = (char)v639;
                          goto LABEL_243;
                        }

                        v442 = *(void (**)(char *, char *, unint64_t *))(v636 + 16);
                        v443 = v608;
                        v442(v608, v430, v407);
                        LOWORD(v653) = -1;
                        v444 = v432(v407, v426);
                        v445 = v426;
                        v446 = v444;
                        v447 = v441(v407, v445);
                        if ((v446 & 1) != 0)
                        {
                          v450 = v642;
                          v451 = (void (*)(char *, unint64_t *))v648;
                          if (v447 <= 16)
                          {
                            v452 = v641;
                            v453 = swift_getAssociatedConformanceWitness( (uint64_t)v265,  (uint64_t)v407,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v453 + 8))( &qword_18180BE68,  256LL,  v452,  v453);
                            v638(v434, v407, v265);
                            v454 = v651;
                            v455 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v651 + 32) + 8LL)
                                                                                                 + 40LL))( v443,  v450,  v407);
                            v451(v450, v407);
                            v456 = (unsigned __int16)v653;
                            v457 = v595;
                            v442(v595, v443, v407);
                            if ((v455 & 1) == 0)
                            {
                              v451(v457, v407);
                              uint64_t v265 = v637;
                              v430 = v618;
                              v425 = v645;
LABEL_231:
                              v451(v443, v407);
                              v426 = v651;
                              goto LABEL_232;
                            }

                            v458 = (*(uint64_t (**)(unint64_t *, unint64_t))(v454 + 120))( v407,  v454);
                            v451(v457, v407);
                            v459 = v456 >= v458;
                            uint64_t v265 = v637;
LABEL_224:
                            v430 = v618;
                            v425 = v645;
                            if (!v459) {
                              goto LABEL_228;
                            }
                            goto LABEL_231;
                          }
                        }

                        else
                        {
                          v450 = v642;
                          v451 = (void (*)(char *, unint64_t *))v648;
                          if (v447 <= 16)
                          {
                            v442(v642, v443, v407);
                            v506 = (*(uint64_t (**)(unint64_t *))(v651 + 120))(v407);
                            v451(v450, v407);
                            v459 = (unsigned __int16)v653 >= v506;
                            goto LABEL_224;
                          }
                        }

                        v500 = v651;
                        v501 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v651 + 96);
                        v502 = lazy protocol witness table accessor for type UInt16 and conformance UInt16( v447,  v448,  v449);
                        v501(&v653, &type metadata for UInt16, v502, v407, v500);
                        LOBYTE(v501) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v500 + 32) + 8LL) + 16LL))( v450,  v443,  v407);
                        v451(v450, v407);
                        v430 = v618;
                        v425 = v645;
                        goto LABEL_231;
                      }

                      uint64_t v316 = (unint64_t)v633;
                      ((void (*)(uint64_t, unint64_t *))v646)(v649, v644);
                      uint64_t v159 = (uint64_t)v632;
                      v460 = v407;
                      (*(void (**)(char *, unint64_t, unint64_t *))(v651 + 224))( v632,  v316,  v407);
                      v461 = v407;
                      uint64_t v128 = (uint64_t)v648;
                      ((void (*)(unint64_t, unint64_t *))v648)(v316, v461);
                      v462 = ((uint64_t (*)(uint64_t, unint64_t *))v128)(v159, v460);
                      uint64_t v287 = -(uint64_t)v425;
                      uint64_t v69 = v647;
                      if (!__OFSUB__(0LL, v425))
                      {
                        v653 = -(uint64_t)v425;
                        v465 = *(void (**)(char *, int64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v651 + 240);
                        v466 = lazy protocol witness table accessor for type Int and conformance Int(v462, v463, v464);
                        v467 = v614;
                        v465(v403, &v653, &type metadata for Int, v466, v460, v651);
                        v468 = v651;
                        v469 = v403;
                        v470 = v467;
                        ((void (*)(char *, unint64_t *))v128)(v469, v460);
                        v471 = *(uint64_t (**)(unint64_t *, unint64_t))(v468 + 64);
                        v472 = v471(v460, v468);
                        v473 = (uint64_t)v460;
                        v474 = (char)v639;
                        if ((v472 & 1) != 0)
                        {
                          (*(void (**)(char *, char *, unint64_t *))(v636 + 16))(v424, v467, v460);
                          v475 = (uint64_t)v460;
                          v476 = v641;
                          v477 = swift_getAssociatedConformanceWitness( (uint64_t)v265,  v475,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v477 + 8))( &qword_18180BE68,  256LL,  v476,  v477);
                          v478 = v642;
                          v638(v69, v473, v265);
                          v479 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v468 + 32)
                                                                                                + 8LL)
                                                                                    + 32LL))( v424,  v478,  v473);
                          v480 = (void (*)(char *, uint64_t))v648;
                          ((void (*)(char *, uint64_t))v648)(v478, v473);
                          if ((v479 & 1) == 0) {
                            goto LABEL_268;
                          }
                          v480(v424, v473);
                          v468 = v651;
                        }

                        v481 = *(uint64_t (**)(uint64_t, unint64_t))(v468 + 128);
                        if (v481(v473, v468) < 16)
                        {
LABEL_238:
                          v398 = v265;
                          v509 = (*(uint64_t (**)(uint64_t, unint64_t))(v468 + 120))(v473, v468);
                          ((void (*)(char *, uint64_t))v648)(v470, v473);
                          v510 = 10LL;
                          unint64_t v396 = v643;
                          v511 = v644;
                          uint64_t v329 = v641;
LABEL_243:
                          v512 = (unsigned int (*)(uint64_t))v396[21];
                          v513 = v649;
                          v514 = ((v474 & 0x1F) << 10) | (v512(v649) << 15) | v509 & 0x3FF;
                          if (v510 < ((uint64_t (*)(uint64_t, unint64_t *))v640)(v513, v511))
                          {
                            v638 = (void (*)(void, void, void))v512;
                            v636 = v509;
                            v515 = v634;
                            v516 = swift_getAssociatedConformanceWitness( (uint64_t)v398,  (uint64_t)v634,  v329,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                            v517 = v647;
                            v640 = *(char **)(v516 + 8);
                            ((void (*)(uint64_t *, uint64_t, uint64_t, unint64_t))v640)( &qword_18180BE70,  512LL,  v329,  v516);
                            v518 = (uint64_t (*)(unint64_t *, unint64_t *, const char *))*((void *)v398 + 3);
                            v519 = v642;
                            v520 = v518(v517, v515, v398);
                            v524 = -v645;
                            if (!__OFSUB__(0LL, v645))
                            {
                              LODWORD(v645) = v514;
                              v653 = v524;
                              v525 = v398;
                              v526 = v329;
                              v527 = (void (*)(unint64_t *, unint64_t *, const char *))v518;
                              v639 = (char *)v518;
                              v528 = v526;
                              v529 = v516;
                              v530 = *(void (**)(char *, int64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v468 + 256);
                              v531 = lazy protocol witness table accessor for type Int and conformance Int( v520,  v521,  v522);
                              v532 = v630;
                              v530(v519, &v653, &type metadata for Int, v531, v515, v468);
                              ((void (*)(char *, unint64_t *))v648)(v519, v515);
                              ((void (*)(uint64_t, unint64_t *))v646)(v649, v644);
                              ((void (*)(uint64_t *, uint64_t, uint64_t, unint64_t))v640)( &qword_18180BE70,  512LL,  v528,  v529);
                              v533 = v626;
                              v527(v647, v515, v525);
                              v534 = v633;
                              (*(void (**)(char *, char *, unint64_t *))(*(void *)(v624 + 8) + 40LL))( v532,  v533,  v515);
                              ((void (*)(char *, unint64_t *))v648)(v533, v515);
                              v535 = v625;
                              (*(void (**)(char *, char *, unint64_t *, unint64_t))(v468 + 192))( v519,  v534,  v515,  v468);
                              ((void (*)(char *, unint64_t *))v648)(v534, v515);
                              ((void (*)(char *, unint64_t *))v648)(v519, v515);
                              v646 = v529;
                              v536 = v640;
                              ((void (*)(void *, uint64_t, uint64_t, unint64_t))v640)( &unk_18180BE80,  768LL,  v528,  v529);
                              ((void (*)(unint64_t *, unint64_t *, char *))v639)( v647,  v515,  v637);
                              v537 = v532;
                              v538 = v532;
                              v539 = *(void (**)(char *, char *, unint64_t *, unint64_t))(v468 + 152);
                              v539(v538, v534, v515, v468);
                              v540 = v534;
                              v541 = v535;
                              v542 = (void (*)(char *, unint64_t *))v648;
                              ((void (*)(char *, unint64_t *))v648)(v540, v515);
                              v543 = *(void *)(*(void *)(v468 + 32) + 8LL);
                              v544 = (*(uint64_t (**)(char *, char *, unint64_t *, uint64_t))(v543 + 16))( v541,  v519,  v515,  v543);
                              v542(v519, v515);
                              if ((v544 & 1) != 0)
                              {
                                v542(v541, v515);
                                v542(v537, v515);
                                uint64_t result = 0LL;
                                *v635 = v645;
                                return result;
                              }

                              _S8 = *(float *)&v645;
                              v545 = ((uint64_t (*)(uint64_t, uint64_t (**)(void)))v638)( v649,  v643);
                              __asm { FCVT            S0, H8 }

                              if ((v545 & 1) != 0)
                              {
                                _S0 = 0.0 - _S0;
                                __asm
                                {
                                  FCVT            H0, S0
                                  FCVT            S1, H0
                                }

                                v551 = v634;
                                v552 = v637;
                                v553 = v630;
                                if (_S1 < INFINITY) {
                                  _H0 += (_H0 >> 15) | 1;
                                }
                                __asm { FCVT            S0, H0 }

                                _S0 = -_S0;
                                __asm { FCVT            H9, S0 }
                              }

                              else
                              {
                                _S0 = _S0 + 0.0;
                                __asm
                                {
                                  FCVT            H9, S0
                                  FCVT            S0, H9
                                }

                                v551 = v634;
                                v552 = v637;
                                v553 = v630;
                                if (_S0 < INFINITY) {
                                  LODWORD(_S9) += (SLOWORD(_S9) >> 15) | 1;
                                }
                              }

                              v559 = v647;
                              ((void (*)(void *, uint64_t))v536)(&unk_18180BE80, 768LL);
                              v560 = v633;
                              ((void (*)(unint64_t *, unint64_t *, const char *))v639)( v559,  v551,  v552);
                              v561 = v642;
                              v539(v553, v560, v551, v651);
                              v562 = v560;
                              v563 = (void (*)(char *, unint64_t *))v648;
                              ((void (*)(char *, unint64_t *))v648)(v562, v551);
                              v563(v553, v551);
                              v564 = (*(uint64_t (**)(char *, char *, unint64_t *, uint64_t))(v543 + 40))( v541,  v561,  v551,  v543);
                              v563(v561, v551);
                              v563(v541, v551);
                              uint64_t result = 0LL;
                              if ((v564 & 1) != 0)
                              {
                                *v635 = LOWORD(_S9);
                                return result;
                              }

                              goto LABEL_272;
                            }

                            __break(1u);
                            goto LABEL_270;
                          }

                          *v635 = v514;
                          return 1LL;
                        }

                        v482 = *(void (**)(char *, char *, uint64_t))(v636 + 16);
                        v483 = v600;
                        v482(v600, v470, v473);
                        LOWORD(v653) = -1;
                        v484 = v471((unint64_t *)v473, v468);
                        v485 = v468;
                        v486 = v484;
                        v487 = v481(v473, v485);
                        if ((v486 & 1) != 0)
                        {
                          v490 = v642;
                          v491 = (void (*)(char *, uint64_t))v648;
                          if (v487 <= 16)
                          {
                            v492 = v641;
                            v493 = swift_getAssociatedConformanceWitness( (uint64_t)v265,  v473,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v493 + 8))( &qword_18180BE68,  256LL,  v492,  v493);
                            v638(v69, v473, v265);
                            v494 = v651;
                            v495 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v651 + 32)
                                                                                                  + 8LL)
                                                                                      + 40LL))( v483,  v490,  v473);
                            v491(v490, v473);
                            v496 = (unsigned __int16)v653;
                            v497 = v591;
                            v482(v591, v483, v473);
                            if ((v495 & 1) != 0)
                            {
                              v498 = (*(uint64_t (**)(uint64_t, unint64_t))(v494 + 120))(v473, v494);
                              v491(v497, v473);
                              v499 = v496 >= v498;
                              uint64_t v265 = v637;
                              goto LABEL_227;
                            }

                            v491(v497, v473);
                            uint64_t v265 = v637;
                            v470 = v614;
                            v474 = (char)v639;
LABEL_237:
                            v491(v483, v473);
                            v468 = v651;
                            goto LABEL_238;
                          }
                        }

                        else
                        {
                          v490 = v642;
                          v491 = (void (*)(char *, uint64_t))v648;
                          if (v487 <= 16)
                          {
                            v482(v642, v483, v473);
                            v507 = (*(uint64_t (**)(uint64_t))(v651 + 120))(v473);
                            v491(v490, v473);
                            v499 = (unsigned __int16)v653 >= v507;
LABEL_227:
                            v470 = v614;
                            v474 = (char)v639;
                            if (!v499)
                            {
LABEL_228:
                              char v305 = 3455LL;
LABEL_229:
                              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  v305,  0);
                            }

                            goto LABEL_237;
                          }
                        }

                        v503 = v651;
                        v504 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))(v651 + 96);
                        v505 = lazy protocol witness table accessor for type UInt16 and conformance UInt16( v487,  v488,  v489);
                        v504(&v653, &type metadata for UInt16, v505, v473, v503);
                        LOBYTE(v504) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v503 + 32) + 8LL)
                                                                                          + 16LL))( v490,  v483,  v473);
                        v491(v490, v473);
                        v470 = v614;
                        v474 = (char)v639;
                        goto LABEL_237;
                      }

                      uint64_t v186 = 266LL;
LABEL_201:
                      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v186,  0);
                    }

            uint64_t v91 = *((unsigned __int8 *)v29 + 18);
            uint64_t v92 = (int ***)v29;
            if (v91 == 5)
            {
              unint64_t v93 = (int **)*v29;
              uint64_t v92 = (int ***)*v29;
            }

            else
            {
              uint64_t v92 = 0LL;
LABEL_414:
              if (v91 == 1)
              {
                unint64_t v163 = (int ***)(v29 + 1);
                goto LABEL_441;
              }

              if (v91 == 2)
              {
                unint64_t v163 = (int ***)(v29 + 2);
                goto LABEL_441;
              }

              if (v91 != 5)
              {
                unint64_t v163 = 0LL;
                goto LABEL_441;
              }

              unint64_t v93 = (int **)*v29;
            }

            unint64_t v163 = (int ***)&v93[*((unsigned int *)v29 + 2)];
LABEL_441:
            if (v92 == v163)
            {
LABEL_449:
              if (v12 == 191)
              {
                uint64_t v183 = 0LL;
                uint64_t v184 = 0;
                char v185 = "";
                switch(*((_BYTE *)v10 + 18))
                {
                  case 1:
                    uint64_t v184 = 0;
                    uint64_t v183 = 1LL;
                    goto LABEL_701;
                  case 2:
                    goto LABEL_822;
                  case 3:
                    uint64_t v183 = 0LL;
                    uint64_t v184 = *((_DWORD *)v10 + 2);
                    char v185 = *(const char **)v10;
                    goto LABEL_701;
                  case 5:
                    uint64_t v183 = *((unsigned int *)v10 + 2);
                    if (v183 > 1)
                    {
                      uint64_t v10 = *(void (**)(uint64_t, int))v10;
LABEL_822:
                      unint64_t v327 = *((unsigned __int16 *)v31 + 8);
                      if (!v31 || v327 != 1)
                      {
                        if (*((_WORD *)v31 + 8))
                        {
                          if (v327 == 1) {
                            ((void (*)(uint64_t, uint64_t, void))v31[1])(*v31, 3LL, 0LL);
                          }
                          uint64_t v186 = 0LL;
                          uint64_t v187 = 1;
                        }

                        else
                        {
                          uint64_t v186 = *v31;
                          uint64_t v187 = 1;
                        }

                        goto LABEL_453;
                      }
                    }

                    else
                    {
                      uint64_t v184 = 0;
LABEL_701:
                      uint64_t v269 = operator new(0x28uLL);
                      void *v269 = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (2)";
                      v269[1] = 0xBF00000320LL;
                      *((_DWORD *)v269 + 4) = v184;
                      v269[3] = v185;
                      v269[4] = v183;
                      *((_WORD *)v31 + 8) = 1;
                      v31[1] = (uint64_t)swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
                      uint64_t v270 = operator new(0x28uLL);
                      unint64_t v271 = *((_OWORD *)v269 + 1);
                      *uint64_t v270 = *(_OWORD *)v269;
                      v270[1] = v271;
                      *((void *)v270 + 4) = v269[4];
                      *uint64_t v31 = (uint64_t)v270;
                      operator delete(v269);
                    }

                    break;
                  default:
                    goto LABEL_701;
                }
              }

              else
              {
                uint64_t v186 = 0LL;
                uint64_t v187 = v12 == 192;
LABEL_453:
              }
            }

            else
            {
              while (1)
              {
                unint64_t v176 = *v92;
                if (!v177) {
                  break;
                }
                unint64_t v178 = v177;
                uint64_t v179 = DWORD2(v541);
                if (DWORD2(v541) >= (unint64_t)HIDWORD(v541))
                {
                  __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod( (uint64_t)&v541,  &v542,  DWORD2(v541) + 1LL,  8LL);
                  uint64_t v179 = DWORD2(v541);
                }

                *(void *)(v541 + 8 * v179) = v178;
                ++DWORD2(v541);
                if (++v92 == v163)
                {
                  uint64_t v12 = *((unsigned __int16 *)v10 + 8);
                  goto LABEL_449;
                }
              }

              uint64_t v180 = *((unsigned __int16 *)v176 + 8);
              if (*((_BYTE *)v176 + 18) == 3)
              {
                uint64_t v181 = *((_DWORD *)v176 + 2);
                uint64_t v182 = (const char *)*v176;
              }

              else
              {
                uint64_t v181 = 0;
                uint64_t v182 = "";
              }

              uint64_t v193 = operator new(0x28uLL);
              *(void *)uint64_t v193 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
              v193[2] = 790;
              v193[3] = v180;
              v193[4] = v181;
              *((void *)v193 + 3) = v182;
              *((void *)v193 + 4) = "failed to decode protocol type";
              *((_WORD *)v31 + 8) = 1;
              v31[1] = (uint64_t)swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
              uint64_t v194 = operator new(0x28uLL);
              uint64_t v195 = *((_OWORD *)v193 + 1);
              *uint64_t v194 = *(_OWORD *)v193;
              v194[1] = v195;
              *((void *)v194 + 4) = *((void *)v193 + 4);
              *uint64_t v31 = (uint64_t)v194;
              operator delete(v193);
            }

            char v251 = (void *)v541;
            return;
          default:
            goto LABEL_476;
        }

      case 0xCF:
        uint64_t v16 = *((unsigned __int8 *)v10 + 18);
        if (v16 != 5)
        {
          if (v16 == 3)
          {
            unint64_t v95 = *((_DWORD *)v10 + 2);
            uint64_t v45 = *(const char **)v10;
          }

          else
          {
LABEL_221:
            unint64_t v95 = 0;
            uint64_t v45 = "";
          }

          uint64_t v97 = operator new(0x28uLL);
          uint64_t v40 = v97;
          *uint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
          uint64_t v98 = 0xCF0000047BLL;
          goto LABEL_225;
        }

        if (!*((_DWORD *)v10 + 2)) {
          goto LABEL_221;
        }
        goto LABEL_49;
      case 0xD2:
        uint64_t v26 = 0;
        uint64_t v27 = "";
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
          case 2:
            goto LABEL_545;
          case 3:
            uint64_t v26 = *((_DWORD *)v10 + 2);
            uint64_t v27 = *(const char **)v10;
            break;
          case 5:
            if (*((_DWORD *)v10 + 2)) {
              goto LABEL_544;
            }
            uint64_t v26 = 0;
            break;
          default:
            break;
        }

        uint64_t v97 = operator new(0x28uLL);
        uint64_t v40 = v97;
        *uint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
        uint64_t v197 = 0xD200000515LL;
        goto LABEL_766;
      case 0xD3:
        uint64_t v50 = 0;
        *(void *)&v538 = v539;
        *((void *)&v538 + 1) = 0x400000000LL;
        v534 = v536;
        v535 = 0x400000000LL;
        v545 = v547;
        v546 = 0x400000000LL;
        *(void *)&v541 = &v542;
        *((void *)&v541 + 1) = 0x800000000LL;
        v531 = v533;
        uint64_t v51 = *((unsigned __int8 *)v10 + 18);
        uint64_t v52 = "";
        v532 = 0x400000000LL;
        uint64_t v53 = 0LL;
        switch(v51)
        {
          case 1:
            goto LABEL_492;
          case 2:
            goto LABEL_96;
          case 3:
            uint64_t v50 = *((_DWORD *)v10 + 2);
            uint64_t v52 = *(const char **)v10;
            goto LABEL_497;
          case 5:
            uint64_t v50 = *((_DWORD *)v10 + 2);
            if (!v50) {
              goto LABEL_497;
            }
            if (v50 == 1) {
              goto LABEL_491;
            }
            if (v50 < 3) {
              uint64_t v53 = 0LL;
            }
            else {
              uint64_t v53 = *(void *)(*(void *)v10 + 16LL);
            }
LABEL_96:
            uint64_t v54 = *(unsigned __int16 *)(v53 + 16);
            if (v54 != 235)
            {
              if (*(_BYTE *)(v53 + 18) == 3)
              {
                uint64_t v261 = *(_DWORD *)(v53 + 8);
                uint64_t v262 = *(const char **)v53;
              }

              else
              {
                uint64_t v261 = 0;
                uint64_t v262 = "";
              }

              uint64_t v204 = operator new(0x28uLL);
              size_t v205 = v204;
              char *v204 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
              *((_DWORD *)v204 + 2) = 1323;
              *((_DWORD *)v204 + 3) = v54;
              *((_DWORD *)v204 + 4) = v261;
              Swift::String v206 = "expected type list";
              v204[3] = v262;
LABEL_811:
              v204[4] = v206;
              *((_WORD *)a4 + 8) = 1;
              a4[1] = (unint64_t)swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
              uint64_t v321 = operator new(0x28uLL);
              size_t v322 = v205[1];
              char *v321 = *v205;
              v321[1] = v322;
              *((void *)v321 + 4) = *((void *)v205 + 4);
              *a4 = (unint64_t)v321;
              goto LABEL_1001;
            }

            uint64_t v55 = (const char *)v10;
            if (v51 == 2) {
              goto LABEL_101;
            }
            if (v51 == 5 && *((_DWORD *)v10 + 2) >= 2u)
            {
              uint64_t v55 = *(const char **)v10;
LABEL_101:
              uint64_t v56 = *((void *)v55 + 1);
            }

            else
            {
              uint64_t v56 = 0LL;
            }

            uint64_t v316 = (uint64_t *)(v56 + 16);
            uint64_t v315 = *(unsigned __int16 *)(v56 + 16);
            if (v315 != 43)
            {
              if (*(_BYTE *)(v56 + 18) == 3)
              {
                char v323 = *(_DWORD *)(v56 + 8);
                uint64_t v260 = *(const char **)v56;
              }

              else
              {
                char v323 = 0;
                uint64_t v260 = "";
              }

              unint64_t v258 = a4;
              uint64_t v313 = operator new(0x28uLL);
              size_t v205 = v313;
              *uint64_t v313 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
              *((_DWORD *)v313 + 2) = 1329;
              *((_DWORD *)v313 + 3) = v315;
              *((_DWORD *)v313 + 4) = v323;
              uint64_t v314 = "expected dependent generic signature";
              goto LABEL_1000;
            }

            v512 = v56;
            uint64_t v317 = *(unsigned __int8 *)(v56 + 18);
            if ((v317 - 1) < 2)
            {
              v528 = v530;
              v529 = 0x400000000LL;
              if (v317 == 2)
              {
                uint64_t v320 = v56 + 16;
                unint64_t v319 = (const char *)v56;
              }

              else if (v317 == 1)
              {
                unint64_t v319 = (const char *)v56;
                uint64_t v320 = v56 + 8;
              }

              else
              {
                uint64_t v320 = 0LL;
                unint64_t v319 = (const char *)v56;
              }

              goto LABEL_1107;
            }

            if (v317 == 3)
            {
              v447 = *(_DWORD *)(v56 + 8);
              v448 = *(const char **)v56;
LABEL_1092:
              v449 = a4;
LABEL_1093:
              size_t v205 = operator new(0x28uLL);
              *(void *)size_t v205 = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (1)";
              *((void *)v205 + 1) = 0x2B00000536LL;
              *((_DWORD *)v205 + 4) = v447;
              *((void *)v205 + 3) = v448;
              *((void *)v205 + 4) = 0LL;
              *((_WORD *)v449 + 8) = 1;
              v449[1] = (unint64_t)swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
              v450 = operator new(0x28uLL);
              v451 = v205[1];
              *v450 = *v205;
              v450[1] = v451;
              *((void *)v450 + 4) = *((void *)v205 + 4);
              *v449 = (unint64_t)v450;
              goto LABEL_1001;
            }

            if (v317 != 5)
            {
              v447 = 0;
              v448 = "";
              goto LABEL_1092;
            }

            if (!*(_DWORD *)(v56 + 8))
            {
              v447 = 0;
              v448 = "";
              v449 = a4;
              goto LABEL_1093;
            }

            v528 = v530;
            v529 = 0x400000000LL;
            unint64_t v318 = *(unsigned int *)(v56 + 8);
            if (!(_DWORD)v318)
            {
              v526[0] = v527;
              v526[1] = (void *)0x600000000LL;
              goto LABEL_1125;
            }

            unint64_t v319 = *(const char **)v56;
            uint64_t v320 = *(void *)v56 + 8 * v318;
            do
            {
LABEL_1107:
              v459 = *(void *)v319;
              if (*(_WORD *)(*(void *)v319 + 16LL) == 37 && *(_BYTE *)(v459 + 18) == 4) {
                __swift::__runtime::llvm::SmallVectorTemplateBase<unsigned int,true>::push_back( (unsigned int *)&v528,  *(_DWORD *)v459);
              }
              v319 += 8;
            }

            while (v319 != (const char *)v320);
            v460 = (uint64_t *)v512;
            v461 = *(unsigned __int8 *)(v512 + 18);
            v526[0] = v527;
            v526[1] = (void *)0x600000000LL;
            if (v461 != 5)
            {
              v460 = 0LL;
LABEL_1113:
              if (v461 == 1)
              {
                uint64_t v316 = (uint64_t *)(v512 + 8);
                goto LABEL_1130;
              }

              if (v461 == 2) {
                goto LABEL_1130;
              }
              if (v461 != 5)
              {
                uint64_t v316 = 0LL;
                goto LABEL_1130;
              }

              v462 = v512;
              v463 = *(uint64_t **)v512;
              goto LABEL_1126;
            }

int64_t Dictionary.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001LL) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v4 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0LL;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0LL;
    uint64_t result = v5 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v9 = -1LL;
    uint64_t v10 = -1LL << *(_BYTE *)(result + 32);
    int64_t v6 = result + 64;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1LL << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 64);
  }

  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0LL;
  a2[4] = v8;
  return result;
}

uint64_t Dictionary.Iterator.next()@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v6 = result;
  uint64_t v8 = *v5;
  if (*v5 < 0)
  {
    uint64_t v21 = *(char **)(result + 16);
    uint64_t v20 = *(char **)(result + 24);
    id v22 = __CocoaDictionary.Iterator.next()(result, a2, a3, a4);
    if (v22)
    {
      uint64_t v25 = v22;
      uint64_t v26 = v23;
      _forceBridgeFromObjectiveC<A>(_:_:)(v22, v21, v24, a5);
      swift_unknownObjectRelease(v25);
      TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)v21, (uint64_t)v20, "key value ", 0LL);
      _forceBridgeFromObjectiveC<A>(_:_:)(v26, v20, v28, &a5[*((int *)TupleTypeMetadata2 + 12)]);
      swift_unknownObjectRelease(v26);
      uint64_t v29 = *(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 56);
      uint64_t v30 = a5;
      uint64_t v31 = 0LL;
      uint64_t v32 = TupleTypeMetadata2;
    }

    else
    {
      uint64_t v32 = swift_getTupleTypeMetadata2(0LL, (uint64_t)v21, (uint64_t)v20, "key value ", 0LL);
      uint64_t v29 = *(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t *))(*(v32 - 1) + 56);
      uint64_t v30 = a5;
      uint64_t v31 = 1LL;
    }

    return v29(v30, v31, 1LL, v32);
  }

  else
  {
    uint64_t v10 = v5[1];
    uint64_t v9 = v5[2];
    int64_t v12 = v5[3];
    unint64_t v11 = v5[4];
    if (v11)
    {
      uint64_t v38 = v5[2];
      uint64_t v13 = (v11 - 1) & v11;
      unint64_t v14 = __clz(__rbit64(v11)) | (v12 << 6);
LABEL_4:
      uint64_t v15 = *(void *)(result + 16);
      (*(void (**)(char *, unint64_t, uint64_t))(*(void *)(v15 - 8) + 16LL))( a5,  *(void *)(v8 + 48) + *(void *)(*(void *)(v15 - 8) + 72LL) * v14,  v15);
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(v16 - 8);
      unint64_t v18 = *(void *)(v8 + 56) + *(void *)(v17 + 72) * v14;
      uint64_t v19 = swift_getTupleTypeMetadata2(0LL, v15, v16, "key value ", 0LL);
      (*(void (**)(char *, unint64_t, uint64_t))(v17 + 16))(&a5[*((int *)v19 + 12)], v18, v16);
      uint64_t result = (*(uint64_t (**)(char *, void, uint64_t, unint64_t *))(*(v19 - 1) + 56))( a5,  0LL,  1LL,  v19);
      uint64_t v9 = v38;
LABEL_19:
      *unint64_t v5 = v8;
      v5[1] = v10;
      v5[2] = v9;
      v5[3] = v12;
      v5[4] = v13;
      return result;
    }

    int64_t v33 = v12 + 1;
    if (!__OFADD__(v12, 1LL))
    {
      int64_t v34 = (unint64_t)(v9 + 64) >> 6;
      if (v33 < v34)
      {
        unint64_t v35 = *(void *)(v10 + 8 * v33);
        if (v35)
        {
LABEL_14:
          uint64_t v38 = v5[2];
          uint64_t v13 = (v35 - 1) & v35;
          unint64_t v14 = __clz(__rbit64(v35)) + (v33 << 6);
          int64_t v12 = v33;
          goto LABEL_4;
        }

        int64_t v36 = v12 + 2;
        while (v34 != v36)
        {
          unint64_t v35 = *(void *)(v10 + 8 * v36++);
          if (v35)
          {
            int64_t v33 = v36 - 1;
            goto LABEL_14;
          }
        }

        int64_t v12 = v34 - 1;
      }

      uint64_t v37 = swift_getTupleTypeMetadata2(0LL, *(void *)(result + 16), *(void *)(result + 24), "key value ", 0LL);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t *))(*(v37 - 1) + 56))( a5,  1LL,  1LL,  v37);
      uint64_t v13 = 0LL;
      goto LABEL_19;
    }

    __break(1u);
  }

  return result;
}

uint64_t Dictionary<>.init(from:)(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = v6;
  uint64_t v328 = a6;
  uint64_t v330 = a5;
  uint64_t v10 = (ValueMetadata *)a2;
  uint64_t v12 = type metadata accessor for Optional(0LL, a2, (uint64_t)a3, a4);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v307 - v15;
  Description = (void (**)(char *, ValueMetadata *))v10[-1].Description;
  uint64_t v18 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  unint64_t v326 = (char *)&v307 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  size_t v322 = (char *)&v307 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v327 = (char *)&v307 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  char v323 = (char *)&v307 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  unint64_t v339 = a3;
  uint64_t v331 = *(a3 - 1);
  uint64_t v29 = MEMORY[0x1895F8858](v28);
  uint64_t v31 = (char *)&v307 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v29);
  uint64_t v33 = MEMORY[0x1895F8858]((char *)&v307 - v32);
  uint64_t v34 = MEMORY[0x1895F8858](v33);
  unint64_t v325 = (char *)&v307 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  uint64_t v38 = (char *)&v307 - v37;
  uint64_t v39 = MEMORY[0x1895F8858](v36);
  uint64_t v40 = MEMORY[0x1895F8858](v39);
  uint64_t v324 = (char *)&v307 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  uint64_t v43 = MEMORY[0x1895F8858](v42);
  uint64_t v44 = MEMORY[0x1895F8858](v43);
  uint64_t v45 = MEMORY[0x1895F8858](v44);
  uint64_t v46 = MEMORY[0x1895F8858](v45);
  uint64_t v329 = Description;
  if (v10 == &type metadata for String)
  {
    uint64_t v324 = (char *)&v307 - v53;
    size_t v322 = v52;
    unint64_t v326 = (char *)v51;
    unint64_t v327 = v48;
    uint64_t v71 = a1[3];
    uint64_t v72 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v71);
    uint64_t v73 = (*(void *(**)(__int128 *__return_ptr, ValueMetadata *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v72 + 24))( &v335,  &type metadata for _DictionaryCodingKey,  &type metadata for _DictionaryCodingKey,  &protocol witness table for _DictionaryCodingKey,  v71,  v72);
    if (v7) {
      goto LABEL_87;
    }
    uint64_t v311 = a1;
    uint64_t v74 = *(uint64_t (**)(void *))(*(void *)v335 + 96LL);
    uint64_t v321 = (char *)v335;
    uint64_t v75 = v74(v73);
    uint64_t v76 = specialized _arrayForceCast<A, B>(_:)(v75);
    swift_bridgeObjectRelease(v75);
    uint64_t v320 = v76[2];
    uint64_t v332 = 0LL;
    if (!v320)
    {
      uint64_t v12 = (uint64_t)&_swiftEmptyDictionarySingleton;
LABEL_94:
      swift_bridgeObjectRelease((uint64_t)v76);
      swift_release((uint64_t)v321);
LABEL_101:
      __swift_destroy_boxed_opaque_existential_1Tm(v311);
      return v12;
    }

    uint64_t v80 = 0LL;
    int64_t v81 = v76 + 7;
    uint64_t v12 = (uint64_t)&_swiftEmptyDictionarySingleton;
    uint64_t v82 = v330;
    uint64_t v83 = v339;
    unint64_t v319 = v76;
    while (1)
    {
      unint64_t v325 = v80;
      uint64_t v86 = v12;
      uint64_t v88 = *((void *)v81 - 3);
      unint64_t v87 = *((void *)v81 - 2);
      char v89 = *v81;
      uint64_t v90 = *((void *)v81 - 1);
      *(void *)&__int128 v335 = v88;
      *((void *)&v335 + 1) = v87;
      *(void *)&__int128 v336 = v90;
      BYTE8(v336) = v89;
      uint64_t v91 = *(void (**)(uint64_t *, __int128 *, uint64_t *, ValueMetadata *, uint64_t, _UNKNOWN **))(*(void *)v321 + 248LL);
      swift_bridgeObjectRetain(v87, v77, v78, v79);
      uint64_t v12 = (uint64_t)v324;
      uint64_t v92 = v332;
      v91( v83,  &v335,  v83,  &type metadata for _DictionaryCodingKey,  v328,  &protocol witness table for _DictionaryCodingKey);
      uint64_t v332 = v92;
      if (v92)
      {
        swift_release((uint64_t)v321);
        swift_bridgeObjectRelease(v87);
        swift_bridgeObjectRelease(v86);
        uint64_t v219 = &v340;
        goto LABEL_114;
      }

      *(void *)&__int128 v335 = v88;
      *((void *)&v335 + 1) = v87;
      unint64_t v93 = v327;
      swift_dynamicCast( v327,  (uint64_t *)&v335,  (swift *)&type metadata for String,  (const char *)&type metadata for String,  7uLL);
      uint64_t v94 = *(void (**)(char *, uint64_t, uint64_t *))(v331 + 32);
      unint64_t v95 = v322;
      v94(v322, v12, v83);
      v94(v326, (uint64_t)v95, v83);
      if ((v86 & 0xC000000000000001LL) != 0)
      {
        if (v86 < 0) {
          unint64_t v96 = (void *)v86;
        }
        else {
          unint64_t v96 = (void *)(v86 & 0xFFFFFFFFFFFFFF8LL);
        }
        id v97 = objc_msgSend(v96, sel_count);
        if (__OFADD__(v97, 1LL)) {
          goto LABEL_182;
        }
        uint64_t v86 = (uint64_t)_NativeDictionary.init(_:capacity:)( v96,  (uint64_t)v97 + 1,  (char *)&type metadata for String,  v83,  v82);
      }

      Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v86);
      v333[0] = v86;
      unint64_t v99 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v93, (uint64_t)&type metadata for String, v82);
      uint64_t v101 = *(void *)(v86 + 16);
      BOOL v102 = (v100 & 1) == 0;
      Swift::Int v103 = v101 + v102;
      if (__OFADD__(v101, v102))
      {
        __break(1u);
LABEL_182:
        __break(1u);
LABEL_183:
        __break(1u);
LABEL_184:
        __break(1u);
LABEL_185:
        __break(1u);
LABEL_186:
        __break(1u);
LABEL_187:
        __break(1u);
LABEL_188:
        __break(1u);
LABEL_189:
        __break(1u);
LABEL_190:
        __break(1u);
LABEL_191:
        __break(1u);
LABEL_192:
        __break(1u);
LABEL_193:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }

      char v104 = v100;
      if (*(void *)(v86 + 24) >= v103)
      {
        unint64_t v109 = v99;
        if (!isUniquelyReferenced_nonNull_native)
        {
          type metadata accessor for _NativeDictionary(0LL, (uint64_t)&type metadata for String, (uint64_t)v339, v330);
          _NativeDictionary.copy()();
        }

        uint64_t v106 = v327;
        uint64_t v12 = v333[0];
        if ((v104 & 1) != 0)
        {
LABEL_16:
          unint64_t v84 = *(void *)(v12 + 56) + *(void *)(v331 + 72) * v109;
          uint64_t v83 = v339;
          (*(void (**)(unint64_t, char *, uint64_t *))(v331 + 40))(v84, v326, v339);
          unint64_t v85 = v329;
          goto LABEL_17;
        }
      }

      else
      {
        uint64_t v105 = v330;
        type metadata accessor for _NativeDictionary(0LL, (uint64_t)&type metadata for String, (uint64_t)v339, v330);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v103, isUniquelyReferenced_nonNull_native);
        uint64_t v106 = v327;
        unint64_t v107 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v327, (uint64_t)&type metadata for String, v105);
        if ((v104 & 1) != (v108 & 1)) {
          KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
        }
        unint64_t v109 = v107;
        uint64_t v12 = v333[0];
        if ((v104 & 1) != 0) {
          goto LABEL_16;
        }
      }

      unint64_t v85 = v329;
      uint64_t v110 = v323;
      ((void (*)(char *, char *, ValueMetadata *))v329[2])(v323, v106, &type metadata for String);
      *(void *)(v12 + 8 * (v109 >> 6) + 64) |= 1LL << v109;
      ((void (*)(unint64_t, char *, ValueMetadata *))v85[4])( *(void *)(v12 + 48) + (void)v85[9] * v109,  v110,  &type metadata for String);
      unint64_t v111 = *(void *)(v12 + 56) + *(void *)(v331 + 72) * v109;
      uint64_t v83 = v339;
      v94((char *)v111, (uint64_t)v326, v339);
      uint64_t v112 = *(void *)(v12 + 16);
      BOOL v113 = __OFADD__(v112, 1LL);
      uint64_t v114 = v112 + 1;
      if (v113) {
        goto LABEL_183;
      }
      *(void *)(v12 + 16) = v114;
LABEL_17:
      uint64_t v80 = v325 + 1;
      swift_bridgeObjectRelease(0x8000000000000000LL);
      v85[1](v106, &type metadata for String);
      v81 += 32;
      uint64_t v82 = v330;
      uint64_t v76 = v319;
      if (v320 == (__objc2_class *)v80) {
        goto LABEL_94;
      }
    }
  }

  if (v10 == &type metadata for Int)
  {
    unint64_t v325 = v50;
    size_t v322 = v49;
    uint64_t v167 = a1[3];
    uint64_t v168 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v167);
    unint64_t v169 = (*(void *(**)(__int128 *__return_ptr, ValueMetadata *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v168 + 24))( &v335,  &type metadata for _DictionaryCodingKey,  &type metadata for _DictionaryCodingKey,  &protocol witness table for _DictionaryCodingKey,  v167,  v168);
    uint64_t v170 = v7;
    if (!v7)
    {
      uint64_t v311 = a1;
      Swift::String::Index v171 = *(uint64_t (**)(void *))(*(void *)v335 + 96LL);
      uint64_t v321 = (char *)v335;
      uint64_t v172 = v171(v169);
      unint64_t v173 = specialized _arrayForceCast<A, B>(_:)(v172);
      swift_bridgeObjectRelease(v172);
      uint64_t v320 = v173[2];
      if (v320)
      {
        unint64_t v177 = 0LL;
        unint64_t v178 = v173 + 7;
        uint64_t v12 = (uint64_t)&_swiftEmptyDictionarySingleton;
        unint64_t v319 = v173;
        while (v177 < (unint64_t)v173[2])
        {
          unint64_t v326 = (char *)v177;
          uint64_t v180 = *((void *)v178 - 3);
          unint64_t v179 = *((void *)v178 - 2);
          uint64_t v181 = *((void *)v178 - 1);
          if ((*v178 & 1) != 0)
          {
            swift_bridgeObjectRetain(*((void *)v178 - 2), v174, v175, v176);
            swift_bridgeObjectRelease((uint64_t)v173);
            swift_release((uint64_t)v321);
            swift_bridgeObjectRelease(v12);
            a1 = v311;
            uint64_t v234 = v311[3];
            uint64_t v235 = v311[4];
            __swift_project_boxed_opaque_existential_0Tm(v311, v234);
            unint64_t v236 = (__objc2_class **)(*(uint64_t (**)(uint64_t, uint64_t))(v235 + 8))(v234, v235);
            if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v236)) {
              unint64_t v236 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v236[2]->isa + 1,  1,  (uint64_t)v236,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
            }
            unint64_t v238 = (unint64_t)v236[2];
            unint64_t v237 = (unint64_t)v236[3];
            if (v238 >= v237 >> 1) {
              unint64_t v236 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v237 > 1),  v238 + 1,  1,  (uint64_t)v236,  &demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>,  &demangling cache variable for type metadata for CodingKey);
            }
            *((void *)&v336 + 1) = &type metadata for _DictionaryCodingKey;
            unint64_t v337 = &protocol witness table for _DictionaryCodingKey;
            Swift::String::Index v239 = swift_allocObject((uint64_t)&unk_189B781B8, 0x29uLL, 7uLL);
            *(void *)&__int128 v335 = v239;
            v239[2] = v180;
            v239[3] = v179;
            v239[4] = v181;
            *((_BYTE *)v239 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000034LL,  0x80000001818BAA70LL,  "Swift/Codable.swift",  19LL,  2,  0x11F9uLL, 0) = 1;
            v236[2] = (__objc2_class *)(v238 + 1);
            outlined init with take of MirrorPath(&v335, (uint64_t)&v236[5 * v238 + 4]);
            swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
            *(void *)uint64_t v240 = &type metadata for Int;
            *(void *)(v240 + 8) = v236;
            *(void *)(v240 + 16) = 0xD00000000000002ELL;
            *(void *)(v240 + 24) = 0x80000001818B59E0LL | 0x8000000000000000LL;
            *(void *)(v240 + 32) = 0LL;
            *(_BYTE *)(v240 + 72) = 0;
            swift_willThrow();
            goto LABEL_88;
          }

          *(void *)&__int128 v335 = *((void *)v178 - 3);
          *((void *)&v335 + 1) = v179;
          *(void *)&__int128 v336 = v181;
          BYTE8(v336) = 0;
          uint64_t v182 = *(void (**)(uint64_t *, __int128 *, uint64_t *, ValueMetadata *, uint64_t, _UNKNOWN **))(*(void *)v321 + 248LL);
          swift_bridgeObjectRetain(v179, v174, v175, v176);
          uint64_t v183 = v325;
          uint64_t v184 = v339;
          v182( v339,  &v335,  v339,  &type metadata for _DictionaryCodingKey,  v328,  &protocol witness table for _DictionaryCodingKey);
          if (v170)
          {
            swift_release((uint64_t)v321);
            swift_bridgeObjectRelease(v179);
            swift_bridgeObjectRelease(v12);
            swift_bridgeObjectRelease((uint64_t)v319);
LABEL_176:
            a1 = v311;
            goto LABEL_88;
          }

          swift_bridgeObjectRelease(v179);
          *(void *)&__int128 v335 = v181;
          swift_dynamicCast( v327,  (uint64_t *)&v335,  (swift *)&type metadata for Int,  (const char *)&type metadata for Int,  7uLL);
          char v185 = *(void (**)(char *, char *, uint64_t *))(v331 + 32);
          uint64_t v186 = v322;
          v185(v322, v183, v184);
          v185(v324, v186, v184);
          uint64_t v332 = 0LL;
          if ((v12 & 0xC000000000000001LL) != 0)
          {
            if (v12 < 0) {
              uint64_t v187 = (void *)v12;
            }
            else {
              uint64_t v187 = (void *)(v12 & 0xFFFFFFFFFFFFFF8LL);
            }
            id v188 = objc_msgSend(v187, sel_count);
            uint64_t v189 = (uint64_t)v188 + 1;
            if (__OFADD__(v188, 1LL)) {
              goto LABEL_187;
            }
            char v190 = v187;
            uint64_t v191 = v330;
            uint64_t v12 = (uint64_t)_NativeDictionary.init(_:capacity:)(v190, v189, (char *)&type metadata for Int, v339, v330);
          }

          else
          {
            uint64_t v191 = v330;
          }

          Swift::Bool v192 = swift_isUniquelyReferenced_nonNull_native(v12);
          v333[0] = v12;
          unint64_t v193 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v327, (uint64_t)&type metadata for Int, v191);
          uint64_t v195 = *(void *)(v12 + 16);
          BOOL v196 = (v194 & 1) == 0;
          Swift::Int v197 = v195 + v196;
          unint64_t v173 = v319;
          if (__OFADD__(v195, v196)) {
            goto LABEL_185;
          }
          char v198 = v194;
          if (*(void *)(v12 + 24) >= v197)
          {
            unint64_t v202 = v193;
            if (!v192)
            {
              type metadata accessor for _NativeDictionary(0LL, (uint64_t)&type metadata for Int, (uint64_t)v339, v330);
              _NativeDictionary.copy()();
            }
          }

          else
          {
            uint64_t v199 = v330;
            type metadata accessor for _NativeDictionary(0LL, (uint64_t)&type metadata for Int, (uint64_t)v339, v330);
            _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v197, v192);
            unint64_t v200 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v327, (uint64_t)&type metadata for Int, v199);
            if ((v198 & 1) != (v201 & 1)) {
              KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for Int);
            }
            unint64_t v202 = v200;
          }

          unint64_t v203 = v329;
          uint64_t v12 = v333[0];
          if ((v198 & 1) != 0)
          {
            (*(void (**)(unint64_t, char *, uint64_t *))(v331 + 40))( *(void *)(v333[0] + 56LL) + *(void *)(v331 + 72) * v202,  v324,  v339);
          }

          else
          {
            uint64_t v204 = v323;
            ((void (*)(char *, char *, ValueMetadata *))v329[2])(v323, v327, &type metadata for Int);
            *(void *)(v12 + 8 * (v202 >> 6) + 64) |= 1LL << v202;
            ((void (*)(unint64_t, char *, ValueMetadata *))v203[4])( *(void *)(v12 + 48) + (void)v203[9] * v202,  v204,  &type metadata for Int);
            v185((char *)(*(void *)(v12 + 56) + *(void *)(v331 + 72) * v202), v324, v339);
            uint64_t v205 = *(void *)(v12 + 16);
            BOOL v113 = __OFADD__(v205, 1LL);
            uint64_t v206 = v205 + 1;
            if (v113) {
              goto LABEL_189;
            }
            *(void *)(v12 + 16) = v206;
          }

          unint64_t v177 = (unint64_t)(v326 + 1);
          swift_bridgeObjectRelease(0x8000000000000000LL);
          v203[1](v327, &type metadata for Int);
          v178 += 32;
          uint64_t v170 = v332;
          if (v320 == (__objc2_class *)v177) {
            goto LABEL_99;
          }
        }

LABEL_180:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }

      uint64_t v12 = (uint64_t)&_swiftEmptyDictionarySingleton;
LABEL_99:
      swift_bridgeObjectRelease((uint64_t)v173);
      uint64_t v220 = (uint64_t)v321;
      goto LABEL_100;
    }

        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v176, 2LL);
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
        uint64_t v222 = xmmword_1817FFD00;
        uint64_t v199 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v222, 2LL);
        _StringGuts.appendInPlace(_:isASCII:)(v199, v200, 1);
        swift_bridgeObjectRelease((uint64_t)object);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        return v223;
      }

      if (*((_WORD *)v80 + 8) != 236) {
        goto LABEL_144;
      }
      uint64_t v114 = *((unsigned __int8 *)v80 + 18);
      if (v114 == 5 && v80[2])
      {
        uint64_t v80 = *(unsigned int **)v80;
LABEL_185:
        uint64_t v115 = *(unsigned int **)v80;
        goto LABEL_187;
      }

      uint64_t v115 = 0LL;
LABEL_187:
      uint64_t v116 = *((unsigned __int8 *)v115 + 18);
      if (v116 == 5 && v115[2])
      {
        uint64_t v115 = *(unsigned int **)v115;
LABEL_191:
        uint64_t v117 = *(unsigned int **)v115;
        goto LABEL_193;
      }

      uint64_t v117 = 0LL;
LABEL_193:
      int v118 = *((unsigned __int8 *)v117 + 18);
      if ((v118 - 1) >= 2)
      {
        if (v118 != 5 || !v117[2])
        {
          char v79 = 0LL;
          goto LABEL_199;
        }

        uint64_t v117 = *(unsigned int **)v117;
      }

      char v79 = *(unsigned int **)v117;
LABEL_199:
      uint64_t v119 = *((unsigned __int8 *)v79 + 18);
      if ((v119 - 1) >= 2)
      {
        if (v119 != 5 || !v79[2])
        {
          uint64_t v80 = 0LL;
          goto LABEL_144;
        }

        char v79 = *(unsigned int **)v79;
      }

      uint64_t v80 = *(unsigned int **)v79;
LABEL_144:
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v55,  (swift::Demangle::__runtime::Node *)v80,  a2,  v83,  v84);
LABEL_145:
      ++v59;
      v58 -= 8LL;
      if (!v58)
      {
LABEL_202:
        unint64_t v120 = *(_DWORD *)(v5 + 8);
        if ((v120 & 0x40000000) != 0)
        {
          uint64_t v121 = *v219;
          if (*v219)
          {
            Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 191);
            uint64_t v122 = _swift_buildDemanglingForMetadata(v121, a2);
            if (v122)
            {
              uint64_t v43 = (unsigned int *)v122;
              swift::Demangle::__runtime::Node::addChild(Node, (swift::Demangle::__runtime::Node *)v220, a2, v123, v124);
              uint64_t v46 = Node;
LABEL_111:
              uint64_t v49 = (swift::Demangle::__runtime::Node *)v43;
              goto LABEL_219;
            }

            goto LABEL_349;
          }
        }

        if (v120 < 0) {
          return v220;
        }
        Node = v220;
        if (!(_DWORD)v221) {
          goto LABEL_213;
        }
        uint64_t v125 = 0;
        uint64_t v126 = &v54[v221];
        do
        {
          while ((*v54 & 1) != 0)
          {
            ++v54;
            uint64_t v125 = 1;
            if (v54 == v126) {
              return Node;
            }
          }

          v125 |= (*(_DWORD *)(*v54++ & 0xFFFFFFFFFFFFFFFELL) & 0x10000) == 0;
        }

        while (v54 != v126);
        if ((v125 & 1) == 0)
        {
LABEL_213:
          unint64_t v127 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 192);
          swift::Demangle::__runtime::Node::addChild(v127, (swift::Demangle::__runtime::Node *)v220, a2, v128, v129);
          return v127;
        }

        return Node;
      }
    }
  }

  switch((int)v6)
  {
    case 512:
    case 513:
    case 514:
    case 515:
    case 516:
      unint64_t v11 = *(unsigned int **)(a1 + 8);
      goto LABEL_9;
    default:
      if (!(_DWORD)v6)
      {
        if ((*(_BYTE *)(a1 + 32) & 2) == 0) {
          goto LABEL_349;
        }
        unint64_t v11 = *(unsigned int **)(a1 + 64);
        if (!v11)
        {
          uint64_t v39 = a1;
          do
          {
            uint64_t v39 = *(void *)(v39 + 8);
            unint64_t v11 = *(unsigned int **)(v39 + 64);
          }

          while (!v11);
        }

LABEL_87:
    swift_bridgeObjectRelease((uint64_t)&_swiftEmptyDictionarySingleton);
    goto LABEL_88;
  }

  uint64_t v320 = (__objc2_class *)v47;
  unint64_t v319 = (__objc2_class **)v46;
  uint64_t v321 = v31;
  uint64_t v316 = v56;
  char v323 = v54;
  uint64_t v324 = (char *)v55;
  uint64_t v57 = swift_conformsToProtocol2((uint64_t)v10, (uint64_t)&protocol descriptor for CodingKeyRepresentable);
  if (v57) {
    uint64_t v58 = v57;
  }
  else {
    uint64_t v58 = 0LL;
  }
  if (v57) {
    uint64_t v59 = (uint64_t)v10;
  }
  else {
    uint64_t v59 = 0LL;
  }
  unint64_t v327 = (char *)v10;
  uint64_t v317 = v59;
  if (!v59)
  {
    unint64_t v326 = (char *)a4;
    uint64_t v207 = a1[3];
    uint64_t v208 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v207);
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v208 + 32))(&v335, v207, v208);
    uint64_t v209 = v7;
    if (v7) {
      goto LABEL_87;
    }
    uint64_t v210 = *((void *)&v336 + 1);
    uint64_t v211 = v337;
    __swift_project_boxed_opaque_existential_0Tm(&v335, *((uint64_t *)&v336 + 1));
    char v212 = ((uint64_t (*)(uint64_t, _UNKNOWN **))v211[2])(v210, v211);
    if ((v213 & 1) == 0 && (v212 & 1) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)&_swiftEmptyDictionarySingleton);
      swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
      uint64_t v215 = v214;
      uint64_t v216 = a1[3];
      uint64_t v217 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v216);
      *(void *)uint64_t v215 = (*(uint64_t (**)(uint64_t, uint64_t))(v217 + 8))(v216, v217);
      *(void *)(v215 + 8) = 0xD00000000000004DLL;
      unint64_t v218 = "Expected collection of key-value pairs; encountered odd-length array instead.";
LABEL_92:
      *(void *)(v215 + 16) = (unint64_t)(v218 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
      *(void *)(v215 + 24) = 0LL;
      *(_BYTE *)(v215 + 72) = 3;
      swift_willThrow();
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v335);
      goto LABEL_88;
    }

    uint64_t v311 = a1;
    uint64_t v222 = *((void *)&v336 + 1);
    id v223 = v337;
    __swift_project_boxed_opaque_existential_0Tm(&v335, *((uint64_t *)&v336 + 1));
    uint64_t v12 = (uint64_t)&_swiftEmptyDictionarySingleton;
    if ((((uint64_t (*)(uint64_t, _UNKNOWN **))v223[3])(v222, v223) & 1) != 0)
    {
LABEL_104:
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v335);
      goto LABEL_101;
    }

    uint64_t v241 = v339;
    uint64_t v242 = (uint64_t)v320;
    while (1)
    {
      uint64_t v246 = *((void *)&v336 + 1);
      uint64_t v247 = v337;
      __swift_mutable_project_boxed_opaque_existential_1((uint64_t *)&v335, *((uint64_t *)&v336 + 1));
      ((void (*)(ValueMetadata *, ValueMetadata *, char *, uint64_t, _UNKNOWN **))v247[22])( v10,  v10,  v326,  v246,  v247);
      if (v209)
      {
        swift_bridgeObjectRelease(v12);
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v335);
        goto LABEL_176;
      }

      uint64_t v248 = *((void *)&v336 + 1);
      uint64_t v249 = v337;
      __swift_project_boxed_opaque_existential_0Tm(&v335, *((uint64_t *)&v336 + 1));
      if ((((uint64_t (*)(uint64_t, _UNKNOWN **))v249[3])(v248, v249) & 1) != 0)
      {
        Description[1](v323, v10);
        swift_bridgeObjectRelease(v12);
        swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
        uint64_t v215 = v304;
        a1 = v311;
        uint64_t v305 = v311[3];
        uint64_t v306 = v311[4];
        __swift_project_boxed_opaque_existential_0Tm(v311, v305);
        *(void *)uint64_t v215 = (*(uint64_t (**)(uint64_t, uint64_t))(v306 + 8))(v305, v306);
        *(void *)(v215 + 8) = 0xD00000000000003DLL;
        unint64_t v218 = "Unkeyed container reached end before value in key-value pair.";
        goto LABEL_92;
      }

      uint64_t v250 = *((void *)&v336 + 1);
      char v251 = v337;
      __swift_mutable_project_boxed_opaque_existential_1((uint64_t *)&v335, *((uint64_t *)&v336 + 1));
      ((void (*)(uint64_t *, uint64_t *, uint64_t, uint64_t, _UNKNOWN **))v251[22])(v241, v241, v328, v250, v251);
      uint64_t v332 = 0LL;
      uint64_t v252 = v10;
      uint64_t v253 = Description[4];
      ((void (*)(char *, char *, ValueMetadata *))v253)(v324, v323, v252);
      uint64_t v254 = *(void (**)(__objc2_class **, uint64_t, uint64_t *))(v331 + 32);
      uint64_t v255 = (uint64_t)v319;
      v254(v319, v242, v241);
      v254((__objc2_class **)v321, v255, v241);
      if ((v12 & 0xC000000000000001LL) != 0)
      {
        if (v12 < 0) {
          uint64_t v256 = (void *)v12;
        }
        else {
          uint64_t v256 = (void *)(v12 & 0xFFFFFFFFFFFFFF8LL);
        }
        id v257 = objc_msgSend(v256, sel_count);
        uint64_t v258 = (uint64_t)v257 + 1;
        if (__OFADD__(v257, 1LL)) {
          goto LABEL_191;
        }
        uint64_t v259 = v256;
        uint64_t v260 = v327;
        uint64_t v261 = v330;
        uint64_t v12 = (uint64_t)_NativeDictionary.init(_:capacity:)(v259, v258, v327, v339, v330);
      }

      else
      {
        uint64_t v261 = v330;
        uint64_t v260 = v327;
      }

      Swift::Bool v262 = swift_isUniquelyReferenced_nonNull_native(v12);
      v333[0] = v12;
      unint64_t v263 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v324, (uint64_t)v260, v261);
      uint64_t v265 = *(void *)(v12 + 16);
      BOOL v266 = (v264 & 1) == 0;
      Swift::Int v267 = v265 + v266;
      if (__OFADD__(v265, v266)) {
        goto LABEL_190;
      }
      char v268 = v264;
      if (*(void *)(v12 + 24) >= v267)
      {
        unint64_t v273 = v263;
        if (v262)
        {
          if ((v264 & 1) != 0) {
            goto LABEL_122;
          }
        }

        else
        {
          type metadata accessor for _NativeDictionary(0LL, (uint64_t)v327, (uint64_t)v339, v330);
          _NativeDictionary.copy()();
          if ((v268 & 1) != 0) {
            goto LABEL_122;
          }
        }
      }

      else
      {
        uint64_t v269 = v327;
        uint64_t v270 = v330;
        type metadata accessor for _NativeDictionary(0LL, (uint64_t)v327, (uint64_t)v339, v330);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v267, v262);
        unint64_t v271 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v324, (uint64_t)v269, v270);
        if ((v268 & 1) != (v272 & 1)) {
          KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v327);
        }
        unint64_t v273 = v271;
        if ((v268 & 1) != 0)
        {
LABEL_122:
          Description = v329;
          uint64_t v10 = (ValueMetadata *)v327;
          v329[1](v324, (ValueMetadata *)v327);
          uint64_t v12 = v333[0];
          (*(void (**)(unint64_t, char *, uint64_t *))(v331 + 40))( *(void *)(v333[0] + 56LL) + *(void *)(v331 + 72) * v273,  v321,  v339);
          uint64_t v209 = v332;
          goto LABEL_123;
        }
      }

      uint64_t v12 = v333[0];
      *(void *)(v333[0] + 8 * (v273 >> 6) + 64) |= 1LL << v273;
      ((void (*)(unint64_t, char *, char *))v253)( *(void *)(v12 + 48) + (void)v329[9] * v273,  v324,  v327);
      v254((__objc2_class **)(*(void *)(v12 + 56) + *(void *)(v331 + 72) * v273), (uint64_t)v321, v339);
      uint64_t v274 = *(void *)(v12 + 16);
      BOOL v113 = __OFADD__(v274, 1LL);
      uint64_t v275 = v274 + 1;
      if (v113) {
        goto LABEL_192;
      }
      *(void *)(v12 + 16) = v275;
      uint64_t v209 = v332;
      Description = v329;
      uint64_t v10 = (ValueMetadata *)v327;
LABEL_123:
      swift_bridgeObjectRelease(0x8000000000000000LL);
      uint64_t v243 = *((void *)&v336 + 1);
      uint64_t v244 = v337;
      __swift_project_boxed_opaque_existential_0Tm(&v335, *((uint64_t *)&v336 + 1));
      char v245 = ((uint64_t (*)(uint64_t, _UNKNOWN **))v244[3])(v243, v244);
      uint64_t v241 = v339;
      if ((v245 & 1) != 0) {
        goto LABEL_104;
      }
    }
  }

  uint64_t v314 = v58;
  uint64_t v313 = v38;
  uint64_t v315 = v16;
  uint64_t v308 = v13;
  uint64_t v60 = a1[3];
  uint64_t v61 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v60);
  uint64_t v62 = (*(void *(**)(__int128 *__return_ptr, ValueMetadata *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v61 + 24))( &v335,  &type metadata for _DictionaryCodingKey,  &type metadata for _DictionaryCodingKey,  &protocol witness table for _DictionaryCodingKey,  v60,  v61);
  uint64_t v63 = v7;
  if (v7) {
    goto LABEL_87;
  }
  uint64_t v311 = a1;
  uint64_t v64 = *(uint64_t (**)(void *))(*(void *)v335 + 96LL);
  uint64_t v312 = v335;
  uint64_t v65 = v64(v62);
  uint64_t v66 = specialized _arrayForceCast<A, B>(_:)(v65);
  swift_bridgeObjectRelease(v65);
  unint64_t v309 = v66[2];
  if (!v309)
  {
    uint64_t v12 = (uint64_t)&_swiftEmptyDictionarySingleton;
LABEL_97:
    swift_bridgeObjectRelease((uint64_t)v66);
    uint64_t v220 = v312;
LABEL_100:
    swift_release(v220);
    goto LABEL_101;
  }

  uint64_t v307 = v12;
  unint64_t v69 = 0LL;
  uint64_t v12 = (uint64_t)&_swiftEmptyDictionarySingleton;
  uint64_t v70 = (unsigned __int8 *)(v66 + 7);
  char v310 = v66;
  while (1)
  {
    unint64_t v319 = (__objc2_class **)v69;
    uint64_t v332 = v63;
    uint64_t v115 = *((void *)v70 - 3);
    uint64_t v116 = *((void *)v70 - 2);
    uint64_t v117 = *((void *)v70 - 1);
    unint64_t v318 = v70;
    int v118 = *v70;
    uint64_t v320 = (__objc2_class *)v115;
    v333[0] = v115;
    v333[1] = v116;
    uint64_t v321 = (char *)v117;
    v333[2] = v117;
    LODWORD(v323) = v118;
    char v334 = v118;
    uint64_t v119 = (_UNKNOWN **)v314;
    unint64_t v120 = *(void (**)(void *, ValueMetadata *, _UNKNOWN **, uint64_t, _UNKNOWN **))(v314 + 16);
    uint64_t v121 = v317;
    uint64_t v122 = type metadata accessor for Optional(0LL, v317, v67, v68);
    uint64_t v123 = *(void *)(v122 - 8);
    MEMORY[0x1895F8858](v122);
    uint64_t v125 = (char *)&v307 - v124;
    uint64_t v324 = (char *)v116;
    swift_bridgeObjectRetain_n(v116, 2LL, v126, v127);
    v120(v333, &type metadata for _DictionaryCodingKey, &protocol witness table for _DictionaryCodingKey, v121, v119);
    uint64_t v128 = v121;
    uint64_t v129 = *(void *)(v121 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v129 + 48))(v125, 1LL, v128) == 1)
    {
      (*(void (**)(char *, uint64_t))(v123 + 8))(v125, v122);
      __int128 v335 = 0u;
      __int128 v336 = 0u;
      unint64_t v337 = 0LL;
    }

    else
    {
      *((void *)&v336 + 1) = v128;
      unint64_t v337 = v119;
      unint64_t v130 = __swift_allocate_boxed_opaque_existential_0Tm(&v335);
      (*(void (**)(void *, char *, uint64_t))(v129 + 32))(v130, v125, v128);
    }

    uint64_t v131 = v315;
    unint64_t v132 = v322;
    unint64_t v133 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CodingKeyRepresentable?);
    uint64_t v134 = v327;
    char v135 = swift_dynamicCast(v131, (uint64_t *)&v335, v133, v327, 6uLL);
    uint64_t v136 = v329;
    uint64_t v137 = v329[7];
    if ((v135 & 1) == 0)
    {
      ((void (*)(char *, uint64_t, uint64_t, char *))v137)(v131, 1LL, 1LL, v134);
      swift_bridgeObjectRelease(v12);
      swift_bridgeObjectRelease((uint64_t)v310);
      (*(void (**)(char *, uint64_t))(v308 + 8))(v131, v307);
      unint64_t v224 = specialized static String._createEmpty(withInitialCapacity:)(32LL);
      uint64_t v226 = v225;
      *(void *)&__int128 v335 = v224;
      *((void *)&v335 + 1) = v225;
      uint64_t v227 = HIBYTE(v225) & 0xF;
      if ((v225 & 0x2000000000000000LL) == 0) {
        uint64_t v227 = v224 & 0xFFFFFFFFFFFFLL;
      }
      if (v227 || (v224 & ~v225 & 0x2000000000000000LL) != 0)
      {
        uint64_t v12 = (uint64_t)"Could not convert key to type ";
        a1 = v311;
        uint64_t v228 = (uint64_t)v324;
        if ((v225 & 0x2000000000000000LL) != 0
          && (0x80000001818B59C0LL & 0x2000000000000000LL) != 0
          && (unint64_t v229 = specialized _SmallString.init(_:appending:)( v224,  v225,  0xD00000000000001ELL,  0x80000001818B59C0LL | 0x8000000000000000LL),  (v231 & 1) == 0))
        {
          unint64_t v232 = v229;
          uint64_t v233 = v230;
          swift_bridgeObjectRelease(v226);
          swift_bridgeObjectRelease(0x80000001818B59C0LL | 0x8000000000000000LL);
          *(void *)&__int128 v335 = v232;
          *((void *)&v335 + 1) = v233;
        }

        else
        {
          if ((0x80000001818B59C0LL & 0x2000000000000000LL) != 0) {
            unint64_t v276 = (0x80000001818B59C0LL >> 56) & 0xF;
          }
          else {
            unint64_t v276 = 30LL;
          }
          _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001818B59C0LL | 0x8000000000000000LL, 0LL, v276);
          swift_bridgeObjectRelease(0x80000001818B59C0LL | 0x8000000000000000LL);
        }
      }

      else
      {
        swift_bridgeObjectRelease(v225);
        *(void *)&__int128 v335 = 0xD00000000000001ELL;
        *((void *)&v335 + 1) = 0x80000001818B59C0LL | 0x8000000000000000LL;
        a1 = v311;
        uint64_t v228 = (uint64_t)v324;
      }

      TypeName = (uint64_t *)swift_getTypeName((unint64_t)v134, 0);
      if (v278 < 0) {
        goto LABEL_193;
      }
      unint64_t v279 = (uint8x16_t *)TypeName;
      int64_t v280 = v278;
      int64_t v281 = validateUTF8(_:)(TypeName, v278);
      if ((v283 & 1) != 0) {
        unint64_t v284 = repairUTF8(_:firstKnownBrokenRange:)(v279->i8, v280, v281, v282);
      }
      else {
        unint64_t v284 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v279, v280, v281 & 1);
      }
      unint64_t v286 = v284;
      unint64_t v287 = v285;
      uint64_t v288 = *((void *)&v335 + 1);
      uint64_t v289 = HIBYTE(*((void *)&v335 + 1)) & 0xFLL;
      if ((*((void *)&v335 + 1) & 0x2000000000000000LL) == 0) {
        uint64_t v289 = v335 & 0xFFFFFFFFFFFFLL;
      }
      if (!v289 && ((unint64_t)v335 & ~*((void *)&v335 + 1) & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(*((uint64_t *)&v335 + 1));
        *(void *)&__int128 v335 = v286;
        *((void *)&v335 + 1) = v287;
        goto LABEL_165;
      }

      if ((*((void *)&v335 + 1) & 0x2000000000000000LL) != 0)
      {
        if ((v285 & 0x2000000000000000LL) != 0)
        {
          unint64_t v291 = specialized _SmallString.init(_:appending:)(v335, *((unint64_t *)&v335 + 1), v284, v285);
          if ((v293 & 1) == 0)
          {
            unint64_t v294 = v291;
            unint64_t v295 = v292;
            swift_bridgeObjectRelease(v288);
            swift_bridgeObjectRelease(v287);
            *(void *)&__int128 v335 = v294;
            *((void *)&v335 + 1) = v295;
            unint64_t v287 = v295;
            unint64_t v286 = v294;
LABEL_165:
            uint64_t v296 = HIBYTE(v287) & 0xF;
            if ((v287 & 0x2000000000000000LL) == 0) {
              uint64_t v296 = v286 & 0xFFFFFFFFFFFFLL;
            }
            if (v296 || (v286 & ~v287 & 0x2000000000000000LL) != 0)
            {
              if ((v287 & 0x2000000000000000LL) == 0
                || (unint64_t v297 = specialized _SmallString.init(_:appending:)(v286, v287, 0LL, 0xE000000000000000LL),
                    (v299 & 1) != 0))
              {
                _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
                swift_bridgeObjectRelease(0xE000000000000000LL);
                unint64_t v301 = *((void *)&v335 + 1);
                uint64_t v300 = v335;
              }

              else
              {
                uint64_t v300 = v297;
                unint64_t v301 = v298;
                swift_bridgeObjectRelease(v287);
                swift_bridgeObjectRelease(0xE000000000000000LL);
              }
            }

            else
            {
              swift_bridgeObjectRelease(v287);
              uint64_t v300 = 0LL;
              unint64_t v301 = 0xE000000000000000LL;
            }

            swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
            uint64_t v302 = v312;
            specialized static DecodingError.dataCorruptedError<A>(forKey:in:debugDescription:)( (uint64_t)v320,  v228,  (uint64_t)v321,  (char)v323,  v312,  v300,  v301,  v303);
            swift_bridgeObjectRelease(v228);
            swift_release(v302);
            swift_bridgeObjectRelease(v301);
            swift_willThrow();
            goto LABEL_88;
          }

          goto LABEL_163;
        }
      }

      else if ((v285 & 0x2000000000000000LL) != 0)
      {
LABEL_163:
        uint64_t v290 = HIBYTE(v287) & 0xF;
        goto LABEL_164;
      }

      uint64_t v290 = v284 & 0xFFFFFFFFFFFFLL;
LABEL_164:
      _StringGuts.append(_:)(v286, v287, 0LL, v290);
      swift_bridgeObjectRelease(v287);
      unint64_t v287 = *((void *)&v335 + 1);
      unint64_t v286 = v335;
      goto LABEL_165;
    }

    ((void (*)(char *, void, uint64_t, char *))v137)(v131, 0LL, 1LL, v134);
    unint64_t v138 = v136[4];
    ((void (*)(char *, char *, char *))v138)(v132, v131, v134);
    uint64_t v139 = (uint64_t)v324;
    *(void *)&__int128 v335 = v320;
    *((void *)&v335 + 1) = v324;
    *(void *)&__int128 v336 = v321;
    BYTE8(v336) = (_BYTE)v323;
    uint64_t v140 = v316;
    uint64_t v141 = v339;
    uint64_t v142 = v332;
    (*(void (**)(uint64_t *, __int128 *, uint64_t *, ValueMetadata *, uint64_t, _UNKNOWN **))(*(void *)v312 + 248LL))( v339,  &v335,  v339,  &type metadata for _DictionaryCodingKey,  v328,  &protocol witness table for _DictionaryCodingKey);
    uint64_t v332 = v142;
    if (v142) {
      break;
    }
    swift_bridgeObjectRelease(v139);
    ((void (*)(char *, char *, char *))v138)(v326, v132, v134);
    uint64_t v143 = *(void (**)(char *, uint64_t, uint64_t *))(v331 + 32);
    uint64_t v144 = v313;
    v143(v313, v140, v141);
    v143(v325, (uint64_t)v144, v141);
    if ((v12 & 0xC000000000000001LL) != 0)
    {
      if (v12 < 0) {
        uint64_t v145 = (void *)v12;
      }
      else {
        uint64_t v145 = (void *)(v12 & 0xFFFFFFFFFFFFFF8LL);
      }
      id v146 = objc_msgSend(v145, sel_count, v307);
      uint64_t v147 = (uint64_t)v146 + 1;
      if (__OFADD__(v146, 1LL)) {
        goto LABEL_186;
      }
      id v148 = v145;
      uint64_t v149 = v330;
      uint64_t v12 = (uint64_t)_NativeDictionary.init(_:capacity:)(v148, v147, v134, v339, v330);
    }

    else
    {
      uint64_t v149 = v330;
    }

    Swift::Bool v150 = swift_isUniquelyReferenced_nonNull_native(v12);
    *(void *)&__int128 v335 = v12;
    unint64_t v151 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v326, (uint64_t)v134, v149);
    uint64_t v153 = *(void *)(v12 + 16);
    BOOL v154 = (v152 & 1) == 0;
    Swift::Int v155 = v153 + v154;
    if (__OFADD__(v153, v154)) {
      goto LABEL_184;
    }
    char v156 = v152;
    if (*(void *)(v12 + 24) < v155)
    {
      uint64_t v157 = v327;
      uint64_t v158 = v330;
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v327, (uint64_t)v339, v330);
      Swift::Int v159 = v155;
      uint64_t v160 = v157;
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v159, v150);
      unint64_t v161 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v326, (uint64_t)v157, v158);
      if ((v156 & 1) != (v162 & 1)) {
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v157);
      }
      unint64_t v163 = v161;
LABEL_55:
      uint64_t v164 = v329;
      if ((v156 & 1) != 0) {
        goto LABEL_36;
      }
      goto LABEL_59;
    }

    unint64_t v163 = v151;
    if (!v150)
    {
      uint64_t v160 = v327;
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v327, (uint64_t)v339, v330);
      _NativeDictionary.copy()();
      goto LABEL_55;
    }

    uint64_t v164 = v329;
    uint64_t v160 = v327;
    if ((v152 & 1) != 0)
    {
LABEL_36:
      v164[1](v326, (ValueMetadata *)v160);
      uint64_t v12 = v335;
      (*(void (**)(unint64_t, char *, uint64_t *))(v331 + 40))( *(void *)(v335 + 56) + *(void *)(v331 + 72) * v163,  v325,  v339);
      goto LABEL_37;
    }

            swift_release_n((uint64_t)v138, 2LL);
            uint64_t v121 = (uint64_t)v139;
            goto LABEL_89;
          }

          ++v16;
        }

    unint64_t v224 = v283;
    ((void (*)(char *, char *, uint64_t))v285)(v283, v203, v77);
    unint64_t v225 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
    ((void (*)(char *, uint64_t))v286)(v224, v77);
    if (v225 < v289) {
      goto LABEL_111;
    }
    goto LABEL_91;
  }

  BOOL v266 = (char *)v64;
  uint64_t v214 = v206(v77, v67);
  uint64_t v215 = v254(v77, v67);
  if ((v214 & 1) == 0)
  {
    uint64_t v64 = (void (*)(char *, uint64_t, swift *))v266;
    if (v215 >= 64) {
      goto LABEL_91;
    }
    goto LABEL_87;
  }

  if (v215 <= 64)
  {
    uint64_t v226 = v264;
    uint64_t v227 = v263;
    uint64_t v228 = swift_getAssociatedConformanceWitness( (uint64_t)v264,  v77,  v263,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    unint64_t v229 = v262;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v228 + 8))( &qword_18180BE68,  256LL,  v227,  v228);
    uint64_t v230 = v283;
    (*((void (**)(char *, uint64_t, const char *))v226 + 3))(v229, v77, v226);
    LOBYTE(v227) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v203,  v230,  v77);
    ((void (*)(char *, uint64_t))v286)(v230, v77);
    char v231 = v256;
    ((void (*)(char *, char *, uint64_t))v285)(v256, v203, v77);
    if ((v227 & 1) != 0)
    {
LABEL_110:
      ((void (*)(char *, uint64_t))v286)(v231, v77);
      goto LABEL_111;
    }

    unint64_t v232 = v289;
    uint64_t v233 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
    ((void (*)(char *, uint64_t))v286)(v231, v77);
    unint64_t v163 = v233 < v232;
    uint64_t v64 = (void (*)(char *, uint64_t, swift *))v266;
    if (v163) {
      goto LABEL_111;
    }
    goto LABEL_91;
  }

  unint64_t v218 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
  uint64_t v219 = lazy protocol witness table accessor for type Int and conformance Int(v215, v216, v217);
  uint64_t v220 = v283;
  v218(&v289, &type metadata for Int, v219, v77, v67);
  uint64_t v221 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v203,  v220,  v77);
  ((void (*)(char *, uint64_t))v286)(v220, v77);
  uint64_t v64 = (void (*)(char *, uint64_t, swift *))v266;
  if ((v221 & 1) != 0) {
LABEL_111:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_91:
  ((void (*)(char *, uint64_t))v286)(v203, v77);
  uint64_t v204 = v254;
LABEL_92:
  uint64_t v234 = v280;
  uint64_t v235 = v204(v77, v67);
  unint64_t v236 = v265;
  ((void (*)(char *, char *, uint64_t))v285)(v265, v234, v77);
  if (v235 >= 65)
  {
    ((void (*)(char *, uint64_t))v286)(v236, v77);
    goto LABEL_94;
  }

  uint64_t v244 = v204(v77, v67);
  ((void (*)(char *, uint64_t))v286)(v236, v77);
  if (v244 == 64 && (v253((unint64_t *)v77, v67) & 1) == 0)
  {
LABEL_94:
    BOOL v266 = (char *)v64;
    ((void (*)(char *, char *, uint64_t))v285)(v267, v280, v77);
    uint64_t v289 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v237 = v253((unint64_t *)v77, v67);
    unint64_t v238 = v204(v77, v67);
    if ((v237 & 1) != 0)
    {
      if (v238 > 64)
      {
        uint64_t v241 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
        uint64_t v242 = lazy protocol witness table accessor for type Int and conformance Int(v238, v239, v240);
        uint64_t v243 = &v289;
        goto LABEL_104;
      }
    }

    else if (v238 >= 64)
    {
      uint64_t v288 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v241 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
      uint64_t v242 = lazy protocol witness table accessor for type Int and conformance Int(v238, v239, v240);
      uint64_t v243 = &v288;
LABEL_104:
      uint64_t v248 = v283;
      v241(v243, &type metadata for Int, v242, v77, v67);
      uint64_t v246 = v267;
      uint64_t v249 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v248,  v267,  v77);
      ((void (*)(char *, uint64_t))v286)(v248, v77);
      uint64_t v64 = (void (*)(char *, uint64_t, swift *))v266;
      if ((v249 & 1) == 0) {
        goto LABEL_105;
      }
      goto LABEL_103;
    }

    char v245 = v283;
    uint64_t v246 = v267;
    ((void (*)(char *, char *, uint64_t))v285)(v283, v267, v77);
    uint64_t v247 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
    ((void (*)(char *, uint64_t))v286)(v245, v77);
    uint64_t v64 = (void (*)(char *, uint64_t, swift *))v266;
    if (v289 >= v247)
    {
LABEL_105:
      ((void (*)(char *, uint64_t))v286)(v246, v77);
      goto LABEL_106;
    }

  swift_release(v23);
  *uint64_t v117 = (uint64_t)v28;
  if ((v115 & 1) != 0)
  {
LABEL_100:
    BOOL v102 = v28[6] + 40 * v13;
    Swift::Int v103 = *(_OWORD *)(v102 + 16);
    *(_OWORD *)a3 = *(_OWORD *)v102;
    *(_OWORD *)(a3 + 16) = v103;
    *(void *)(a3 + 32) = *(void *)(v102 + 32);
    char v104 = *((void *)a1 + 4);
    uint64_t v105 = a1[1];
    *(_OWORD *)BOOL v102 = *a1;
    *(_OWORD *)(v102 + 16) = v105;
    *(void *)(v102 + 32) = v104;
    return *(double *)&v105;
  }

          swift_bridgeObjectRetain(v155, v155, v156, v157);
          swift_bridgeObjectRelease(v160);
          v566 = v158;
          v567 = v159;
          goto LABEL_88;
        }

        v565 = 0LL;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((void *)&v564 + 1) = v1;
        unint64_t v203 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
        memcpy(v203, v106, v2);
        Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
        uint64_t v204 = v560._object;
        uint64_t v205 = v562;
        ((void (*)(char *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v106,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
        swift_release(v205);
        swift_release((uint64_t)v204);
LABEL_55:
        char v162 = v558;
        goto LABEL_90;
      }

      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      unint64_t v173 = (uint64_t)v561;
      uint64_t v174 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v174 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v173,  v174);
      __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    }

    unint64_t v151 = v559;
    goto LABEL_55;
  }

  unint64_t v151 = v559;
  memcpy(v559, v106, v2);
  char v152 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  swift_dynamicCast((char *)&v560, v151, v1, v152, 7uLL);
  uint64_t v153 = (uint64_t)v561;
  BOOL v154 = v562;
  __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  uint64_t v158 = (*(uint64_t (**)(uint64_t, uint64_t))(v154 + 8))(v153, v154);
  Swift::Int v159 = v155;
  uint64_t v160 = v567;
  unint64_t v161 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    unint64_t v161 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (!v161 && (v566 & ~v567 & 0x2000000000000000LL) == 0) {
    goto LABEL_87;
  }
  char v162 = v558;
  if ((v567 & 0x2000000000000000LL) != 0)
  {
    if ((v155 & 0x2000000000000000LL) == 0) {
      goto LABEL_57;
    }
    uint64_t v186 = specialized _SmallString.init(_:appending:)(v566, v567, v158, v155);
    if ((v188 & 1) != 0)
    {
      unint64_t v163 = HIBYTE(v159) & 0xF;
      char v162 = v558;
      unint64_t v151 = v559;
      goto LABEL_81;
    }

    uint64_t v189 = v186;
    char v190 = v187;
    swift_bridgeObjectRelease(v160);
    v566 = v189;
    v567 = v190;
    unint64_t v151 = v559;
LABEL_88:
    char v162 = v558;
    goto LABEL_89;
  }

  if ((v155 & 0x2000000000000000LL) == 0)
  {
LABEL_57:
    unint64_t v163 = v158 & 0xFFFFFFFFFFFFLL;
    goto LABEL_81;
  }

  unint64_t v163 = HIBYTE(v155) & 0xF;
LABEL_81:
  _StringGuts.append(_:)(v158, v159, 0LL, v163);
LABEL_89:
  swift_bridgeObjectRelease(v159);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
LABEL_90:
  uint64_t v206 = v567;
  uint64_t v207 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    uint64_t v207 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v207 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    if ((v567 & 0x2000000000000000LL) == 0
      || (uint64_t v208 = specialized _SmallString.init(_:appending:)(v566, v567, 0x202CuLL, 0xE200000000000000LL),
          (v210 & 1) != 0))
    {
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
    }

    else
    {
      uint64_t v211 = v208;
      char v212 = v209;
      swift_bridgeObjectRelease(v206);
      v566 = v211;
      v567 = v212;
    }

    char v213 = 0xE200000000000000LL;
  }

  else
  {
    v566 = 8236LL;
    v567 = 0xE200000000000000LL;
    char v213 = v206;
  }

  swift_bridgeObjectRelease(v213);
  uint64_t v214 = v549;
  v146(1LL, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  uint64_t v215 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v215, v214, v2);
  uint64_t v216 = v561;
  uint64_t v217 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  unint64_t v218 = (void *)swift_getDynamicType(v217, v216, 1);
  LODWORD(v216) = swift_isOptionalType(v218);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v216)
  {
    memcpy(v151, v214, v2);
    uint64_t v219 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v219, 7uLL);
    uint64_t v220 = (uint64_t)v561;
    uint64_t v221 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    unint64_t v225 = (*(uint64_t (**)(uint64_t, uint64_t))(v221 + 8))(v220, v221);
    uint64_t v226 = v222;
    uint64_t v227 = v567;
    uint64_t v228 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000LL) == 0) {
      uint64_t v228 = v566 & 0xFFFFFFFFFFFFLL;
    }
    if (v228 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
    {
      if ((v567 & 0x2000000000000000LL) == 0)
      {
        if ((v222 & 0x2000000000000000LL) != 0)
        {
          unint64_t v229 = HIBYTE(v222) & 0xF;
LABEL_130:
          _StringGuts.append(_:)(v225, v226, 0LL, v229);
          goto LABEL_131;
        }

    if (v16 == 514)
    {
      if (isa == 514)
      {
        GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a4, (uint64_t)v23, v24, v25);
        uint64_t v50 = *GenericArgs;
        uint64_t v51 = (swift::runtime::bincompat *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*(void *)(*GenericArgs - 8)
                                                                                                  + 48LL))( a3,  1LL,  *GenericArgs);
        if ((_DWORD)v51)
        {
          if (swift::runtime::bincompat::useLegacyProtocolConformanceReverseIteration(v51))
          {
            uint64_t v58 = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a2, v55, v56, v57);
            uint64_t v20 = 1LL;
            (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(*v58 - 8) + 56LL))(v78, 1LL, 1LL);
          }

          else
          {
            uint64_t v67 = (uint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a4, v55, v56, v57);
            uint64_t v71 = 1;
            if (*v67 == 514)
            {
              uint64_t v72 = (uint64_t)v78;
              do
              {
                ++v71;
                uint64_t v67 = (uint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs(v67, v68, v69, v70);
              }

              while (*v67 == 514);
            }

            else
            {
              uint64_t v72 = (uint64_t)v78;
            }

            uint64_t v73 = (uint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a2, v68, v69, v70);
            for (uint64_t i = 1;
                  *v73 == 514;
                  uint64_t v73 = (uint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs(v73, v74, v75, v76))
            {
              ++i;
            }

            initializeToNilAtDepth( v72,  (uint64_t *)a2,  (const char *)((i - v71) & ~((i - v71) >> 31)),  v76);
            return 1LL;
          }

          return v20;
        }

        uint64_t v59 = *swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a2, v52, v53, v54);
        uint64_t v60 = tryCast(v78, v59, a3, v50, a5, a6, a7, a8);
        if ((_DWORD)v60) {
          goto LABEL_94;
        }
      }

      uint64_t v59 = *swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a2, (uint64_t)v23, v24, v25);
      uint64_t v60 = tryCast(v78, v59, a3, a4, a5, a6, a7, a8);
      if ((_DWORD)v60)
      {
LABEL_94:
        uint64_t v20 = v60;
        (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v59 - 8) + 56LL))(v78, 0LL, 1LL, v59);
        return v20;
      }
    }

    if (isa == 514)
    {
      uint64_t v61 = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a4, (uint64_t)v23, v24, v25);
      uint64_t v62 = *v61;
      if (!(*(unsigned int (**)(uint64_t *, uint64_t, uint64_t))(*(void *)(*v61 - 8) + 48LL))(a3, 1LL, *v61))
      {
        uint64_t v20 = tryCast(v78, a2, a3, v62, a5, a6, a7, a8);
        if ((_DWORD)v20) {
          return v20;
        }
      }
    }

    if (v16 > 514)
    {
      if (v16 != 515)
      {
        if (v16 == 771)
        {
          if (swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a2) == 1)
          {
            uint64_t v20 = tryCastToClassExistentialViaSwiftValue((char **)v78, a2, (unint64_t **)a3, (uint64_t *)a4, a7);
            if ((_DWORD)v20) {
              return v20;
            }
          }

          return 0LL;
        }

        if (v16 != 773) {
          return 0LL;
        }
      }
    }

    else
    {
      if ((v16 - 512) < 2) {
        return (!isa || isa == 773 || isa == 515)
      }
            && tryCastFromClassToObjCBridgeable( (uint64_t)v78,  (const char *)a2,  a3,  (objc_class *)a4,  a5,  a8);
      if (v16)
      {
        if (v16 != 514
          || *(void *)a4 != 771LL
          || swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a4) != 1
          || *(_DWORD *)(a4 + 12))
        {
          return 0LL;
        }

        uint64_t v63 = *(_DWORD *)(a4 + 8);
        if ((v63 & 0x40000000) != 0)
        {
          if (v63 < 0 || *(void *)(a4 + 16)) {
            return 0LL;
          }
        }

        else if (v63 < 0)
        {
          return 0LL;
        }

        return tryCastFromClassToObjCBridgeable( (uint64_t)v78,  (const char *)a2,  a3,  (objc_class *)a4,  a5,  0) != 0;
      }
    }

    if ((isa & 0xFFFFFFFE) == 0x200
      && tryCastFromObjCBridgeableToClass((unint64_t **)v78, a2, (uint64_t)a3, a4))
    {
      return 1LL;
    }

    if (v16 == 773)
    {
      ErrorWitness = (swift *)swift::findErrorWitness(a4);
      if (ErrorWitness)
      {
        uint64_t v65 = (uint64_t)ErrorWitness;
        NSErrorMetadata = (swift *)swift::getNSErrorMetadata(ErrorWitness);
        if (NSErrorMetadata == (swift *)a2 || swift::getNSObjectMetadata(NSErrorMetadata) == a2)
        {
          *(void *)uint64_t v78 = swift::dynamicCastValueToNSError((uint64_t)a3, a4, v65, 0);
          return 1LL;
        }
      }
    }

    return 0LL;
  }

  return v20;
}

  operator delete(v13);
  uint64_t v39 = (unsigned __int16 *)operator new(0x40uLL);
  *uint64_t v39 = 232;
  *((void *)v39 + 1) = 2LL;
  v39[8] = 82;
  *((void *)v39 + 3) = 0LL;
  v39[16] = 3;
  *((void *)v39 + 5) = 0LL;
  v39[24] = 232;
  *((void *)v39 + 7) = 0LL;
  uint64_t v40 = *((unsigned __int8 *)v11 + 18);
  uint64_t v41 = v40 - 1;
  if ((_DWORD)v40 != 1)
  {
    if ((_DWORD)v40 == 5)
    {
      uint64_t v40 = v11[2];
    }

    else
    {
      if ((_DWORD)v40 != 2) {
        goto LABEL_143;
      }
      uint64_t v40 = 2LL;
    }
  }

  if (v40 <= 2) {
    goto LABEL_143;
  }
  uint64_t v42 = v11;
  if (v41 >= 2) {
    uint64_t v42 = *(unsigned int **)v11;
  }
  uint64_t v43 = (uint64_t *)*((void *)v42 + 2);
  if (!v43 || *((_WORD *)v43 + 8) != 232) {
    goto LABEL_143;
  }
  uint64_t v44 = *((void *)v39 + 3);
  uint64_t v45 = *((unsigned __int8 *)v43 + 18);
  uint64_t v46 = v45 - 1;
  if ((_DWORD)v45 != 1)
  {
    if ((_DWORD)v45 == 2)
    {
      uint64_t v45 = 2LL;
    }

    else
    {
      if ((_DWORD)v45 != 5) {
        goto LABEL_143;
      }
      uint64_t v45 = *((unsigned int *)v43 + 2);
    }
  }

  if (v45 <= v44) {
    goto LABEL_143;
  }
  if (v46 >= 2) {
    uint64_t v43 = (uint64_t *)*v43;
  }
  uint64_t v47 = (uint64_t **)v43[v44];
  uint64_t v48 = *((void *)v39 + 5);
  uint64_t v49 = *((unsigned __int8 *)v47 + 18);
  uint64_t v50 = v49 - 1;
  if ((_DWORD)v49 != 1)
  {
    if ((_DWORD)v49 == 2)
    {
      uint64_t v49 = 2LL;
    }

    else
    {
      if ((_DWORD)v49 != 5) {
        goto LABEL_143;
      }
      uint64_t v49 = *((unsigned int *)v47 + 2);
    }
  }

  if (v49 <= v48) {
    goto LABEL_143;
  }
  if (v50 >= 2) {
    uint64_t v47 = (uint64_t **)*v47;
  }
  uint64_t v51 = (uint64_t **)v47[v48];
  uint64_t v52 = *((void *)v39 + 7);
  uint64_t v53 = *((unsigned __int8 *)v51 + 18);
  uint64_t v54 = v53 - 1;
  if ((_DWORD)v53 != 1)
  {
    if ((_DWORD)v53 == 2)
    {
      uint64_t v53 = 2LL;
      goto LABEL_122;
    }

    if ((_DWORD)v53 == 5)
    {
      uint64_t v53 = *((unsigned int *)v51 + 2);
      goto LABEL_122;
    }

  uint64_t v71 = (unsigned int *)((char *)this + 12728);
  swift::Demangle::__runtime::CharVector::append((char **)this + 1591, "Tf", 2uLL, *((void **)this + 1593));
  uint64_t v43 = *((unsigned __int8 *)v5 + 18);
  uint64_t v44 = v5;
  if ((v43 - 1) >= 2)
  {
    if (v43 == 5)
    {
      uint64_t v45 = *(void *)v5;
      uint64_t v44 = *(swift::Demangle::__runtime::Node **)v5;
      goto LABEL_96;
    }

    uint64_t v44 = 0LL;
  }

  if (v43 == 1)
  {
    uint64_t v46 = (swift::Demangle::__runtime::Node *)((char *)v5 + 8);
    goto LABEL_100;
  }

  if (v43 == 2)
  {
    uint64_t v46 = (swift::Demangle::__runtime::Node *)((char *)v5 + 16);
    goto LABEL_100;
  }

  if (v43 != 5)
  {
    uint64_t v46 = 0LL;
    goto LABEL_100;
  }

  uint64_t v45 = *(void *)v5;
LABEL_96:
  uint64_t v46 = (swift::Demangle::__runtime::Node *)(v45 + 8LL * *((unsigned int *)v5 + 2));
LABEL_100:
  uint64_t v67 = v46;
  if (v44 == v46) {
    goto LABEL_130;
  }
  uint64_t v47 = 0;
  uint64_t v48 = a3 + 1;
  uint64_t v49 = v46;
  uint64_t v65 = a4;
  unint64_t v69 = v48;
  do
  {
    uint64_t v50 = *(swift::Demangle::__runtime::Node **)v44;
    if (*(_WORD *)(*(void *)v44 + 16LL) != 79) {
      goto LABEL_124;
    }
    uint64_t v51 = *((_DWORD *)this + 3184);
    uint64_t v52 = *((unsigned int *)this + 3185);
    uint64_t v53 = (char *)*((void *)this + 1591);
    if (v51 >= v52)
    {
      uint64_t v54 = (void *)*((void *)this + 1593);
      uint64_t v55 = (char *)v54[1];
      if (&v53[v52] == v55)
      {
        uint64_t v57 = (unint64_t)&v53[v52 + 1];
        uint64_t v56 = v54[2];
        if (v57 <= v56)
        {
          v54[1] = v57;
          LODWORD(v58) = 1;
LABEL_122:
          *((_DWORD *)this + 3185) = v52 + v58;
          uint64_t v49 = v67;
          goto LABEL_123;
        }
      }

      else
      {
        uint64_t v56 = v54[2];
      }

      else {
        uint64_t v58 = (2 * v52);
      }
      uint64_t v59 = v58 + v52;
      if (v55) {
        uint64_t v60 = (unint64_t)&v55[v58 + v52] > v56;
      }
      else {
        uint64_t v60 = 1;
      }
      uint64_t v53 = (char *)v54[1];
      if (v60)
      {
        uint64_t v61 = 2LL * v54[4];
        if (v61 <= v59 + 1) {
          uint64_t v61 = v59 + 1;
        }
        v54[4] = v61;
        uint64_t v62 = v61 + 8;
        uint64_t v63 = malloc(v61 + 8);
        *uint64_t v63 = v54[3];
        uint64_t v53 = (char *)(v63 + 1);
        uint64_t v64 = (char *)v63 + v62;
        a4 = v65;
        v54[2] = v64;
        v54[3] = v63;
      }

      v54[1] = &v53[v59];
      if ((_DWORD)v52)
      {
        memcpy(v53, *((const void **)this + 1591), v52);
        LODWORD(v52) = *((_DWORD *)this + 3185);
        uint64_t v51 = *((_DWORD *)this + 3184);
      }

      unint64_t v5 = a2;
      *(void *)uint64_t v71 = v53;
      goto LABEL_122;
    }

__objc2_class **Dictionary.init()()
{
  return &_swiftEmptyDictionarySingleton;
}

uint64_t static Int.% infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int.% infix(_:_:)(a1, a2, 0x390EuLL, 0x3913uLL);
}

uint64_t SingleValueEncodingContainer<>.encode(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = v9;
  uint64_t v9[3] = &type metadata for Int128;
  unint64_t v11 = swift_allocObject((uint64_t)&unk_189B78168, 0x20uLL, 0xFuLL);
  *uint64_t v10 = v11;
  v11[2] = a1;
  uint64_t v11[3] = a2;
  v10[4] = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 8))(a3, a5);
  v10[5] = 0xD00000000000002ELL;
  v10[6] = 0x80000001818B56D0LL;
  v10[7] = 0LL;
  return swift_willThrow();
}

{
  void *v9;
  void *v10;
  void *v11;
  swift_allocError( (uint64_t)&type metadata for EncodingError,  (uint64_t)&protocol witness table for EncodingError,  0LL,  0);
  uint64_t v10 = v9;
  uint64_t v9[3] = &type metadata for UInt128;
  unint64_t v11 = swift_allocObject((uint64_t)&unk_189B78168, 0x20uLL, 0xFuLL);
  *uint64_t v10 = v11;
  v11[2] = a1;
  uint64_t v11[3] = a2;
  v10[4] = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 8))(a3, a5);
  v10[5] = 0xD00000000000002FLL;
  v10[6] = 0x80000001818B5700LL;
  v10[7] = 0LL;
  return swift_willThrow();
}

uint64_t SingleValueDecodingContainer<>.decode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SingleValueDecodingContainer<>.decode(_:)( a1,  a2,  a3,  (uint64_t)&type metadata for Int128,  0xD00000000000002ELL,  0x80000001818B5730LL);
}

{
  return SingleValueDecodingContainer<>.decode(_:)( a1,  a2,  a3,  (uint64_t)&type metadata for UInt128,  0xD00000000000002FLL,  0x80000001818B5760LL);
}

uint64_t SingleValueDecodingContainer<>.decode(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = v11;
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a1, a3);
  *(void *)uint64_t v12 = a4;
  *(void *)(v12 + 8) = v13;
  *(void *)(v12 + 16) = a5;
  *(void *)(v12 + 24) = a6;
  *(void *)(v12 + 32) = 0LL;
  *(_BYTE *)(v12 + 72) = 0;
  return swift_willThrow();
}

uint64_t IndexingIterator._position.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter( a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index,  a2);
}

uint64_t IndexingIterator._position.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
}

uint64_t (*IndexingIterator._position.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance IndexingIterator<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2;
  uint64_t v31 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v30 = *(void *)(v5 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v30 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v6 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - v15;
  uint64_t v17 = v2 + *(int *)(a1 + 36);
  (*(void (**)(char *, uint64_t, unint64_t))(v11 + 16))((char *)&v30 - v15, v17, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v9 + 72))(v5, v9);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v19 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v16,  v14,  AssociatedTypeWitness);
  uint64_t v20 = *(void (**)(char *, unint64_t))(v11 + 8);
  v20(v14, AssociatedTypeWitness);
  v20(v16, AssociatedTypeWitness);
  if ((v19 & 1) != 0)
  {
    unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v9 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v21 - 8) + 56LL))( v31,  1LL,  1LL,  v21);
  }

  else
  {
    uint64_t v23 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v9 + 80))( v32,  v17,  v5,  v9);
    uint64_t v25 = v24;
    unint64_t v26 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v9 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v27 = *(void *)(v26 - 8);
    uint64_t v28 = v31;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v27 + 16))(v31, v25, v26);
    v23(v32, 0LL);
    uint64_t v29 = v30;
    (*(void (**)(char *, uint64_t, uint64_t))(v30 + 16))(v8, v4, v5);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 192))(v17, v5, v9);
    (*(void (**)(char *, uint64_t))(v29 + 8))(v8, v5);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v27 + 56))(v28, 0LL, 1LL, v26);
  }

uint64_t Collection.index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Only BidirectionalCollections can be advanced by a negative amount",  66LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x3C3uLL,  0);
  }
  uint64_t v7 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a5,  a1,  AssociatedTypeWitness);
  if (v7)
  {
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 192);
    do
    {
      uint64_t result = v12(a5, a3, a4);
      --v7;
    }

    while (v7);
  }

  return result;
}

uint64_t Collection.index(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v22 - v14;
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Only BidirectionalCollections can be advanced by a negative amount",  66LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x3D3uLL,  0);
  }
  uint64_t v22 = v13;
  uint64_t v23 = a6;
  (*(void (**)(char *, uint64_t, unint64_t))(v13 + 16))(v15, a1, AssociatedTypeWitness);
  if (a2)
  {
    uint64_t v16 = *(void *)(swift_getAssociatedConformanceWitness( a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    uint64_t v17 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v16 + 8);
    while ((v17(v15, a3, AssociatedTypeWitness, v16) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(a5 + 192))(v15, a4, a5);
      if (!--a2) {
        goto LABEL_6;
      }
    }

    uint64_t v19 = v22;
    (*(void (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
    uint64_t v20 = 1LL;
    uint64_t v18 = v23;
  }

  else
  {
LABEL_6:
    uint64_t v19 = v22;
    uint64_t v18 = v23;
    (*(void (**)(uint64_t, char *, unint64_t))(v22 + 32))(v23, v15, AssociatedTypeWitness);
    uint64_t v20 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v19 + 56))( v18,  v20,  1LL,  AssociatedTypeWitness);
}

uint64_t Collection.distance(from:to:)( void (*a1)(char *, unint64_t), void (*a2)(void, void), uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v29 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v29 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v29 - v15;
  uint64_t v29 = v17;
  uint64_t v18 = *(void (**)(char *, void (*)(void, void), unint64_t))(v17 + 16);
  uint64_t v32 = a1;
  v18((char *)&v29 - v15, (void (*)(void, void))a1, AssociatedTypeWitness);
  uint64_t v30 = v18;
  uint64_t v31 = a2;
  v18(v14, a2, AssociatedTypeWitness);
  uint64_t v19 = a4;
  uint64_t v33 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v16,  v14,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    goto LABEL_10;
  }
  unint64_t v21 = *(void (**)(char *, unint64_t))(v29 + 8);
  v21(v14, AssociatedTypeWitness);
  v21(v16, AssociatedTypeWitness);
  v30(v11, (void (*)(void, void))v32, AssociatedTypeWitness);
  uint64_t v22 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v23 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v22 + 8);
  uint64_t v24 = v31;
  if ((v23(v11, (uint64_t)v31, AssociatedTypeWitness, v22) & 1) == 0)
  {
    uint64_t v32 = v21;
    uint64_t v26 = 0LL;
    uint64_t v27 = (void (*)(char *, uint64_t, const char *))*((void *)v19 + 24);
    while (1)
    {
      uint64_t v25 = v26 + 1;
      if (__OFADD__(v26, 1LL)) {
        break;
      }
      v27(v11, v33, v19);
      ++v26;
      if ((v23(v11, (uint64_t)v24, AssociatedTypeWitness, v22) & 1) != 0)
      {
        unint64_t v21 = v32;
        goto LABEL_8;
      }
    }

    __break(1u);
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Only BidirectionalCollections can have end come before start",  60LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x379uLL,  0);
  }

  uint64_t v25 = 0LL;
LABEL_8:
  v21(v11, AssociatedTypeWitness);
  return v25;
}

uint64_t Collection.formIndex(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v13 - v10;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 136))(a1, a2, a3, a4);
  (*(void (**)(uint64_t, unint64_t))(v9 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v9 + 32))(a1, v11, AssociatedTypeWitness);
}

BOOL Collection.formIndex(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v20 - v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 144))(a1, a2, a3, a4, a5);
  uint64_t v17 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v17 + 8))(a1, AssociatedTypeWitness);
  int v18 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v17 + 48))(v16, 1LL, AssociatedTypeWitness);
  if (v18 == 1)
  {
    (*(void (**)(char *, uint64_t))(v14 + 8))(v16, v13);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v17 + 16))(a1, a3, AssociatedTypeWitness);
  }

  else
  {
    (*(void (**)(uint64_t, char *, unint64_t))(v17 + 32))(a1, v16, AssociatedTypeWitness);
  }

  return v18 != 1;
}

uint64_t specialized Collection.randomElement<A>(using:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = &v23[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = &v23[-v11];
  if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 104))(a1, a2) & 1) != 0)
  {
    unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v13 - 8) + 56LL))( a3,  1LL,  1LL,  v13);
  }

  else
  {
    unint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 112))(a1, a2);
    if ((v15 & 0x8000000000000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    if (!v15) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't get random value with an empty range",  42LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xA79uLL,  0);
    }
    uint64_t v16 = specialized RandomNumberGenerator.next<A>(upperBound:)(v15);
    (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
    (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(a2 + 136))(v10, v16, a1, a2);
    uint64_t v17 = *(void (**)(_BYTE *, unint64_t))(v7 + 8);
    v17(v10, AssociatedTypeWitness);
    int v18 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t, uint64_t))(a2 + 80))( v23,  v12,  a1,  a2);
    uint64_t v20 = v19;
    unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v22 = *(void *)(v21 - 8);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v22 + 16))(a3, v20, v21);
    v18(v23, 0LL);
    v17(v12, AssociatedTypeWitness);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v22 + 56))(a3, 0LL, 1LL, v21);
  }

uint64_t Collection.randomElement<A>(using:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v28 = a2;
  uint64_t v29 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v26 - v13;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(a3 + 104))(a1, a3) & 1) != 0)
  {
    unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v15 - 8) + 56LL))( a5,  1LL,  1LL,  v15);
  }

  else
  {
    uint64_t v27 = a5;
    unint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 112))(a1, a3);
    if ((v17 & 0x8000000000000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    if (!v17) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't get random value with an empty range",  42LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xA79uLL,  0);
    }
    uint64_t v18 = specialized RandomNumberGenerator.next<A>(upperBound:)(v17, v28, v29);
    (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a1, a3);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(a3 + 136))(v12, v18, a1, a3);
    uint64_t v19 = *(void (**)(char *, unint64_t))(v9 + 8);
    v19(v12, AssociatedTypeWitness);
    uint64_t v20 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a3 + 80))( v30,  v14,  a1,  a3);
    uint64_t v22 = v21;
    unint64_t v23 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v24 = *(void *)(v23 - 8);
    uint64_t v25 = v27;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v24 + 16))(v27, v22, v23);
    v20(v30, 0LL);
    v19(v14, AssociatedTypeWitness);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v24 + 56))(v25, 0LL, 1LL, v23);
  }

uint64_t specialized static FixedWidthInteger.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v40 = a2;
  uint64_t v41 = a4;
  uint64_t v34 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v34 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v35 = v8;
  uint64_t v9 = *(void *)(v8 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v9 + 24),  v10,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  uint64_t v36 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v39 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v38 = (char *)&v34 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v37 = (char *)&v34 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v34 - v18;
  uint64_t v21 = type metadata accessor for Range(0LL, a3, *(void *)(*(void *)(v9 + 32) + 8LL), v20);
  uint64_t v22 = *(void *)(v21 - 8);
  MEMORY[0x1895F8858](v21);
  uint64_t v24 = (char *)&v34 - v23;
  (*(void (**)(char *, uint64_t, uint64_t))(v22 + 16))((char *)&v34 - v23, a1, v21);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v9 + 16) + 8LL) + 8LL))( v24,  &v24[*(int *)(v21 + 36)],  a3) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't get random value with an empty range",  42LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xA79uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v22 + 8))(v24, v21);
  uint64_t v25 = v35;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v35 + 88))(v7, a1, a3, v35);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v27 = *(void (**)(char *, uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 96);
  v27(v7, a3, v9, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v34 + 16))(v7, a1, a3);
  uint64_t v28 = v38;
  v27(v7, a3, v9, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v29 = swift_getAssociatedConformanceWitness( v25,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  swift_getAssociatedConformanceWitness( v25,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: UnsignedInteger);
  uint64_t v30 = v39;
  specialized RandomNumberGenerator.next<A>(upperBound:)(v19, AssociatedTypeWitness, v29, v39);
  uint64_t v31 = *(void (**)(char *, unint64_t))(v36 + 8);
  v31(v19, AssociatedTypeWitness);
  uint64_t v32 = v37;
  (*(void (**)(char *, char *, unint64_t, unint64_t))(v29 + 80))( v37,  v30,  AssociatedTypeWitness,  v29);
  v31(v30, AssociatedTypeWitness);
  v31(v28, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, unint64_t, unint64_t, uint64_t, uint64_t))(v9 + 96))( v32,  AssociatedTypeWitness,  AssociatedConformanceWitness,  a3,  v9);
}

uint64_t static FixedWidthInteger.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v47 = a2;
  uint64_t v48 = a5;
  uint64_t v46 = a4;
  uint64_t v49 = a6;
  uint64_t v41 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v38 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = v10;
  uint64_t v11 = *(void *)(v10 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 24),  v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  uint64_t v42 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v44 = (char *)&v38 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v40 = (char *)&v38 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v43 = (char *)&v38 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v21 = (char *)&v38 - v20;
  uint64_t v23 = type metadata accessor for Range(0LL, a3, *(void *)(*(void *)(v11 + 32) + 8LL), v22);
  uint64_t v24 = *(void *)(v23 - 8);
  MEMORY[0x1895F8858](v23);
  uint64_t v26 = (char *)&v38 - v25;
  (*(void (**)(char *, uint64_t, uint64_t))(v24 + 16))((char *)&v38 - v25, a1, v23);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v11 + 16) + 8LL) + 8LL))( v26,  &v26[*(int *)(v23 + 36)],  a3) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't get random value with an empty range",  42LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xA79uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v24 + 8))(v26, v23);
  uint64_t v27 = v45;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 88))(v9, a1, a3, v45);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  unint64_t v29 = *(void (**)(char *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 96);
  uint64_t v30 = a1;
  unint64_t v31 = AssociatedConformanceWitness;
  unint64_t v39 = AssociatedConformanceWitness;
  v29(v9, a3, v11, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v9, v30, a3);
  uint64_t v32 = v40;
  ((void (*)(char *, uint64_t, uint64_t, unint64_t, unint64_t))v29)( v9,  a3,  v11,  AssociatedTypeWitness,  v31);
  unint64_t v33 = swift_getAssociatedConformanceWitness( v27,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  uint64_t v34 = v44;
  RandomNumberGenerator.next<A>(upperBound:)(v21, v46, AssociatedTypeWitness, v48, v33, v44);
  uint64_t v35 = *(void (**)(char *, unint64_t))(v42 + 8);
  v35(v21, AssociatedTypeWitness);
  uint64_t v36 = v43;
  (*(void (**)(char *, char *, unint64_t, unint64_t))(v33 + 80))( v43,  v34,  AssociatedTypeWitness,  v33);
  v35(v34, AssociatedTypeWitness);
  v35(v32, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, unint64_t, unint64_t, uint64_t, uint64_t))(v11 + 96))( v36,  AssociatedTypeWitness,  v39,  a3,  v11);
}

uint64_t Collection.randomElement()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Collection.randomElement<A>(using:)(a1, a2, a3);
}

uint64_t specialized Collection<>.subscript.getter(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 < 0x10000)
  {
    if (result < 0 || a2 >= 2) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }

  else if (result < 0 || a2 > 2)
  {
    goto LABEL_8;
  }

  return result;
}

{
  uint64_t v3;
  if (a3 >= 0x80)
  {
    if (a3 >= 0x800)
    {
      if (HIWORD(a3))
      {
        if ((result & 0x8000000000000000LL) == 0 && a2 <= 4) {
          return result;
        }
      }

      else if ((result & 0x8000000000000000LL) == 0 && a2 <= 3)
      {
        return result;
      }

uint64_t Collection<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v67 = a1;
  uint64_t v65 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v61 = (char *)&v52 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v57 = (char *)&v52 - v11;
  uint64_t v66 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v52 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v52 - v21;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v59 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v24);
  uint64_t v55 = *(void *)(v59 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v59);
  uint64_t v58 = (char *)&v52 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v28 = (char *)&v52 - v27;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  unint64_t v29 = *(void (**)(uint64_t, uint64_t))(a3 + 72);
  uint64_t v63 = a2;
  uint64_t v64 = v4;
  uint64_t v62 = a3;
  uint64_t v30 = a3;
  unint64_t v31 = v66;
  v29(a2, v30);
  uint64_t v32 = (void (*)(char *, char *, unint64_t))v31[2];
  uint64_t v54 = v22;
  v32(v17, v22, AssociatedTypeWitness);
  uint64_t v56 = v20;
  v32(v14, v20, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v17,  v14,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v53 = v28;
  unint64_t v33 = (void (*)(char *, unint64_t))v31[1];
  v33(v14, AssociatedTypeWitness);
  v33(v17, AssociatedTypeWitness);
  uint64_t v34 = TupleTypeMetadata2;
  uint64_t v35 = v57;
  uint64_t v36 = &v57[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v37 = (void (*)(char *, char *, unint64_t))v31[4];
  v37(v57, v54, AssociatedTypeWitness);
  v37(v36, v56, AssociatedTypeWitness);
  uint64_t v38 = v61;
  unint64_t v39 = &v61[*((int *)v34 + 12)];
  v32(v61, v35, AssociatedTypeWitness);
  v32(v39, v36, AssociatedTypeWitness);
  uint64_t v40 = v58;
  v37(v58, v38, AssociatedTypeWitness);
  v33(v39, AssociatedTypeWitness);
  uint64_t v41 = &v38[*((int *)v34 + 12)];
  v37(v38, v35, AssociatedTypeWitness);
  v37(v41, v36, AssociatedTypeWitness);
  uint64_t v42 = v59;
  v37(&v40[*(int *)(v59 + 36)], v41, AssociatedTypeWitness);
  v33(v38, AssociatedTypeWitness);
  uint64_t v43 = v55;
  uint64_t v44 = v53;
  (*(void (**)(char *, char *, uint64_t))(v55 + 32))(v53, v40, v42);
  uint64_t v45 = v62;
  uint64_t v46 = v63;
  uint64_t v47 = v64;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v62 + 176))(v67, v44, v63, v62);
  (*(void (**)(char *, uint64_t))(v43 + 8))(v44, v42);
  uint64_t v49 = type metadata accessor for Slice(0LL, v46, v45, v48);
  uint64_t v50 = v65;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v46 - 8) + 16LL))(&v65[*(int *)(v49 + 40)], v47, v46);
  (*(void (**)(char *, uint64_t, uint64_t))(v43 + 16))(v40, v67, v42);
  v37(v50, v40, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, unint64_t))v37)( &v50[*(int *)(v49 + 36)],  &v40[*(int *)(v42 + 36)],  AssociatedTypeWitness);
}

uint64_t Slice.init(base:bounds:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = type metadata accessor for Slice(0LL, a3, (uint64_t)a4, (uint64_t)a4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 32LL))(a5 + *(int *)(v10 + 40), a1, a3);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v16 = *(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL);
  v16(a5, a2, AssociatedTypeWitness);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = a2
      + *(int *)(type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13) + 36);
  return ((uint64_t (*)(uint64_t, uint64_t, unint64_t))v16)( a5 + *(int *)(v10 + 36),  v14,  AssociatedTypeWitness);
}

uint64_t Collection<>.popFirst()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v90 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v82 = (char *)&v69 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  char v79 = (char *)&v69 - v10;
  uint64_t v87 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  unint64_t v85 = (char *)&v69 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v84 = (char *)&v69 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v86 = (char *)&v69 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v69 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v88 = (char *)&v69 - v20;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v77 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v21);
  uint64_t v80 = *(void *)(v77 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v77);
  uint64_t v76 = (char *)&v69 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v78 = (char *)&v69 - v25;
  uint64_t v26 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v24);
  char v89 = (char *)&v69 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v28 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a2 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v31 = type metadata accessor for Optional(0LL, v28, v29, v30);
  uint64_t v32 = MEMORY[0x1895F8858](v31);
  uint64_t v34 = (char *)&v69 - v33;
  unint64_t v35 = v28;
  uint64_t v36 = *(void *)(v28 - 8);
  MEMORY[0x1895F8858](v32);
  uint64_t v38 = (char *)&v69 - v37;
  unint64_t v39 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 104);
  uint64_t v91 = v3;
  if ((v39(a1, a2) & 1) != 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v36 + 56))(v90, 1LL, 1LL, v35);
  }
  Collection.first.getter(a1, a2, (uint64_t)v34);
  uint64_t v75 = v36;
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v36 + 48))(v34, 1LL, v35) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x425uLL,  0);
  }
  uint64_t v41 = *(void (**)(uint64_t, char *, unint64_t))(v75 + 32);
  uint64_t v73 = v38;
  unint64_t v70 = v35;
  uint64_t v74 = v41;
  v41((uint64_t)v38, v34, v35);
  uint64_t v42 = v91;
  (*(void (**)(char *, char *, uint64_t))(v26 + 16))(v89, v91, a1);
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  uint64_t v43 = v88;
  (*(void (**)(char *, uint64_t, uint64_t))(a2 + 184))(v19, a1, a2);
  uint64_t v44 = v87;
  uint64_t v45 = a1;
  uint64_t v46 = *(void (**)(char *, unint64_t))(v87 + 8);
  v46(v19, AssociatedTypeWitness);
  uint64_t v47 = v86;
  (*(void (**)(uint64_t, uint64_t))(a2 + 72))(v45, a2);
  uint64_t v48 = *(void (**)(char *, uint64_t))(v26 + 8);
  uint64_t v71 = v45;
  uint64_t v72 = v48;
  v48(v42, v45);
  uint64_t v49 = *(void (**)(char *, char *, unint64_t))(v44 + 16);
  uint64_t v50 = v84;
  v49(v84, v43, AssociatedTypeWitness);
  uint64_t v51 = v85;
  v49(v85, v47, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v50,  v51,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v46(v51, AssociatedTypeWitness);
  v46(v50, AssociatedTypeWitness);
  uint64_t v52 = v47;
  uint64_t v53 = TupleTypeMetadata2;
  uint64_t v54 = v79;
  uint64_t v55 = &v79[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v56 = *(void (**)(char *, char *, unint64_t))(v44 + 32);
  v56(v79, v88, AssociatedTypeWitness);
  v56(v55, v52, AssociatedTypeWitness);
  uint64_t v57 = v82;
  uint64_t v58 = &v82[*((int *)v53 + 12)];
  v49(v82, v54, AssociatedTypeWitness);
  v49(v58, v55, AssociatedTypeWitness);
  uint64_t v59 = v76;
  v56(v76, v57, AssociatedTypeWitness);
  v46(v58, AssociatedTypeWitness);
  uint64_t v60 = &v57[*((int *)v53 + 12)];
  v56(v57, v54, AssociatedTypeWitness);
  v56(v60, v55, AssociatedTypeWitness);
  uint64_t v61 = v77;
  v56(&v59[*(int *)(v77 + 36)], v60, AssociatedTypeWitness);
  v46(v57, AssociatedTypeWitness);
  uint64_t v62 = v80;
  uint64_t v63 = v78;
  uint64_t v64 = v61;
  (*(void (**)(char *, char *, uint64_t))(v80 + 32))(v78, v59, v61);
  uint64_t v65 = v89;
  uint64_t v66 = v71;
  (*(void (**)(char *, uint64_t, uint64_t))(a2 + 88))(v63, v71, a2);
  (*(void (**)(char *, uint64_t))(v62 + 8))(v63, v64);
  v72(v65, v66);
  uint64_t v67 = v90;
  unint64_t v68 = v70;
  v74(v90, v73, v70);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v75 + 56))(v67, 0LL, 1LL, v68);
}

uint64_t Collection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return Collection.map<A>(_:)( a1,  a2,  a3,  a4,  a5,  (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error),  (uint64_t (*)(uint64_t, void *))_sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm);
}

Swift::UInt64 specialized Collection.dropFirst(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a collection",  58LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x4E1uLL,  0);
  }
  uint64_t v5 = a1;
  if ((a3 & 0x2000000000000000LL) != 0) {
    Swift::UInt64 v6 = HIBYTE(a3) & 0xF;
  }
  else {
    Swift::UInt64 v6 = a2 & 0xFFFFFFFFFFFFLL;
  }
  Swift::UInt64 v7 = v6 << 16;
  BOOL v8 = (a3 & 0x1000000000000000LL) == 0 || (a2 & 0x800000000000000LL) != 0;
  if (v8)
  {
    v9._Swift::UInt64 rawBits = v7 | 7;
    if ((a3 & 0x1000000000000000LL) == 0)
    {
      LOBYTE(v1swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = 1;
      goto LABEL_13;
    }
  }

  else
  {
    v9._Swift::UInt64 rawBits = v7 | 0xB;
  }

  unint64_t v10 = (a2 & 0x800000000000000uLL) >> 59;
LABEL_13:
  BOOL v32 = v8;
  if ((v9._rawBits & 0xC) == 4LL << v10) {
    v9._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v9)._rawBits;
  }
  v11._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)15LL)._rawBits;
  Swift::UInt64 v12 = v9._rawBits >> 14;
  if (v5)
  {
    Swift::UInt64 v13 = v6 << 16;
    int v14 = v32;
    while (v12 > v11._rawBits >> 14)
    {
      Swift::UInt64 v15 = v11._rawBits >> 16;
      if (v11._rawBits >> 16 >= v6) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0xE5uLL,  0);
      }
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 rawBits = v11._rawBits;
        Swift::UInt64 v21 = v13;
        v22._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
        int v14 = v32;
        Swift::UInt64 v13 = v21;
        v11._Swift::UInt64 rawBits = v22._rawBits;
        if (!--v5) {
          goto LABEL_32;
        }
      }

      else
      {
        if ((a3 & 0x2000000000000000LL) != 0)
        {
          v33[0] = a2;
          v33[1] = a3 & 0xFFFFFFFFFFFFFFLL;
          int v17 = *((unsigned __int8 *)v33 + v15);
        }

        else
        {
          uint64_t v16 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a2 & 0x1000000000000000LL) == 0)
          {
            Swift::UInt64 v23 = v13;
            uint64_t v16 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
            int v14 = v32;
            Swift::UInt64 v13 = v23;
          }

          int v17 = v16[v15];
        }

        int v18 = (char)v17;
        unsigned int v19 = __clz(v17 ^ 0xFF) - 24;
        if (v18 >= 0) {
          LOBYTE(v19) = 1;
        }
        v11._Swift::UInt64 rawBits = ((v15 + v19) << 16) | 5;
        if (!--v5) {
          goto LABEL_32;
        }
      }
    }

LABEL_33:
    if (v14) {
      v11._Swift::UInt64 rawBits = v13 | 7;
    }
    else {
      v11._Swift::UInt64 rawBits = v13 | 0xB;
    }
    goto LABEL_36;
  }

  Swift::UInt64 v13 = v6 << 16;
  int v14 = v32;
LABEL_32:
  if (v12 < v11._rawBits >> 14) {
    goto LABEL_33;
  }
LABEL_36:
  uint64_t v24 = 11LL;
  if (v14) {
    uint64_t v24 = 7LL;
  }
  unint64_t v25 = 4 * v6;
  Swift::UInt64 v26 = v11._rawBits >> 14;
  if (4 * v6 < v11._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v27 = 4LL << v14;
  Swift::UInt64 v28 = v13 | v24;
  uint64_t v29 = v11._rawBits & 0xC;
  uint64_t v30 = v24 & 0xC;
  if (v30 == 4LL << v14 || v29 == v27 || (v11._rawBits & 1) == 0)
  {
    if (v30 == v27)
    {
      Swift::UInt64 v28 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v28)._rawBits;
      if (v29 != v27) {
        goto LABEL_44;
      }
    }

    else if (v29 != v27)
    {
LABEL_44:
      if (v25 < v28 >> 14 || v28 >> 14 < v26) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x50uLL,  0);
      }
      if ((v11._rawBits & 1) != 0)
      {
        if ((v28 & 1) != 0) {
          return v11._rawBits;
        }
      }

      else
      {
        v11._Swift::UInt64 rawBits = v11._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v11)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        if ((v28 & 1) != 0) {
          return v11._rawBits;
        }
      }

      _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v28)._rawBits;
      return v11._rawBits;
    }

    v11._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v11)._rawBits;
    Swift::UInt64 v26 = v11._rawBits >> 14;
    goto LABEL_44;
  }

  return v11._rawBits;
}

        uint64_t v55 = v54;
        uint64_t v56 = v7;
        uint64_t v145 = (char *)((v88 - 1) & v88);
        uint64_t v57 = __clz(__rbit64(v88)) + (v86 << 6);
        unint64_t v138 = v86;
      }

      uint64_t v58 = v148;
      uint64_t v59 = v147;
      (*(void (**)(uint64_t *, unint64_t, char *))(v26 + 16))( v141,  *(void *)(v148 + 48) + *(void *)(v26 + 72) * v57,  v147);
      uint64_t v60 = *(void *)(v58 + 56);
      uint64_t v61 = v52;
      uint64_t v62 = v60 + *(void *)(v52 + 72) * v57;
      uint64_t v63 = *(void (**)(uint64_t *, uint64_t, uint64_t *))(v52 + 16);
      uint64_t v64 = v146;
      v63(v53, v62, v146);
      uint64_t v65 = v149;
      uint64_t v66 = v144;
      uint64_t v67 = &v144[*((int *)v149 + 12)];
      (*(void (**)(char *, uint64_t *, const char *))(v143 + 32))(v144, v85, v59);
      unint64_t v68 = v67;
      Swift::UInt64 v26 = v143;
      (*(void (**)(char *, uint64_t *, uint64_t *))(v61 + 32))(v68, v53, v64);
      uint64_t v69 = *(void (**)(char *, void, uint64_t, unint64_t *))(v56 + 56);
      unint64_t v70 = v65;
      Swift::UInt64 v7 = v56;
      uint64_t v71 = v61;
      v69(v66, 0LL, 1LL, v70);
      uint64_t v54 = v55;
      goto LABEL_21;
    }

    uint64_t v90 = (void *)v135;
    uint64_t v91 = *(void *)(v135 + 216);
    if (v91 < 0) {
      goto LABEL_53;
    }
    uint64_t v92 = *(void **)(v135 + 208);
    if (v91 == *(void *)(v135 + 224)) {
      break;
    }
LABEL_38:
    uint64_t v94 = v90[3];
    if (!v94) {
      goto LABEL_59;
    }
    unint64_t v95 = (void **)(v94 + 8 * v91);
    unint64_t v96 = (uint64_t *)v147;
    id v97 = v54;
    uint64_t v98 = *v95;
    v90[27] = v91 + 1;
    swift_unknownObjectRetain(v98, v49, v50, v51);
    unint64_t v99 = (swift *)objc_msgSend(v92, sel_objectForKey_, v98);
    if (!v99)
    {
      uint64_t v119 = 784LL;
      goto LABEL_61;
    }

    char v100 = v99;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v96, v96);
    BOOL v102 = v134;
    if (isClassOrObjCExistentialType)
    {
      *(void *)&v156[0] = v98;
      Swift::Int v103 = v144;
      swift_dynamicCast(v144, (uint64_t *)v156, v133, v147, 7uLL);
    }

    else
    {
      uint64_t v106 = v41;
      unint64_t v107 = v143;
      char v108 = v147;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v143 + 56))(v134, 1LL, 1LL, v147);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v98, (uint64_t)v108, v102);
      swift_unknownObjectRelease(v98);
      unint64_t v109 = v122;
      uint64_t v110 = v121;
      unint64_t v111 = v123;
      (*(void (**)(char *, uint64_t *, uint64_t))(v122 + 16))(v121, v102, v123);
      (*(void (**)(uint64_t *, uint64_t))(v109 + 8))(v102, v111);
      Swift::Int v103 = v144;
      (*(void (**)(char *, char *, char *))(v107 + 32))(v144, v110, v147);
      uint64_t v41 = v106;
    }

    uint64_t v145 = (char *)v41;
    char v104 = &v103[*((int *)v149 + 12)];
    uint64_t v105 = _swift_isClassOrObjCExistentialType((uint64_t)v146, v146);
    uint64_t v71 = v137;
    if (v105)
    {
      *(void *)&v156[0] = v100;
      swift_dynamicCast(v104, (uint64_t *)v156, (swift *)&unk_189B8D230, (const char *)v146, 7uLL);
    }

    else
    {
      uint64_t v112 = v124;
      BOOL v113 = v146;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v137 + 56))(v124, 1LL, 1LL, v146);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v100, (uint64_t)v113, v112);
      swift_unknownObjectRelease(v100);
      uint64_t v114 = v126;
      uint64_t v115 = v125;
      uint64_t v116 = v127;
      (*(void (**)(char *, uint64_t *, uint64_t))(v126 + 16))(v125, v112, v127);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v71 + 48))(v115, 1LL, v113) == 1) {
LABEL_62:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      (*(void (**)(uint64_t *, uint64_t))(v114 + 8))(v112, v116);
      (*(void (**)(char *, char *, uint64_t *))(v71 + 32))(v104, v115, v146);
    }

    uint64_t v66 = v144;
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v7 + 56))(v144, 0LL, 1LL, v149);
    uint64_t v54 = v97;
    uint64_t v53 = v136;
    Swift::UInt64 v26 = v143;
    unint64_t v85 = v141;
LABEL_21:
    uint64_t v72 = v66;
    uint64_t v73 = v149;
    (*(void (**)(char *, char *, unint64_t *))(v7 + 32))(v54, v72, v149);
    uint64_t v74 = &v54[*((int *)v73 + 12)];
    uint64_t v75 = (swift *)v147;
    (*(void (**)(uint64_t *, char *, char *))(v26 + 32))(v85, v54, v147);
    swift_dynamicCast((char *)&v152, v85, v75, (const char *)&type metadata for AnyHashable, 7uLL);
    uint64_t v52 = v71;
    uint64_t v76 = (swift *)v146;
    (*(void (**)(uint64_t *, char *, uint64_t *))(v71 + 32))(v53, v74, v146);
    uint64_t v77 = v140;
    swift_dynamicCast(v140, v53, v76, (const char *)&type metadata for AnyHashable, 7uLL);
    uint64_t v78 = v154;
    uint64_t v157 = v154;
    uint64_t v80 = v152;
    char v79 = v153;
    v156[0] = v152;
    v156[1] = v153;
    int64_t v81 = *((_OWORD *)v77 + 1);
    uint64_t v82 = v139;
    *(_OWORD *)uint64_t v139 = *(_OWORD *)v77;
    *((_OWORD *)v82 + 1) = v81;
    uint64_t v83 = *((void *)v77 + 4);
    *((void *)v82 + 4) = v83;
    char v152 = v80;
    uint64_t v153 = v79;
    BOOL v154 = v78;
    unint64_t v84 = *((_OWORD *)v82 + 1);
    v150[0] = *(_OWORD *)v82;
    v150[1] = v84;
    unint64_t v151 = v83;
    specialized _NativeDictionary._unsafeInsertNew(key:value:)(&v152, (uint64_t)v150, v142);
    uint64_t v41 = (unint64_t)v145;
  }

  unint64_t v93 = objc_msgSend(*(id *)(v135 + 208), sel_countByEnumeratingWithState_objects_count_, v130, v129, 16);
  v90[28] = v93;
  if (v93)
  {
    uint64_t v91 = 0LL;
    v90[27] = 0LL;
    goto LABEL_38;
  }

  v90[27] = -1LL;
LABEL_53:
  uint64_t v87 = v144;
LABEL_54:
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v7 + 56))(v87, 1LL, 1LL, v149);
  uint64_t v117 = v142;
  swift_release((uint64_t)v142);
  outlined consume of [A : B].Iterator._Variant<A, B>(v148);
  return v117;
}

          uint64_t v145 = v116(v84, v90);
          v114(v126, v111, v84);
          if (v145 >= 65)
          {
            v87(v126, v84);
            v114(v92, v111, v84);
LABEL_35:
            uint64_t v372 = 0x7FFFFFFFFFFFFFFFLL;
            id v146 = v125(v84, v90);
            uint64_t v147 = v116(v84, v90);
            if ((v146 & 1) != 0)
            {
              unint64_t v133 = v363;
              if (v147 > 64)
              {
                Swift::Bool v150 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v90 + 96);
                unint64_t v151 = lazy protocol witness table accessor for type Int and conformance Int(v147, v148, v149);
                v150(&v372, &type metadata for Int, v151, v84, v90);
                char v152 = v348(v133, v92, v84, v346);
                v87(v133, v84);
                uint64_t v153 = v92;
                goto LABEL_105;
              }
            }

            else
            {
              unint64_t v133 = v363;
              if (v147 > 63)
              {
LABEL_104:
                uint64_t v371 = 0x7FFFFFFFFFFFFFFFLL;
                unint64_t v232 = (*(uint64_t (**)(char *, char *, uint64_t))(v368 + 32))(v133, v92, v84);
                uint64_t v233 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v90 + 96);
                unint64_t v236 = lazy protocol witness table accessor for type Int and conformance Int(v232, v234, v235);
                unint64_t v237 = v340;
                v233(&v371, &type metadata for Int, v236, v84, v90);
                char v152 = v348(v237, v133, v84, v346);
                v87(v237, v84);
                uint64_t v153 = v133;
LABEL_105:
                v87(v153, v84);
                if ((v152 & 1) == 0) {
                  goto LABEL_106;
                }
LABEL_138:
                unint64_t v370 = (uint64_t (*)(void, void))v84;
                Swift::String::Index v364 = v111;
LABEL_168:
                ((void (*)(uint64_t, uint64_t (*)(uint64_t, unint64_t)))v355)(v364, v370);
LABEL_169:
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Distance is not representable in Int",  36LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x64AuLL,  0);
              }
            }

            (*(void (**)(char *, char *, uint64_t))(v368 + 32))(v133, v92, v84);
            (*(void (**)(uint64_t, uint64_t))(v90 + 120))(v84, v90);
            unint64_t v203 = v133;
LABEL_92:
            v87(v203, v84);
LABEL_106:
            uint64_t v230 = (*(uint64_t (**)(uint64_t, uint64_t))(v90 + 120))(v84, v90);
            v87((char *)v111, v84);
            return v230;
          }

          BOOL v196 = v116(v84, v90);
          v87(v126, v84);
          if (v196 == 64)
          {
            Swift::Int v197 = v125(v84, v90);
            v114(v92, v111, v84);
            if ((v197 & 1) == 0) {
              goto LABEL_35;
            }
          }

          else
          {
            v114(v92, v111, v84);
          }

          unint64_t v203 = v92;
          goto LABEL_92;
        }

        char v264 = v119(v4, v90);
        unint64_t v370 = (uint64_t (*)(void, void))v4;
        uint64_t v265 = v116(v4, v90);
        if ((v264 & 1) != 0)
        {
          if (v265 > 64)
          {
            char v268 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v90 + 96);
            uint64_t v269 = lazy protocol witness table accessor for type Int and conformance Int(v265, v266, v267);
            uint64_t v270 = v363;
            unint64_t v84 = (uint64_t)v370;
            v268(&v372, &type metadata for Int, v269, (uint64_t)v370, v90);
            unint64_t v271 = v348(v118, v270, v84, v346);
            uint64_t v87 = (void (*)(char *, uint64_t))v355;
            ((void (*)(char *, uint64_t))v355)(v270, v84);
            v87(v118, v84);
            uint64_t v125 = v367;
            unint64_t v111 = (uint64_t)v358;
            uint64_t v92 = v349;
            uint64_t v126 = v347;
            if ((v271 & 1) == 0) {
              goto LABEL_33;
            }
            goto LABEL_165;
          }

          ((void (*)(void *, uint64_t))v360)(&unk_18180BE68, 256LL);
          unint64_t v326 = v363;
          unint64_t v327 = v27;
          unint64_t v84 = (uint64_t)v370;
          ((void (*)(char *, uint64_t (*)(uint64_t, unint64_t), uint64_t))v341)( v327,  v370,  v78);
          uint64_t v328 = v348(v118, v326, v84, v346);
          uint64_t v87 = (void (*)(char *, uint64_t))v355;
          ((void (*)(char *, uint64_t))v355)(v326, v84);
          uint64_t v329 = v333;
          (*(void (**)(char *, char *, uint64_t))(v368 + 32))(v333, v118, v84);
          unint64_t v111 = (uint64_t)v358;
          if ((v328 & 1) != 0)
          {
            v87(v329, v84);
            Swift::String::Index v364 = v111;
            goto LABEL_168;
          }

          uint64_t v330 = v372;
          uint64_t v331 = (*(uint64_t (**)(uint64_t, uint64_t))(v90 + 120))(v84, v90);
          v87(v329, v84);
          uint64_t v316 = v331 < v330;
          uint64_t v125 = v367;
          uint64_t v92 = v349;
LABEL_163:
          uint64_t v126 = v347;
          if (!v316) {
            goto LABEL_33;
          }
LABEL_165:
          Swift::String::Index v364 = v111;
          goto LABEL_168;
        }

        unint64_t v111 = (uint64_t)v358;
        uint64_t v92 = v349;
        if (v265 < 64)
        {
          uint64_t v314 = v354;
          unint64_t v84 = (uint64_t)v370;
          uint64_t v315 = (*(uint64_t (**)(uint64_t, uint64_t))(v90 + 120))((uint64_t)v370, v90);
          uint64_t v87 = (void (*)(char *, uint64_t))v355;
          ((void (*)(char *, uint64_t))v355)(v314, v84);
          uint64_t v316 = v315 < v372;
          uint64_t v125 = v367;
          goto LABEL_163;
        }

        uint64_t v87 = (void (*)(char *, uint64_t))v355;
        unint64_t v84 = (uint64_t)v370;
        ((void (*)(char *, uint64_t (*)(uint64_t, unint64_t)))v355)(v354, v370);
        uint64_t v125 = v367;
LABEL_32:
        uint64_t v126 = v347;
        goto LABEL_33;
      }
    }

    else
    {
      uint64_t v90 = v112;
      uint64_t v87 = (void (*)(char *, uint64_t))v355;
      ((void (*)(char *, uint64_t))v355)(v115, v4);
      int v118 = v354;
      v114(v354, v111, v4);
    }

    v87(v118, v4);
    uint64_t v116 = *(uint64_t (**)(uint64_t, uint64_t))(v90 + 128);
    uint64_t v125 = v367;
    uint64_t v92 = v349;
    unint64_t v84 = v4;
    goto LABEL_32;
  }

  uint64_t v80 = v364;
  int64_t v81 = *(void (**)(uint64_t, uint64_t))(v364 + 56);
  uint64_t v82 = v361;
  v81(v4, v364);
  uint64_t v83 = v357;
  v81(v4, v80);
  unint64_t v85 = (uint64_t)v352;
  unint64_t v84 = (uint64_t)v353;
  (*(void (**)(uint64_t, char *, unint64_t *))(*(void *)(AssociatedConformanceWitness + 8) + 24LL))( v82,  v83,  v353);
  uint64_t v86 = v359;
  uint64_t v87 = *(void (**)(char *, uint64_t))(v359 + 8);
  v87(v83, v84);
  v87((char *)v82, v84);
  uint64_t v88 = swift_getAssociatedConformanceWitness( v366,  v4,  v84,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  unint64_t v369 = *(uint64_t (**)(uint64_t, unint64_t))(v88 + 64);
  char v89 = v369(v84, v88);
  uint64_t v90 = *(void *)(v86 + 16);
  uint64_t v91 = v343;
  ((void (*)(char *, uint64_t, uint64_t))v90)(v343, v85, v84);
  unint64_t v370 = (uint64_t (*)(void, void))v4;
  if ((v89 & 1) == 0)
  {
    v87(v91, v84);
    uint64_t v94 = v356;
    ((void (*)(char *, uint64_t, uint64_t))v90)(v356, v85, v84);
    unint64_t v95 = v350;
    goto LABEL_20;
  }

  uint64_t v92 = *(char **)(v88 + 128);
  unint64_t v93 = ((uint64_t (*)(uint64_t, unint64_t))v92)(v84, v88);
  v87(v91, v84);
  uint64_t v94 = v356;
  ((void (*)(char *, uint64_t, uint64_t))v90)(v356, v85, v84);
  unint64_t v95 = v350;
  if (v93 < 65)
  {
LABEL_20:
    v87(v94, v84);
    uint64_t v92 = *(char **)(v88 + 128);
    goto LABEL_21;
  }

  uint64_t v372 = 0x8000000000000000LL;
  unint64_t v96 = v369;
  if ((v369(v84, v88) & 1) != 0)
  {
    id v97 = ((uint64_t (*)(uint64_t, unint64_t))v92)(v84, v88);
    if (v97 < 64)
    {
      char v100 = (*(uint64_t (**)(uint64_t, unint64_t))(v88 + 120))(v84, v88);
      goto LABEL_151;
    }

    uint64_t v368 = *(void *)(v88 + 96);
    unint64_t v285 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
    unint64_t v286 = v94;
    unint64_t v287 = v361;
    ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))v368)( &v372,  &type metadata for Int,  v285,  v84,  v88);
    uint64_t v288 = swift_getAssociatedConformanceWitness( v364,  (uint64_t)v370,  v84,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    Swift::Bool v262 = (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v288 + 16))(v286, v287, v84, v288);
    v87((char *)v287, v84);
    unint64_t v263 = v286;
    goto LABEL_135;
  }

  uint64_t v253 = v96(v84, v88);
  uint64_t v254 = ((uint64_t (*)(uint64_t, unint64_t))v92)(v84, v88);
  if ((v253 & 1) == 0)
  {
    if (v254 < 64)
    {
      uint64_t v94 = v356;
      char v100 = (*(uint64_t (**)(uint64_t, unint64_t))(v88 + 120))(v84, v88);
LABEL_151:
      uint64_t v313 = v100;
      v87(v94, v84);
      unint64_t v133 = (char *)v369;
      if (v313 < v372) {
        goto LABEL_159;
      }
      goto LABEL_22;
    }

    v87(v356, v84);
LABEL_21:
    unint64_t v133 = (char *)v369;
    goto LABEL_22;
  }

  if (v254 > 64)
  {
    id v257 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))(v88 + 96);
    uint64_t v258 = lazy protocol witness table accessor for type Int and conformance Int(v254, v255, v256);
    uint64_t v259 = v361;
    v257(&v372, &type metadata for Int, v258, v84, v88);
    uint64_t v260 = swift_getAssociatedConformanceWitness( v364,  (uint64_t)v370,  v84,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    uint64_t v261 = v356;
    Swift::Bool v262 = (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v260 + 16))(v356, v259, v84, v260);
    v87((char *)v259, v84);
    unint64_t v263 = v261;
LABEL_135:
    v87(v263, v84);
    unint64_t v133 = (char *)v369;
    if ((v262 & 1) != 0) {
      goto LABEL_159;
    }
    goto LABEL_22;
  }

  uint64_t v317 = v336;
  unint64_t v318 = v335;
  unint64_t v319 = swift_getAssociatedConformanceWitness( (uint64_t)v336,  v84,  v335,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v320 = v334;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v319 + 8))( &unk_18180BE68,  256LL,  v318,  v319);
  (*((void (**)(char *, uint64_t, const char *))v317 + 3))(v320, v84, v317);
  uint64_t v321 = swift_getAssociatedConformanceWitness( v364,  (uint64_t)v370,  v84,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  size_t v322 = v361;
  LOBYTE(v318) = (*(uint64_t (**)(char *, unint64_t, uint64_t, unint64_t))(v321 + 16))( v356,  v361,  v84,  v321);
  v87((char *)v322, v84);
  char v323 = v337;
  (*(void (**)(char *, char *, uint64_t))(v359 + 32))(v337, v356, v84);
  if ((v318 & 1) != 0)
  {
    Swift::String::Index v355 = (char *)v87;
    v87(v323, v84);
    goto LABEL_160;
  }

  uint64_t v324 = v372;
  unint64_t v325 = (*(uint64_t (**)(uint64_t, unint64_t))(v88 + 120))(v84, v88);
  v87(v323, v84);
  unint64_t v284 = v325 < v324;
  unint64_t v133 = (char *)v369;
  if (v284) {
    goto LABEL_159;
  }
LABEL_22:
  uint64_t v134 = ((uint64_t (*)(uint64_t, unint64_t))v92)(v84, v88);
  ((void (*)(char *, uint64_t, uint64_t))v90)(v95, v85, v84);
  if (v134 < 65)
  {
    char v185 = ((uint64_t (*)(uint64_t, unint64_t))v92)(v84, v88);
    v87(v95, v84);
    if (v185 == 64)
    {
      uint64_t v186 = ((uint64_t (*)(uint64_t, unint64_t))v133)(v84, v88);
      unint64_t v111 = (uint64_t)v351;
      ((void (*)(char *, uint64_t, uint64_t))v90)(v351, v85, v84);
      if ((v186 & 1) == 0) {
        goto LABEL_59;
      }
    }

    else
    {
      unint64_t v111 = (uint64_t)v351;
      ((void (*)(char *, uint64_t, uint64_t))v90)(v351, v85, v84);
    }

    v87((char *)v111, v84);
    goto LABEL_100;
  }

  v87(v95, v84);
  unint64_t v111 = (uint64_t)v351;
  ((void (*)(char *, uint64_t, uint64_t))v90)(v351, v85, v84);
LABEL_59:
  uint64_t v372 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v187 = ((uint64_t (*)(uint64_t, unint64_t))v133)(v84, v88);
  id v188 = ((uint64_t (*)(uint64_t, unint64_t))v92)(v84, v88);
  if ((v187 & 1) != 0)
  {
    if (v188 > 64)
    {
      unint64_t v133 = *(char **)(v88 + 96);
      uint64_t v191 = lazy protocol witness table accessor for type Int and conformance Int(v188, v189, v190);
      Swift::Bool v192 = v361;
      ((void (*)(int64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))v133)( &v372,  &type metadata for Int,  v191,  v84,  v88);
      unint64_t v193 = swift_getAssociatedConformanceWitness( v364,  (uint64_t)v370,  v84,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v194 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v193 + 16))(v192, v111, v84, v193);
      v87((char *)v192, v84);
      uint64_t v195 = v111;
      goto LABEL_99;
    }
  }

  else if (v188 > 63)
  {
    uint64_t v371 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v224 = v361;
    unint64_t v225 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v359 + 32))(v361, v111, v84);
    unint64_t v133 = *(char **)(v88 + 96);
    uint64_t v228 = lazy protocol witness table accessor for type Int and conformance Int(v225, v226, v227);
    unint64_t v111 = (uint64_t)v357;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))v133)( &v371,  &type metadata for Int,  v228,  v84,  v88);
    unint64_t v229 = swift_getAssociatedConformanceWitness( v364,  (uint64_t)v370,  v84,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v194 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v229 + 16))(v111, v224, v84, v229);
    v87((char *)v111, v84);
    uint64_t v195 = v224;
LABEL_99:
    v87((char *)v195, v84);
    if ((v194 & 1) == 0) {
      goto LABEL_100;
    }
LABEL_159:
    Swift::String::Index v355 = (char *)v87;
LABEL_160:
    unint64_t v370 = (uint64_t (*)(void, void))v84;
    Swift::String::Index v364 = v85;
    goto LABEL_168;
  }

  unint64_t v202 = v361;
  (*(void (**)(unint64_t, uint64_t, uint64_t))(v359 + 32))(v361, v111, v84);
  unint64_t v133 = (char *)(*(uint64_t (**)(uint64_t, unint64_t))(v88 + 120))(v84, v88);
  v87((char *)v202, v84);
LABEL_100:
  uint64_t v230 = (*(uint64_t (**)(uint64_t, unint64_t))(v88 + 120))(v84, v88);
  v87((char *)v85, v84);
  if ((v365 & 1) == 0)
  {
    char v231 = __OFSUB__(0LL, v230);
    uint64_t v230 = -v230;
    if (v231)
    {
      __break(1u);
      goto LABEL_104;
    }
  }

  return v230;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if ((v16 & 1) == 0)
  {
    if ((a1 & 0x8000000000000000LL) == 0
      && 1LL << *(_BYTE *)(a3 + 32) > a1
      && ((*(void *)(a3 + (((unint64_t)a1 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> a1) & 1) != 0
      && *(_DWORD *)(a3 + 36) == (_DWORD)a2)
    {
      (*(void (**)(char *, uint64_t, char *))(v12 + 16))( a6,  *(void *)(a3 + 48) + *(void *)(v12 + 72) * a1,  a4);
      return;
    }

    uint64_t v49 = 266LL;
LABEL_32:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  v49,  0);
  }

  uint64_t v55 = (char *)&v50 - v17;
  if (a1 >= 0) {
    Swift::UInt64 v28 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    Swift::UInt64 v28 = a1;
  }
  uint64_t v29 = type metadata accessor for __CocoaSet.Index.Storage();
  swift_bridgeObjectRetain(a1, v30, v31, v32);
  if (!swift_dynamicCastClass(v28, v29)) {
    goto LABEL_33;
  }
  if (!swift_dynamicCastClass(v28, v29)) {
    goto LABEL_33;
  }
  uint64_t v36 = *(void *)(v28 + 24);
  if (*(void *)(v36 + 16) <= a2) {
    goto LABEL_30;
  }
  uint64_t v54 = v12;
  uint64_t v51 = a6;
  uint64_t v37 = *(void **)(v36 + 8 * a2 + 24);
  swift_unknownObjectRetain(v37, v33, v34, v35);
  outlined consume of [A : B].Index._Variant<A, B>(a1, a2, 1);
  _forceBridgeFromObjectiveC<A>(_:_:)(v37, a4, v38, v55);
  swift_unknownObjectRelease(v37);
  unint64_t v39 = (*(uint64_t (**)(void, char *, uint64_t))(a5 + 32))(*(void *)(a3 + 40), a4, a5);
  uint64_t v40 = -1LL << *(_BYTE *)(a3 + 32);
  uint64_t v41 = v39 & ~v40;
  uint64_t v52 = a3 + 56;
  uint64_t v53 = a3;
  if (((*(void *)(a3 + 56 + ((v41 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v41) & 1) == 0)
  {
    (*(void (**)(char *, char *))(v54 + 8))(v55, a4);
LABEL_27:
    uint64_t v49 = 287LL;
    goto LABEL_32;
  }

  uint64_t v42 = ~v40;
  uint64_t v43 = *(void *)(a5 + 8);
  uint64_t v44 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v43 + 8);
  uint64_t v45 = *(void *)(v54 + 72);
  uint64_t v46 = *(void (**)(char *, unint64_t, char *))(v54 + 16);
  while (1)
  {
    v46(v15, *(void *)(v53 + 48) + v45 * v41, a4);
    uint64_t v47 = v44(v15, v55, a4, v43);
    uint64_t v48 = *(void (**)(char *, char *))(v54 + 8);
    v48(v15, a4);
    if ((v47 & 1) != 0) {
      break;
    }
    uint64_t v41 = (v41 + 1) & v42;
    if (((*(void *)(v52 + ((v41 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v41) & 1) == 0)
    {
      v48(v55, a4);
      goto LABEL_27;
    }
  }

  v48(v55, a4);
  v46(v51, *(void *)(v53 + 48) + v45 * v41, a4);
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if ((v16 & 1) == 0)
  {
    if ((a1 & 0x8000000000000000LL) == 0
      && 1LL << *(_BYTE *)(a3 + 32) > a1
      && ((*(void *)(a3 + (((unint64_t)a1 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> a1) & 1) != 0
      && *(_DWORD *)(a3 + 36) == (_DWORD)a2)
    {
      (*(void (**)(char *, uint64_t, char *))(v12 + 16))( a6,  *(void *)(a3 + 48) + *(void *)(v12 + 72) * a1,  a4);
      return;
    }

    uint64_t v49 = 266LL;
LABEL_32:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  v49,  0);
  }

  uint64_t v55 = (char *)&v50 - v17;
  if (a1 >= 0) {
    Swift::UInt64 v28 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    Swift::UInt64 v28 = a1;
  }
  uint64_t v29 = type metadata accessor for __CocoaSet.Index.Storage();
  swift_bridgeObjectRetain(a1, v30, v31, v32);
  if (!swift_dynamicCastClass(v28, v29)) {
    goto LABEL_33;
  }
  if (!swift_dynamicCastClass(v28, v29)) {
    goto LABEL_33;
  }
  uint64_t v36 = *(void *)(v28 + 24);
  if (*(void *)(v36 + 16) <= a2) {
    goto LABEL_30;
  }
  uint64_t v54 = v12;
  uint64_t v51 = a6;
  uint64_t v37 = *(void **)(v36 + 8 * a2 + 24);
  swift_unknownObjectRetain(v37, v33, v34, v35);
  outlined consume of [A : B].Index._Variant<A, B>(a1, a2, 1);
  _forceBridgeFromObjectiveC<A>(_:_:)(v37, a4, v38, v55);
  swift_unknownObjectRelease(v37);
  unint64_t v39 = (*(uint64_t (**)(void, char *, uint64_t))(a5 + 32))(*(void *)(a3 + 40), a4, a5);
  uint64_t v40 = -1LL << *(_BYTE *)(a3 + 32);
  uint64_t v41 = v39 & ~v40;
  uint64_t v52 = a3 + 56;
  uint64_t v53 = a3;
  if (((*(void *)(a3 + 56 + ((v41 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v41) & 1) == 0)
  {
    (*(void (**)(char *, char *))(v54 + 8))(v55, a4);
LABEL_27:
    uint64_t v49 = 287LL;
    goto LABEL_32;
  }

  uint64_t v42 = ~v40;
  uint64_t v43 = *(void *)(a5 + 8);
  uint64_t v44 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v43 + 8);
  uint64_t v45 = *(void *)(v54 + 72);
  uint64_t v46 = *(void (**)(char *, unint64_t, char *))(v54 + 16);
  while (1)
  {
    v46(v15, *(void *)(v53 + 48) + v45 * v41, a4);
    uint64_t v47 = v44(v15, v55, a4, v43);
    uint64_t v48 = *(void (**)(char *, char *))(v54 + 8);
    v48(v15, a4);
    if ((v47 & 1) != 0) {
      break;
    }
    uint64_t v41 = (v41 + 1) & v42;
    if (((*(void *)(v52 + ((v41 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v41) & 1) == 0)
    {
      v48(v55, a4);
      goto LABEL_27;
    }
  }

  v48(v55, a4);
  v46(v51, *(void *)(v53 + 48) + v45 * v41, a4);
}

      uint64_t v29 = (v48 - 1) & v48;
      uint64_t v45 = __clz(__rbit64(v48)) + (v47 << 6);
      uint64_t v43 = v47;
    }

    (*(void (**)(char *, unint64_t, swift *))(v4 + 16))( v22,  *(void *)(v30 + 48) + *(void *)(v4 + 72) * v45,  a2);
    uint64_t v46 = *(void (**)(char *, uint64_t, uint64_t, swift *))(v4 + 56);
LABEL_21:
    v46(v22, 0LL, 1LL, a2);
    (*(void (**)(uint64_t *, char *, swift *))(v4 + 32))(v6, v22, a2);
    swift_dynamicCast((char *)v71, v6, a2, (const char *)&type metadata for AnyHashable, 7uLL);
    v69[0] = v71[0];
    v69[1] = v71[1];
    unint64_t v70 = v72;
    uint64_t v42 = specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)v69, (uint64_t)v35);
  }

  uint64_t v50 = *(void *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8);
  if (v50 < 0) {
    goto LABEL_46;
  }
  if (v50 != *(void *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0xE0))
  {
LABEL_38:
    uint64_t v52 = *(void *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0x18);
    if (!v52) {
      goto LABEL_52;
    }
    uint64_t v53 = (void **)(v52 + 8 * v50);
    uint64_t v54 = *v53;
    *(void *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = v50 + 1;
    swift_unknownObjectRetain(v54, v39, v40, v41);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a2, (uint64_t *)a2))
    {
      *(void *)&v71[0] = v54;
      swift_dynamicCast(v22, (uint64_t *)v71, v67, (const char *)a2, 7uLL);
      uint64_t v46 = *(void (**)(char *, uint64_t, uint64_t, swift *))(v4 + 56);
    }

    else
    {
      uint64_t v46 = *(void (**)(char *, uint64_t, uint64_t, swift *))(v4 + 56);
      v46((char *)v61, 1LL, 1LL, a2);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v54, (uint64_t)a2, v61);
      swift_unknownObjectRelease(v54);
      uint64_t v55 = v58;
      (*(void (**)(char *, uint64_t *, uint64_t))(v59 + 16))(v60, v61, v58);
      if ((*(unsigned int (**)(char *, uint64_t, swift *))(v4 + 48))(v60, 1LL, a2) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v59 + 8))(v61, v55);
      (*(void (**)(char *, char *, swift *))(v4 + 32))(v22, v60, a2);
    }

    unint64_t v35 = v68;
    goto LABEL_21;
  }

  uint64_t v51 = objc_msgSend( *(id *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0xD0),  sel_countByEnumeratingWithState_objects_count_,  v64,  v63,  16,  v42.n128_f64[0]);
  *(void *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0xEswift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v51;
  if (v51)
  {
    uint64_t v50 = 0LL;
    *(void *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = 0LL;
    goto LABEL_38;
  }

  *(void *)((v30 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = -1LL;
LABEL_46:
  (*(void (**)(char *, uint64_t, uint64_t, swift *, __n128))(v4 + 56))(v22, 1LL, 1LL, a2, v42);
  swift_release((uint64_t)v35);
  outlined consume of [A : B].Iterator._Variant<A, B>(v30);
  return v35;
}

LABEL_43:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }

  Swift::UInt64 v15 = v14 - v12;
  uint64_t v16 = (a5 >> 62) & 1;
  if ((a5 & 0x2000000000000000LL) == 0) {
    LODWORD(v16) = a4 < 0;
  }
  if ((_DWORD)v16 != 1)
  {
    if (v15 < 0) {
      Swift::UInt64 v15 = v12 - v14;
    }
    if ((unint64_t)v15 > 0x20)
    {
      int v14 = String.UTF16View._nativeGetOffset(for:)(from);
      int v17 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)rawBits);
      from._Swift::UInt64 rawBits = v17 - v14;
      if (!__OFSUB__(v17, v14))
      {
        while (1)
        {
          uint64_t v20 = String.UTF16View._nativeGetOffset(for:)(a2);
          unsigned int v19 = v20 - v14;
          if (!__OFSUB__(v20, v14)) {
            break;
          }
          __break(1u);
LABEL_45:
          Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
LABEL_26:
          if ((a2._rawBits & 0xC001) == 0) {
            a2._Swift::UInt64 rawBits = a2._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a2)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
          }
          from._Swift::UInt64 rawBits = String.UTF16View.distance(from:to:)(from, (Swift::String::Index)rawBits);
          int v18 = String.UTF16View._utf16Distance(from:to:)((Swift::String::Index)rawBits, a2);
          unsigned int v19 = from._rawBits + v18;
          if (!__OFADD__(from._rawBits, v18)) {
            break;
          }
          __break(1u);
LABEL_31:
          from._Swift::UInt64 rawBits = String.UTF16View._utf16Distance(from:to:)(from, (Swift::String::Index)rawBits);
        }

        goto LABEL_33;
      }

      __break(1u);
    }

    if ((rawBits & 0xC001) != 0) {
      goto LABEL_26;
    }
    goto LABEL_45;
  }

  if (v15 < 0) {
    goto LABEL_43;
  }
  return v12 - (from._rawBits >> 16);
}

  uint64_t v20 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v21);
  if (v20 <= 63) {
    goto LABEL_42;
  }
LABEL_43:
  Swift::UInt64 v26 = (v4 & 0x800000000000000LL) != 0 || v19 == 0;
  uint64_t v27 = 7LL;
  if (!v26) {
    uint64_t v27 = 11LL;
  }
  return (Swift::String::Index)(v27 | v17);
}

      _StringGuts._foreignGrow(_:)(v22);
LABEL_29:
      uint64_t v29 = v49;
    }
  }

  uint64_t v45 = v13[1];
  v29(v23, v11, a3, a4, a5, a6, v10);
  *Swift::UInt64 v13 = *(void *)(v45 + 24);
  return v23;
}

    uint64_t v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    int64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
    v80(&v124, &type metadata for Int, v81, a3, a4);
    uint64_t v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v74,  v29,  a3);
    uint64_t v83 = v109;
    ((void (*)(char *, uint64_t))v109)(v29, a3);
    if ((v82 & 1) != 0) {
      goto LABEL_70;
    }
    goto LABEL_41;
  }

  char v79 = v75(a3, a4);
  uint64_t v76 = v121(a3, a4);
  if ((v79 & 1) == 0)
  {
    if (v76 >= 64)
    {
      ((void (*)(char *, uint64_t))v109)(v74, a3);
      goto LABEL_42;
    }

    goto LABEL_37;
  }

  if (v76 > 64) {
    goto LABEL_33;
  }
  uint64_t v86 = AssociatedTypeWitness;
  unint64_t v85 = v114;
  uint64_t v87 = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v88 = v112;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))( &unk_18180BE68,  256LL,  v86,  v87);
  (*((void (**)(char *, uint64_t, const char *))v85 + 3))(v88, a3, v85);
  LOBYTE(v88) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v74,  v29,  a3);
  uint64_t v83 = v109;
  ((void (*)(char *, uint64_t))v109)(v29, a3);
  char v89 = v110;
  v67(v110, (uint64_t)v74, a3);
  if ((v88 & 1) != 0)
  {
    ((void (*)(char *, uint64_t))v83)(v89, a3);
    goto LABEL_70;
  }

  uint64_t v116 = (char *)v124;
  uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v83)(v89, a3);
  uint64_t v91 = v90 < (uint64_t)v116;
  uint64_t v72 = v118;
  if (v91) {
    goto LABEL_70;
  }
LABEL_41:
  ((void (*)(char *, uint64_t))v83)(v74, a3);
LABEL_42:
  uint64_t v92 = v120;
  unint64_t v93 = v121;
  uint64_t v94 = v121(a3, a4);
  v67(v73, (uint64_t)v92, a3);
  if (v94 >= 65)
  {
    unint64_t v95 = v109;
    ((void (*)(char *, uint64_t))v109)(v73, a3);
    unint64_t v96 = v122;
    goto LABEL_44;
  }

  char v104 = v93(a3, a4);
  unint64_t v95 = v109;
  ((void (*)(char *, uint64_t))v109)(v73, a3);
  uint64_t v105 = v104 == 64;
  unint64_t v96 = v122;
  if (v105 && (v122(a3, a4) & 1) == 0)
  {
LABEL_44:
    v67(v72, (uint64_t)v120, a3);
    uint64_t v124 = 0x7FFFFFFFFFFFFFFFLL;
    id v97 = v96(a3, a4);
    uint64_t v98 = v121(a3, a4);
    if ((v97 & 1) != 0)
    {
      if (v98 > 64)
      {
        uint64_t v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        BOOL v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
        Swift::Int v103 = &v124;
        goto LABEL_54;
      }
    }

    else if (v98 > 63)
    {
      uint64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
      Swift::Int v103 = &v123;
LABEL_54:
      v101(v103, &type metadata for Int, v102, a3, a4);
      uint64_t v106 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v72,  a3);
      ((void (*)(char *, uint64_t))v95)(v29, a3);
      if ((v106 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    v67(v29, (uint64_t)v72, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    ((void (*)(char *, uint64_t))v95)(v29, a3);
LABEL_55:
    ((void (*)(char *, uint64_t))v95)(v72, a3);
  }

  unint64_t v107 = v120;
  char v108 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v95)(v107, a3);
  if ((v108 & 0x8000000000000000LL) == 0)
  {
    if (v108 < 0x80)
    {
      uint64_t v56 = ((2 * v119) << ~(_BYTE)v108) | (v115 >> v108);
      uint64_t v57 = v119 >> v108;
      if ((v108 & 0x40) != 0)
      {
        uint64_t v56 = v119 >> v108;
        uint64_t v57 = 0LL;
      }

      goto LABEL_60;
    }

    uint64_t v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    int64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
    v80(&v124, &type metadata for Int, v81, a3, a4);
    uint64_t v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v74,  v29,  a3);
    uint64_t v83 = v109;
    ((void (*)(char *, uint64_t))v109)(v29, a3);
    if ((v82 & 1) != 0) {
      goto LABEL_74;
    }
    goto LABEL_41;
  }

  char v79 = v75(a3, a4);
  uint64_t v76 = v121(a3, a4);
  if ((v79 & 1) == 0)
  {
    if (v76 >= 64)
    {
      ((void (*)(char *, uint64_t))v109)(v74, a3);
      goto LABEL_42;
    }

    goto LABEL_37;
  }

  if (v76 > 64) {
    goto LABEL_33;
  }
  uint64_t v86 = AssociatedTypeWitness;
  unint64_t v85 = v114;
  uint64_t v87 = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v88 = v112;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))( &unk_18180BE68,  256LL,  v86,  v87);
  (*((void (**)(char *, uint64_t, const char *))v85 + 3))(v88, a3, v85);
  LOBYTE(v88) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v74,  v29,  a3);
  uint64_t v83 = v109;
  ((void (*)(char *, uint64_t))v109)(v29, a3);
  char v89 = v110;
  v67(v110, (uint64_t)v74, a3);
  if ((v88 & 1) != 0)
  {
    ((void (*)(char *, uint64_t))v83)(v89, a3);
    goto LABEL_74;
  }

  uint64_t v116 = (char *)v124;
  uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v83)(v89, a3);
  uint64_t v91 = v90 < (uint64_t)v116;
  uint64_t v72 = v118;
  if (v91) {
    goto LABEL_74;
  }
LABEL_41:
  ((void (*)(char *, uint64_t))v83)(v74, a3);
LABEL_42:
  uint64_t v92 = v120;
  unint64_t v93 = v121;
  uint64_t v94 = v121(a3, a4);
  v67(v73, (uint64_t)v92, a3);
  if (v94 >= 65)
  {
    unint64_t v95 = v109;
    ((void (*)(char *, uint64_t))v109)(v73, a3);
    unint64_t v96 = v122;
    goto LABEL_44;
  }

  char v104 = v93(a3, a4);
  unint64_t v95 = v109;
  ((void (*)(char *, uint64_t))v109)(v73, a3);
  uint64_t v105 = v104 == 64;
  unint64_t v96 = v122;
  if (v105 && (v122(a3, a4) & 1) == 0)
  {
LABEL_44:
    v67(v72, (uint64_t)v120, a3);
    uint64_t v124 = 0x7FFFFFFFFFFFFFFFLL;
    id v97 = v96(a3, a4);
    uint64_t v98 = v121(a3, a4);
    if ((v97 & 1) != 0)
    {
      if (v98 > 64)
      {
        uint64_t v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        BOOL v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
        Swift::Int v103 = &v124;
        goto LABEL_54;
      }
    }

    else if (v98 > 63)
    {
      uint64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
      Swift::Int v103 = &v123;
LABEL_54:
      v101(v103, &type metadata for Int, v102, a3, a4);
      uint64_t v106 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v72,  a3);
      ((void (*)(char *, uint64_t))v95)(v29, a3);
      if ((v106 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    v67(v29, (uint64_t)v72, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    ((void (*)(char *, uint64_t))v95)(v29, a3);
LABEL_55:
    ((void (*)(char *, uint64_t))v95)(v72, a3);
  }

  unint64_t v107 = v120;
  char v108 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v95)(v107, a3);
  if ((v108 & 0x8000000000000000LL) == 0)
  {
    if (v108 <= 0x7F)
    {
      if ((v108 & 0x40) != 0) {
        uint64_t v57 = v119 << v108;
      }
      else {
        uint64_t v57 = (v115 << v108) | (v119 >> 1 >> ~(_BYTE)v108);
      }
      if ((v108 & 0x40) != 0) {
        uint64_t v56 = 0LL;
      }
      else {
        uint64_t v56 = v119 << v108;
      }
      goto LABEL_64;
    }

          if (!_swift_stdlib_isLinkingConsonant(a2)) {
            goto LABEL_15;
          }
        }

        else
        {
LABEL_35:
          isLinkingConsonant = _swift_stdlib_isLinkingConsonant(a2);
          if (v12 == 12)
          {
            if (!isLinkingConsonant) {
              goto LABEL_15;
            }
          }

          else
          {
            if (v12 != 2) {
              goto LABEL_15;
            }
            uint64_t v16 = a1 > 0x2FF && isLinkingConsonant;
          }
        }

        LOBYTE(v8) = specialized _StringGuts.checkIfInIndicSequence(at:with:)(a3, a4) ^ 1;
        return v8 & 1;
      }

      if (v13 != 8) {
        goto LABEL_14;
      }
      return specialized _StringGuts.countRIs(at:with:)(a3, a4);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }

  while (1)
  {
    (*(void (**)(id *, unint64_t, uint64_t *))(v9 + 16))( v14,  *(void *)(v70[4] + 48LL) + *(void *)(v9 + 72) * v29,  v8);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v8, v8))
    {
      if (v64 != 8) {
        goto LABEL_33;
      }
      uint64_t v30 = *v14;
      swift_unknownObjectRetain(*v14, v37, v38, v39);
      (*(void (**)(id *, uint64_t *))(v9 + 8))(v14, v8);
      if (!v19) {
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v41 = v60;
      (*(void (**)(id *, id *, uint64_t *))(v9 + 32))(v60, v14, v8);
      uint64_t v30 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v41, v8, v42, v43);
      if (!v19) {
        goto LABEL_22;
      }
    }

  *(void *)BOOL v8 = v16;
  return result;
}

    unint64_t v25 = v24;
LABEL_34:
    if (v11 != 8205)
    {
      if (v11 != 39)
      {
        if (v11 == 34)
        {
LABEL_37:
          Swift::UInt64 v26 = 0;
          uint64_t v27 = 0;
LABEL_38:
          Swift::UInt64 v28 = 2;
LABEL_231:
          uint64_t v30 = 1;
LABEL_232:
          if (v18 == 18) {
            uint64_t v31 = v25;
          }
          else {
            uint64_t v31 = v18;
          }
          switch(v31)
          {
            case 0:
              if (v28 > 0xF) {
                goto LABEL_281;
              }
              BOOL v32 = 1 << v28;
              if ((v32 & 0x20A1) != 0) {
                goto LABEL_272;
              }
              if ((v32 & 0x8A00) == 0) {
                goto LABEL_281;
              }
              goto LABEL_255;
            case 2:
              if ((v27 & 1) == 0) {
                goto LABEL_281;
              }
              if ((v19 & 1) != 0) {
                return v12;
              }
              if ((v38 & 1) == 0) {
                return v17;
              }
              Swift::UInt64 v12 = v17;
              if (v37 < 2) {
                return v12;
              }
              goto LABEL_8;
            case 5:
              if (v28 > 0xD || ((1 << v28) & 0x21A1) == 0) {
                goto LABEL_281;
              }
              goto LABEL_272;
            case 7:
              if (v28 > 0xF) {
                goto LABEL_281;
              }
              if (((1 << v28) & 0xA0A1) != 0) {
                goto LABEL_272;
              }
              if (((1 << v28) & 0xA00) != 0)
              {
LABEL_255:
                uint64_t v37 = 0LL;
                unsigned int v19 = 0;
                int v18 = 18;
              }

              else
              {
                if (v28 != 2) {
                  goto LABEL_281;
                }
                unsigned int v19 = 0;
                int v18 = 18;
                uint64_t v34 = 2LL;
LABEL_279:
                uint64_t v37 = v34;
              }

              uint64_t v38 = 1;
              int v17 = v12;
              goto LABEL_9;
            case 8:
              int v18 = 18;
              if (v28 != 5 && v28 != 8) {
                goto LABEL_281;
              }
              goto LABEL_9;
            case 9:
              if (v28 && v28 != 7) {
                goto LABEL_281;
              }
              goto LABEL_261;
            case 10:
              if ((v26 & 1) == 0) {
                goto LABEL_281;
              }
              goto LABEL_266;
            case 11:
            case 15:
              if (!v28 || v28 == 7)
              {
LABEL_261:
                if ((v19 & 1) != 0) {
                  return v12;
                }
                if ((v38 & 1) == 0) {
                  return v17;
                }
                Swift::UInt64 v12 = v17;
                if (v37) {
                  return v12;
                }
              }

              else
              {
                if (v28 != 13) {
                  goto LABEL_281;
                }
LABEL_266:
                if ((v19 & 1) != 0) {
                  return v12;
                }
                if ((v38 & 1) == 0) {
                  return v17;
                }
                Swift::UInt64 v12 = v17;
                if (v37 != 1) {
                  return v12;
                }
              }

      if (!strcmp(v7, v6))
      {
LABEL_51:
        if (!prespecializedLoggingEnabled) {
          return swift_prespecialized_data;
        }
        fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Prespecializations library: Found %s in SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES, enabling\n",  v7);
        goto LABEL_49;
      }
    }

    Swift::UInt64 v15 = (const char *)swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable;
    if (swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable
      && *swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable)
    {
      uint64_t v16 = *v5;
      int v17 = strlen(*v5);
      int v18 = strchr(swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable, 58);
      if (v18)
      {
        unsigned int v19 = v18;
        while (v19 - v15 != v17 || strncmp(v15, v16, v17))
        {
          Swift::UInt64 v15 = v19 + 1;
          unsigned int v19 = strchr(v19 + 1, 58);
          if (!v19) {
            goto LABEL_42;
          }
        }

        goto LABEL_53;
      }

    *(void *)a3 = 0LL;
    a3[23] = 0;
    goto LABEL_34;
  }

  if (v12 != 220) {
    goto LABEL_33;
  }
  v157.__r_.__value_.__s.__size_ = 10;
  strcpy((char *)&v157, "subscript(");
  BOOL v154 = 0LL;
  Swift::Int v155 = 0LL;
  char v156 = 0LL;
  uint64_t v153 = &v154;
  Swift::UInt64 v13 = (unsigned __int16 *)operator new(0x50uLL);
  *Swift::UInt64 v13 = 232;
  *((void *)v13 + 1) = 2LL;
  v13[8] = 82;
  *((void *)v13 + 3) = 0LL;
  v13[16] = 3;
  *((void *)v13 + 5) = 0LL;
  v13[24] = 232;
  *((void *)v13 + 7) = 0LL;
  v13[32] = 223;
  *((void *)v13 + 9) = 0LL;
  int v14 = *((unsigned __int8 *)v11 + 18);
  Swift::UInt64 v15 = v14 - 1;
  if ((_DWORD)v14 != 1)
  {
    if ((_DWORD)v14 == 5)
    {
      int v14 = v11[2];
    }

    else
    {
      if ((_DWORD)v14 != 2) {
        goto LABEL_87;
      }
      int v14 = 2LL;
    }
  }

  if (v14 > 2)
  {
    uint64_t v20 = v11;
    if (v15 >= 2) {
      uint64_t v20 = *(unsigned int **)v11;
    }
    Swift::UInt64 v21 = (uint64_t *)*((void *)v20 + 2);
    if (v21)
    {
      if (*((_WORD *)v21 + 8) == 232)
      {
        Swift::String::Index v22 = *((void *)v13 + 3);
        Swift::UInt64 v23 = *((unsigned __int8 *)v21 + 18);
        uint64_t v24 = v23 - 1;
        if ((_DWORD)v23 != 1)
        {
          if ((_DWORD)v23 == 2)
          {
            Swift::UInt64 v23 = 2LL;
          }

          else
          {
            if ((_DWORD)v23 != 5) {
              goto LABEL_87;
            }
            Swift::UInt64 v23 = *((unsigned int *)v21 + 2);
          }
        }

        if (v23 > v22)
        {
          if (v24 >= 2) {
            Swift::UInt64 v21 = (uint64_t *)*v21;
          }
          unint64_t v25 = (uint64_t **)v21[v22];
          if (v25)
          {
            if (*((unsigned __int16 *)v25 + 8) == v13[8])
            {
              Swift::UInt64 v26 = *((void *)v13 + 5);
              uint64_t v27 = *((unsigned __int8 *)v25 + 18);
              Swift::UInt64 v28 = v27 - 1;
              if ((_DWORD)v27 != 1)
              {
                if ((_DWORD)v27 == 2)
                {
                  uint64_t v27 = 2LL;
                }

                else
                {
                  if ((_DWORD)v27 != 5) {
                    goto LABEL_87;
                  }
                  uint64_t v27 = *((unsigned int *)v25 + 2);
                }
              }

              if (v27 > v26)
              {
                if (v28 >= 2) {
                  unint64_t v25 = (uint64_t **)*v25;
                }
                uint64_t v29 = (uint64_t **)v25[v26];
                if (v29)
                {
                  if (*((unsigned __int16 *)v29 + 8) == v13[16])
                  {
                    uint64_t v30 = *((void *)v13 + 7);
                    uint64_t v31 = *((unsigned __int8 *)v29 + 18);
                    BOOL v32 = v31 - 1;
                    if ((_DWORD)v31 != 1)
                    {
                      if ((_DWORD)v31 == 2)
                      {
                        uint64_t v31 = 2LL;
                      }

                      else
                      {
                        if ((_DWORD)v31 != 5) {
                          goto LABEL_87;
                        }
                        uint64_t v31 = *((unsigned int *)v29 + 2);
                      }
                    }

                    if (v31 > v30)
                    {
                      if (v32 >= 2) {
                        uint64_t v29 = (uint64_t **)*v29;
                      }
                      uint64_t v33 = (uint64_t **)v29[v30];
                      if (v33)
                      {
                        if (*((unsigned __int16 *)v33 + 8) == v13[24])
                        {
                          uint64_t v34 = *((void *)v13 + 9);
                          unint64_t v35 = *((unsigned __int8 *)v33 + 18);
                          uint64_t v36 = v35 - 1;
                          if ((_DWORD)v35 != 1)
                          {
                            if ((_DWORD)v35 == 2)
                            {
                              unint64_t v35 = 2LL;
                            }

                            else
                            {
                              if ((_DWORD)v35 != 5) {
                                goto LABEL_87;
                              }
                              unint64_t v35 = *((unsigned int *)v33 + 2);
                            }
                          }

                          if (v35 > v34)
                          {
                            if (v36 >= 2) {
                              uint64_t v33 = (uint64_t **)*v33;
                            }
                            uint64_t v37 = v33[v34];
                            if (v37)
                            {
                              if (*((unsigned __int16 *)v37 + 8) == v13[32])
                              {
                                operator delete(v13);
                                uint64_t v38 = *((unsigned __int8 *)v37 + 18);
                                switch((_DWORD)v38)
                                {
                                  case 1:
LABEL_274:
                                    uint64_t v116 = 0LL;
                                    while (1)
                                    {
                                      int v118 = *((unsigned __int8 *)v37 + 18);
                                      uint64_t v119 = v118 - 1;
                                      if ((_DWORD)v118 != 1)
                                      {
                                        if ((_DWORD)v118 == 5)
                                        {
                                          int v118 = *((unsigned int *)v37 + 2);
                                        }

                                        else
                                        {
                                          if ((_DWORD)v118 != 2) {
                                            goto LABEL_287;
                                          }
                                          int v118 = 2LL;
                                        }
                                      }

                                      if (v118 <= v116)
                                      {
LABEL_287:
                                        uint64_t v121 = 0LL;
                                        goto LABEL_288;
                                      }

                                      unint64_t v120 = v37;
                                      if (v119 >= 2) {
                                        unint64_t v120 = (uint64_t *)*v37;
                                      }
                                      uint64_t v121 = (uint64_t *)v120[v116];
LABEL_288:
                                      if (*((_WORD *)v121 + 8) != 224)
                                      {
                                        uint64_t v124 = v155;
                                        if (v155 < v156)
                                        {
                                          *(void *)Swift::Int v155 = 0x6E776F6E6B6E553CLL;
                                          *((_WORD *)v124 + 4) = 62;
                                          uint64_t v117 = v124 + 24;
                                          v124[23] = 9;
                                        }

                                        else
                                        {
                                          uint64_t v125 = (char *)v154;
                                          uint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v155 - (_BYTE *)v154) >> 3);
                                          unint64_t v127 = v126 + 1;
                                          if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                            goto LABEL_352;
                                          }
                                          if (0x5555555555555556LL * ((v156 - (_BYTE *)v154) >> 3) > v127) {
                                            unint64_t v127 = 0x5555555555555556LL * ((v156 - (_BYTE *)v154) >> 3);
                                          }
                                          if (0xAAAAAAAAAAAAAAABLL * ((v156 - (_BYTE *)v154) >> 3) >= 0x555555555555555LL) {
                                            uint64_t v128 = 0xAAAAAAAAAAAAAAALL;
                                          }
                                          else {
                                            uint64_t v128 = v127;
                                          }
                                          if (v128)
                                          {
                                            if (v128 > 0xAAAAAAAAAAAAAAALL) {
                                              goto LABEL_353;
                                            }
                                            uint64_t v129 = (char *)operator new(24 * v128);
                                          }

                                          else
                                          {
                                            uint64_t v129 = 0LL;
                                          }

                                          uint64_t v141 = &v129[24 * v126];
                                          strcpy(v141, "<Unknown>");
                                          uint64_t v142 = &v129[24 * v128];
                                          v141[23] = 9;
                                          uint64_t v117 = v141 + 24;
                                          if (v124 == v125)
                                          {
                                            BOOL v154 = v141;
                                            Swift::Int v155 = v141 + 24;
                                            char v156 = &v129[24 * v128];
                                          }

                                          else
                                          {
                                            do
                                            {
                                              uint64_t v143 = *(_OWORD *)(v124 - 24);
                                              *((void *)v141 - 1) = *((void *)v124 - 1);
                                              *(_OWORD *)(v141 - 24) = v143;
                                              v141 -= 24;
                                              *((void *)v124 - 2) = 0LL;
                                              *((void *)v124 - 1) = 0LL;
                                              *((void *)v124 - 3) = 0LL;
                                              v124 -= 24;
                                            }

                                            while (v124 != v125);
                                            uint64_t v124 = (char *)v154;
                                            uint64_t v144 = v155;
                                            BOOL v154 = v141;
                                            Swift::Int v155 = v117;
                                            char v156 = v142;
                                            while (v144 != v124)
                                            {
                                              if (*(v144 - 1) < 0) {
                                                operator delete(*((void **)v144 - 3));
                                              }
                                              v144 -= 24;
                                            }
                                          }

                                          if (v124) {
                                            operator delete(v124);
                                          }
                                        }

                                        Swift::Int v155 = v117;
                                        goto LABEL_277;
                                      }

                                      uint64_t v122 = *((unsigned __int8 *)v121 + 18);
                                      if (v122 == 5 && *((_DWORD *)v121 + 2))
                                      {
                                        uint64_t v121 = (uint64_t *)*v121;
LABEL_293:
                                        uint64_t v123 = (uint64_t *)*v121;
                                        goto LABEL_305;
                                      }

                                      uint64_t v123 = 0LL;
LABEL_305:
                                      unint64_t v130 = *((unsigned __int8 *)v123 + 18);
                                      if (v130 == 5 && *((_DWORD *)v123 + 2))
                                      {
                                        uint64_t v123 = (uint64_t *)*v123;
LABEL_309:
                                        uint64_t v131 = (uint64_t *)*v123;
                                        goto LABEL_311;
                                      }

                                      uint64_t v131 = 0LL;
LABEL_311:
                                      unint64_t v132 = *((unsigned __int8 *)v131 + 18);
                                      if (v132 != 2)
                                      {
                                        if (v132 != 5 || *((_DWORD *)v131 + 2) < 2u)
                                        {
                                          unint64_t v133 = 0LL;
                                          goto LABEL_317;
                                        }

                                        uint64_t v131 = (uint64_t *)*v131;
                                      }

                                      unint64_t v133 = (void *)v131[1];
LABEL_317:
                                      swift::Demangle::__runtime::keyPathSourceString(char const*,unsigned long)::$_1::operator()( v133,  (char *)&__p);
                                      uint64_t v134 = (std::string *)v155;
                                      if (v155 >= v156)
                                      {
                                        uint64_t v136 = (std::string *)v154;
                                        uint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v155 - (_BYTE *)v154) >> 3);
                                        unint64_t v138 = v137 + 1;
                                        if (v137 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                          goto LABEL_352;
                                        }
                                        if (0x5555555555555556LL * ((v156 - (_BYTE *)v154) >> 3) > v138) {
                                          unint64_t v138 = 0x5555555555555556LL * ((v156 - (_BYTE *)v154) >> 3);
                                        }
                                        if (0xAAAAAAAAAAAAAAABLL * ((v156 - (_BYTE *)v154) >> 3) >= 0x555555555555555LL) {
                                          uint64_t v139 = 0xAAAAAAAAAAAAAAALL;
                                        }
                                        else {
                                          uint64_t v139 = v138;
                                        }
                                        if (v139)
                                        {
                                          if (v139 > 0xAAAAAAAAAAAAAAALL) {
LABEL_353:
                                          }
                                            std::__throw_bad_array_new_length[abi:nn180100]();
                                          uint64_t v140 = (char *)operator new(24 * v139);
                                        }

                                        else
                                        {
                                          uint64_t v140 = 0LL;
                                        }

                                        uint64_t v145 = (std::string *)&v140[24 * v137];
                                        *uint64_t v145 = __p;
                                        id v146 = &v140[24 * v139];
                                        memset(&__p, 0, sizeof(__p));
                                        char v135 = v145 + 1;
                                        if (v134 == v136)
                                        {
                                          BOOL v154 = v145;
                                          Swift::Int v155 = (char *)&v145[1];
                                          char v156 = &v140[24 * v139];
                                        }

                                        else
                                        {
                                          do
                                          {
                                            uint64_t v147 = *(_OWORD *)&v134[-1].__r_.__value_.__l.__data_;
                                            v145[-1].__r_.__value_.__l.__cap_ = v134[-1].__r_.__value_.__l.__cap_;
                                            *(_OWORD *)&v145[-1].__r_.__value_.__l.__data_ = v147;
                                            --v145;
                                            v134[-1].__r_.__value_.__l.__size_ = 0LL;
                                            v134[-1].__r_.__value_.__l.__cap_ = 0LL;
                                            v134[-1].__r_.__value_.__r.__words[0] = 0LL;
                                            --v134;
                                          }

                                          while (v134 != v136);
                                          uint64_t v134 = (std::string *)v154;
                                          id v148 = v155;
                                          BOOL v154 = v145;
                                          Swift::Int v155 = (char *)v135;
                                          char v156 = v146;
                                          while (v148 != (char *)v134)
                                          {
                                            if (*(v148 - 1) < 0) {
                                              operator delete(*((void **)v148 - 3));
                                            }
                                            v148 -= 24;
                                          }
                                        }

                                        if (v134) {
                                          operator delete(v134);
                                        }
                                      }

                                      else
                                      {
                                        *(_OWORD *)Swift::Int v155 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                                        v134->__r_.__value_.__l.__cap_ = __p.__r_.__value_.__l.__cap_;
                                        memset(&__p, 0, sizeof(__p));
                                        char v135 = v134 + 1;
                                      }

                                      Swift::Int v155 = (char *)v135;
LABEL_277:
                                      if (++v116 == v38) {
                                        goto LABEL_144;
                                      }
                                    }

                                  case 5:
                                    uint64_t v38 = *((unsigned int *)v37 + 2);
                                    if ((_DWORD)v38) {
                                      goto LABEL_274;
                                    }
                                    break;
                                  case 2:
                                    uint64_t v38 = 2LL;
                                    goto LABEL_274;
                                }

                                goto LABEL_144;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  uint64_t v62 = a4;
  Swift::String::Index v22 = (_DWORD *)(v5 + 12736);
  Swift::UInt64 v23 = *(_DWORD *)(v5 + 12736);
  uint64_t v24 = *(unsigned int *)(v5 + 12740);
  unint64_t v25 = *(char **)(v5 + 12728);
  if (v23 >= v24)
  {
    Swift::UInt64 v26 = *(void **)(v5 + 12744);
    uint64_t v27 = (char *)v26[1];
    if (&v25[v24] != v27)
    {
      Swift::UInt64 v28 = v26[2];
      goto LABEL_37;
    }

    uint64_t v29 = (unint64_t)&v25[v24 + 1];
    Swift::UInt64 v28 = v26[2];
    if (v29 <= v28)
    {
      v26[1] = v29;
      LODWORD(v3swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = 1;
    }

    else
    {
LABEL_37:
      else {
        uint64_t v30 = (2 * v24);
      }
      uint64_t v31 = v30 + v24;
      if (!v27 || (unint64_t)&v27[v31] > v28)
      {
        BOOL v32 = 2LL * v26[4];
        if (v32 <= v31 + 1) {
          BOOL v32 = v31 + 1;
        }
        v26[4] = v32;
        uint64_t v33 = v32 + 8;
        this = (uint64_t *)malloc(v32 + 8);
        uint64_t v34 = (char *)this + v33;
        *this = v26[3];
        uint64_t v27 = (char *)(this + 1);
        void v26[2] = v34;
        v26[3] = this;
      }

      v26[1] = &v27[v31];
      if ((_DWORD)v24)
      {
        this = (uint64_t *)memcpy(v27, *(const void **)(v5 + 12728), v24);
        LODWORD(v24) = *(_DWORD *)(v5 + 12740);
        Swift::UInt64 v23 = *(_DWORD *)(v5 + 12736);
      }

      *(void *)(v5 + 12728) = v27;
      unint64_t v25 = v27;
    }

    *(_DWORD *)(v5 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v24 + v30;
  }

  *Swift::String::Index v22 = v23 + 1;
  v25[v23] = 114;
  uint64_t v63 = (_DWORD *)(v5 + 12736);
  if (v8)
  {
    unint64_t v35 = 0LL;
    while (1)
    {
      uint64_t v36 = (swift::Demangle::__runtime::Node *)a2;
      uint64_t v37 = **((void **)v36 + v35);
      if (!v37) {
        break;
      }
LABEL_52:
      if (v8 == ++v35) {
        goto LABEL_77;
      }
    }

    uint64_t v38 = *(_DWORD *)(v5 + 12736);
    unint64_t v39 = *(unsigned int *)(v5 + 12740);
    uint64_t v40 = *(char **)(v5 + 12728);
    if (v38 >= v39)
    {
      uint64_t v41 = *(void **)(v5 + 12744);
      uint64_t v42 = (char *)v41[1];
      if (&v40[v39] != v42)
      {
        uint64_t v43 = v41[2];
        goto LABEL_60;
      }

      uint64_t v44 = (unint64_t)&v40[v39 + 1];
      uint64_t v43 = v41[2];
      if (v44 <= v43)
      {
        v41[1] = v44;
        LODWORD(v45) = 1;
      }

      else
      {
LABEL_60:
        else {
          uint64_t v45 = (2 * v39);
        }
        uint64_t v46 = v45 + v39;
        if (v42) {
          uint64_t v47 = (unint64_t)&v42[v45 + v39] > v43;
        }
        else {
          uint64_t v47 = 1;
        }
        uint64_t v40 = (char *)v41[1];
        if (v47)
        {
          uint64_t v48 = 2LL * v41[4];
          if (v48 <= v46 + 1) {
            uint64_t v48 = v46 + 1;
          }
          v41[4] = v48;
          uint64_t v49 = v48 + 8;
          this = (uint64_t *)malloc(v48 + 8);
          uint64_t v50 = (char *)this + v49;
          *this = v41[3];
          uint64_t v40 = (char *)(this + 1);
          v41[2] = v50;
          v41[3] = this;
        }

        v41[1] = &v40[v46];
        if ((_DWORD)v39)
        {
          this = (uint64_t *)memcpy(v40, *(const void **)(v5 + 12728), v39);
          LODWORD(v39) = *(_DWORD *)(v5 + 12740);
          uint64_t v38 = *(_DWORD *)(v5 + 12736);
        }

        Swift::String::Index v22 = (_DWORD *)(v5 + 12736);
        *(void *)(v5 + 12728) = v40;
      }

      *(_DWORD *)(v5 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v39 + v45;
    }

    *Swift::String::Index v22 = v38 + 1;
    v40[v38] = 122;
    goto LABEL_52;
  }

  if (*((_WORD *)v16 + 8) != 44)
  {
    uint64_t v20 = *((unsigned __int8 *)v16 + 18);
    if ((_DWORD)v20 != 1)
    {
      if ((_DWORD)v20 == 5)
      {
        uint64_t v20 = *((unsigned int *)v16 + 2);
        if ((_DWORD)v20) {
          goto LABEL_55;
        }
      }

      else if ((_DWORD)v20 == 2)
      {
        uint64_t v20 = 2LL;
        goto LABEL_55;
      }

  if (!*(_DWORD *)a4)
  {
LABEL_34:
    uint64_t v20 = (char *)(this + 1591);
    swift::Demangle::__runtime::CharVector::append(this + 1591, "WJ", 2uLL, this[1593]);
    Swift::UInt64 v21 = **(_BYTE **)v8;
    Swift::String::Index v22 = *((_DWORD *)this + 3184);
    Swift::UInt64 v23 = *((unsigned int *)this + 3185);
    uint64_t v24 = this[1591];
    if (v22 >= v23)
    {
      unint64_t v25 = this[1593];
      Swift::UInt64 v26 = (char *)*((void *)v25 + 1);
      if (&v24[v23] != v26)
      {
        uint64_t v27 = *((void *)v25 + 2);
        goto LABEL_38;
      }

      Swift::UInt64 v28 = (unint64_t)&v24[v23 + 1];
      uint64_t v27 = *((void *)v25 + 2);
      if (v28 <= v27)
      {
        *((void *)v25 + 1) = v28;
        LODWORD(v29) = 1;
        uint64_t v20 = (char *)(this + 1591);
      }

      else
      {
LABEL_38:
        uint64_t v61 = **(_BYTE **)v8;
        else {
          uint64_t v29 = (2 * v23);
        }
        uint64_t v30 = v29 + v23;
        if (!v26 || (unint64_t)&v26[v30] > v27)
        {
          uint64_t v31 = 2LL * *((void *)v25 + 4);
          if (v31 <= v30 + 1) {
            uint64_t v31 = v30 + 1;
          }
          *((void *)v25 + 4) = v31;
          BOOL v32 = v31 + 8;
          uint64_t v33 = malloc(v31 + 8);
          uint64_t v34 = (char *)v33 + v32;
          *uint64_t v33 = *((void *)v25 + 3);
          Swift::UInt64 v26 = (char *)(v33 + 1);
          *((void *)v25 + 2) = v34;
          *((void *)v25 + 3) = v33;
        }

        *((void *)v25 + 1) = &v26[v30];
        if ((_DWORD)v23)
        {
          memcpy(v26, this[1591], v23);
          LODWORD(v23) = *((_DWORD *)this + 3185);
          Swift::String::Index v22 = *((_DWORD *)this + 3184);
        }

        uint64_t v20 = (char *)(this + 1591);
        Swift::UInt64 v21 = v61;
        this[1591] = v26;
        uint64_t v24 = v26;
      }

      *((_DWORD *)this + 3185) = v23 + v29;
    }

    *((_DWORD *)this + 3184) = v22 + 1;
    v24[v22] = v21;
    if (!*(_DWORD *)a4)
    {
      unint64_t v35 = *((_DWORD *)this + 3184);
      uint64_t v36 = *((unsigned int *)this + 3185);
      uint64_t v37 = this[1591];
      if (v35 >= v36)
      {
        uint64_t v62 = v20;
        uint64_t v38 = this[1593];
        unint64_t v39 = (char *)*((void *)v38 + 1);
        if (&v37[v36] != v39)
        {
          uint64_t v40 = *((void *)v38 + 2);
          goto LABEL_56;
        }

        uint64_t v41 = (unint64_t)&v37[v36 + 1];
        uint64_t v40 = *((void *)v38 + 2);
        if (v41 <= v40)
        {
          *((void *)v38 + 1) = v41;
          LODWORD(v42) = 1;
          uint64_t v20 = v62;
        }

        else
        {
LABEL_56:
          else {
            uint64_t v42 = (2 * v36);
          }
          uint64_t v43 = v42 + v36;
          if (!v39 || (unint64_t)&v39[v43] > v40)
          {
            uint64_t v44 = 2LL * *((void *)v38 + 4);
            if (v44 <= v43 + 1) {
              uint64_t v44 = v43 + 1;
            }
            *((void *)v38 + 4) = v44;
            uint64_t v45 = v44 + 8;
            uint64_t v46 = malloc(v44 + 8);
            uint64_t v47 = (char *)v46 + v45;
            uint8x16_t *v46 = *((void *)v38 + 3);
            unint64_t v39 = (char *)(v46 + 1);
            *((void *)v38 + 2) = v47;
            *((void *)v38 + 3) = v46;
          }

          *((void *)v38 + 1) = &v39[v43];
          if ((_DWORD)v36)
          {
            memcpy(v39, this[1591], v36);
            LODWORD(v36) = *((_DWORD *)this + 3185);
            unint64_t v35 = *((_DWORD *)this + 3184);
          }

          uint64_t v20 = v62;
          *(void *)uint64_t v62 = v39;
          uint64_t v37 = v39;
        }

        *((_DWORD *)this + 3185) = v36 + v42;
      }

      *((_DWORD *)this + 3184) = v35 + 1;
      v37[v35] = 112;
      if (!*(_DWORD *)a4)
      {
        uint64_t v48 = *((_DWORD *)this + 3184);
        uint64_t v49 = *((unsigned int *)this + 3185);
        uint64_t v50 = this[1591];
        if (v48 >= v49)
        {
          uint64_t v51 = (char **)v20;
          uint64_t v52 = this[1593];
          uint64_t v53 = (char *)*((void *)v52 + 1);
          if (&v50[v49] != v53)
          {
            uint64_t v54 = *((void *)v52 + 2);
            goto LABEL_75;
          }

          uint64_t v55 = (unint64_t)&v50[v49 + 1];
          uint64_t v54 = *((void *)v52 + 2);
          if (v55 <= v54)
          {
            *((void *)v52 + 1) = v55;
            LODWORD(v56) = 1;
          }

          else
          {
LABEL_75:
            else {
              uint64_t v56 = (2 * v49);
            }
            uint64_t v57 = v56 + v49;
            if (!v53 || (unint64_t)&v53[v57] > v54)
            {
              uint64_t v58 = 2LL * *((void *)v52 + 4);
              if (v58 <= v57 + 1) {
                uint64_t v58 = v57 + 1;
              }
              *((void *)v52 + 4) = v58;
              uint64_t v59 = v58 + 8;
              uint64_t result = (uint64_t *)malloc(v58 + 8);
              uint64_t v60 = (char *)result + v59;
              *uint64_t result = *((void *)v52 + 3);
              uint64_t v53 = (char *)(result + 1);
              *((void *)v52 + 2) = v60;
              *((void *)v52 + 3) = result;
            }

            *((void *)v52 + 1) = &v53[v57];
            if ((_DWORD)v49)
            {
              uint64_t result = (uint64_t *)memcpy(v53, this[1591], v49);
              LODWORD(v49) = *((_DWORD *)this + 3185);
              uint64_t v48 = *((_DWORD *)this + 3184);
            }

            *uint64_t v51 = v53;
            uint64_t v50 = v53;
          }

          *((_DWORD *)this + 3185) = v49 + v56;
        }

        *((_DWORD *)this + 3184) = v48 + 1;
        v50[v48] = 114;
        *(_DWORD *)a4 = 0;
        *(void *)(a4 + 8) = 0LL;
        *(_DWORD *)(a4 + 16) = 0;
      }
    }
  }

  return result;
}

      *(_DWORD *)a3 = v7;
      *(void *)(a3 + 8) = v3;
      *(_DWORD *)(a3 + 16) = v6;
      return this;
    case 0x16uLL:
      this = memcmp(*(const void **)a2, "@unowned_inner_pointer", v5);
      if ((_DWORD)this) {
        goto LABEL_30;
      }
      uint64_t v33 = *(_DWORD *)(v8 + 12736);
      uint64_t v34 = *(unsigned int *)(v8 + 12740);
      unint64_t v35 = *(char **)(v8 + 12728);
      uint64_t v36 = *(void **)(v8 + 12744);
      uint64_t v37 = (char *)v36[1];
      if (&v35[v34] == v37)
      {
        uint64_t v51 = (unint64_t)&v35[v34 + 1];
        uint64_t v38 = v36[2];
        if (v51 <= v38)
        {
          v36[1] = v51;
          LODWORD(v52) = 1;
          goto LABEL_95;
        }
      }

      else
      {
        uint64_t v38 = v36[2];
      }

      else {
        uint64_t v52 = (2 * v34);
      }
      uint64_t v53 = v52 + v34;
      if (!v37 || (unint64_t)&v37[v53] > v38)
      {
        uint64_t v54 = 2LL * v36[4];
        if (v54 <= v53 + 1) {
          uint64_t v54 = v53 + 1;
        }
        v36[4] = v54;
        uint64_t v55 = v54 + 8;
        this = (uint64_t)malloc(v54 + 8);
        uint64_t v56 = this + v55;
        *(void *)this = v36[3];
        uint64_t v37 = (char *)(this + 8);
        v36[2] = v56;
        uint64_t v36[3] = this;
      }

      v36[1] = &v37[v53];
      if ((_DWORD)v34)
      {
        this = (uint64_t)memcpy(v37, *(const void **)(v8 + 12728), v34);
        LODWORD(v34) = *(_DWORD *)(v8 + 12740);
        uint64_t v33 = *(_DWORD *)(v8 + 12736);
      }

      *(void *)(v8 + 12728) = v37;
      unint64_t v35 = v37;
LABEL_95:
      *(_DWORD *)(v8 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v34 + v52;
LABEL_96:
      Swift::UInt64 v7 = 0;
      uint64_t v3 = 0LL;
      Swift::UInt64 v6 = 0;
      *(_DWORD *)(v8 + 12736) = v33 + 1;
      v35[v33] = 68;
      goto LABEL_33;
    default:
      goto LABEL_33;
  }

uint64_t specialized Collection.dropFirst(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a collection",  58LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x4E1uLL,  0);
  }
  uint64_t result = specialized Slice.index(_:offsetBy:limitedBy:)(a2, a1, a3);
  if ((v6 & 1) != 0) {
    uint64_t result = a3;
  }
  if (result > a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (result < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x71BuLL,  0);
  }
  return result;
}

uint64_t Collection.dropFirst(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v82 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  int64_t v81 = (char *)&v74 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v77 = (char *)&v74 - v11;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v80 = *(void *)(v13 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v76 = (char *)&v74 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v78 = (char *)&v74 - v17;
  uint64_t v89 = a2;
  uint64_t v92 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v91 = (char *)&v74 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v19, v20);
  uint64_t v87 = *(void *)(v21 - 8);
  uint64_t v88 = v21;
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  uint64_t v90 = (char *)&v74 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::UInt64 v26 = (char *)&v74 - v25;
  uint64_t v27 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v24);
  unint64_t v84 = (char *)&v74 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v83 = (char *)&v74 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  unint64_t v85 = (char *)&v74 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v74 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  unint64_t v39 = (char *)&v74 - v38;
  MEMORY[0x1895F8858](v37);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a collection",  58LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x4E1uLL,  0);
  }
  uint64_t v41 = a1;
  uint64_t v74 = v13;
  uint64_t v75 = (char *)&v74 - v40;
  uint64_t v42 = v89;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(v89, a3);
  uint64_t v43 = *(void (**)(uint64_t, uint64_t))(a3 + 72);
  v43(v42, a3);
  (*(void (**)(char *, uint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v39, v41, v36, v42, a3);
  uint64_t v44 = *(void (**)(char *, unint64_t))(v27 + 8);
  uint64_t v45 = v36;
  uint64_t v46 = v42;
  v44(v45, AssociatedTypeWitness);
  v44(v39, AssociatedTypeWitness);
  uint64_t v47 = v4;
  (*(void (**)(char *, char *, uint64_t))(v92 + 16))(v91, v4, v42);
  uint64_t v48 = v90;
  (*(void (**)(char *, char *, uint64_t))(v87 + 32))(v90, v26, v88);
  uint64_t v49 = v27;
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v27 + 48))(v48, 1LL, AssociatedTypeWitness) == 1)
  {
    uint64_t v50 = v75;
    uint64_t v51 = v91;
    v43(v46, a3);
    uint64_t v92 = *(void *)(v92 + 8);
    ((void (*)(char *, uint64_t))v92)(v51, v46);
    (*(void (**)(char *, uint64_t))(v87 + 8))(v90, v88);
  }

  else
  {
    uint64_t v92 = *(void *)(v92 + 8);
    ((void (*)(char *, uint64_t))v92)(v91, v42);
    uint64_t v50 = v75;
    (*(void (**)(char *, char *, unint64_t))(v27 + 32))(v75, v90, AssociatedTypeWitness);
  }

  uint64_t v52 = (char *)a3;
  uint64_t v53 = v85;
  uint64_t v90 = v52;
  uint64_t v91 = v47;
  v43(v46, (uint64_t)v52);
  uint64_t v54 = *(void (**)(char *, char *, unint64_t))(v27 + 16);
  uint64_t v55 = v83;
  v54(v83, v50, AssociatedTypeWitness);
  uint64_t v56 = v84;
  v54(v84, v53, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v55,  v56,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v44(v56, AssociatedTypeWitness);
  v44(v55, AssociatedTypeWitness);
  uint64_t v57 = v49;
  uint64_t v58 = TupleTypeMetadata2;
  uint64_t v59 = v53;
  uint64_t v60 = v77;
  uint64_t v61 = &v77[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v62 = *(void (**)(char *, char *, unint64_t))(v57 + 32);
  v62(v77, v50, AssociatedTypeWitness);
  v62(v61, v59, AssociatedTypeWitness);
  uint64_t v63 = v90;
  uint64_t v64 = v81;
  uint64_t v65 = &v81[*((int *)v58 + 12)];
  v54(v81, v60, AssociatedTypeWitness);
  v54(v65, v61, AssociatedTypeWitness);
  uint64_t v66 = v76;
  v62(v76, v64, AssociatedTypeWitness);
  v44(v65, AssociatedTypeWitness);
  uint64_t v67 = &v64[*((int *)v58 + 12)];
  v62(v64, v60, AssociatedTypeWitness);
  v62(v67, v61, AssociatedTypeWitness);
  uint64_t v68 = v74;
  v62(&v66[*(int *)(v74 + 36)], v67, AssociatedTypeWitness);
  v44(v64, AssociatedTypeWitness);
  uint64_t v69 = v80;
  unint64_t v70 = v78;
  (*(void (**)(char *, char *, uint64_t))(v80 + 32))(v78, v66, v68);
  uint64_t v71 = v91;
  uint64_t v72 = v89;
  (*((void (**)(char *, uint64_t, char *))v63 + 11))(v70, v89, v63);
  ((void (*)(char *, uint64_t))v92)(v71, v72);
  return (*(uint64_t (**)(char *, uint64_t))(v69 + 8))(v70, v68);
}

uint64_t Collection.dropLast(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v86 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v85 = (char *)&v74 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  int64_t v81 = (char *)&v74 - v11;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v84 = *(void *)(v13 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v80 = (char *)&v74 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v82 = (char *)&v74 - v17;
  uint64_t v89 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v74 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v87 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v95 = *(void *)(v87 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v87);
  uint64_t v88 = (char *)&v74 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v93 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  uint64_t v92 = (char *)&v74 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v90 = (char *)&v74 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v91 = (char *)&v74 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v74 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  uint64_t v36 = (char *)&v74 - v35;
  MEMORY[0x1895F8858](v34);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a collection",  58LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x4FCuLL,  0);
  }
  char v79 = v19;
  uint64_t v39 = v38;
  unint64_t v96 = (char *)&v74 - v37;
  uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 112))(a2, a3);
  if (__OFSUB__(v40, a1))
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v76 = v13;
  uint64_t v41 = (v40 - a1) & ~((v40 - a1) >> 63);
  uint64_t v77 = *(void (**)(uint64_t, uint64_t))(a3 + 64);
  v77(a2, a3);
  uint64_t v74 = *(void (**)(uint64_t, uint64_t))(a3 + 72);
  v74(a2, a3);
  uint64_t v42 = v39;
  (*(void (**)(char *, uint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v36, v41, v33, a2, a3);
  uint64_t v43 = v93;
  uint64_t v44 = *(void (**)(char *, unint64_t))(v93 + 8);
  v44(v33, AssociatedTypeWitness);
  uint64_t v75 = v44;
  v44(v36, AssociatedTypeWitness);
  uint64_t v45 = v79;
  uint64_t v46 = v89;
  uint64_t v47 = *(void (**)(char *, uint64_t, uint64_t))(v89 + 16);
  uint64_t v78 = v4;
  v47(v79, v4, a2);
  uint64_t v48 = v88;
  uint64_t v49 = v43;
  uint64_t v50 = v87;
  (*(void (**)(char *, uint64_t, uint64_t))(v95 + 32))(v88, v42, v87);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v49 + 48))(v48, 1LL, AssociatedTypeWitness) == 1)
  {
    v74(a2, a3);
    uint64_t v51 = *(void (**)(char *, uint64_t))(v46 + 8);
    v51(v45, a2);
    (*(void (**)(char *, uint64_t))(v95 + 8))(v48, v50);
  }

  else
  {
    uint64_t v51 = *(void (**)(char *, uint64_t))(v46 + 8);
    v51(v45, a2);
    (*(void (**)(char *, char *, unint64_t))(v49 + 32))(v96, v48, AssociatedTypeWitness);
  }

  uint64_t v53 = v91;
  uint64_t v52 = v92;
  uint64_t v54 = a3;
  uint64_t v55 = v90;
  uint64_t v56 = v49;
  uint64_t v57 = v78;
  uint64_t v95 = v54;
  v77(a2, v54);
  uint64_t v58 = *(void (**)(char *, char *, unint64_t))(v56 + 16);
  v58(v55, v53, AssociatedTypeWitness);
  v58(v52, v96, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v55,  v52,  AssociatedTypeWitness) & 1) == 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  unint64_t AssociatedConformanceWitness = (unint64_t)v51;
  uint64_t v59 = v75;
  v75(v52, AssociatedTypeWitness);
  v59(v55, AssociatedTypeWitness);
  uint64_t v92 = (char *)a2;
  uint64_t v60 = TupleTypeMetadata2;
  uint64_t v61 = v81;
  uint64_t v62 = &v81[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v63 = v53;
  uint64_t v64 = *(void (**)(char *, char *, unint64_t))(v56 + 32);
  v64(v81, v63, AssociatedTypeWitness);
  v64(v62, v96, AssociatedTypeWitness);
  uint64_t v65 = v85;
  uint64_t v66 = &v85[*((int *)v60 + 12)];
  v58(v85, v61, AssociatedTypeWitness);
  v58(v66, v62, AssociatedTypeWitness);
  uint64_t v67 = v80;
  v64(v80, v65, AssociatedTypeWitness);
  v59(v66, AssociatedTypeWitness);
  uint64_t v68 = &v65[*((int *)v60 + 12)];
  v64(v65, v61, AssociatedTypeWitness);
  v64(v68, v62, AssociatedTypeWitness);
  uint64_t v69 = v76;
  v64(&v67[*(int *)(v76 + 36)], v68, AssociatedTypeWitness);
  v59(v65, AssociatedTypeWitness);
  uint64_t v70 = v84;
  uint64_t v71 = v82;
  (*(void (**)(char *, char *, uint64_t))(v84 + 32))(v82, v67, v69);
  uint64_t v72 = v92;
  (*(void (**)(char *, char *))(v95 + 88))(v71, v92);
  ((void (*)(uint64_t, char *))AssociatedConformanceWitness)(v57, v72);
  return (*(uint64_t (**)(char *, uint64_t))(v70 + 8))(v71, v69);
}

uint64_t Collection.drop(while:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v93 = a1;
  uint64_t v94 = a2;
  uint64_t v83 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v82 = (char *)&v77 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v77 = (char *)&v77 - v11;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v81 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v80 = *(void *)(v81 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v81);
  uint64_t v88 = (char *)&v77 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v78 = (char *)&v77 - v16;
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v91 = *(void *)(v17 - 8);
  unint64_t v92 = v17;
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v90 = (char *)&v77 - v19;
  uint64_t v100 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  BOOL v102 = (char *)&v77 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  unint64_t v85 = (char *)&v77 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v84 = (char *)&v77 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v86 = (char *)&v77 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v89 = (char *)&v77 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v101 = (char *)&v77 - v32;
  MEMORY[0x1895F8858](v31);
  uint64_t v34 = (char *)&v77 - v33;
  uint64_t v35 = v5;
  (*(void (**)(uint64_t, uint64_t))(a4 + 64))(a3, a4);
  uint64_t v36 = a4;
  uint64_t v105 = *(void (**)(uint64_t, uint64_t))(a4 + 72);
  unint64_t v87 = AssociatedConformanceWitness;
  uint64_t v99 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v37 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v99 + 8);
  unint64_t v97 = AssociatedTypeWitness;
  uint64_t v98 = v37;
  uint64_t v103 = v22;
  char v104 = v5;
  unint64_t v96 = v34;
  while (1)
  {
    uint64_t v38 = v101;
    uint64_t v39 = v35;
    uint64_t v40 = (void (**)(char *, uint64_t, char *))v36;
    v105(a3, v36);
    char v41 = v98(v34, v38, AssociatedTypeWitness, v99);
    uint64_t v95 = *(void (**)(char *, unint64_t))(v22 + 8);
    v95(v38, AssociatedTypeWitness);
    uint64_t v42 = v102;
    uint64_t v43 = v100;
    uint64_t v44 = (void (*)(uint64_t, uint64_t))a3;
    (*(void (**)(char *, char *, uint64_t))(v100 + 16))(v102, v39, a3);
    if ((v41 & 1) != 0)
    {
      uint64_t v45 = v40;
      uint64_t v101 = *(char **)(v43 + 8);
      ((void (*)(char *, uint64_t))v101)(v42, a3);
      goto LABEL_9;
    }

    uint64_t v45 = v40;
    uint64_t v46 = (void (*)(_BYTE *, void))((uint64_t (*)(_BYTE *, char *, uint64_t, void (**)(char *, uint64_t, char *)))v40[10])( v106,  v34,  a3,  v40);
    uint64_t v48 = v91;
    unint64_t v47 = v92;
    uint64_t v49 = v42;
    uint64_t v50 = v90;
    (*(void (**)(char *))(v91 + 16))(v90);
    v46(v106, 0LL);
    uint64_t v51 = *(void (**)(char *, uint64_t))(v43 + 8);
    v51(v49, a3);
    uint64_t v52 = v107;
    char v53 = v93(v50);
    uint64_t v107 = v52;
    if (v52)
    {
      v51(v104, a3);
      (*(void (**)(char *, unint64_t))(v48 + 8))(v50, v47);
      return ((uint64_t (*)(char *, unint64_t))v95)(v96, v97);
    }

    char v54 = v53;
    (*(void (**)(char *, unint64_t))(v48 + 8))(v50, v47);
    if ((v54 & 1) == 0) {
      break;
    }
    uint64_t v34 = v96;
    uint64_t v35 = v104;
    v45[24](v96, a3, (char *)v45);
    unint64_t AssociatedTypeWitness = v97;
    uint64_t v22 = v103;
    uint64_t v36 = (uint64_t)v45;
  }

  uint64_t v101 = (char *)v51;
  uint64_t v44 = (void (*)(uint64_t, uint64_t))a3;
LABEL_9:
  uint64_t v56 = *(void (**)(char *, char *, unint64_t))(v103 + 16);
  uint64_t v57 = v89;
  uint64_t v59 = v96;
  unint64_t v58 = v97;
  v56(v89, v96, v97);
  uint64_t v60 = v86;
  BOOL v102 = (char *)v45;
  v105((uint64_t)v44, (uint64_t)v45);
  uint64_t v61 = v84;
  v56(v84, v57, v58);
  uint64_t v62 = v85;
  v56(v85, v60, v58);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(v87 + 24))(v61, v62, v58) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v105 = v44;
  uint64_t v63 = v95;
  v95(v62, v58);
  v63(v61, v58);
  v63(v59, v58);
  uint64_t v64 = TupleTypeMetadata2;
  uint64_t v65 = v77;
  uint64_t v66 = &v77[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v67 = *(void (**)(char *, char *, unint64_t))(v103 + 32);
  v67(v77, v89, v58);
  v67(v66, v60, v58);
  uint64_t v68 = v82;
  uint64_t v69 = &v82[*((int *)v64 + 12)];
  v56(v82, v65, v58);
  v56(v69, v66, v58);
  v67(v88, v68, v58);
  v63(v69, v58);
  uint64_t v70 = &v68[*((int *)v64 + 12)];
  v67(v68, v65, v58);
  v67(v70, v66, v58);
  uint64_t v71 = v81;
  uint64_t v72 = v88;
  v67(&v88[*(int *)(v81 + 36)], v70, v58);
  v63(v68, v58);
  uint64_t v73 = v80;
  uint64_t v74 = v78;
  (*(void (**)(char *, char *, uint64_t))(v80 + 32))(v78, v72, v71);
  uint64_t v76 = v104;
  uint64_t v75 = v105;
  (*((void (**)(char *, void))v102 + 11))(v74, v105);
  ((void (*)(char *, void))v101)(v76, v75);
  return (*(uint64_t (**)(char *, uint64_t))(v73 + 8))(v74, v71);
}

uint64_t specialized Collection.prefix(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a prefix of negative length from a collection",  56LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x52EuLL,  0);
  }
  uint64_t v4 = specialized UnsafeMutableBufferPointer.index(_:offsetBy:limitedBy:)(0LL, a1, a3);
  if ((v5 & 1) != 0) {
    uint64_t v6 = a3;
  }
  else {
    uint64_t v6 = v4;
  }
  if (v6 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v6 > a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x266uLL,  0);
  }
  return 0LL;
}

uint64_t Collection.prefix(_:)@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v84 = (unint64_t)a1;
  uint64_t v77 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v76 = (char *)&v68 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v72 = (char *)&v68 - v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v75 = *(void *)(v12 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v71 = (char *)&v68 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v73 = (char *)&v68 - v16;
  uint64_t v87 = a2;
  uint64_t v79 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v78 = (char *)&v68 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v18, v19);
  uint64_t v85 = *(void *)(v20 - 8);
  uint64_t v86 = v20;
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v88 = (char *)&v68 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v68 - v24;
  uint64_t v26 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v23);
  uint64_t v82 = (char *)&v68 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v80 = (char *)&v68 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v81 = (char *)&v68 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v35 = (char *)&v68 - v34;
  uint64_t v36 = MEMORY[0x1895F8858](v33);
  uint64_t v38 = (char *)&v68 - v37;
  MEMORY[0x1895F8858](v36);
  uint64_t v40 = (char *)&v68 - v39;
  if ((v84 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a prefix of negative length from a collection",  56LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x52EuLL,  0);
  }
  unint64_t v41 = v84;
  uint64_t v69 = v12;
  uint64_t v42 = v87;
  uint64_t v70 = *(void (**)(uint64_t, uint64_t))(a3 + 64);
  v70(v87, a3);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(a3 + 72);
  v68(v42, a3);
  (*(void (**)(char *, unint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v38, v41, v35, v42, a3);
  uint64_t v43 = *(void (**)(char *, unint64_t))(v26 + 8);
  v43(v35, AssociatedTypeWitness);
  unint64_t v84 = (unint64_t)v43;
  v43(v38, AssociatedTypeWitness);
  uint64_t v45 = v78;
  uint64_t v44 = v79;
  (*(void (**)(char *, char *, uint64_t))(v79 + 16))(v78, v4, v42);
  uint64_t v46 = v88;
  (*(void (**)(char *, char *, uint64_t))(v85 + 32))(v88, v25, v86);
  uint64_t v47 = v26;
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v26 + 48))(v46, 1LL, AssociatedTypeWitness) == 1)
  {
    v68(v42, a3);
    uint64_t v79 = *(void *)(v44 + 8);
    ((void (*)(char *, uint64_t))v79)(v45, v42);
    (*(void (**)(char *, uint64_t))(v85 + 8))(v88, v86);
  }

  else
  {
    uint64_t v79 = *(void *)(v44 + 8);
    ((void (*)(char *, uint64_t))v79)(v45, v42);
    (*(void (**)(char *, char *, unint64_t))(v26 + 32))(v40, v88, AssociatedTypeWitness);
  }

  uint64_t v49 = v80;
  uint64_t v48 = v81;
  v70(v42, a3);
  uint64_t v50 = *(void (**)(char *, char *, unint64_t))(v26 + 16);
  v50(v49, v48, AssociatedTypeWitness);
  uint64_t v88 = v4;
  uint64_t v51 = v82;
  v50(v82, v40, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v49,  v51,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v86 = a3;
  uint64_t v52 = (void (*)(char *, unint64_t))v84;
  ((void (*)(char *, unint64_t))v84)(v51, AssociatedTypeWitness);
  v52(v49, AssociatedTypeWitness);
  char v53 = TupleTypeMetadata2;
  char v54 = v48;
  uint64_t v55 = v72;
  uint64_t v56 = &v72[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v57 = *(void (**)(char *, char *, unint64_t))(v47 + 32);
  v57(v72, v54, AssociatedTypeWitness);
  v57(v56, v40, AssociatedTypeWitness);
  unint64_t v58 = v76;
  uint64_t v59 = &v76[*((int *)v53 + 12)];
  v50(v76, v55, AssociatedTypeWitness);
  v50(v59, v56, AssociatedTypeWitness);
  uint64_t v60 = v71;
  v57(v71, v58, AssociatedTypeWitness);
  v52(v59, AssociatedTypeWitness);
  uint64_t v61 = &v58[*((int *)v53 + 12)];
  v57(v58, v55, AssociatedTypeWitness);
  v57(v61, v56, AssociatedTypeWitness);
  uint64_t v62 = v69;
  v57(&v60[*(int *)(v69 + 36)], v61, AssociatedTypeWitness);
  v52(v58, AssociatedTypeWitness);
  uint64_t v63 = v75;
  uint64_t v64 = v73;
  (*(void (**)(char *, char *, uint64_t))(v75 + 32))(v73, v60, v62);
  uint64_t v65 = v87;
  uint64_t v66 = v88;
  (*(void (**)(char *, uint64_t))(v86 + 88))(v64, v87);
  ((void (*)(char *, uint64_t))v79)(v66, v65);
  return (*(uint64_t (**)(char *, uint64_t))(v63 + 8))(v64, v62);
}

uint64_t Collection.prefix(while:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v7 = (uint64_t)a4;
  uint64_t v98 = a1;
  uint64_t v99 = a2;
  uint64_t v88 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v87 = (char *)&v81 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v82 = (char *)&v81 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v86 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v85 = *(void *)(v86 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v86);
  uint64_t v81 = (char *)&v81 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v83 = (char *)&v81 - v17;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v96 = *(void *)(v18 - 8);
  unint64_t v97 = v18;
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v95 = (char *)&v81 - v20;
  uint64_t v21 = *(void *)(a3 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v106 = (char *)&v81 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v91 = (char *)&v81 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v90 = (char *)&v81 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v92 = (char *)&v81 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v94 = (char *)&v81 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v105 = (char *)&v81 - v34;
  MEMORY[0x1895F8858](v33);
  uint64_t v36 = (char *)&v81 - v35;
  uint64_t v89 = *(void (**)(uint64_t, uint64_t))(v7 + 64);
  v89(a3, v7);
  uint64_t v37 = *(void (**)(uint64_t, uint64_t))(v7 + 72);
  unint64_t v93 = AssociatedConformanceWitness;
  uint64_t v103 = *(void *)(AssociatedConformanceWitness + 8);
  char v104 = v37;
  uint64_t v38 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v103 + 8);
  unint64_t v101 = AssociatedTypeWitness;
  BOOL v102 = v38;
  uint64_t v107 = v24;
  uint64_t v100 = v36;
  unint64_t v109 = v5;
  while (1)
  {
    uint64_t v39 = v105;
    v104(a3, v7);
    char v40 = v102(v36, v39, AssociatedTypeWitness, v103);
    char v108 = *(void (**)(char *, unint64_t))(v24 + 8);
    v108(v39, AssociatedTypeWitness);
    unint64_t v41 = v106;
    uint64_t v42 = (char *)a3;
    (*(void (**)(char *, char *, uint64_t))(v21 + 16))(v106, v6, a3);
    if ((v40 & 1) != 0)
    {
      uint64_t v43 = v7;
      uint64_t v106 = *(char **)(v21 + 8);
      ((void (*)(char *, uint64_t))v106)(v41, a3);
      goto LABEL_9;
    }

    uint64_t v43 = v7;
    uint64_t v44 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v7 + 80))( v110,  v36,  a3,  v7);
    uint64_t v45 = v95;
    uint64_t v46 = v96;
    unint64_t v47 = v97;
    (*(void (**)(char *))(v96 + 16))(v95);
    v44(v110, 0LL);
    uint64_t v48 = v41;
    uint64_t v49 = v21;
    uint64_t v50 = *(void (**)(char *, uint64_t))(v21 + 8);
    v50(v48, a3);
    uint64_t v51 = v111;
    char v52 = v98(v45);
    uint64_t v111 = v51;
    if (v51)
    {
      v50(v109, a3);
      (*(void (**)(char *, unint64_t))(v46 + 8))(v45, v47);
      return ((uint64_t (*)(char *, unint64_t))v108)(v100, v101);
    }

    char v53 = v52;
    (*(void (**)(char *, unint64_t))(v46 + 8))(v45, v47);
    if ((v53 & 1) == 0) {
      break;
    }
    uint64_t v7 = v43;
    char v54 = *(void (**)(char *, uint64_t, uint64_t))(v43 + 192);
    uint64_t v36 = v100;
    uint64_t v6 = v109;
    v54(v100, a3, v7);
    unint64_t AssociatedTypeWitness = v101;
    uint64_t v24 = v107;
    uint64_t v21 = v49;
  }

  uint64_t v106 = (char *)v50;
LABEL_9:
  uint64_t v56 = v94;
  uint64_t v57 = v43;
  v89((uint64_t)v42, v43);
  unint64_t v58 = *(void (**)(char *, char *, unint64_t))(v107 + 16);
  uint64_t v59 = v92;
  uint64_t v61 = v100;
  unint64_t v60 = v101;
  v58(v92, v100, v101);
  uint64_t v62 = v90;
  v58(v90, v56, v60);
  uint64_t v63 = v91;
  v58(v91, v59, v60);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(v93 + 24))(v62, v63, v60) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v105 = v42;
  uint64_t v64 = v108;
  v108(v63, v60);
  v64(v62, v60);
  v64(v61, v60);
  uint64_t v65 = TupleTypeMetadata2;
  uint64_t v66 = v82;
  uint64_t v67 = &v82[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v68 = *(void (**)(char *, char *, unint64_t))(v107 + 32);
  v68(v82, v94, v60);
  v68(v67, v59, v60);
  uint64_t v69 = *((int *)v65 + 12);
  uint64_t v107 = v57;
  unint64_t v70 = v60;
  uint64_t v71 = v87;
  uint64_t v72 = &v87[v69];
  v58(v87, v66, v60);
  v58(v72, v67, v60);
  uint64_t v73 = v81;
  v68(v81, v71, v70);
  uint64_t v74 = v108;
  v108(v72, v70);
  uint64_t v75 = &v71[*((int *)v65 + 12)];
  v68(v71, v66, v70);
  v68(v75, v67, v70);
  uint64_t v76 = v86;
  v68(&v73[*(int *)(v86 + 36)], v75, v70);
  v74(v71, v70);
  uint64_t v77 = v85;
  uint64_t v78 = v83;
  (*(void (**)(char *, char *, uint64_t))(v85 + 32))(v83, v73, v76);
  uint64_t v79 = v109;
  uint64_t v80 = v105;
  (*(void (**)(char *, char *))(v107 + 88))(v78, v105);
  ((void (*)(char *, char *))v106)(v79, v80);
  return (*(uint64_t (**)(char *, uint64_t))(v77 + 8))(v78, v76);
}

uint64_t Collection.suffix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v87 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v78 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v83 = (char *)&v78 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v86 = *(void *)(v14 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  uint64_t v17 = (char *)&v78 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  unint64_t v84 = (char *)&v78 - v19;
  uint64_t v100 = a2;
  uint64_t v91 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v90 = (char *)&v78 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v21, v22);
  uint64_t v88 = *(void *)(v23 - 8);
  uint64_t v89 = v23;
  uint64_t v24 = MEMORY[0x1895F8858](v23);
  uint64_t v98 = (char *)&v78 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v78 - v27;
  uint64_t v96 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  uint64_t v94 = (char *)&v78 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  unint64_t v93 = (char *)&v78 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v95 = (char *)&v78 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v37 = (char *)&v78 - v36;
  uint64_t v38 = MEMORY[0x1895F8858](v35);
  char v40 = (char *)&v78 - v39;
  MEMORY[0x1895F8858](v38);
  unint64_t v92 = (char *)&v78 - v41;
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a suffix of negative length from a collection",  56LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x560uLL,  0);
  }
  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 112))(v100, a3);
  if (__OFSUB__(v42, a1))
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v80 = v17;
  uint64_t v81 = v11;
  uint64_t v82 = v14;
  uint64_t v43 = (v42 - a1) & ~((v42 - a1) >> 63);
  uint64_t v44 = v100;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(v100, a3);
  uint64_t v45 = *(void (**)(uint64_t, uint64_t))(a3 + 72);
  v45(v44, a3);
  (*(void (**)(char *, uint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v40, v43, v37, v44, a3);
  uint64_t v46 = v96;
  unint64_t v47 = *(void (**)(char *, unint64_t))(v96 + 8);
  v47(v37, AssociatedTypeWitness);
  uint64_t v79 = v47;
  v47(v40, AssociatedTypeWitness);
  uint64_t v49 = v90;
  uint64_t v48 = v91;
  uint64_t v50 = *(void (**)(char *, uint64_t, uint64_t))(v91 + 16);
  uint64_t v99 = v4;
  v50(v90, v4, v44);
  uint64_t v51 = v88;
  char v52 = v98;
  char v53 = v28;
  uint64_t v54 = v89;
  (*(void (**)(char *, char *, uint64_t))(v88 + 32))(v98, v53, v89);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v46 + 48))(v52, 1LL, AssociatedTypeWitness) == 1)
  {
    uint64_t v55 = v49;
    uint64_t v56 = v92;
    uint64_t v57 = v100;
    v45(v100, a3);
    uint64_t v91 = *(void *)(v48 + 8);
    ((void (*)(char *, uint64_t))v91)(v55, v57);
    (*(void (**)(char *, uint64_t))(v51 + 8))(v98, v54);
  }

  else
  {
    uint64_t v91 = *(void *)(v48 + 8);
    ((void (*)(char *, uint64_t))v91)(v49, v100);
    uint64_t v56 = v92;
    (*(void (**)(char *, char *, unint64_t))(v46 + 32))(v92, v52, AssociatedTypeWitness);
  }

  unint64_t v58 = v95;
  uint64_t v59 = v93;
  v45(v100, a3);
  unint64_t v60 = *(void (**)(char *, char *, unint64_t))(v46 + 16);
  v60(v59, v56, AssociatedTypeWitness);
  uint64_t v61 = v94;
  v60(v94, v58, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v59,  v61,  AssociatedTypeWitness) & 1) == 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v98 = (char *)a3;
  uint64_t v62 = v79;
  v79(v61, AssociatedTypeWitness);
  v62(v59, AssociatedTypeWitness);
  uint64_t v63 = TupleTypeMetadata2;
  uint64_t v64 = v83;
  uint64_t v65 = &v83[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v66 = v56;
  uint64_t v67 = *(void (**)(char *, char *, unint64_t))(v46 + 32);
  v67(v83, v66, AssociatedTypeWitness);
  v67(v65, v58, AssociatedTypeWitness);
  uint64_t v68 = v81;
  uint64_t v69 = &v81[*((int *)v63 + 12)];
  v60(v81, v64, AssociatedTypeWitness);
  v60(v69, v65, AssociatedTypeWitness);
  unint64_t v70 = v80;
  v67(v80, v68, AssociatedTypeWitness);
  v62(v69, AssociatedTypeWitness);
  uint64_t v71 = &v68[*((int *)v63 + 12)];
  v67(v68, v64, AssociatedTypeWitness);
  v67(v71, v65, AssociatedTypeWitness);
  uint64_t v72 = v82;
  v67(&v70[*(int *)(v82 + 36)], v71, AssociatedTypeWitness);
  v62(v68, AssociatedTypeWitness);
  uint64_t v73 = v86;
  uint64_t v74 = v84;
  (*(void (**)(char *, char *, uint64_t))(v86 + 32))(v84, v70, v72);
  uint64_t v75 = v99;
  uint64_t v76 = v100;
  (*((void (**)(char *, uint64_t))v98 + 11))(v74, v100);
  ((void (*)(uint64_t, uint64_t))v91)(v75, v76);
  return (*(uint64_t (**)(char *, uint64_t))(v73 + 8))(v74, v72);
}

uint64_t specialized Collection.prefix(upTo:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a3 < a1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x266uLL,  0);
  }
  return 0LL;
}

uint64_t Collection.prefix(upTo:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v55 = a1;
  uint64_t v51 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v10 = (char *)&v44 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v47 = (char *)&v44 - v12;
  uint64_t v13 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v44 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v44 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v44 - v20;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v24 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v23);
  uint64_t v48 = *(void *)(v24 - 8);
  uint64_t v49 = v24;
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  uint64_t v45 = (char *)&v44 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v46 = (char *)&v44 - v27;
  uint64_t v28 = *(void (**)(uint64_t, uint64_t))(a3 + 64);
  uint64_t v53 = a2;
  uint64_t v54 = v4;
  uint64_t v52 = a3;
  v28(a2, a3);
  uint64_t v29 = (void (*)(char *, char *, unint64_t))v13[2];
  v29(v19, v21, AssociatedTypeWitness);
  v29(v16, v55, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v19,  v16,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v30 = (void (*)(char *, unint64_t))v13[1];
  v30(v16, AssociatedTypeWitness);
  v30(v19, AssociatedTypeWitness);
  uint64_t v31 = TupleTypeMetadata2;
  uint64_t v32 = v47;
  uint64_t v33 = &v47[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v34 = (void (*)(char *, char *, unint64_t))v13[4];
  v34(v47, v21, AssociatedTypeWitness);
  v29(v33, v55, AssociatedTypeWitness);
  uint64_t v35 = &v10[*((int *)v31 + 12)];
  v29(v10, v32, AssociatedTypeWitness);
  v29(v35, v33, AssociatedTypeWitness);
  uint64_t v36 = v45;
  v34(v45, v10, AssociatedTypeWitness);
  v30(v35, AssociatedTypeWitness);
  uint64_t v37 = &v10[*((int *)v31 + 12)];
  v34(v10, v32, AssociatedTypeWitness);
  v34(v37, v33, AssociatedTypeWitness);
  uint64_t v38 = v49;
  v34(&v36[*(int *)(v49 + 36)], v37, AssociatedTypeWitness);
  v30(v10, AssociatedTypeWitness);
  uint64_t v39 = v48;
  char v40 = v46;
  (*(void (**)(char *, char *, uint64_t))(v48 + 32))(v46, v36, v38);
  uint64_t v41 = v53;
  uint64_t v42 = v54;
  (*(void (**)(char *, uint64_t))(v52 + 88))(v40, v53);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v41 - 8) + 8LL))(v42, v41);
  return (*(uint64_t (**)(char *, uint64_t))(v39 + 8))(v40, v38);
}

uint64_t Collection.suffix(from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v55 = a1;
  uint64_t v51 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v10 = (char *)&v44 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v47 = (char *)&v44 - v12;
  uint64_t v13 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v44 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v44 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v44 - v20;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v24 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v23);
  uint64_t v48 = *(void *)(v24 - 8);
  uint64_t v49 = v24;
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  uint64_t v45 = (char *)&v44 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v46 = (char *)&v44 - v27;
  uint64_t v28 = *(void (**)(uint64_t, uint64_t))(a3 + 72);
  uint64_t v53 = a2;
  uint64_t v54 = v4;
  uint64_t v52 = a3;
  v28(a2, a3);
  uint64_t v29 = (void (*)(char *, uint64_t, unint64_t))v13[2];
  v29(v19, v55, AssociatedTypeWitness);
  v29(v16, (uint64_t)v21, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v19,  v16,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v30 = (void (*)(char *, unint64_t))v13[1];
  v30(v16, AssociatedTypeWitness);
  v30(v19, AssociatedTypeWitness);
  uint64_t v31 = TupleTypeMetadata2;
  uint64_t v32 = v47;
  uint64_t v33 = &v47[*((int *)TupleTypeMetadata2 + 12)];
  v29(v47, v55, AssociatedTypeWitness);
  uint64_t v34 = (void (*)(char *, char *, unint64_t))v13[4];
  v34(v33, v21, AssociatedTypeWitness);
  uint64_t v35 = &v10[*((int *)v31 + 12)];
  v29(v10, (uint64_t)v32, AssociatedTypeWitness);
  v29(v35, (uint64_t)v33, AssociatedTypeWitness);
  uint64_t v36 = v45;
  v34(v45, v10, AssociatedTypeWitness);
  v30(v35, AssociatedTypeWitness);
  uint64_t v37 = &v10[*((int *)v31 + 12)];
  v34(v10, v32, AssociatedTypeWitness);
  v34(v37, v33, AssociatedTypeWitness);
  uint64_t v38 = v49;
  v34(&v36[*(int *)(v49 + 36)], v37, AssociatedTypeWitness);
  v30(v10, AssociatedTypeWitness);
  uint64_t v39 = v48;
  char v40 = v46;
  (*(void (**)(char *, char *, uint64_t))(v48 + 32))(v46, v36, v38);
  uint64_t v41 = v53;
  uint64_t v42 = v54;
  (*(void (**)(char *, uint64_t))(v52 + 88))(v40, v53);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v41 - 8) + 8LL))(v42, v41);
  return (*(uint64_t (**)(char *, uint64_t))(v39 + 8))(v40, v38);
}

uint64_t Collection.prefix(through:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v17 - v12;
  uint64_t v14 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))( (char *)&v17 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v4,  a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 184))(a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v14 + 8))(v4, a2);
  Collection.prefix(upTo:)(v13, a2, a3, a4);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v13, AssociatedTypeWitness);
}

uint64_t static SignedInteger<>.max.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(v8 + 72))(v5);
  (*(void (**)(char *, uint64_t))(*(void *)(a2 + 8) + 184LL))(v7, a1);
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v7, a1);
}

void (*Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)( uint64_t a1, int a2, uint64_t (*a3)(char *), uint64_t a4, uint64_t a5, uint64_t a6))(char *, unint64_t)
{
  uint64_t v7 = a5;
  uint64_t v143 = a3;
  uint64_t v144 = a4;
  LODWORD(v145) = a2;
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  a5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v122 = (char *)&v114 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v11, v11, "lower upper ", 0LL);
  uint64_t v12 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v120 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v117 = (char *)&v114 - v14;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  v7,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v121 = type metadata accessor for Range(0LL, v11, AssociatedConformanceWitness, v15);
  uint64_t v16 = *(void *)(v121 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v121);
  uint64_t v116 = (char *)&v114 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  int v118 = (char *)&v114 - v19;
  uint64_t v150 = a6;
  unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v114 - v22;
  uint64_t v146 = *(void *)(v11 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v124 = (char *)&v114 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v123 = (char *)&v114 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v29 = MEMORY[0x1895F8858](v28);
  unint64_t v132 = (char *)&v114 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v114 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  unint64_t v138 = (void (*)(char *, unint64_t))((char *)&v114 - v35);
  uint64_t v36 = *(void *)(v7 - 8);
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  uint64_t v41 = (char *)&v114 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v134 = a1;
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Must take zero or more splits",  29LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x610uLL,  0);
  }
  uint64_t v141 = v39;
  uint64_t v142 = v37;
  uint64_t v125 = v38;
  uint64_t v115 = v16;
  uint64_t v42 = swift_allocObject((uint64_t)&unk_189B781E0, 0x18uLL, 7uLL);
  uint64_t v131 = AssociatedTypeWitness;
  _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
  uint64_t v139 = v42;
  v42[2] = &_swiftEmptyArrayStorage;
  unint64_t v130 = v42 + 2;
  uint64_t v140 = swift_allocBox(v11);
  uint64_t v43 = *(void (**)(uint64_t, uint64_t))(v150 + 64);
  uint64_t v137 = v44;
  uint64_t v45 = v147;
  v43(v7, v150);
  (*(void (**)(char *, uint64_t, uint64_t))(v36 + 16))(v41, v45, v7);
  if (!v134)
  {
    uint64_t v49 = *(void (**)(char *, uint64_t))(v36 + 8);
    v49(v41, v7);
    uint64_t v48 = v147;
    char v47 = v145;
    goto LABEL_6;
  }

  char v46 = (*(uint64_t (**)(uint64_t))(v150 + 104))(v7);
  uint64_t v126 = *(void (**)(char *, uint64_t))(v36 + 8);
  v126(v41, v7);
  char v47 = v145;
  if ((v46 & 1) != 0)
  {
    uint64_t v48 = v147;
    uint64_t v49 = v126;
LABEL_6:
    uint64_t v50 = (const char *)v150;
    uint64_t v51 = v138;
    (*(void (**)(uint64_t, uint64_t))(v150 + 72))(v7, v150);
    int v52 = v47 & 1;
    uint64_t v54 = (uint64_t)v139;
    uint64_t v53 = v140;
    appendSubsequence #1 <A>(end:) in Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)( v51,  (uint64_t)v140,  v52,  (uint64_t)v139,  v48,  v7,  v50);
    v49((char *)v48, v7);
    (*(void (**)(void, unint64_t))(v146 + 8))(v51, v11);
    uint64_t v55 = *(void (**)(char *, unint64_t))(v54 + 16);
    swift_bridgeObjectRetain((unint64_t)v55, v56, v57, v58);
    swift_release(v54);
LABEL_22:
    swift_release((uint64_t)v53);
    return v55;
  }

  uint64_t v129 = *(void (**)(char *, uint64_t, unint64_t))(v146 + 16);
  v129(v33, v137, v11);
  uint64_t v59 = v132;
  uint64_t v60 = v147;
  (*(void (**)(uint64_t))(v150 + 72))(v7);
  uint64_t v61 = *(void *)(AssociatedConformanceWitness + 8);
  char v135 = *(uint64_t (**)(uint64_t, char *, unint64_t, uint64_t))(v61 + 8);
  uint64_t v136 = v61;
  if ((((uint64_t (*)(char *, char *, unint64_t))v135)(v33, v59, v11) & 1) != 0)
  {
LABEL_8:
    if ((v135(v137, v59, v11, v136) & 1) != 0 && (v145 & 1) != 0)
    {
      v126((char *)v60, v7);
      uint64_t v62 = *(void (**)(char *, unint64_t))(v146 + 8);
      v62(v59, v11);
      v62(v33, v11);
    }

    else
    {
      uint64_t v145 = v7;
      uint64_t v88 = v125;
      uint64_t v89 = v129;
      v129(v125, v137, v11);
      uint64_t v90 = v123;
      v89(v123, (uint64_t)v88, v11);
      uint64_t v91 = v124;
      v89(v124, (uint64_t)v59, v11);
      if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v90,  v91,  v11) & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }
      unint64_t v92 = v59;
      uint64_t v93 = v146;
      uint64_t v94 = *(void (**)(char *, unint64_t))(v146 + 8);
      v94(v91, v11);
      v94(v90, v11);
      v94(v33, v11);
      uint64_t v95 = TupleTypeMetadata2;
      uint64_t v96 = v117;
      unint64_t v97 = &v117[*((int *)TupleTypeMetadata2 + 12)];
      uint64_t v98 = *(void (**)(char *, uint64_t, unint64_t))(v93 + 32);
      v98(v117, (uint64_t)v125, v11);
      v98(v97, (uint64_t)v92, v11);
      uint64_t v99 = v120;
      uint64_t v100 = &v120[*((int *)v95 + 12)];
      v89(v120, (uint64_t)v96, v11);
      v89(v100, (uint64_t)v97, v11);
      unint64_t v101 = v116;
      v98(v116, (uint64_t)v99, v11);
      v94(v100, v11);
      BOOL v102 = &v99[*((int *)v95 + 12)];
      v98(v99, (uint64_t)v96, v11);
      v98(v102, (uint64_t)v97, v11);
      uint64_t v103 = v121;
      v98(&v101[*(int *)(v121 + 36)], (uint64_t)v102, v11);
      v94(v99, v11);
      uint64_t v104 = v115;
      uint64_t v105 = v118;
      (*(void (**)(char *, char *, uint64_t))(v115 + 32))(v118, v101, v103);
      uint64_t v106 = (uint64_t)v122;
      uint64_t v107 = v147;
      uint64_t v108 = v145;
      (*(void (**)(char *, uint64_t))(v150 + 88))(v105, v145);
      v126((char *)v107, v108);
      (*(void (**)(char *, uint64_t))(v104 + 8))(v105, v103);
      uint64_t v111 = type metadata accessor for Array(0LL, (uint64_t)v131, v109, v110);
      Array.append(_:)(v106, v111);
    }

    uint64_t v112 = (uint64_t)v139;
    uint64_t v55 = (void (*)(char *, unint64_t))v139[2];
    swift_bridgeObjectRetain((unint64_t)v55, v63, v64, v65);
    swift_release(v112);
    uint64_t v53 = v140;
    goto LABEL_22;
  }

  unint64_t v133 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v150 + 80);
  unint64_t v127 = v23;
  while (1)
  {
    uint64_t v67 = v7;
    uint64_t v68 = (void (*)(char *, void))v133(v149, v33, v7, v150);
    uint64_t v69 = v23;
    uint64_t v71 = v141;
    uint64_t v70 = v142;
    (*(void (**)(char *))(v141 + 16))(v69);
    v68(v149, 0LL);
    uint64_t v72 = v148;
    char v73 = v143(v69);
    uint64_t v148 = v72;
    if (v72) {
      break;
    }
    char v74 = v73;
    (*(void (**)(char *, uint64_t))(v71 + 8))(v69, v70);
    if ((v74 & 1) != 0)
    {
      unint64_t v75 = v11;
      uint64_t v76 = (const char *)v150;
      uint64_t v77 = v33;
      uint64_t v78 = v138;
      v129((char *)v138, (uint64_t)v77, v75);
      uint64_t v7 = v67;
      BOOL v79 = appendSubsequence #1 <A>(end:) in Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)( v78,  (uint64_t)v140,  v145 & 1,  (uint64_t)v139,  v60,  v67,  v76);
      uint64_t v80 = v146;
      uint64_t v81 = v78;
      uint64_t v33 = v77;
      uint64_t v82 = v76;
      unint64_t v11 = v75;
      uint64_t v23 = v127;
      (*(void (**)(void, unint64_t))(v146 + 8))(v81, v11);
      (*((void (**)(char *, uint64_t, const char *))v82 + 24))(v33, v67, v82);
      uint64_t v59 = v132;
      (*(void (**)(uint64_t, char *, unint64_t))(v80 + 24))(v137, v33, v11);
      if (v79)
      {
        uint64_t v86 = *v130;
        swift_bridgeObjectRetain(*v130, v83, v84, v85);
        Swift::Int v87 = Array._getCount()();
        swift_bridgeObjectRelease(v86);
        if (v87 == v134)
        {
          uint64_t v60 = v147;
          goto LABEL_8;
        }
      }
    }

    else
    {
      uint64_t v23 = v69;
      uint64_t v7 = v67;
      (*(void (**)(char *, uint64_t))(v150 + 192))(v33, v67);
    }

    char v66 = v135((uint64_t)v33, v59, v11, v136);
    uint64_t v60 = v147;
    if ((v66 & 1) != 0) {
      goto LABEL_8;
    }
  }

  v126((char *)v60, v67);
  (*(void (**)(char *, uint64_t))(v71 + 8))(v69, v70);
  uint64_t v55 = *(void (**)(char *, unint64_t))(v146 + 8);
  v55(v59, v11);
  v55(v33, v11);
  swift_release((uint64_t)v139);
  swift_release((uint64_t)v140);
  return v55;
}

BOOL appendSubsequence #1 <A>(end:) in Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)( void (*a1)(char *, unint64_t), uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7)
{
  uint64_t v67 = a5;
  uint64_t v60 = a4;
  int v71 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a7,  a6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v65 = (char *)&v56 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  a7,  a6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v11, v11, "lower upper ", 0LL);
  uint64_t v12 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v64 = (char *)&v56 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v58 = (char *)&v56 - v14;
  uint64_t v68 = a6;
  uint64_t v69 = a7;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a7,  a6,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for Range(0LL, v11, AssociatedConformanceWitness, v16);
  uint64_t v62 = *(void *)(v17 - 8);
  uint64_t v63 = v17;
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v57 = (char *)&v56 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v59 = (char *)&v56 - v21;
  uint64_t v22 = *(void **)(v11 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v56 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v28 = (char *)&v56 - v27;
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  uint64_t v31 = (char *)&v56 - v30;
  MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v56 - v32;
  uint64_t v34 = swift_projectBox(a2);
  uint64_t v35 = (void (*)(char *, uint64_t, unint64_t))v22[2];
  v35(v33, v34, v11);
  uint64_t v70 = a1;
  LODWORD(a1) = v36(v33, (void (*)(void, void))a1, v11);
  uint64_t v37 = v33;
  uint64_t v38 = (void (*)(char *, unint64_t))v22[1];
  v38(v37, v11);
  LODWORD(a1) = a1 & v71;
  if ((a1 & 1) == 0)
  {
    v35(v31, v34, v11);
    v35(v28, (uint64_t)v31, v11);
    v35(v25, (uint64_t)v70, v11);
    if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 24))( v28,  v25,  v11,  AssociatedConformanceWitness) & 1) == 0)
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    v60 += 16LL;
    int v71 = (int)a1;
    a1 = v38;
    v38(v25, v11);
    v38(v28, v11);
    uint64_t v40 = TupleTypeMetadata2;
    uint64_t v41 = v58;
    uint64_t v42 = &v58[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v43 = (void (*)(char *, char *, unint64_t))v22[4];
    v43(v58, v31, v11);
    v35(v42, (uint64_t)v70, v11);
    uint64_t v44 = v64;
    uint64_t v45 = &v64[*((int *)v40 + 12)];
    v35(v64, (uint64_t)v41, v11);
    v35(v45, (uint64_t)v42, v11);
    char v46 = v57;
    v43(v57, v44, v11);
    a1(v45, v11);
    char v47 = &v44[*((int *)v40 + 12)];
    v43(v44, v41, v11);
    v43(v47, v42, v11);
    uint64_t v48 = v63;
    v43(&v46[*(int *)(v63 + 36)], v47, v11);
    a1(v44, v11);
    LOBYTE(a1) = v71;
    uint64_t v49 = v62;
    uint64_t v50 = v59;
    (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v59, v46, v48);
    uint64_t v51 = (uint64_t)v65;
    (*((void (**)(char *, uint64_t))v69 + 11))(v50, v68);
    (*(void (**)(char *, uint64_t))(v49 + 8))(v50, v48);
    uint64_t v54 = type metadata accessor for Array(0LL, AssociatedTypeWitness, v52, v53);
    Array.append(_:)(v51, v54);
  }

  return (a1 & 1) == 0;
}

uint64_t Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)( a1,  a2,  a3,  a4,  a5,  a6,  (uint64_t)partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:));
}

uint64_t Collection<>.removeFirst()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void (*a3)(uint64_t, uint64_t)@<X8>)
{
  uint64_t v72 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v68 = (char *)&v62 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v67 = (char *)&v62 - v10;
  uint64_t v75 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  char v73 = (char *)&v62 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v70 = (char *)&v62 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  char v74 = (char *)&v62 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v62 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v62 - v20;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v23 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v22);
  uint64_t v65 = *(void *)(v23 - 8);
  uint64_t v66 = v23;
  uint64_t v24 = MEMORY[0x1895F8858](v23);
  uint64_t v63 = (char *)&v62 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v64 = (char *)&v62 - v27;
  uint64_t v28 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v26);
  uint64_t v76 = (char *)&v62 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v30 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a2 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v33 = type metadata accessor for Optional(0LL, v30, v31, v32);
  MEMORY[0x1895F8858](v33);
  uint64_t v35 = (char *)&v62 - v34;
  uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 104);
  uint64_t v78 = v3;
  uint64_t v79 = a1;
  uint64_t v77 = a2;
  if ((v36(a1, a2) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove items from an empty collection",  43LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x682uLL,  0);
  }
  Collection.first.getter(v79, v77, (uint64_t)v35);
  uint64_t v37 = *(void *)(v30 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v37 + 48))(v35, 1LL, v30) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x683uLL,  0);
  }
  (*(void (**)(void (*)(uint64_t, uint64_t), char *, unint64_t))(v37 + 32))(v72, v35, v30);
  uint64_t v38 = v79;
  (*(void (**)(char *, uint64_t, uint64_t))(v28 + 16))(v76, v78, v79);
  uint64_t v39 = v77;
  (*(void (**)(uint64_t, uint64_t))(v77 + 64))(v38, v77);
  (*(void (**)(char *, uint64_t, uint64_t))(v39 + 184))(v19, v38, v39);
  uint64_t v40 = v75;
  uint64_t v41 = *(void (**)(char *, unint64_t))(v75 + 8);
  v41(v19, AssociatedTypeWitness);
  uint64_t v42 = v74;
  uint64_t v43 = v38;
  uint64_t v44 = v40;
  (*(void (**)(uint64_t, uint64_t))(v39 + 72))(v43, v39);
  uint64_t v45 = *(void (**)(char *, char *, unint64_t))(v40 + 16);
  char v46 = v70;
  v45(v70, v21, AssociatedTypeWitness);
  char v47 = v73;
  v45(v73, v42, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v46,  v47,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v72 = *(void (**)(uint64_t, uint64_t))(v28 + 8);
  v72(v78, v79);
  v41(v47, AssociatedTypeWitness);
  v41(v46, AssociatedTypeWitness);
  uint64_t v48 = TupleTypeMetadata2;
  uint64_t v49 = v67;
  uint64_t v50 = &v67[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v51 = *(void (**)(char *, char *, unint64_t))(v44 + 32);
  v51(v67, v21, AssociatedTypeWitness);
  v51(v50, v42, AssociatedTypeWitness);
  uint64_t v52 = v68;
  uint64_t v53 = &v68[*((int *)v48 + 12)];
  v45(v68, v49, AssociatedTypeWitness);
  v45(v53, v50, AssociatedTypeWitness);
  uint64_t v54 = v63;
  v51(v63, v52, AssociatedTypeWitness);
  v41(v53, AssociatedTypeWitness);
  uint64_t v55 = &v52[*((int *)v48 + 12)];
  v51(v52, v49, AssociatedTypeWitness);
  v51(v55, v50, AssociatedTypeWitness);
  uint64_t v56 = v66;
  v51(&v54[*(int *)(v66 + 36)], v55, AssociatedTypeWitness);
  v41(v52, AssociatedTypeWitness);
  unint64_t v58 = v64;
  uint64_t v57 = v65;
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v64, v54, v56);
  uint64_t v59 = v76;
  uint64_t v60 = v79;
  (*(void (**)(char *, uint64_t))(v77 + 88))(v58, v79);
  (*(void (**)(char *, uint64_t))(v57 + 8))(v58, v56);
  return ((uint64_t (*)(char *, uint64_t))v72)(v59, v60);
}

uint64_t Collection<>.removeFirst(_:)(uint64_t a1, uint64_t a2, const char *a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v9 = (char *)&v70 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v77 = (char *)&v70 - v10;
  uint64_t v88 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v80 = *(void *)(v12 - 8);
  uint64_t v81 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v70 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v78 = (char *)&v70 - v17;
  uint64_t v18 = (char *)a2;
  uint64_t v83 = *(void (***)(char *, uint64_t, char *))(a2 - 8);
  MEMORY[0x1895F8858](v16);
  Swift::Int v87 = (char *)&v70 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v70 - v24;
  uint64_t v26 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v23);
  uint64_t v84 = (char *)&v70 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v30 = MEMORY[0x1895F8858](v29);
  uint64_t v82 = (char *)&v70 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v70 - v33;
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  uint64_t v37 = (char *)&v70 - v36;
  uint64_t result = MEMORY[0x1895F8858](v35);
  uint64_t v43 = (void (**)(char *, uint64_t, char *))((char *)&v70 - v42);
  if (v39)
  {
    if (v39 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x695uLL,  0);
    }
    uint64_t v70 = v41;
    uint64_t v71 = result;
    uint64_t v76 = v40;
    char v73 = v15;
    char v74 = v9;
    uint64_t v44 = v88;
    uint64_t v45 = v39;
    (*((void (**)(char *, const char *))v88 + 8))(v18, v88);
    uint64_t v75 = (void (*)(char *, const char *))*((void *)v44 + 9);
    v75(v18, v44);
    (*((void (**)(char *, uint64_t, char *, char *, const char *))v44 + 18))(v37, v45, v34, v18, v44);
    uint64_t v86 = v3;
    char v46 = *(void (**)(char *, unint64_t))(v26 + 8);
    v46(v34, AssociatedTypeWitness);
    uint64_t v72 = (void (*)(uint64_t, unint64_t))v46;
    v46(v37, AssociatedTypeWitness);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v26 + 48))(v25, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v70 + 8))(v25, v71);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x697uLL,  0);
    }

    char v47 = *(void (**)(void, char *, unint64_t))(v26 + 32);
    uint64_t v48 = v43;
    v47(v43, v25, AssociatedTypeWitness);
    uint64_t v49 = v83;
    uint64_t v50 = v86;
    v83[2](v87, v86, v18);
    uint64_t v51 = v82;
    v75(v18, v88);
    uint64_t v52 = v49[1];
    ((void (*)(uint64_t, char *))v52)(v50, v18);
    uint64_t v53 = *(void (**)(uint64_t, void, unint64_t))(v26 + 16);
    uint64_t v54 = v76;
    uint64_t v83 = v48;
    v53(v76, v48, AssociatedTypeWitness);
    uint64_t v55 = v84;
    v53((uint64_t)v84, v51, AssociatedTypeWitness);
    if (((*(uint64_t (**)(uint64_t, char *, unint64_t))(AssociatedConformanceWitness + 24))( v54,  v55,  AssociatedTypeWitness) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    unint64_t AssociatedConformanceWitness = (unint64_t)v52;
    uint64_t v56 = v72;
    v72((uint64_t)v55, AssociatedTypeWitness);
    v56(v54, AssociatedTypeWitness);
    uint64_t v57 = TupleTypeMetadata2;
    uint64_t v58 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v84 = v18;
    uint64_t v59 = v77;
    uint64_t v60 = &v77[v58];
    v47(v77, (char *)v83, AssociatedTypeWitness);
    v47(v60, v51, AssociatedTypeWitness);
    uint64_t v61 = v74;
    uint64_t v62 = &v74[*((int *)v57 + 12)];
    v53((uint64_t)v74, v59, AssociatedTypeWitness);
    v53((uint64_t)v62, v60, AssociatedTypeWitness);
    uint64_t v63 = v73;
    v47(v73, v61, AssociatedTypeWitness);
    v56((uint64_t)v62, AssociatedTypeWitness);
    uint64_t v64 = &v61[*((int *)v57 + 12)];
    v47(v61, v59, AssociatedTypeWitness);
    v47(v64, v60, AssociatedTypeWitness);
    uint64_t v65 = v81;
    v47(&v63[*(int *)(v81 + 36)], v64, AssociatedTypeWitness);
    v56((uint64_t)v61, AssociatedTypeWitness);
    uint64_t v66 = v80;
    uint64_t v67 = v78;
    (*(void (**)(char *, char *, uint64_t))(v80 + 32))(v78, v63, v65);
    uint64_t v68 = v87;
    uint64_t v69 = v84;
    (*((void (**)(char *, char *))v88 + 11))(v67, v84);
    (*(void (**)(char *, uint64_t))(v66 + 8))(v67, v65);
    return ((uint64_t (*)(char *, char *))AssociatedConformanceWitness)(v68, v69);
  }

  return result;
}

uint64_t Collection<>.firstIndex(of:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v50 = a4;
  uint64_t v43 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v51 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v49 = (char *)&v42 - v9;
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v44 = *(void *)(v10 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v42 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v42 - v14;
  uint64_t v18 = type metadata accessor for Optional((const char *)0xFF, v10, v16, v17);
  uint64_t v21 = type metadata accessor for Optional(0LL, v18, v19, v20);
  uint64_t v47 = *(void *)(v21 - 8);
  uint64_t v48 = (void (*)(uint64_t, uint64_t))v21;
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  uint64_t v24 = (char *)&v42 - v23;
  uint64_t v25 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858](v22);
  char v46 = (uint64_t (*)(char *, char *, unint64_t, uint64_t))((char *)&v42 - v26);
  uint64_t v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 120);
  uint64_t v52 = a1;
  v27(a1, a2, a3);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v25 + 48))(v24, 1LL, v18) == 1)
  {
    (*(void (**)(char *, void))(v47 + 8))(v24, v48);
    (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
    uint64_t v28 = *(void (**)(uint64_t, uint64_t))(a3 + 72);
    uint64_t v29 = *(void *)(swift_getAssociatedConformanceWitness( a3,  a2,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    uint64_t v30 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v29 + 8);
    uint64_t v48 = v28;
    v28(a2, a3);
    char v46 = v30;
    uint64_t v47 = v29;
    char v31 = v30(v15, v13, v10, v29);
    uint64_t v32 = *(void (**)(char *, unint64_t))(v44 + 8);
    v32(v13, v10);
    if ((v31 & 1) != 0)
    {
LABEL_6:
      v32(v15, v10);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v44 + 56))(v43, 1LL, 1LL, v10);
    }

    else
    {
      uint64_t v45 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a3 + 80);
      uint64_t v33 = v51;
      uint64_t v34 = v49;
      while (1)
      {
        uint64_t v35 = v45(v53, v15, a2, a3);
        (*(void (**)(char *))(v33 + 16))(v34);
        ((void (*)(_BYTE *, void))v35)(v53, 0LL);
        LOBYTE(v35) = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v50 + 8))( v34,  v52,  AssociatedTypeWitness);
        (*(void (**)(char *, unint64_t))(v33 + 8))(v34, AssociatedTypeWitness);
        if ((v35 & 1) != 0) {
          break;
        }
        (*(void (**)(char *, uint64_t, uint64_t))(a3 + 192))(v15, a2, a3);
        v48(a2, a3);
        char v36 = v46(v15, v13, v10, v47);
        v32(v13, v10);
        if ((v36 & 1) != 0) {
          goto LABEL_6;
        }
      }

      uint64_t v41 = v43;
      uint64_t v40 = v44;
      (*(void (**)(uint64_t, char *, unint64_t))(v44 + 32))(v43, v15, v10);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v40 + 56))(v41, 0LL, 1LL, v10);
    }
  }

  else
  {
    uint64_t v38 = *(void (**)(char *, char *, uint64_t))(v25 + 32);
    uint64_t v39 = v46;
    v38((char *)v46, v24, v18);
    return ((uint64_t (*)(uint64_t, uint64_t (*)(char *, char *, unint64_t, uint64_t), uint64_t))v38)( v43,  v39,  v18);
  }

Swift::UInt64 specialized Collection.firstIndex(where:)(unint64_t a1, unint64_t a2)
{
  uint64_t v47 = HIBYTE(a2) & 0xF;
  uint64_t v48 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    unint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v2) {
    return 0LL;
  }
  uint64_t v5 = 4 * v2;
  uint64_t v6 = (a1 >> 59) & 1;
  if ((a2 & 0x1000000000000000LL) == 0) {
    LODWORD(v6) = 1;
  }
  uint64_t v7 = 4LL << v6;
  uint64_t v44 = a2 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v45 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
  BOOL v11 = (_DWORD)v6 == 0;
  uint64_t v8 = 11LL;
  if (!v11) {
    uint64_t v8 = 7LL;
  }
  uint64_t v46 = v8;
  v9._Swift::UInt64 rawBits = 15LL;
  while (1)
  {
    uint64_t v10 = v9._rawBits & 0xC;
    BOOL v11 = v10 == v7 || (v9._rawBits & 1) == 0LL;
    if (v11)
    {
      Swift::UInt64 rawBits = v9._rawBits;
      if (v10 == v7)
      {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v9)._rawBits;
        if (v2 <= rawBits >> 16) {
          goto LABEL_123;
        }
      }

      else if (v2 <= v9._rawBits >> 16)
      {
        goto LABEL_123;
      }

      if ((rawBits & 1) == 0) {
        Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
      }
    }

    else
    {
      Swift::UInt64 rawBits = v9._rawBits;
      if (v2 <= v9._rawBits >> 16)
      {
        unint64_t v43 = 121LL;
LABEL_125:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v43,  0);
      }
    }

    uint64_t v13 = (rawBits >> 8) & 0x3F;
    int64_t v14 = rawBits >> 16;
    if (v13)
    {
      Swift::Int v15 = v13 + v14;
      if ((a2 & 0x1000000000000000LL) != 0) {
        goto LABEL_111;
      }
LABEL_23:
      if (v15 < v14) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }
      goto LABEL_27;
    }

    if (v5 != rawBits >> 14)
    {
      if ((a2 & 0x1000000000000000LL) == 0)
      {
        if ((a2 & 0x2000000000000000LL) != 0)
        {
          unint64_t v49 = a1;
          uint64_t v50 = v44;
          Swift::Int v15 = v14 + 1;
          if (v14 + 1 == v47) {
            goto LABEL_49;
          }
          int v22 = *(unsigned __int16 *)((char *)&v49 + v14);
          if (v22 != 2573 && (v22 & 0x80808080) == 0) {
            goto LABEL_49;
          }
        }

        else
        {
          uint64_t v19 = (char *)v45;
          uint64_t v20 = v48;
          if ((a1 & 0x1000000000000000LL) == 0) {
            uint64_t v19 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
          }
          Swift::Int v15 = v14 + 1;
          if (v14 + 1 == v20) {
            goto LABEL_28;
          }
          if (!v19) {
            goto LABEL_126;
          }
          int v21 = *(unsigned __int16 *)&v19[v14];
          if (v21 != 2573 && (v21 & 0x80808080) == 0)
          {
LABEL_28:
            uint64_t v16 = (char *)v45;
            if ((a1 & 0x1000000000000000LL) != 0)
            {
              if (v48 < v15) {
                goto LABEL_121;
              }
            }

            else
            {
              uint64_t v16 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
              if (v39 < v15) {
LABEL_121:
              }
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
            }

            if (v16) {
              uint64_t v17 = (uint8x16_t *)&v16[v14];
            }
            else {
              uint64_t v17 = 0LL;
            }
            uint64_t v18 = v15 - v14;
            if (v15 - v14 < 0) {
LABEL_122:
            }
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
            if (v15 != v14 && !v17) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
            }
            goto LABEL_52;
          }
        }
      }

      Swift::Int v15 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v14) + v14;
      if ((a2 & 0x1000000000000000LL) != 0)
      {
LABEL_111:
        Swift::String v41 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v14, v15);
        unint64_t object = (unint64_t)v41._object;
        uint64_t countAndFlagsBits = v41._countAndFlagsBits;
        goto LABEL_53;
      }

      goto LABEL_23;
    }

    Swift::Int v15 = rawBits >> 16;
    if ((a2 & 0x1000000000000000LL) != 0) {
      goto LABEL_111;
    }
LABEL_27:
    if ((a2 & 0x2000000000000000LL) == 0) {
      goto LABEL_28;
    }
LABEL_49:
    unint64_t v49 = a1;
    uint64_t v50 = v44;
    if (v47 < v15) {
      goto LABEL_121;
    }
    uint64_t v18 = v15 - v14;
    if (v15 - v14 < 0) {
      goto LABEL_122;
    }
    uint64_t v17 = (uint8x16_t *)((char *)&v49 + v14);
LABEL_52:
    uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v17, v18);
LABEL_53:
    uint64_t v25 = object;
    if (countAndFlagsBits == 48 && object == 0xE100000000000000LL)
    {
      char v26 = 1;
      if (v51) {
        goto LABEL_118;
      }
      goto LABEL_59;
    }

    if ((~object & 0x6000000000000000LL) == 0) {
      break;
    }
    char v26 = _stringCompareInternal(_:_:expecting:)(countAndFlagsBits, object, 48LL, 0xE100000000000000LL, 0);
    if (v51) {
      goto LABEL_118;
    }
LABEL_59:
    swift_bridgeObjectRelease(v25);
    if ((v26 & 1) == 0) {
      return v9._rawBits;
    }
    if (v10 == v7 || (v9._rawBits & 2) == 0)
    {
      if (v10 == v7)
      {
        v9._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v9)._rawBits;
        if (v2 <= v9._rawBits >> 16)
        {
LABEL_123:
          unint64_t v43 = 31LL;
          goto LABEL_125;
        }
      }

      else if (v2 <= v9._rawBits >> 16)
      {
        goto LABEL_123;
      }

      if ((v9._rawBits & 1) != 0)
      {
        if ((v9._rawBits & 2) != 0) {
          goto LABEL_68;
        }
      }

      else
      {
        Swift::UInt64 v40 = v9._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v9)._rawBits & 0xFFFFFFFFFFFFFFF3LL;
        v9._Swift::UInt64 rawBits = v40 | 1;
        if ((v40 & 2) != 0) {
          goto LABEL_68;
        }
      }

      if (v9._rawBits < 0x10000 || v9._rawBits >> 16 == v2) {
        v9._rawBits |= 3;
      }
      else {
        v9._Swift::UInt64 rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:)(v9)._rawBits;
      }
    }

    else if (v2 <= v9._rawBits >> 16)
    {
      unint64_t v43 = 254LL;
      goto LABEL_125;
    }

LABEL_90:
    unint64_t v29 = (v9._rawBits + 0x10000) & 0xFFFFFFFFFFFF0000LL;
    if (v5 != v29 >> 14)
    {
      Swift::Int v30 = (v9._rawBits + 0x10000) >> 16;
      if ((a2 & 0x2000000000000000LL) != 0)
      {
LABEL_92:
        unint64_t v49 = a1;
        uint64_t v50 = v44;
        if (v30 + 1 != v47)
        {
          int v33 = *(unsigned __int16 *)((char *)&v49 + v30);
          goto LABEL_94;
        }

    uint64_t v93 = HIBYTE(v85) & 0xF;
    uint64_t v94 = HIBYTE(v92) & 0xF;
    uint64_t v95 = v94 + v93;
    if (v94)
    {
      uint64_t v96 = 0;
      unint64_t v97 = 0LL;
      do
      {
        uint64_t v98 = v93 + v97;
        uint64_t v99 = v97 + 1;
        if (v97 >= 8) {
          uint64_t v100 = v92;
        }
        else {
          uint64_t v100 = v90;
        }
        unint64_t v101 = v100 >> (v96 & 0x38);
        BOOL v102 = (8 * v93 + v96) & 0x38;
        uint64_t v103 = (-255LL << v102) - 1;
        uint64_t v104 = (unint64_t)v101 << v102;
        uint64_t v105 = v104 | v103 & v85;
        uint64_t v106 = v104 | v103 & countAndFlagsBits;
        if (v98 < 8) {
          uint64_t countAndFlagsBits = v106;
        }
        else {
          uint64_t v85 = v105;
        }
        v96 += 8;
        unint64_t v97 = v99;
      }

      while (v94 != v99);
    }

    swift_bridgeObjectRelease(v5);
    swift_bridgeObjectRelease(object);
    uint64_t v109 = 0xA000000000000000LL;
    if (!(countAndFlagsBits & 0x8080808080808080LL | v85 & 0x80808080808080LL)) {
      uint64_t v109 = 0xE000000000000000LL;
    }
    v268._uint64_t countAndFlagsBits = countAndFlagsBits;
    v268._unint64_t object = (void *)(v109 & 0xFF00000000000000LL | (v95 << 56) | v85 & 0xFFFFFFFFFFFFFFLL);
  }

  swift_bridgeObjectRelease(v5);
  v268._uint64_t countAndFlagsBits = v184;
  v268._unint64_t object = (void *)v183;
LABEL_215:
  uint64_t v219 = v268._object;
  uint64_t v220 = ((unint64_t)v268._object >> 56) & 0xF;
  if (v220 || (v268._countAndFlagsBits & ~(uint64_t)v268._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v268._object & 0x2000000000000000LL) == 0
      || (uint64_t v221 = specialized _SmallString.init(_:appending:)( v268._countAndFlagsBits,  (unint64_t)v268._object,  0x29uLL,  0xE100000000000000LL),  (v214 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v213, v214, v215);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      uint64_t v222 = v268._countAndFlagsBits;
      id v223 = (uint64_t)v268._object;
    }

    else
    {
      uint64_t v222 = v221;
      id v223 = v213;
      swift_bridgeObjectRelease((uint64_t)v219);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v268._object);
    id v223 = 0xE100000000000000LL;
    uint64_t v222 = 41LL;
  }

  unint64_t v224 = specialized static String.+ infix(_:_:)(countAndFlagsBits, v158, v222, v223);
  swift_bridgeObjectRelease(v158);
  swift_bridgeObjectRelease(v223);
  return v224;
}

      swift_release(v133);
    }

    else if (v132)
    {
      uint64_t v123 = v8;
      uint64_t v77 = *(void *)(v2 + 64);
      uint64_t v131 = v2 + 64;
      uint64_t v78 = 1LL << *(_BYTE *)(v2 + 32);
      uint64_t v79 = -1LL;
      if (v78 < 64) {
        uint64_t v79 = ~(-1LL << v78);
      }
      uint64_t v80 = v79 & v77;
      uint64_t v134 = (id *)((unint64_t)(v78 + 63) >> 6);
      uint64_t v129 = (char *)v134 - 1;
      char v135 = (id *)(v41 - 1);
      swift_retain((unint64_t *)v2, v38, v39, v40);
      uint64_t v81 = 0LL;
      uint64_t v82 = 0LL;
      uint64_t v83 = v126;
      if (!v80) {
        goto LABEL_50;
      }
LABEL_41:
      uint64_t v84 = __clz(__rbit64(v80));
      v80 &= v80 - 1;
      uint64_t v85 = v84 | (v82 << 6);
LABEL_42:
      uint64_t v86 = v133;
      (*(void (**)(char *, unint64_t, uint64_t *))(v138 + 16))( v26,  *(void *)(v133 + 48) + *(void *)(v138 + 72) * v85,  v13);
      (*(void (**)(char *, unint64_t, uint64_t *))(v139 + 16))( &v26[*((int *)TupleTypeMetadata2 + 12)],  *(void *)(v86 + 56) + *(void *)(v139 + 72) * v85,  v3);
      Swift::Int v87 = 0LL;
      uint64_t v83 = v126;
      while (1)
      {
LABEL_43:
        uint64_t v88 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v88 + 56))( v26,  v87,  1LL,  TupleTypeMetadata2);
        (*(void (**)(char *, char *, uint64_t))(v136 + 32))(v29, v26, v137);
        if ((*(unsigned int (**)(char *, uint64_t, unint64_t *))(v88 + 48))( v29,  1LL,  TupleTypeMetadata2) == 1) {
          goto LABEL_90;
        }
        uint64_t v89 = *(void (**)(id *, char *, uint64_t *))(v139 + 32);
        v89(v83, &v29[*((int *)TupleTypeMetadata2 + 12)], v3);
        if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3))
        {
          if (v130 != 8) {
LABEL_94:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
          uint64_t v93 = *v83;
          swift_unknownObjectRetain(*v83, v90, v91, v92);
          (*(void (**)(id *, uint64_t *))(v139 + 8))(v83, v3);
        }

        else
        {
          unint64_t v97 = v123;
          v89(v123, (char *)v126, v3);
          uint64_t v98 = v97;
          uint64_t v83 = v126;
          uint64_t v93 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v98, v3, v99, v100);
        }

        if (v81 == (id *)0x1000000000000000LL) {
          goto LABEL_96;
        }
        *(void *)(v132 + 8LL * (void)v81) = v93;
        swift_unknownObjectRelease(v93);
        if (v81 == v135)
        {
          swift_release(v133);
          (*(void (**)(char *, uint64_t *))(v138 + 8))(v29, v13);
          return;
        }

        uint64_t v81 = (id *)((char *)v81 + 1);
        (*(void (**)(char *, uint64_t *))(v138 + 8))(v29, v13);
        if (v80) {
          goto LABEL_41;
        }
LABEL_50:
        uint64_t v94 = v82 + 1;
        if (__OFADD__(v82, 1LL)) {
          break;
        }
        if (v94 >= (uint64_t)v134)
        {
          uint64_t v80 = 0LL;
          Swift::Int v87 = 1LL;
        }

        else
        {
          uint64_t v95 = *(void *)(v131 + 8 * v94);
          if (v95) {
            goto LABEL_53;
          }
          uint64_t v96 = v82 + 2;
          if (v82 + 2 < (uint64_t)v134)
          {
            uint64_t v95 = *(void *)(v131 + 8 * v96);
            if (v95)
            {
              uint64_t v94 = v82 + 2;
LABEL_53:
              uint64_t v80 = (v95 - 1) & v95;
              uint64_t v85 = __clz(__rbit64(v95)) + (v94 << 6);
              uint64_t v82 = v94;
              goto LABEL_42;
            }

            while (1)
            {
              uint64_t v94 = v96 + 1;
              if (__OFADD__(v96, 1LL)) {
                goto LABEL_103;
              }
              if (v94 >= (uint64_t)v134)
              {
                uint64_t v80 = 0LL;
                Swift::Int v87 = 1LL;
                uint64_t v82 = (uint64_t)v129;
                goto LABEL_43;
              }

              uint64_t v95 = *(void *)(v131 + 8 * v94);
              ++v96;
              if (v95) {
                goto LABEL_53;
              }
            }
          }

          uint64_t v80 = 0LL;
          Swift::Int v87 = 1LL;
          ++v82;
        }
      }

      __break(1u);
LABEL_101:
      __break(1u);
LABEL_102:
      __break(1u);
LABEL_103:
      __break(1u);
LABEL_104:
      __break(1u);
    }
  }

      unint64_t v29 = __OFADD__(v53, v76);
      uint64_t v77 = v53 + v76;
      if (!v29)
      {
LABEL_91:
        if ((v15 & ~v19 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v19 & 0xFFFFFFFFFFFFFFFLL))
        {
          uint64_t v78 = v234;
          uint64_t v79 = _StringGuts.nativeUnusedCapacity.getter(v233, v234);
          if ((v80 & 1) != 0) {
            goto LABEL_250;
          }
          if (v77 < 16 && ((v78 & 0x2000000000000000LL) != 0 || v79 < v76)) {
            goto LABEL_149;
          }
        }

        else if (v77 <= 15)
        {
          uint64_t v78 = v234;
LABEL_149:
          swift_bridgeObjectRelease_n(v14, 5LL);
          uint64_t v126 = v233;
          swift_bridgeObjectRetain(v78, v127, v128, v129);
          unint64_t v130 = _StringGuts._convertedToSmall()(v126, v78);
          unint64_t v132 = v131;
          swift_bridgeObjectRelease(v78);
          v133._Swift::UInt64 rawBits = (v20 << 16) | 1;
          v134._Swift::UInt64 rawBits = 1LL;
          v135._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v134, v133, v13, v14);
          if (v135._rawBits < 0x10000) {
            v135._rawBits |= 3;
          }
          uint64_t v137 = specialized String.init(_:)(v135, v136, v13, v14);
          uint64_t v139 = v138;
          swift_bridgeObjectRelease(v14);
          uint64_t v140 = _StringGuts._convertedToSmall()(v137, v139);
          uint64_t v142 = v141;
          swift_bridgeObjectRelease(v139);
          uint64_t v143 = specialized _SmallString.init(_:appending:)(v130, v132, v140, v142);
          if ((v145 & 1) != 0)
          {
LABEL_249:
            uint64_t v219 = 266LL;
            goto LABEL_251;
          }

          uint64_t v146 = v143;
          uint64_t v147 = v144;
          swift_bridgeObjectRelease(v78);
          swift_bridgeObjectRelease(v14);
          uint64_t v233 = v146;
          uint64_t v234 = v147;
LABEL_176:
          __swift_destroy_boxed_opaque_existential_1Tm(v226);
          return v233;
        }

        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v77, v76);
        swift_bridgeObjectRelease_n(v14, 4LL);
        if ((v14 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v14);
          uint64_t v81 = v13;
          uint64_t v82 = v14;
          uint64_t v83 = v20;
          goto LABEL_159;
        }

        if (v31)
        {
          swift_bridgeObjectRelease_n(v14, 2LL);
          uint64_t v60 = (v14 >> 62) & 1;
          *(void *)&unint64_t v229 = v13;
          *((void *)&v229 + 1) = v14 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v85 = v16;
          uint64_t v86 = v16;
          goto LABEL_123;
        }

                  uint64_t v55 = (v104 - 1) & v104;
                  BOOL v102 = __clz(__rbit64(v104)) + (v105 << 6);
                  uint64_t v126 = v105;
                }

                (*(void (**)(char *, unint64_t, uint64_t *))(v8 + 16))( v34,  *(void *)(v56 + 48) + *(void *)(v8 + 72) * v102,  a2);
LABEL_92:
                unint64_t v97 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
              }
            }

    swift_bridgeObjectRelease((uint64_t)v20);
    $defer #1 <A>() in Array.init(_unsafeUninitializedCapacity:initializingWith:)( &v125,  v110,  &v127,  &v126,  &v129,  v117);
    swift_bridgeObjectRelease(v129);
    return;
  }

  if (v13 < 0) {
LABEL_106:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  unint64_t v127 = 0LL;
  uint64_t v128 = v13;
  if (v13) {
    goto LABEL_88;
  }
}

LABEL_74:
      char v31 = (char *)v45;
      uint64_t v32 = v48;
      if ((a1 & 0x1000000000000000LL) == 0) {
        char v31 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
      }
      if (v30 + 1 == v32) {
        goto LABEL_96;
      }
      if (!v31) {
        goto LABEL_126;
      }
      int v33 = *(unsigned __int16 *)&v31[v30];
LABEL_94:
      if (v33 != 2573 && (v33 & 0x80808080) == 0) {
        goto LABEL_96;
      }
LABEL_98:
      Swift::Int v38 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v30);
      if (v38 > 63) {
        goto LABEL_10;
      }
      goto LABEL_97;
    }

                uint64_t v80 = _StringGuts.nativeUnusedCapacity.getter(v72, v71);
                uint64_t v83 = (v81 & 1) == 0 && v80 >= v66;
                if ((v72 & ~v71 & 0x2000000000000000LL) != 0
                  && swift_isUniquelyReferenced_nonNull_native(v71 & 0xFFFFFFFFFFFFFFFLL))
                {
                  Swift::String::Index v9 = v239;
                  if (v83) {
                    goto LABEL_105;
                  }
LABEL_98:
                  BOOL v102 = _StringGuts.nativeCapacity.getter(v72, v71);
                  if ((v103 & 1) != 0) {
                    uint64_t v104 = 0LL;
                  }
                  else {
                    uint64_t v104 = v102;
                  }
                  if (v104 + 0x4000000000000000LL < 0)
                  {
                    __break(1u);
LABEL_261:
                    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
                  }

                  uint64_t v105 = 2 * v104;
                  if (v105 > v70) {
                    uint64_t v70 = v105;
                  }
                }

                else
                {
                  Swift::String::Index v9 = v239;
                  if (!v83) {
                    goto LABEL_98;
                  }
                }

                _StringGuts.grow(_:)(v70);
LABEL_105:
                swift_bridgeObjectRelease_n(v62, 4LL);
                if ((v62 & 0x1000000000000000LL) != 0)
                {
                  swift_bridgeObjectRelease(v62);
                  _StringGuts._foreignAppendInPlace(_:)(v61, v62, 0LL, v235);
                  swift_bridgeObjectRelease(v62);
                  uint64_t v7 = v236;
                }

                else if (v63)
                {
                  swift_bridgeObjectRelease_n(v62, 2LL);
                  *(void *)&uint64_t v241 = v61;
                  *((void *)&v241 + 1) = v62 & 0xFFFFFFFFFFFFFFLL;
                  uint64_t v106 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v64, (uint64_t)&v241, v64);
                  _StringGuts.appendInPlace(_:isASCII:)(v106, v107, (v62 & 0x4000000000000000LL) != 0);
                  uint64_t v7 = v236;
                }

                else
                {
                  if ((v61 & 0x1000000000000000LL) != 0)
                  {
                    swift_bridgeObjectRelease(v62);
                    uint64_t v126 = (id)((v62 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    unint64_t v127 = v61 & 0xFFFFFFFFFFFFLL;
                  }

                  else
                  {
                    uint64_t v126 = _StringObject.sharedUTF8.getter(v61, v62);
                    unint64_t v127 = v177;
                    swift_bridgeObjectRelease(v62);
                    if (v127 < (v61 & 0xFFFFFFFFFFFFLL)) {
                      goto LABEL_259;
                    }
                  }

                  uint64_t v7 = v236;
                  uint64_t v128 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v61 & 0xFFFFFFFFFFFFLL,  (uint64_t)v126,  v127);
                  _StringGuts.appendInPlace(_:isASCII:)(v128, v129, v61 < 0);
                  swift_bridgeObjectRelease(v62);
                }

        goto LABEL_7;
      }
    }

    else
    {
      uint64_t v20 = byte_18180BE40[(char)v21];
      if (v18 == 1) {
        goto LABEL_72;
      }
    }

      if (v14 < v12 && *(_BYTE *)(v15 + v14) == 79)
      {
        *((void *)a1 + 9) = ++v14;
        v22 |= 0x200u;
      }

      if (v14 < v12 && *(_BYTE *)(v15 + v14) == 88)
      {
        *((void *)a1 + 9) = v14 + 1;
        v22 |= 0x100u;
      }

      uint64_t v23 = v22;
      uint64_t v17 = (v7 + 31) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v17 || v17 + 24 > v8) {
        goto LABEL_89;
      }
      goto LABEL_92;
    case 'g':
      if (v14 < v12 && *(_BYTE *)(v15 + v14) == 88)
      {
        *((void *)a1 + 9) = v13 + 2;
        uint64_t v23 = 384LL;
      }

      else
      {
        uint64_t v23 = 128LL;
      }

      goto LABEL_84;
    case 'i':
      uint64_t v17 = (v7 + 31) & 0xFFFFFFFFFFFFFFF8LL;
      if (v17) {
        uint64_t v24 = v17 + 24 > v8;
      }
      else {
        uint64_t v24 = 1;
      }
      if (v24)
      {
        uint64_t v25 = 2LL * *((void *)a1 + 4);
        if (v25 <= 0x20) {
          uint64_t v25 = 32LL;
        }
        *((void *)a1 + 4) = v25;
        char v26 = v25 + 8;
        uint64_t v27 = malloc(v25 + 8);
        *uint64_t v27 = *((void *)a1 + 3);
        uint64_t v17 = ((unint64_t)v27 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)a1 + 2) = (char *)v27 + v26;
        *((void *)a1 + 3) = v27;
      }

      *((void *)a1 + 1) = v17 + 24;
      *(_WORD *)(v17 + 16) = 80;
      *(_BYTE *)(v17 + 18) = 4;
      *(void *)uint64_t v17 = 6LL;
      break;
    case 'n':
      return result;
    case 'o':
      if (v14 < v12 && *(_BYTE *)(v15 + v14) == 88)
      {
        *((void *)a1 + 9) = v13 + 2;
        uint64_t v23 = 768LL;
      }

      else
      {
        uint64_t v23 = 512LL;
      }

    Swift::Int v30 = 0LL;
LABEL_79:
    uint64_t v19 = v12 + 1;
    LODWORD(v11) = *((unsigned __int8 *)v5 + 18);
    ++v12;
  }

  if ((v11 - 1) >= 2)
  {
    uint64_t v32 = 0;
    int v33 = *(swift::Demangle::__runtime::Node **)v5;
  }

  else
  {
    uint64_t v32 = 1;
    int v33 = v5;
  }

  if (*(_WORD *)(*((void *)v33 + v19) + 16LL) == 272) {
    goto LABEL_87;
  }
  Swift::UInt64 v34 = v5;
  if ((v32 & 1) == 0) {
    Swift::UInt64 v34 = *(swift::Demangle::__runtime::Node **)v5;
  }
  if (*(_WORD *)(*((void *)v34 + v19) + 16LL) == 273)
  {
LABEL_87:
    if ((_DWORD)v11 == 1)
    {
      if (!v19) {
        goto LABEL_97;
      }
    }

    else
    {
      if ((_DWORD)v11 != 5)
      {
        if ((_DWORD)v11 != 2 || v19 >= 2) {
          goto LABEL_95;
        }
LABEL_97:
        int v37 = v5;
        if ((v32 & 1) == 0) {
          int v37 = *(swift::Demangle::__runtime::Node **)v5;
        }
        uint64_t v35 = (swift::Demangle::__runtime::Node *)*((void *)v37 + v19);
LABEL_100:
        uint64_t v19 = ++v12;
        uint64_t v36 = v5;
        if ((v32 & 1) != 0) {
          goto LABEL_102;
        }
        goto LABEL_101;
      }
    }

        uint64_t v32 = 1570;
        char v31 = 14;
        goto LABEL_194;
      }

      this = memcmp((const void *)this, "u16", 3uLL);
      if ((_DWORD)this) {
        goto LABEL_74;
      }
      this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<((char **)(v4 + 12728), 119);
LABEL_61:
      char v31 = 0;
      uint64_t v3 = 0LL;
      uint64_t v32 = 0;
      goto LABEL_194;
    case 5:
      uint64_t v18 = *(_DWORD *)(this + 12736);
      uint64_t v48 = *(unsigned int *)(this + 12740);
      uint64_t v20 = *(char **)(this + 12728);
      unint64_t v49 = *(void **)(this + 12744);
      uint64_t v50 = (char *)v49[1];
      if (&v20[v48] == v50)
      {
        uint64_t v80 = (unint64_t)&v20[v48 + 1];
        uint64_t v51 = v49[2];
        if (v80 <= v51)
        {
          v49[1] = v80;
          LODWORD(v81) = 1;
          goto LABEL_103;
        }
      }

      else
      {
        uint64_t v51 = v49[2];
      }

      else {
        uint64_t v81 = (2 * v48);
      }
      uint64_t v82 = v81 + v48;
      if (!v50 || (unint64_t)&v50[v82] > v51)
      {
        uint64_t v83 = 2LL * v49[4];
        if (v83 <= v82 + 1) {
          uint64_t v83 = v82 + 1;
        }
        v49[4] = v83;
        uint64_t v84 = v83 + 8;
        this = (uint64_t)malloc(v83 + 8);
        uint64_t v85 = this + v84;
        *(void *)this = v49[3];
        uint64_t v50 = (char *)(this + 8);
        v49[2] = v85;
        v49[3] = this;
      }

      v49[1] = &v50[v82];
      if ((_DWORD)v48)
      {
        this = (uint64_t)memcpy(v50, *(const void **)(v4 + 12728), v48);
        LODWORD(v48) = *(_DWORD *)(v4 + 12740);
        uint64_t v18 = *(_DWORD *)(v4 + 12736);
      }

      *(void *)(v4 + 12728) = v50;
      uint64_t v20 = v50;
LABEL_103:
      *(_DWORD *)(v4 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v48 + v81;
LABEL_104:
      char v31 = 0;
      uint64_t v3 = 0LL;
      uint64_t v32 = 0;
      *(_DWORD *)(v4 + 12736) = v18 + 1;
      uint64_t v79 = 99;
      goto LABEL_193;
    case 6:
      uint64_t v18 = *(_DWORD *)(this + 12736);
      uint64_t v52 = *(unsigned int *)(this + 12740);
      uint64_t v20 = *(char **)(this + 12728);
      uint64_t v53 = *(void **)(this + 12744);
      uint64_t v54 = (char *)v53[1];
      if (&v20[v52] == v54)
      {
        uint64_t v86 = (unint64_t)&v20[v52 + 1];
        uint64_t v55 = v53[2];
        if (v86 <= v55)
        {
          v53[1] = v86;
          LODWORD(v87) = 1;
          goto LABEL_117;
        }
      }

      else
      {
        uint64_t v55 = v53[2];
      }

      else {
        Swift::Int v87 = (2 * v52);
      }
      uint64_t v88 = v87 + v52;
      if (!v54 || (unint64_t)&v54[v88] > v55)
      {
        uint64_t v89 = 2LL * v53[4];
        if (v89 <= v88 + 1) {
          uint64_t v89 = v88 + 1;
        }
        v53[4] = v89;
        uint64_t v90 = v89 + 8;
        this = (uint64_t)malloc(v89 + 8);
        uint64_t v91 = this + v90;
        *(void *)this = v53[3];
        uint64_t v54 = (char *)(this + 8);
        v53[2] = v91;
        v53[3] = this;
      }

      v53[1] = &v54[v88];
      if ((_DWORD)v52)
      {
        this = (uint64_t)memcpy(v54, *(const void **)(v4 + 12728), v52);
        LODWORD(v52) = *(_DWORD *)(v4 + 12740);
        uint64_t v18 = *(_DWORD *)(v4 + 12736);
      }

      *(void *)(v4 + 12728) = v54;
      uint64_t v20 = v54;
LABEL_117:
      *(_DWORD *)(v4 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v52 + v87;
LABEL_118:
      char v31 = 0;
      uint64_t v3 = 0LL;
      uint64_t v32 = 0;
      *(_DWORD *)(v4 + 12736) = v18 + 1;
      uint64_t v79 = 105;
      goto LABEL_193;
    case 7:
      uint64_t v18 = *(_DWORD *)(this + 12736);
      uint64_t v56 = *(unsigned int *)(this + 12740);
      uint64_t v20 = *(char **)(this + 12728);
      uint64_t v57 = *(void **)(this + 12744);
      uint64_t v58 = (char *)v57[1];
      if (&v20[v56] == v58)
      {
        unint64_t v92 = (unint64_t)&v20[v56 + 1];
        uint64_t v59 = v57[2];
        if (v92 <= v59)
        {
          v57[1] = v92;
          LODWORD(v93) = 1;
          goto LABEL_131;
        }
      }

      else
      {
        uint64_t v59 = v57[2];
      }

      else {
        uint64_t v93 = (2 * v56);
      }
      uint64_t v94 = v93 + v56;
      if (!v58 || (unint64_t)&v58[v94] > v59)
      {
        uint64_t v95 = 2LL * v57[4];
        if (v95 <= v94 + 1) {
          uint64_t v95 = v94 + 1;
        }
        v57[4] = v95;
        uint64_t v96 = v95 + 8;
        this = (uint64_t)malloc(v95 + 8);
        unint64_t v97 = this + v96;
        *(void *)this = v57[3];
        uint64_t v58 = (char *)(this + 8);
        v57[2] = v97;
        v57[3] = this;
      }

      v57[1] = &v58[v94];
      if ((_DWORD)v56)
      {
        this = (uint64_t)memcpy(v58, *(const void **)(v4 + 12728), v56);
        LODWORD(v56) = *(_DWORD *)(v4 + 12740);
        uint64_t v18 = *(_DWORD *)(v4 + 12736);
      }

      *(void *)(v4 + 12728) = v58;
      uint64_t v20 = v58;
LABEL_131:
      *(_DWORD *)(v4 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v56 + v93;
LABEL_132:
      char v31 = 0;
      uint64_t v3 = 0LL;
      uint64_t v32 = 0;
      *(_DWORD *)(v4 + 12736) = v18 + 1;
      uint64_t v79 = 115;
      goto LABEL_193;
    case 8:
      uint64_t v18 = *(_DWORD *)(this + 12736);
      uint64_t v60 = *(unsigned int *)(this + 12740);
      uint64_t v20 = *(char **)(this + 12728);
      uint64_t v61 = *(void **)(this + 12744);
      uint64_t v62 = (char *)v61[1];
      if (&v20[v60] == v62)
      {
        uint64_t v98 = (unint64_t)&v20[v60 + 1];
        uint64_t v63 = v61[2];
        if (v98 <= v63)
        {
          v61[1] = v98;
          LODWORD(v99) = 1;
          goto LABEL_145;
        }
      }

      else
      {
        uint64_t v63 = v61[2];
      }

      else {
        uint64_t v99 = (2 * v60);
      }
      uint64_t v100 = v99 + v60;
      if (!v62 || (unint64_t)&v62[v100] > v63)
      {
        unint64_t v101 = 2LL * v61[4];
        if (v101 <= v100 + 1) {
          unint64_t v101 = v100 + 1;
        }
        v61[4] = v101;
        BOOL v102 = v101 + 8;
        this = (uint64_t)malloc(v101 + 8);
        uint64_t v103 = this + v102;
        *(void *)this = v61[3];
        uint64_t v62 = (char *)(this + 8);
        v61[2] = v103;
        v61[3] = this;
      }

      v61[1] = &v62[v100];
      if ((_DWORD)v60)
      {
        this = (uint64_t)memcpy(v62, *(const void **)(v4 + 12728), v60);
        LODWORD(v6swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = *(_DWORD *)(v4 + 12740);
        uint64_t v18 = *(_DWORD *)(v4 + 12736);
      }

      *(void *)(v4 + 12728) = v62;
      uint64_t v20 = v62;
LABEL_145:
      *(_DWORD *)(v4 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v60 + v99;
LABEL_146:
      char v31 = 0;
      uint64_t v3 = 0LL;
      uint64_t v32 = 0;
      *(_DWORD *)(v4 + 12736) = v18 + 1;
      uint64_t v79 = 114;
      goto LABEL_193;
    case 9:
      Swift::String::Index v9 = (char **)(this + 12728);
      uint64_t v10 = *(void **)(v4 + 12744);
      BOOL v11 = "pk";
LABEL_59:
      int v37 = 2LL;
LABEL_60:
      this = (uint64_t)swift::Demangle::__runtime::CharVector::append(v9, v11, v37, v10);
      goto LABEL_61;
    default:
      if (v8 == 256)
      {
        uint64_t v18 = *(_DWORD *)(this + 12736);
        uint64_t v19 = *(unsigned int *)(this + 12740);
        uint64_t v20 = *(char **)(this + 12728);
        if (v18 < v19)
        {
LABEL_90:
          char v31 = 0;
          uint64_t v3 = 0LL;
          uint64_t v32 = 0;
          *(_DWORD *)(v4 + 12736) = v18 + 1;
          uint64_t v79 = 120;
          goto LABEL_193;
        }

        int v21 = *(void **)(this + 12744);
        int v22 = (char *)v21[1];
        if (&v20[v19] == v22)
        {
          char v73 = (unint64_t)&v20[v19 + 1];
          uint64_t v23 = v21[2];
          if (v73 <= v23)
          {
            v21[1] = v73;
            LODWORD(v74) = 1;
LABEL_89:
            *(_DWORD *)(v4 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v19 + v74;
            goto LABEL_90;
          }
        }

        else
        {
          uint64_t v23 = v21[2];
        }

        else {
          char v74 = (2 * v19);
        }
        uint64_t v75 = v74 + v19;
        if (!v22 || (unint64_t)&v22[v75] > v23)
        {
          uint64_t v76 = 2LL * v21[4];
          if (v76 <= v75 + 1) {
            uint64_t v76 = v75 + 1;
          }
          v21[4] = v76;
          uint64_t v77 = v76 + 8;
          this = (uint64_t)malloc(v76 + 8);
          uint64_t v78 = this + v77;
          *(void *)this = v21[3];
          int v22 = (char *)(this + 8);
          _OWORD v21[2] = v78;
          v21[3] = this;
        }

        v21[1] = &v22[v75];
        if ((_DWORD)v19)
        {
          this = (uint64_t)memcpy(v22, *(const void **)(v4 + 12728), v19);
          LODWORD(v19) = *(_DWORD *)(v4 + 12740);
          uint64_t v18 = *(_DWORD *)(v4 + 12736);
        }

        *(void *)(v4 + 12728) = v22;
        uint64_t v20 = v22;
        goto LABEL_89;
      }

      if ((v8 & 0x400) != 0)
      {
        uint64_t v66 = (char **)(this + 12728);
        uint64_t v67 = *(_DWORD *)(this + 12736);
        uint64_t v68 = *(unsigned int *)(this + 12740);
        uint64_t v69 = *(char **)(this + 12728);
        uint64_t v70 = *(void **)(this + 12744);
        uint64_t v71 = (char *)v70[1];
        if (&v69[v68] == v71)
        {
          uint64_t v104 = (unint64_t)&v69[v68 + 1];
          uint64_t v72 = v70[2];
          if (v104 <= v72)
          {
            v70[1] = v104;
            LODWORD(v105) = 1;
LABEL_160:
            *(_DWORD *)(v4 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v68 + v105;
LABEL_161:
            *(_DWORD *)(v4 + 12736) = v67 + 1;
            v69[v67] = 101;
            if ((v8 & 0x40) != 0)
            {
              this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<((char **)(v4 + 12728), 68);
              if ((v8 & 0x80) == 0) {
                goto LABEL_163;
              }
            }

            else if ((v8 & 0x80) == 0)
            {
              goto LABEL_163;
            }

            this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<((char **)(v4 + 12728), 71);
            if ((v8 & 0x200) == 0) {
              goto LABEL_169;
            }
            goto LABEL_167;
          }
        }

        else
        {
          uint64_t v72 = v70[2];
        }

        else {
          uint64_t v105 = (2 * v68);
        }
        uint64_t v106 = v105 + v68;
        if (!v71 || (unint64_t)&v71[v106] > v72)
        {
          uint64_t v107 = 2LL * v70[4];
          if (v107 <= v106 + 1) {
            uint64_t v107 = v106 + 1;
          }
          v70[4] = v107;
          uint64_t v108 = v107 + 8;
          this = (uint64_t)malloc(v107 + 8);
          uint64_t v109 = this + v108;
          *(void *)this = v70[3];
          uint64_t v71 = (char *)(this + 8);
          v70[2] = v109;
          v70[3] = this;
        }

        v70[1] = &v71[v106];
        if ((_DWORD)v68)
        {
          this = (uint64_t)memcpy(v71, *(const void **)(v4 + 12728), v68);
          LODWORD(v68) = *(_DWORD *)(v4 + 12740);
          uint64_t v67 = *(_DWORD *)(v4 + 12736);
        }

        *uint64_t v66 = v71;
        uint64_t v69 = v71;
        goto LABEL_160;
      }

      if ((v8 & 0x40) != 0)
      {
        uint64_t v66 = (char **)(this + 12728);
        this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<((char **)(this + 12728), 100);
        if ((v8 & 0x80) != 0) {
          this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<((char **)(v4 + 12728), 71);
        }
LABEL_163:
        if ((v8 & 0x200) == 0) {
          goto LABEL_169;
        }
LABEL_167:
        uint64_t v64 = v66;
        uint64_t v65 = 79;
        goto LABEL_168;
      }

      if ((v8 & 0x80) != 0)
      {
        uint64_t v64 = (char **)(this + 12728);
        uint64_t v65 = 103;
      }

      else
      {
        if ((v8 & 0x200) == 0) {
          goto LABEL_169;
        }
        uint64_t v64 = (char **)(this + 12728);
        uint64_t v65 = 111;
      }

  *(_DWORD *)(v4 + 12736) = v34 + 1;
  v36[v34] = a4;
  return this;
}

uint64_t Collection.firstIndex(where:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v8 = a3;
  uint64_t v48 = a1;
  uint64_t v49 = a2;
  uint64_t v39 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v46 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v47 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v45 = (char *)&v38 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v40 = *(void *)(v11 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  int64_t v14 = (char *)&v38 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v38 - v15;
  (*(void (**)(uint64_t, uint64_t))(a4 + 64))(v8, a4);
  uint64_t v51 = *(void (**)(uint64_t, uint64_t))(a4 + 72);
  uint64_t v17 = *(void *)(swift_getAssociatedConformanceWitness( a4,  v8,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v18 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v17 + 8);
  v51(v8, a4);
  uint64_t v42 = v18;
  uint64_t v43 = v17;
  char v19 = v18(v16, v14, v11, v17);
  uint64_t v20 = *(void (**)(char *, unint64_t))(v40 + 8);
  uint64_t v44 = v14;
  uint64_t v50 = v20;
  v20(v14, v11);
  if ((v19 & 1) != 0)
  {
LABEL_6:
    v50(v16, v11);
    uint64_t v34 = 1LL;
    uint64_t v35 = v39;
    uint64_t v36 = v40;
  }

  else
  {
    Swift::String v41 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a4 + 80);
    while (1)
    {
      unint64_t v21 = v11;
      int v22 = v16;
      uint64_t v23 = v6;
      uint64_t v24 = v8;
      uint64_t v25 = (void (*)(_BYTE *, void))v41(v52, v16, v8, a4);
      uint64_t v27 = v45;
      uint64_t v26 = v46;
      unint64_t v28 = v47;
      (*(void (**)(char *))(v46 + 16))(v45);
      v25(v52, 0LL);
      uint64_t v29 = v53;
      char v30 = v48(v27);
      if (v29)
      {
        (*(void (**)(char *, unint64_t))(v26 + 8))(v27, v28);
        return ((uint64_t (*)(char *, unint64_t))v50)(v22, v21);
      }

      char v31 = v30;
      uint64_t v53 = 0LL;
      (*(void (**)(char *, unint64_t))(v26 + 8))(v27, v28);
      if ((v31 & 1) != 0) {
        break;
      }
      uint64_t v16 = v22;
      uint64_t v6 = v23;
      uint64_t v8 = v24;
      (*(void (**)(char *, uint64_t, uint64_t))(a4 + 192))(v22, v24, a4);
      uint64_t v32 = v44;
      v51(v24, a4);
      unint64_t v11 = v21;
      char v33 = v42(v16, v32, v21, v43);
      v50(v32, v21);
      if ((v33 & 1) != 0) {
        goto LABEL_6;
      }
    }

    uint64_t v35 = v39;
    uint64_t v36 = v40;
    unint64_t v11 = v21;
    (*(void (**)(uint64_t, char *, unint64_t))(v40 + 32))(v39, v22, v21);
    uint64_t v34 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v36 + 56))(v35, v34, 1LL, v11);
}

uint64_t BidirectionalCollection.last(where:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v21 = a5;
  uint64_t v11 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v11,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t v20 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v20 - v16;
  uint64_t result = BidirectionalCollection.lastIndex(where:)(a1, a2, a3, a4, (uint64_t)&v20 - v16);
  if (!v6)
  {
    MEMORY[0x1895F8858](result);
    *(&v20 - 4) = a3;
    *(&v20 - 3) = a4;
    *(&v20 - 2) = v5;
    unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    _sSq3mapyqd_0_Sgqd_0_xqd__YKXEqd__YKs5ErrorRd__Ri_d_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyxs5NeverOqd_0_Isgnrzr_xSgAb2ERsd__Ri_d_0_r_0_lIetMgnrzo_Tpq5( (void (*)(char *))partial apply for closure #1 in BidirectionalCollection.last(where:),  v15,  v19,  v21);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v17, v15);
  }

  return result;
}

uint64_t BidirectionalCollection.lastIndex(where:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v42 = a1;
  uint64_t v43 = a2;
  uint64_t v37 = a5;
  uint64_t v44 = a4;
  uint64_t v8 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v40 = (char *)&v37 - v11;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v48 = (char *)&v37 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = *(void (**)(uint64_t, uint64_t))(v8 + 72);
  uint64_t v49 = (char *)&v37 - v17;
  v16(a3, v8);
  unint64_t v47 = *(void (**)(uint64_t, uint64_t))(v8 + 64);
  uint64_t v18 = v8;
  unint64_t v50 = v12;
  uint64_t v46 = *(void *)(swift_getAssociatedConformanceWitness( v8,  a3,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v45 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v46 + 8);
  uint64_t v41 = v13;
  uint64_t v38 = v10;
  unint64_t v39 = AssociatedTypeWitness;
  while (1)
  {
    unint64_t v19 = v48;
    v47(a3, v18);
    uint64_t v20 = v6;
    int v22 = v49;
    unint64_t v21 = v50;
    char v23 = v45(v49, v19, v50, v46);
    uint64_t v24 = *(void (**)(char *, unint64_t))(v13 + 8);
    v24(v19, v21);
    if ((v23 & 1) != 0)
    {
      unint64_t v34 = v50;
      v24(v22, v50);
      uint64_t v35 = 1LL;
      uint64_t v33 = v37;
      uint64_t v13 = v41;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v13 + 56))(v33, v35, 1LL, v34);
    }

    (*(void (**)(char *, uint64_t))(v44 + 40))(v22, a3);
    uint64_t v25 = v22;
    uint64_t v6 = v20;
    uint64_t v26 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v18 + 80))( v51,  v25,  a3,  v18);
    uint64_t v28 = v38;
    unint64_t v27 = v39;
    uint64_t v29 = v40;
    (*(void (**)(char *))(v38 + 16))(v40);
    v26(v51, 0LL);
    uint64_t v30 = v52;
    char v31 = v42(v29);
    if (v30) {
      break;
    }
    char v32 = v31;
    uint64_t v52 = 0LL;
    (*(void (**)(char *, unint64_t))(v28 + 8))(v29, v27);
    uint64_t v13 = v41;
    if ((v32 & 1) != 0)
    {
      uint64_t v33 = v37;
      unint64_t v34 = v50;
      (*(void (**)(uint64_t, char *, unint64_t))(v41 + 32))(v37, v49, v50);
      uint64_t v35 = 0LL;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v13 + 56))(v33, v35, 1LL, v34);
    }
  }

  (*(void (**)(char *, unint64_t))(v28 + 8))(v29, v27);
  return ((uint64_t (*)(char *, unint64_t))v24)(v49, v50);
}

uint64_t closure #1 in BidirectionalCollection.last(where:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t v7 = (uint64_t (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v6 + 80))( v12,  a1,  a2,  v6);
  uint64_t v9 = v8;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v6 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a4,  v9,  AssociatedTypeWitness);
  return v7(v12, 0LL);
}

uint64_t BidirectionalCollection<>.lastIndex(of:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v31 = a4;
  uint64_t v32 = a5;
  uint64_t v29 = a3;
  uint64_t v7 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional((const char *)0xFF, AssociatedTypeWitness, v9, v10);
  uint64_t v14 = type metadata accessor for Optional(0LL, v11, v12, v13);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v28 - v17;
  uint64_t v19 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v16);
  unint64_t v21 = (char *)&v28 - v20;
  int v22 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 128);
  uint64_t v30 = a1;
  v22(a1, a2, v7);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v18, 1LL, v11) == 1)
  {
    uint64_t v23 = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v18, v14);
    MEMORY[0x1895F8858](v23);
    uint64_t v24 = v29;
    *(&v28 - 4) = a2;
    *(&v28 - 3) = v24;
    uint64_t v25 = v30;
    *(&v28 - 2) = v31;
    *(&v28 - 1) = v25;
    return BidirectionalCollection.lastIndex(where:)( (uint64_t (*)(char *))partial apply for closure #1 in BidirectionalCollection<>.lastIndex(of:),  (uint64_t)(&v28 - 6),  a2,  v24,  v32);
  }

  else
  {
    unint64_t v27 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
    v27(v21, v18, v11);
    return ((uint64_t (*)(uint64_t, char *, uint64_t))v27)(v32, v21, v11);
  }

void Collection.indices(where:)( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v203 = a1;
  uint64_t v204 = a2;
  uint64_t v167 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v213 = (char *)&v164 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  char v212 = (char *)&v164 - v11;
  uint64_t v222 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = (uint64_t *)type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v190 = *(v14 - 1);
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  uint64_t v172 = (char *)&v164 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v178 = (char *)&v164 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v210 = (char *)&v164 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v189 = (char *)&v164 - v21;
  unint64_t v202 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v185 = *(void *)(v202 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v202);
  unint64_t v177 = (char *)&v164 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v176 = (uint64_t)&v164 - v25;
  MEMORY[0x1895F8858](v24);
  id v188 = (char *)&v164 - v26;
  unint64_t v219 = AssociatedConformanceWitness;
  uint64_t v201 = type metadata accessor for PartialRangeFrom(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v27);
  uint64_t v187 = *(void *)(v201 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v201);
  uint64_t v183 = (char *)&v164 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v28);
  uint64_t v31 = (char *)&v164 - v30;
  uint64_t v166 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v32, v33);
  uint64_t v165 = *(void *)(v166 - 8);
  uint64_t v34 = MEMORY[0x1895F8858](v166);
  uint64_t v186 = (uint64_t)&v164 - v35;
  uint64_t v36 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  Swift::String::Index v171 = (char *)&v164 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v175 = (char *)&v164 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v174 = (char *)&v164 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  unint64_t v173 = (char *)&v164 - v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v182 = (char *)&v164 - v46;
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  uint64_t v181 = (char *)&v164 - v48;
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  uint64_t v180 = (char *)&v164 - v50;
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  unint64_t v179 = (char *)&v164 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  uint64_t v184 = (char *)&v164 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  unint64_t v193 = (char *)&v164 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  Swift::Bool v192 = (char *)&v164 - v58;
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  uint64_t v191 = (char *)&v164 - v60;
  uint64_t v61 = MEMORY[0x1895F8858](v59);
  uint64_t v63 = (char *)&v164 - v62;
  uint64_t v64 = MEMORY[0x1895F8858](v61);
  uint64_t v66 = (char *)&v164 - v65;
  uint64_t v67 = MEMORY[0x1895F8858](v64);
  char v194 = (char *)&v164 - v68;
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  unint64_t v200 = (char *)&v164 - v70;
  MEMORY[0x1895F8858](v69);
  uint64_t v72 = (char *)&v164 - v71;
  uint64_t v211 = v14;
  _swift_isClassOrObjCExistentialType((uint64_t)v14, v14);
  id v223 = &_swiftEmptyArrayStorage;
  char v73 = *(void (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v221 = a4;
  v73(v222, a4);
  uint64_t v205 = v36;
  uint64_t v215 = *(void (**)(void))(v36 + 16);
  uint64_t v217 = v5;
  uint64_t v170 = v31;
  unint64_t v169 = v63;
  uint64_t v168 = v66;
  uint64_t v209 = v72;
  while (1)
  {
    char v74 = v194;
    uint64_t v75 = v215;
    v215();
    ((void (*)(char *, char *, unint64_t))v75)(v66, v74, AssociatedTypeWitness);
    unint64_t v76 = v219;
    uint64_t v77 = *(uint64_t (**)(char *, char *, unint64_t, const char *))(*(void *)(v219 + 8) + 8LL);
    uint64_t v199 = *(const char **)(v219 + 8);
    char v198 = v77;
    if ((((uint64_t (*)(char *, char *, unint64_t))v77)(v66, v66, AssociatedTypeWitness) & 1) == 0) {
LABEL_20:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range cannot have an unordered lower bound.",  43LL,  2,  "Swift/Range.swift",  17LL,  2,  0x34FuLL,  0);
    uint64_t v78 = v205;
    uint64_t v220 = *(void (**)(char *, unint64_t))(v205 + 8);
    v220(v66, AssociatedTypeWitness);
    uint64_t v216 = *(void (**)(char *, char *, unint64_t))(v78 + 32);
    v216(v31, v74, AssociatedTypeWitness);
    ((void (*)(char *, char *, unint64_t))v75)(v63, v31, AssociatedTypeWitness);
    uint64_t v79 = v191;
    uint64_t v207 = *(void (**)(uint64_t))(v221 + 72);
    v207(v222);
    uint64_t v80 = v192;
    ((void (*)(char *, char *, unint64_t))v75)(v192, v63, AssociatedTypeWitness);
    uint64_t v81 = v63;
    uint64_t v82 = v79;
    uint64_t v83 = v193;
    ((void (*)(char *, char *, unint64_t))v75)(v193, v82, AssociatedTypeWitness);
    uint64_t v208 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v76 + 24);
    if ((v208(v80, v83, AssociatedTypeWitness, v76) & 1) == 0) {
      goto LABEL_19;
    }
    uint64_t v84 = v220;
    v220(v83, AssociatedTypeWitness);
    v84(v80, AssociatedTypeWitness);
    BOOL v196 = *(void (**)(char *, uint64_t))(v187 + 8);
    v196(v31, v201);
    uint64_t v85 = TupleTypeMetadata2;
    uint64_t v86 = v212;
    Swift::Int v87 = &v212[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v88 = v216;
    v216(v212, v81, AssociatedTypeWitness);
    uint64_t v206 = v87;
    v88(v87, v82, AssociatedTypeWitness);
    uint64_t v89 = v213;
    uint64_t v90 = &v213[*((int *)v85 + 12)];
    ((void (*)(char *, char *, unint64_t))v75)(v213, v86, AssociatedTypeWitness);
    ((void (*)(char *, char *, unint64_t))v75)(v90, v87, AssociatedTypeWitness);
    uint64_t v91 = v210;
    v88(v210, v89, AssociatedTypeWitness);
    v84(v90, AssociatedTypeWitness);
    unint64_t v92 = &v89[*((int *)v85 + 12)];
    v88(v89, v86, AssociatedTypeWitness);
    v88(v92, v206, AssociatedTypeWitness);
    uint64_t v93 = v211;
    v88(&v91[*((int *)v211 + 9)], v92, AssociatedTypeWitness);
    v84(v89, AssociatedTypeWitness);
    uint64_t v94 = v190;
    uint64_t v95 = v189;
    uint64_t v206 = *(char **)(v190 + 32);
    ((void (*)(char *, char *, uint64_t *))v206)(v189, v91, v93);
    uint64_t v96 = v221;
    unint64_t v97 = v188;
    Swift::Int v197 = *(void (**)(char *, uint64_t, uint64_t))(v221 + 88);
    v197(v95, v222, v221);
    uint64_t v195 = *(void (**)(char *, uint64_t *))(v94 + 8);
    v195(v95, v93);
    uint64_t v98 = v202;
    unint64_t v99 = swift_getAssociatedConformanceWitness( v96,  v222,  v202,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    uint64_t v100 = v186;
    uint64_t v101 = v218;
    Collection.firstIndex(where:)(v203, v204, v98, v99, v186);
    if (v101)
    {
      (*(void (**)(char *, uint64_t))(v185 + 8))(v97, v98);
      char v162 = v209;
LABEL_15:
      v220(v162, AssociatedTypeWitness);
      swift_bridgeObjectRelease((uint64_t)v223);
      return;
    }

    BOOL v102 = (void (*)(char *, uint64_t, unint64_t))v88;
    uint64_t v103 = (const char *)v99;
    uint64_t v104 = *(void (**)(char *, uint64_t))(v185 + 8);
    v104(v97, v98);
    if ((*(unsigned int (**)(uint64_t, uint64_t, unint64_t))(v205 + 48))( v100,  1LL,  AssociatedTypeWitness) == 1)
    {
      v220(v209, AssociatedTypeWitness);
      (*(void (**)(uint64_t, uint64_t))(v165 + 8))(v100, v166);
      uint64_t v161 = v219;
      goto LABEL_17;
    }

    uint64_t v218 = 0LL;
    uint64_t v105 = v200;
    v102(v200, v100, AssociatedTypeWitness);
    uint64_t v106 = v184;
    uint64_t v107 = v215;
    ((void (*)(char *, char *, unint64_t))v215)(v184, v105, AssociatedTypeWitness);
    if ((v198(v106, v106, AssociatedTypeWitness, v199) & 1) == 0) {
      goto LABEL_20;
    }
    char v198 = (uint64_t (*)(char *, char *, unint64_t, const char *))v104;
    uint64_t v199 = v103;
    uint64_t v108 = v220;
    v220(v106, AssociatedTypeWitness);
    v108(v209, AssociatedTypeWitness);
    uint64_t v109 = v183;
    ((void (*)(char *, char *, unint64_t))v107)(v183, v105, AssociatedTypeWitness);
    uint64_t v110 = v179;
    ((void (*)(char *, char *, unint64_t))v107)(v179, v109, AssociatedTypeWitness);
    uint64_t v111 = v180;
    ((void (*)(uint64_t, uint64_t))v207)(v222, v221);
    uint64_t v112 = v181;
    ((void (*)(char *, char *, unint64_t))v107)(v181, v110, AssociatedTypeWitness);
    BOOL v113 = v182;
    ((void (*)(char *, char *, unint64_t))v107)(v182, v111, AssociatedTypeWitness);
    if ((v208(v112, v113, AssociatedTypeWitness, v219) & 1) == 0) {
LABEL_19:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    v108(v113, AssociatedTypeWitness);
    v108(v112, AssociatedTypeWitness);
    v196(v109, v201);
    uint64_t v114 = TupleTypeMetadata2;
    uint64_t v115 = v110;
    uint64_t v116 = v212;
    uint64_t v117 = &v212[*((int *)TupleTypeMetadata2 + 12)];
    int v118 = v107;
    uint64_t v119 = v216;
    v216(v212, v115, AssociatedTypeWitness);
    v119(v117, v111, AssociatedTypeWitness);
    unint64_t v120 = v213;
    uint64_t v121 = &v213[*((int *)v114 + 12)];
    ((void (*)(char *, char *, unint64_t))v118)(v213, v116, AssociatedTypeWitness);
    ((void (*)(char *, char *, unint64_t))v118)(v121, v117, AssociatedTypeWitness);
    uint64_t v122 = v210;
    v119(v210, v120, AssociatedTypeWitness);
    v108(v121, AssociatedTypeWitness);
    uint64_t v123 = &v120[*((int *)v114 + 12)];
    v119(v120, v116, AssociatedTypeWitness);
    v119(v123, v117, AssociatedTypeWitness);
    uint64_t v124 = v211;
    v119(&v122[*((int *)v211 + 9)], v123, AssociatedTypeWitness);
    v108(v120, AssociatedTypeWitness);
    uint64_t v125 = v178;
    ((void (*)(char *, char *, uint64_t *))v206)(v178, v122, v124);
    v197(v125, v222, v221);
    uint64_t v126 = v125;
    uint64_t v127 = v202;
    v195(v126, v124);
    uint64_t v128 = v176;
    uint64_t v129 = v199;
    uint64_t v130 = v218;
    Collection.prefix(while:)(v203, v204, v127, v199, v176);
    if (v130)
    {
      char v162 = v200;
      goto LABEL_15;
    }

    uint64_t v218 = 0LL;
    uint64_t v131 = v209;
    (*((void (**)(uint64_t, const char *))v129 + 9))(v127, v129);
    ((void (*)(uint64_t, uint64_t))v198)(v128, v127);
    unint64_t v132 = v173;
    unint64_t v133 = v215;
    ((void (*)(char *, char *, unint64_t))v215)(v173, v131, AssociatedTypeWitness);
    uint64_t v134 = v174;
    char v135 = v200;
    ((void (*)(char *, char *, unint64_t))v133)(v174, v200, AssociatedTypeWitness);
    uint64_t v136 = v175;
    ((void (*)(char *, char *, unint64_t))v133)(v175, v132, AssociatedTypeWitness);
    if ((v208(v134, v136, AssociatedTypeWitness, v219) & 1) == 0) {
      goto LABEL_19;
    }
    uint64_t v137 = v136;
    unint64_t v138 = v220;
    v220(v137, AssociatedTypeWitness);
    v138(v134, AssociatedTypeWitness);
    uint64_t v139 = TupleTypeMetadata2;
    uint64_t v140 = v135;
    uint64_t v141 = v212;
    uint64_t v142 = &v212[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v143 = v216;
    v216(v212, v140, AssociatedTypeWitness);
    v143(v142, v132, AssociatedTypeWitness);
    uint64_t v144 = v213;
    uint64_t v145 = &v213[*((int *)v139 + 12)];
    ((void (*)(char *, char *, unint64_t))v133)(v213, v141, AssociatedTypeWitness);
    ((void (*)(char *, char *, unint64_t))v133)(v145, v142, AssociatedTypeWitness);
    uint64_t v146 = v210;
    v143(v210, v144, AssociatedTypeWitness);
    uint64_t v147 = v220;
    v220(v145, AssociatedTypeWitness);
    uint64_t v148 = &v144[*((int *)v139 + 12)];
    uint64_t v149 = v141;
    uint64_t v150 = v209;
    v143(v144, v149, AssociatedTypeWitness);
    v143(v148, v142, AssociatedTypeWitness);
    uint64_t v151 = (uint64_t)v211;
    v143(&v146[*((int *)v211 + 9)], v148, AssociatedTypeWitness);
    char v152 = v144;
    uint64_t v153 = v147;
    v147(v152, AssociatedTypeWitness);
    uint64_t v154 = (uint64_t)v172;
    ((void (*)(char *, char *, uint64_t))v206)(v172, v146, v151);
    uint64_t v157 = type metadata accessor for Array(0LL, v151, v155, v156);
    Array.append(_:)(v154, v157);
    uint64_t v158 = v171;
    uint64_t v159 = v221;
    uint64_t v160 = v222;
    ((void (*)(uint64_t, uint64_t))v207)(v222, v221);
    LOBYTE(v151) = (*(uint64_t (**)(char *, char *, unint64_t))(v219 + 16))( v150,  v158,  AssociatedTypeWitness);
    v153(v158, AssociatedTypeWitness);
    uint64_t v161 = v219;
    if ((v151 & 1) == 0) {
      break;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v159 + 192))(v150, v160, v159);
    uint64_t v31 = v170;
    uint64_t v63 = v169;
    uint64_t v66 = v168;
  }

  v153(v150, AssociatedTypeWitness);
LABEL_17:
  RangeSet.init(_orderedRanges:)((unint64_t)v223, AssociatedTypeWitness, v161, v163, v167);
}

uint64_t static Comparable.... postfix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return static Comparable.... postfix(_:)(a1, a2, a3, "Range cannot have an unordered lower bound.", 0x34FuLL, a4);
}

uint64_t specialized Collection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a3 < a1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }
  return 0LL;
}

uint64_t specialized Collection.subscript.getter(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 < result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (result < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x744uLL,  0);
  }
  return result;
}

uint64_t Collection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v18 - v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 24))(v5, a2, a4, a3, a5);
  (*(void (**)(char *, uint64_t, uint64_t))(a4 + 88))(v16, a2, a4);
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, v13);
}

void RangeSet.init(_orderedRanges:)( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v7 = (uint64_t *)type metadata accessor for Range(0LL, a2, a3, a4);
  uint64_t v8 = *(v7 - 1);
  uint64_t v9 = *(void *)(v8 + 64);
  MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v37 - v10;
  Swift::Int v12 = Array._getCount()();
  if (v12 == 1)
  {
    char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v7, v7);
    char v22 = ((a1 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
    Array._checkSubscript(_:wasNativeTypeChecked:)( 0LL,  (a1 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
    if ((v22 & 1) != 0)
    {
      uint64_t v23 = *(unsigned __int8 *)(v8 + 80);
      uint64_t v24 = (v23 + 32) & ~v23;
      (*(void (**)(char *, unint64_t, uint64_t *))(v8 + 16))(v11, a1 + v24, v7);
      swift_bridgeObjectRelease(a1);
    }

    else
    {
      id v35 = _ArrayBuffer._getElementSlowPath(_:)(0LL, a1, v7);
      if (v9 != 8)
      {
        swift_unknownObjectRelease(v35);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

      unint64_t v38 = (unint64_t)v35;
      uint64_t v36 = v35;
      (*(void (**)(char *, unint64_t *, uint64_t *))(v8 + 16))(v11, &v38, v7);
      swift_bridgeObjectRelease(a1);
      swift_unknownObjectRelease(v36);
      uint64_t v23 = *(unsigned __int8 *)(v8 + 80);
      uint64_t v24 = (v23 + 32) & ~v23;
    }

    uint64_t v27 = type metadata accessor for _ContiguousArrayStorage(0LL, (uint64_t)v7, v25, v26);
    a1 = (unint64_t)swift_allocObject(v27, v24 + *(void *)(v8 + 72), v23 | 7);
    uint64_t v28 = *(uint64_t **)(*(void *)a1 + 144LL);
    BOOL v29 = _swift_isClassOrObjCExistentialType((uint64_t)v28, v28);
    *(void *)(a1 + 16) = 1LL;
    *(void *)(a1 + 24) = v29 | 2LL;
    uint64_t v30 = *(unsigned __int8 *)(*(v28 - 1) + 80);
    (*(void (**)(unint64_t, char *, uint64_t *))(v8 + 32))(a1 + ((v30 + 32) & ~v30), v11, v7);
    uint64_t v16 = (const char *)_ArrayBuffer.requestNativeBuffer()(a1, v7);
    if (v16) {
      goto LABEL_12;
    }
    goto LABEL_8;
  }

  if (v12)
  {
    unint64_t v31 = swift_bridgeObjectRetain(a1, v13, v14, v15);
    uint64_t v19 = _ArrayBuffer.requestNativeBuffer()(v31, v7);
    swift_bridgeObjectRelease(a1);
    if (v19)
    {
LABEL_13:
      uint64_t v20 = (__objc2_class **)a1;
      goto LABEL_14;
    }

    unint64_t v38 = a1;
    uint64_t v16 = 0LL;
    goto LABEL_11;
  }

  swift_bridgeObjectRelease(a1);
  _swift_isClassOrObjCExistentialType((uint64_t)v7, v7);
  a1 = (unint64_t)&_swiftEmptyArrayStorage;
  uint64_t v16 = (const char *)_ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v7);
  if (!v16)
  {
LABEL_8:
    unint64_t v38 = a1;
LABEL_11:
    uint64_t v32 = type metadata accessor for Array(v16, (uint64_t)v7, v17, v18);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v32, v33);
    uint64_t v16 = (const char *)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v38, v32, WitnessTable);
LABEL_12:
    uint64_t v19 = (uint64_t)v16;
    goto LABEL_13;
  }

  uint64_t v19 = (uint64_t)v16;
  uint64_t v20 = &_swiftEmptyArrayStorage;
LABEL_14:
  swift_bridgeObjectRelease((uint64_t)v20);
  *a5 = v19;
}

void Collection<>.indices(of:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  v5[2] = a2;
  v5[3] = a3;
  v5[4] = a4;
  unint64_t v5[5] = a1;
  Collection.indices(where:)( (uint64_t (*)(char *))partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:),  (uint64_t)v5,  a2,  a3,  a5);
}

uint64_t MutableCollection.partition(by:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return MutableCollection._halfStablePartition(isSuffixElement:)(a1, a2, a3, a4, a5);
}

uint64_t MutableCollection._halfStablePartition(isSuffixElement:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v83 = a1;
  uint64_t v84 = a2;
  uint64_t v66 = a5;
  uint64_t v77 = a4;
  uint64_t v6 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v6 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v75 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v76 = AssociatedTypeWitness;
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v74 = (char *)&v65 - v9;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v65 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v65 - v14;
  unint64_t v16 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v70 = type metadata accessor for Optional(0LL, v16, v17, v18);
  uint64_t v71 = *(void (**)(void, void))(v70 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v70);
  uint64_t v21 = (char *)&v65 - v20;
  unint64_t v67 = v16;
  uint64_t v81 = *(void *)(v16 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v79 = (char *)&v65 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v78 = (char *)&v65 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v65 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v65 - v29;
  unint64_t v31 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v31(v15, v87, a3);
  uint64_t v80 = (void (*)(void, void, void))v21;
  uint64_t v89 = v6;
  uint64_t v32 = v86;
  Collection.firstIndex(where:)(v83, v84, a3, v6, (uint64_t)v21);
  uint64_t v33 = *(uint64_t (**)(char *, uint64_t))(v10 + 8);
  uint64_t result = v33(v15, a3);
  if (!v32)
  {
    id v35 = v71;
    uint64_t v85 = v33;
    uint64_t v72 = v31;
    uint64_t v82 = v28;
    uint64_t v68 = v30;
    uint64_t v73 = a3;
    uint64_t v36 = (char *)v80;
    uint64_t v37 = v67;
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v81 + 48))((char *)v80, 1LL, v67) == 1)
    {
      (*((void (**)(char *, uint64_t))v35 + 1))(v36, v70);
      uint64_t v38 = v73;
      v72(v13, v87, v73);
      (*(void (**)(uint64_t))(v89 + 72))(v38);
      return v85(v13, v38);
    }

    else
    {
      uint64_t v86 = 0LL;
      uint64_t v39 = v68;
      uint64_t v65 = *(uint64_t (**)(uint64_t, char *, uint64_t))(v81 + 32);
      v65((uint64_t)v68, v36, v37);
      uint64_t v40 = v87;
      uint64_t v41 = v72;
      uint64_t v42 = v73;
      v72(v13, v87, v73);
      uint64_t v43 = v89;
      uint64_t v44 = v82;
      (*(void (**)(char *, uint64_t, uint64_t))(v89 + 184))(v39, v42, v89);
      uint64_t v45 = (void (*)(char *, uint64_t))v85;
      v85(v13, v42);
      uint64_t v71 = *(void (**)(void, void))(v43 + 72);
      uint64_t v46 = v43;
      uint64_t v47 = v41;
      uint64_t v70 = *(void *)(swift_getAssociatedConformanceWitness( v46,  v42,  v37,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                      + 8);
      uint64_t v69 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v70 + 8);
      uint64_t v80 = *(void (**)(void, void, void))(v81 + 16);
      uint64_t v49 = v78;
      uint64_t v48 = v79;
      v80(v78, v44, v37);
      while (1)
      {
        v47(v13, v40, v42);
        uint64_t v50 = v49;
        uint64_t v51 = v44;
        v71(v42, v89);
        v45(v13, v42);
        char v52 = v69(v50, v48, v37, v70);
        uint64_t v53 = *(void (**)(char *, uint64_t))(v81 + 8);
        v53(v48, v37);
        v53(v50, v37);
        if ((v52 & 1) != 0)
        {
          v53(v44, v37);
          return v65(v66, v68, v37);
        }

        uint64_t v54 = v37;
        uint64_t v55 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t))(v89 + 80))( v88,  v51,  v42);
        uint64_t v57 = v74;
        uint64_t v56 = v75;
        unint64_t v58 = v76;
        (*(void (**)(char *))(v75 + 16))(v74);
        v55(v88, 0LL);
        uint64_t v59 = v86;
        char v60 = v83(v57);
        uint64_t v61 = v77;
        uint64_t v86 = v59;
        if (v59) {
          break;
        }
        char v62 = v60;
        (*(void (**)(char *, unint64_t))(v56 + 8))(v57, v58);
        uint64_t v37 = v54;
        uint64_t v47 = v72;
        uint64_t v42 = v73;
        uint64_t v49 = v78;
        if ((v62 & 1) == 0)
        {
          v80(v78, v82, v54);
          uint64_t v63 = v68;
          uint64_t v64 = v87;
          (*(void (**)(char *, char *, uint64_t, uint64_t))(v61 + 64))(v68, v49, v42, v61);
          v53(v49, v37);
          v47(v13, v64, v42);
          (*(void (**)(char *, uint64_t))(v89 + 192))(v63, v42);
          v85(v13, v42);
        }

        uint64_t v40 = v87;
        v47(v13, v87, v42);
        uint64_t v44 = v82;
        (*(void (**)(char *, uint64_t))(v89 + 192))(v82, v42);
        uint64_t v45 = (void (*)(char *, uint64_t))v85;
        v85(v13, v42);
        uint64_t v48 = v79;
        v80(v49, v44, v37);
      }

      (*(void (**)(char *, unint64_t))(v56 + 8))(v57, v58);
      v53(v82, v54);
      return ((uint64_t (*)(char *, uint64_t))v53)(v68, v54);
    }
  }

  return result;
}

uint64_t closure #1 in MutableCollection<>.partition(by:)@<X0>( uint64_t (*a1)(char *)@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(*(void *)(a4 + 8) + 8LL),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v12 = type metadata accessor for UnsafeMutableBufferPointer(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v12, v13);
  uint64_t v16 = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v12, v15);
  uint64_t result = MutableCollection<>._partitionImpl(by:)(a1, a2, v12, WitnessTable, v16, (uint64_t)&v18);
  if (!v5) {
    *a5 = v18;
  }
  return result;
}

unint64_t specialized MutableCollection<>._partitionImpl(by:)(uint64_t (*a1)(char *))
{
  unint64_t v3 = v1[1];
  uint64_t v4 = HIBYTE(v3) & 0xF;
  if (!v4) {
    return 0LL;
  }
  unint64_t v6 = 0LL;
  unint64_t v7 = *v1;
  do
  {
    if (v6 >= 8) {
      unint64_t v8 = v3;
    }
    else {
      unint64_t v8 = v7;
    }
    char v22 = v8 >> (8 * (v6 & 7u));
    char v9 = a1(&v22);
    if (v2) {
      break;
    }
    uint64_t v10 = HIBYTE(v3) & 0xF;
    if ((v9 & 1) != 0)
    {
      unint64_t v19 = v7;
      uint64_t v20 = a1;
      char v11 = 8 * v4 + 56;
      uint64_t v12 = v4;
      do
      {
        uint64_t v13 = v12 - 1;
        if (v12 < 1 || v4 > v10) {
          goto LABEL_25;
        }
        BOOL v14 = (unint64_t)v12 >= 9;
        else {
          char v15 = v11 - 64;
        }
        unint64_t v16 = v19;
        if (v14) {
          unint64_t v16 = v3;
        }
        char v21 = v16 >> (v15 & 0x38);
        char v17 = v20(&v21);
        v11 -= 8;
        uint64_t v12 = v13;
      }

      while ((v17 & 1) != 0);
      specialized MutableCollection.swapAt(_:_:)(v6, v13);
      unint64_t v3 = v1[1];
      if (v6 >= (HIBYTE(v3) & 0xF)) {
LABEL_25:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
      uint64_t v4 = v13;
      unint64_t v7 = *v1;
      a1 = v20;
    }

    else if (v6 >= v10)
    {
      goto LABEL_25;
    }

    ++v6;
  }

  while ((uint64_t)v6 < v4);
  return v6;
}

uint64_t specialized MutableCollection<>._partitionImpl(by:)(uint64_t (*a1)(char *))
{
  uint64_t v3 = v1[1];
  if (v3 < 1) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  uint64_t v6 = *v1;
  uint64_t v7 = v1[1];
  do
  {
    if (v5 == v3) {
LABEL_17:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x207uLL,  0);
    char v15 = *(_BYTE *)(v6 + v5);
    char v8 = a1(&v15);
    if (v2) {
      break;
    }
    if ((v8 & 1) != 0)
    {
      uint64_t v9 = v7;
      while (1)
      {
        uint64_t v10 = v9 - 1;
        if (v5 >= v9 - 1) {
          return v5;
        }
        if (v7 > v3) {
          goto LABEL_17;
        }
        char v14 = *(_BYTE *)(v6 + v9 - 1);
        char v11 = a1(&v14);
        uint64_t v9 = v10;
        if ((v11 & 1) == 0)
        {
          char v12 = *(_BYTE *)(v6 + v5);
          *(_BYTE *)(v6 + v5) = *(_BYTE *)(v6 + v10);
          *(_BYTE *)(v6 + v1swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v12;
          uint64_t v7 = v10;
          goto LABEL_13;
        }
      }
    }

    uint64_t v10 = v7;
LABEL_13:
    ++v5;
  }

  while (v5 < v10);
  return v5;
}

Swift::Int specialized MutableCollection<>._partitionImpl(by:)(uint64_t (*a1)(char *))
{
  uint64_t v3 = *v1;
  if (!*v1) {
    return 0LL;
  }
  uint64_t v4 = v1[1];
  Swift::Int v5 = v4 - v3;
  if (v4 - v3 < 1) {
    return 0LL;
  }
  Swift::Int v7 = 0LL;
  Swift::Int v8 = v4 - v3;
  do
  {
    if (v7 == v5) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xBCuLL,  0);
    }
    char v15 = *(_BYTE *)(v3 + v7);
    char v9 = a1(&v15);
    if (v2) {
      break;
    }
    if ((v9 & 1) != 0)
    {
      Swift::Int v10 = v8;
      while (1)
      {
        if (v8 > v5) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
        }
        Swift::Int v11 = v10 - 1;
        if (v7 >= v10 - 1) {
          return v7;
        }
        char v14 = *(_BYTE *)(v3 - 1 + v10);
        char v12 = a1(&v14);
        Swift::Int v10 = v11;
        if ((v12 & 1) == 0)
        {
          UnsafeMutableRawBufferPointer.swapAt(_:_:)(v7, v11);
          Swift::Int v8 = v11;
          goto LABEL_14;
        }
      }
    }

    Swift::Int v11 = v8;
LABEL_14:
    ++v7;
  }

  while (v7 < v11);
  return v7;
}

uint64_t MutableCollection<>._partitionImpl(by:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8 = v7;
  uint64_t v9 = v6;
  uint64_t v72 = a5;
  uint64_t v10 = a3;
  uint64_t v91 = a1;
  uint64_t v92 = a2;
  uint64_t v75 = a6;
  uint64_t v85 = a4;
  uint64_t v11 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v74 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v78 = (char *)&v70 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v73 = (char *)&v70 - v15;
  uint64_t v16 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v70 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v84 = *(void *)(v19 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  uint64_t v71 = (char *)&v70 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v82 = (char *)&v70 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v95 = (char *)&v70 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v27 = (char *)&v70 - v26;
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  v28(v18, v9, v10);
  (*(void (**)(uint64_t, uint64_t))(v11 + 64))(v10, v11);
  uint64_t v29 = *(void (**)(char *, uint64_t))(v16 + 8);
  v29(v18, v10);
  uint64_t v94 = v9;
  uint64_t v86 = v28;
  v28(v18, v9, v10);
  uint64_t v30 = v95;
  (*(void (**)(uint64_t, uint64_t))(v11 + 72))(v10, v11);
  uint64_t v87 = v18;
  uint64_t v90 = v29;
  v29(v18, v10);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  v10,  v19,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = *(uint64_t (**)(char *, char *))(AssociatedConformanceWitness + 16);
  uint64_t v96 = v27;
  uint64_t v33 = v27;
  uint64_t v34 = v30;
  unint64_t v93 = v19;
  uint64_t v88 = v32;
  unint64_t v89 = AssociatedConformanceWitness;
  if ((((uint64_t (*)(char *, char *, unint64_t))v32)(v33, v30, v19) & 1) != 0)
  {
    id v35 = *(uint64_t (**)(void, void, void, void))(v11 + 80);
    unint64_t v36 = AssociatedTypeWitness;
    uint64_t v37 = v75;
    uint64_t v80 = v35;
    uint64_t v81 = v11;
    while (1)
    {
      uint64_t v38 = (void (*)(_BYTE *, void))v35(v97, v96, v10, v11);
      uint64_t v39 = v74;
      uint64_t v40 = v73;
      uint64_t v79 = *(void (**)(char *))(v74 + 16);
      v79(v73);
      v38(v97, 0LL);
      char v41 = v91(v40);
      if (v8)
      {
        (*(void (**)(char *, unint64_t))(v39 + 8))(v40, v36);
        uint64_t v51 = *(void (**)(char *, unint64_t))(v84 + 8);
        goto LABEL_18;
      }

      char v42 = v41;
      uint64_t v43 = *(void (**)(char *, unint64_t))(v39 + 8);
      v43(v40, v36);
      if ((v42 & 1) != 0) {
        break;
      }
      uint64_t v65 = v87;
      v86(v87, v94, v10);
      uint64_t v11 = v81;
      unint64_t v58 = v96;
      (*(void (**)(void))(v81 + 192))();
LABEL_11:
      id v35 = v80;
      v90(v65, v10);
      if ((v88(v58, v34) & 1) == 0) {
        goto LABEL_14;
      }
    }

    unint64_t v76 = v43;
    uint64_t v98 = 0LL;
    uint64_t v77 = *(void (**)(char *, uint64_t, uint64_t))(v85 + 40);
    while (1)
    {
      uint64_t v44 = v87;
      v86(v87, v94, v10);
      uint64_t v45 = v95;
      v77(v95, v10, v85);
      v90(v44, v10);
      uint64_t v46 = v84;
      uint64_t v47 = *(void (**)(char *, char *, unint64_t))(v84 + 16);
      uint64_t v48 = v82;
      unint64_t v49 = v93;
      v47(v82, v96, v93);
      char v50 = ((uint64_t (*)(char *, char *, unint64_t, unint64_t))v88)(v48, v45, v49, v89);
      uint64_t v51 = *(void (**)(char *, unint64_t))(v46 + 8);
      v51(v48, v49);
      if ((v50 & 1) == 0)
      {
        uint64_t v37 = v75;
        goto LABEL_16;
      }

      char v52 = (void (*)(_BYTE *, void))v80(v97, v45, v10, v81);
      uint64_t v53 = v78;
      unint64_t v36 = AssociatedTypeWitness;
      v79(v78);
      v52(v97, 0LL);
      uint64_t v54 = v98;
      char v55 = v91(v53);
      if (v54) {
        break;
      }
      char v56 = v55;
      uint64_t v98 = 0LL;
      v76(v53, v36);
      if ((v56 & 1) == 0)
      {
        uint64_t v57 = v82;
        unint64_t v58 = v96;
        uint64_t v79 = (void (*)(char *))v10;
        unint64_t v59 = v93;
        v47(v82, v96, v93);
        char v60 = v71;
        uint64_t v61 = v95;
        v47(v71, v95, v59);
        uint64_t v62 = v94;
        (*(void (**)(char *, char *, void (*)(char *)))(v72 + 64))(v57, v60, v79);
        v51(v60, v59);
        unint64_t v63 = v59;
        uint64_t v10 = (uint64_t)v79;
        v51(v57, v63);
        uint64_t v34 = v61;
        uint64_t v64 = v62;
        uint64_t v65 = v87;
        v86(v87, v64, v10);
        uint64_t v11 = v81;
        (*(void (**)(char *, uint64_t, uint64_t))(v81 + 192))(v58, v10, v81);
        uint64_t v37 = v75;
        uint64_t v8 = v98;
        goto LABEL_11;
      }
    }

    v76(v53, v36);
LABEL_18:
    uint64_t v68 = v96;
    unint64_t v69 = v93;
    v51(v95, v93);
    return ((uint64_t (*)(char *, unint64_t))v51)(v68, v69);
  }

  else
  {
    uint64_t v37 = v75;
LABEL_14:
    uint64_t v46 = v84;
    uint64_t v51 = *(void (**)(char *, unint64_t))(v84 + 8);
LABEL_16:
    unint64_t v66 = v93;
    v51(v95, v93);
    return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v46 + 32))(v37, v96, v66);
  }

uint64_t MutableCollection._indexedStablePartition(count:range:by:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(uint64_t)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v142 = a4;
  uint64_t v143 = a3;
  uint64_t v146 = a2;
  uint64_t v139 = a7;
  uint64_t v137 = a6;
  uint64_t v9 = *(void *)(a6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  a5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v11 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v136 = (char *)&v115 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v141 = (char *)&v115 - v13;
  uint64_t v144 = a5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v140 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  uint64_t v16 = MEMORY[0x1895F8858](v140);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  unint64_t v19 = (char *)&v115 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v145 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  MEMORY[0x1895F8858](v22);
  uint64_t v24 = MEMORY[0x1895F8858]((char *)&v115 - v23);
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  uint64_t v26 = MEMORY[0x1895F8858](v25);
  uint64_t v27 = MEMORY[0x1895F8858](v26);
  uint64_t v28 = MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v115 - v29;
  uint64_t v31 = MEMORY[0x1895F8858](v28);
  uint64_t v33 = (char *)&v115 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  unint64_t v36 = (char *)&v115 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  uint64_t v38 = MEMORY[0x1895F8858](v37);
  char v50 = (void (*)(char *, unint64_t))((char *)&v115 - v49);
  if (a1 == 1)
  {
    uint64_t v52 = v146;
    uint64_t v53 = v147;
    uint64_t result = v143(v146);
    if (!v53)
    {
      if ((result & 1) != 0) {
        return (*((uint64_t (**)(uint64_t, uint64_t, unint64_t))v145 + 2))( v139,  v52,  AssociatedTypeWitness);
      }
      else {
        return (*((uint64_t (**)(uint64_t, uint64_t, unint64_t))v145 + 2))( v139,  v52 + *(int *)(v140 + 36),  AssociatedTypeWitness);
      }
    }
  }

  else
  {
    if (!a1) {
      return (*((uint64_t (**)(uint64_t, uint64_t, unint64_t))v145 + 2))( v139,  v146,  AssociatedTypeWitness);
    }
    uint64_t v129 = v45;
    uint64_t v123 = v44;
    uint64_t v124 = v43;
    uint64_t v130 = v42;
    uint64_t v125 = v41;
    unint64_t v132 = v40;
    uint64_t v121 = v39;
    uint64_t v119 = v38;
    uint64_t v122 = v19;
    unint64_t v120 = v48;
    uint64_t v134 = v47;
    int v118 = v46;
    uint64_t v126 = a1;
    if (a1 >= 0) {
      uint64_t v54 = a1;
    }
    else {
      uint64_t v54 = a1 + 1;
    }
    char v55 = *(void (**)(uint64_t))(v9 + 136);
    uint64_t v56 = v146;
    uint64_t v133 = v54 >> 1;
    v55(v146);
    uint64_t v57 = (void (*)(char *, uint64_t, unint64_t))*((void *)v145 + 2);
    uint64_t v58 = v56;
    unint64_t v59 = v50;
    v57(v36, v58, AssociatedTypeWitness);
    v57(v33, (uint64_t)v36, AssociatedTypeWitness);
    char v135 = v57;
    v57(v30, (uint64_t)v50, AssociatedTypeWitness);
    uint64_t v127 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 24);
    unint64_t v128 = AssociatedConformanceWitness;
    if ((v127(v33, v30, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0) {
      goto LABEL_21;
    }
    char v60 = v145;
    uint64_t v61 = (char *)*((void *)v145 + 1);
    ((void (*)(char *, unint64_t))v61)(v30, AssociatedTypeWitness);
    ((void (*)(char *, unint64_t))v61)(v33, AssociatedTypeWitness);
    uint64_t v62 = TupleTypeMetadata2;
    unint64_t v63 = v141;
    uint64_t v64 = &v141[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v65 = (void (*)(char *, char *, unint64_t))*((void *)v60 + 4);
    v65(v141, v36, AssociatedTypeWitness);
    uint64_t v131 = v64;
    uint64_t v145 = v59;
    unint64_t v66 = v59;
    unint64_t v67 = (void (*)(char *, char *, unint64_t))v135;
    v135(v64, (uint64_t)v66, AssociatedTypeWitness);
    uint64_t v68 = v136;
    unint64_t v69 = &v136[*((int *)v62 + 12)];
    v67(v136, v63, AssociatedTypeWitness);
    v67(v69, v64, AssociatedTypeWitness);
    uint64_t v70 = v134;
    v65(v134, v68, AssociatedTypeWitness);
    ((void (*)(char *, unint64_t))v61)(v69, AssociatedTypeWitness);
    uint64_t v71 = &v68[*((int *)v62 + 12)];
    v65(v68, v63, AssociatedTypeWitness);
    v65(v71, v131, AssociatedTypeWitness);
    uint64_t v72 = v140;
    v65(&v70[*(int *)(v140 + 36)], v71, AssociatedTypeWitness);
    uint64_t v131 = v61;
    ((void (*)(char *, unint64_t))v61)(v68, AssociatedTypeWitness);
    uint64_t v73 = v129;
    uint64_t v74 = v130;
    uint64_t v75 = *(void (**)(uint64_t, uint64_t, uint64_t))(v130 + 32);
    v75(v129, (uint64_t)v70, v72);
    uint64_t v76 = v147;
    MutableCollection._indexedStablePartition(count:range:by:)(v133, v73, v143, v142, v144, v137);
    if (v76)
    {
      (*(void (**)(uint64_t, uint64_t))(v74 + 8))(v73, v72);
      return ((uint64_t (*)(void, unint64_t))v131)(v145, AssociatedTypeWitness);
    }

    uint64_t v117 = v75;
    uint64_t v116 = (void (*)(uint64_t, char *, unint64_t))v65;
    uint64_t v77 = (void (*)(void))v135;
    uint64_t v147 = 0LL;
    uint64_t v78 = *(uint64_t (**)(uint64_t, uint64_t))(v74 + 8);
    uint64_t result = v78(v73, v72);
    uint64_t v130 = v126 - v133;
    if (!__OFSUB__(v126, v133))
    {
      uint64_t v133 = (uint64_t)v78;
      uint64_t v79 = v125;
      ((void (*)(char *, uint64_t, unint64_t))v77)( v125,  v146 + *(int *)(v72 + 36),  AssociatedTypeWitness);
      uint64_t v80 = v123;
      ((void (*)(char *, void (*)(char *, unint64_t), unint64_t))v77)( v123,  v145,  AssociatedTypeWitness);
      uint64_t v81 = v124;
      ((void (*)(char *, char *, unint64_t))v77)(v124, v79, AssociatedTypeWitness);
      char v82 = v127(v80, v81, AssociatedTypeWitness, v128);
      uint64_t v83 = (void (*)(char *, uint64_t, uint64_t))v117;
      uint64_t v84 = TupleTypeMetadata2;
      if ((v82 & 1) != 0)
      {
        uint64_t v85 = v81;
        uint64_t v86 = v131;
        ((void (*)(char *, unint64_t))v131)(v85, AssociatedTypeWitness);
        ((void (*)(char *, unint64_t))v86)(v80, AssociatedTypeWitness);
        uint64_t v87 = &v141[*((int *)v84 + 12)];
        v77();
        uint64_t v88 = v79;
        unint64_t v89 = v116;
        v116((uint64_t)v87, v88, AssociatedTypeWitness);
        uint64_t v90 = v136;
        uint64_t v91 = &v136[*((int *)v84 + 12)];
        ((void (*)(char *, char *, unint64_t))v77)(v136, v141, AssociatedTypeWitness);
        ((void (*)(char *, char *, unint64_t))v77)(v91, v87, AssociatedTypeWitness);
        uint64_t v92 = v134;
        v89((uint64_t)v134, v90, AssociatedTypeWitness);
        ((void (*)(char *, unint64_t))v86)(v91, AssociatedTypeWitness);
        unint64_t v93 = &v90[*((int *)v84 + 12)];
        v89((uint64_t)v90, v141, AssociatedTypeWitness);
        v89((uint64_t)v93, v87, AssociatedTypeWitness);
        uint64_t v94 = v140;
        v89((uint64_t)&v92[*(int *)(v140 + 36)], v93, AssociatedTypeWitness);
        ((void (*)(char *, unint64_t))v86)(v90, AssociatedTypeWitness);
        uint64_t v95 = v122;
        v83(v122, (uint64_t)v92, v94);
        uint64_t v96 = v121;
        uint64_t v97 = v147;
        MutableCollection._indexedStablePartition(count:range:by:)(v130, v95, v143, v142, v144, v137);
        if (v97)
        {
          ((void (*)(char *, uint64_t))v133)(v95, v94);
          ((void (*)(char *, unint64_t))v86)(v132, AssociatedTypeWitness);
          return ((uint64_t (*)(void, unint64_t))v86)(v145, AssociatedTypeWitness);
        }

        uint64_t v147 = 0LL;
        ((void (*)(char *, uint64_t))v133)(v95, v94);
        uint64_t v98 = v119;
        unint64_t v99 = v132;
        uint64_t v100 = (void (*)(uint64_t, uint64_t, unint64_t))v135;
        v135((char *)v119, (uint64_t)v132, AssociatedTypeWitness);
        uint64_t v101 = v120;
        v100((uint64_t)v120, v96, AssociatedTypeWitness);
        if ((v127((char *)v98, v101, AssociatedTypeWitness, v128) & 1) != 0)
        {
          BOOL v102 = v131;
          ((void (*)(char *, unint64_t))v131)(v101, AssociatedTypeWitness);
          ((void (*)(uint64_t, unint64_t))v102)(v98, AssociatedTypeWitness);
          uint64_t v103 = TupleTypeMetadata2;
          uint64_t v104 = v141;
          uint64_t v105 = &v141[*((int *)TupleTypeMetadata2 + 12)];
          uint64_t v106 = (void (*)(char *, uint64_t, unint64_t))v116;
          v116((uint64_t)v141, v99, AssociatedTypeWitness);
          v106(v105, v96, AssociatedTypeWitness);
          uint64_t v107 = (void (*)(char *, char *, unint64_t))v135;
          uint64_t v108 = v136;
          uint64_t v109 = &v136[*((int *)v103 + 12)];
          v135(v136, (uint64_t)v104, AssociatedTypeWitness);
          v107(v109, v105, AssociatedTypeWitness);
          uint64_t v110 = v134;
          v106(v134, (uint64_t)v108, AssociatedTypeWitness);
          ((void (*)(char *, unint64_t))v102)(v109, AssociatedTypeWitness);
          uint64_t v111 = &v108[*((int *)v103 + 12)];
          v106(v108, (uint64_t)v104, AssociatedTypeWitness);
          v106(v111, (uint64_t)v105, AssociatedTypeWitness);
          uint64_t v112 = v140;
          v106(&v110[*(int *)(v140 + 36)], (uint64_t)v111, AssociatedTypeWitness);
          ((void (*)(char *, unint64_t))v102)(v108, AssociatedTypeWitness);
          BOOL v113 = v118;
          v117((uint64_t)v118, (uint64_t)v110, v112);
          uint64_t v114 = v145;
          MutableCollection._rotate(in:shiftingToStart:)(v113, v145, v144, v137, v139);
          ((void (*)(void, uint64_t))v133)(v113, v112);
          return ((uint64_t (*)(void, unint64_t))v102)(v114, AssociatedTypeWitness);
        }
      }

uint64_t static Int./ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int./ infix(_:_:)(a1, a2, 0x3829uLL, 0x3830uLL);
}

uint64_t MutableCollection._rotate(in:shiftingToStart:)@<X0>( void (*a1)(char *, unint64_t)@<X0>, void (*a2)(char *, unint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v141 = a2;
  uint64_t v110 = a5;
  uint64_t v120 = a4;
  uint64_t v7 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v121 = (char *)&v110 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v125 = (char *)&v110 - v11;
  uint64_t v119 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v136 = *(void *)(v14 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  int v118 = (char *)&v110 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v137 = (char *)&v110 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v135 = (uint64_t)&v110 - v20;
  uint64_t v21 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v124 = (char *)&v110 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v123 = (char *)&v110 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v122 = (char *)&v110 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  unint64_t v128 = (char *)&v110 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v126 = (char *)&v110 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v110 - v33;
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  uint64_t v127 = (char *)&v110 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v117 = (uint64_t)&v110 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v116 = (uint64_t)&v110 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v111 = (char *)&v110 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  uint64_t v45 = (char *)&v110 - v44;
  uint64_t v46 = MEMORY[0x1895F8858](v43);
  uint64_t v48 = (char *)&v110 - v47;
  MEMORY[0x1895F8858](v46);
  char v50 = (char *)&v110 - v49;
  uint64_t v51 = *(void (**)(char *, void (*)(char *, unint64_t), unint64_t))(v21 + 16);
  v51((char *)&v110 - v49, v141, AssociatedTypeWitness);
  v51(v48, (void (*)(char *, unint64_t))a1, AssociatedTypeWitness);
  uint64_t v134 = v14;
  uint64_t v52 = a1 + *(int *)(v14 + 36);
  uint64_t v129 = (void (*)(char *, char *, unint64_t))v51;
  v51(v45, (void (*)(char *, unint64_t))v52, AssociatedTypeWitness);
  uint64_t v53 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v54 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v53 + 8);
  if ((v54(v48, v50, AssociatedTypeWitness, v53) & 1) != 0)
  {
    char v55 = *(void (**)(char *, unint64_t))(v21 + 8);
    v55(v48, AssociatedTypeWitness);
    v55(v50, AssociatedTypeWitness);
    return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v21 + 32))(v110, v45, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v115 = v21;
    uint64_t v57 = v110;
    uint64_t v140 = v48;
    uint64_t v114 = v54;
    uint64_t v58 = v50;
    if ((v54(v50, v45, AssociatedTypeWitness, v53) & 1) != 0)
    {
      uint64_t v59 = v115;
      char v60 = *(void (**)(char *, unint64_t))(v115 + 8);
      v60(v45, AssociatedTypeWitness);
      v60(v50, AssociatedTypeWitness);
      return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v59 + 32))(v57, v140, AssociatedTypeWitness);
    }

    else
    {
      uint64_t v113 = v53;
      uint64_t v133 = v45;
      uint64_t v61 = v129;
      v129(v111, v45, AssociatedTypeWitness);
      unint64_t v63 = v127;
      uint64_t v62 = v128;
      uint64_t v64 = v126;
      unint64_t v132 = AssociatedConformanceWitness;
      uint64_t v112 = v34;
      uint64_t v139 = v58;
      while (1)
      {
        v61(v63, v140, AssociatedTypeWitness);
        v61(v34, v58, AssociatedTypeWitness);
        v61(v64, v63, AssociatedTypeWitness);
        v61(v62, v34, AssociatedTypeWitness);
        uint64_t v65 = v63;
        unint64_t v66 = v34;
        uint64_t v131 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 24);
        if ((v131(v64, v62, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0) {
          goto LABEL_18;
        }
        uint64_t v67 = v115;
        uint64_t v68 = *(void (**)(char *, unint64_t))(v115 + 8);
        v68(v62, AssociatedTypeWitness);
        v68(v64, AssociatedTypeWitness);
        unint64_t v69 = TupleTypeMetadata2;
        uint64_t v70 = v125;
        uint64_t v71 = &v125[*((int *)TupleTypeMetadata2 + 12)];
        uint64_t v72 = *(void (**)(char *, char *, unint64_t))(v67 + 32);
        v72(v125, v65, AssociatedTypeWitness);
        v72(v71, v66, AssociatedTypeWitness);
        uint64_t v73 = v121;
        uint64_t v74 = &v121[*((int *)v69 + 12)];
        v61(v121, v70, AssociatedTypeWitness);
        v61(v74, v71, AssociatedTypeWitness);
        uint64_t v75 = v137;
        v72(v137, v73, AssociatedTypeWitness);
        v68(v74, AssociatedTypeWitness);
        uint64_t v76 = &v73[*((int *)v69 + 12)];
        v72(v73, v70, AssociatedTypeWitness);
        v72(v76, v71, AssociatedTypeWitness);
        uint64_t v77 = v134;
        v72(&v75[*(int *)(v134 + 36)], v76, AssociatedTypeWitness);
        uint64_t v141 = v68;
        v68(v73, AssociatedTypeWitness);
        uint64_t v130 = *(void (**)(uint64_t, char *, uint64_t))(v136 + 32);
        v130(v135, v75, v77);
        uint64_t v78 = v122;
        v61(v122, v139, AssociatedTypeWitness);
        uint64_t v79 = v123;
        v61(v123, v78, AssociatedTypeWitness);
        uint64_t v80 = v124;
        uint64_t v81 = v133;
        ((void (*)(char *))v61)(v124);
        if ((v131(v79, v80, AssociatedTypeWitness, v132) & 1) == 0) {
LABEL_18:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
        char v82 = v80;
        uint64_t v83 = v141;
        v141(v82, AssociatedTypeWitness);
        v83(v79, AssociatedTypeWitness);
        v83(v140, AssociatedTypeWitness);
        uint64_t v84 = TupleTypeMetadata2;
        uint64_t v85 = &v70[*((int *)TupleTypeMetadata2 + 12)];
        v72(v70, v78, AssociatedTypeWitness);
        v61(v85, v81, AssociatedTypeWitness);
        uint64_t v86 = &v73[*((int *)v84 + 12)];
        v61(v73, v70, AssociatedTypeWitness);
        v61(v86, v85, AssociatedTypeWitness);
        uint64_t v87 = v137;
        v72(v137, v73, AssociatedTypeWitness);
        uint64_t v88 = v141;
        v141(v86, AssociatedTypeWitness);
        unint64_t v89 = &v73[*((int *)v84 + 12)];
        v72(v73, v70, AssociatedTypeWitness);
        v72(v89, v85, AssociatedTypeWitness);
        uint64_t v90 = v134;
        uint64_t v91 = &v87[*(int *)(v134 + 36)];
        uint64_t v131 = (uint64_t (*)(char *, char *, unint64_t, unint64_t))v72;
        v72(v91, v89, AssociatedTypeWitness);
        v88(v73, AssociatedTypeWitness);
        uint64_t v92 = (uint64_t)v118;
        v130((uint64_t)v118, v87, v90);
        uint64_t v93 = v116;
        uint64_t v94 = v117;
        uint64_t v95 = v135;
        MutableCollection._swapNonemptySubrangePrefixes(_:_:)(v116, v117, v135, v92, v119, v120);
        uint64_t v96 = *(void (**)(uint64_t, uint64_t))(v136 + 8);
        uint64_t v97 = v92;
        uint64_t v98 = v93;
        v96(v97, v90);
        v96(v95, v90);
        unint64_t v99 = v133;
        uint64_t v100 = v113;
        uint64_t v101 = v114;
        char v102 = v114((char *)v94, v133, AssociatedTypeWitness, v113);
        unint64_t v63 = v127;
        uint64_t v62 = v128;
        uint64_t v103 = v141;
        if ((v102 & 1) != 0)
        {
          if ((v101(v111, v99, AssociatedTypeWitness, v100) & 1) != 0)
          {
            uint64_t v104 = v111;
            v103(v111, AssociatedTypeWitness);
            v129(v104, (char *)v98, AssociatedTypeWitness);
          }
        }

        uint64_t v105 = v140;
        uint64_t v106 = v98;
        uint64_t v107 = (void (*)(char *, uint64_t, unint64_t))v131;
        ((void (*)(char *, uint64_t, unint64_t))v131)(v140, v106, AssociatedTypeWitness);
        uint64_t v108 = v105;
        uint64_t v109 = v139;
        if ((v101(v108, v139, AssociatedTypeWitness, v100) & 1) != 0)
        {
          v103(v109, AssociatedTypeWitness);
          v107(v109, v94, AssociatedTypeWitness);
        }

        else
        {
          v103((char *)v94, AssociatedTypeWitness);
        }

        uint64_t v58 = v109;
        unint64_t AssociatedConformanceWitness = v132;
        uint64_t v64 = v126;
        uint64_t v34 = v112;
        uint64_t v61 = v129;
      }

      v103((char *)v94, AssociatedTypeWitness);
      v103((char *)v98, AssociatedTypeWitness);
      v103(v99, AssociatedTypeWitness);
      v103(v139, AssociatedTypeWitness);
      return ((uint64_t (*)(uint64_t, char *, unint64_t))v131)(v110, v111, AssociatedTypeWitness);
    }
  }

uint64_t Collection._partitioningIndex(where:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v7 = v6;
  uint64_t v43 = a1;
  uint64_t v44 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v42 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v36 - v12;
  unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v40 = *(void *)(v14 - 8);
  unint64_t v41 = v14;
  MEMORY[0x1895F8858](v14);
  uint64_t v49 = (char *)&v36 - v15;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 112))(a3, a4);
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v46 = v5;
  uint64_t v47 = a5;
  uint64_t v45 = a3;
  uint64_t result = v17(a3, a4);
  if (v16 >= 1)
  {
    uint64_t v19 = *(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a4 + 136);
    uint64_t v38 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a4 + 80);
    uint64_t v39 = v19;
    while (1)
    {
      uint64_t v25 = v49;
      uint64_t v26 = v45;
      v39((uint64_t)v47, (unint64_t)v16 >> 1, v45, a4);
      uint64_t v27 = (void (*)(_BYTE *, void))v38(v48, v25, v26, a4);
      uint64_t v28 = v42;
      (*(void (**)(char *))(v42 + 16))(v13);
      v27(v48, 0LL);
      char v29 = v43(v13);
      if (v7) {
        break;
      }
      char v30 = v29;
      uint64_t v31 = *(void (**)(char *, unint64_t))(v28 + 8);
      unint64_t v32 = AssociatedTypeWitness;
      v31(v13, AssociatedTypeWitness);
      uint64_t v33 = *(uint64_t (**)(char *, unint64_t))(v40 + 8);
      if ((v30 & 1) != 0)
      {
        uint64_t result = v33(v49, v41);
        uint64_t v16 = (unint64_t)v16 >> 1;
      }

      else
      {
        uint64_t v37 = 0LL;
        uint64_t v20 = v13;
        unint64_t v21 = v41;
        v33(v47, v41);
        uint64_t v22 = v49;
        (*(void (**)(char *, uint64_t, uint64_t))(a4 + 184))(v49, v45, a4);
        uint64_t v23 = v22;
        unint64_t v24 = v21;
        uint64_t v13 = v20;
        uint64_t v7 = v37;
        uint64_t result = v33(v23, v24);
        v16 += ~((unint64_t)v16 >> 1);
      }

      unint64_t AssociatedTypeWitness = v32;
      if (v16 <= 0) {
        return result;
      }
    }

    (*(void (**)(char *, unint64_t))(v28 + 8))(v13, AssociatedTypeWitness);
    unint64_t v34 = v41;
    uint64_t v35 = *(void (**)(char *, unint64_t))(v40 + 8);
    v35(v49, v41);
    return ((uint64_t (*)(char *, unint64_t))v35)(v47, v34);
  }

  return result;
}

uint64_t Sequence.shuffled<A>(using:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a2, a4);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v16 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v14, v15);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v16, v17);
  uint64_t v20 = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v16, v19);
  MutableCollection<>.shuffle<A>(using:)(a1, v16, a3, WitnessTable, v20, a5);
  return v23;
}

uint64_t specialized MutableCollection<>.shuffle<A>(using:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v21 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v22 = AssociatedTypeWitness;
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v20 - v12;
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 112);
  uint64_t result = v14(a2, v7);
  if (result >= 2)
  {
    uint64_t v16 = v14(a2, v7);
    (*(void (**)(uint64_t, uint64_t))(v7 + 64))(a2, v7);
    if (v16 > 1)
    {
      do
      {
        uint64_t __buf = 0LL;
        swift_stdlib_random(&__buf, 8uLL);
        if (v16 > (unint64_t)(__buf * v16))
        {
          unint64_t v19 = -v16 % (unint64_t)v16;
          while (v19 > __buf * v16)
          {
            uint64_t __buf = 0LL;
            swift_stdlib_random(&__buf, 8uLL);
          }
        }

        (*(void (**)(char *))(a4 + 32))(v13);
        (*(void (**)(char *, char *, uint64_t, uint64_t))(a3 + 64))(v13, v11, a2, a3);
        uint64_t v17 = *(void (**)(char *, unint64_t))(v21 + 8);
        v17(v11, v22);
        (*(void (**)(char *, uint64_t, uint64_t))(v7 + 192))(v13, a2, v7);
      }

      while (v16-- > 2);
    }

    else
    {
      uint64_t v17 = *(void (**)(char *, unint64_t))(v21 + 8);
    }

    return ((uint64_t (*)(char *, unint64_t))v17)(v13, v22);
  }

  return result;
}

uint64_t MutableCollection<>.shuffle<A>(using:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v32 = a4;
  uint64_t v33 = a5;
  uint64_t v10 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v34 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v35 = AssociatedTypeWitness;
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v31 = (char *)&v27 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v27 - v14;
  uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 112);
  uint64_t result = v16(a2, v10);
  if (result >= 2)
  {
    uint64_t v18 = v16(a2, v10);
    (*(void (**)(uint64_t, uint64_t))(v10 + 64))(a2, v10);
    if (v18 <= 1)
    {
      return (*(uint64_t (**)(char *, unint64_t))(v34 + 8))(v15, v35);
    }

    else
    {
      uint64_t v29 = v6;
      char v30 = v15;
      uint64_t v27 = v10;
      uint64_t v28 = a2;
      unint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 8);
      uint64_t v20 = v15;
      uint64_t v21 = v31;
      uint64_t v22 = v28;
      for (uint64_t i = v19(a3, a6); ; uint64_t i = v19(a3, a6))
      {
        if (v18 > (unint64_t)(i * v18))
        {
          unint64_t v26 = -v18 % (unint64_t)v18;
          if (v26 > i * v18)
          {
            while (v26 > v19(a3, a6) * v18)
              ;
          }
        }

        uint64_t v36 = v18 - 1;
        (*(void (**)(char *))(v33 + 32))(v20);
        (*(void (**)(char *, char *, uint64_t))(v32 + 64))(v20, v21, v22);
        unint64_t v24 = *(void (**)(char *, unint64_t))(v34 + 8);
        v24(v21, v35);
        (*(void (**)(char *, uint64_t))(v27 + 192))(v20, v22);
        BOOL v25 = v18 <= 2;
        uint64_t v18 = v36;
        if (v25) {
          break;
        }
      }

      return ((uint64_t (*)(char *, unint64_t))v24)(v30, v35);
    }
  }

  return result;
}

uint64_t Sequence.shuffled()(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, a2);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v10, v11);
  uint64_t v14 = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v10, v13);
  specialized MutableCollection<>.shuffle<A>(using:)(v14, v10, WitnessTable, v14);
  return v17;
}

uint64_t MutableCollection<>.shuffle()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized MutableCollection<>.shuffle<A>(using:)(a1, a1, a2, a3);
}

uint64_t == infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v18 - v13;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(a4 + 24);
  v15(a3, a4);
  v15(a3, a4);
  LOBYTE(a5) = (*(uint64_t (**)(char *, char *, unint64_t, uint64_t))(a5 + 8))( v14,  v12,  AssociatedTypeWitness,  a5);
  uint64_t v16 = *(void (**)(char *, unint64_t))(v9 + 8);
  v16(v12, AssociatedTypeWitness);
  v16(v14, AssociatedTypeWitness);
  return a5 & 1;
}

BOOL != infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v18 - v13;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(a4 + 24);
  v15(a3, a4);
  v15(a3, a4);
  LOBYTE(a5) = (*(uint64_t (**)(char *, char *, unint64_t, uint64_t))(a5 + 8))( v14,  v12,  AssociatedTypeWitness,  a5);
  uint64_t v16 = *(void (**)(char *, unint64_t))(v9 + 8);
  v16(v12, AssociatedTypeWitness);
  v16(v14, AssociatedTypeWitness);
  return (a5 & 1) == 0;
}

BOOL != infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v19 - v14;
  uint64_t v16 = *(void (**)(uint64_t, uint64_t))(a5 + 24);
  v16(a3, a5);
  v16(a3, a5);
  LOBYTE(a6) = (*(uint64_t (**)(char *, char *, unint64_t, uint64_t))(a6 + 8))( v15,  v13,  AssociatedTypeWitness,  a6);
  uint64_t v17 = *(void (**)(char *, unint64_t))(v10 + 8);
  v17(v13, AssociatedTypeWitness);
  v17(v15, AssociatedTypeWitness);
  return (a6 & 1) == 0;
}

uint64_t RawRepresentable<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t))(a2 + 32))(0LL, a1);
}

uint64_t RawRepresentable<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v14 - v11;
  (*(void (**)(uint64_t, uint64_t))(a4 + 24))(a2, a4);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(a5 + 24))(a1, AssociatedTypeWitness, a5);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t ExpressibleByStringLiteral<>.init(extendedGraphemeClusterLiteral:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t ExpressibleByStringInterpolation<>.init(stringInterpolation:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[0] = a1;
  v5[1] = a2;
  return (*(uint64_t (**)(void *, uint64_t))(*(void *)(a4 + 8) + 32LL))(v5, a3);
}

uint64_t (*ContiguousArray._buffer.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Int __swiftcall ContiguousArray._getCount()()
{
  return *(void *)(v0 + 16);
}

Swift::Int __swiftcall ContiguousArray._getCapacity()()
{
  return *(void *)(v0 + 24) >> 1;
}

Swift::Void __swiftcall ContiguousArray._makeMutableAndUnique()()
{
  uint64_t v2 = v0;
  uint64_t v3 = *v1;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  uint64_t *v1 = v3;
  if (!isUniquelyReferenced_nonNull_native) {
    uint64_t *v1 = (uint64_t)_ContiguousArrayBuffer._consumeAndCreateNew()(v3, *(uint64_t **)(v2 + 16));
  }
}

__objc2_class **_ContiguousArrayBuffer._consumeAndCreateNew()(uint64_t a1, uint64_t *a2)
{
  return _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(a1 + 16),  0,  a1,  a2);
}

Swift::Void __swiftcall ContiguousArray._checkSubscript_native(_:)(Swift::Int a1)
{
  if (a1 < 0 || *(void *)(v1 + 16) <= (unint64_t)a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
}

Swift::Void __swiftcall ContiguousArray._checkIndex(_:)(Swift::Int a1)
{
  if (*(void *)(v1 + 16) < a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ContiguousArray index is out of range",  37LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x6CuLL,  0);
  }
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative ContiguousArray index is out of range",  46LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x6DuLL,  0);
  }
}

uint64_t ContiguousArray.startIndex.getter()
{
  return 0LL;
}

unint64_t ContiguousArray._getElementAddress(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2
}

uint64_t ContiguousArray.capacity.getter(uint64_t a1)
{
  return *(void *)(a1 + 24) >> 1;
}

id ContiguousArray._owner.getter()
{
  uint64_t v0 = (void *)EnumeratedSequence._base.modify();
  return swift_unknownObjectRetain(v0, v1, v2, v3);
}

uint64_t ContiguousArray._baseAddressIfContiguous.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL);
  return a1 + ((v2 + 32) & ~v2);
}

uint64_t _ContiguousArrayBuffer.firstElementAddressIfContiguous.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL);
  return a1 + ((v2 + 32) & ~v2);
}

uint64_t ContiguousArray._baseAddress.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL);
  return a1 + ((v2 + 32) & ~v2);
}

uint64_t protocol witness for _ArrayProtocol.capacity.getter in conformance ContiguousArray<A>()
{
  return ContiguousArray.capacity.getter(*v0);
}

id protocol witness for _ArrayProtocol._owner.getter in conformance ContiguousArray<A>()
{
  uint64_t v0 = (void *)EnumeratedSequence._base.modify();
  return swift_unknownObjectRetain(v0, v1, v2, v3);
}

uint64_t protocol witness for _ArrayProtocol._baseAddressIfContiguous.getter in conformance ContiguousArray<A>( uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 16) - 8LL) + 80LL);
  return *v1 + ((v2 + 32) & ~v2);
}

uint64_t protocol witness for _ArrayProtocol.init(_:) in conformance ContiguousArray<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v7 = type metadata accessor for _ContiguousArrayBuffer(0LL, *(void *)(a2 + 16), a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, v7, v8);
  uint64_t result = Array.init<A>(_:)(a1, v10, v7, WitnessTable);
  *a5 = result;
  return result;
}

unint64_t *protocol witness for _ArrayProtocol._buffer.getter in conformance ContiguousArray<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, unint64_t **a4@<X8>)
{
  uint64_t v5 = *v4;
  *a4 = *v4;
  return swift_retain(v5, a1, a2, a3);
}

uint64_t Array.index(_:offsetBy:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t Array.distance(from:to:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __OFSUB__(a2, a1);
  uint64_t result = a2 - a1;
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t ContiguousArray.subscript.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if ((a1 & 0x8000000000000000LL) != 0 || *(void *)(a2 + 16) <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + ((*(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL))
         + *(void *)(*(void *)(a3 - 8) + 72LL) * a1);
}

uint64_t key path getter for ContiguousArray.subscript(_:) : <A>ContiguousArray<A>A@<X0>( uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return ContiguousArray.subscript.getter(*a2, *a1, *(unint64_t *)((char *)a2 + a3 - 8), a4);
}

uint64_t key path setter for ContiguousArray.subscript(_:) : <A>ContiguousArray<A>A( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  return key path setter for Array.subscript(_:) : <A>[A]A( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t))type metadata accessor for ContiguousArray,  (uint64_t (*)(_BYTE *, uint64_t, uint64_t))ContiguousArray.subscript.modify);
}

{
  return key path setter for Array.subscript(_:) : <A>[A]A( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void))type metadata accessor for ContiguousArray,  (uint64_t (*)(id, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))ContiguousArray.subscript.setter);
}

uint64_t key path setter for Array.subscript(_:) : <A>[A]A( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t (*a5)(void, uint64_t), uint64_t (*a6)(_BYTE *, uint64_t, uint64_t))
{
  uint64_t v8 = *(uint64_t *)((char *)a3 + a4 - 8);
  uint64_t v9 = *a3;
  uint64_t v10 = a5(0LL, v8);
  uint64_t v11 = (uint64_t (*)(_BYTE *, void))a6(v14, v9, v10);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 24LL))(v12, a1, v8);
  return v11(v14, 0LL);
}

uint64_t (*ContiguousArray.subscript.modify(uint64_t a1, unint64_t a2))()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _ContiguousArrayBuffer.getElement(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + ((*(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL))
         + *(void *)(*(void *)(a3 - 8) + 72LL) * a1);
}

uint64_t ContiguousArray.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(a3 + 16);
  specialized Array._checkSubscript_mutating(_:)(a2, v7);
  return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 40LL))( v7 + ((*(unsigned __int8 *)(*(void *)(v8 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v8 - 8) + 80LL))
         + *(void *)(*(void *)(v8 - 8) + 72LL) * a2,
           a1,
           v8);
}

id ContiguousArray.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _ContiguousArrayBuffer.subscript.getter( a1,  a2,  a3,  a4,  (uint64_t (*)(void))specialized ContiguousArray.subscript.getter);
}

id _ContiguousArrayBuffer.subscript.getter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v5 = (void *)a5();
  return swift_unknownObjectRetain(v5, v6, v7, v8);
}

id key path getter for ContiguousArray.subscript(_:) : <A>ContiguousArray<A>A@<X0>( uint64_t *a1@<X0>, Swift::Int *a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = (void *)specialized ContiguousArray.subscript.getter(*a2, a2[1], *a1);
  *a3 = v4;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

uint64_t key path setter for Array.subscript(_:) : <A>[A]A( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t (*a5)(void, void), uint64_t (*a6)(id, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  uint64_t v9 = *(void **)a1;
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v13 = a5(0LL, *(uint64_t *)((char *)a3 + a4 - 8));
  id v17 = swift_unknownObjectRetain(v9, v14, v15, v16);
  return a6(v17, v10, v11, v12, v7, v8, v13);
}

void ContiguousArray.subscript.setter( void *a1, uint64_t a2, uint64_t a3, unint64_t a4, Swift::Int a5, Swift::Int a6, uint64_t a7)
{
  uint64_t v15 = *v7;
  uint64_t v16 = *(void *)(a7 + 16);
  ContiguousArray._checkIndex(_:)(a5);
  ContiguousArray._checkIndex(_:)(a6);
  if (a6 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  if (v15
     + ((*(unsigned __int8 *)(*(void *)(v16 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v16 - 8) + 80LL))
     + *(void *)(*(void *)(v16 - 8) + 72LL) * a5 != a2 + *(void *)(*(void *)(v16 - 8) + 72LL) * a3)
    goto LABEL_3;
  if ((uint64_t)(a4 >> 1) < a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a5 == a3 && a4 >> 1 == a6)
  {
    swift_unknownObjectRelease(a1);
  }

  else
  {
LABEL_3:
    v22[0] = a1;
    v22[1] = a2;
    v22[2] = a3;
    v22[3] = a4;
    uint64_t v19 = type metadata accessor for ArraySlice(0LL, v16, v17, v18);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v19, v20);
    ContiguousArray.replaceSubrange<A>(_:with:)(a5, a6, (uint64_t)v22, a7, v19, WitnessTable);
  }

void ContiguousArray.replaceSubrange<A>(_:with:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = v6;
  uint64_t v75 = (uint64_t (*)(void *, char *, uint64_t, uint64_t))a4;
  uint64_t v13 = *(void *)(a4 + 16);
  uint64_t v72 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v64 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  MEMORY[0x1895F8858](v19);
  if (a1 < 0)
  {
    LODWORD(v62) = 0;
    unint64_t v61 = 1284LL;
    LOBYTE(WitnessTable) = 2;
    uint64_t v58 = "ContiguousArray replace: subrange start is negative";
    uint64_t v59 = 51LL;
    goto LABEL_28;
  }

  if (*(void *)(*v7 + 16) < a2)
  {
    LODWORD(v62) = 0;
    unint64_t v61 = 1287LL;
    LOBYTE(WitnessTable) = 2;
    uint64_t v58 = "ContiguousArray replace: subrange extends past the end";
    uint64_t v59 = 54LL;
LABEL_28:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  v58,  v59,  2,  "Swift/ContiguousArray.swift",  27LL,  WitnessTable,  v61,  v62);
  }

  uint64_t v68 = v15;
  uint64_t v69 = v21;
  uint64_t v76 = a2;
  BOOL v22 = __OFSUB__(a2, a1);
  uint64_t v23 = a2 - a1;
  if (v22)
  {
    __break(1u);
    goto LABEL_30;
  }

  uint64_t v73 = v13;
  uint64_t v67 = (char *)&v64 - v20;
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 112))(a5, a6);
  uint64_t v25 = v24 - v23;
  if (__OFSUB__(v24, v23))
  {
LABEL_30:
    __break(1u);
    goto LABEL_31;
  }

  uint64_t v65 = v18;
  unint64_t v66 = AssociatedTypeWitness;
  uint64_t v71 = a3;
  uint64_t v26 = *v7;
  Swift::Int v27 = *(void *)(*v7 + 16);
  Swift::Int v28 = v27 + v25;
  if (__OFADD__(v27, v25))
  {
LABEL_31:
    __break(1u);
    goto LABEL_32;
  }

  uint64_t v29 = v24;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v7);
  *uint64_t v7 = v26;
  if (!isUniquelyReferenced_nonNull_native || v28 > *(void *)(v26 + 24) >> 1)
  {
    if (v27 <= v28) {
      Swift::Int v31 = v27 + v25;
    }
    else {
      Swift::Int v31 = v27;
    }
    ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( isUniquelyReferenced_nonNull_native,  v31,  1);
    uint64_t v26 = *v7;
  }

  if (v23 < 0) {
LABEL_32:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
  unint64_t v32 = v26 + ((*(unsigned __int8 *)(v72 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v72 + 80));
  uint64_t v33 = *(void *)(v72 + 72);
  unint64_t v34 = v32 + v33 * a1;
  uint64_t v35 = v33 * v29;
  uint64_t v70 = (char *)(v34 + v33 * v29);
  swift_arrayDestroy(v34, v23, v73);
  if (!v25) {
    goto LABEL_17;
  }
  uint64_t v37 = *(void *)(v26 + 16);
  if (__OFSUB__(v37, v76))
  {
    __break(1u);
    goto LABEL_34;
  }

  uint64_t v36 = UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v32 + v33 * v76), v37 - v76, v70, v73);
  uint64_t v38 = *(void *)(v26 + 16);
  BOOL v22 = __OFADD__(v38, v25);
  uint64_t v39 = v38 + v25;
  if (v22)
  {
LABEL_34:
    __break(1u);
    return;
  }

  *(void *)(v26 + 16) = v39;
  uint64_t v35 = v33 * v29;
LABEL_17:
  if (v29 <= 0)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a5 - 8) + 8LL))(v71, a5);
  }

  else
  {
    uint64_t v76 = v33;
    MEMORY[0x1895F8858](v36);
    uint64_t v40 = v73;
    uint64_t v43 = type metadata accessor for _ContiguousArrayBuffer(0LL, v73, v41, v42);
    *(&v64 - 6) = v43;
    *(&v64 - 5) = a5;
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, v43, v44);
    unint64_t v61 = a6;
    uint64_t v62 = v29;
    unint64_t v63 = v34;
    uint64_t v45 = v71;
    (*(void (**)(void *__return_ptr, char *(*)(char *, uint64_t), uint64_t *, void *, uint64_t))(*(void *)(a6 + 8) + 72LL))( v77,  partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:),  &v64 - 8,  &unk_189B8D178,  a5);
    if ((v77[0] & 1) != 0)
    {
      uint64_t v46 = v67;
      (*(void (**)(uint64_t, uint64_t))(a6 + 64))(a5, a6);
      BOOL v47 = v35 < 1;
      uint64_t v48 = v68;
      uint64_t v49 = a5;
      char v50 = v46;
      uint64_t v51 = v72;
      uint64_t v52 = v70;
      if (!v47)
      {
        uint64_t v53 = *(uint64_t (**)(void *, char *, uint64_t, uint64_t))(a6 + 80);
        uint64_t v74 = *(void (**)(char *, uint64_t, uint64_t))(a6 + 192);
        uint64_t v75 = v53;
        do
        {
          uint64_t v54 = (void (*)(void *, void))v75(v77, v50, v49, a6);
          (*(void (**)(char *))(v51 + 16))(v48);
          v54(v77, 0LL);
          (*(void (**)(unint64_t, char *, uint64_t))(v51 + 32))(v34, v48, v40);
          v34 += v76;
          v74(v50, v49, a6);
        }

        while (v34 < (unint64_t)v52);
      }

      uint64_t v56 = v65;
      unint64_t v55 = v66;
      uint64_t v57 = v69;
      (*(void (**)(uint64_t, char *, unint64_t))(v65 + 32))(v69, v50, v66);
      _expectEnd<A>(of:is:)(v45, v57, v49, a6);
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v49 - 8) + 8LL))(v45, v49);
      (*(void (**)(uint64_t, unint64_t))(v56 + 8))(v57, v55);
    }

    else
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)(a5 - 8) + 8LL))(v45, a5);
    }
  }

void (*ContiguousArray.subscript.modify( void *a1, Swift::Int a2, Swift::Int a3, uint64_t a4))(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[6] = a4;
  v9[7] = v4;
  v9[4] = a2;
  v9[5] = a3;
  uint64_t v10 = *v4;
  uint64_t v11 = *(void *)(a4 + 16);
  ContiguousArray._checkIndex(_:)(a2);
  ContiguousArray._checkIndex(_:)(a3);
  if (a3 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  uint64_t v15 = *(unsigned __int8 *)(*(void *)(v11 - 8) + 80LL);
  void *v9 = v10;
  v9[1] = (char *)v10 + ((v15 + 32) & ~v15);
  void v9[2] = a2;
  uint64_t v9[3] = (2 * a3) | 1;
  swift_retain(v10, v12, v13, v14);
  return ContiguousArray.subscript.modify;
}

void ContiguousArray.subscript.modify(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
}

void Array.subscript.modify( void ***a1, uint64_t a2, void (*a3)(id, void *, void *, void *, void *, void *, void *), char *a4)
{
  uint64_t v5 = *a1;
  uint64_t v6 = **a1;
  uint64_t v7 = v5[1];
  uint64_t v8 = v5[2];
  uint64_t v9 = v5[3];
  uint64_t v10 = v5[6];
  uint64_t v12 = v5[4];
  uint64_t v11 = v5[5];
  if ((a2 & 1) != 0)
  {
    id v13 = swift_unknownObjectRetain(v6, a2, (uint64_t)a3, a4);
    a3(v13, v7, v8, v9, v12, v11, v10);
    swift_unknownObjectRelease(*v5);
  }

  else
  {
    a3(v6, v5[1], v5[2], v5[3], v5[4], v5[5], v5[6]);
  }

  free(v5);
}

uint64_t ContiguousArray.count.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance ContiguousArray<A>( uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  ContiguousArray._makeMutableAndUnique()();
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(a3 + 16);
  specialized Array._checkSubscript_mutating(_:)(v6, *v3);
  (*(void (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 40LL))( v7 + ((*(unsigned __int8 *)(*(void *)(v8 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v8 - 8) + 80LL))
  + *(void *)(*(void *)(v8 - 8) + 72LL) * v6,
    a1,
    v8);
  return EnumeratedSequence._base.modify();
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance ContiguousArray<A>( void *a1, unint64_t *a2))()
{
  uint64_t v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = ContiguousArray.subscript.modify((uint64_t)v4, *a2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance ContiguousArray<A>( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for MutableCollection.subscript.setter in conformance [A]( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void, void, void, uint64_t))ContiguousArray.subscript.setter);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance [A]( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void, void, void, void, uint64_t))
{
  return a5(*a1, a1[1], a1[2], a1[3], *a2, a2[1], a3);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance ContiguousArray<A>( void *a1, Swift::Int *a2, uint64_t a3))(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  _OWORD v7[4] = v3;
  v7[5] = a3;
  Swift::Int v9 = *a2;
  Swift::Int v8 = a2[1];
  v7[6] = *a2;
  v7[7] = v8;
  uint64_t v10 = *v3;
  uint64_t v11 = *(void *)(a3 + 16);
  ContiguousArray._checkIndex(_:)(v9);
  ContiguousArray._checkIndex(_:)(v8);
  if (v8 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  uint64_t v15 = *(unsigned __int8 *)(*(void *)(v11 - 8) + 80LL);
  *uint64_t v7 = v10;
  v7[1] = (char *)v10 + ((v15 + 32) & ~v15);
  v7[2] = v9;
  v7[3] = (2 * v8) | 1;
  swift_retain(v10, v12, v13, v14);
  return protocol witness for MutableCollection.subscript.modify in conformance ContiguousArray<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance ContiguousArray<A>( void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
}

void protocol witness for MutableCollection.subscript.modify in conformance [A]( void ***a1, uint64_t a2, void (*a3)(id, void *, void *, void *, void *, void *, void *), char *a4)
{
  uint64_t v5 = *a1;
  unint64_t v6 = **a1;
  uint64_t v7 = v5[1];
  Swift::Int v8 = v5[2];
  Swift::Int v9 = v5[3];
  uint64_t v11 = v5[6];
  uint64_t v10 = v5[7];
  uint64_t v12 = v5[5];
  if ((a2 & 1) != 0)
  {
    id v13 = swift_unknownObjectRetain(v6, a2, (uint64_t)a3, a4);
    a3(v13, v7, v8, v9, v11, v10, v12);
    swift_unknownObjectRelease(*v5);
  }

  else
  {
    a3(v6, v5[1], v5[2], v5[3], v5[6], v5[7], v5[5]);
  }

  free(v5);
}

void *protocol witness for MutableCollection.partition(by:) in conformance ContiguousArray<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void *protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance ContiguousArray<A>@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ContiguousArray.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a3, a2, a4);
}

void *ContiguousArray._withUnsafeMutableBufferPointerIfSupported<A>(_:)@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ContiguousArray._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3, a4);
}

{
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  void v14[2];
  uint64_t v15;
  uint64_t v15 = a3;
  ContiguousArray._makeMutableAndUnique()();
  Swift::Int v9 = *(void *)(*(void *)v4 + 16LL);
  uint64_t v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL);
  v14[0] = *(void *)v4 + ((v10 + 32) & ~v10);
  uint64_t v11 = v14[0];
  v14[1] = v9;
  a1(v14);
  if (v5) {
    return $defer #1 <A><A1>() in ContiguousArray.withUnsafeMutableBufferPointer<A>(_:)(v14, v11, v9);
  }
  id v13 = v15;
  $defer #1 <A><A1>() in ContiguousArray.withUnsafeMutableBufferPointer<A>(_:)(v14, v11, v9);
  return (void *)(*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56LL))( a4,  0LL,  1LL,  v13);
}

void *ContiguousArray.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ContiguousArray._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3, a4);
}

void protocol witness for Collection.endIndex.getter in conformance ContiguousArray<A>(void *a1@<X8>)
{
  *a1 = *(void *)(*(void *)v1 + 16LL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance ContiguousArray<A>( void *a1, unint64_t *a2))()
{
  uint64_t v5 = malloc(0x28uLL);
  *a1 = v5;
  v5[4] = ContiguousArray.subscript.read((uint64_t)v5, *a2, *v2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*ContiguousArray.subscript.read(uint64_t a1, unint64_t a2, uint64_t a3))()
{
  if ((a2 & 0x8000000000000000LL) != 0 || *(void *)(a3 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

id protocol witness for Collection.subscript.getter in conformance ContiguousArray<A>@<X0>( Swift::Int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (void *)specialized ContiguousArray.subscript.getter(*a1, a1[1], *v2);
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

uint64_t protocol witness for Collection.indices.getter in conformance ContiguousArray<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.count.getter in conformance ContiguousArray<A>()
{
  return ContiguousArray.count.getter(*v0);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance ContiguousArray<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, void, void))ContiguousArray._copyContents(initializing:));
}

unint64_t *ContiguousArray._copyContents(initializing:)( char *a1, uint64_t a2, unint64_t *a3, char *a4)
{
  uint64_t v5 = a3[2];
  if (v5)
  {
    if (!a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to copy contents into nil buffer pointer",  48LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x4C4uLL,  0);
    }
    if (v5 > a2) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x4C5uLL,  0);
    }
    uint64_t v8 = *(unsigned __int8 *)(*((void *)a4 - 1) + 80LL);
    Swift::Int v9 = (char *)a3 + ((v8 + 32) & ~v8);
    swift_retain(a3, a2, (uint64_t)a3, a4);
    UnsafeMutablePointer.initialize(from:count:)(v9, v5, a1, (uint64_t)a4);
    swift_release((uint64_t)a3);
  }

  return a3;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance ContiguousArray<A>@<X0>( uint64_t (*a1)(uint64_t, void)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ContiguousArray.withContiguousStorageIfAvailable<A>(_:)(a1, *v4, *(void *)(a3 + 16), a2, a4);
}

uint64_t ContiguousArray.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t, void)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v8 = *(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL);
  uint64_t result = a1(a2 + ((v8 + 32) & ~v8), *(void *)(a2 + 16));
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))(a5, 0LL, 1LL, a4);
  }
  return result;
}

uint64_t ContiguousArray.init(arrayLiteral:)(unint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    if ((a1 & 0x8000000000000000LL) != 0 || (a1 & 0x4000000000000000LL) != 0)
    {
      unint64_t v13 = a1;
      uint64_t v10 = type metadata accessor for Array(0LL, (uint64_t)a2, v5, (uint64_t)v6);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v10, v11);
      uint64_t v8 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v13, v10, WitnessTable);
      swift_bridgeObjectRelease(a1);
    }

    else
    {
      swift_bridgeObjectRetain(a1, v4, v5, v6);
      BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
      swift_bridgeObjectRelease(a1);
      if (isClassOrObjCExistentialType) {
        return a1 & 0xFFFFFFFFFFFFFF8LL;
      }
      else {
        return a1;
      }
    }
  }

  else if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    return a1 & 0xFFFFFFFFFFFFFF8LL;
  }

  else
  {
    return a1;
  }

  return (uint64_t)v8;
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance ContiguousArray<A>@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = ContiguousArray.init(arrayLiteral:)(a1, *(uint64_t **)(a2 + 16));
  *a3 = result;
  return result;
}

uint64_t ContiguousArray.init(repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Array.init(repeating:count:)( a1,  a2,  a3,  (uint64_t (*)(uint64_t, uint64_t))static ContiguousArray._allocateUninitialized(_:));
}

uint64_t Array.init(repeating:count:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  uint64_t v6 = specialized Array.init(repeating:count:)(a1, a2, a3, a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  return v6;
}

__objc2_class **static ContiguousArray._allocateUninitialized(_:)(uint64_t a1, uint64_t *a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct ContiguousArray with count < 0",  46LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x251uLL,  0);
  }
  if (!a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t result = static Array._allocateBufferUninitialized(minimumCapacity:)(a1, a2);
  result[2] = (__objc2_class *)a1;
  return result;
}

uint64_t _ContiguousArrayBuffer.init(_buffer:shiftedToStartIndex:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return EnumeratedSequence._base.modify(a1, a3);
}

__objc2_class **ContiguousArray.init(_uninitializedCount:)(uint64_t a1, uint64_t *a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct ContiguousArray with count < 0",  46LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x251uLL,  0);
  }
  if (!a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t result = static Array._allocateBufferUninitialized(minimumCapacity:)(a1, a2);
  result[2] = (__objc2_class *)a1;
  return result;
}

uint64_t specialized ContiguousArray._reserveCapacityImpl(minimumCapacity:growForAppend:)( uint64_t a1, uint64_t a2)
{
  return specialized ContiguousArray._reserveCapacityImpl(minimumCapacity:growForAppend:)( a1,  a2,  (uint64_t (*)(void))specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:));
}

{
  return specialized ContiguousArray._reserveCapacityImpl(minimumCapacity:growForAppend:)( a1,  a2,  (uint64_t (*)(void))specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:));
}

{
  return specialized ContiguousArray._reserveCapacityImpl(minimumCapacity:growForAppend:)( a1,  a2,  (uint64_t (*)(void))specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:));
}

uint64_t specialized ContiguousArray._reserveCapacityImpl(minimumCapacity:growForAppend:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = *v3;
  uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t *v3 = v5;
  if (!(_DWORD)result || a1 > *(void *)(v5 + 24) >> 1) {
    return a3();
  }
  return result;
}

uint64_t specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( uint64_t a1, int64_t a2, char a3)
{
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3,  (uint64_t)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>,  (uint64_t (*)(uint64_t, unint64_t, uint64_t))specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:),  (void (*)(uint64_t, uint64_t, uint64_t))specialized UnsafeMutablePointer.moveInitialize(from:count:),  (void (*)(void, uint64_t, uint64_t, uint64_t))specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:));
  uint64_t *v3 = result;
  return result;
}

{
  uint64_t *v3;
  uint64_t result;
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3,  (uint64_t)canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt32>,  (uint64_t (*)(uint64_t, unint64_t, uint64_t))specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:),  (void (*)(uint64_t, uint64_t, uint64_t))specialized UnsafeMutablePointer.moveInitialize(from:count:),  (void (*)(void, uint64_t, uint64_t, uint64_t))specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:));
  uint64_t *v3 = result;
  return result;
}

__objc2_class **specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **a1, int64_t a2, char a3)
{
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3);
  uint64_t *v3 = (uint64_t)result;
  return result;
}

{
  uint64_t *v3;
  __objc2_class **result;
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_DictionaryCodingKey>,  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.moveInitialize(from:count:),  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.initialize(from:count:));
  uint64_t *v3 = (uint64_t)result;
  return result;
}

{
  uint64_t *v3;
  __objc2_class **result;
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3);
  uint64_t *v3 = (uint64_t)result;
  return result;
}

{
  uint64_t *v3;
  __objc2_class **result;
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>,  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.moveInitialize(from:count:),  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.initialize(from:count:));
  uint64_t *v3 = (uint64_t)result;
  return result;
}

{
  uint64_t *v3;
  __objc2_class **result;
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3);
  uint64_t *v3 = (uint64_t)result;
  return result;
}

{
  uint64_t *v3;
  __objc2_class **result;
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Character>,  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.moveInitialize(from:count:),  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.initialize(from:count:));
  uint64_t *v3 = (uint64_t)result;
  return result;
}

Swift::Void __swiftcall ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( Swift::Bool bufferIsUnique, Swift::Int minimumCapacity, Swift::Bool growForAppend)
{
  uint64_t *v4 = (uint64_t)_ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)bufferIsUnique,  minimumCapacity,  growForAppend,  *v4,  *(uint64_t **)(v3 + 16));
}

uint64_t specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( uint64_t result, int64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, unint64_t, uint64_t), void (*a7)(uint64_t, uint64_t, uint64_t), void (*a8)(void, uint64_t, uint64_t, uint64_t))
{
  char v11 = result;
  if ((a3 & 1) != 0)
  {
    unint64_t v12 = *(void *)(a4 + 24);
    unint64_t v13 = v12 >> 1;
    if ((uint64_t)(v12 >> 1) < a2)
    {
      if ((uint64_t)(v13 + 0x4000000000000000LL) < 0)
      {
        __break(1u);
        return result;
      }

      unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    unint64_t v13 = a2;
  }

  uint64_t v14 = *(void *)(a4 + 16);
  uint64_t v15 = a6(v14, v13, a5);
  uint64_t v16 = v15 + 32;
  if ((v11 & 1) != 0)
  {
    a7(a4 + 32, v14, v16);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    a8(0LL, v14, v16, a4);
  }

  swift_release(a4);
  return v15;
}

__objc2_class **specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **result, int64_t a2, char a3, uint64_t a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  uint64_t v8 = *(void *)(a4 + 16);
  if (v7 <= v8) {
    uint64_t v9 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<CodingKey>);
    char v11 = (__objc2_class **)swift_allocObject(v10, 40 * v9 + 32, 7uLL);
    size_t v12 = _swift_stdlib_malloc_size(v11);
    v11[2] = (__objc2_class *)v8;
    uint64_t v11[3] = (__objc2_class *)(2 * ((uint64_t)(v12 - 32) / 40));
  }

  else
  {
    char v11 = &_swiftEmptyArrayStorage;
  }

  unint64_t v13 = (char *)(v11 + 4);
  uint64_t v14 = (char *)(a4 + 32);
  if ((v5 & 1) != 0)
  {
    specialized UnsafeMutablePointer.moveInitialize(from:count:)(v14, v8, v13);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    specialized UnsafeMutablePointer.initialize(from:count:)( v14,  v8,  v13,  &demangling cache variable for type metadata for CodingKey);
  }

  swift_release(a4);
  return v11;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  size_t v12;
  char *v13;
  char *v14;
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  uint64_t v8 = *(void *)(a4 + 16);
  if (v7 <= v8) {
    uint64_t v9 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int8>();
    char v11 = (__objc2_class **)swift_allocObject(v10, v9 + 32, 7uLL);
    size_t v12 = _swift_stdlib_malloc_size(v11);
    v11[2] = (__objc2_class *)v8;
    uint64_t v11[3] = (__objc2_class *)(2 * v12 - 64);
  }

  else
  {
    char v11 = &_swiftEmptyArrayStorage;
  }

  unint64_t v13 = (char *)(v11 + 4);
  uint64_t v14 = (char *)(a4 + 32);
  if ((v5 & 1) != 0)
  {
    specialized UnsafeMutablePointer.moveInitialize(from:count:)( v14,  v8,  v13,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    specialized UnsafeMutablePointer.initialize(from:count:)(v14, v8, v13);
  }

  swift_release(a4);
  return v11;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  uint64_t v8 = *(void *)(a4 + 16);
  if (v7 <= v8) {
    uint64_t v9 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
    char v11 = (__objc2_class **)swift_allocObject(v10, 8 * v9 + 32, 7uLL);
    size_t v12 = _swift_stdlib_malloc_size(v11);
    unint64_t v13 = v12 - 32;
    if (v12 < 32) {
      unint64_t v13 = v12 - 25;
    }
    v11[2] = (__objc2_class *)v8;
    uint64_t v11[3] = (__objc2_class *)((2 * (v13 >> 3)) | 1);
  }

  else
  {
    char v11 = &_swiftEmptyArrayStorage;
  }

  uint64_t v14 = (char *)(v11 + 4);
  uint64_t v15 = (char *)(a4 + 32);
  if ((v5 & 1) != 0)
  {
    specialized UnsafeMutablePointer.moveInitialize(from:count:)(v15, v8, v14);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    specialized UnsafeMutablePointer.initialize(from:count:)(v15, v8, v14);
  }

  swift_release(a4);
  return v11;
}

__objc2_class **specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **a1, int64_t a2, char a3, uint64_t a4)
{
  return specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>,  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.moveInitialize(from:count:),  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.initialize(from:count:));
}

{
  return specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>,  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.moveInitialize(from:count:),  (void (*)(uint64_t, __objc2_class *, __objc2_class **))specialized UnsafeMutablePointer.initialize(from:count:));
}

__objc2_class **specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **result, int64_t a2, char a3, uint64_t a4, uint64_t (*a5)(void), void (*a6)(uint64_t, __objc2_class *, __objc2_class **), void (*a7)(uint64_t, __objc2_class *, __objc2_class **))
{
  char v10 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v11 = *(void *)(a4 + 24);
    uint64_t v12 = v11 >> 1;
    if ((uint64_t)(v11 >> 1) < a2)
    {
      if (v12 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v12 = a2;
  }

  unint64_t v13 = *(__objc2_class **)(a4 + 16);
  else {
    uint64_t v14 = v12;
  }
  if (v14)
  {
    uint64_t v15 = a5(0LL);
    uint64_t v16 = (__objc2_class **)swift_allocObject(v15, 32 * v14 + 32, 7uLL);
    int64_t v17 = _swift_stdlib_malloc_size(v16);
    uint64_t v18 = v17 - 32;
    if (v17 < 32) {
      uint64_t v18 = v17 - 1;
    }
    v16[2] = v13;
    v16[3] = (__objc2_class *)(2 * (v18 >> 5));
  }

  else
  {
    uint64_t v16 = &_swiftEmptyArrayStorage;
  }

  uint64_t v19 = v16 + 4;
  uint64_t v20 = a4 + 32;
  if ((v10 & 1) != 0)
  {
    a6(v20, v13, v19);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    a7(v20, v13, v19);
  }

  swift_release(a4);
  return v16;
}

{
  char v10;
  unint64_t v11;
  uint64_t v12;
  __objc2_class *v13;
  uint64_t v14;
  uint64_t v15;
  __objc2_class **v16;
  int64_t v17;
  uint64_t v18;
  __objc2_class **v19;
  uint64_t v20;
  char v10 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v11 = *(void *)(a4 + 24);
    uint64_t v12 = v11 >> 1;
    if ((uint64_t)(v11 >> 1) < a2)
    {
      if (v12 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v12 = a2;
  }

  unint64_t v13 = *(__objc2_class **)(a4 + 16);
  else {
    uint64_t v14 = v12;
  }
  if (v14)
  {
    uint64_t v15 = a5(0LL);
    uint64_t v16 = (__objc2_class **)swift_allocObject(v15, 16 * v14 + 32, 7uLL);
    int64_t v17 = _swift_stdlib_malloc_size(v16);
    uint64_t v18 = v17 - 32;
    if (v17 < 32) {
      uint64_t v18 = v17 - 17;
    }
    v16[2] = v13;
    v16[3] = (__objc2_class *)(2 * (v18 >> 4));
  }

  else
  {
    uint64_t v16 = &_swiftEmptyArrayStorage;
  }

  uint64_t v19 = v16 + 4;
  uint64_t v20 = a4 + 32;
  if ((v10 & 1) != 0)
  {
    a6(v20, v13, v19);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    a7(v20, v13, v19);
  }

  swift_release(a4);
  return v16;
}

__objc2_class **_ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **result, int64_t a2, char a3, uint64_t a4, uint64_t *a5)
{
  char v7 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v8 = *(void *)(a4 + 24);
    uint64_t v9 = v8 >> 1;
    if ((uint64_t)(v8 >> 1) < a2)
    {
      if (v9 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v9 = v8 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v9 = a2;
  }

  uint64_t v10 = *(void *)(a4 + 16);
  if (v9 <= v10) {
    uint64_t v11 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v11 = v9;
  }
  if (v11)
  {
    uint64_t v12 = getContiguousArrayStorageType<A>(for:)((uint64_t)a5, a5);
    uint64_t v13 = *(a5 - 1);
    uint64_t v14 = *(void *)(v13 + 72);
    uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
    uint64_t v16 = (__objc2_class **)swift_allocObject( v12,  ((v15 + *(unsigned int *)(v12 + 48)) & ~v15) + v14 * v11,  v15 | *(unsigned __int16 *)(v12 + 52));
    size_t v17 = _swift_stdlib_malloc_size(v16);
    if (!v14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }
    uint64_t v21 = (v15 + 32) & ~v15;
    if (v17 - v21 == 0x8000000000000000LL && v14 == -1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
    }
    uint64_t v23 = (uint64_t)(v17 - v21) / v14;
    swift_retain((unint64_t *)v16, v18, v19, v20);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
    v16[2] = (__objc2_class *)v10;
    v16[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v23));
    swift_release((uint64_t)v16);
  }

  else
  {
    uint64_t v25 = *(unsigned __int8 *)(*(a5 - 1) + 80);
    uint64_t v21 = (v25 + 32) & ~v25;
    uint64_t v16 = &_swiftEmptyArrayStorage;
  }

  uint64_t v26 = (char *)v16 + v21;
  Swift::Int v27 = (char *)(a4 + v21);
  if ((v7 & 1) != 0)
  {
    UnsafeMutablePointer.moveInitialize(from:count:)(v27, v10, v26, (uint64_t)a5);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    UnsafeMutablePointer.initialize(from:count:)(v27, v10, v26, (uint64_t)a5);
  }

  swift_release(a4);
  return v16;
}

Swift::Void __swiftcall ContiguousArray._copyToNewBuffer(oldCount:)(Swift::Int oldCount)
{
  uint64_t v6 = oldCount + 1;
  uint64_t v14 = *v4;
  uint64_t v7 = type metadata accessor for _ContiguousArrayBuffer(0LL, *(void *)(v1 + 16), v2, v3);
  uint64_t WitnessTable = (uint64_t (**)(uint64_t, uint64_t, char *))swift_getWitnessTable( &protocol conformance descriptor for _ContiguousArrayBuffer<A>,  v7,  v8);
  uint64_t v10 = (unint64_t *)_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(countForNewBuffer:minNewCapacity:)( oldCount,  v6,  v7,  (uint64_t)WitnessTable);
  uint64_t v14 = v10;
  uint64_t v11 = default argument 3 of _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)(v7, (uint64_t)WitnessTable);
  uint64_t v13 = v12;
  _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( &v14,  oldCount,  0LL,  (void (*)(char *, uint64_t))v11,  v12,  v7,  WitnessTable);
  swift_release(v13);
  swift_release((uint64_t)v10);
}

uint64_t specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()()
{
  return specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()((uint64_t (*)(void, uint64_t, uint64_t))specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:));
}

{
  return specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()((uint64_t (*)(void, uint64_t, uint64_t))specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:));
}

{
  return specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()((uint64_t (*)(void, uint64_t, uint64_t))specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:));
}

uint64_t specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()( uint64_t (*a1)(void, uint64_t, uint64_t))
{
  uint64_t v2 = *v1;
  uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v1);
  uint64_t *v1 = v2;
  if ((result & 1) == 0) {
    return a1(0LL, *(void *)(v2 + 16) + 1LL, 1LL);
  }
  return result;
}

Swift::Void __swiftcall ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()()
{
  uint64_t v1 = *v0;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
  uint64_t *v0 = v1;
  if (!isUniquelyReferenced_nonNull_native) {
    ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v1 + 16) + 1LL, 1);
  }
}

__objc2_class **specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)( __objc2_class **result)
{
  unint64_t v2 = *(void *)(*(void *)v1 + 24LL);
  if ((uint64_t)result + 1 > (uint64_t)(v2 >> 1)) {
    return specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v2 > 1),  (int64_t)result + 1,  1);
  }
  return result;
}

Swift::Void __swiftcall ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)(Swift::Int oldCount)
{
  unint64_t v2 = *(void *)(*(void *)v1 + 24LL);
}

uint64_t specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *v3;
  *(void *)(v4 + 16) = result + 1;
  uint64_t v5 = v4 + 16 * result;
  *(void *)(v5 + 32) = a2;
  *(void *)(v5 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = a3;
  return result;
}

_OWORD *specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)( uint64_t a1, _OWORD *a2)
{
  uint64_t v3 = *v2;
  *(void *)(v3 + 16) = a1 + 1;
  return outlined init with take of Any(a2, (_OWORD *)(v3 + 32 * a1 + 32));
}

uint64_t specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)( uint64_t result, uint64_t a2)
{
  uint64_t v3 = *v2;
  *(void *)(v3 + 16) = result + 1;
  *(void *)(v3 + 8 * result + 32) = a2;
  return result;
}

uint64_t ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *v3;
  *(void *)(v4 + 16) = a1 + 1;
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  return (*(uint64_t (**)(unint64_t))(v5 + 32))( v4 + ((*(unsigned __int8 *)(v5 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80))
         + *(void *)(v5 + 72) * a1);
}

uint64_t specialized ContiguousArray.append<A>(contentsOf:)(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *v1;
  int64_t v4 = *(void *)(*v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
LABEL_59:
    __break(1u);
    goto LABEL_60;
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  uint64_t *v1 = v3;
  if (!isUniquelyReferenced_nonNull_native || (int64_t v8 = *(void *)(v3 + 24) >> 1, v8 < v5))
  {
    if (v4 <= v5) {
      int64_t v9 = v4 + v2;
    }
    else {
      int64_t v9 = v4;
    }
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( isUniquelyReferenced_nonNull_native,  v9,  1);
    uint64_t v3 = *v1;
    int64_t v8 = *(void *)(*v1 + 24) >> 1;
  }

  uint64_t v10 = *(void *)(v3 + 16);
  uint64_t v11 = v8 - v10;
  if (v8 - v10 < 0) {
LABEL_60:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  uint64_t result = specialized Sequence._copySequenceContents(initializing:)(&v50, v3 + 16 * v10 + 32, v11, a1);
  if (result < v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x35AuLL,  0);
  }
  if (result)
  {
    uint64_t v15 = *(void *)(v3 + 16);
    BOOL v16 = __OFADD__(v15, result);
    uint64_t v17 = v15 + result;
    if (v16)
    {
      __break(1u);
      goto LABEL_63;
    }

    *(void *)(v3 + 16) = v17;
  }

  if (result == v11)
  {
    uint64_t v18 = v3;
    uint64_t v19 = *(void *)(v3 + 16);
    uint64_t v20 = v50;
    uint64_t v48 = v1;
    uint64_t v49 = v51;
    uint64_t v21 = v53;
    if (v54)
    {
      unint64_t v22 = (v54 - 1) & v54;
      unint64_t v23 = __clz(__rbit64(v54)) | (v53 << 6);
      int64_t v24 = (unint64_t)(v52 + 64) >> 6;
LABEL_16:
      uint64_t v25 = (uint64_t *)(*(void *)(v50 + 48) + 16 * v23);
      uint64_t v26 = *v25;
      unint64_t v27 = v25[1];
      uint64_t v53 = v21;
      unint64_t v54 = v22;
      swift_bridgeObjectRetain(v27, v13, v52, v14);
      for (uint64_t i = v18; ; *(void *)(i + 16) = v19)
      {
        while (1)
        {
          unint64_t v31 = *(void *)(i + 24);
          int64_t v32 = v19 + 1;
          uint64_t v33 = *v48;
          uint64_t v34 = *(void *)(*v48 + 24) >> 1;
          if (v19 < v34) {
            break;
          }
          uint64_t i = *v48;
          *(void *)(v33 + 16) = v19;
        }

        uint64_t i = *v48;
        uint64_t v35 = v33 + 32;
        do
        {
          uint64_t v39 = (void *)(v35 + 16 * v19);
          *uint64_t v39 = v26;
          v39[1] = v27;
          ++v19;
          if (v22)
          {
            unint64_t v36 = __clz(__rbit64(v22));
            v22 &= v22 - 1;
            unint64_t v37 = v36 | (v21 << 6);
          }

          else
          {
            int64_t v40 = v21 + 1;
            if (__OFADD__(v21, 1LL))
            {
              __break(1u);
              goto LABEL_59;
            }

            if (v40 >= v24) {
              goto LABEL_41;
            }
            unint64_t v41 = *(void *)(v49 + 8 * v40);
            uint64_t v42 = v21 + 1;
            if (!v41)
            {
              uint64_t v42 = v21 + 2;
              if (v21 + 2 >= v24) {
                goto LABEL_41;
              }
              unint64_t v41 = *(void *)(v49 + 8 * v42);
              if (!v41)
              {
                uint64_t v42 = v21 + 3;
                if (v21 + 3 >= v24) {
                  goto LABEL_41;
                }
                unint64_t v41 = *(void *)(v49 + 8 * v42);
                if (!v41)
                {
                  uint64_t v42 = v21 + 4;
                  if (v21 + 4 >= v24)
                  {
LABEL_41:
                    uint64_t v3 = i;
                    *(void *)(i + 16) = v19;
                    uint64_t result = outlined consume of [A : B].Iterator._Variant<A, B>(v20);
                    uint64_t v1 = v48;
                    goto LABEL_57;
                  }

                  unint64_t v41 = *(void *)(v49 + 8 * v42);
                  if (!v41)
                  {
                    uint64_t v43 = v21 + 5;
                    do
                    {
                      if (v24 == v43) {
                        goto LABEL_41;
                      }
                      unint64_t v41 = *(void *)(v49 + 8 * v43++);
                    }

                    while (!v41);
                    uint64_t v42 = v43 - 1;
                  }
                }
              }
            }

            unint64_t v22 = (v41 - 1) & v41;
            unint64_t v37 = __clz(__rbit64(v41)) + (v42 << 6);
            uint64_t v21 = v42;
          }

          uint64_t v38 = (uint64_t *)(*(void *)(v20 + 48) + 16 * v37);
          uint64_t v26 = *v38;
          unint64_t v27 = v38[1];
          swift_bridgeObjectRetain(v27, v32, v28, v29);
        }

        while (v19 < v34);
      }
    }

    int64_t v44 = v53 + 1;
    if (!__OFADD__(v53, 1LL))
    {
      int64_t v24 = (unint64_t)(v52 + 64) >> 6;
      if (v44 < v24)
      {
        unint64_t v45 = *(void *)(v51 + 8 * v44);
        uint64_t v46 = v53 + 1;
        if (v45)
        {
LABEL_45:
          unint64_t v22 = (v45 - 1) & v45;
          unint64_t v23 = __clz(__rbit64(v45)) + (v46 << 6);
          uint64_t v21 = v46;
          goto LABEL_16;
        }

        uint64_t v46 = v53 + 2;
        if (v53 + 2 < v24)
        {
          unint64_t v45 = *(void *)(v51 + 8 * v46);
          if (v45) {
            goto LABEL_45;
          }
          uint64_t v46 = v53 + 3;
          if (v53 + 3 < v24)
          {
            unint64_t v45 = *(void *)(v51 + 8 * v46);
            if (v45) {
              goto LABEL_45;
            }
            uint64_t v46 = v53 + 4;
            if (v53 + 4 < v24)
            {
              unint64_t v45 = *(void *)(v51 + 8 * v46);
              if (!v45)
              {
                uint64_t v47 = v53 + 5;
                do
                {
                  if (v24 == v47) {
                    goto LABEL_56;
                  }
                  unint64_t v45 = *(void *)(v51 + 8 * v47++);
                }

                while (!v45);
                uint64_t v46 = v47 - 1;
              }

              goto LABEL_45;
            }
          }
        }
      }

      goto LABEL_56;
    }

LABEL_63:
    __break(1u);
    return result;
  }

  uint64_t v39 = (unint64_t)result[3];
  if (v39 >= 2)
  {
    int64_t v40 = v39 >> 1;
    int64_t v8 = __OFSUB__(v40, v11);
    unint64_t v41 = (__objc2_class *)(v40 - v11);
    if (v8)
    {
LABEL_74:
      __break(1u);
LABEL_75:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x429uLL,  0);
    }

    result[2] = v41;
  }

  return result;
}

    uint64_t v58 = (v67 - 1) & v67;
    unint64_t v61 = __clz(__rbit64(v67)) + (v55 << 6);
LABEL_48:
    uint64_t v62 = 40 * v61;
    outlined init with copy of AnyHashable(*(void *)(v23 + 48) + 40 * v61, (uint64_t)&v123);
    unint64_t v63 = v28[6] + v62;
    uint64_t v64 = v123;
    uint64_t v65 = v124;
    *(void *)(v63 + 32) = v125;
    *(_OWORD *)unint64_t v63 = v64;
    *(_OWORD *)(v63 + 16) = v65;
  }

  uint64_t v68 = v66 + 3;
  if (v68 >= v59) {
    goto LABEL_87;
  }
  uint64_t v67 = *(void *)(v53 + 8 * v68);
  if (v67)
  {
    unint64_t v55 = v68;
    goto LABEL_63;
  }

  while (1)
  {
    unint64_t v55 = v68 + 1;
    if (__OFADD__(v68, 1LL)) {
      goto LABEL_111;
    }
    if (v55 >= v59) {
      break;
    }
    uint64_t v67 = *(void *)(v53 + 8 * v55);
    ++v68;
    if (v67) {
      goto LABEL_63;
    }
  }

              uint64_t v119 = _StringGuts.uniqueNativeCapacity.getter();
              if ((v120 & 1) != 0 || v119 < Description) {
                _StringGuts.grow(_:)(Description);
              }
              goto LABEL_66;
            }

            goto LABEL_181;
          }

          __break(1u);
LABEL_180:
          __break(1u);
LABEL_181:
          __break(1u);
LABEL_182:
          __break(1u);
          goto LABEL_183;
        }
      }

      else
      {
        uint64_t v111 = _StringObject.sharedUTF8.getter(v271, v272);
        uint64_t v112 = v250;
        if (v250 >= v110) {
          goto LABEL_57;
        }
      }
    }

          BOOL v196 = v227;
          ((void (*)(uint64_t, uint64_t))v249)(a2, v136);
          v144(v196, a2);
          return v73;
        }

        char v212 = v250;
        (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v136 + 96))( &v252,  &type metadata for UInt64,  v247,  a2,  v136);
        char v213 = v240;
        uint64_t v214 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v136 + 32) + 8LL) + 16LL))( v212,  v240,  a2);
        uint64_t v144 = v245;
        v245(v212, a2);
        v144(v213, a2);
        if ((v214 & 1) != 0) {
          goto LABEL_74;
        }
        goto LABEL_63;
      }

      v154(v229, v150, a2);
      uint64_t v252 = -1LL;
      uint64_t v164 = v151(a2, v136);
      uint64_t v165 = v163(a2, v136);
      if ((v164 & 1) != 0)
      {
        if (v165 < 65)
        {
          uint64_t v166 = v237;
          uint64_t v167 = v238;
          uint64_t v168 = swift_getAssociatedConformanceWitness( (uint64_t)v238,  a2,  v237,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v169 = v236;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v168 + 8))( &qword_18180BE68,  256LL,  v166,  v168);
          uint64_t v170 = v250;
          Swift::String::Index v171 = v169;
          uint64_t v144 = v245;
          (*((void (**)(char *, uint64_t, const char *))v167 + 3))(v171, a2, v167);
          uint64_t v172 = v229;
          LOBYTE(v166) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v136 + 32) + 8LL)
                                                                            + 40LL))( v229,  v170,  a2);
          v144(v170, a2);
          unint64_t v173 = v252;
          uint64_t v174 = v221;
          v154(v221, v172, a2);
          if ((v166 & 1) != 0)
          {
            uint64_t v175 = (*(uint64_t (**)(uint64_t, uint64_t))(v136 + 120))(a2, v136);
            v144(v174, a2);
            uint64_t v163 = v235;
            uint64_t v176 = v229;
            if (v173 < v175) {
              goto LABEL_53;
            }
          }

          else
          {
            v144(v174, a2);
            uint64_t v163 = v235;
            uint64_t v176 = v229;
          }

          goto LABEL_56;
        }
      }

      else if (v165 <= 64)
      {
        unint64_t v179 = v250;
        uint64_t v176 = v229;
        v154(v250, v229, a2);
        uint64_t v180 = (*(uint64_t (**)(uint64_t, uint64_t))(v136 + 120))(a2, v136);
        v144(v179, a2);
        if (v252 < v180) {
          goto LABEL_53;
        }
LABEL_56:
        v144(v176, a2);
        uint64_t v150 = v241;
        uint64_t v153 = v233;
        goto LABEL_57;
      }

      unint64_t v177 = v250;
      (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v136 + 96))( &v252,  &type metadata for UInt64,  v247,  a2,  v136);
      uint64_t v176 = v229;
      unint64_t v178 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v136 + 32) + 8LL) + 16LL))( v177,  v229,  a2);
      v144(v177, a2);
      if ((v178 & 1) != 0) {
LABEL_53:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
      goto LABEL_56;
    }
  }

  else
  {
    unint64_t v89 = *(void (**)(char *, unint64_t *))(v60 + 8);
    v89(v81, v9);
  }

  uint64_t v91 = v223;
  uint64_t v92 = *(uint64_t (**)(unint64_t *, unint64_t))(v223 + 128);
  uint64_t v93 = v92(v9, v223);
  uint64_t v94 = v239;
  v80(v239, v76, v9);
  if (v93 <= 63)
  {
    v89(v94, v9);
    uint64_t v95 = v245;
    uint64_t v96 = v228;
    goto LABEL_24;
  }

  uint64_t v252 = -1LL;
  uint64_t v103 = v219(v9, v91);
  uint64_t v104 = v92(v9, v91);
  uint64_t v96 = v228;
  if ((v103 & 1) != 0)
  {
    uint64_t v107 = v89;
    uint64_t v108 = v247;
    if (v104 < 65)
    {
      uint64_t v122 = v232;
      uint64_t v123 = v231;
      uint64_t v124 = swift_getAssociatedConformanceWitness( (uint64_t)v232,  (uint64_t)v9,  v231,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v125 = v230;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v124 + 8))( &qword_18180BE68,  256LL,  v123,  v124);
      uint64_t v126 = v243;
      (*((void (**)(char *, unint64_t *, const char *))v122 + 3))(v125, v9, v122);
      uint64_t v127 = swift_getAssociatedConformanceWitness( v249,  a2,  (uint64_t)v9,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v123) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v127 + 40))( v94,  v126,  v9,  v127);
      v107(v126, v9);
      unint64_t v128 = v252;
      uint64_t v129 = *(void (**)(char *, char *, unint64_t *))(v108 + 32);
      uint64_t v130 = v222;
      v129(v222, v94, v9);
      uint64_t v95 = v245;
      if ((v123 & 1) != 0)
      {
        uint64_t v91 = v223;
        uint64_t v131 = (*(uint64_t (**)(unint64_t *, unint64_t))(v223 + 120))(v9, v223);
        v107(v130, v9);
        unint64_t v132 = v128 >= v131;
        uint64_t v74 = v249;
        unint64_t v89 = v107;
        if (!v132) {
          goto LABEL_39;
        }
      }

      else
      {
        v107(v130, v9);
        uint64_t v74 = v249;
        uint64_t v91 = v223;
        unint64_t v89 = v107;
      }
    }

    else
    {
      uint64_t v109 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v91 + 96);
      uint64_t v110 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v104, v105, v106);
      uint64_t v111 = v243;
      v109(&v252, &type metadata for UInt64, v110, v9, v91);
      uint64_t v74 = v249;
      uint64_t v112 = swift_getAssociatedConformanceWitness( v249,  a2,  (uint64_t)v9,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      uint64_t v113 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v112 + 16))( v111,  v94,  v9,  v112);
      uint64_t v114 = v111;
      unint64_t v89 = v107;
      v107(v114, v9);
      v107(v94, v9);
      uint64_t v95 = v245;
      if ((v113 & 1) != 0) {
        goto LABEL_39;
      }
    }
  }

  else if (v104 < 65)
  {
    uint64_t v133 = v243;
    (*(void (**)(char *, char *, unint64_t *))(v247 + 32))(v243, v94, v9);
    uint64_t v134 = (*(uint64_t (**)(unint64_t *, unint64_t))(v91 + 120))(v9, v91);
    v89(v133, v9);
    uint64_t v95 = v245;
    uint64_t v74 = v249;
    if (v252 < v134)
    {
LABEL_39:
      uint64_t v76 = v246;
      goto LABEL_40;
    }
  }

  else
  {
    uint64_t v115 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v91 + 96);
    uint64_t v116 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v104, v105, v106);
    uint64_t v117 = v89;
    int v118 = v243;
    v115(&v252, &type metadata for UInt64, v116, v9, v91);
    uint64_t v74 = v249;
    uint64_t v119 = swift_getAssociatedConformanceWitness( v249,  a2,  (uint64_t)v9,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    uint64_t v120 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v119 + 16))( v118,  v94,  v9,  v119);
    uint64_t v121 = v118;
    unint64_t v89 = v117;
    v117(v121, v9);
    v117(v94, v9);
    uint64_t v95 = v245;
    if ((v120 & 1) != 0) {
      goto LABEL_39;
    }
  }

  uint64_t v92 = 0LL;
  uint64_t v93 = (uint8x16_t *)((char *)TypeName + v81);
  uint64_t v91 = 1;
  uint64_t v94 = TypeName;
  uint64_t v95 = TypeName;
  while (1)
  {
    uint64_t v98 = v95->i8[0];
    uint64_t v95 = (uint8x16_t *)((char *)v95 + 1);
    uint64_t v97 = v98;
    if (v98 < 0) {
      break;
    }
    uint64_t v96 = 1LL;
LABEL_65:
    v92 += v96;
    uint64_t v94 = v95;
    if (v95 == v93)
    {
      if (v81 > 15) {
        goto LABEL_104;
      }
      goto LABEL_114;
    }
  }

  if (v97 <= 0xDFu)
  {
    if (v95 == v93 || (v95->i8[0] & 0xC0) != 0x80) {
      goto LABEL_105;
    }
    uint64_t v91 = 0;
    uint64_t v95 = (uint8x16_t *)&v94->i16[1];
    uint64_t v96 = 2LL;
    goto LABEL_65;
  }

  if (v97 == 224)
  {
    if (v95 == v93 || (v94->i8[1] & 0xE0) != 0xA0) {
      goto LABEL_105;
    }
    goto LABEL_85;
  }

  if (v97 <= 0xECu) {
    goto LABEL_82;
  }
  if (v97 == 237)
  {
    if (v95 == v93) {
      goto LABEL_105;
    }
    unint64_t v99 = v94->u8[1];
    if (v99 > 0x9F) {
      goto LABEL_105;
    }
    goto LABEL_84;
  }

  if (v97 <= 0xEFu)
  {
LABEL_82:
    if (v95 == v93) {
      goto LABEL_105;
    }
    LOBYTE(v99) = v94->i8[1];
LABEL_84:
    if ((v99 & 0xC0) != 0x80) {
      goto LABEL_105;
    }
LABEL_85:
    uint64_t v91 = 0;
    uint64_t v95 = (uint8x16_t *)((char *)v94->i32 + 3);
    uint64_t v96 = 3LL;
    goto LABEL_65;
  }

  if (v97 == 240)
  {
    goto LABEL_98;
  }

  if ((v97 + 15) <= 2u)
  {
    if (v95 == v93) {
      goto LABEL_105;
    }
    LOBYTE(v10swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v94->i8[1];
LABEL_97:
    if ((v100 & 0xC0) != 0x80) {
      goto LABEL_105;
    }
LABEL_98:
    if (&v94->i16[1] == (__int16 *)v93
      || (v94->i8[2] & 0xC0) != 0x80
      || (uint8x16_t *)((char *)v94->i32 + 3) == v93
      || (v94->i8[3] & 0xC0) != 0x80)
    {
      goto LABEL_105;
    }

    uint64_t v91 = 0;
    uint64_t v95 = (uint8x16_t *)((char *)v94->i64 + 4);
    uint64_t v96 = 4LL;
    goto LABEL_65;
  }

  if (v95 != v93)
  {
    uint64_t v100 = v94->u8[1];
    if (v100 <= 0x8F) {
      goto LABEL_97;
    }
  }

  foreign_type_protocol_conformance = _dyld_find_protocol_conformance_on_disk();
LABEL_64:
  int64_t v9 = v22;
  if (foreign_type_protocol_conformance == 1) {
    goto LABEL_6;
  }
LABEL_65:
  if (foreign_type_protocol_conformance == 3) {
    return 0LL;
  }
  if (foreign_type_protocol_conformance) {
    goto LABEL_7;
  }
  if ((*(_DWORD *)(v9 + 12) & 0x20000) != 0
    && v9
     + 4 * (((unint64_t)*(unsigned int *)(v9 + 12) >> 6) & 1)
     + 12LL * BYTE1(*(_DWORD *)(v9 + 12))
     + 8LL * HIBYTE(*(_DWORD *)(v9 + 12))
     + 19 > 3)
  {
    uint64_t WitnessTable = 0LL;
  }

  else
  {
    uint64_t WitnessTable = swift::TargetProtocolConformanceDescriptor<swift::InProcess>::getWitnessTable( v9,  (uint64_t)v4,  a3,  a4);
  }

              unint64_t v27 = (unsigned __int16 *)swift::Demangle::__runtime::Demangler::popContext(this, a2, a3, a4, a5);
              int64_t v32 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
              if (v12) {
                goto LABEL_64;
              }
              goto LABEL_60;
            }
          }

          else
          {
            uint64_t v18 = 0LL;
            if (!v17) {
              goto LABEL_44;
            }
          }

          if (v16)
          {
            uint64_t v19 = v16 - 1;
            uint64_t v20 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * (v16 - 1));
            if (*((_WORD *)v20 + 8) == 176)
            {
              *uint64_t v15 = v19;
              if ((v12 & 1) == 0)
              {
                uint64_t v12 = 0;
                uint64_t v21 = 0LL;
                if (v16 == 1) {
                  goto LABEL_63;
                }
                goto LABEL_46;
              }

              goto LABEL_30;
            }

            goto LABEL_44;
          }
        }

        else
        {
          uint64_t v18 = 0LL;
        }

        uint64_t v19 = 0;
        uint64_t v20 = 0LL;
        if (!v12) {
          goto LABEL_45;
        }
        goto LABEL_30;
      default:
        return (unint64_t)v8;
    }
  }

  return 0LL;
}

LABEL_56:
  uint64_t result = outlined consume of [A : B].Iterator._Variant<A, B>(v50);
LABEL_57:
  uint64_t *v1 = v3;
  return result;
}

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x83uLL,  0);
      }

            v256((char *)v292, a2);
            goto LABEL_3;
          }
        }

        (*(void (**)(char *, char *, uint64_t))(v84 + 32))(v83, v290, v78);
        uint64_t v182 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
        ((void (*)(char *, uint64_t))v291)(v83, v78);
        if (v294 >= v182) {
          goto LABEL_62;
        }
        goto LABEL_56;
      }
    }

    else
    {
      uint64_t v64 = v289;
      uint64_t v65 = *(void (**)(char *, uint64_t, swift *))(v289 + 16);
      v65(v59, v292, a2);
      unint64_t v66 = v60;
    }

    uint64_t v68 = v291;
    uint64_t v69 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 376))(a2, v66);
    goto LABEL_9;
  }

  (*(void (**)(uint64_t, swift *))(v42 + 8))(a1, a2);
LABEL_3:
  unint64_t v61 = 0;
  uint64_t v62 = 1;
  return v61 | (v62 << 16);
}

        v251((char *)v287, a2);
        return 0LL;
      }
    }

    (*(void (**)(char *, char *, uint64_t))(v83 + 32))(v82, v285, v77);
    unint64_t v178 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
    ((void (*)(char *, uint64_t))v286)(v82, v77);
    if (v289 >= v178) {
      goto LABEL_62;
    }
    goto LABEL_56;
  }

                          __break(1u);
LABEL_57:
                          __break(1u);
                          __break(1u);
                          __break(1u);
                          goto LABEL_58;
                        }

          uint64_t v46 = HIBYTE(v11) & 0xF;
          uint64_t v47 = HIBYTE(v45) & 0xF;
          uint64_t v48 = v47 + v46;
          if ((unint64_t)(v47 + v46) <= 0xF)
          {
            if (v47)
            {
              uint64_t v49 = 0;
              uint64_t v50 = 0LL;
              do
              {
                uint64_t v51 = v46 + v50;
                uint64_t v52 = v50 + 1;
                if (v50 >= 8) {
                  uint64_t v53 = v45;
                }
                else {
                  uint64_t v53 = v43;
                }
                unint64_t v54 = v53 >> (v49 & 0x38);
                unint64_t v55 = (8 * v46 + v49) & 0x38;
                uint64_t v56 = (-255LL << v55) - 1;
                uint64_t v57 = (unint64_t)v54 << v55;
                uint64_t v58 = v57 | v56 & v11;
                uint64_t v59 = v57 | v56 & v8;
                if (v51 < 8) {
                  int64_t v8 = v59;
                }
                else {
                  uint64_t v11 = v58;
                }
                v49 += 8;
                uint64_t v50 = v52;
              }

              while (v47 != v52);
            }

            swift_bridgeObjectRelease(v9);
            swift_bridgeObjectRelease(0xE100000000000000LL);
            char v60 = 0xA000000000000000LL;
            if (!(v8 & 0x8080808080808080LL | v11 & 0x80808080808080LL)) {
              char v60 = 0xE000000000000000LL;
            }
            uint64_t v20 = v60 & 0xFF00000000000000LL | (v48 << 56) | v11 & 0xFFFFFFFFFFFFFFLL;
            goto LABEL_69;
          }

  int64_t v40 = (rawBits >> 8) & 0x3F;
  unint64_t v41 = rawBits >> 16;
  uint64_t v42 = v30 >> 16;
  if (v40) {
    goto LABEL_86;
  }
  if (v41 == v42)
  {
    int64_t v40 = 0LL;
    goto LABEL_86;
  }

  if ((v32 & 0x1000000000000000LL) != 0) {
    goto LABEL_115;
  }
  if ((v32 & 0x2000000000000000LL) == 0)
  {
    if ((v31 & 0x1000000000000000LL) != 0)
    {
      uint64_t v47 = (char *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v48 = v31 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v75 = v28;
      uint64_t v76 = v27;
      uint64_t v47 = (char *)_StringObject.sharedUTF8.getter(v31, v32);
      unint64_t v27 = v76;
      uint64_t v28 = v75;
    }

    if (v41 + 1 == v48) {
      goto LABEL_85;
    }
    if (!v47) {
      goto LABEL_119;
    }
    uint64_t v49 = *(unsigned __int16 *)&v47[v41];
    if (v49 == 2573) {
      goto LABEL_115;
    }
LABEL_84:
    if ((v49 & 0x80808080) == 0) {
      goto LABEL_85;
    }
    goto LABEL_115;
  }

  uint64_t v79 = v31;
  uint64_t v80 = v32 & 0xFFFFFFFFFFFFFFLL;
  if (v41 + 1 == (HIBYTE(v32) & 0xF))
  {
LABEL_85:
    int64_t v40 = 1LL;
    goto LABEL_86;
  }

  uint64_t v49 = *(unsigned __int16 *)((char *)&v79 + v41);
  if (v49 != 2573) {
    goto LABEL_84;
  }
LABEL_115:
  uint64_t v71 = v28;
  uint64_t v72 = v27;
  int64_t v40 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v41);
  unint64_t v27 = v72;
  uint64_t v28 = v71;
LABEL_86:
  uint64_t v50 = v40 + v41;
  if (v42 < v40 + v41) {
    uint64_t v50 = v42;
  }
  uint64_t v51 = v50 << 16;
  uint64_t v52 = v50 & 0xFFFFFFFFFFFFLL;
  if ((v50 & 0xFFFFFFFFFFFFLL) != v42)
  {
    if ((v32 & 0x1000000000000000LL) != 0) {
      goto LABEL_110;
    }
    if ((v32 & 0x2000000000000000LL) != 0)
    {
      uint64_t v79 = v31;
      uint64_t v80 = v32 & 0xFFFFFFFFFFFFFFLL;
      if (v52 + 1 == (HIBYTE(v32) & 0xF)) {
        goto LABEL_101;
      }
      uint64_t v56 = *(unsigned __int16 *)((char *)&v79 + v52);
      if (v56 == 2573) {
        goto LABEL_110;
      }
LABEL_100:
      if ((v56 & 0x80808080) != 0) {
        goto LABEL_110;
      }
LABEL_101:
      uint64_t v53 = 1LL;
      goto LABEL_102;
    }

    if ((v31 & 0x1000000000000000LL) != 0)
    {
      unint64_t v54 = (char *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
      unint64_t v55 = v31 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v73 = v28;
      uint64_t v74 = v27;
      unint64_t v54 = (char *)_StringObject.sharedUTF8.getter(v31, v32);
      unint64_t v27 = v74;
      uint64_t v28 = v73;
    }

    if (v52 + 1 == v55) {
      goto LABEL_101;
    }
    if (v54)
    {
      uint64_t v56 = *(unsigned __int16 *)&v54[v52];
      if (v56 == 2573)
      {
LABEL_110:
        unint64_t v66 = v52;
        uint64_t v67 = v28;
        uint64_t v68 = v27;
        uint64_t v53 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v66);
        unint64_t v27 = v68;
        uint64_t v28 = v67;
        if (v53 > 63) {
          goto LABEL_103;
        }
        goto LABEL_102;
      }

      goto LABEL_100;
    }

        int64_t v44 = HIBYTE(countAndFlagsBits) & 0xF;
        unint64_t v45 = HIBYTE(v43) & 0xF;
        uint64_t v46 = v45 + v44;
        if (v45)
        {
          uint64_t v47 = 0;
          uint64_t v48 = 0LL;
          do
          {
            uint64_t v49 = v44 + v48;
            uint64_t v50 = v48 + 1;
            if (v48 >= 8) {
              uint64_t v51 = v43;
            }
            else {
              uint64_t v51 = v9;
            }
            uint64_t v52 = v51 >> (v47 & 0x38);
            uint64_t v53 = (8 * v44 + v47) & 0x38;
            unint64_t v54 = (-255LL << v53) - 1;
            unint64_t v55 = (unint64_t)v52 << v53;
            uint64_t v56 = v55 | v54 & countAndFlagsBits;
            uint64_t v57 = v55 | v54 & v7;
            if (v49 < 8) {
              uint64_t v7 = v57;
            }
            else {
              uint64_t countAndFlagsBits = v56;
            }
            v47 += 8;
            uint64_t v48 = v50;
          }

          while (v45 != v50);
        }

        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        uint64_t v58 = 0xA000000000000000LL;
        if (!(v7 & 0x8080808080808080LL | countAndFlagsBits & 0x80808080808080LL)) {
          uint64_t v58 = 0xE000000000000000LL;
        }
        uint64_t v19 = v58 & 0xFF00000000000000LL | (v46 << 56) | countAndFlagsBits & 0xFFFFFFFFFFFFFFLL;
        continue;
      }

  __break(1u);
LABEL_57:
  __break(1u);
LABEL_58:
  __break(1u);
LABEL_59:
  __break(1u);
LABEL_60:
  __break(1u);
  return result;
}

  swift_bridgeObjectRelease(v17);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v16;
}

  swift_bridgeObjectRelease(v17);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v16;
}

        unint64_t v55 = HIBYTE(v28) & 0xF;
        uint64_t v56 = HIBYTE(v34) & 0xF;
        uint64_t v57 = v56 + v55;
        if (v56)
        {
          uint64_t v58 = 0;
          uint64_t v59 = 0LL;
          do
          {
            char v60 = v55 + v59;
            unint64_t v61 = v59 + 1;
            if (v59 >= 8) {
              uint64_t v62 = v34;
            }
            else {
              uint64_t v62 = v41;
            }
            unint64_t v63 = v62 >> (v58 & 0x38);
            uint64_t v64 = (8 * v55 + v58) & 0x38;
            uint64_t v65 = (-255LL << v64) - 1;
            unint64_t v66 = (unint64_t)v63 << v64;
            uint64_t v67 = v65 & v28 | v66;
            uint64_t v68 = v65 & v30 | v66;
            if (v60 < 8) {
              char v30 = v68;
            }
            else {
              uint64_t v28 = v67;
            }
            v58 += 8;
            uint64_t v59 = v61;
          }

          while (v56 != v61);
        }

        swift_bridgeObjectRelease((unint64_t)(v32 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
        swift_bridgeObjectRelease(v27);
        uint64_t v69 = 0xA000000000000000LL;
        if (!(v30 & 0x8080808080808080LL | v28 & 0x80808080808080LL)) {
          uint64_t v69 = 0xE000000000000000LL;
        }
        unint64_t v31 = v69 & 0xFF00000000000000LL | (v57 << 56) | v28 & 0xFFFFFFFFFFFFFFLL;
      }
    }

    int64_t v32 = "Unknown raw display style '";
    if ((v24 & 0x2000000000000000LL) != 0 && (0x80000001818BB2F0LL & 0x2000000000000000LL) != 0)
    {
      uint64_t v33 = v29 + ((0x80000001818BB2F0LL >> 56) & 0xF);
      if (v33 <= 0xF)
      {
        uint64_t v78 = (0x80000001818BB2F0LL >> 56) & 0xF;
        if (v78)
        {
          uint64_t v80 = 0;
          uint64_t v81 = 0LL;
          uint64_t v79 = v24;
          do
          {
            char v82 = v29 + v81;
            uint64_t v83 = v81 + 1;
            uint64_t v84 = 0x80000001818BB2F0LL | 0x8000000000000000LL;
            if (v81 < 8) {
              uint64_t v84 = 0xD00000000000001BLL;
            }
            uint64_t v85 = v84 >> (v80 & 0x38);
            uint64_t v86 = (8 * v29 + v80) & 0x38;
            uint64_t v87 = (-255LL << v86) - 1;
            uint64_t v88 = (unint64_t)v85 << v86;
            unint64_t v89 = v87 & v79 | v88;
            uint64_t v90 = v87 & v27 | v88;
            if (v82 < 8) {
              unint64_t v27 = v90;
            }
            else {
              uint64_t v79 = v89;
            }
            v80 += 8;
            uint64_t v81 = v83;
          }

          while (v78 != v83);
        }

        else
        {
          uint64_t v79 = v24;
        }

        swift_bridgeObjectRelease(0x80000001818BB2F0LL | 0x8000000000000000LL);
        swift_bridgeObjectRelease(v28);
        uint64_t v91 = 0xA000000000000000LL;
        if (!(v27 & 0x8080808080808080LL | v79 & 0x80808080808080LL)) {
          uint64_t v91 = 0xE000000000000000LL;
        }
        unint64_t v31 = v91 & 0xFF00000000000000LL | (v33 << 56) | v79 & 0xFFFFFFFFFFFFFFLL;
        *(void *)&v213[0] = v27;
        goto LABEL_97;
      }
    }

    if ((0x80000001818BB2F0LL & 0x2000000000000000LL) != 0) {
      uint64_t v34 = (0x80000001818BB2F0LL >> 56) & 0xF;
    }
    else {
      uint64_t v34 = 27LL;
    }
    swift_bridgeObjectRetain_n(0x80000001818BB2F0LL | 0x8000000000000000LL, 2LL, v25, v26);
    if ((0x80000001818BB2F0LL & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(0x80000001818BB2F0LL | 0x8000000000000000LL, 5LL, v35, v36);
      v189._Swift::UInt64 rawBits = 1LL;
      v190._Swift::UInt64 rawBits = (v34 << 16) | 1;
      v191._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v189,  v190,  0xD00000000000001BLL,  0x80000001818BB2F0LL | 0x8000000000000000LL);
      if (v191._rawBits < 0x10000) {
        v191._rawBits |= 3;
      }
      int64_t v40 = specialized Collection.count.getter( v191,  v192,  0xD00000000000001BLL,  0x80000001818BB2F0LL | 0x8000000000000000LL);
      swift_bridgeObjectRelease(0x80000001818BB2F0LL | 0x8000000000000000LL);
      if ((v28 & 0x1000000000000000LL) == 0)
      {
LABEL_27:
        unint64_t v41 = v30 + v40;
        if (!__OFADD__(v30, v40)) {
          goto LABEL_28;
        }
        goto LABEL_209;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(0x80000001818BB2F0LL | 0x8000000000000000LL, 4LL, v35, v36);
      int64_t v40 = v34;
      if ((v28 & 0x1000000000000000LL) == 0) {
        goto LABEL_27;
      }
    }

    char v30 = String.UTF8View._foreignCount()();
    unint64_t v41 = v30 + v40;
    if (!__OFADD__(v30, v40))
    {
LABEL_28:
      if ((v27 & ~v28 & 0x2000000000000000LL) != 0)
      {
        BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v28 & 0xFFFFFFFFFFFFFFFLL);
        unint64_t v27 = *((void *)&v213[0] + 1);
        char v30 = *(void *)&v213[0];
        if (isUniquelyReferenced_nonNull_native)
        {
          uint64_t v43 = _StringGuts.nativeUnusedCapacity.getter(*(uint64_t *)&v213[0], *((uint64_t *)&v213[0] + 1));
          if ((v37 & 1) != 0) {
            goto LABEL_200;
          }
          if (v41 > 15) {
            goto LABEL_37;
          }
          if ((v27 & 0x2000000000000000LL) != 0)
          {
            uint64_t v28 = v27;
            goto LABEL_52;
          }

          if (v43 >= v40) {
            goto LABEL_37;
          }
          goto LABEL_48;
        }
      }

      else
      {
        unint64_t v27 = *((void *)&v213[0] + 1);
        char v30 = *(void *)&v213[0];
      }

      if (v41 > 15)
      {
LABEL_37:
        int64_t v44 = _StringGuts.nativeUnusedCapacity.getter(v30, v27);
        uint64_t v47 = (v45 & 1) == 0 && v44 >= v40;
        if ((v30 & ~v27 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v47)
          {
LABEL_77:
            if ((0x80000001818BB2F0LL & 0x1000000000000000LL) != 0)
            {
              _StringGuts._foreignAppendInPlace(_:)( 0xD00000000000001BLL,  0x80000001818BB2F0LL | 0x8000000000000000LL,  0LL,  v34);
              uint64_t v77 = 0x80000001818BB2F0LL | 0x8000000000000000LL;
            }

            else
            {
              swift_bridgeObjectRelease_n(0x80000001818BB2F0LL | 0x8000000000000000LL, 5LL);
              uint64_t v74 = (0x80000001818BB2F0LL & 0x2000000000000000LL) == 0
                 || (0x80000001818BB2F0LL & 0x4000000000000000LL) != 0;
              if ((0x80000001818BB2F0LL & 0x2000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(0x80000001818BB2F0LL | 0x8000000000000000LL);
                *(void *)&char v212 = 0xD00000000000001BLL;
                *((void *)&v212 + 1) = 0x80000001818BB2F0LL & 0xFFFFFFFFFFFFFFLL;
                uint64_t v127 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v34,  (uint64_t)&v212,  (0x80000001818BB2F0LL >> 56) & 0xF);
                _StringGuts.appendInPlace(_:isASCII:)(v127, v128, v74);
                swift_bridgeObjectRelease(0x80000001818BB2F0LL | 0x8000000000000000LL);
                goto LABEL_98;
              }

              uint64_t v75 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v34,  (0x80000001818BB2F0LL & 0xFFFFFFFFFFFFFFFLL) + 32,  27LL);
              _StringGuts.appendInPlace(_:isASCII:)(v75, v76, v74);
              uint64_t v77 = 0x80000001818BB2F0LL | 0x8000000000000000LL;
            }

            swift_bridgeObjectRelease_n(v77, 2LL);
            goto LABEL_98;
          }
        }

        else if (v47)
        {
LABEL_76:
          _StringGuts.grow(_:)(v41);
          goto LABEL_77;
        }

        uint64_t v70 = _StringGuts.nativeCapacity.getter(v30, v27);
        if ((v71 & 1) != 0) {
          uint64_t v72 = 0LL;
        }
        else {
          uint64_t v72 = v70;
        }
        if (v72 + 0x4000000000000000LL >= 0)
        {
          uint64_t v73 = 2 * v72;
          if (v73 > v41) {
            unint64_t v41 = v73;
          }
          goto LABEL_76;
        }

        __break(1u);
        goto LABEL_228;
      }

      uint64_t v28 = v27;
      if ((v27 & 0x2000000000000000LL) != 0) {
        goto LABEL_52;
      }
LABEL_48:
      if ((v27 & 0x1000000000000000LL) == 0)
      {
        if ((v30 & 0x1000000000000000LL) != 0)
        {
          uint64_t v48 = (unsigned __int8 *)((v27 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v49 = v30 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v48 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v30, v27);
          uint64_t v49 = v37;
        }

        swift_bridgeObjectRetain(v27, v37, v38, v39);
        closure #1 in _StringGuts._convertedToSmall()(v48, v49, &v212);
        swift_bridgeObjectRelease(v27);
        uint64_t v28 = *((void *)&v212 + 1);
        char v30 = v212;
LABEL_52:
        v50._Swift::UInt64 rawBits = (v34 << 16) | 1;
        v51._Swift::UInt64 rawBits = 1LL;
        v52._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v51,  v50,  0xD00000000000001BLL,  0x80000001818BB2F0LL | 0x8000000000000000LL);
        if (v52._rawBits < 0x10000) {
          v52._rawBits |= 3;
        }
        unint64_t v41 = specialized String.init(_:)(v52, v53, 0xD00000000000001BLL, 0x80000001818BB2F0LL | 0x8000000000000000LL);
        uint64_t v34 = v54;
        swift_bridgeObjectRelease(0x80000001818BB2F0LL | 0x8000000000000000LL);
        if ((v34 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v34);
          goto LABEL_56;
        }

        goto LABEL_216;
      }

      unint64_t v41 = (unint64_t)v13[2];
      int64_t v40 = (unint64_t)v13[3];
      if (v41 >= v40 >> 1) {
        uint64_t v13 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v40 > 1),  v41 + 1,  1,  (uint64_t)v13);
      }
      void v13[2] = (__objc2_class *)(v41 + 1);
      uint64_t v42 = &v13[v41];
      *((_DWORD *)v42 + 8) = v20;
      *((_WORD *)v42 + 18) = v37;
      unint64_t v54 = v13;
      uint64_t v20 = specialized Unicode._InternalNFD.Iterator.next()();
      uint64_t v14 = 0;
      if ((v20 & 0x1000000000000LL) != 0) {
        goto LABEL_10;
      }
    }

    if ((v20 & 0x7F800000000LL) == 0)
    {
      LODWORD(v35) = v20;
LABEL_30:
      uint64_t v56 = v35;
      uint64_t v57 = 0;
      unint64_t v36 = specialized Unicode._InternalNFD.Iterator.next()();
      if ((v36 & 0x1000000000000LL) == 0)
      {
        uint64_t v20 = v36;
        do
        {
          uint64_t v52 = v35;
          unint64_t v37 = WORD2(v20);
          uint64_t v38 = v13[2];
          if (v38)
          {
            uint64_t v39 = (v20 >> 35);
            if ((v20 & 0x600000000LL) == 0) {
              goto LABEL_55;
            }
            uint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v35, v20);
            if ((v35 & 0x100000000LL) != 0)
            {
              LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
              if ((_DWORD)v35 == -1) {
                goto LABEL_55;
              }
            }
          }

          else
          {
            if ((v20 & 0x600000000LL) == 0) {
              goto LABEL_54;
            }
            uint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v35, v20);
            if ((v35 & 0x100000000LL) != 0)
            {
              LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
              if ((_DWORD)v35 == -1) {
                goto LABEL_54;
              }
            }
          }

          uint64_t v56 = v35;
          uint64_t v57 = 0;
          uint64_t v20 = specialized Unicode._InternalNFD.Iterator.next()();
        }

        while ((v20 & 0x1000000000000LL) == 0);
      }

      uint64_t v52 = v35;
LABEL_10:
      uint64_t v20 = 0LL;
      uint64_t v56 = 0;
      uint64_t v14 = 1;
      uint64_t v57 = 1;
LABEL_11:
      uint64_t v21 = v52;
      goto LABEL_12;
    }

    uint64_t v14 = 1;
    uint64_t v21 = v20;
    uint64_t v20 = v52;
LABEL_12:
    ++v12;
    *v9++ = v21;
    uint64_t v10 = v51;
    uint64_t v11 = v20;
    a3 = v50;
    if (v12 != v50) {
      continue;
    }
    break;
  }

  uint64_t v18 = v54;
  uint64_t v17 = v55;
  BOOL v16 = v56;
  int64_t v8 = v57;
  uint64_t v15 = v58;
  a5 = v59;
  a6 = v60;
  a7 = v61;
LABEL_7:
  *(void *)a1 = v18;
  *(_BYTE *)(a1 + 8) = v17;
  *(_DWORD *)(a1 + 12) = v16;
  *(_BYTE *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a1 + 32) = 0;
LABEL_8:
  *(int64x2_t *)(a1 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v15;
  *(void *)(a1 + 56) = a5;
  *(void *)(a1 + 64) = a6;
  *(void *)(a1 + 72) = a7;
  return a3;
}

    unint64_t v45 = 1860LL;
    goto LABEL_53;
  }

  v47[0] = v2;
  v47[1] = v3 & 0xFFFFFFFFFFFFFFLL;
  if (v4 < 0) {
    goto LABEL_56;
  }
  char v30 = v5 - v4;
  if (v5 - v4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (v30)
  {
    unint64_t v31 = 0LL;
    int64_t v32 = (char *)v47 + v4;
    do
    {
      if (v31 < 0) {
        goto LABEL_52;
      }
      uint64_t v35 = v32[v31];
      if (v35 < 0xCC)
      {
        uint64_t v33 = 0;
        if (v35 < 0xC0) {
          uint64_t v34 = 1LL;
        }
        else {
          uint64_t v34 = 2LL;
        }
      }

      else
      {
        unint64_t v36 = __clz(v35 ^ 0xFF) - 24;
        uint64_t v34 = v36;
        if (v36 == 2)
        {
          uint64_t v39 = &v32[v31 + 1];
          int64_t v40 = (v35 & 0x1F) << 6;
        }

        else
        {
          unint64_t v37 = &v32[v31];
          uint64_t v38 = v32[v31 + 1];
          if (v34 == 3)
          {
            uint64_t v39 = v37 + 2;
            int64_t v40 = ((v35 & 0xF) << 12) | ((v38 & 0x3F) << 6);
          }

          else
          {
            unint64_t v41 = v37[2];
            uint64_t v39 = v37 + 3;
            int64_t v40 = ((v35 & 0xF) << 18) | ((v38 & 0x3F) << 12) | ((v41 & 0x3F) << 6);
          }
        }

        uint64_t v42 = v40 | *v39 & 0x3F;
        if (v42 >= 0x300) {
          uint64_t v43 = _swift_stdlib_getNormData(v42);
        }
        else {
          uint64_t v43 = 0;
        }
        int64_t v44 = *a2 <= (v43 >> 3);
        uint64_t v33 = v43 >> 3;
        if (!v33) {
          int64_t v44 = 1;
        }
        if ((v43 & 6) != 0 || !v44)
        {
LABEL_50:
          *a1 = 0;
          return;
        }
      }

      *a2 = v33;
      v31 += v34;
    }

    while (v31 < v30);
  }

    uint64_t v48 = v17;
    uint64_t v46 = v20;
    uint64_t v20 = 1;
    uint64_t v17 = 0LL;
LABEL_59:
    uint64_t v49 = v87;
    uint64_t v50 = (unint64_t)v87[2];
    uint64_t v85 = v50 != 0;
    if (v50)
    {
      if (!v15)
      {
        char v82 = v46;
        uint64_t v51 = v50 - 1;
        if (v50 <= 1)
        {
          uint64_t v46 = v82;
        }

        else
        {
          uint64_t v52 = 0LL;
          uint64_t v53 = 0LL;
          unint64_t v54 = 8 * v50 + 24;
          do
          {
            unint64_t v55 = v49[2];
            uint64_t v80 = v20;
            uint64_t v74 = (int)v49[v52 + 4];
            uint64_t v76 = v48;
            uint64_t v73 = WORD2(v49[v52 + 4]);
            uint64_t v56 = *(_DWORD *)((char *)v49 + v54);
            uint64_t v57 = *(_WORD *)((char *)v49 + v54 + 4);
            specialized Array._checkSubscript_mutating(_:)(v53, (uint64_t)v49);
            uint64_t v58 = &v49[v52];
            *((_DWORD *)v58 + 8) = v56;
            *((_WORD *)v58 + 18) = v57;
            uint64_t v20 = v80;
            uint64_t v48 = v76;
            specialized Array._checkSubscript_mutating(_:)(v51, (uint64_t)v49);
            uint64_t v59 = (char *)v49 + v54;
            *(_DWORD *)uint64_t v59 = v74;
            *((_WORD *)v59 + 2) = v73;
            ++v53;
            --v51;
            v54 -= 8LL;
            ++v52;
          }

          while ((uint64_t)v53 < (uint64_t)v51);
          uint64_t v46 = v82;
          if (!v49[2]) {
            goto LABEL_127;
          }
        }
      }

      if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v49))
      {
        uint64_t v69 = v49[2];
        if (v69)
        {
LABEL_102:
          uint64_t v68 = 0;
          uint64_t v70 = (__objc2_class *)((char *)v69 - 1);
          LODWORD(v62) = v49[(void)v70 + 4];
          v49[2] = v70;
          uint64_t v87 = v49;
          if ((v46 & 1) == 0) {
            goto LABEL_109;
          }
          goto LABEL_122;
        }
      }

      else
      {
        uint64_t v49 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v49);
        uint64_t v69 = v49[2];
        if (v69) {
          goto LABEL_102;
        }
      }

          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
      }

      else if ((a3 & 0x1000000000000000LL) != 0)
      {
        uint64_t v19 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v20 = a3 & 0xFFFFFFFFFFFFLL;
        if ((uint64_t)(a3 & 0xFFFFFFFFFFFFLL) >= v10)
        {
LABEL_17:
          uint64_t v21 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, (uint64_t)v19, v20);
          unint64_t v23 = v22;
          int64_t v24 = v5[1] & 0xFFFFFFFFFFFFFFFLL;
          specialized UnsafeMutablePointer.initialize(from:count:)( v21,  v22,  (char *)(v24 + (*(void *)(v24 + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
          uint64_t v25 = *(void *)(v24 + 24);
          uint64_t v26 = (v25 & 0xFFFFFFFFFFFFLL) + v23;
          if (!__OFADD__(v25 & 0xFFFFFFFFFFFFLL, v23))
          {
            unint64_t v27 = (v25 & a3) >> 63;
LABEL_43:
            __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v26, v27);
            *int64_t v5 = *(void *)(v24 + 24);
            return;
          }

          __break(1u);
          goto LABEL_56;
        }
      }

      else
      {
        uint64_t v19 = _StringObject.sharedUTF8.getter(a3, a4);
        uint64_t v20 = v69;
        if (v69 >= v10) {
          goto LABEL_17;
        }
      }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }
  }

  else if (v15 > 15)
  {
    goto LABEL_13;
  }

  uint64_t v28 = _StringGuts._convertedToSmall()(v13, v12);
  char v30 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    char v30 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v30 < v10) {
LABEL_52:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
  unint64_t v31 = v28;
  int64_t v32 = v29;
  if ((a1 & 0xFFFFFFFFFFFF0000LL | 1) >= 0x10000) {
    v34._Swift::UInt64 rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 1;
  }
  else {
    v34._Swift::UInt64 rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 3;
  }
  v33._Swift::UInt64 rawBits = a2 & 0xFFFFFFFFFFFF0000LL | 1;
  uint64_t v35 = specialized String.init(_:)(v34, v33, a3, a4);
  unint64_t v37 = v36;
  uint64_t v38 = _StringGuts._convertedToSmall()(v35, v36);
  int64_t v40 = v39;
  swift_bridgeObjectRelease(v37);
  unint64_t v41 = HIBYTE(v32) & 0xF;
  uint64_t v42 = HIBYTE(v40) & 0xF;
  uint64_t v43 = v42 + v41;
  if ((unint64_t)(v42 + v41) > 0xF)
  {
    uint64_t v70 = 266LL;
    goto LABEL_59;
  }

  if (v42)
  {
    int64_t v44 = 0;
    unint64_t v45 = 0LL;
    do
    {
      uint64_t v46 = v41 + v45;
      uint64_t v47 = v45 + 1;
      if (v45 >= 8) {
        uint64_t v48 = v40;
      }
      else {
        uint64_t v48 = v38;
      }
      uint64_t v49 = v48 >> (v44 & 0x38);
      uint64_t v50 = (8 * v41 + v44) & 0x38;
      uint64_t v51 = (-255LL << v50) - 1;
      uint64_t v52 = (unint64_t)v49 << v50;
      uint64_t v53 = v52 | v51 & v32;
      unint64_t v54 = v52 | v51 & v31;
      if (v46 < 8) {
        unint64_t v31 = v54;
      }
      else {
        int64_t v32 = v53;
      }
      v44 += 8;
      unint64_t v45 = v47;
    }

    while (v42 != v47);
  }

  swift_bridgeObjectRelease(v12);
  unint64_t v55 = 0xA000000000000000LL;
  if (!(v31 & 0x8080808080808080LL | v32 & 0x80808080808080LL)) {
    unint64_t v55 = 0xE000000000000000LL;
  }
  *int64_t v5 = v31;
  v5[1] = v55 & 0xFF00000000000000LL | (v43 << 56) | v32 & 0xFFFFFFFFFFFFFFLL;
}

    if ((countAndFlagsBits & ~object & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v67 = (unint64_t)v288._object;
      uint64_t v68 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
      if ((v69 & 1) != 0) {
        goto LABEL_262;
      }
      if (v65 <= 15 && ((v67 & 0x2000000000000000LL) != 0 || v68 < v64))
      {
LABEL_66:
        swift_bridgeObjectRelease_n(v53, 5LL);
        uint64_t v74 = v288._countAndFlagsBits;
        uint64_t v75 = v288._object;
        swift_bridgeObjectRetain((unint64_t)v288._object, v76, v77, v78);
        uint64_t v79 = _StringGuts._convertedToSmall()(v74, (unint64_t)v75);
        uint64_t v81 = v80;
        swift_bridgeObjectRelease((uint64_t)v75);
        v82._Swift::UInt64 rawBits = (v61 << 16) | 1;
        v83._Swift::UInt64 rawBits = 1LL;
        v84._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v83, v82, v52, v53);
        if (v84._rawBits < 0x10000) {
          v84._rawBits |= 3;
        }
        uint64_t v86 = specialized String.init(_:)(v84, v85, v52, v53);
        uint64_t v88 = v87;
        swift_bridgeObjectRelease(v53);
        unint64_t v89 = _StringGuts._convertedToSmall()(v86, v88);
        uint64_t v91 = v90;
        swift_bridgeObjectRelease(v88);
        uint64_t v92 = specialized _SmallString.init(_:appending:)(v79, v81, v89, v91);
        if ((v94 & 1) != 0) {
          goto LABEL_261;
        }
        uint64_t v95 = v92;
        uint64_t v96 = v93;
        swift_bridgeObjectRelease(v53);
        uint64_t v97 = v288._object;
        v288._uint64_t countAndFlagsBits = v95;
        v288._unint64_t object = v96;
        swift_bridgeObjectRelease((uint64_t)v97);
        goto LABEL_88;
      }
    }

    else if (v65 <= 15)
    {
      goto LABEL_66;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v65, v64);
    swift_bridgeObjectRelease_n(v53, 4LL);
    if ((v53 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v53);
      _StringGuts._foreignAppendInPlace(_:)(v52, v53, 0LL, v61);
    }

    else
    {
      if (v58)
      {
        swift_bridgeObjectRelease_n(v53, 2LL);
        *(void *)&unint64_t v287 = v52;
        *((void *)&v287 + 1) = v53 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v70 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v53) & 0xF,  (uint64_t)&v287,  HIBYTE(v53) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v70, v71, (v53 & 0x4000000000000000LL) != 0);
        swift_bridgeObjectRelease(v53);
        goto LABEL_88;
      }

      if ((v52 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v53);
        uint64_t v111 = (id)((v53 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v112 = v52 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v111 = _StringObject.sharedUTF8.getter(v52, v53);
        uint64_t v112 = v280;
        swift_bridgeObjectRelease(v53);
        if (v112 < (v52 & 0xFFFFFFFFFFFFLL)) {
          goto LABEL_260;
        }
      }

      uint64_t v113 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v52 & 0xFFFFFFFFFFFFLL, (uint64_t)v111, v112);
      _StringGuts.appendInPlace(_:isASCII:)(v113, v114, v52 < 0);
    }

    swift_bridgeObjectRelease_n(v53, 2LL);
LABEL_88:
    uint64_t v116 = v288._countAndFlagsBits;
    uint64_t v115 = (uint64_t)v288._object;
    uint64_t v117 = ((unint64_t)v288._object >> 56) & 0xF;
    else {
      int v118 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v118 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000LL) == 0)
    {
      v288._uint64_t countAndFlagsBits = 11093LL;
      v288._unint64_t object = (void *)0xE200000000000000LL;
      uint64_t v131 = v115;
      goto LABEL_115;
    }

    if (((uint64_t)v288._object & 0x2000000000000000LL) == 0 || v117 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v72, v73);
      if ((v115 & 0x1000000000000000LL) != 0)
      {
        uint64_t v250 = String.UTF8View._foreignCount()();
        uint64_t v125 = v250 + 2;
        if (__OFADD__(v250, 2LL))
        {
LABEL_237:
          __break(1u);
LABEL_238:
          uint64_t v230 = String.UTF8View._foreignCount()();
          if ((v116 & ~v115 & 0x2000000000000000LL) == 0) {
            goto LABEL_239;
          }
LABEL_213:
          if (!swift_isUniquelyReferenced_nonNull_native(v115 & 0xFFFFFFFFFFFFFFFLL)) {
            goto LABEL_239;
          }
          unint64_t v232 = (unint64_t)v288._object;
          uint64_t v233 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
          if ((v234 & 1) != 0)
          {
LABEL_262:
            int64_t v282 = 258LL;
LABEL_263:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v282,  0);
          }

          if (v230 <= 15 && ((v232 & 0x2000000000000000LL) != 0 || (v233 & 0x8000000000000000LL) != 0)) {
            goto LABEL_240;
          }
LABEL_218:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v230, 0LL);
          swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
          unint64_t v287 = 0uLL;
          uint64_t v235 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v287, 0LL);
          _StringGuts.appendInPlace(_:isASCII:)(v235, v236, 1);
          unint64_t v237 = 0xE000000000000000LL;
          goto LABEL_244;
        }
      }

      else
      {
        uint64_t v124 = __OFADD__(v118, 2LL);
        uint64_t v125 = v118 + 2;
        if (v124) {
          goto LABEL_237;
        }
      }

      if ((v116 & ~v115 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v115 & 0xFFFFFFFFFFFFFFFLL))
      {
        uint64_t v126 = (unint64_t)v288._object;
        uint64_t v127 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
        if ((v128 & 1) != 0) {
          goto LABEL_262;
        }
        if (v125 > 15 || (v126 & 0x2000000000000000LL) == 0 && v127 > 1) {
          goto LABEL_106;
        }
      }

      else if (v125 > 15)
      {
LABEL_106:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v125, 2LL);
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
        unint64_t v287 = xmmword_1817FFFA0;
        uint64_t v129 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v287, 2LL);
        _StringGuts.appendInPlace(_:isASCII:)(v129, v130, 1);
        uint64_t v131 = 0xE200000000000000LL;
LABEL_115:
        swift_bridgeObjectRelease(v131);
        uint64_t v123 = _;
        goto LABEL_120;
      }

      swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
      unint64_t v132 = v288._countAndFlagsBits;
      uint64_t v133 = v288._object;
      swift_bridgeObjectRetain((unint64_t)v288._object, v134, v135, v136);
      uint64_t v137 = _StringGuts._convertedToSmall()(v132, (unint64_t)v133);
      uint64_t v139 = v138;
      swift_bridgeObjectRelease((uint64_t)v133);
      v140._Swift::UInt64 rawBits = 1LL;
      v141._Swift::UInt64 rawBits = 131073LL;
      v142._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v140, v141, 0x2B55uLL, 0xE200000000000000LL);
      if (v142._rawBits < 0x10000) {
        v142._rawBits |= 3;
      }
      uint64_t v144 = specialized String.init(_:)(v142, v143, 0x2B55uLL, 0xE200000000000000LL);
      uint64_t v146 = v145;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v147 = _StringGuts._convertedToSmall()(v144, v146);
      uint64_t v149 = v148;
      swift_bridgeObjectRelease(v146);
      uint64_t v150 = specialized _SmallString.init(_:appending:)(v137, v139, v147, v149);
      if ((v152 & 1) != 0) {
        goto LABEL_261;
      }
      uint64_t v153 = v150;
      uint64_t v154 = v151;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v131 = (uint64_t)v288._object;
      v288._uint64_t countAndFlagsBits = v153;
      v288._unint64_t object = v154;
      goto LABEL_115;
    }

    uint64_t v119 = 8 * (((unint64_t)v288._object >> 56) & 7);
    uint64_t v120 = (-255LL << v119) - 1;
    uint64_t v121 = 85LL << v119;
    uint64_t v122 = v117 + 1;
    if (v117 >= 8)
    {
      uint64_t v115 = v121 | v120 & (uint64_t)v288._object;
      uint64_t v123 = _;
    }

    else
    {
      uint64_t v116 = v121 | v120 & v288._countAndFlagsBits;
      uint64_t v123 = _;
      if (v117 != 7)
      {
        uint64_t v116 = (43LL << (8 * (v122 & 7u))) | ((-255LL << (8 * (v122 & 7u))) - 1) & v116;
        goto LABEL_117;
      }

      uint64_t v122 = 8;
    }

    uint64_t v115 = (43LL << (8 * (v122 & 7u))) | ((-255LL << (8 * (v122 & 7u))) - 1) & v115;
LABEL_117:
    swift_bridgeObjectRelease(0xE200000000000000LL);
    uint64_t v155 = 0xA000000000000000LL;
    if (!(v116 & 0x8080808080808080LL | v115 & 0x80808080808080LL)) {
      uint64_t v155 = 0xE000000000000000LL;
    }
    uint64_t v156 = (void *)((v155 & 0xFF00000000000000LL | (v117 << 56) | v115 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL);
    swift_bridgeObjectRelease((uint64_t)v288._object);
    v288._uint64_t countAndFlagsBits = v116;
    v288._unint64_t object = v156;
LABEL_120:
    uint64_t v159 = _uint64ToString(_:radix:uppercase:)(v123, 16LL, 1);
    int64_t v9 = v159._countAndFlagsBits;
    uint64_t v160 = v288._countAndFlagsBits;
    uint64_t v161 = (unint64_t)v288._object;
    char v162 = ((unint64_t)v288._object >> 56) & 0xF;
    uint64_t v163 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v163 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000LL) == 0)
    {
      uint64_t v288 = v159;
      unint64_t v203 = v161;
LABEL_188:
      swift_bridgeObjectRelease(v203);
      goto LABEL_205;
    }

    int64_t v4 = (uint64_t)v159._object & 0x2000000000000000LL;
    uint64_t v164 = ((unint64_t)v159._object >> 56) & 0xF;
    if (((uint64_t)v288._object & 0x2000000000000000LL) != 0 && v4)
    {
      uint64_t v165 = v162 + v164;
      if (v162 + v164 <= 0xF)
      {
        if (v164)
        {
          char v212 = 0;
          char v213 = 0LL;
          do
          {
            uint64_t v214 = v162 + v213;
            uint64_t v215 = v213 + 1;
            if (v213 >= 8) {
              uint64_t v216 = (unint64_t)v159._object;
            }
            else {
              uint64_t v216 = v159._countAndFlagsBits;
            }
            uint64_t v217 = v216 >> (v212 & 0x38);
            uint64_t v218 = (8 * v162 + v212) & 0x38;
            unint64_t v219 = (-255LL << v218) - 1;
            uint64_t v220 = (unint64_t)v217 << v218;
            uint64_t v221 = v220 | v219 & v161;
            uint64_t v222 = v220 | v219 & v160;
            if (v214 < 8) {
              uint64_t v160 = v222;
            }
            else {
              uint64_t v161 = v221;
            }
            v212 += 8;
            char v213 = v215;
          }

          while (v164 != v215);
        }

        swift_bridgeObjectRelease((uint64_t)v159._object);
        id v223 = 0xA000000000000000LL;
        if (!(v160 & 0x8080808080808080LL | v161 & 0x80808080808080LL)) {
          id v223 = 0xE000000000000000LL;
        }
        unint64_t v224 = (void *)(v223 & 0xFF00000000000000LL | (v165 << 56) | v161 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v288._object);
        v288._uint64_t countAndFlagsBits = v160;
        v288._unint64_t object = v224;
        goto LABEL_205;
      }

      int64_t v4 = 1LL;
    }

    if (v4) {
      uint64_t v166 = ((unint64_t)v159._object >> 56) & 0xF;
    }
    else {
      uint64_t v166 = v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v159._object, 2LL, v157, v158);
    if (((uint64_t)v159._object & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v159._object, 5LL, v167, v168);
      v245._Swift::UInt64 rawBits = 1LL;
      v246._Swift::UInt64 rawBits = (v166 << 16) | 1;
      v247._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v245,  v246,  v159._countAndFlagsBits,  (unint64_t)v159._object);
      if (v247._rawBits < 0x10000) {
        v247._rawBits |= 3;
      }
      unint64_t v169 = specialized Collection.count.getter(v247, v248, v159._countAndFlagsBits, (unint64_t)v159._object);
      swift_bridgeObjectRelease((uint64_t)v159._object);
      uint64_t v160 = v288._countAndFlagsBits;
      uint64_t v161 = (unint64_t)v288._object;
      if (((uint64_t)v288._object & 0x1000000000000000LL) != 0)
      {
LABEL_232:
        uint64_t v249 = String.UTF8View._foreignCount()();
        uint64_t v2 = v249 + v169;
        if (!__OFADD__(v249, v169)) {
          goto LABEL_138;
        }
        goto LABEL_136;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v159._object, 4LL, v167, v168);
      unint64_t v169 = v166;
      if ((v161 & 0x1000000000000000LL) != 0) {
        goto LABEL_232;
      }
    }

    if ((v161 & 0x2000000000000000LL) == 0)
    {
      uint64_t v2 = (v160 & 0xFFFFFFFFFFFFLL) + v169;
      if (!__OFADD__(v160 & 0xFFFFFFFFFFFFLL, v169)) {
        goto LABEL_138;
      }
      goto LABEL_136;
    }

    while (1)
    {
      uint64_t v170 = HIBYTE(v161) & 0xF;
      uint64_t v2 = v170 + v169;
      if (!__OFADD__(v170, v169)) {
        break;
      }
LABEL_136:
      __break(1u);
    }

  uint64_t v7 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v12);
LABEL_27:
  uint64_t v19 = v6._rawBits + (v7 << 16);
  uint64_t v20 = v19 & 0xFFFFFFFFFFFF0000LL;
  if (v8) {
    uint64_t v21 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v21 = a2 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v22 = a3 & 0x1000000000000000LL;
  if (v20 >> 14 == 4 * v21)
  {
    uint64_t result = 0LL;
LABEL_47:
    v20 |= result << 8;
    goto LABEL_48;
  }

  int64_t v24 = v19 >> 16;
  if (!v22)
  {
    if (v8)
    {
      unint64_t v31 = a2;
      int64_t v32 = a3 & 0xFFFFFFFFFFFFFFLL;
      if (v24 + 1 == v9) {
        goto LABEL_46;
      }
      uint64_t v25 = *(unsigned __int16 *)((char *)&v31 + v24);
LABEL_41:
      if (v25 == 2573 || (v25 & 0x8080) != 0) {
        goto LABEL_54;
      }
LABEL_46:
      unint64_t v22 = 0LL;
      uint64_t result = 1LL;
      goto LABEL_47;
    }

    if ((a2 & 0x1000000000000000LL) != 0)
    {
      uint64_t v26 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v26 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      uint64_t v10 = v30;
    }

    if (v24 + 1 == v10) {
      goto LABEL_46;
    }
    if (v26)
    {
      uint64_t v25 = *(unsigned __int16 *)&v26[v24];
      goto LABEL_41;
    }

        uint64_t v47 = xmmword_18180BFB0;
        uint64_t v48 = 0LL;
        uint64_t v49 = 0;
        uint64_t v84 = 0LL;
        uint64_t v51 = 0LL;
        uint64_t v52 = 0LL;
        uint64_t v50 = 0LL;
        uint64_t v53 = 0;
        uint64_t v65 = 0u;
        unint64_t v66 = 0u;
        uint64_t v67 = 0u;
        uint64_t v68 = 0u;
        uint64_t v69 = 0u;
        uint64_t v70 = 0u;
        uint64_t v71 = 0u;
        uint64_t v72 = 0u;
        uint64_t v73 = 0u;
        uint64_t v74 = 0u;
        uint64_t v75 = 0u;
        uint64_t v76 = 0u;
        uint64_t v77 = 0u;
        uint64_t v78 = 0u;
        uint64_t v79 = 0u;
        uint64_t v80 = 0u;
        uint64_t v81 = 0u;
        unint64_t v54 = 0u;
        unint64_t v55 = 0u;
        uint64_t v56 = 0u;
        uint64_t v57 = 0u;
        uint64_t v58 = 0u;
        uint64_t v59 = 0u;
        char v60 = 0u;
        unint64_t v61 = 0u;
        uint64_t v62 = 0u;
        unint64_t v63 = 0u;
        uint64_t v64 = 0u;
        char v82 = 0;
        v46[0] = off_189B8D1A0;
        v46[1] = &v85;
        v46[2] = &v86;
        uint64_t v20 = swift::_buildDemanglingForGenericType(v5, v4, (swift::Demangle::__runtime::NodeFactory *)v46);
        if (v20)
        {
          uint64_t v21 = (swift::Demangle::__runtime::Node *)v20;
          if (*((_WORD *)v20 + 8) != 99)
          {
            Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(v46, 99);
            swift::Demangle::__runtime::Node::addChild( Node,  v21,  (swift::Demangle::__runtime::NodeFactory *)v46,  v23,  v24);
            uint64_t v21 = (swift::Demangle::__runtime::Node *)Node;
          }

          swift::Demangle::__runtime::mangleNode((uint64_t)v21);
          if (v43)
          {
            swift::warning(0LL, "Mangling for prespecialized metadata failed with code %d", v25, v26, v43);
            pointer_hash_table_entry = 0LL;
          }

          else
          {
            uint64_t v38 = swift::PrebuiltStringMap<char const*,swift::TargetMetadata<swift::InProcess> *,&swift::LibPrespecializedData<swift::InProcess>::stringIsNull>::find( *(unint64_t **)(LibPrespecialized + 8),  v44,  v45);
            if (v38) {
              pointer_hash_table_entry = (const void *)v38[1];
            }
            else {
              pointer_hash_table_entry = 0LL;
            }
            if (prespecializedLoggingEnabled) {
              fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Prespecializations library: found %p for key '%.*s'.\n",  pointer_hash_table_entry,  v45,  v44);
            }
          }
        }

        else
        {
          if (prespecializedLoggingEnabled) {
            fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Prespecializations library: failed to build demangling with descriptor %p.\n",  v5);
          }
          pointer_hash_table_entry = 0LL;
        }

        v46[0] = off_189B8E500;
        uint64_t v39 = v84;
        if (v84 == v83)
        {
          int64_t v40 = 4LL;
          uint64_t v39 = v83;
        }

        else
        {
          if (!v84) {
            goto LABEL_96;
          }
          int64_t v40 = 5LL;
        }

        (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_96:
        v46[0] = off_189B8E4D8;
        swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v47);
        if (v48) {
          *(_BYTE *)(v48 + 48) = 0;
        }
        return pointer_hash_table_entry;
      }

      return 0LL;
    }

    if ((*(_DWORD *)v5 & 0x80) == 0) {
      return 0LL;
    }
    pointer_hash_table_entry = 0LL;
    switch(*(_DWORD *)v5 & 0x1F)
    {
      case 1:
      case 2:
      case 4:
      case 0x10:
      case 0x11:
      case 0x12:
        pointer_hash_table_entry = (const void *)_dyld_find_pointer_hash_table_entry();
        if (prespecializedLoggingEnabled) {
          fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Prespecializations library: Looking up description %p in dyld table, found %p.\n",  v5,  pointer_hash_table_entry);
        }
        break;
      default:
        return pointer_hash_table_entry;
    }
  }

  return pointer_hash_table_entry;
}

  ++*(void *)(a1 + 24);
  return i;
}

  ++*(void *)(a1 + 24);
  return i;
}

      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = 0LL;
      *(_DWORD *)(a4 + 16) = 0;
LABEL_57:
      if (--v24 == -1) {
        goto LABEL_68;
      }
    }
  }

  uint64_t v17 = *((unsigned __int8 *)v16 + 18);
  uint64_t v18 = v16;
  if (v17 == 2)
  {
LABEL_38:
    uint64_t v19 = (uint64_t *)*((void *)v18 + 1);
    goto LABEL_44;
  }

  if (v17 == 5 && *((_DWORD *)v16 + 2) >= 2u)
  {
    uint64_t v18 = *(swift::Demangle::__runtime::Node **)v16;
    goto LABEL_38;
  }

  uint64_t v19 = 0LL;
LABEL_44:
  uint64_t v21 = *((unsigned __int8 *)v19 + 18);
  if ((v21 - 1) >= 2)
  {
    if (v21 != 5 || !*((_DWORD *)v19 + 2))
    {
      unint64_t v22 = 0LL;
      goto LABEL_50;
    }

    uint64_t v19 = (uint64_t *)*v19;
  }

  unint64_t v22 = (uint64_t *)*v19;
LABEL_50:
  unint64_t v23 = *((unsigned __int8 *)v22 + 18);
  if ((_DWORD)v23 != 1)
  {
    if ((_DWORD)v23 == 5)
    {
      unint64_t v23 = *((unsigned int *)v22 + 2);
      if (!(_DWORD)v23) {
        goto LABEL_84;
      }
    }

    else
    {
      if ((_DWORD)v23 != 2) {
        goto LABEL_84;
      }
      unint64_t v23 = 2LL;
    }
  }

  uint64_t v29 = v23 - 1;
  do
  {
    char v30 = *((unsigned __int8 *)v22 + 18);
    unint64_t v31 = v30 - 1;
    if ((_DWORD)v30 != 1)
    {
      if ((_DWORD)v30 == 5)
      {
        char v30 = *((unsigned int *)v22 + 2);
      }

      else
      {
        if ((_DWORD)v30 != 2) {
          goto LABEL_71;
        }
        char v30 = 2LL;
      }
    }

    if (v30 <= v29)
    {
LABEL_71:
      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = 0LL;
      *(_DWORD *)(a4 + 16) = 0;
      goto LABEL_72;
    }

    int64_t v32 = v22;
    if (v31 >= 2) {
      int64_t v32 = (uint64_t *)*v22;
    }
    if (*(_DWORD *)a4) {
      return result;
    }
LABEL_72:
    --v29;
  }

  while (v29 != -1);
  uint64_t v17 = *((unsigned __int8 *)v16 + 18);
LABEL_84:
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  uint64_t v28 = (_DWORD *)(a4 + 16);
  if ((v17 - 1) < 2)
  {
LABEL_88:
    if (!*(_DWORD *)a4) {
      goto LABEL_92;
    }
  }

  else
  {
    if (v17 == 5 && *((_DWORD *)v16 + 2))
    {
      BOOL v16 = *(swift::Demangle::__runtime::Node **)v16;
      goto LABEL_88;
    }

    *(void *)(a4 + 8) = 0LL;
LABEL_91:
    *uint64_t v28 = 0;
LABEL_92:
    uint64_t result = swift::Demangle::__runtime::CharVector::append(this + 1591, "F", 1uLL, this[1593]);
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
  }

  return result;
}

  int64_t v32 = *(_DWORD *)(v4 + 12736);
  uint64_t v33 = *(unsigned int *)(v4 + 12740);
  uint64_t v34 = *(char **)(v4 + 12728);
  uint64_t v35 = *(void **)(v4 + 12744);
  unint64_t v36 = (char *)v35[1];
  if (&v34[v33] != v36)
  {
    unint64_t v37 = v35[2];
LABEL_60:
    else {
      uint64_t v39 = (2 * v33);
    }
    int64_t v40 = v39 + v33;
    if (v36) {
      unint64_t v41 = (unint64_t)&v36[v39 + v33] > v37;
    }
    else {
      unint64_t v41 = 1;
    }
    uint64_t v34 = (char *)v35[1];
    if (v41)
    {
      uint64_t v42 = 2LL * v35[4];
      if (v42 <= v40 + 1) {
        uint64_t v42 = v40 + 1;
      }
      v35[4] = v42;
      uint64_t v43 = v42 + 8;
      this = malloc(v42 + 8);
      int64_t v44 = (char *)this + v43;
      *this = v35[3];
      uint64_t v34 = (char *)(this + 1);
      v35[2] = v44;
      v35[3] = this;
    }

    v35[1] = &v34[v40];
    if ((_DWORD)v33)
    {
      this = memcpy(v34, *(const void **)(v4 + 12728), v33);
      LODWORD(v33) = *(_DWORD *)(v4 + 12740);
      int64_t v32 = *(_DWORD *)(v4 + 12736);
    }

    *(void *)(v4 + 12728) = v34;
    goto LABEL_74;
  }

  uint64_t v38 = (unint64_t)&v34[v33 + 1];
  unint64_t v37 = v35[2];
  if (v38 > v37) {
    goto LABEL_60;
  }
  v35[1] = v38;
  LODWORD(v39) = 1;
LABEL_74:
  *(_DWORD *)(v4 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v33 + v39;
LABEL_75:
  *(_DWORD *)(v4 + 12736) = v32 + 1;
  v34[v32] = 114;
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  unint64_t v45 = (_DWORD *)(a4 + 16);
LABEL_76:
  *unint64_t v45 = 0;
  return this;
}

void specialized ContiguousArray.append<A>(contentsOf:)(unint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *v1;
  int64_t v4 = *(void *)(*v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
    goto LABEL_31;
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  uint64_t *v1 = v3;
  if (!isUniquelyReferenced_nonNull_native || (int64_t v11 = *(void *)(v3 + 24) >> 1, v11 < v5))
  {
    if (v4 <= v5) {
      int64_t v12 = v4 + v2;
    }
    else {
      int64_t v12 = v4;
    }
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( isUniquelyReferenced_nonNull_native,  v12,  1);
    uint64_t v3 = *v1;
    int64_t v11 = *(void *)(*v1 + 24) >> 1;
  }

  uint64_t v13 = *(void *)(v3 + 16);
  unint64_t v14 = v11 - v13;
  if (v11 - v13 < 0) {
LABEL_31:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  unint64_t v15 = *(void *)(a1 + 16);
  if (!v15)
  {
    if (!v2) {
      goto LABEL_17;
    }
LABEL_32:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x35AuLL,  0);
  }

  if (v14 < v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x694uLL,  0);
  }
  BOOL v16 = (char *)(v3 + 16 * v13 + 32);
  swift_bridgeObjectRetain(a1, v8, v9, v10);
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(a1 + 32), v15, v16);
  swift_bridgeObjectRelease(a1);
  if (v15 < v2) {
    goto LABEL_32;
  }
  uint64_t v17 = *(void *)(v3 + 16);
  uint64_t v18 = v17 + v15;
  if (!__OFADD__(v17, v15))
  {
    *(void *)(v3 + 16) = v18;
    if (v15 == v14)
    {
      uint64_t v19 = *(void *)(a1 + 16);
      if (v15 != v19)
      {
        specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v15, 1, a1);
        unint64_t v43 = v15 + 1;
        uint64_t v20 = (uint64_t *)(a1 + 32 + 16 * v15);
        uint64_t v22 = *v20;
        unint64_t v21 = v20[1];
        swift_bridgeObjectRetain(v21, v23, v24, v25);
        unint64_t v41 = v1;
        uint64_t v39 = v19;
        while (1)
        {
LABEL_20:
          unint64_t v28 = *(void *)(v3 + 24);
          int64_t v29 = v18 + 1;
          uint64_t v3 = *v1;
          uint64_t v30 = *(void *)(*v1 + 24) >> 1;
          uint64_t v31 = v18 - v30;
          if (v18 < v30) {
            break;
          }
          *(void *)(v3 + 16) = v18;
        }

        uint64_t v40 = *(void *)(*v1 + 24) >> 1;
        uint64_t v32 = v18;
        uint64_t v33 = 0LL;
        uint64_t v34 = 0LL;
        uint64_t v35 = v19 - v43;
        unint64_t v36 = a1 + 16 * v43;
        uint64_t v42 = v32;
        uint64_t v37 = v3 + 16 * v32;
        while (1)
        {
          uint64_t v38 = v37 + v33;
          *(void *)(v38 + 32) = v22;
          *(void *)(v38 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v21;
          if (v35 == v34) {
            break;
          }
          if ((int64_t)(v43 + v34) >= *(void *)(a1 + 16)) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
          }
          uint64_t v22 = *(void *)(v36 + v33 + 32);
          unint64_t v21 = *(void *)(v36 + v33 + 40);
          swift_bridgeObjectRetain(v21, v29, v26, v27);
          ++v34;
          v33 += 16LL;
          if (!(v31 + v34))
          {
            v43 += v34;
            uint64_t v1 = v41;
            uint64_t v18 = v40;
            uint64_t v19 = v39;
            *(void *)(v3 + 16) = v40;
            goto LABEL_20;
          }
        }

        *(void *)(v3 + 16) = v42 + v34 + 1;
        swift_bridgeObjectRelease(a1);
        uint64_t v1 = v41;
        goto LABEL_18;
      }
    }

{
  uint64_t *v1;
  unint64_t v2;
  uint64_t v3;
  int64_t v4;
  int64_t v5;
  BOOL isUniquelyReferenced_nonNull_native;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  int64_t v12;
  int64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int64_t v18;
  uint64_t v19;
  char *v20;
  unint64_t *v21;
  unint64_t v22;
  int64_t v23;
  int64_t v24;
  unint64_t *v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  unint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *v1;
  int64_t v4 = *(void *)(*v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
    goto LABEL_42;
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  uint64_t *v1 = v3;
  if (!isUniquelyReferenced_nonNull_native || (int64_t v11 = *(void *)(v3 + 24) >> 1, v11 < v5))
  {
    if (v4 <= v5) {
      int64_t v12 = v4 + v2;
    }
    else {
      int64_t v12 = v4;
    }
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)isUniquelyReferenced_nonNull_native,  v12,  1);
    uint64_t v3 = *v1;
    int64_t v11 = *(void *)(*v1 + 24) >> 1;
  }

  uint64_t v13 = *(void *)(v3 + 16);
  unint64_t v14 = v11 - v13;
  if (v11 - v13 < 0) {
LABEL_42:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  unint64_t v15 = *(void *)(a1 + 16);
  if (!v15)
  {
    if (!v2)
    {
      if (v11 == v13)
      {
        uint64_t v17 = 0LL;
        goto LABEL_19;
      }

LABEL_43:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x35AuLL,  0);
  }

  if (v14 < v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x694uLL,  0);
  }
  swift_bridgeObjectRetain(a1, v8, v9, v10);
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(a1 + 32), v15, (char *)(v3 + 32 * v13 + 32));
  swift_bridgeObjectRelease(a1);
  if (v15 < v2) {
    goto LABEL_43;
  }
  BOOL v16 = *(void *)(v3 + 16);
  uint64_t v13 = v16 + v15;
  if (__OFADD__(v16, v15))
  {
    __break(1u);
    return;
  }

  *(void *)(v3 + 16) = v13;
  if (v15 != v14) {
    goto LABEL_38;
  }
  uint64_t v17 = *(void *)(a1 + 16);
  if (v15 == v17)
  {
LABEL_19:
    uint64_t v30 = 0u;
    uint64_t v31 = 0u;
    goto LABEL_20;
  }

  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v15, 1, a1);
  outlined init with copy of Any(a1 + 32 + 32 * v15++, (uint64_t)&v30);
LABEL_20:
  outlined init with copy of Any?((uint64_t)&v30, (uint64_t)&v28);
  while (v29)
  {
    outlined destroy of Any?((uint64_t *)&v28);
    unint64_t v21 = (unint64_t *)*v1;
    uint64_t v22 = *(void *)(*v1 + 24);
    uint64_t v23 = v22 >> 1;
    uint64_t v24 = v13 + 1;
    if ((uint64_t)(v22 >> 1) < v13 + 1)
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v22 > 1),  v24,  1);
      unint64_t v21 = (unint64_t *)*v1;
      uint64_t v23 = *(void *)(*v1 + 24) >> 1;
    }

    swift_retain(v21, v24, v19, v20);
    outlined init with copy of Any?((uint64_t)&v30, (uint64_t)&v26);
    if (v27)
    {
      if (v13 <= v23) {
        uint64_t v18 = v23;
      }
      else {
        uint64_t v18 = v13;
      }
      uint64_t v25 = &v21[4 * v13 + 4];
      while (1)
      {
        outlined init with take of Any(&v26, &v28);
        if (v18 == v13) {
          break;
        }
        outlined destroy of Any?((uint64_t *)&v30);
        outlined init with take of Any(&v28, v25);
        if (v15 == v17)
        {
          uint64_t v30 = 0u;
          uint64_t v31 = 0u;
          unint64_t v15 = v17;
        }

        else
        {
          if ((int64_t)v15 >= *(void *)(a1 + 16)) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
          }
          outlined init with copy of Any(a1 + 32 + 32 * v15++, (uint64_t)&v30);
        }

        outlined init with copy of Any?((uint64_t)&v30, (uint64_t)&v26);
        v25 += 4;
        ++v13;
        if (!v27) {
          goto LABEL_22;
        }
      }

      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v28);
      swift_release((uint64_t)v21);
      uint64_t v13 = v18;
    }

    else
    {
LABEL_22:
      swift_release((uint64_t)v21);
      outlined destroy of Any?((uint64_t *)&v26);
      uint64_t v18 = v13;
    }

    *(void *)(*v1 + 16) = v18;
    outlined init with copy of Any?((uint64_t)&v30, (uint64_t)&v28);
  }

  outlined destroy of Any?((uint64_t *)&v30);
  swift_bridgeObjectRelease(a1);
  outlined destroy of Any?((uint64_t *)&v28);
}

      if (!v24)
      {
        int64_t v4 = v18;
        int64_t v5 = 0;
        goto LABEL_70;
      }

      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v10))
      {
        unint64_t v28 = (int64_t)&v23->isa + 1;
LABEL_47:
        uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v28,  1,  (uint64_t)v10);
      }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  __src = 0u;
  uint64_t v26 = 0u;
  unint64_t v14 = a4(&__src, 32LL, a1, a2, a3 & 1);
  if (v14 < 0) {
    goto LABEL_43;
  }
  int64_t v5 = v14;
  if (!v14) {
    return 0LL;
  }
  uint64_t v18 = v14 - 8;
  uint64_t v19 = 8LL;
  if (v14 < 8) {
    uint64_t v19 = v14;
  }
  uint64_t result = __src;
  if (v19 != 1)
  {
    uint64_t result = __src | ((unint64_t)BYTE1(__src) << 8);
    if (v19 != 2)
    {
      result |= (unint64_t)BYTE2(__src) << 16;
      if (v19 != 3)
      {
        result |= (unint64_t)BYTE3(__src) << 24;
        if (v19 != 4)
        {
          result |= (unint64_t)BYTE4(__src) << 32;
          if (v19 != 5)
          {
            result |= (unint64_t)BYTE5(__src) << 40;
            if (v19 != 6)
            {
              result |= (unint64_t)BYTE6(__src) << 48;
              if (v19 != 7) {
                result |= (unint64_t)BYTE7(__src) << 56;
              }
            }
          }
        }
      }
    }
  }

  uint64_t v20 = 0LL;
  if (v5 >= 9)
  {
    unint64_t v21 = 0LL;
    uint64_t v22 = (unsigned __int8 *)&__src + 8;
    uint64_t v23 = v18 & ~(v18 >> 63);
    while (v23 > v5 - 9)
    {
      uint64_t v24 = *v22++;
      v20 |= (unint64_t)v24 << v21;
      v21 += 8LL;
      if (!--v18) {
        return result;
      }
    }

      (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v6 + 96))( v140,  v11,  v76,  a2,  v6);
      uint64_t v148 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v48,  v144,  a2);
      uint64_t v149 = v48;
      uint64_t v150 = a2;
      uint64_t v139 = (void (*)(char *, uint64_t))v214;
LABEL_44:
      v139(v149, v150);
      uint64_t v135 = v213;
      if ((v148 & 1) == 0) {
        goto LABEL_54;
      }
      goto LABEL_50;
    }

    if ((v141(v11, v76) & 1) != 0)
    {
      uint64_t v140 = v215;
      uint64_t v143 = v201(v11, v76);
      uint64_t v144 = v212;
      if (v207(a2, v6) < v143)
      {
        uint64_t v145 = v6;
        v198(v48, v144, a2);
        uint64_t v135 = v213;
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v76 + 96))( v48,  a2,  v145,  v11,  v76);
LABEL_34:
        uint64_t v136 = swift_getAssociatedConformanceWitness( v197,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        uint64_t v137 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v136 + 16))( v140,  v135,  v11,  v136);
        unint64_t v138 = *(void (**)(char *, unint64_t *))(v130 + 8);
        v138(v135, v11);
        v138(v140, v11);
        uint64_t v139 = (void (*)(char *, uint64_t))v214;
        if ((v137 & 1) == 0) {
          goto LABEL_54;
        }
        goto LABEL_50;
      }

      uint64_t v151 = v191;
      char v152 = v190;
      uint64_t v153 = swift_getAssociatedConformanceWitness( (uint64_t)v191,  (uint64_t)v11,  v190,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v154 = v189;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v153 + 8))( &unk_18180BE68,  256LL,  v152,  v153);
      uint64_t v155 = v213;
      uint64_t v156 = v154;
      uint64_t v130 = v196;
      (*((void (**)(char *, unint64_t *, const char *))v151 + 3))(v156, v11, v151);
      uint64_t v157 = swift_getAssociatedConformanceWitness( v197,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v152) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v157 + 16))( v140,  v155,  v11,  v157);
      uint64_t v158 = *(void (**)(char *, unint64_t *))(v130 + 8);
      v158(v155, v11);
      uint64_t v159 = v187;
      (*(void (**)(char *, char *, unint64_t *))(v130 + 32))(v187, v140, v11);
      uint64_t v160 = v185;
      v198(v185, v144, a2);
      if ((v152 & 1) != 0)
      {
        uint64_t v139 = (void (*)(char *, uint64_t))v214;
        ((void (*)(char *, uint64_t))v214)(v160, a2);
        v158(v159, v11);
        uint64_t v135 = v213;
        uint64_t v48 = v180;
        goto LABEL_50;
      }

      uint64_t v172 = v200;
      unint64_t v173 = v159;
      uint64_t v48 = v180;
      (*((void (**)(char *, unint64_t *, unint64_t, uint64_t, char *))v200 + 12))( v173,  v11,  v76,  a2,  v200);
      uint64_t v148 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v172 + 4) + 8LL) + 16LL))( v48,  v160,  a2);
      uint64_t v139 = (void (*)(char *, uint64_t))v214;
      ((void (*)(char *, uint64_t))v214)(v48, a2);
      uint64_t v149 = v160;
      uint64_t v150 = a2;
      goto LABEL_44;
    }

    uint64_t v140 = v215;
    uint64_t v147 = v201(v11, v76);
    uint64_t v144 = v212;
    if (v147 < v207(a2, v6)) {
      goto LABEL_43;
    }
    uint64_t v161 = v193;
    ((void (*)(void *, uint64_t))v182)(&unk_18180BE68, 256LL);
    ((void (*)(char *, uint64_t, const char *))v181)(v161, a2, v195);
    char v162 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8LL) + 40LL))( v144,  v48,  a2);
    ((void (*)(char *, uint64_t))v214)(v48, a2);
    uint64_t v163 = v188;
    (*(void (**)(char *, char *, unint64_t *))(v130 + 32))(v188, v140, v11);
    uint64_t v164 = v186;
    v198(v186, v144, a2);
    if ((v162 & 1) == 0) {
      break;
    }
    uint64_t v165 = v6;
    uint64_t v135 = v213;
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v76 + 96))( v164,  a2,  v165,  v11,  v76);
    uint64_t v166 = swift_getAssociatedConformanceWitness( v197,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    uint64_t v167 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v166 + 16))( v163,  v135,  v11,  v166);
    uint64_t v168 = v163;
    unint64_t v169 = *(void (**)(char *, unint64_t *))(v130 + 8);
    v169(v135, v11);
    v169(v168, v11);
    uint64_t v144 = v212;
    uint64_t v139 = (void (*)(char *, uint64_t))v214;
    if ((v167 & 1) == 0) {
      goto LABEL_54;
    }
LABEL_50:
    uint64_t v170 = v205;
    Swift::String::Index v171 = v209;
    specialized static FixedWidthInteger._random<A>(using:)(a2, v209, v205);
    ((void (*)(char *, char *, char *, uint64_t, uint64_t))v199)(v48, v135, v210, a2, v171);
    v139((char *)v170, a2);
    (*(void (**)(char *, char *, uint64_t))(v206 + 40))(v211, v48, a2);
    uint64_t v133 = v204;
    (*(void (**)(char *, char *, unint64_t *))(v130 + 40))(v204, v135, v11);
    uint64_t v6 = (uint64_t)v200;
  }

  uint64_t v174 = v164;
  uint64_t v139 = (void (*)(char *, uint64_t))v214;
  ((void (*)(char *, uint64_t))v214)(v174, a2);
  (*(void (**)(char *, unint64_t *))(v130 + 8))(v163, v11);
  uint64_t v144 = v212;
LABEL_54:
  v139(v144, a2);
LABEL_55:
  uint64_t v119 = TupleTypeMetadata2;
  uint64_t v120 = v184;
LABEL_56:
  uint64_t v175 = v211;
  v198(v179, v211, a2);
  return (*(uint64_t (**)(char *, unint64_t *))(v120 + 8))(v175, v119);
}

      v221(v49, v123, a3);
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v134 + 96))( v49,  a3,  v241,  v12,  v134);
      uint64_t v150 = swift_getAssociatedConformanceWitness( v220,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      uint64_t v151 = v240;
      char v152 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v150 + 16))( v240,  v25,  v12,  v150);
      uint64_t v130 = v239;
      uint64_t v153 = *(void (**)(char *, unint64_t *))(v239 + 8);
      v153(v25, v12);
      uint64_t v154 = v151;
      uint64_t v123 = v219;
      v153(v154, v12);
      uint64_t v131 = v49;
      goto LABEL_48;
    }

    if ((v135(v12, v134) & 1) != 0)
    {
      uint64_t v137 = v224(v12, v134);
      if (((uint64_t (*)(uint64_t, uint64_t))v234)(a3, v241) >= v137)
      {
        unint64_t v138 = v213;
        uint64_t v139 = v212;
        uint64_t v140 = swift_getAssociatedConformanceWitness( (uint64_t)v213,  (uint64_t)v12,  v212,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v141 = v25;
        uint64_t v142 = v211;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v140 + 8))( &unk_18180BE68,  256LL,  v139,  v140);
        (*((void (**)(char *, unint64_t *, const char *))v138 + 3))(v142, v12, v138);
        uint64_t v143 = swift_getAssociatedConformanceWitness( v220,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        uint64_t v144 = v240;
        LOBYTE(v139) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v143 + 16))( v240,  v141,  v12,  v143);
        uint64_t v145 = v239;
        uint64_t v146 = *(void (**)(char *, unint64_t *))(v239 + 8);
        uint64_t v147 = v141;
        uint64_t v123 = v219;
        v146(v147, v12);
        (*(void (**)(char *, char *, unint64_t *))(v145 + 32))(v217, v144, v12);
        uint64_t v148 = v207;
        v221(v207, v123, a3);
        if ((v139 & 1) != 0)
        {
          uint64_t v129 = (void (*)(char *, uint64_t))v238;
          ((void (*)(char *, uint64_t))v238)(v148, a3);
          v146(v217, v12);
          uint64_t v130 = v239;
          uint64_t v25 = v218;
          uint64_t v131 = v49;
          goto LABEL_36;
        }

        uint64_t v166 = v241;
        (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v241 + 96))( v217,  v12,  v134,  a3,  v241);
        unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v166 + 32) + 8LL) + 16LL))( v49,  v148,  a3);
        uint64_t v129 = (void (*)(char *, uint64_t))v238;
        ((void (*)(char *, uint64_t))v238)(v49, a3);
        v129(v148, a3);
        goto LABEL_51;
      }

      goto LABEL_43;
    }

    uint64_t v155 = v224(v12, v134);
    if (v155 < ((uint64_t (*)(uint64_t, uint64_t))v234)(a3, v241))
    {
      uint64_t v156 = v241;
      (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v241 + 96))( v240,  v12,  v134,  a3,  v241);
      unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v156 + 32) + 8LL) + 16LL))( v49,  v123,  a3);
      uint64_t v129 = (void (*)(char *, uint64_t))v238;
      ((void (*)(char *, uint64_t))v238)(v49, a3);
LABEL_51:
      uint64_t v130 = v239;
      uint64_t v25 = v218;
LABEL_35:
      uint64_t v131 = v49;
      if ((v128 & 1) == 0) {
        goto LABEL_61;
      }
      goto LABEL_36;
    }

    uint64_t v157 = v214;
    ((void (*)(void *, uint64_t))v205)(&unk_18180BE68, 256LL);
    ((void (*)(char *, uint64_t, const char *))v204)(v157, a3, v216);
    uint64_t v158 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v241 + 32) + 8LL) + 40LL))( v123,  v49,  a3);
    ((void (*)(char *, uint64_t))v238)(v49, a3);
    uint64_t v130 = v239;
    uint64_t v159 = v209;
    (*(void (**)(char *, char *, unint64_t *))(v239 + 32))(v209, v240, v12);
    uint64_t v160 = v208;
    v221(v208, v123, a3);
    if ((v158 & 1) == 0) {
      break;
    }
    uint64_t v161 = v160;
    uint64_t v25 = v218;
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v134 + 96))( v161,  a3,  v241,  v12,  v134);
    char v162 = swift_getAssociatedConformanceWitness( v220,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v152 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v162 + 16))( v159,  v25,  v12,  v162);
    uint64_t v131 = v49;
    uint64_t v163 = v159;
    uint64_t v164 = *(void (**)(char *, unint64_t *))(v130 + 8);
    v164(v25, v12);
    uint64_t v165 = v163;
    uint64_t v123 = v219;
    v164(v165, v12);
LABEL_48:
    uint64_t v129 = (void (*)(char *, uint64_t))v238;
    if ((v152 & 1) == 0) {
      goto LABEL_61;
    }
LABEL_36:
    unint64_t v132 = v229;
    uint64_t v133 = v235;
    static FixedWidthInteger._random<A>(using:)(v232, a3, v230, v235, v231, v229);
    v222(v131, v25, (uint64_t)v237, a3, v133);
    v129((char *)v132, a3);
    (*(void (**)(char *, char *, uint64_t))(v233 + 40))(v236, v131, a3);
    uint64_t v126 = v227;
    (*(void (**)(char *, char *, unint64_t *))(v130 + 40))(v227, v25, v12);
    uint64_t v49 = v131;
    uint64_t v96 = v228;
  }

  uint64_t v129 = (void (*)(char *, uint64_t))v238;
  ((void (*)(char *, uint64_t))v238)(v160, a3);
  (*(void (**)(char *, unint64_t *))(v130 + 8))(v159, v12);
LABEL_61:
  v129(v123, a3);
LABEL_62:
  BOOL v196 = v236;
  v221(v203, v236, a3);
  return (*(uint64_t (**)(char *, unint64_t *))(v202 + 8))(v196, TupleTypeMetadata2);
}

  char v102 = v111;
  uint64_t v103 = swift_bridgeObjectRetain((unint64_t)v41, v37, v38, v39);
  uint64_t v104 = _ArrayBuffer.requestNativeBuffer()(v103, (uint64_t *)v18);
  swift_bridgeObjectRelease((uint64_t)v41);
  if (!v104)
  {
    uint64_t v143 = v41;
    uint64_t v107 = type metadata accessor for Array(0LL, v18, v105, v106);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v107, v108);
    uint64_t v104 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v143, v107, WitnessTable);
  }

  swift_bridgeObjectRelease((uint64_t)v41);
  *char v102 = v104;
}

        if ((v7 & 0x1000000000000000LL) != 0)
        {
          v43._Swift::UInt64 rawBits = v22._rawBits;
          uint64_t v119 = a1;
          uint64_t v127 = v21;
          int64_t v44 = a5;
          unint64_t v45 = v14;
          uint64_t v46 = v16;
          uint64_t v104 = v8;
          uint64_t v111 = v13;
          uint64_t v91 = v11;
          uint64_t v97 = rawBits;
          uint64_t v47 = v12;
          uint64_t v48 = v17;
          uint64_t v84 = v7;
          uint64_t v49 = v18;
          uint64_t v50 = v19;
          uint64_t v51 = v20;
          uint64_t v52 = v23;
          uint64_t v53 = v33;
          v54._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v43)._rawBits;
          uint64_t v33 = v53;
          uint64_t v23 = v52;
          a1 = v119;
          unint64_t v21 = v127;
          uint64_t v20 = v51;
          uint64_t v19 = v50;
          uint64_t v18 = v49;
          uint64_t v17 = v48;
          int64_t v12 = v47;
          uint64_t v7 = v84;
          int64_t v11 = v91;
          Swift::UInt64 rawBits = v97;
          uint64_t v8 = v104;
          uint64_t v13 = v111;
          BOOL v16 = v46;
          unint64_t v14 = v45;
          a5 = v44;
          v22._Swift::UInt64 rawBits = v54._rawBits;
        }

        else
        {
          uint64_t v40 = v22._rawBits >> 16;
          if ((v7 & 0x2000000000000000LL) != 0)
          {
            uint64_t v131 = v8;
            unint64_t v132 = v18;
            uint64_t v42 = *((unsigned __int8 *)&v131 + v40);
          }

          else
          {
            unint64_t v41 = (unsigned __int8 *)v19;
            if ((v8 & 0x1000000000000000LL) == 0)
            {
              uint64_t v62 = v8;
              uint64_t v122 = a1;
              uint64_t v130 = v21;
              unint64_t v63 = v7;
              uint64_t v64 = a5;
              uint64_t v65 = v14;
              uint64_t v87 = v16;
              uint64_t v93 = v11;
              uint64_t v106 = v8;
              uint64_t v114 = v13;
              unint64_t v99 = rawBits;
              unint64_t v66 = v12;
              uint64_t v67 = v17;
              uint64_t v68 = v7;
              uint64_t v69 = v18;
              uint64_t v70 = v19;
              uint64_t v71 = v20;
              uint64_t v72 = v23;
              uint64_t v79 = v33;
              unint64_t v41 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v62, v63);
              uint64_t v33 = v79;
              uint64_t v23 = v72;
              uint64_t v20 = v71;
              uint64_t v19 = v70;
              uint64_t v18 = v69;
              uint64_t v7 = v68;
              uint64_t v17 = v67;
              int64_t v12 = v66;
              int64_t v11 = v93;
              Swift::UInt64 rawBits = v99;
              uint64_t v8 = v106;
              uint64_t v13 = v114;
              a1 = v122;
              unint64_t v21 = v130;
              BOOL v16 = v87;
              unint64_t v14 = v65;
              a5 = v64;
            }

            uint64_t v42 = v41[v40];
          }

          unint64_t v55 = (char)v42;
          uint64_t v56 = __clz(v42 ^ 0xFF) - 24;
          if (v55 >= 0) {
            LOBYTE(v56) = 1;
          }
          v22._Swift::UInt64 rawBits = ((v40 + v56) << 16) | 5;
        }

        *(_DWORD *)(v12 + 4 * v13++) = v33;
        if (v11 == v13) {
          goto LABEL_59;
        }
      }
    }

    v22._Swift::UInt64 rawBits = a4._rawBits;
LABEL_59:
    uint64_t v13 = v11;
  }

  else
  {
    uint64_t v13 = 0LL;
    v22._Swift::UInt64 rawBits = a4._rawBits;
  }

          v151(v141, v85);
          uint64_t v129 = v151;
          goto LABEL_44;
        }
      }

      else if (v143 <= 32)
      {
        v130(v86, v141, v85);
        uint64_t v160 = v127(v85, v16);
        uint64_t v161 = v86;
        uint64_t v151 = (void (*)(char *, uint64_t))v277;
        v277(v161, v85);
        uint64_t v155 = v279 >= v160;
        goto LABEL_40;
      }

      uint64_t v156 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v16 + 96);
      uint64_t v157 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v143, v144, v145);
      v156(&v279, &type metadata for UInt32, v157, v85, v16);
      uint64_t v158 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v16 + 32) + 8LL) + 16LL))( v86,  v141,  v85);
      uint64_t v159 = v86;
      uint64_t v151 = (void (*)(char *, uint64_t))v277;
      v277(v159, v85);
      uint64_t v131 = v270;
      if ((v158 & 1) != 0) {
        goto LABEL_58;
      }
      goto LABEL_43;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  uint64_t v42 = v98;
  unint64_t v43 = v38(a5, a7);
  if (v43 < 64)
  {
    uint64_t v46 = v101;
    v37(v101, (uint64_t)v42, a5);
    uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
    v40(v46, a5);
    uint64_t v48 = v108;
    if (v47 < v111) {
      goto LABEL_43;
    }
    goto LABEL_23;
  }

  uint64_t v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
  char v60 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
  unint64_t v61 = v101;
  v59(&v111, &type metadata for Int, v60, a5, a7);
  uint64_t v57 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v98,  v61,  a5);
  uint64_t v58 = v61;
  uint64_t v42 = v98;
LABEL_13:
  v40(v58, a5);
  uint64_t v48 = v108;
  if ((v57 & 1) != 0) {
    goto LABEL_43;
  }
LABEL_23:
  v40(v42, a5);
LABEL_24:
  uint64_t v75 = v38(a5, a7);
  v37(v26, (uint64_t)v36, a5);
  if (v75 < 65)
  {
    uint64_t v83 = v38(a5, a7);
    v40(v26, a5);
    if (v83 != 64 || (v109(a5, a7) & 1) != 0) {
      goto LABEL_37;
    }
  }

  else
  {
    v40(v26, a5);
  }

  v37(v48, (uint64_t)v36, a5);
  uint64_t v111 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v76 = v109(a5, a7);
  uint64_t v77 = v38(a5, a7);
  if ((v76 & 1) != 0)
  {
    if (v77 > 64)
    {
      uint64_t v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
      uint64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v77, v78, v79);
      char v82 = &v111;
      goto LABEL_35;
    }
  }

  else if (v77 > 63)
  {
    uint64_t v110 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
    uint64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v77, v78, v79);
    char v82 = &v110;
LABEL_35:
    uint64_t v85 = v101;
    v80(v82, &type metadata for Int, v81, a5, a7);
    uint64_t v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v85,  v48,  a5);
    v40(v85, a5);
    if ((v86 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_36;
  }

  uint64_t v84 = v101;
  v37(v101, (uint64_t)v48, a5);
  (*(void (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v40(v84, a5);
LABEL_36:
  v40(v48, a5);
LABEL_37:
  uint64_t v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v40(v36, a5);
  uint64_t v88 = v106;
  unint64_t v89 = v102;
  uint64_t v90 = v107;
  (*((void (**)(uint64_t, uint64_t, uint64_t, uint64_t))v105 + 18))(v107, v87, v106, v103);
  uint64_t v91 = v104;
  uint64_t v92 = *(void *)(v104 - 8);
  (*(void (**)(uint64_t, unint64_t))(v92 + 8))(v90, v104);
  uint64_t v93 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v92 + 48))(v89, 1LL, v91);
  if (v93 == 1)
  {
    (*(void (**)(char *, uint64_t))(v99 + 8))(v89, v100);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v92 + 16))(v90, v88, v91);
  }

  else
  {
    (*(void (**)(uint64_t, char *, unint64_t))(v92 + 32))(v90, v89, v91);
  }

  return v93 != 1;
}

            __break(1u);
            goto LABEL_44;
          }

  if (v31 == 1) {
    v30(v29, 3LL, 0LL);
  }
  if (__p)
  {
    unint64_t v43 = __p;
    operator delete(__p);
  }

  if (v40 == v39)
  {
    unint64_t v27 = 4LL;
    goto LABEL_51;
  }

  if (v40)
  {
    unint64_t v27 = 5LL;
    BOOL v16 = v40;
LABEL_51:
    (*(void (**)(void *))(*v16 + 8 * v27))(v16);
  }

  if (v38 == v37)
  {
    unint64_t v28 = 4LL;
  }

  else
  {
    if (!v38) {
      return;
    }
    unint64_t v28 = 5LL;
    unint64_t v15 = v38;
  }

  (*(void (**)(void *))(*v15 + 8 * v28))(v15);
}
}

  uint64_t v32 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v32 || v32 + 24 > *((void *)a1 + 2))
  {
    uint64_t v33 = 2LL * *((void *)a1 + 4);
    if (v33 <= 0x20) {
      uint64_t v33 = 32LL;
    }
    *((void *)a1 + 4) = v33;
    uint64_t v34 = v33 + 8;
    uint64_t v35 = malloc(v33 + 8);
    *uint64_t v35 = *((void *)a1 + 3);
    uint64_t v32 = ((unint64_t)v35 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)a1 + 2) = (char *)v35 + v34;
    *((void *)a1 + 3) = v35;
  }

  *((void *)a1 + 1) = v32 + 24;
  *(_WORD *)(v32 + 16) = 216;
  *(_BYTE *)(v32 + 18) = 4;
  *(void *)uint64_t v32 = v23;
  swift::Demangle::__runtime::Node::addChild((unsigned int *)v13, (swift::Demangle::__runtime::Node *)v32, a1, a4, a5);
  return v13;
}

  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
}

    uint64_t v33 = v10;
    if (v32 >= 2) {
      uint64_t v33 = (uint64_t *)*v10;
    }
    uint64_t v34 = v33[v11];
LABEL_48:
    uint64_t v35 = *(unsigned __int8 *)(v34 + 18);
    unint64_t v36 = (swift::Demangle::__runtime::Node **)v34;
    if ((v35 - 1) >= 2)
    {
      if (v35 == 5)
      {
        uint64_t v37 = *(swift::Demangle::__runtime::Node **)v34;
        unint64_t v36 = *(swift::Demangle::__runtime::Node ***)v34;
LABEL_56:
        uint64_t v38 = (swift::Demangle::__runtime::Node **)((char *)v37 + 8 * *(unsigned int *)(v34 + 8));
        goto LABEL_62;
      }

      unint64_t v36 = 0LL;
    }

    switch(v35)
    {
      case 1:
        uint64_t v38 = (swift::Demangle::__runtime::Node **)(v34 + 8);
        goto LABEL_62;
      case 2:
        uint64_t v38 = (swift::Demangle::__runtime::Node **)(v34 + 16);
        goto LABEL_62;
      case 5:
        uint64_t v37 = *(swift::Demangle::__runtime::Node **)v34;
        goto LABEL_56;
    }

    uint64_t v38 = 0LL;
LABEL_62:
    while (v36 != v38)
    {
      if (*(_DWORD *)a4) {
        return result;
      }
      ++v36;
    }

    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    ++v11;
    *(_DWORD *)(a4 + 16) = 0;
  }

  if (*((_BYTE *)v5 + 18) == 5 && *((_DWORD *)v5 + 2) >= 4u)
  {
    uint64_t v39 = 0LL;
    uint64_t v40 = (uint64_t *)*((void *)*v5 + 3);
    while (1)
    {
      uint64_t v42 = *((unsigned __int8 *)v40 + 18);
      switch((_DWORD)v42)
      {
        case 1:
          unint64_t v43 = *((unsigned __int8 *)v40 + 18);
          break;
        case 5:
          unint64_t v43 = *((unsigned int *)v40 + 2);
          break;
        case 2:
          unint64_t v43 = 2LL;
          break;
        default:
          goto LABEL_85;
      }

      if (v43 <= v39) {
        break;
      }
      int64_t v44 = v42 - 1;
      if ((_DWORD)v42 != 1)
      {
        if ((_DWORD)v42 == 5) {
          uint64_t v42 = *((unsigned int *)v40 + 2);
        }
        else {
          uint64_t v42 = 2LL;
        }
      }

      if (v42 <= v39)
      {
        unint64_t v41 = 0LL;
      }

      else
      {
        unint64_t v45 = v40;
        if (v44 >= 2) {
          unint64_t v45 = (uint64_t *)*v40;
        }
        unint64_t v41 = (swift::Demangle::__runtime::Node *)v45[v39];
      }

      ++v39;
      if (*(_DWORD *)a4) {
        return result;
      }
    }
  }

  if (Node)
  {
    uint64_t v46 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*((void **)this + 5), 67);
    swift::Demangle::__runtime::Node::addChild( v46,  (swift::Demangle::__runtime::Node *)Node,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v47,  v48);
    swift::Demangle::__runtime::Node::addChild( v32,  (swift::Demangle::__runtime::Node *)v46,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v49,  v50);
  }

  uint64_t v51 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( *((void **)this + 5),  3);
  swift::Demangle::__runtime::Node::addChild( v32,  v51,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v52,  v53);
  swift::Demangle::__runtime::Node::addChild( (unsigned int *)v51,  (swift::Demangle::__runtime::Node *)v24,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v54,  v55);
  uint64_t v56 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*((void **)this + 5), 207);
  swift::Demangle::__runtime::Node::addChild( v56,  (swift::Demangle::__runtime::Node *)v29,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v57,  v58);
  swift::Demangle::__runtime::Node::addChild( v32,  (swift::Demangle::__runtime::Node *)v56,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v59,  v60);
  return v32;
}

uint64_t ContiguousArray.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int64_t v5 = v4;
  uint64_t v68 = a2;
  uint64_t v9 = *(void *)(a2 + 16);
  uint64_t v71 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v77 = (char *)&v68 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v81 = type metadata accessor for Optional(0LL, v9, v11, v12);
  uint64_t v74 = *(unint64_t **)(v81 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v81);
  unint64_t v15 = (char *)&v68 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v72 = (char *)&v68 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v68 - v19;
  uint64_t v21 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v18);
  char v82 = (char *)&v68 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v69 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v79 = (char *)&v68 - v23;
  uint64_t v24 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 40);
  uint64_t v83 = a4;
  uint64_t v25 = v24(a3, a4);
  uint64_t v26 = *v4;
  Swift::Int v27 = *(void *)(*v5 + 16);
  Swift::Int v28 = v27 + v25;
  if (__OFADD__(v27, v25))
  {
    __break(1u);
    goto LABEL_30;
  }

  uint64_t v76 = v25;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v26);
  uint64_t v73 = v5;
  *int64_t v5 = v26;
  if (!isUniquelyReferenced_nonNull_native || (Swift::Int v30 = *(void *)(v26 + 24) >> 1, v30 < v28))
  {
    if (v27 <= v28) {
      Swift::Int v31 = v28;
    }
    else {
      Swift::Int v31 = v27;
    }
    uint64_t v32 = v73;
    ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( isUniquelyReferenced_nonNull_native,  v31,  1);
    uint64_t v26 = *v32;
    Swift::Int v30 = *(void *)(v26 + 24) >> 1;
  }

  uint64_t v33 = *(void *)(v26 + 16);
  Swift::Int v34 = v30 - v33;
  uint64_t v35 = v81;
  if (v30 - v33 < 0) {
LABEL_30:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  uint64_t v36 = *(void *)(v71 + 72);
  unint64_t v70 = (*(unsigned __int8 *)(v71 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v71 + 80);
  uint64_t v80 = v36;
  unint64_t v37 = v26 + v70 + v36 * v33;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v82, a1, a3);
  unint64_t v38 = v37;
  uint64_t v39 = v83;
  uint64_t v40 = (*(uint64_t (**)(char *, unint64_t, Swift::Int, uint64_t, uint64_t))(v83 + 64))( v79,  v38,  v34,  a3,  v83);
  if (v40 < v76) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x35AuLL,  0);
  }
  uint64_t v41 = v40;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v21 + 8))(a1, a3);
  if (v41 >= 1)
  {
    uint64_t v43 = *(void *)(*v73 + 16);
    BOOL v44 = __OFADD__(v43, v41);
    uint64_t v45 = v43 + v41;
    if (v44)
    {
      __break(1u);
      return result;
    }

    *(void *)(*v73 + 16) = v45;
  }

  if (v41 != v34) {
    return (*(uint64_t (**)(char *, unint64_t))(v69 + 8))(v79, AssociatedTypeWitness);
  }
  uint64_t v46 = (unint64_t **)v73;
  int64_t v47 = *(void *)(*v73 + 16);
  uint64_t v48 = a3;
  unint64_t v49 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v39,  v48,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v75 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v76 = AssociatedConformanceWitness;
  v75(v49);
  uint64_t v51 = (uint64_t)v74;
  uint64_t v52 = v72;
  uint64_t v83 = v74[2];
  ((void (*)(char *, char *, uint64_t))v83)(v72, v20, v35);
  uint64_t v53 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v71 + 48);
  int v54 = v53(v52, 1LL, v9);
  char v82 = *(char **)(v51 + 8);
  unint64_t v55 = v77;
  if (v54 != 1)
  {
    do
    {
      ((void (*)(char *, uint64_t))v82)(v52, v35);
      char v60 = *v46;
      unint64_t v61 = (*v46)[3];
      int64_t v57 = v61 >> 1;
      Swift::Int v62 = v47 + 1;
      if ((uint64_t)(v61 >> 1) < v47 + 1)
      {
        ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v61 > 1, v62, 1);
        unint64_t v55 = v77;
        char v60 = *v46;
        int64_t v57 = (*v46)[3] >> 1;
      }

      swift_retain(v60, v62, v58, v59);
      ((void (*)(char *, char *, uint64_t))v83)(v15, v20, v35);
      int v63 = v53(v15, 1LL, v9);
      uint64_t v74 = v60;
      if (v63 == 1)
      {
LABEL_16:
        swift_release((uint64_t)v74);
        uint64_t v35 = v81;
        ((void (*)(char *, uint64_t))v82)(v15, v81);
        int64_t v57 = v47;
      }

      else
      {
        uint64_t v64 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
        if (v47 > v57) {
          int64_t v57 = v47;
        }
        uint64_t v65 = (char *)v60 + v70 + v80 * v47;
        while (1)
        {
          v64(v55, v15, v9);
          if (v57 == v47) {
            break;
          }
          uint64_t v66 = v81;
          ((void (*)(char *, uint64_t))v82)(v20, v81);
          v64(v65, v55, v9);
          ++v47;
          ((void (*)(unint64_t, uint64_t))v75)(AssociatedTypeWitness, v76);
          unint64_t v55 = v77;
          ((void (*)(char *, char *, uint64_t))v83)(v15, v20, v66);
          int v67 = v53(v15, 1LL, v9);
          v65 += v80;
          if (v67 == 1) {
            goto LABEL_16;
          }
        }

        (*(void (**)(char *, uint64_t))(v71 + 8))(v55, v9);
        swift_release((uint64_t)v74);
        int64_t v47 = v57;
        uint64_t v35 = v81;
      }

      uint64_t v46 = (unint64_t **)v73;
      *(void *)(*v73 + 16) = v57;
      uint64_t v52 = v72;
      ((void (*)(char *, char *, uint64_t))v83)(v72, v20, v35);
    }

    while (v53(v52, 1LL, v9) != 1);
  }

  uint64_t v56 = v82;
  ((void (*)(char *, uint64_t))v82)(v20, v35);
  (*(void (**)(char *, unint64_t))(v69 + 8))(v79, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, uint64_t))v56)(v52, v35);
}

Swift::Void __swiftcall ContiguousArray.reserveCapacityForAppend(newElementsCount:)(Swift::Int newElementsCount)
{
  uint64_t v2 = *v1;
  Swift::Int v3 = *(void *)(*v1 + 16);
  Swift::Int v4 = v3 + newElementsCount;
  if (__OFADD__(v3, newElementsCount))
  {
    __break(1u);
  }

  else
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
    uint64_t *v1 = v2;
    if (!isUniquelyReferenced_nonNull_native || v4 > *(void *)(v2 + 24) >> 1)
    {
      if (v3 <= v4) {
        Swift::Int v6 = v4;
      }
      else {
        Swift::Int v6 = v3;
      }
      ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( isUniquelyReferenced_nonNull_native,  v6,  1);
    }
  }

uint64_t ContiguousArray._customRemoveLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 16);
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty ContiguousArray",  46LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x388uLL,  0);
  }
  uint64_t v7 = v6 - 1;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(v8 - 8);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v9 + 32))( a2,  v5 + ((*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
  + *(void *)(v9 + 72) * (v6 - 1),
    v8);
  *(void *)(v5 + 16) = v7;
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 56))(a2, 0LL, 1LL, v8);
}

char *ContiguousArray.remove(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 16);
  if (v8 <= a1)
  {
    unint64_t v14 = 933LL;
    goto LABEL_6;
  }

  if (a1 < 0)
  {
    unint64_t v14 = 934LL;
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  v14,  0);
  }

  uint64_t v9 = *(void *)(a2 + 16);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = *(void *)(v10 + 72);
  uint64_t v12 = (char *)(v7
  (*(void (**)(uint64_t, char *, uint64_t))(v10 + 32))(a3, v12, v9);
  uint64_t result = UnsafeMutablePointer.moveInitialize(from:count:)(&v12[v11], v8 - 1 - a1, v12, v9);
  *(void *)(v7 + 16) = v8 - 1;
  return result;
}

void ContiguousArray.insert(_:at:)(uint64_t a1, Swift::Int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t v8 = type metadata accessor for CollectionOfOne(0LL, v7, a3, a4);
  MEMORY[0x1895F8858](v8);
  uint64_t v10 = (char *)&v13 - v9;
  ContiguousArray._checkIndex(_:)(a2);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(v10, a1, v7);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v8, v11);
  ContiguousArray.replaceSubrange<A>(_:with:)(a2, a2, (uint64_t)v10, a3, v8, WitnessTable);
}

Swift::Void __swiftcall ContiguousArray.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  uint64_t v4 = *v2;
  if (keepingCapacity)
  {
    uint64_t v5 = v1;
    if (swift_isUniquelyReferenced_nonNull_native(v4))
    {
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v5, v6);
      RandomAccessCollection<>.indices.getter(v5, WitnessTable, (uint64_t)&protocol witness table for Int, (char *)v18);
      uint64_t v8 = v18[0];
      uint64_t v9 = v18[1];
      uint64_t v12 = type metadata accessor for EmptyCollection(0LL, *(void *)(v5 + 16), v10, v11);
      uint64_t v14 = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v12, v13);
      ContiguousArray.replaceSubrange<A>(_:with:)(v8, v9, v15, v5, v12, v14);
      return;
    }

    uint64_t v16 = _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( 0LL,  *(void *)(*v2 + 24) >> 1,  *(uint64_t **)(v5 + 16));
    uint64_t v17 = *v2;
    *uint64_t v2 = (uint64_t)v16;
    uint64_t v4 = v17;
  }

  else
  {
    *uint64_t v2 = (uint64_t)&_swiftEmptyArrayStorage;
  }

  swift_release(v4);
}

void *ContiguousArray.withUnsafeMutableBufferPointer<A>(_:)( void (*a1)(void *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11[3] = a4;
  ContiguousArray._makeMutableAndUnique()();
  uint64_t v7 = *(void *)(*(void *)v4 + 16LL);
  uint64_t v8 = *(unsigned __int8 *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 80LL);
  v11[0] = *(void *)v4 + ((v8 + 32) & ~v8);
  uint64_t v9 = v11[0];
  v11[1] = v7;
  a1(v11);
  return $defer #1 <A><A1>() in ContiguousArray.withUnsafeMutableBufferPointer<A>(_:)(v11, v9, v7);
}

unint64_t *_ContiguousArrayBuffer.requestNativeBuffer()()
{
  uint64_t v0 = (unint64_t *)EnumeratedSequence._base.modify();
  return swift_retain(v0, v1, v2, v3);
}

void protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance ContiguousArray<A>( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance ContiguousArray<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = specialized Array.init(repeating:count:)( a1,  a2,  v6,  (uint64_t (*)(uint64_t, uint64_t))static ContiguousArray._allocateUninitialized(_:));
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8LL))(a1, v6);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ContiguousArray.append<A>(contentsOf:)(a1, a4, a2, a3);
}

void protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance ContiguousArray<A>( uint64_t a1, Swift::Int *a2, uint64_t a3, uint64_t a4)
{
}

char *protocol witness for RangeReplaceableCollection.remove(at:) in conformance ContiguousArray<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return ContiguousArray.remove(at:)(*a1, a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance ContiguousArray<A>( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a3, a3);
  return RangeReplaceableCollection<>.removeAll(where:)(a1, a2, a3, WitnessTable, a4);
}

uint64_t ContiguousArray.customMirror.getter@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = (uint64_t)a1;
  uint64_t v7 = (swift *)type metadata accessor for ContiguousArray(0LL, a2, a3, a4);
  v35[0] = 0LL;
  v35[1] = 0LL;
  swift_retain(a1, v8, v9, v10);
  uint64_t v11 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v38, (uint64_t)v35, v7);
  uint64_t v13 = v12;
  uint64_t v14 = swift_allocObject((uint64_t)&unk_189B78208, 0x28uLL, 7uLL);
  uint64_t v14[2] = v7;
  v14[3] = v7;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v7, v15);
  v14[4] = WitnessTable;
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for (label: String?, value: Any));
  uint64_t v19 = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v7, v18);
  uint64_t v20 = type metadata accessor for LazyMapSequence(255LL, (uint64_t)v7, v17, v19);
  uint64_t v37 = WitnessTable;
  uint64_t v21 = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v20, &v37);
  uint64_t v23 = type metadata accessor for _CollectionBox(0LL, v20, v21, v22);
  uint64_t v24 = swift_allocObject(v23, 0x48uLL, 7uLL);
  v24[6] = a1;
  v24[7] = closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)partial apply;
  v24[8] = v14;
  uint64_t v25 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v26 = swift_allocObject(v25, 0x18uLL, 7uLL);
  void v26[2] = 0LL;
  unint64_t v27 = a1[2];
  Swift::Int v28 = swift_allocObject(v25, 0x18uLL, 7uLL);
  v28[2] = v27;
  v24[2] = v26;
  uint64_t v24[3] = &protocol witness table for _IndexBox<A>;
  v24[4] = v28;
  v24[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v36 = v38;
  swift_retain(a1, v29, v30, v31);
  uint64_t v32 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v35, &v36, v7, v32, 6uLL);
  char v34 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v35);
  }
  *(void *)a5 = v7;
  *(void *)(a5 + 8) = v24;
  *(_BYTE *)(a5 + 16) = 5;
  *(void *)(a5 + 24) = v11;
  *(void *)(a5 + 32) = v13;
  *(_BYTE *)(a5 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v34;
  return result;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance ContiguousArray<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ContiguousArray.customMirror.getter(*v4, *(void *)(a1 + 16), a2, a3, a4);
}

uint64_t ContiguousArray.description.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v114 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v5);
  uint64_t v9 = (char *)&v114 - v8;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v12 = 91LL;
  unint64_t v13 = 0xE100000000000000LL;
  uint64_t v125 = 91LL;
  unint64_t v126 = 0xE100000000000000LL;
  uint64_t v14 = *(void *)(a1 + 16);
  if (!v14) {
    goto LABEL_49;
  }
  uint64_t v15 = a1 + ((*(unsigned __int8 *)(v4 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  uint64_t v16 = *(void *)(v4 + 72);
  uint64_t v17 = *(void (**)(void, void, void))(v4 + 16);
  char v18 = 1;
  __int128 v122 = xmmword_1817FFC60;
  __int128 v118 = xmmword_1817FFC70;
  Swift::UInt64 v117 = 131073LL;
  uint64_t v116 = v4;
  uint64_t v115 = v7;
  uint64_t v120 = v16;
  uint64_t v121 = v9;
  uint64_t v119 = v17;
  v17(v9, v15, a2);
  while (1)
  {
    uint64_t v24 = *(void (**)(char *, char *, uint64_t))(v4 + 32);
    v24(v7, v9, a2);
    if ((v18 & 1) == 0) {
      break;
    }
LABEL_5:
    uint64_t v21 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v21, v124);
    *((_OWORD *)inited + 1) = v122;
    inited[7] = a2;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v24(boxed_opaque_existential_0Tm, v7, a2);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v125);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    char v18 = 0;
    v15 += v16;
    if (!--v14) {
      goto LABEL_48;
    }
    v17(v9, v15, a2);
  }

  uint64_t v28 = v125;
  uint64_t v27 = v126;
  unint64_t v29 = HIBYTE(v126) & 0xF;
  if ((v126 & 0x2000000000000000LL) != 0) {
    unint64_t v30 = HIBYTE(v126) & 0xF;
  }
  else {
    unint64_t v30 = v125 & 0xFFFFFFFFFFFFLL;
  }
  if (!v30 && (v125 & ~v126 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v126);
    uint64_t v125 = 8236LL;
    unint64_t v64 = 0xE200000000000000LL;
LABEL_44:
    unint64_t v126 = v64;
    goto LABEL_4;
  }

  if ((v126 & 0x2000000000000000LL) != 0 && v29 <= 0xD)
  {
    unint64_t v31 = 8 * (HIBYTE(v126) & 7);
    uint64_t v32 = (-255LL << v31) - 1;
    uint64_t v33 = 44LL << v31;
    char v34 = v29 + 1;
    if (v29 >= 8)
    {
      uint64_t v35 = v33 | v32 & v126;
    }

    else
    {
      uint64_t v28 = v33 | v32 & v125;
      if (v29 != 7)
      {
        uint64_t v28 = (32LL << (8 * (v34 & 7u))) | ((-255LL << (8 * (v34 & 7u))) - 1) & v28;
        uint64_t v63 = v126;
        goto LABEL_41;
      }

      char v34 = 8;
      uint64_t v35 = v126;
    }

    uint64_t v63 = (32LL << (8 * (v34 & 7u))) | ((-255LL << (8 * (v34 & 7u))) - 1) & v35;
LABEL_41:
    swift_bridgeObjectRelease(v126);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v65 = 0xE000000000000000LL;
    if (v28 & 0x8080808080808080LL | v63 & 0x80808080808080LL) {
      unint64_t v65 = 0xA000000000000000LL;
    }
    unint64_t v64 = (v65 & 0xFF00000000000000LL | (v29 << 56) | v63 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
    uint64_t v125 = v28;
    goto LABEL_44;
  }

  swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v25, v26);
  if ((v27 & 0x1000000000000000LL) == 0)
  {
    BOOL v36 = __OFADD__(v30, 2LL);
    int64_t v37 = v30 + 2;
    if (v36) {
      goto LABEL_47;
    }
LABEL_20:
    if ((v28 & ~v27 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v38 = _StringGuts.nativeUnusedCapacity.getter(v28, v27);
      if ((v39 & 1) != 0) {
        goto LABEL_120;
      }
      BOOL v41 = (v27 & 0x2000000000000000LL) == 0 && v38 > 1;
      if (v37 > 15 || v41) {
        goto LABEL_3;
      }
    }

    else if (v37 > 15)
    {
LABEL_3:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v37, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
      __int128 v123 = v118;
      uint64_t v19 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v123, 2LL);
      _StringGuts.appendInPlace(_:isASCII:)(v19, v20, 1);
      swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_4:
      uint64_t v16 = v120;
      uint64_t v9 = v121;
      uint64_t v17 = v119;
      goto LABEL_5;
    }

    swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
    swift_bridgeObjectRetain(v27, v42, v43, v44);
    unint64_t v45 = _StringGuts._convertedToSmall()(v28, v27);
    unint64_t v47 = v46;
    swift_bridgeObjectRelease(v27);
    v48._Swift::UInt64 rawBits = 1LL;
    v49._Swift::UInt64 rawBits = v117;
    v50._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v48, v49, 0x202CuLL, 0xE200000000000000LL);
    if (v50._rawBits < 0x10000) {
      v50._rawBits |= 3;
    }
    unint64_t v52 = specialized String.init(_:)(v50, v51, 0x202CuLL, 0xE200000000000000LL);
    unint64_t v54 = v53;
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v55 = _StringGuts._convertedToSmall()(v52, v54);
    unint64_t v57 = v56;
    swift_bridgeObjectRelease(v54);
    unint64_t v58 = specialized _SmallString.init(_:appending:)(v45, v47, v55, v57);
    if ((v60 & 1) != 0) {
      goto LABEL_119;
    }
    uint64_t v61 = v58;
    unint64_t v62 = v59;
    swift_bridgeObjectRelease(v27);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    uint64_t v125 = v61;
    unint64_t v126 = v62;
    uint64_t v4 = v116;
    uint64_t v7 = v115;
    goto LABEL_4;
  }

  Swift::Int v66 = String.UTF8View._foreignCount()();
  int64_t v37 = v66 + 2;
  if (!__OFADD__(v66, 2LL)) {
    goto LABEL_20;
  }
LABEL_47:
  __break(1u);
LABEL_48:
  uint64_t v12 = v125;
  unint64_t v13 = v126;
LABEL_49:
  unint64_t v67 = HIBYTE(v13) & 0xF;
  unint64_t v68 = v12 & 0xFFFFFFFFFFFFLL;
  if ((v13 & 0x2000000000000000LL) != 0) {
    uint64_t v69 = HIBYTE(v13) & 0xF;
  }
  else {
    uint64_t v69 = v12 & 0xFFFFFFFFFFFFLL;
  }
  if (!v69 && (v12 & ~v13 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v13);
    return 93LL;
  }

  if ((v13 & 0x2000000000000000LL) != 0 && v67 != 15)
  {
    if (v67 < 8) {
      uint64_t v12 = (93LL << (8 * (HIBYTE(v13) & 7u))) | ((-255LL << (8 * (HIBYTE(v13) & 7u))) - 1) & v12;
    }
    goto LABEL_58;
  }

  swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v10, v11);
  if ((v13 & 0x1000000000000000LL) != 0)
  {
    Swift::Int v106 = String.UTF8View._foreignCount()();
    uint64_t v70 = v106 + 1;
    if (!__OFADD__(v106, 1LL)) {
      goto LABEL_61;
    }
    goto LABEL_109;
  }

  BOOL v36 = __OFADD__(v69, 1LL);
  uint64_t v70 = v69 + 1;
  if (v36)
  {
LABEL_109:
    __break(1u);
    goto LABEL_110;
  }

LABEL_61:
  unint64_t v71 = v12 & ~v13;
  if ((v71 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v70 <= 15) {
      goto LABEL_78;
    }
LABEL_67:
    int64_t v74 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
    BOOL v77 = (v75 & 1) == 0 && v74 > 0;
    if ((v71 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v77) {
        goto LABEL_103;
      }
    }

    else if (v77)
    {
LABEL_102:
      _StringGuts.grow(_:)(v70);
LABEL_103:
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
      __int128 v123 = xmmword_1817FFC80;
      uint64_t v103 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v123, 1LL);
      _StringGuts.appendInPlace(_:isASCII:)(v103, v104, 1);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return v125;
    }

    uint64_t v99 = _StringGuts.nativeCapacity.getter(v12, v13);
    if ((v100 & 1) != 0) {
      uint64_t v101 = 0LL;
    }
    else {
      uint64_t v101 = v99;
    }
    if (v101 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_119;
    }

    uint64_t v102 = 2 * v101;
    if (v102 > v70) {
      uint64_t v70 = v102;
    }
    goto LABEL_102;
  }

  int64_t v72 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
  if ((v73 & 1) != 0)
  {
LABEL_120:
    unint64_t v110 = 258LL;
LABEL_121:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v110,  0);
  }

  if (v70 > 15) {
    goto LABEL_67;
  }
  if ((v13 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    goto LABEL_79;
  }

  if (v72 > 0) {
    goto LABEL_67;
  }
LABEL_78:
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
  if ((v13 & 0x2000000000000000LL) != 0)
  {
LABEL_79:
    unint64_t v68 = v13;
  }

  else if ((v13 & 0x1000000000000000LL) != 0)
  {
    uint64_t v12 = _StringGuts._foreignConvertedToSmall()(v12, v13);
    unint64_t v68 = v113;
  }

  else
  {
    if ((v12 & 0x1000000000000000LL) != 0)
    {
      uint64_t v109 = (unsigned __int8 *)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v109 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v12, v13);
      unint64_t v68 = v78;
    }

    swift_bridgeObjectRetain(v13, v78, v79, v80);
    closure #1 in _StringGuts._convertedToSmall()(v109, v68, &v123);
    swift_bridgeObjectRelease(v13);
    unint64_t v68 = *((void *)&v123 + 1);
    uint64_t v12 = v123;
  }

  v81._Swift::UInt64 rawBits = 1LL;
  v82._Swift::UInt64 rawBits = 65537LL;
  v83._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v81, v82, 0x5DuLL, 0xE100000000000000LL);
  if (v83._rawBits < 0x10000) {
    v83._rawBits |= 3;
  }
  unint64_t v67 = specialized String.init(_:)(v83, v84, 0x5DuLL, 0xE100000000000000LL);
  uint64_t v70 = v85;
  swift_bridgeObjectRelease(0xE100000000000000LL);
  if ((v70 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v70);
    goto LABEL_84;
  }

      (*(void (**)(char *, uint64_t))(v243 + 8))(v232, v237);
      Swift::Int v356 = (uint64_t)v782;
      ((void (*)(char **, char **))v759)(v778, v782);
      ((void (*)(unint64_t, unint64_t *))v241)(v781, v245);
      if (((*(uint64_t (**)(uint64_t))(v764 + 168))(v779) & 1) != 0)
      {
        uint64_t v357 = v705;
        Swift::Int v361 = v703;
        Swift::String::Index v362 = swift_getAssociatedConformanceWitness( (uint64_t)v705,  v356,  v703,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
        uint64_t v360 = v704;
        (*(void (**)(unint64_t, unint64_t, double))(v362 + 8))(v361, v362, -0.0);
      }

      else
      {
        uint64_t v357 = v729;
        uint64_t v358 = v727;
        uint64_t v359 = swift_getAssociatedConformanceWitness( (uint64_t)v729,  v356,  v727,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v360 = v728;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v359 + 8))( &unk_18180BE68,  256LL,  v358,  v359);
      }

      (*((void (**)(char *, uint64_t, const char *))v357 + 3))(v360, v356, v357);
      return 0LL;
    }

    if (v227 >= v230)
    {
      uint64_t v306 = (void (**)(char *, uint64_t, const char *))v724;
      unint64_t v237 = v758;
      uint64_t v307 = v722;
      uint64_t v308 = swift_getAssociatedConformanceWitness( (uint64_t)v724,  v758,  v722,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v309 = v723;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v308 + 8))( &unk_18180BE68,  256LL,  v307,  v308);
      v306[3](v309, v237, (const char *)v306);
      LOBYTE(v306) = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v229[4] + 1) + 40LL))( v232,  v231,  v237);
      char v310 = v772;
      uint64_t v311 = *(void (**)(char *, uint64_t))(v772 + 8);
      v311(v231, v237);
      uint64_t v312 = v692;
      char v245 = v733;
      (*(void (**)(char *, char *, unint64_t *))(v777 + 32))(v692, v742, v733);
      uint64_t v313 = *(void (**)(char *, char *, uint64_t))(v310 + 16);
      uint64_t v314 = v694;
      v313(v694, v232, v237);
      if ((v306 & 1) == 0)
      {
        v311(v314, v237);
        uint64_t v241 = v766;
        ((void (*)(char *, unint64_t *))v766)(v312, v245);
        uint64_t v246 = v769;
        uint64_t v243 = v772;
        uint64_t v244 = v773;
        uint64_t v242 = v774;
        goto LABEL_66;
      }

      uint64_t v244 = v773;
      uint64_t v315 = v776;
      (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v773 + 96))( v314,  v237,  v774,  v245,  v773);
      uint64_t v316 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v244 + 32) + 8LL)
                                                                           + 16LL))( v312,  v315,  v245);
      uint64_t v317 = v774;
      uint64_t v241 = v766;
      ((void (*)(char *, unint64_t *))v766)(v315, v245);
      ((void (*)(char *, unint64_t *))v241)(v312, v245);
      uint64_t v242 = v317;
      uint64_t v246 = v769;
      uint64_t v243 = v772;
      if ((v316 & 1) != 0) {
        goto LABEL_61;
      }
    }

    else
    {
      uint64_t v254 = v222;
      char v245 = v733;
      uint64_t v244 = v773;
      unint64_t v237 = v758;
      ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v229[12])( v742,  v733,  v773,  v758,  v229);
      LODWORD(v742) = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v229[4] + 1) + 16LL))( v231,  v228,  v237);
      uint64_t v255 = v772;
      (*(void (**)(char *, uint64_t))(v772 + 8))(v231, v237);
      uint64_t v242 = v229;
      uint64_t v243 = v255;
      uint64_t v241 = v766;
      uint64_t v246 = v254;
    }
  }

  else
  {
    uint64_t v247 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v168);
    uint64_t v248 = v768;
    uint64_t v249 = v223;
    unint64_t v173 = v247 < ((uint64_t (*)(uint64_t, char **))v761)(v167, v223);
    uint64_t v250 = v770;
    unint64_t v232 = v248;
    if (v173)
    {
      ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v249[12])( v220,  v125,  v168,  v167,  v249);
      char v251 = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v249[4] + 1) + 16LL))(v250, v248, v167);
      uint64_t v252 = v168;
      unint64_t v237 = v225;
      uint64_t v253 = v772;
      (*(void (**)(char *, uint64_t))(v772 + 8))(v250, v225);
      uint64_t v242 = v249;
      uint64_t v243 = v253;
      char v245 = v125;
      uint64_t v244 = v252;
      uint64_t v246 = v769;
      uint64_t v241 = v766;
      if ((v251 & 1) != 0) {
        goto LABEL_61;
      }
    }

    else
    {
      uint64_t v256 = v168;
      unint64_t v237 = v225;
      id v257 = v772;
      (*(void (**)(char *, char *, uint64_t))(v772 + 16))(v770, v248, v237);
      uint64_t v258 = v776;
      (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v256 + 96))( v250,  v237,  v774,  v125,  v256);
      uint64_t v259 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v256 + 32) + 8LL)
                                                                           + 16LL))( v220,  v258,  v125);
      uint64_t v260 = v258;
      uint64_t v243 = v257;
      uint64_t v246 = v769;
      uint64_t v261 = v774;
      Swift::Bool v262 = v766;
      ((void (*)(char *, unint64_t *))v766)(v260, v125);
      unint64_t v263 = v220;
      uint64_t v241 = v262;
      ((void (*)(char *, unint64_t *))v262)(v263, v125);
      uint64_t v242 = v261;
      char v245 = v125;
      uint64_t v244 = v256;
      if ((v259 & 1) != 0) {
        goto LABEL_61;
      }
    }
  }

          uint64_t v14 = 1;
          *uint64_t v2 = 1;
          goto LABEL_62;
        }

    uint64_t v26 = "_:";
    uint64_t v27 = *(std::string **)(a1 + 8);
    uint64_t v28 = 2LL;
    goto LABEL_62;
  }

  uint64_t v5 = **(unsigned int **)(a1 + 24);
  uint64_t v6 = ***(uint64_t *****)(a1 + 16);
  uint64_t v7 = *((unsigned __int8 *)v6 + 18);
  uint64_t v8 = v7 - 1;
  if ((_DWORD)v7 == 1) {
    goto LABEL_6;
  }
  if ((_DWORD)v7 == 5)
  {
LABEL_15:
    uint64_t v9 = 0LL;
    goto LABEL_16;
  }

  if ((_DWORD)v7 != 2) {
    goto LABEL_15;
  }
  uint64_t v7 = 2LL;
LABEL_6:
  if (v7 <= v5) {
    goto LABEL_15;
  }
LABEL_7:
  if (v8 >= 2) {
    uint64_t v6 = (uint64_t **)*v6;
  }
  uint64_t v9 = v6[v5];
LABEL_16:
  if (*((_WORD *)v9 + 8) != 101)
  {
    uint64_t v16 = 1;
    HIBYTE(v31) = 1;
    uint64_t v17 = 95LL;
    LOWORD(__dst) = 95;
    goto LABEL_29;
  }

  unint64_t v13 = (const void *)*v9;
  if (!*v9)
  {
    uint64_t v17 = 0LL;
    uint64_t v16 = 0;
    __dst = 0LL;
    unint64_t v30 = 0LL;
    unint64_t v31 = 0LL;
    goto LABEL_29;
  }

  uint64_t v14 = v9[1];
  if (v14 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  if (v14 >= 0x17)
  {
    char v18 = (v14 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v14 | 7) != 0x17) {
      char v18 = v14 | 7;
    }
    uint64_t v19 = v18 + 1;
    p_dst = (void **)operator new(v18 + 1);
    unint64_t v30 = v14;
    unint64_t v31 = v19 | 0x8000000000000000LL;
    __dst = p_dst;
  }

  else
  {
    HIBYTE(v31) = v9[1];
    p_dst = (void **)&__dst;
    if (!v14) {
      goto LABEL_28;
    }
  }

  memmove(p_dst, v13, v14);
LABEL_28:
  *((_BYTE *)p_dst + v14) = 0;
  uint64_t v16 = HIBYTE(v31);
  uint64_t v17 = v30;
LABEL_29:
  if ((v16 & 0x80u) == 0) {
    size_t v20 = (const std::string::value_type *)&__dst;
  }
  else {
    size_t v20 = (const std::string::value_type *)__dst;
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v21 = v16;
  }
  else {
    uint64_t v21 = v17;
  }
  std::string::append(v4, v20, v21);
  std::string::push_back(v4, 58);
  if (SHIBYTE(v31) < 0) {
    operator delete(__dst);
  }
LABEL_63:
  if (**(_BYTE **)a1 && **(_BYTE **)(a1 + 32)) {
    std::string::push_back(v4, 32);
  }
  ++**(_DWORD **)(a1 + 24);
  if (**(_BYTE **)(a1 + 32)) {
}
  }

  ++*(void *)(a1 + 24);
  return v12;
}

uint64_t ContiguousArray.debugDescription.getter(void (*a1)(char *, char *, uint64_t), uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v217 = a1;
  uint64_t v3 = *(void *)(a2 - 8);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v211 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v4);
  uint64_t v218 = (char *)&v211 - v7;
  Swift::String v8 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ContiguousArray", 0xFuLL, 1);
  uint64_t countAndFlagsBits = v8._countAndFlagsBits;
  unint64_t object = v8._object;
  unint64_t v223 = 0LL;
  unint64_t v224 = 0xE000000000000000LL;
  uint64_t v11 = specialized static String._createEmpty(withInitialCapacity:)(4LL);
  unint64_t v15 = v11;
  unint64_t v16 = v12;
  *(void *)&__int128 v222 = v11;
  *((void *)&v222 + 1) = v12;
  uint64_t v17 = HIBYTE(v12) & 0xF;
  int64_t v18 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v12 & 0x2000000000000000LL) != 0) {
    uint64_t v19 = HIBYTE(v12) & 0xF;
  }
  else {
    uint64_t v19 = v11 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v214 = v6;
  if (!v19 && (v11 & ~v12 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v12);
    unint64_t v15 = 0LL;
    unint64_t v41 = 0xE000000000000000LL;
    *(void *)&__int128 v222 = 0LL;
LABEL_21:
    *((void *)&v222 + 1) = v41;
    goto LABEL_25;
  }

  if ((v12 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v12);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v45 = 0xA000000000000000LL;
    if (!(v16 & 0x80808080808080LL | v15 & 0x8080808080808080LL)) {
      unint64_t v45 = 0xE000000000000000LL;
    }
    unint64_t v41 = v45 & 0xFF00000000000000LL | (v17 << 56) | v16 & 0xFFFFFFFFFFFFFFLL;
    *(void *)&__int128 v222 = v15;
    goto LABEL_21;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v13, v14);
  if ((v16 & 0x1000000000000000LL) != 0)
  {
    int64_t v18 = String.UTF8View._foreignCount()();
    if ((v15 & ~v16 & 0x2000000000000000LL) == 0) {
      goto LABEL_23;
    }
  }

  else if ((v15 & ~v16 & 0x2000000000000000LL) == 0)
  {
    goto LABEL_23;
  }

  if (swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v15, v16);
    if ((v21 & 1) != 0) {
      goto LABEL_198;
    }
    if (v18 <= 15 && (v20 & 0x8000000000000000LL) != 0) {
      goto LABEL_13;
    }
LABEL_24:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v18, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    uint64_t v219 = 0LL;
    uint64_t v220 = 0LL;
    unint64_t v46 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v219, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v46, v47, 1);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v41 = *((void *)&v222 + 1);
    unint64_t v15 = v222;
    goto LABEL_25;
  }

LABEL_48:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v59, v57);
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 4LL);
    if (((uint64_t)v8._object & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v8._object);
      _StringGuts._foreignAppendInPlace(_:)(v216, (unint64_t)v8._object, 0LL, v54);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      uint64_t v6 = v214;
      uint64_t v3 = v215;
      goto LABEL_76;
    }

    uint64_t v3 = v215;
    if (!v50)
    {
      uint64_t v50 = v216;
      if ((v216 & 0x1000000000000000LL) == 0) {
        goto LABEL_195;
      }
      swift_bridgeObjectRelease((uint64_t)v8._object);
      id v100 = (id)(((uint64_t)v8._object & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v101 = v53;
      uint64_t v6 = v214;
      goto LABEL_70;
    }

    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
    uint64_t v219 = v216;
    uint64_t v220 = (uint64_t)v8._object & 0xFFFFFFFFFFFFFFLL;
    uint64_t v63 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v8._object >> 56) & 0xF,  (uint64_t)&v219,  ((unint64_t)v8._object >> 56) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v63, v64, ((uint64_t)v8._object & 0x4000000000000000LL) != 0);
    goto LABEL_75;
  }

  unint64_t v60 = *((void *)&v222 + 1);
  int64_t v61 = _StringGuts.nativeUnusedCapacity.getter(v222, *((uint64_t *)&v222 + 1));
  if ((v62 & 1) != 0) {
    goto LABEL_198;
  }
  if (v59 > 15 || (v60 & 0x2000000000000000LL) == 0 && v61 >= v57) {
    goto LABEL_48;
  }
LABEL_52:
  swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
  unint64_t v65 = v222;
  swift_bridgeObjectRetain(v60, v66, v67, v68);
  unint64_t v69 = _StringGuts._convertedToSmall()(v65, v60);
  unint64_t v71 = v70;
  swift_bridgeObjectRelease(v60);
  v72._Swift::UInt64 rawBits = (v54 << 16) | 1;
  v73._Swift::UInt64 rawBits = 1LL;
  unint64_t v74 = v216;
  v75._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v73, v72, v216, (unint64_t)v8._object);
  if (v75._rawBits < 0x10000) {
    v75._rawBits |= 3;
  }
  unint64_t v77 = specialized String.init(_:)(v75, v76, v74, (unint64_t)v8._object);
  unint64_t v79 = v78;
  swift_bridgeObjectRelease((uint64_t)v8._object);
  unint64_t v80 = _StringGuts._convertedToSmall()(v77, v79);
  unint64_t v82 = v81;
  swift_bridgeObjectRelease(v79);
  unint64_t v83 = specialized _SmallString.init(_:appending:)(v69, v71, v80, v82);
  uint64_t v3 = v215;
  if ((v85 & 1) != 0)
  {
LABEL_197:
    unint64_t v210 = 266LL;
    goto LABEL_199;
  }

  unint64_t v86 = v83;
  uint64_t v87 = v84;
  swift_bridgeObjectRelease(v60);
  *(void *)&__int128 v222 = v86;
  *((void *)&v222 + 1) = v87;
LABEL_75:
  uint64_t v6 = v214;
  while (1)
  {
LABEL_76:
    uint64_t v105 = v217;
    uint64_t v106 = v222;
    unint64_t v107 = HIBYTE(*((void *)&v222 + 1)) & 0xFLL;
    uint64_t v108 = v222 & 0xFFFFFFFFFFFFLL;
    if ((*((void *)&v222 + 1) & 0x2000000000000000LL) != 0) {
      uint64_t v108 = HIBYTE(*((void *)&v222 + 1)) & 0xFLL;
    }
    if (!v108 && ((unint64_t)v222 & ~*((void *)&v222 + 1) & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(*((uint64_t *)&v222 + 1));
      uint64_t v53 = 0xE200000000000000LL;
      uint64_t v106 = 23336LL;
      goto LABEL_93;
    }

    if ((*((void *)&v222 + 1) & 0x2000000000000000LL) == 0 || v107 > 0xD)
    {
      _StringGuts.append(_:)(23336LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v53 = *((void *)&v222 + 1);
      uint64_t v106 = v222;
      goto LABEL_93;
    }

    uint64_t v109 = 8 * (HIBYTE(*((void *)&v222 + 1)) & 7LL);
    uint64_t v110 = (-255LL << v109) - 1;
    uint64_t v111 = 40LL << v109;
    char v112 = v107 + 1;
    if (v107 >= 8)
    {
      uint64_t v113 = v111 | v110 & *((void *)&v222 + 1);
    }

    else
    {
      uint64_t v106 = v111 | v110 & v222;
      if (v107 != 7)
      {
        uint64_t v106 = (91LL << (8 * (v112 & 7u))) | ((-255LL << (8 * (v112 & 7u))) - 1) & v106;
        uint64_t v117 = *((void *)&v222 + 1);
        goto LABEL_90;
      }

      char v112 = 8;
      uint64_t v113 = *((void *)&v222 + 1);
    }

    uint64_t v117 = (91LL << (8 * (v112 & 7u))) | ((-255LL << (8 * (v112 & 7u))) - 1) & v113;
LABEL_90:
    swift_bridgeObjectRelease(*((uint64_t *)&v222 + 1));
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v118 = 0xA000000000000000LL;
    if (!(v106 & 0x8080808080808080LL | v117 & 0x80808080808080LL)) {
      unint64_t v118 = 0xE000000000000000LL;
    }
    uint64_t v53 = (v118 & 0xFF00000000000000LL | (v107 << 56) | v117 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
    *(void *)&__int128 v222 = v106;
LABEL_93:
    uint64_t v119 = v224;
    unint64_t v120 = HIBYTE(v224) & 0xF;
    if ((v224 & 0x2000000000000000LL) == 0) {
      unint64_t v120 = v223 & 0xFFFFFFFFFFFFLL;
    }
    if (!v120 && (v223 & ~v224 & 0x2000000000000000LL) == 0)
    {
LABEL_151:
      swift_bridgeObjectRelease(v119);
      unint64_t v223 = v106;
      unint64_t v224 = v53;
      uint64_t v127 = *((void *)v105 + 2);
      if (!v127) {
        goto LABEL_152;
      }
LABEL_107:
      uint64_t v53 = (uint64_t)v105 + ((*(unsigned __int8 *)(v3 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
      uint64_t v128 = *(void *)(v3 + 72);
      uint64_t v217 = *(void (**)(char *, char *, uint64_t))(v3 + 16);
      char v129 = 1;
      __int128 v216 = xmmword_1817FFC60;
      __int128 v213 = xmmword_1817FFC70;
      uint64_t v212 = v2;
      uint64_t v215 = v128;
      while (1)
      {
        uint64_t v135 = v218;
        v217(v218, (char *)v53, v2);
        uint64_t v105 = *(void (**)(char *, char *, uint64_t))(v3 + 32);
        v105(v6, v135, v2);
        if ((v129 & 1) != 0) {
          goto LABEL_110;
        }
        uint64_t v106 = v223;
        unint64_t v138 = v224;
        unint64_t v139 = HIBYTE(v224) & 0xF;
        if ((v224 & 0x2000000000000000LL) != 0) {
          unint64_t v140 = HIBYTE(v224) & 0xF;
        }
        else {
          unint64_t v140 = v223 & 0xFFFFFFFFFFFFLL;
        }
        if (v140 || (v223 & ~v224 & 0x2000000000000000LL) != 0)
        {
          if ((v224 & 0x2000000000000000LL) != 0 && v139 <= 0xD)
          {
            unint64_t v141 = 8 * (HIBYTE(v224) & 7);
            uint64_t v142 = (-255LL << v141) - 1;
            uint64_t v143 = 44LL << v141;
            char v144 = v139 + 1;
            if (v139 >= 8)
            {
              uint64_t v145 = v143 | v142 & v224;
LABEL_142:
              uint64_t v172 = (32LL << (8 * (v144 & 7u))) | ((-255LL << (8 * (v144 & 7u))) - 1) & v145;
            }

            else
            {
              uint64_t v106 = v143 | v142 & v223;
              if (v139 == 7)
              {
                char v144 = 8;
                uint64_t v145 = v224;
                goto LABEL_142;
              }

              uint64_t v106 = (32LL << (8 * (v144 & 7u))) | ((-255LL << (8 * (v144 & 7u))) - 1) & v106;
              uint64_t v172 = v224;
            }

            swift_bridgeObjectRelease(v224);
            swift_bridgeObjectRelease(0xE200000000000000LL);
            unint64_t v173 = 0xE000000000000000LL;
            if (v106 & 0x8080808080808080LL | v172 & 0x80808080808080LL) {
              unint64_t v173 = 0xA000000000000000LL;
            }
            unint64_t v223 = v106;
            unint64_t v224 = (v173 & 0xFF00000000000000LL | (v139 << 56) | v172 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
            goto LABEL_109;
          }

          swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v136, v137);
          if ((v138 & 0x1000000000000000LL) != 0)
          {
            Swift::Int v174 = String.UTF8View._foreignCount()();
            uint64_t v119 = v174 + 2;
            if (__OFADD__(v174, 2LL))
            {
LABEL_150:
              __break(1u);
              goto LABEL_151;
            }
          }

          else
          {
            BOOL v58 = __OFADD__(v140, 2LL);
            uint64_t v119 = v140 + 2;
            if (v58) {
              goto LABEL_150;
            }
          }

          if ((v106 & ~v138 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v138 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v146 = _StringGuts.nativeUnusedCapacity.getter(v106, v138);
            if ((v147 & 1) != 0) {
              goto LABEL_198;
            }
            BOOL v149 = (v138 & 0x2000000000000000LL) == 0 && v146 > 1;
            if (v119 <= 15 && !v149)
            {
LABEL_137:
              uint64_t v150 = v3;
              swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
              swift_bridgeObjectRetain(v138, v151, v152, v153);
              unint64_t v154 = _StringGuts._convertedToSmall()(v106, v138);
              unint64_t v156 = v155;
              swift_bridgeObjectRelease(v138);
              v157._Swift::UInt64 rawBits = 1LL;
              v158._Swift::UInt64 rawBits = 131073LL;
              v159._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v157, v158, 0x202CuLL, 0xE200000000000000LL);
              if (v159._rawBits < 0x10000) {
                v159._rawBits |= 3;
              }
              unint64_t v161 = specialized String.init(_:)(v159, v160, 0x202CuLL, 0xE200000000000000LL);
              unint64_t v163 = v162;
              swift_bridgeObjectRelease(0xE200000000000000LL);
              unint64_t v164 = _StringGuts._convertedToSmall()(v161, v163);
              unint64_t v166 = v165;
              swift_bridgeObjectRelease(v163);
              unint64_t v167 = specialized _SmallString.init(_:appending:)(v154, v156, v164, v166);
              if ((v169 & 1) != 0) {
                goto LABEL_197;
              }
              unint64_t v170 = v167;
              unint64_t v171 = v168;
              swift_bridgeObjectRelease(v138);
              swift_bridgeObjectRelease(0xE200000000000000LL);
              unint64_t v223 = v170;
              unint64_t v224 = v171;
              uint64_t v3 = v150;
              uint64_t v2 = v212;
              uint64_t v6 = v214;
              goto LABEL_109;
            }
          }

          else if (v119 <= 15)
          {
            goto LABEL_137;
          }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v119, 2LL);
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
          __int128 v222 = v213;
          uint64_t v130 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v222, 2LL);
          _StringGuts.appendInPlace(_:isASCII:)(v130, v131, 1);
          swift_bridgeObjectRelease(0xE200000000000000LL);
        }

        else
        {
          swift_bridgeObjectRelease(v224);
          unint64_t v223 = 8236LL;
          unint64_t v224 = 0xE200000000000000LL;
        }

    uint64_t v10 = (v21 - 1) & v21;
    unint64_t v20 = __clz(__rbit64(v21)) + (v13 << 6);
    if (v11) {
      goto LABEL_36;
    }
  }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
      }
    }

  uint64_t v289 = -1074LL;
  if ((v76((unint64_t *)v77, v67) & 1) == 0)
  {
    unint64_t v179 = v76((unint64_t *)v77, v67);
    unint64_t v165 = v254(v77, v67);
    unint64_t v65 = v252;
    if ((v179 & 1) == 0)
    {
      unint64_t v191 = *(void (**)(char *, char *, uint64_t))(v83 + 16);
      if (v165 >= 64)
      {
        uint64_t v199 = v257;
        unint64_t v164 = v285;
        v191(v257, v285, v77);
        ((void (*)(char *, uint64_t))v286)(v199, v77);
        goto LABEL_73;
      }

      unint64_t v164 = v285;
      v191(v82, v285, v77);
      goto LABEL_68;
    }

    if (v165 <= 64)
    {
      unint64_t v193 = v264;
      unint64_t v194 = v263;
      unint64_t v195 = swift_getAssociatedConformanceWitness( (uint64_t)v264,  v77,  v263,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v196 = v262;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v195 + 8))( &qword_18180BE68,  256LL,  v194,  v195);
      unint64_t v197 = v196;
      unint64_t v83 = v282;
      (*((void (**)(char *, uint64_t, const char *))v193 + 3))(v197, v77, v193);
      unint64_t v164 = v285;
      LOBYTE(v194) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v285,  v82,  v77);
      ((void (*)(char *, uint64_t))v286)(v82, v77);
      char v198 = v258;
      (*(void (**)(char *, char *, uint64_t))(v83 + 16))(v258, v164, v77);
      if ((v194 & 1) != 0)
      {
        ((void (*)(char *, uint64_t))v286)(v198, v77);
      }

      else
      {
        __int128 v222 = v289;
        unint64_t v223 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
        ((void (*)(char *, uint64_t))v286)(v198, v77);
        unint64_t v163 = v223 < v222;
        unint64_t v164 = v285;
        if (!v163) {
          goto LABEL_73;
        }
      }

  *a1 = a3 & 0x8000000000000000LL | v24 & 0xFFFFFFFFFFFFFLL | ((v11 << 52) + 0x3FF0000000000000LL);
  return (v22 | v21) == 0;
}

                  __break(1u);
LABEL_49:
                  __break(1u);
                  goto LABEL_50;
                }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  Swift::String::Index v28 = a4;
  Swift::String::Index v29 = a5 & 0xFFFFFFFFFFFFFFLL;
  if (v16 - v15 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return specialized static String._uncheckedFromUTF8(_:)((uint8x16_t *)((char *)&v28 + v15), v16 - v15);
}

    uint64_t v17 = "CollectionOfOne(";
    swift_bridgeObjectRelease_n(0x80000001818B7C00LL | 0x8000000000000000LL, 5LL);
    if ((v13 & 0x1000000000000000LL) == 0)
    {
      if ((v12 & 0x1000000000000000LL) != 0)
      {
        char v40 = (unsigned __int8 *)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        char v40 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v12, v13);
        unint64_t v15 = v37;
      }

      swift_bridgeObjectRetain(v13, v37, v38, v39);
      closure #1 in _StringGuts._convertedToSmall()(v40, v15, &v198);
      swift_bridgeObjectRelease(v13);
      unint64_t v41 = *((void *)&v198 + 1);
      unint64_t v12 = v198;
      goto LABEL_57;
    }

    goto LABEL_231;
  }

  unint64_t v26 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
  Swift::String::Index v29 = (v27 & 1) == 0 && v26 >= v20;
  if ((v23 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v3 = v197;
    uint64_t v17 = "CollectionOfOne(";
    if (v29) {
      goto LABEL_41;
    }
  }

  else
  {
    uint64_t v3 = v197;
    uint64_t v17 = "CollectionOfOne(";
    if (v29) {
      goto LABEL_40;
    }
  }

  Swift::String::Index v30 = _StringGuts.nativeCapacity.getter(v12, v13);
  if ((v31 & 1) != 0) {
    unint64_t v32 = 0LL;
  }
  else {
    unint64_t v32 = v30;
  }
  if (v32 + 0x4000000000000000LL >= 0)
  {
    unint64_t v33 = 2 * v32;
    if (v33 > v22) {
      uint64_t v22 = v33;
    }
LABEL_40:
    _StringGuts.grow(_:)(v22);
LABEL_41:
    unint64_t v34 = 0x80000001818B7C00LL | 0x8000000000000000LL;
    swift_bridgeObjectRelease_n(0x80000001818B7C00LL | 0x8000000000000000LL, 4LL);
    if ((0x80000001818B7C00LL & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(0x80000001818B7C00LL | 0x8000000000000000LL);
      _StringGuts._foreignAppendInPlace(_:)(0xD000000000000010LL, 0x80000001818B7C00LL | 0x8000000000000000LL, 0LL, v2);
    }

    else
    {
      if ((0x80000001818B7C00LL & 0x2000000000000000LL) != 0) {
        unint64_t v12 = (v34 >> 62) & 1;
      }
      else {
        unint64_t v12 = 1LL;
      }
      swift_bridgeObjectRelease(0x80000001818B7C00LL | 0x8000000000000000LL);
      if ((0x80000001818B7C00LL & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(0x80000001818B7C00LL | 0x8000000000000000LL);
        *(void *)&char v198 = 0xD000000000000010LL;
        *((void *)&v198 + 1) = 0x80000001818B7C00LL & 0xFFFFFFFFFFFFFFLL;
        unint64_t v138 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v2,  (uint64_t)&v198,  (0x80000001818B7C00LL >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v138, v139, v12);
        swift_bridgeObjectRelease(0x80000001818B7C00LL | 0x8000000000000000LL);
        goto LABEL_86;
      }

      unint64_t v34 = 0x80000001818B7C00LL | 0x8000000000000000LL;
      unint64_t v35 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v2,  (0x80000001818B7C00LL & 0xFFFFFFFFFFFFFFFLL) + 32,  16LL);
      _StringGuts.appendInPlace(_:isASCII:)(v35, v36, v12);
    }

    swift_bridgeObjectRelease_n(v34, 2LL);
    goto LABEL_86;
  }

  while (1)
  {
    __break(1u);
LABEL_231:
    unint64_t v12 = _StringGuts._foreignConvertedToSmall()(v12, v13);
    unint64_t v41 = v188;
LABEL_57:
    v44._Swift::UInt64 rawBits = (v2 << 16) | 1;
    v45._Swift::UInt64 rawBits = 1LL;
    v46._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v45,  v44,  0xD000000000000010LL,  (unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    if (v46._rawBits < 0x10000) {
      v46._rawBits |= 3;
    }
    uint64_t v48 = specialized String.init(_:)( v46,  v47,  0xD000000000000010LL,  (unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    uint64_t v2 = v49;
    swift_bridgeObjectRelease((unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v2);
    }

    else if ((v2 & 0x1000000000000000LL) != 0)
    {
      uint64_t v48 = _StringGuts._foreignConvertedToSmall()(v48, v2);
      unint64_t v194 = v193;
      swift_bridgeObjectRelease(v2);
      uint64_t v2 = v194;
    }

    else
    {
      if ((v48 & 0x1000000000000000LL) != 0)
      {
        unint64_t v185 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v186 = v48 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v185 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v48, v2);
      }

      closure #1 in _StringGuts._convertedToSmall()(v185, v186, &v198);
      swift_bridgeObjectRelease(v2);
      uint64_t v2 = *((void *)&v198 + 1);
      uint64_t v48 = v198;
    }

    uint64_t v50 = HIBYTE(v41) & 0xF;
    unint64_t v51 = HIBYTE(v2) & 0xF;
    unint64_t v52 = v51 + v50;
    if (v51)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 0LL;
      do
      {
        uint64_t v55 = v50 + v54;
        unint64_t v56 = v54 + 1;
        if (v54 >= 8) {
          Swift::Int v57 = v2;
        }
        else {
          Swift::Int v57 = v48;
        }
        BOOL v58 = v57 >> (v53 & 0x38);
        int64_t v59 = (8 * v50 + v53) & 0x38;
        unint64_t v60 = (-255LL << v59) - 1;
        int64_t v61 = (unint64_t)v58 << v59;
        char v62 = v61 | v60 & v41;
        uint64_t v63 = v61 | v60 & v12;
        if (v55 < 8) {
          unint64_t v12 = v63;
        }
        else {
          unint64_t v41 = v62;
        }
        v53 += 8;
        uint64_t v54 = v56;
      }

      while (v51 != v56);
    }

    swift_bridgeObjectRelease(v13);
    swift_bridgeObjectRelease((unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    size_t v64 = 0xA000000000000000LL;
    if (!(v12 & 0x8080808080808080LL | v41 & 0x80808080808080LL)) {
      size_t v64 = 0xE000000000000000LL;
    }
    uint64_t v199 = v12;
    size_t v200 = v64 & 0xFF00000000000000LL | (v52 << 56) | v41 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v3 = v197;
LABEL_86:
    (*(void (**)(uint64_t, unint64_t, unint64_t))(v5 + 16))(v7, v3, v4);
    *(void *)&char v198 = 0LL;
    *((void *)&v198 + 1) = 0xE000000000000000LL;
    _debugPrint_unlocked<A, B>(_:_:)( v7,  (uint64_t)&v198,  (swift *)v4,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
    (*(void (**)(uint64_t, unint64_t))(v5 + 8))(v7, v4);
    uint64_t v4 = *((void *)&v198 + 1);
    uint64_t v5 = v198;
    uint64_t v7 = v199;
    uint64_t v13 = v200;
    unint64_t v80 = HIBYTE(v200) & 0xF;
    unint64_t v16 = v199 & 0xFFFFFFFFFFFFLL;
    if ((v200 & 0x2000000000000000LL) != 0) {
      unint64_t v81 = HIBYTE(v200) & 0xF;
    }
    else {
      unint64_t v81 = v199 & 0xFFFFFFFFFFFFLL;
    }
    if (!v81 && (v199 & ~v200 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v200);
      uint64_t v199 = v5;
      size_t v200 = v4;
      goto LABEL_171;
    }

    unint64_t v15 = *((void *)&v198 + 1) & 0x2000000000000000LL;
    uint64_t v2 = HIBYTE(*((void *)&v198 + 1)) & 0xFLL;
    if ((v200 & 0x2000000000000000LL) != 0 && v15)
    {
      unint64_t v12 = v80 + v2;
      if (v80 + v2 <= 0xF)
      {
        if (v2)
        {
          unint64_t v126 = 0;
          uint64_t v127 = 0LL;
          uint64_t v128 = v200;
          do
          {
            char v129 = v80 + v127;
            uint64_t v130 = v127 + 1;
            if (v127 >= 8) {
              size_t v131 = *((void *)&v198 + 1);
            }
            else {
              size_t v131 = v198;
            }
            uint64_t v132 = v131 >> (v126 & 0x38);
            uint64_t v133 = (8 * v80 + v126) & 0x38;
            uint64_t v134 = (-255LL << v133) - 1;
            uint64_t v135 = (unint64_t)v132 << v133;
            uint64_t v136 = v135 | v134 & v128;
            uint64_t v137 = v135 | v134 & v7;
            if (v129 < 8) {
              uint64_t v7 = v137;
            }
            else {
              uint64_t v128 = v136;
            }
            v126 += 8;
            uint64_t v127 = v130;
          }

          while (v2 != v130);
        }

        else
        {
          uint64_t v128 = v200;
        }

        swift_bridgeObjectRelease(v200);
        swift_bridgeObjectRelease(v4);
        uint64_t v145 = 0xA000000000000000LL;
        if (!(v7 & 0x8080808080808080LL | v128 & 0x80808080808080LL)) {
          uint64_t v145 = 0xE000000000000000LL;
        }
        uint64_t v119 = v145 & 0xFF00000000000000LL | (v12 << 56) | v128 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_170;
      }

      unint64_t v15 = 1LL;
    }

    unint64_t v196 = v198 & 0xFFFFFFFFFFFFLL;
    unint64_t v12 = v15 ? HIBYTE(*((void *)&v198 + 1)) & 0xFLL : v198 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(*((uint64_t *)&v198 + 1), 2LL, v78, v79);
    if ((v4 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v4, 5LL, v82, v83);
      v172._Swift::UInt64 rawBits = 1LL;
      v173._Swift::UInt64 rawBits = (v12 << 16) | 1;
      v174._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v172, v173, v5, v4);
      if (v174._rawBits < 0x10000) {
        v174._rawBits |= 3;
      }
      uint64_t v17 = (const char *)specialized Collection.count.getter(v174, v175, v5, v4);
      swift_bridgeObjectRelease(v4);
      if ((v13 & 0x1000000000000000LL) == 0)
      {
LABEL_100:
        char v21 = __OFADD__(v81, v17);
        uint64_t v84 = (Swift::Int)&v17[v81];
        if (v21) {
          goto LABEL_207;
        }
        goto LABEL_101;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(v4, 4LL, v82, v83);
      uint64_t v17 = (const char *)v12;
      if ((v13 & 0x1000000000000000LL) == 0) {
        goto LABEL_100;
      }
    }

    int64_t v176 = String.UTF8View._foreignCount()();
    uint64_t v84 = (Swift::Int)&v17[v176];
    if (__OFADD__(v176, v17))
    {
LABEL_207:
      __break(1u);
LABEL_208:
      swift_bridgeObjectRetain_n((uint64_t)v17, 5LL, v18, v19);
      v177._Swift::UInt64 rawBits = 1LL;
      v178._Swift::UInt64 rawBits = (v2 << 16) | 1;
      v179._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v177, v178, 0xD000000000000010LL, (unint64_t)v17);
      if (v179._rawBits < 0x10000) {
        v179._rawBits |= 3;
      }
      unint64_t v20 = specialized Collection.count.getter(v179, v180, 0xD000000000000010LL, (unint64_t)v17);
      swift_bridgeObjectRelease((uint64_t)v17);
      if ((v13 & 0x1000000000000000LL) == 0) {
        goto LABEL_14;
      }
LABEL_211:
      uint64_t v181 = String.UTF8View._foreignCount()();
      uint64_t v22 = v181 + v20;
      if (__OFADD__(v181, v20)) {
        goto LABEL_213;
      }
      goto LABEL_15;
    }

    if (v15 != v17)
    {
      int64_t v18 = v32 + 1;
      do
      {
        uint64_t v19 = *v15++;
      }

      while (v15 != v17);
    }
  }

  *(_DWORD *)a3 = v12;
  *(void *)(a3 + 8) = v3;
  *(_DWORD *)(a3 + 16) = v11;
  return this;
}

    uint64_t v13 = 2716;
    uint64_t v14 = 1;
    uint64_t v4 = v12;
    goto LABEL_49;
  }

  if (*((_DWORD *)v4 + 2))
  {
    uint64_t v11 = *(swift::Demangle::__runtime::Node **)v4;
LABEL_9:
    unint64_t v12 = *(swift::Demangle::__runtime::Node **)v11;
    goto LABEL_13;
  }

  unint64_t v12 = 0LL;
  if (MEMORY[0x10] != 212) {
    goto LABEL_48;
  }
LABEL_15:
  if (*((_DWORD *)v4 + 2) == 3)
  {
    unint64_t v15 = *(swift::Demangle::__runtime::Node **)v4;
    uint64_t v4 = *(swift::Demangle::__runtime::Node **)(*(void *)v4 + 8LL);
    if (*((_WORD *)v4 + 8) != 43)
    {
      uint64_t v13 = 2722;
      uint64_t v14 = 1;
      goto LABEL_49;
    }

    unint64_t v16 = (swift::Demangle::__runtime::Node *)*((void *)v15 + 2);
    if (*((_WORD *)v16 + 8) != 235)
    {
      uint64_t v13 = 2725;
LABEL_58:
      uint64_t v14 = 1;
      uint64_t v4 = v16;
      goto LABEL_49;
    }

    uint64_t v17 = *(_DWORD *)(v7 + 12736);
    int64_t v18 = *(unsigned int *)(v7 + 12740);
    uint64_t v19 = *(char **)(v7 + 12728);
    if (v17 < v18)
    {
LABEL_73:
      *(_DWORD *)(v7 + 12736) = v17 + 1;
      v19[v17] = 71;
      if (*(_DWORD *)a4) {
        return this;
      }
      goto LABEL_22;
    }

    unint64_t v20 = *(void **)(v7 + 12744);
    char v21 = (char *)v20[1];
    if (&v19[v18] == v21)
    {
      unint64_t v36 = (unint64_t)&v19[v18 + 1];
      uint64_t v22 = v20[2];
      if (v36 <= v22)
      {
        v20[1] = v36;
        uint64_t v43 = 1;
LABEL_72:
        *(_DWORD *)(v7 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v18 + v43;
        goto LABEL_73;
      }
    }

    else
    {
      uint64_t v22 = v20[2];
    }

    LODWORD(v37) = 2 * v18;
    else {
      unint64_t v37 = v37;
    }
    unint64_t v52 = v37;
    unint64_t v38 = v37 + v18;
    if (!v21 || (unint64_t)&v21[v38] > v22)
    {
      unint64_t v39 = 2LL * v20[4];
      if (v39 <= v38 + 1) {
        unint64_t v39 = v38 + 1;
      }
      _OWORD v20[4] = v39;
      char v40 = v39 + 8;
      unint64_t v51 = v17;
      uint64_t v50 = v38;
      unint64_t v41 = malloc(v39 + 8);
      unint64_t v38 = v50;
      uint64_t v17 = v51;
      uint64_t v42 = (char *)v41 + v40;
      *unint64_t v41 = v20[3];
      char v21 = (char *)(v41 + 1);
      void v20[2] = v42;
      v20[3] = v41;
    }

    v20[1] = &v21[v38];
    if ((_DWORD)v18)
    {
      memcpy(v21, *(const void **)(v7 + 12728), v18);
      LODWORD(v18) = *(_DWORD *)(v7 + 12740);
      uint64_t v17 = *(_DWORD *)(v7 + 12736);
    }

    uint64_t v43 = v52;
    char *v9 = v21;
    uint64_t v19 = v21;
    goto LABEL_72;
  }

LABEL_109:
        uint64_t v128 = v215;
LABEL_110:
        uint64_t v132 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
        inited = swift_initStackObject(v132, v221);
        *((_OWORD *)inited + 1) = v216;
        inited[7] = v2;
        boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
        v105(boxed_opaque_existential_0Tm, v6, v2);
        specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  (uint64_t *)&v223);
        swift_bridgeObjectRelease((uint64_t)inited);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        char v129 = 0;
        v53 += v128;
        if (!--v127) {
          goto LABEL_152;
        }
      }
    }

    if ((v224 & 0x2000000000000000LL) != 0)
    {
      if ((v53 & 0x2000000000000000LL) == 0)
      {
LABEL_101:
        uint64_t v121 = v106 & 0xFFFFFFFFFFFFLL;
        goto LABEL_106;
      }

      unint64_t v122 = specialized _SmallString.init(_:appending:)(v223, v224, v106, v53);
      if ((v115 & 1) == 0)
      {
        unint64_t v123 = v122;
        unint64_t v124 = v114;
        swift_bridgeObjectRelease(v119);
        swift_bridgeObjectRelease(v53);
        unint64_t v223 = v123;
        unint64_t v224 = v124;
        uint64_t v127 = *((void *)v105 + 2);
        if (v127) {
          goto LABEL_107;
        }
        goto LABEL_152;
      }
    }

    else if ((v53 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_101;
    }

    uint64_t v121 = HIBYTE(v53) & 0xF;
LABEL_106:
    swift_bridgeObjectRetain(v53, v114, v115, v116);
    _StringGuts.append(_:)(v106, v53, 0LL, v121);
    swift_bridgeObjectRelease_n(v53, 2LL);
    uint64_t v127 = *((void *)v105 + 2);
    if (v127) {
      goto LABEL_107;
    }
LABEL_152:
    uint64_t v2 = v223;
    unint64_t v15 = v224;
    uint64_t v50 = HIBYTE(v224) & 0xF;
    if ((v224 & 0x2000000000000000LL) != 0) {
      unint64_t v175 = HIBYTE(v224) & 0xF;
    }
    else {
      unint64_t v175 = v223 & 0xFFFFFFFFFFFFLL;
    }
    if (!v175 && (v223 & ~v224 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v224);
      swift_bridgeObjectRelease((uint64_t)v211);
      return 10589LL;
    }

    unint64_t object = v211;
    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v125, v126);
    if ((v15 & 0x1000000000000000LL) != 0)
    {
LABEL_192:
      Swift::Int v208 = String.UTF8View._foreignCount()();
      int64_t v176 = v208 + 2;
      if (__OFADD__(v208, 2LL)) {
        goto LABEL_194;
      }
LABEL_164:
      if ((v2 & ~v15 & 0x2000000000000000LL) == 0
        || !swift_isUniquelyReferenced_nonNull_native(v15 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v176 <= 15) {
          goto LABEL_175;
        }
        goto LABEL_180;
      }

      int64_t v177 = _StringGuts.nativeUnusedCapacity.getter(v2, v15);
      if ((v178 & 1) == 0)
      {
        BOOL v180 = (v15 & 0x2000000000000000LL) == 0 && v177 > 1;
        if (v176 <= 15 && !v180)
        {
LABEL_175:
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
          swift_bridgeObjectRetain(v15, v181, v182, v183);
          unint64_t v184 = _StringGuts._convertedToSmall()(v2, v15);
          unint64_t v186 = v185;
          swift_bridgeObjectRelease(v15);
          v187._Swift::UInt64 rawBits = 1LL;
          v188._Swift::UInt64 rawBits = 131073LL;
          v189._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v187, v188, 0x295DuLL, 0xE200000000000000LL);
          if (v189._rawBits < 0x10000) {
            v189._rawBits |= 3;
          }
          unint64_t v191 = specialized String.init(_:)(v189, v190, 0x295DuLL, 0xE200000000000000LL);
          unint64_t v193 = v192;
          swift_bridgeObjectRelease(0xE200000000000000LL);
          unint64_t v194 = _StringGuts._convertedToSmall()(v191, v193);
          unint64_t v196 = v195;
          swift_bridgeObjectRelease(v193);
          unint64_t v197 = specialized _SmallString.init(_:appending:)(v184, v186, v194, v196);
          if ((v198 & 1) == 0)
          {
            uint64_t v2 = v197;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease((uint64_t)v211);
            swift_bridgeObjectRelease(0xE200000000000000LL);
            return v2;
          }

          goto LABEL_197;
        }

                  __break(1u);
LABEL_110:
                  __break(1u);
LABEL_111:
                  __break(1u);
LABEL_112:
                  __break(1u);
                  goto LABEL_113;
                }

                unint64_t v41 = v47;
              }
            }
          }

            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
          }

    swift_bridgeObjectRetain_n(a6, 3LL, v41, (char *)v42);
    v152._Swift::UInt64 rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 1;
    v153._Swift::UInt64 rawBits = v15 & 0xFFFFFFFFFFFF0000LL | 1;
    id v100 = v192;
    v154._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v152, v153, a4, a6);
    if (v154._rawBits < 0x10000) {
      v154._rawBits |= 3;
    }
    a3 = specialized Collection.count.getter(v154, v155, a4, a6);
    swift_bridgeObjectRelease_n(v43, 2LL);
    swift_bridgeObjectRelease(a6);
    if ((v43 & 0x1000000000000000LL) == 0) {
      goto LABEL_71;
    }
    goto LABEL_112;
  }

  if ((a6 & 0x1000000000000000LL) != 0) {
    goto LABEL_114;
  }
  unint64_t v20 = (unint64_t)a3 >> 16;
  char v21 = (unint64_t)a4 >> 16;
  if ((a6 & 0x2000000000000000LL) == 0)
  {
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      uint64_t v22 = (id)((a6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v23 = a5 & 0xFFFFFFFFFFFFLL;
      if ((a5 & 0xFFFFFFFFFFFFLL) < v21) {
        goto LABEL_133;
      }
    }

    else
    {
      uint64_t v22 = _StringObject.sharedUTF8.getter(a5, a6);
      uint64_t v23 = v169;
      if (v169 < v21) {
        goto LABEL_133;
      }
    }

    uint64_t v24 = specialized UnsafeBufferPointer.init(rebasing:)(v20, v21, (uint64_t)v22, v23);
    unint64_t v26 = a1 >> 16;
    unint64_t v27 = (a1 >> 16) + v25;
    if (!__OFADD__(a1 >> 16, v25))
    {
      a1 = a2 >> 16;
      Swift::String::Index v28 = v14 & 0xFFFFFFFFFFFFLL;
      if ((v15 & 0x2000000000000000LL) != 0) {
        Swift::String::Index v28 = HIBYTE(v15) & 0xF;
      }
      Swift::String::Index v29 = v28 - a1;
      Swift::String::Index v30 = v27 + v29;
      if (!__OFADD__(v27, v29))
      {
        Swift::String::Index v31 = (char *)v24;
        unint64_t v32 = v25;
        if (v30 < 16) {
          goto LABEL_59;
        }
LABEL_56:
        unint64_t v90 = _StringGuts.uniqueNativeCapacity.getter();
        if ((v91 & 1) != 0 || v90 < v30) {
          _StringGuts.grow(_:)(v30);
        }
        goto LABEL_59;
      }

      goto LABEL_128;
    }

    __break(1u);
LABEL_127:
    __break(1u);
LABEL_128:
    __break(1u);
LABEL_129:
    __break(1u);
    goto LABEL_130;
  }

  unint64_t v83 = HIBYTE(a6) & 0xF;
  size_t v200 = a5;
  uint64_t v201 = a6 & 0xFFFFFFFFFFFFFFLL;
  if (v83 < v21) {
    goto LABEL_133;
  }
  uint64_t v84 = specialized UnsafeBufferPointer.init(rebasing:)(v20, (unint64_t)a4 >> 16, (uint64_t)&v200, v83);
  unint64_t v26 = a1 >> 16;
  unint64_t v86 = (a1 >> 16) + v85;
  if (__OFADD__(a1 >> 16, v85)) {
    goto LABEL_127;
  }
  a1 = a2 >> 16;
  uint64_t v87 = *(void *)(v7 + 8);
  if ((v87 & 0x2000000000000000LL) != 0) {
    char v88 = HIBYTE(v87) & 0xF;
  }
  else {
    char v88 = *(void *)v7 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v89 = v88 - a1;
  Swift::String::Index v30 = v86 + v89;
  if (__OFADD__(v86, v89)) {
    goto LABEL_129;
  }
  Swift::String::Index v31 = (char *)v84;
  unint64_t v32 = v85;
  if (v30 >= 16) {
    goto LABEL_56;
  }
LABEL_59:
  unint64_t v92 = *(void *)(v7 + 8);
  __StringStorage.replace(from:to:with:)(v26, a1, v31, v32);
  unint64_t v93 = *(void *)(v92 + 24);
LABEL_60:
  *(void *)uint64_t v7 = v93;
  return v26;
}

            BOOL v180 = __src;
            uint64_t v181 = v270;
            swift_bridgeObjectRelease(v141[1]);
            *unint64_t v141 = v180;
            v141[1] = v181;
            return v50;
          }

          goto LABEL_91;
        }

            int64_t v59 = 0LL;
            goto LABEL_110;
          case 5:
            std::string::append(this, v9, 1uLL);
            Swift::String::Index v29 = *((unsigned __int8 *)a2 + 18);
            Swift::String::Index v30 = v29 - 1;
            switch((_DWORD)v29)
            {
              case 1:
                goto LABEL_56;
              case 5:
                break;
              case 2:
                Swift::String::Index v29 = 2LL;
LABEL_56:
                if (v29 <= v7)
                {
LABEL_115:
                  unint64_t v32 = 0LL;
                  goto LABEL_116;
                }

                break;
              default:
                goto LABEL_115;
            }

            Swift::String::Index v31 = a2;
            if (v30 >= 2) {
              Swift::String::Index v31 = *(swift::Demangle::__runtime::Node **)a2;
            }
            unint64_t v32 = (swift::Demangle::__runtime::Node *)*((void *)v31 + v7);
LABEL_116:
            std::string::append(this, v10, 3uLL);
            char v62 = *((unsigned __int8 *)a2 + 18);
            if (v62 == 2)
            {
              uint64_t v63 = *((unsigned __int8 *)a2 + 18);
            }

            else
            {
              if (v62 != 5) {
                goto LABEL_124;
              }
              uint64_t v63 = *((unsigned int *)a2 + 2);
            }

            size_t v64 = (v7 + 1);
            if (v63 > v64)
            {
              unint64_t v65 = v62 - 1;
              uint64_t v66 = a2;
              if (v65 >= 2) {
                uint64_t v66 = *(swift::Demangle::__runtime::Node **)a2;
              }
              uint64_t v67 = (swift::Demangle::__runtime::Node *)*((void *)v66 + v64);
              goto LABEL_125;
            }

LABEL_198:
      unint64_t v210 = 258LL;
LABEL_199:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v210,  0);
    }

    BOOL v58 = __OFADD__(v175, 2LL);
    int64_t v176 = v175 + 2;
    if (!v58) {
      goto LABEL_164;
    }
LABEL_194:
    __break(1u);
LABEL_195:
    id v100 = _StringObject.sharedUTF8.getter(v50, (uint64_t)object);
    uint64_t v101 = v209;
    swift_bridgeObjectRelease((uint64_t)object);
    if (v101 < v53) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }
    unint64_t object = v211;
    uint64_t v6 = v214;
    uint64_t v3 = v215;
    uint64_t v50 = v216;
LABEL_70:
    uint64_t v102 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v53, (uint64_t)v100, v101);
    _StringGuts.appendInPlace(_:isASCII:)(v102, v103, v50 < 0);
    swift_bridgeObjectRelease((uint64_t)object);
  }

  if ((unint64_t)v50 < 8)
  {
    uint64_t v2 = (93LL << (8 * (HIBYTE(v224) & 7u))) | ((-255LL << (8 * (HIBYTE(v224) & 7u))) - 1) & v223;
    if (v50 != 7) {
      uint64_t v2 = (41LL << (8 * ((v50 + 1) & 7))) | ((-255LL << (8 * ((v50 + 1) & 7))) - 1) & v2;
    }
  }

  swift_bridgeObjectRelease(v224);
  swift_bridgeObjectRelease((uint64_t)object);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  return v2;
}

  Swift::String::Index v159 = String.UTF8View._foreignCount()();
  uint64_t countAndFlagsBits = v159 + 1;
  if (__OFADD__(v159, 1LL)) {
    goto LABEL_200;
  }
LABEL_170:
  if ((v7 & ~object & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if (countAndFlagsBits <= 15) {
      goto LABEL_181;
    }
    goto LABEL_186;
  }

  uint64_t v130 = _StringGuts.nativeUnusedCapacity.getter(v7, object);
  if ((v131 & 1) != 0) {
    goto LABEL_222;
  }
  uint64_t v133 = (object & 0x2000000000000000LL) == 0 && v130 > 0;
  if (countAndFlagsBits <= 15 && !v133)
  {
LABEL_181:
    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    swift_bridgeObjectRetain(object, v134, v135, v136);
    uint64_t v137 = _StringGuts._convertedToSmall()(v7, object);
    unint64_t v139 = v138;
    swift_bridgeObjectRelease(object);
    v140._Swift::UInt64 rawBits = 1LL;
    v141._Swift::UInt64 rawBits = 65537LL;
    v142._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v140, v141, 0x22uLL, 0xE100000000000000LL);
    if (v142._rawBits < 0x10000) {
      v142._rawBits |= 3;
    }
    char v144 = specialized String.init(_:)(v142, v143, 0x22uLL, 0xE100000000000000LL);
    int64_t v146 = v145;
    swift_bridgeObjectRelease(0xE100000000000000LL);
    char v147 = _StringGuts._convertedToSmall()(v144, v146);
    BOOL v149 = v148;
    swift_bridgeObjectRelease(v146);
    specialized _SmallString.init(_:appending:)(v137, v139, v147, v149);
    if ((v150 & 1) == 0)
    {
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return;
    }

                    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v120, 1LL);
                    swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
                    uint64_t v212 = xmmword_1817FFDC0;
                    Swift::String::Index v187 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v212, 1LL);
                    _StringGuts.appendInPlace(_:isASCII:)(v187, v188, 1);
                    swift_bridgeObjectRelease(0xE100000000000000LL);
                    unint64_t v156 = *((void *)&v213[0] + 1);
                    uint64_t v111 = *(void *)&v213[0];
LABEL_199:
                    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)v111,  v156,  "Swift/ReflectionMirror.swift",  28LL,  2,  0xB0uLL,  0);
                  }

      uint64_t v228 = v379;
      ((void (*)(uint64_t, char *))v383)(v59, v384);
      if (v381(v228, 1LL, (ValueMetadata *)v62) == 1) {
        goto LABEL_193;
      }
    }

    unint64_t v79 = v374;
    if ((v377 & 0x2000000000000000LL) == 0) {
      goto LABEL_210;
    }
    uint64_t v233 = v230 + v371;
    if (v230 + v371 <= 0xF)
    {
      if (v371)
      {
        unint64_t v309 = 0LL;
        char v310 = 0LL;
        uint64_t v311 = v391;
        unint64_t v263 = (void (*)(unint64_t, uint64_t))v373;
        do
        {
          uint64_t v312 = v230 + v310;
          unint64_t v141 = v310++ >= 8;
          if (v141) {
            uint64_t v313 = v377;
          }
          else {
            uint64_t v313 = v376;
          }
          uint64_t v314 = (8 * v230 + v309) & 0x38;
          uint64_t v315 = (-255LL << v314) - 1;
          uint64_t v316 = (unint64_t)(v313 >> (v309 & 0x38)) << v314;
          uint64_t v317 = v316 | v315 & v311;
          unint64_t v318 = v316 | v315 & v96;
          if (v312 < 8) {
            uint64_t v96 = v318;
          }
          else {
            uint64_t v311 = v317;
          }
          v309 += 8LL;
        }

        while (v367 != v309);
      }

      else
      {
        uint64_t v311 = v391;
        unint64_t v263 = (void (*)(unint64_t, uint64_t))v373;
      }

      swift_bridgeObjectRelease(v391);
      __int128 v335 = 0xA000000000000000LL;
      if (!(v96 & 0x8080808080808080LL | v311 & 0x80808080808080LL)) {
        __int128 v335 = 0xE000000000000000LL;
      }
      v390 = v96;
      v391 = v335 & 0xFF00000000000000LL | (v233 << 56) | v311 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_234;
    }

          v22.partialValue.low = 0LL;
          goto LABEL_193;
        }

        Swift::String v8 = 1;
        unint64_t v46 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
        uint64_t v50 = specialized UnsafeBufferPointer.init(rebasing:)(v46, v47, v48, v49);
        if (v51)
        {
          unint64_t v52 = (unsigned __int8 *)v50;
          uint64_t v53 = low + 87;
          if (low <= 10) {
            uint64_t v53 = 97;
          }
          unint64_t v104 = v53;
          if (low <= 10) {
            uint64_t v54 = 65;
          }
          else {
            uint64_t v54 = low + 55;
          }
          if (low <= 10) {
            uint64_t v55 = low + 48;
          }
          else {
            uint64_t v55 = 58;
          }
          if (v50)
          {
            unint64_t v56 = v51;
            while (1)
            {
              char v88 = *v52;
              if (v88 < 0x30 || v88 >= v55)
              {
                if (v88 < 0x41 || v88 >= v54)
                {
                  v22.partialValue.low = 0LL;
                  Swift::String v8 = 1;
                  unint64_t v89 = -87;
                }

                else
                {
                  unint64_t v89 = -55;
                }
              }

              else
              {
                unint64_t v89 = -48;
              }

              unint64_t v90 = v88 + v89;
              v91.low = low;
              v91.high = low >> 63;
              uint64_t v22 = _Int128.multipliedReportingOverflow(by:)(v91);
              unint64_t v92 = *(_DWORD *)&v22.overflow;
              *(void *)&v22.overflow = v22.partialValue.low + v90;
              unint64_t v93 = __CFADD__(v22.partialValue.low, v90);
              if (v22.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
              {
                if (((v93 | v92) & 1) != 0) {
                  goto LABEL_191;
                }
              }

              else if (v93)
              {
                if ((v92 & 1) != 0) {
                  goto LABEL_191;
                }
              }

              else if ((v92 & 1) != 0)
              {
                goto LABEL_191;
              }

              ++v52;
              if (!--v56) {
                goto LABEL_192;
              }
            }
          }

          goto LABEL_120;
        }

              v161 |= v160 << 8;
              goto LABEL_199;
            }

    swift_bridgeObjectRelease(v274);
    unint64_t v273 = v113;
    uint64_t v274 = v114;
    goto LABEL_89;
  }

  uint64_t v119 = v260;
  memcpy(v260, v46, v3);
  if ((swift_dynamicCast((char *)&v267, v119, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    unint64_t object = v267._object;
    String.append(_:)(v267);
    swift_bridgeObjectRelease((uint64_t)object);
  }

  else
  {
    memcpy(v40, v46, v3);
    char v144 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v270, (uint64_t *)v40, v2, v144, 6uLL))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      uint64_t v145 = (uint64_t)v268;
      int64_t v146 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v146 + 8))( &v273,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v145,  v146);
      goto LABEL_89;
    }

    char v272 = 0LL;
    uint64_t v270 = 0u;
    unint64_t v271 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v215 = v253;
    memcpy(v253, v46, v3);
    __int128 v216 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v270, v215, v2, v216, 6uLL)
      || (char v272 = 0LL,
          uint64_t v270 = 0u,
          unint64_t v271 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomStringConvertible?),  v217 = v249,  memcpy(v249, v46, v3),  uint64_t v218 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v270, v217, v2, v218, 6uLL)))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      uint64_t v219 = (uint64_t)v268;
      uint64_t v220 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      uint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t))(v220 + 8))(v219, v220);
      uint64_t v114 = v112;
      uint64_t v221 = HIBYTE(v274) & 0xF;
      if ((v274 & 0x2000000000000000LL) == 0) {
        uint64_t v221 = v273 & 0xFFFFFFFFFFFFLL;
      }
      if (v221 || (v273 & ~v274 & 0x2000000000000000LL) != 0) {
        goto LABEL_88;
      }
      goto LABEL_198;
    }

    char v272 = 0LL;
    uint64_t v270 = 0u;
    unint64_t v271 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v271 + 1) = v2;
    uint64_t v234 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
    memcpy(v234, v46, v3);
    Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
    uint64_t v235 = v267._object;
    unint64_t v236 = v269;
    ((void (*)(char *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v46,  &v267,  &v273,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v236);
    swift_release((uint64_t)v235);
  }

    unint64_t v38 = v41;
LABEL_199:
    v175._Swift::UInt64 rawBits = 65537LL;
    v176._Swift::UInt64 rawBits = 1LL;
    v177._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v176, v175, 0x5DuLL, 0xE100000000000000LL);
    if (v177._rawBits < 0x10000) {
      v177._rawBits |= 3;
    }
    unint64_t v52 = specialized String.init(_:)(v177, v178, 0x5DuLL, 0xE100000000000000LL);
    unint64_t v164 = v179;
    swift_bridgeObjectRelease(0xE100000000000000LL);
    if ((v164 & 0x2000000000000000LL) == 0) {
      goto LABEL_233;
    }
    swift_bridgeObjectRelease(v164);
LABEL_203:
    BOOL v180 = HIBYTE(v38) & 0xF;
    uint64_t v181 = HIBYTE(v164) & 0xF;
    if ((unint64_t)(v181 + v180) <= 0xF)
    {
      if (v181)
      {
        uint64_t v182 = 0;
        uint64_t v183 = 0LL;
        do
        {
          unint64_t v184 = v180 + v183;
          unint64_t v185 = v183 + 1;
          if (v183 >= 8) {
            unint64_t v186 = v164;
          }
          else {
            unint64_t v186 = v52;
          }
          Swift::String::Index v187 = v186 >> (v182 & 0x38);
          Swift::String::Index v188 = (8 * v180 + v182) & 0x38;
          Swift::String::Index v189 = (-255LL << v188) - 1;
          Swift::String::Index v190 = (unint64_t)v187 << v188;
          unint64_t v191 = v190 | v189 & v38;
          unint64_t v192 = v190 | v189 & v28;
          if (v184 < 8) {
            Swift::String::Index v28 = v192;
          }
          else {
            unint64_t v38 = v191;
          }
          v182 += 8;
          uint64_t v183 = v185;
        }

        while (v181 != v185);
      }

      swift_bridgeObjectRelease(v41);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return v28;
    }

    BOOL v44 = 0LL;
    unint64_t v45 = *a1;
    if ((_DWORD)v45) {
      goto LABEL_199;
    }
    goto LABEL_197;
  }

  BOOL v44 = *(void *)((char *)v22 + *v22);
  unint64_t v45 = *a1;
  if ((_DWORD)v45) {
    goto LABEL_199;
  }
LABEL_197:
  uint64_t v121 = 0LL;
  return _getForeignWitnessTable(v7, v44, (uint64_t)v121);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance ContiguousArray<A>( uint64_t a1)
{
  return ContiguousArray.description.getter(*v1, *(void *)(a1 + 16));
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance ContiguousArray<A>( uint64_t a1)
{
  return ContiguousArray.debugDescription.getter(*v1, *(void *)(a1 + 16));
}

unint64_t *ContiguousArray._cPointerArgs()(unint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain(a1, a2, a3, a4);
}

uint64_t _ContiguousArrayBuffer.withUnsafeBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(a4 - 8) + 80LL);
  return a1(a3 + ((v4 + 32) & ~v4), *(void *)(a3 + 16));
}

void *$defer #1 <A><A1>() in ContiguousArray.withUnsafeMutableBufferPointer<A>(_:)( void *result, uint64_t a2, uint64_t a3)
{
  if (*result) {
    BOOL v3 = *result == a2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3 || result[1] != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed",  83LL,  2,  "Swift/ContiguousArray.swift",  27LL,  2,  0x4AEuLL,  0);
  }
  return result;
}

uint64_t _ContiguousArrayBuffer.startIndex.getter()
{
  return 0LL;
}

uint64_t static ContiguousArray<A>.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v19 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v7 + 16);
  if (v11 != *(void *)(v8 + 16)) {
    return 0LL;
  }
  if (!v11 || v7 == v8) {
    return 1LL;
  }
  uint64_t v12 = 0LL;
  unint64_t v13 = (*(unsigned __int8 *)(v6 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80);
  unint64_t v14 = v7 + v13;
  uint64_t v15 = v8 + v13;
  do
  {
    BOOL v16 = v11 == v12;
    if (v11 == v12) {
      break;
    }
    uint64_t v17 = *(void *)(v6 + 72) * v12;
    (*(void (**)(char *, unint64_t, uint64_t))(v6 + 16))(v10, v14 + v17, a3);
    ++v12;
    LOBYTE(v17) = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(a4 + 8))(v10, v15 + v17, a3, a4);
    (*(void (**)(char *, uint64_t))(v6 + 8))(v10, a3);
  }

  while ((v17 & 1) != 0);
  return v16;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> ContiguousArray<A>( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return static ContiguousArray<A>.== infix(_:_:)(*a1, *a2, *(void *)(a3 + 16), *(void *)(a4 - 8));
}

void ContiguousArray<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v16 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::UInt v12 = *(void *)(v11 + 16);
  Hasher._combine(_:)(v12);
  if (v12)
  {
    uint64_t v13 = a2 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80));
    uint64_t v14 = *(void *)(v8 + 72);
    uint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
    do
    {
      v15(v10, v13, a3);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 24))(a1, a3, a4);
      (*(void (**)(char *, uint64_t))(v8 + 8))(v10, a3);
      v13 += v14;
      --v12;
    }

    while (v12);
  }

Swift::Int ContiguousArray<A>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Array<A>.hashValue.getter( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t, uint64_t))ContiguousArray<A>.hash(into:));
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> ContiguousArray<A>( uint64_t a1, uint64_t a2)
{
  return ContiguousArray<A>.hashValue.getter(*v2, *(void *)(a1 + 16), *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <A> [A]( a1,  a2,  a3,  (void (*)(void *, void, void, uint64_t))ContiguousArray<A>.hash(into:));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> [A]( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *, void, void, uint64_t))
{
  uint64_t v6 = *(void *)(a3 - 8);
  v8[0] = 0LL;
  v8[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v8[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v8[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v8[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  a4(v8, *v4, *(void *)(a2 + 16), v6);
  return Hasher._finalize()();
}

void *ContiguousArray.withUnsafeMutableBytes<A>(_:)( void (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13[3] = a4;
  ContiguousArray._makeMutableAndUnique()();
  uint64_t v7 = *(void *)(*(void *)v4 + 16LL);
  uint64_t v8 = *(void *)(*(void *)(a3 + 16) - 8LL);
  uint64_t v9 = *(void *)v4 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80));
  v13[0] = v9;
  v13[1] = v7;
  uint64_t v10 = *(void *)(v8 + 72);
  uint64_t v11 = v7 * v10;
  if ((unsigned __int128)(v7 * (__int128)v10) >> 64 != (v7 * v10) >> 63)
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if (v11 < 0) {
    goto LABEL_5;
  }
  a1(v9, v9 + v11);
  return $defer #1 <A><A1>() in ContiguousArray.withUnsafeMutableBufferPointer<A>(_:)(v13, v9, v7);
}

uint64_t ContiguousArray.withUnsafeBytes<A>(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 - 8);
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v4 + 72);
  uint64_t v7 = v5 * v6;
  if ((unsigned __int128)(v5 * (__int128)v6) >> 64 != (v5 * v6) >> 63)
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v7 < 0) {
    goto LABEL_5;
  }
  uint64_t v9 = a3 + ((*(unsigned __int8 *)(v4 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1(v9, v9 + v7);
}

uint64_t _HasContiguousBytes._providesContiguousBytesNoCopy.getter()
{
  return 1LL;
}

uint64_t Array._providesContiguousBytesNoCopy.getter(uint64_t a1, uint64_t *a2)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  BOOL v5 = (a1 & 0x4000000000000000LL) == 0 && a1 >= 0;
  return !isClassOrObjCExistentialType || v5;
}

uint64_t protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance [A]( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Array.withUnsafeBytes<A>(_:)(a1, a2, *v4, *(uint64_t **)(a4 + 16));
}

uint64_t protocol witness for _HasContiguousBytes._providesContiguousBytesNoCopy.getter in conformance [A]( uint64_t a1)
{
  uint64_t v2 = *v1;
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType(*(void *)(a1 + 16), *(uint64_t **)(a1 + 16));
  BOOL v5 = (v2 & 0x4000000000000000LL) == 0 && v2 >= 0;
  return !isClassOrObjCExistentialType || v5;
}

uint64_t protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance ContiguousArray<A>( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ContiguousArray.withUnsafeBytes<A>(_:)(a1, a2, *v4, *(void *)(a4 + 16));
}

uint64_t UnsafeBufferPointer.withUnsafeBytes<A>(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnsafeBufferPointer.withUnsafeBytes<A>(_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v5;
  uint64_t v6;
  BOOL v5 = *(void *)(*(void *)(a5 - 8) + 72LL) * a4;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  if (v5)
  {
    if (!a3) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  else if (!a3)
  {
    uint64_t v6 = 0LL;
    return a1(a3, v6);
  }

  uint64_t v6 = a3 + v5;
  return a1(a3, v6);
}

uint64_t _Pointer.init(_:)@<X0>(const void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 - 8);
  size_t v9 = *(void *)(v8 + 64);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v8 + 48))(v10, 1LL, a2) == 1)
  {
    uint64_t v13 = type metadata accessor for Optional(0LL, a2, v11, v12);
    (*(void (**)(const void *, uint64_t))(*(void *)(v13 - 8) + 8LL))(a1, v13);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56))(a4, 1LL, 1LL, a2);
  }

  else
  {
    memcpy((char *)&v16 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, v9);
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 48))(a2, a3);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))(v15, a2, a3);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v8 + 56))(a4, 0LL, 1LL, a2);
  }

uint64_t static MemoryLayout.stride.getter(uint64_t a1)
{
  return *(void *)(*(void *)(a1 - 8) + 72LL);
}

uint64_t protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance UnsafeBufferPointer<A>( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance UnsafeBufferPointer<A>( a1,  a2,  a3,  a4);
}

{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  BOOL v5 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8LL) + 72LL) * v4[1];
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  uint64_t v7 = *v4;
  if (v5)
  {
    if (!v7) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  else if (!v7)
  {
    uint64_t v8 = 0LL;
    return a1(v7, v8);
  }

  uint64_t v8 = v7 + v5;
  return a1(v7, v8);
}

uint64_t UnsafeMutableBufferPointer.withUnsafeBytes<A>(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnsafeBufferPointer.withUnsafeBytes<A>(_:)(a1, a2, a3, a4, a5);
}

uint64_t UnsafeRawBufferPointer.withUnsafeBytes<A>(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1(a3, a4);
}

uint64_t protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance UnsafeRawBufferPointer( uint64_t (*a1)(void, void))
{
  return a1(*v1, v1[1]);
}

uint64_t UnsafeMutableRawBufferPointer.withUnsafeBytes<A>(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3) {
    uint64_t v4 = a4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  return a1(a3, v4);
}

uint64_t protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance UnsafeMutableRawBufferPointer( uint64_t (*a1)(void))
{
  return a1();
}

BOOL String._providesContiguousBytesNoCopy.getter(uint64_t a1, uint64_t a2)
{
  return (a2 & 0x1000000000000000LL) == 0;
}

BOOL _StringGuts.isFastUTF8.getter(uint64_t a1, uint64_t a2)
{
  return (a2 & 0x1000000000000000LL) == 0;
}

void String.withUnsafeBytes<A>(_:)( void (*a1)(void *, char *), uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4 = (unint64_t)a4;
  uint64_t v5 = a3;
  swift_bridgeObjectRetain((unint64_t)a4, a2, a3, a4);
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    uint64_t v5 = specialized static String._copying(_:)(v5, v4);
    unint64_t v12 = v11;
    swift_bridgeObjectRelease(v4);
    unint64_t v4 = v12;
    if ((v12 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    v13[0] = v5;
    v13[1] = v4 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v10 = (char *)v13 + (HIBYTE(v4) & 0xF);
    size_t v9 = v13;
    goto LABEL_8;
  }

  if ((v4 & 0x2000000000000000LL) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((v5 & 0x1000000000000000LL) != 0)
  {
    id v7 = (id)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    id v7 = _StringObject.sharedUTF8.getter(v5, v4);
  }

  size_t v9 = (void *)specialized UnsafeRawBufferPointer.init<A>(_:)((uint64_t)v7, v8);
LABEL_8:
  a1(v9, v10);
  swift_bridgeObjectRelease(v4);
}

void protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance String( void (*a1)(uint64_t), uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v7 = *v4;
  unint64_t v6 = v4[1];
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  if ((v6 & 0x1000000000000000LL) == 0)
  {
    if ((v6 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v13[0] = v7;
    v13[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v13;
    goto LABEL_7;
  }

  uint64_t v7 = specialized static String._copying(_:)(v7, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v7 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = v7 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(v7, v6);
  }

BOOL protocol witness for _HasContiguousBytes._providesContiguousBytesNoCopy.getter in conformance String()
{
  return (*(_BYTE *)(v0 + 15) & 0x10) == 0;
}

BOOL Substring._providesContiguousBytesNoCopy.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (a4 & 0x1000000000000000LL) == 0;
}

uint64_t Substring._wholeGuts.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a3;
}

void Substring.withUnsafeBytes<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  unint64_t v10 = a6;
  v9[6] = a3;
  v9[7] = a4;
  v9[8] = a5;
  void v9[2] = a7;
  uint64_t v9[3] = a1;
  v9[4] = a2;
  swift_bridgeObjectRetain(a6, a2, a3, a4);
  Substring.withUTF8<A>(_:)( (void (*)(char *, int64_t))partial apply for closure #1 in Substring.withUnsafeBytes<A>(_:),  (uint64_t)v9,  a7,  v8);
  swift_bridgeObjectRelease(v10);
}

uint64_t closure #1 in Substring.withUnsafeBytes<A>(_:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  if (a2)
  {
    if (!a1) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  else if (!a1)
  {
    uint64_t v3 = 0LL;
    return a3(a1, v3);
  }

  uint64_t v3 = a1 + a2;
  return a3(a1, v3);
}

void Substring.withUTF8<A>(_:)( void (*a1)(char *, int64_t), uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v6 = v4[3];
  if ((v6 & 0x1000000000000000LL) != 0)
  {
    Substring._slowMakeContiguousUTF8()();
    unint64_t v6 = v4[3];
  }

  unint64_t v8 = v4[1];
  uint64_t v7 = v4[2];
  uint64_t v9 = *v4 >> 16;
  int64_t v10 = v8 >> 16;
  if ((v6 & 0x2000000000000000LL) == 0)
  {
    if ((v7 & 0x1000000000000000LL) != 0)
    {
      id v11 = (id)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v12 = v7 & 0xFFFFFFFFFFFFLL;
      if ((v7 & 0xFFFFFFFFFFFFLL) >= v10)
      {
LABEL_6:
        swift_bridgeObjectRetain(v6, a2, a3, a4);
        uint64_t v13 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, (uint64_t)v11, v12);
        goto LABEL_10;
      }
    }

    else
    {
      id v11 = _StringObject.sharedUTF8.getter(v7, v6);
      uint64_t v12 = a2;
      if (a2 >= v10) {
        goto LABEL_6;
      }
    }

void protocol witness for _HasContiguousBytes.withUnsafeBytes<A>(_:) in conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v7 = *((void *)v4 + 2);
  unint64_t v6 = *((void *)v4 + 3);
  __int128 v10 = *v4;
  uint64_t v11 = v7;
  unint64_t v12 = v6;
  void v9[2] = a3;
  uint64_t v9[3] = a1;
  v9[4] = a2;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  Substring.withUTF8<A>(_:)( (void (*)(char *, int64_t))closure #1 in Substring.withUnsafeBytes<A>(_:)partial apply,  (uint64_t)v9,  a3,  v8);
  swift_bridgeObjectRelease(v12);
}

BOOL protocol witness for _HasContiguousBytes._providesContiguousBytesNoCopy.getter in conformance Substring()
{
  return (*(_BYTE *)(v0 + 31) & 0x10) == 0;
}

uint64_t ClosedRange.init(uncheckedBounds:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v48 = a1;
  uint64_t v49 = (char *)a4;
  uint64_t v47 = a5;
  uint64_t v7 = type metadata accessor for ClosedRange(0LL, a3, a4, a4);
  uint64_t v45 = *(void *)(v7 - 8);
  uint64_t v46 = v7;
  MEMORY[0x1895F8858](v7);
  BOOL v44 = (char *)&v41 - v8;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, a3, "lower upper ", 0LL);
  uint64_t v42 = *(TupleTypeMetadata2 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v12 = (char *)&v41 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v43 = (char *)&v41 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v50 = (char *)&v41 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v41 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v41 - v21;
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  unint64_t v25 = (char *)&v41 - v24;
  unint64_t v26 = (char *)&v41 + *(int *)(v23 + 48) - v24;
  uint64_t v27 = *(void *)(a3 - 8);
  Swift::String::Index v28 = *(void (**)(void))(v27 + 32);
  ((void (*)(char *, uint64_t, uint64_t))v28)((char *)&v41 - v24, v48, a3);
  ((void (*)(char *, uint64_t, uint64_t))v28)(v26, a2, a3);
  Swift::String::Index v29 = &v22[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v48 = v27;
  Swift::String::Index v30 = *(void (**)(char *, char *, uint64_t))(v27 + 16);
  v30(v22, v25, a3);
  v30(v29, v26, a3);
  if (((*((uint64_t (**)(char *, char *, uint64_t))v49 + 3))(v22, v29, a3) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ClosedRange requires lowerBound <= upperBound",  45LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x59uLL,  0);
  }
  (*(void (**)(char *, unint64_t *))(v42 + 8))(v22, TupleTypeMetadata2);
  uint64_t v49 = &v19[*((int *)TupleTypeMetadata2 + 12)];
  Swift::String::Index v31 = v49;
  v30(v19, v25, a3);
  v30(v31, v26, a3);
  unint64_t v32 = &v50[*((int *)TupleTypeMetadata2 + 12)];
  v28();
  ((void (*)(char *, char *, uint64_t))v28)(v32, v26, a3);
  unint64_t v33 = v43;
  unint64_t v34 = &v43[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, uint64_t))v28)(v43, v19, a3);
  ((void (*)(char *, char *, uint64_t))v28)(v34, v32, a3);
  unint64_t v35 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  v30(v12, v33, a3);
  v30(v35, v34, a3);
  unint64_t v36 = v44;
  ((void (*)(char *, char *, uint64_t))v28)(v44, v12, a3);
  unint64_t v37 = *(void (**)(char *, uint64_t))(v48 + 8);
  v37(v35, a3);
  unint64_t v38 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, uint64_t))v28)(v12, v33, a3);
  ((void (*)(char *, char *, uint64_t))v28)(v38, v34, a3);
  uint64_t v39 = v46;
  ((void (*)(char *, char *, uint64_t))v28)(&v36[*(int *)(v46 + 36)], v38, a3);
  v37(v12, a3);
  (*(void (**)(uint64_t, char *, uint64_t))(v45 + 32))(v47, v36, v39);
  v37(v50, a3);
  return ((uint64_t (*)(char *, uint64_t))v37)(v49, a3);
}

uint64_t ClosedRange.isEmpty.getter()
{
  return 0LL;
}

uint64_t ClosedRange.relative<A>(to:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v30 = a2;
  uint64_t v31 = a1;
  unint64_t v32 = a4;
  uint64_t v7 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v12 = (char *)&v29 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v29 - v14;
  uint64_t v16 = *(void **)(v7 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v29 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 184))(v4 + *(int *)(a1 + 36), v30, a3);
  uint64_t v19 = &v15[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v20 = (void (*)(char *, uint64_t, uint64_t))v16[2];
  v20(v15, v5, v7);
  uint64_t v21 = (void (*)(char *, char *, uint64_t))v16[4];
  v21(v19, v18, v7);
  uint64_t v22 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  v20(v12, (uint64_t)v15, v7);
  v20(v22, (uint64_t)v19, v7);
  uint64_t v23 = v32;
  v21(v32, v12, v7);
  uint64_t v24 = (void (*)(char *, uint64_t))v16[1];
  v24(v22, v7);
  unint64_t v25 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  v21(v12, v15, v7);
  v21(v25, v19, v7);
  uint64_t v27 = type metadata accessor for Range(0LL, v7, *(void *)(v31 + 24), v26);
  v21(&v23[*(int *)(v27 + 36)], v25, v7);
  return ((uint64_t (*)(char *, uint64_t))v24)(v12, v7);
}

uint64_t ClosedRange.contains(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v7);
  uint64_t v15 = (char *)&v21 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *(void *)(v16 + 24);
  char v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 32))(v13, v3, v11, v17);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a1, v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v9, v3, a2);
  if ((v18 & 1) != 0) {
    char v19 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v17 + 24))( v15,  &v9[*(int *)(a2 + 36)],  v11,  v17);
  }
  else {
    char v19 = 0;
  }
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v15, v11);
  return v19 & 1;
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance ClosedRange<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  return ClosedRange.relative<A>(to:)(a3, a1, a2, a4);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = *(void *)(a2 - 16);
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v8 = type metadata accessor for ClosedRange<>.Index(0LL, *(void *)(a1 + 16), v6, v7);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)v17 - v10;
  uint64_t v12 = *(void *)(a1 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a3, v3, a1);
  ClosedRange<>.startIndex.getter(a1, (uint64_t)v11);
  (*(void (**)(uint64_t, uint64_t))(v12 + 8))(v3, a1);
  v17[0] = v6;
  v17[1] = v7;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <> ClosedRange<A>, a1, v17);
  uint64_t v15 = type metadata accessor for IndexingIterator(0LL, a1, WitnessTable, v14);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 32))(a3 + *(int *)(v15 + 36), v11, v8);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>( a1,  a2,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  Collection.underestimatedCount.getter);
}

uint64_t protocol witness for Sequence._customContainsEquatableElement(_:) in conformance <> ClosedRange<A>( char *a1, uint64_t a2)
{
  return ClosedRange<>._customContainsEquatableElement(_:)(a1, a2);
}

uint64_t ClosedRange<>._customContainsEquatableElement(_:)(char *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(v15 + 8);
  uint64_t v21 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v16 + 24);
  char v17 = v21(v3, a1, v11, v16);
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v14, a1, v11);
  (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v9, v3, a2);
  if ((v17 & 1) != 0) {
    char v18 = v21(v14, &v9[*(int *)(a2 + 36)], v11, v16);
  }
  else {
    char v18 = 0;
  }
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
  return v18 & 1;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>( a1,  a2,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  Collection._copyToContiguousArray());
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  int8x16_t v8 = vextq_s8(*(int8x16_t *)(a2 - 16), *(int8x16_t *)(a2 - 16), 8uLL);
  uint64_t WitnessTable = swift_getWitnessTable(a3, a1, &v8);
  return a4(a1, WitnessTable);
}

uint64_t static ClosedRange<>.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = a2;
  uint64_t v5 = *(void **)(a3 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  unint64_t v32 = (char *)&v29 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v30 = v8;
  uint64_t v31 = (char *)&v29 - v9;
  uint64_t v12 = type metadata accessor for ClosedRange<>.Index(0LL, v10, v8, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v29 - v14;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v12, v12, 0LL, 0LL);
  uint64_t v33 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v19 = (char *)&v29 - v18;
  uint64_t v20 = (char *)&v29 + *(int *)(v17 + 48) - v18;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v21((char *)&v29 - v18, a1, v12);
  v21(v20, v34, v12);
  uint64_t v22 = (unsigned int (*)(char *, uint64_t, uint64_t))v5[6];
  if (v22(v19, 1LL, a3) == 1)
  {
    char v23 = 1;
    if (v22(v20, 1LL, a3) == 1) {
      goto LABEL_8;
    }
  }

  else
  {
    v21(v15, (uint64_t)v19, v12);
    if (v22(v20, 1LL, a3) != 1)
    {
      uint64_t v24 = (void (*)(char *, char *, uint64_t))v5[4];
      unint64_t v25 = v31;
      v24(v31, v15, a3);
      uint64_t v26 = v32;
      v24(v32, v20, a3);
      char v23 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v30 + 8) + 8LL) + 8LL))( v25,  v26,  a3);
      uint64_t v27 = (void (*)(char *, uint64_t))v5[1];
      v27(v26, a3);
      v27(v25, a3);
      goto LABEL_8;
    }

    ((void (*)(char *, uint64_t))v5[1])(v15, a3);
  }

  char v23 = 0;
  uint64_t v13 = v33;
  uint64_t v12 = (uint64_t)TupleTypeMetadata2;
LABEL_8:
  (*(void (**)(char *, uint64_t))(v13 + 8))(v19, v12);
  return v23 & 1;
}

uint64_t static ClosedRange<>.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = a1;
  uint64_t v35 = a2;
  uint64_t v4 = *(void *)(a3 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v33 = (char *)&v30 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v5);
  uint64_t v31 = (char *)&v30 - v8;
  uint64_t v32 = v7;
  uint64_t v11 = type metadata accessor for ClosedRange<>.Index(0LL, v9, v7, v10);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v30 - v13;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v11, v11, 0LL, 0LL);
  uint64_t v16 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v19 = (char *)&v30 - v18;
  uint64_t v20 = (char *)&v30 + *(int *)(v17 + 48) - v18;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v21((char *)&v30 - v18, v34, v11);
  v21(v20, v35, v11);
  uint64_t v35 = v4;
  uint64_t v22 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v4 + 48);
  if (v22(v19, 1LL, a3) == 1)
  {
    char v23 = 0;
    uint64_t v12 = v16;
    uint64_t v11 = (uint64_t)TupleTypeMetadata2;
  }

  else
  {
    v21(v14, (uint64_t)v19, v11);
    if (v22(v20, 1LL, a3) == 1)
    {
      (*(void (**)(char *, uint64_t))(v35 + 8))(v14, a3);
      char v23 = 1;
    }

    else
    {
      uint64_t v24 = v35;
      unint64_t v25 = *(void (**)(char *, char *, uint64_t))(v35 + 32);
      uint64_t v26 = v31;
      v25(v31, v14, a3);
      uint64_t v27 = v33;
      v25(v33, v20, a3);
      char v23 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v32 + 8) + 16LL))(v26, v27, a3);
      Swift::String::Index v28 = *(void (**)(char *, uint64_t))(v24 + 8);
      v28(v27, a3);
      v28(v26, a3);
    }
  }

  (*(void (**)(char *, uint64_t))(v12 + 8))(v19, v11);
  return v23 & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance ClosedRange<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static ClosedRange<>.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance ClosedRange<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static ClosedRange<>.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16));
}

void ClosedRange<>.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v12 + 16))(v11, v13);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v6 + 48))(v11, 1LL, v5) == 1)
  {
    Hasher._combine(_:)(1u);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v6 + 32))(v9, v11, v5);
    Hasher._combine(_:)(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v5, a3);
    (*(void (**)(char *, uint64_t))(v6 + 8))(v9, v5);
  }

Swift::Int ClosedRange<>.Index<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v14[-1] - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v5);
  uint64_t v9 = (char *)&v14[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v14[0] = 0LL;
  v14[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  uint64_t v14[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v14[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v14[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  (*(void (**)(char *, uint64_t))(v10 + 16))(v9, v11);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v4 + 48))(v9, 1LL, v3) == 1)
  {
    Hasher._combine(_:)(1u);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v4 + 32))(v7, v9, v3);
    Hasher._combine(_:)(0);
    (*(void (**)(void *, uint64_t, uint64_t))(a2 + 24))(v14, v3, a2);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v7, v3);
  }

  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> ClosedRange<A><>.Index( uint64_t a1, uint64_t a2)
{
  return ClosedRange<>.Index<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <> ClosedRange<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))ClosedRange<>.Index<>.hash(into:));
}

uint64_t ClosedRange<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(a2, v3, v5);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v6 + 56))(a2, 0LL, 1LL, v5);
}

uint64_t ClosedRange<>.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 56LL))( a2,  1LL,  1LL);
}

uint64_t ClosedRange<>.index(after:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v32 = a5;
  uint64_t v33 = a1;
  uint64_t v8 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v8,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v30 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v29 = (char *)&v28 - v10;
  uint64_t v11 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( a3,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  __int128 v15 = (char *)&v28 - v14;
  uint64_t v16 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v28 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = type metadata accessor for ClosedRange<>.Index(0LL, v8, a3, a4);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (char *)&v28 - v20;
  (*(void (**)(char *, uint64_t))(v22 + 16))((char *)&v28 - v20, v33);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48))(v21, 1LL, v8) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Incrementing past end index",  27LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0xE4uLL,  0);
  }
  (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v18, v21, v8);
  if (((*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 8) + 8LL) + 8LL))( v18,  v31 + *(int *)(a2 + 36),  v8) & 1) != 0)
  {
    uint64_t v23 = 1LL;
    uint64_t v24 = v32;
  }

  else
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  AssociatedTypeWitness,  v12,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  v12,  AssociatedConformanceWitness);
    uint64_t v26 = v29;
    (*(void (**)(char *, unint64_t, uint64_t))(v11 + 24))(v15, AssociatedTypeWitness, v11);
    uint64_t v24 = v32;
    (*(void (**)(char *, uint64_t, uint64_t))(a3 + 48))(v26, v8, a3);
    (*(void (**)(char *, unint64_t))(v30 + 8))(v26, AssociatedTypeWitness);
    uint64_t v23 = 0LL;
  }

  (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 56))(v24, v23, 1LL, v8);
}

uint64_t ClosedRange<>.index(before:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v48 = a1;
  uint64_t v46 = a5;
  uint64_t v47 = a4;
  uint64_t v7 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v45 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  BOOL v44 = (char *)&v41 - v9;
  uint64_t v43 = *(const char **)(*(void *)(swift_getAssociatedConformanceWitness( (uint64_t)a3,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                                   + 8)
                       + 16LL);
  unint64_t v42 = swift_getAssociatedTypeWitness( 0LL,  v43,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](v42);
  uint64_t v41 = (char *)&v41 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  __int128 v15 = (char *)&v41 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v41 - v17;
  uint64_t v19 = *(void *)(v7 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v16);
  uint64_t v22 = (char *)&v41 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v41 - v23;
  uint64_t v50 = a3;
  uint64_t v25 = type metadata accessor for ClosedRange<>.Index(0LL, v7, (uint64_t)a3, v47);
  MEMORY[0x1895F8858](v25);
  uint64_t v27 = (char *)&v41 - v26;
  (*(void (**)(char *, uint64_t))(v28 + 16))((char *)&v41 - v26, v48);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v27, 1LL, v7) != 1)
  {
    (*(void (**)(char *, char *, uint64_t))(v19 + 32))(v24, v27, v7);
    (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v22, v24, v7);
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v18, v49, a2);
    uint64_t v32 = v50;
    if (((*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v50 + 1) + 40LL))(v22, v18, v7) & 1) != 0)
    {
      (*(void (**)(char *, uint64_t))(v12 + 8))(v18, a2);
      uint64_t v33 = *(void (**)(char *, uint64_t))(v19 + 8);
      v33(v22, v7);
      unint64_t v34 = v42;
      uint64_t v35 = v43;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v43,  AssociatedTypeWitness,  v42,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v37 = v41;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE78,  257LL,  v34,  AssociatedConformanceWitness);
      unint64_t v38 = v44;
      (*((void (**)(char *, unint64_t, const char *))v35 + 3))(v37, AssociatedTypeWitness, v35);
      uint64_t v31 = v46;
      (*((void (**)(char *, uint64_t, const char *))v32 + 6))(v38, v7, v32);
      (*(void (**)(char *, unint64_t))(v45 + 8))(v38, AssociatedTypeWitness);
      v33(v24, v7);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v19 + 56))(v31, 0LL, 1LL, v7);
    }

    unint64_t v40 = 236LL;
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Incrementing past start index",  29LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  v40,  0);
  }

  uint64_t v29 = v49;
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, v49, a2);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v50 + 1) + 32LL))( &v15[*(int *)(a2 + 36)],  v15,  v7) & 1) == 0)
  {
    unint64_t v40 = 239LL;
    goto LABEL_9;
  }

  (*(void (**)(char *, uint64_t))(v12 + 8))(v15, a2);
  uint64_t v30 = v29 + *(int *)(a2 + 36);
  uint64_t v31 = v46;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v19 + 16))(v46, v30, v7);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v19 + 56))(v31, 0LL, 1LL, v7);
}

uint64_t ClosedRange<>.index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v197 = a2;
  uint64_t v196 = a6;
  uint64_t v185 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v184 = (char *)&v173 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v199 = v10;
  uint64_t v11 = *(void *)(v10 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v12,  v11,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v186 = *(void *)(swift_getAssociatedConformanceWitness( a4,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                   + 8);
  Swift::String::Index v190 = *(const char **)(v186 + 16);
  unint64_t v189 = swift_getAssociatedTypeWitness( 0LL,  v190,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v189);
  Swift::String::Index v188 = (char *)&v173 - v14;
  __int128 v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v16 = *(v15 - 1);
  unint64_t v192 = v15;
  uint64_t v193 = v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  char v178 = (char *)&v173 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64_t v177 = (char *)&v173 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v191 = (char *)&v173 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v179 = (char *)&v173 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  BOOL v180 = (char *)&v173 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v194 = (char *)&v173 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  size_t v200 = (char *)&v173 - v30;
  uint64_t v31 = *(void *)(v11 - 8);
  uint64_t v32 = MEMORY[0x1895F8858](v29);
  uint64_t v182 = (char *)&v173 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v183 = (char *)&v173 - v35;
  MEMORY[0x1895F8858](v34);
  unint64_t v37 = (char *)&v173 - v36;
  unint64_t v195 = (uint64_t (*)(uint64_t, uint64_t))a5;
  uint64_t v38 = type metadata accessor for ClosedRange<>.Index(0LL, v11, a4, a5);
  uint64_t v39 = *(void *)(v38 - 8);
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  unint64_t v42 = (char *)&v173 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v40);
  BOOL v44 = (char *)&v173 - v43;
  uint64_t v45 = *(void (**)(char *, uint64_t, uint64_t))(v39 + 16);
  v45((char *)&v173 - v43, a1, v38);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v31 + 48))(v44, 1LL, v11) != 1)
  {
    uint64_t v49 = *(void (**)(char *, char *, uint64_t))(v31 + 32);
    v49(v37, v44, v11);
    uint64_t v50 = v198 + *(int *)(v199 + 36);
    unint64_t v51 = *(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 40);
    unint64_t v52 = v200;
    uint64_t v187 = a4;
    v51(v50, v11, a4);
    uint64_t v53 = *((void *)v195 + 1);
    uint64_t v54 = *(uint64_t (**)(unint64_t *, uint64_t))(v53 + 64);
    uint64_t v55 = (uint64_t)v192;
    char v56 = v54(v192, v53);
    Swift::Int v57 = v52;
    uint64_t v181 = v37;
    uint64_t v176 = v31;
    Swift::Int v174 = (void (*)(uint64_t, char *, uint64_t))v49;
    unint64_t v195 = (uint64_t (*)(uint64_t, uint64_t))v54;
    if ((v56 & 1) != 0)
    {
      unint64_t v175 = *(uint64_t (**)(uint64_t, uint64_t))(v53 + 128);
      uint64_t v58 = v175(v55, v53);
      int64_t v61 = v194;
      if (v58 < 64)
      {
        uint64_t v62 = v193;
        goto LABEL_19;
      }

      uint64_t v68 = v197;
      v201[0] = v197;
      Swift::String::Index v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v53 + 96);
      unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
      v72(v201, &type metadata for Int, v73, v55, v53);
      uint64_t v71 = v187;
    }

    else
    {
      char v63 = v54((unint64_t *)v55, v53);
      unint64_t v175 = *(uint64_t (**)(uint64_t, uint64_t))(v53 + 128);
      uint64_t v64 = v175(v55, v53);
      if ((v63 & 1) == 0)
      {
        uint64_t v82 = v187;
        if (v64 < 64)
        {
          uint64_t v62 = v193;
          int64_t v61 = v194;
LABEL_19:
          (*(void (**)(char *, char *, uint64_t))(v62 + 16))(v61, v57, v55);
          uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t))(v53 + 120))(v55, v53);
          Swift::String::Index v76 = *(uint64_t (**)(char *, uint64_t))(v62 + 8);
          uint64_t v78 = v76(v61, v55);
          uint64_t v68 = v197;
          unint64_t v81 = v181;
          if (v83 >= v197) {
            goto LABEL_47;
          }
          goto LABEL_26;
        }

        uint64_t v94 = v193;
        char v95 = v179;
        uint64_t v96 = (*(uint64_t (**)(char *, char *, uint64_t))(v193 + 16))(v179, v52, v55);
        uint64_t v68 = v197;
        if (v197 <= 0)
        {
          Swift::String::Index v76 = *(uint64_t (**)(char *, uint64_t))(v94 + 8);
          uint64_t v78 = v76(v95, v55);
          int64_t v61 = v194;
          unint64_t v81 = v181;
          goto LABEL_47;
        }

        v201[0] = v197;
        unint64_t v99 = v95;
        id v100 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v53 + 96);
        unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
        int64_t v61 = v194;
        v100(v201, &type metadata for Int, v101, v55, v53);
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v82,  v11,  v55,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
        char v75 = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(AssociatedConformanceWitness + 16))( v99,  v61,  v55,  AssociatedConformanceWitness);
        Swift::String::Index v76 = *(uint64_t (**)(char *, uint64_t))(v193 + 8);
        v76(v61, v55);
        unint64_t v77 = v99;
        goto LABEL_14;
      }

      uint64_t v67 = v187;
      if (v64 <= 64)
      {
        uint64_t v84 = v187;
        unint64_t v85 = v189;
        unint64_t v86 = v190;
        unint64_t v87 = swift_getAssociatedConformanceWitness( (uint64_t)v190,  v55,  v189,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v88 = v188;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))( &unk_18180BE68,  256LL,  v85,  v87);
        unint64_t v89 = v194;
        (*((void (**)(char *, uint64_t, const char *))v86 + 3))(v88, v55, v86);
        unint64_t v90 = swift_getAssociatedConformanceWitness( v84,  v11,  v55,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
        LOBYTE(v85) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v90 + 16))( v52,  v89,  v55,  v90);
        uint64_t v91 = v193;
        unint64_t v92 = *(void (**)(char *, uint64_t))(v193 + 8);
        v92(v89, v55);
        unint64_t v93 = v180;
        (*(void (**)(char *, char *, uint64_t))(v91 + 16))(v180, v52, v55);
        if ((v85 & 1) != 0)
        {
          Swift::String::Index v76 = (uint64_t (*)(char *, uint64_t))v92;
          v92(v93, v55);
          int64_t v61 = v194;
          goto LABEL_26;
        }

        uint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(v53 + 120))(v55, v53);
        Swift::String::Index v76 = (uint64_t (*)(char *, uint64_t))v92;
        uint64_t v78 = ((uint64_t (*)(char *, uint64_t))v92)(v93, v55);
        uint64_t v68 = v197;
        int64_t v61 = v194;
        unint64_t v81 = v181;
        if (v103 < v197)
        {
LABEL_26:
          uint64_t v199 = v11;
          unint64_t v105 = v189;
          unint64_t v104 = v190;
          unint64_t v106 = swift_getAssociatedConformanceWitness( (uint64_t)v190,  v55,  v189,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v107 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v106 + 8);
          uint64_t v108 = (void (*)(char *, uint64_t))v76;
          uint64_t v109 = v188;
          v107(&unk_18180BE78, 257LL, v105, v106);
          uint64_t v110 = (void (*)(char *, uint64_t, const char *))*((void *)v104 + 3);
          uint64_t v111 = v109;
          char v112 = v108;
          v110(v111, v55, v104);
          uint64_t v113 = v191;
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v186 + 8) + 40LL))(v200, v61, v55);
          v108(v61, v55);
          uint64_t v114 = v195;
          if ((v195(v55, v53) & 1) != 0)
          {
            uint64_t v115 = v175(v55, v53);
            if (v115 < 64)
            {
              uint64_t v118 = (*(uint64_t (**)(uint64_t, uint64_t))(v53 + 120))(v55, v53);
              uint64_t v119 = v113;
              uint64_t v120 = v118;
              v108(v119, v55);
              BOOL v121 = v120 == v197;
              uint64_t v122 = v199;
              uint64_t v123 = v55;
              goto LABEL_41;
            }

            v201[0] = v197;
            uint64_t v135 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v53 + 96);
            unint64_t v136 = lazy protocol witness table accessor for type Int and conformance Int(v115, v116, v117);
            uint64_t v137 = v194;
            v135(v201, &type metadata for Int, v136, v55, v53);
            uint64_t v122 = v199;
            unint64_t v138 = swift_getAssociatedConformanceWitness( v187,  v199,  v55,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
            unint64_t v139 = v113;
            char v134 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v138 + 8) + 8LL))(v113, v137, v55);
            v108(v137, v55);
            v108(v139, v55);
            uint64_t v123 = v55;
            goto LABEL_33;
          }

          char v124 = v114(v55, v53);
          uint64_t v125 = v55;
          uint64_t v126 = v175(v55, v53);
          if ((v124 & 1) != 0)
          {
            if (v126 > 64)
            {
              v201[0] = v197;
              char v129 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v53 + 96);
              unint64_t v130 = lazy protocol witness table accessor for type Int and conformance Int(v126, v127, v128);
              size_t v131 = v194;
              uint64_t v123 = v55;
              v129(v201, &type metadata for Int, v130, v55, v53);
              uint64_t v122 = v199;
              unint64_t v132 = swift_getAssociatedConformanceWitness( v187,  v199,  v55,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
              uint64_t v133 = v191;
              char v134 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v132 + 8) + 8LL))(v191, v131, v55);
              v112(v131, v55);
              v112(v133, v55);
LABEL_33:
              unint64_t v140 = v181;
              if ((v134 & 1) != 0) {
                goto LABEL_45;
              }
LABEL_54:
              unint64_t v172 = 256LL;
              goto LABEL_55;
            }

            uint64_t v143 = v188;
            ((void (*)(void *, uint64_t))v107)(&unk_18180BE68, 256LL);
            char v144 = v194;
            uint64_t v123 = v55;
            v110(v143, v55, v190);
            uint64_t v122 = v199;
            unint64_t v145 = swift_getAssociatedConformanceWitness( v187,  v199,  v55,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
            int64_t v146 = v191;
            char v147 = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v145 + 32))( v191,  v144,  v55,  v145);
            v108(v144, v55);
            uint64_t v148 = v177;
            (*(void (**)(char *, char *, uint64_t))(v193 + 32))(v177, v146, v55);
            if ((v147 & 1) != 0)
            {
              uint64_t v149 = (*(uint64_t (**)(uint64_t, uint64_t))(v53 + 120))(v55, v53);
              v108(v148, v55);
              BOOL v121 = v149 == v197;
LABEL_41:
              unint64_t v140 = v181;
              if (!v121) {
                goto LABEL_54;
              }
LABEL_45:
              v112(v200, v123);
              uint64_t v158 = v176;
              (*(void (**)(char *, uint64_t))(v176 + 8))(v140, v122);
              return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v158 + 56))(v196, 1LL, 1LL, v122);
            }

            char v178 = v148;
          }

          else
          {
            unint64_t v140 = v181;
            if (v126 < 64)
            {
              unint64_t v141 = v191;
              uint64_t v123 = v125;
              uint64_t v142 = (*(uint64_t (**)(uint64_t, uint64_t))(v53 + 120))(v125, v53);
              v108(v141, v123);
              uint64_t v122 = v199;
              if (v142 == v197) {
                goto LABEL_45;
              }
              goto LABEL_54;
            }

            uint64_t v150 = v178;
            uint64_t v123 = v125;
            uint64_t v151 = (*(uint64_t (**)(char *, char *, uint64_t))(v193 + 32))(v178, v191, v125);
            uint64_t v122 = v199;
            if ((v197 & 0x8000000000000000LL) == 0)
            {
              v201[0] = v197;
              unint64_t v154 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v53 + 96);
              unint64_t v155 = lazy protocol witness table accessor for type Int and conformance Int(v151, v152, v153);
              unint64_t v156 = v194;
              v154(v201, &type metadata for Int, v155, v123, v53);
              unint64_t v157 = swift_getAssociatedConformanceWitness( v187,  v122,  v123,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
              LOBYTE(v154) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v157 + 8) + 8LL))( v150,  v156,  v123);
              v112(v156, v123);
              v112(v150, v123);
              goto LABEL_54;
            }
          }

          v108(v178, v125);
          goto LABEL_54;
        }

BOOL static BinaryInteger.<= infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v104 = a2;
  uint64_t v105 = a1;
  unint64_t v99 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v99,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v96 = (char *)&v87 - v10;
  char v95 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t v94 = swift_getAssociatedTypeWitness( 0LL,  v95,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v94);
  unint64_t v93 = (char *)&v87 - v12;
  uint64_t v103 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v98 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v87 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  unint64_t v101 = (char *)&v87 - v19;
  uint64_t v102 = *(void *)(a4 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v87 - v24;
  MEMORY[0x1895F8858](v23);
  id v100 = (char *)&v87 - v26;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  int v28 = v27(a4, a6);
  if (((v28 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a5 + 64))(a3, a5)) & 1) != 0)
  {
    unint64_t v87 = v25;
    char v88 = v22;
    uint64_t v29 = v99;
    unint64_t v89 = v17;
    char v30 = v27(a4, a6);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    uint64_t v91 = a6;
    uint64_t v32 = v31(a4, a6);
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v92 = a3;
    uint64_t v90 = a5;
    uint64_t v34 = v33(a3, a5);
    uint64_t v35 = a4;
    if ((v30 & 1) != 0)
    {
      if (v34 >= v32)
      {
        unint64_t v54 = v94;
        uint64_t v55 = v95;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v95,  a4,  v94,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        Swift::Int v57 = v93;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v54,  AssociatedConformanceWitness);
        uint64_t v58 = v100;
        (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a4, v55);
        uint64_t v59 = v91;
        uint64_t v60 = v104;
        LOBYTE(v54) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v91 + 32) + 8LL)
                                                                          + 16LL))( v104,  v58,  a4);
        uint64_t v61 = v102;
        uint64_t v62 = *(void (**)(char *, uint64_t))(v102 + 8);
        v62(v58, v35);
        char v63 = v87;
        (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v87, v60, v35);
        uint64_t v64 = v103;
        uint64_t v65 = v89;
        uint64_t v66 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v89, v105, v92);
        if ((v54 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t))(v64 + 8))(v65, v66);
          v62(v63, v35);
          char v40 = 1;
        }

        else
        {
          uint64_t v84 = v90;
          unint64_t v85 = v101;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v63, v35, v59, v66, v90);
          char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v84 + 32) + 8LL) + 16LL))( v85,  v65,  v66);
          unint64_t v86 = *(void (**)(char *, uint64_t))(v64 + 8);
          v86(v85, v66);
          v86(v65, v66);
        }
      }

      else
      {
        uint64_t v36 = v101;
        uint64_t v37 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v105, v92);
        uint64_t v38 = v91;
        uint64_t v39 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v36, v37, v90, a4, v91);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v38 + 32) + 8LL) + 16LL))( v104,  v39,  a4);
        (*(void (**)(char *, uint64_t))(v102 + 8))(v39, a4);
      }
    }

    else if (v32 >= v34)
    {
      uint64_t v67 = v92;
      unint64_t v68 = AssociatedTypeWitness;
      unint64_t v69 = swift_getAssociatedConformanceWitness( (uint64_t)v29,  v92,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v70 = v96;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v69 + 8))( &unk_18180BE68,  256LL,  v68,  v69);
      uint64_t v71 = v101;
      (*((void (**)(char *, uint64_t, const char *))v29 + 3))(v70, v67, v29);
      uint64_t v72 = v90;
      uint64_t v73 = v105;
      LOBYTE(v68) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8LL) + 40LL))( v105,  v71,  v67);
      uint64_t v74 = v103;
      char v75 = *(void (**)(char *, uint64_t))(v103 + 8);
      v75(v71, v67);
      uint64_t v76 = v102;
      unint64_t v77 = v88;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v88, v104, v35);
      uint64_t v78 = *(void (**)(char *, uint64_t, uint64_t))(v74 + 16);
      uint64_t v79 = v98;
      v78(v98, v73, v67);
      if ((v68 & 1) != 0)
      {
        uint64_t v80 = v72;
        uint64_t v81 = v91;
        uint64_t v82 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v79, v67, v80, v35, v91);
        char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v81 + 32) + 8LL) + 16LL))( v77,  v82,  v35);
        uint64_t v83 = *(void (**)(char *, uint64_t))(v76 + 8);
        v83(v82, v35);
        v83(v77, v35);
      }

      else
      {
        v75(v79, v67);
        (*(void (**)(char *, uint64_t))(v76 + 8))(v77, v35);
        char v40 = 0;
      }
    }

    else
    {
      uint64_t v46 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v104, a4);
      uint64_t v47 = v90;
      uint64_t v48 = v101;
      uint64_t v49 = v46;
      uint64_t v50 = v92;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v49, a4, v91, v92, v90);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v47 + 32) + 8LL) + 16LL))( v48,  v105,  v50);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v48, v50);
    }
  }

  else
  {
    uint64_t v41 = v104;
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
    uint64_t v43 = v105;
    if (v42 >= (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5))
    {
      unint64_t v51 = v101;
      (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v43, a3);
      unint64_t v52 = v100;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v51, a3, a5, a4, a6);
      char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v41,  v52,  a4);
      (*(void (**)(char *, uint64_t))(v102 + 8))(v52, a4);
    }

    else
    {
      BOOL v44 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v41, a4);
      uint64_t v45 = v101;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v44, a4, a6, a3, a5);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v45,  v43,  a3);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v45, a3);
    }
  }

  return (v40 & 1) == 0;
}

unint64_t specialized numericCast<A, B>(_:)(unint64_t result)
{
  if ((result & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  if (result >= 0x100) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  return result;
}

uint64_t specialized numericCast<A, B>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v81 = *(const char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v81,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v80 - v8;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v7);
  uint64_t v82 = (char *)&v80 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v84 = (char *)&v80 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v80 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  unint64_t v85 = (char *)&v80 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v86 = (char *)&v80 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v80 - v23;
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v80 - v25;
  uint64_t v27 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v27((char *)&v80 - v25, a1, a2);
  unint64_t v87 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v87(a2, a3);
  v27(v24, (uint64_t)v26, a2);
  if ((a1 & 1) == 0)
  {
    uint64_t v29 = *(void (**)(char *, uint64_t))(v10 + 8);
    v29(v24, a2);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    char v30 = v87;
    uint64_t v38 = v31(a2, a3);
    goto LABEL_23;
  }

  uint64_t v83 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v28 = v83(a2, a3);
  uint64_t v29 = *(void (**)(char *, uint64_t))(v10 + 8);
  v29(v24, a2);
  if (v28 <= 64) {
    goto LABEL_21;
  }
  v27(v86, (uint64_t)v26, a2);
  int64_t v89 = 0x8000000000000000LL;
  char v30 = v87;
  if ((v87(a2, a3) & 1) == 0)
  {
    char v39 = v30(a2, a3);
    uint64_t v40 = v83(a2, a3);
    if ((v39 & 1) != 0)
    {
      if (v40 <= 64)
      {
        char v56 = v81;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v81,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
        uint64_t v58 = v85;
        (*((void (**)(char *, uint64_t, const char *))v56 + 3))(v9, a2, v56);
        uint64_t v59 = v86;
        LODWORD(v81) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL)
                                                                          + 16LL))( v86,  v58,  a2);
        v29(v58, a2);
        uint64_t v60 = v82;
        v27(v82, (uint64_t)v59, a2);
        char v30 = v87;
        if ((v81 & 1) != 0)
        {
          v29(v60, a2);
          goto LABEL_39;
        }

        int64_t v61 = v89;
        uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v29(v60, a2);
        BOOL v63 = v62 < v61;
        uint64_t v31 = v83;
        uint64_t v37 = v86;
        if (v63) {
          goto LABEL_39;
        }
      }

      else
      {
        uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
        uint64_t v45 = v85;
        v43(&v89, &type metadata for Int, v44, a2, a3);
        uint64_t v37 = v86;
        char v46 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v86,  v45,  a2);
        v29(v45, a2);
        char v30 = v87;
        uint64_t v31 = v83;
        if ((v46 & 1) != 0) {
          goto LABEL_39;
        }
      }

      goto LABEL_20;
    }

    if (v40 < 64)
    {
      unint64_t v52 = v85;
      uint64_t v53 = v86;
      v27(v85, (uint64_t)v86, a2);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v55 = v52;
      uint64_t v37 = v53;
      v29(v55, a2);
      char v30 = v87;
      uint64_t v31 = v83;
      if (v54 < v89) {
        goto LABEL_39;
      }
      goto LABEL_20;
    }

    v29(v86, a2);
LABEL_21:
    char v30 = v87;
    uint64_t v31 = v83;
    goto LABEL_22;
  }

  uint64_t v31 = v83;
  uint64_t v32 = v83(a2, a3);
  if (v32 < 64)
  {
    uint64_t v35 = v85;
    v27(v85, (uint64_t)v86, a2);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v29(v35, a2);
    uint64_t v37 = v86;
    if (v36 < v89) {
      goto LABEL_39;
    }
    goto LABEL_20;
  }

  uint64_t v47 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
  uint64_t v49 = v85;
  v47(&v89, &type metadata for Int, v48, a2, a3);
  uint64_t v37 = v86;
  char v50 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v86,  v49,  a2);
  unint64_t v51 = v49;
  uint64_t v31 = v83;
  v29(v51, a2);
  if ((v50 & 1) != 0) {
LABEL_39:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_20:
  v29(v37, a2);
LABEL_22:
  uint64_t v38 = v31(a2, a3);
LABEL_23:
  uint64_t v64 = v38;
  v27(v17, (uint64_t)v26, a2);
  if (v64 >= 65)
  {
    v29(v17, a2);
    goto LABEL_25;
  }

  uint64_t v74 = v31(a2, a3);
  v29(v17, a2);
  if (v74 == 64 && (v30(a2, a3) & 1) == 0)
  {
LABEL_25:
    uint64_t v65 = v31;
    uint64_t v66 = v84;
    v27(v84, (uint64_t)v26, a2);
    int64_t v89 = 0x7FFFFFFFFFFFFFFFLL;
    char v67 = v30(a2, a3);
    uint64_t v68 = v65(a2, a3);
    if ((v67 & 1) != 0)
    {
      if (v68 > 64)
      {
        uint64_t v71 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
        unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
        uint64_t v73 = &v89;
        goto LABEL_34;
      }
    }

    else if (v68 >= 64)
    {
      uint64_t v88 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v71 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
      uint64_t v73 = &v88;
LABEL_34:
      uint64_t v76 = v85;
      v71(v73, &type metadata for Int, v72, a2, a3);
      char v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v76,  v66,  a2);
      v29(v76, a2);
      if ((v77 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_35;
    }

    char v75 = v85;
    v27(v85, (uint64_t)v66, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v29(v75, a2);
LABEL_35:
    v29(v66, a2);
  }

  uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v29(v26, a2);
  return v78;
}

{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char *v25;
  char v26;
  void (*v27)(char *, uint64_t);
  uint64_t (*v28)(uint64_t, uint64_t);
  char *v29;
  char v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char v37;
  void (*v38)(char *, uint64_t);
  unint64_t v39;
  char *v40;
  unint64_t v41;
  void (*v42)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  char v44;
  unint64_t v45;
  uint64_t v46;
  char *v48;
  char *v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  uint64_t v52;
  unint64_t v53;
  uint64_t v6 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v50 = (char *)&v48 - v9;
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v48 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v49 = (char *)&v48 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v48 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v48 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v48 - v20;
  unint64_t v51 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 16);
  unint64_t v52 = v22;
  v51((char *)&v48 - v20, a1, a2);
  uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  if ((v23(a2, a3) & 1) != 0)
  {
    v51(v19, (uint64_t)v21, a2);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v25 = v50;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v25, a2, v6);
    uint64_t v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 32LL))( v19,  v16,  a2);
    uint64_t v27 = *(void (**)(char *, uint64_t))(v52 + 8);
    v27(v16, a2);
    if ((v26 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    v27(v19, a2);
  }

  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  if (v28(a2, a3) >= 64)
  {
    uint64_t v29 = v49;
    v51(v49, (uint64_t)v21, a2);
    uint64_t v53 = -1LL;
    char v30 = v23(a2, a3);
    uint64_t v31 = v29;
    LOBYTE(v29) = v30;
    uint64_t v32 = v28(a2, a3);
    if ((v29 & 1) != 0)
    {
      if (v32 <= 64)
      {
        uint64_t v35 = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v36 = v50;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v35 + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  v35);
        (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v36, a2, v6);
        uint64_t v37 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 40LL))( v31,  v16,  a2);
        uint64_t v38 = *(void (**)(char *, uint64_t))(v52 + 8);
        v38(v16, a2);
        char v39 = v53;
        uint64_t v40 = v48;
        v51(v48, (uint64_t)v31, a2);
        if ((v37 & 1) != 0)
        {
          uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v38(v40, a2);
          if (v39 < v41) {
            goto LABEL_14;
          }
        }

        else
        {
          v38(v40, a2);
        }

        goto LABEL_16;
      }
    }

    else if (v32 <= 64)
    {
      v51(v16, (uint64_t)v31, a2);
      uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v38 = *(void (**)(char *, uint64_t))(v52 + 8);
      v38(v16, a2);
      if (v53 < v45) {
        goto LABEL_14;
      }
LABEL_16:
      v38(v31, a2);
      goto LABEL_17;
    }

    uint64_t v42 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    uint64_t v43 = lazy protocol witness table accessor for type UInt and conformance UInt(v32, v33, v34);
    v42(&v53, &type metadata for UInt, v43, a2, a3);
    unint64_t v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v16,  v31,  a2);
    uint64_t v38 = *(void (**)(char *, uint64_t))(v52 + 8);
    v38(v16, a2);
    if ((v44 & 1) != 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_16;
  }

{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char *v25;
  char v26;
  void (*v27)(char *, uint64_t);
  uint64_t (*v28)(uint64_t, uint64_t);
  char *v29;
  char v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char v37;
  void (*v38)(char *, uint64_t);
  unsigned int v39;
  char *v40;
  unsigned __int8 v41;
  void (*v42)(unsigned __int8 *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  char v44;
  unsigned __int8 v45;
  uint64_t v46;
  char *v48;
  char *v49;
  char *v50;
  void (*v51)(char *, uint64_t, uint64_t);
  uint64_t v52;
  unsigned __int8 v53;
  uint64_t v6 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v50 = (char *)&v48 - v9;
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v48 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v49 = (char *)&v48 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v48 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v48 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v48 - v20;
  unint64_t v51 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 16);
  unint64_t v52 = v22;
  v51((char *)&v48 - v20, a1, a2);
  uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  if ((v23(a2, a3) & 1) != 0)
  {
    v51(v19, (uint64_t)v21, a2);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v25 = v50;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v25, a2, v6);
    uint64_t v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 32LL))( v19,  v16,  a2);
    uint64_t v27 = *(void (**)(char *, uint64_t))(v52 + 8);
    v27(v16, a2);
    if ((v26 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    v27(v19, a2);
  }

  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  if (v28(a2, a3) >= 8)
  {
    uint64_t v29 = v49;
    v51(v49, (uint64_t)v21, a2);
    uint64_t v53 = -1;
    char v30 = v23(a2, a3);
    uint64_t v31 = v29;
    LOBYTE(v29) = v30;
    uint64_t v32 = v28(a2, a3);
    if ((v29 & 1) != 0)
    {
      if (v32 <= 8)
      {
        uint64_t v35 = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v36 = v50;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v35 + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  v35);
        (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v36, a2, v6);
        uint64_t v37 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 40LL))( v31,  v16,  a2);
        uint64_t v38 = *(void (**)(char *, uint64_t))(v52 + 8);
        v38(v16, a2);
        char v39 = v53;
        uint64_t v40 = v48;
        v51(v48, (uint64_t)v31, a2);
        if ((v37 & 1) != 0)
        {
          uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v38(v40, a2);
          if (v39 < v41) {
            goto LABEL_14;
          }
        }

        else
        {
          v38(v40, a2);
        }

        goto LABEL_16;
      }
    }

    else if (v32 <= 8)
    {
      v51(v16, (uint64_t)v31, a2);
      uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v38 = *(void (**)(char *, uint64_t))(v52 + 8);
      v38(v16, a2);
LABEL_16:
      v38(v31, a2);
      goto LABEL_17;
    }

    uint64_t v42 = *(void (**)(unsigned __int8 *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    uint64_t v43 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v32, v33, v34);
    v42(&v53, &type metadata for UInt8, v43, a2, a3);
    unint64_t v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v16,  v31,  a2);
    uint64_t v38 = *(void (**)(char *, uint64_t))(v52 + 8);
    v38(v16, a2);
    if ((v44 & 1) != 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_16;
  }

uint64_t numericCast<A, B>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v11 + 16))(v10);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 88))(v10, a2, a4, a3, a5);
}

uint64_t static BinaryInteger.== infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v104 = a1;
  uint64_t v105 = a2;
  unint64_t v99 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v99,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v96 = (char *)&v87 - v10;
  char v95 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t v94 = swift_getAssociatedTypeWitness( 0LL,  v95,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v94);
  unint64_t v93 = (char *)&v87 - v12;
  uint64_t v103 = *(void *)(a4 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v98 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v87 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  unint64_t v101 = (char *)&v87 - v19;
  uint64_t v102 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v87 - v24;
  MEMORY[0x1895F8858](v23);
  id v100 = (char *)&v87 - v26;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  int v28 = v27(a3, a5);
  if (((v28 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a6 + 64))(a4, a6)) & 1) != 0)
  {
    unint64_t v87 = v25;
    uint64_t v88 = v22;
    uint64_t v29 = v99;
    int64_t v89 = v17;
    char v30 = v27(a3, a5);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v91 = a5;
    uint64_t v32 = v31(a3, a5);
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    uint64_t v92 = a4;
    uint64_t v90 = a6;
    uint64_t v34 = v33(a4, a6);
    uint64_t v35 = a3;
    if ((v30 & 1) != 0)
    {
      if (v34 < v32)
      {
        uint64_t v36 = v101;
        uint64_t v37 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v105, v92);
        uint64_t v38 = v91;
        char v39 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v36, v37, v90, a3, v91);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v38 + 16) + 8LL) + 8LL))( v104,  v39,  a3);
        (*(void (**)(char *, uint64_t))(v102 + 8))(v39, a3);
        return v40 & 1;
      }

      unint64_t v53 = v94;
      uint64_t v54 = v95;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v95,  a3,  v94,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v56 = v93;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v53,  AssociatedConformanceWitness);
      Swift::Int v57 = v100;
      (*((void (**)(char *, uint64_t, const char *))v54 + 3))(v56, a3, v54);
      uint64_t v58 = v91;
      uint64_t v59 = v104;
      LOBYTE(v53) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v91 + 32) + 8LL) + 32LL))( v104,  v57,  a3);
      uint64_t v60 = v102;
      int64_t v61 = *(void (**)(char *, uint64_t))(v102 + 8);
      v61(v57, v35);
      uint64_t v62 = v87;
      (*(void (**)(char *, uint64_t, uint64_t))(v60 + 16))(v87, v59, v35);
      uint64_t v63 = v103;
      uint64_t v64 = v89;
      uint64_t v65 = v92;
      (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v89, v105, v92);
      if ((v53 & 1) != 0)
      {
        uint64_t v66 = v90;
        char v67 = v101;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v62, v35, v58, v65, v90);
        char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v66 + 16) + 8LL) + 8LL))( v67,  v64,  v65);
        uint64_t v68 = *(void (**)(char *, uint64_t))(v63 + 8);
        v68(v67, v65);
        v68(v64, v65);
        return v40 & 1;
      }

      (*(void (**)(char *, uint64_t))(v63 + 8))(v64, v65);
      v61(v62, v35);
    }

    else
    {
      if (v32 < v34)
      {
        char v46 = v100;
        (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v104, a3);
        uint64_t v47 = v90;
        unint64_t v48 = v101;
        uint64_t v49 = v46;
        uint64_t v50 = v92;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v49, a3, v91, v92, v90);
        char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v47 + 16) + 8LL) + 8LL))( v48,  v105,  v50);
        (*(void (**)(char *, uint64_t))(v103 + 8))(v48, v50);
        return v40 & 1;
      }

      uint64_t v69 = v92;
      unint64_t v70 = AssociatedTypeWitness;
      unint64_t v71 = swift_getAssociatedConformanceWitness( (uint64_t)v29,  v92,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v72 = v96;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v71 + 8))( &unk_18180BE68,  256LL,  v70,  v71);
      uint64_t v73 = v101;
      (*((void (**)(char *, uint64_t, const char *))v29 + 3))(v72, v69, v29);
      uint64_t v74 = v90;
      uint64_t v75 = v105;
      LOBYTE(v7swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8LL) + 32LL))( v105,  v73,  v69);
      uint64_t v76 = v103;
      char v77 = *(void (**)(char *, uint64_t))(v103 + 8);
      v77(v73, v69);
      uint64_t v78 = v102;
      uint64_t v79 = v88;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v88, v104, v35);
      uint64_t v80 = *(void (**)(char *, uint64_t, uint64_t))(v76 + 16);
      uint64_t v81 = v98;
      v80(v98, v75, v69);
      if ((v70 & 1) != 0)
      {
        uint64_t v82 = v74;
        uint64_t v83 = v91;
        uint64_t v84 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v81, v69, v82, v35, v91);
        char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v83 + 16) + 8LL) + 8LL))( v79,  v84,  v35);
        unint64_t v85 = *(void (**)(char *, uint64_t))(v78 + 8);
        v85(v84, v35);
        v85(v79, v35);
        return v40 & 1;
      }

      v77(v81, v69);
      (*(void (**)(char *, uint64_t))(v78 + 8))(v79, v35);
    }

    char v40 = 0;
    return v40 & 1;
  }

  uint64_t v41 = v104;
  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
  uint64_t v43 = v105;
  if (v42 >= (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6))
  {
    unint64_t v51 = v101;
    (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v43, a4);
    unint64_t v52 = v100;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v51, a4, a6, a3, a5);
    char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 16) + 8LL) + 8LL))( v41,  v52,  a3);
    (*(void (**)(char *, uint64_t))(v102 + 8))(v52, a3);
  }

  else
  {
    unint64_t v44 = v100;
    (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v41, a3);
    uint64_t v45 = v101;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v44, a3, a5, a4, a6);
    char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a6 + 16) + 8LL) + 8LL))( v45,  v43,  a4);
    (*(void (**)(char *, uint64_t))(v103 + 8))(v45, a4);
  }

  return v40 & 1;
}

uint64_t ClosedRange<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v53 = a3;
  uint64_t v62 = a1;
  uint64_t v63 = a2;
  uint64_t v7 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v58 = *(void *)(swift_getAssociatedConformanceWitness( a4,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                  + 8);
  uint64_t v55 = *(const char **)(v58 + 16);
  unint64_t v51 = swift_getAssociatedTypeWitness( 0LL,  v55,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v51);
  unint64_t v52 = (char *)&v50 - v9;
  uint64_t v10 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v59 = *(v10 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  char v56 = (char *)&v50 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  Swift::Int v57 = (char *)&v50 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v60 = (char *)&v50 - v16;
  uint64_t v17 = *(void **)(v7 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v50 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v50 - v21;
  uint64_t v61 = a5;
  uint64_t v23 = type metadata accessor for ClosedRange<>.Index(255LL, v7, a4, a5);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v23, v23, 0LL, 0LL);
  uint64_t v25 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v27 = (char *)&v50 - v26;
  int v28 = (char *)&v50 + *(int *)(v25 + 48) - v26;
  uint64_t v29 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v23 - 8) + 16LL);
  v29((char *)&v50 - v26, v62, v23);
  v29(v28, v63, v23);
  char v30 = (uint64_t (*)(char *, uint64_t, uint64_t))v17[6];
  LODWORD(v29) = v30(v27, 1LL, v7);
  int v31 = v30(v28, 1LL, v7);
  int v32 = v31;
  if ((_DWORD)v29 != 1)
  {
    uint64_t v34 = (void (*)(char *, char *, uint64_t))v17[4];
    v34(v22, v27, v7);
    if (v32 != 1)
    {
      v34(v20, v28, v7);
      uint64_t v41 = (uint64_t)v60;
      (*(void (**)(char *, uint64_t, uint64_t))(a4 + 40))(v20, v7, a4);
      unint64_t v48 = (void (*)(char *, uint64_t))v17[1];
      v48(v20, v7);
      v48(v22, v7);
      uint64_t v33 = specialized numericCast<A, B>(_:)(v41, (uint64_t)v10, *(void *)(v61 + 8));
      uint64_t v42 = *(void (**)(char *, unint64_t *))(v59 + 8);
      goto LABEL_9;
    }

    uint64_t v35 = v55;
    unint64_t v36 = v51;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v55,  (uint64_t)v10,  v51,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v38 = v52;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  v36,  AssociatedConformanceWitness);
    char v39 = v57;
    (*((void (**)(char *, unint64_t *, const char *))v35 + 3))(v38, v10, v35);
    char v40 = v56;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 40))(v54 + *(int *)(v53 + 36), v7, a4);
    ((void (*)(char *, uint64_t))v17[1])(v22, v7);
    uint64_t v41 = (uint64_t)v60;
    (*(void (**)(char *, char *, unint64_t *))(*(void *)(v58 + 8) + 24LL))(v39, v40, v10);
    uint64_t v42 = *(void (**)(char *, unint64_t *))(v59 + 8);
    v42(v40, v10);
LABEL_7:
    v42(v39, v10);
    uint64_t v33 = specialized numericCast<A, B>(_:)(v41, (uint64_t)v10, *(void *)(v61 + 8));
LABEL_9:
    v42((char *)v41, v10);
    return v33;
  }

  if (v31 != 1)
  {
    ((void (*)(char *, char *, uint64_t))v17[4])(v22, v28, v7);
    char v39 = v57;
    (*(void (**)(char *, uint64_t, uint64_t))(a4 + 40))(v22, v7, a4);
    ((void (*)(char *, uint64_t))v17[1])(v22, v7);
    uint64_t v43 = v55;
    unint64_t v44 = v51;
    unint64_t v45 = swift_getAssociatedConformanceWitness( (uint64_t)v55,  (uint64_t)v10,  v51,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    char v46 = v52;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v45 + 8))( &qword_18180BE70,  512LL,  v44,  v45);
    uint64_t v47 = v56;
    (*((void (**)(char *, unint64_t *, const char *))v43 + 3))(v46, v10, v43);
    uint64_t v41 = (uint64_t)v60;
    (*(void (**)(char *, char *, unint64_t *))(*(void *)(v58 + 8) + 40LL))(v39, v47, v10);
    uint64_t v42 = *(void (**)(char *, unint64_t *))(v59 + 8);
    v42(v47, v10);
    goto LABEL_7;
  }

  return 0LL;
}

uint64_t ClosedRange<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = type metadata accessor for ClosedRange<>.Index(0LL, v7, a3, a4);
  MEMORY[0x1895F8858](v8);
  uint64_t v10 = (char *)&v14 - v9;
  (*(void (**)(char *, uint64_t))(v11 + 16))((char *)&v14 - v9, a1);
  uint64_t v12 = *(void *)(v7 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v12 + 48))(v10, 1LL, v7) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x12DuLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v12 + 32))(a5, v10, v7);
}

{
  return ClosedRange<>.subscript.getter( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t, void))type metadata accessor for ClosedRange<>.Index,  (uint64_t)&protocol witness table for ClosedRange<A><>.Index,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  a5);
}

uint64_t ClosedRange<>._customIndexOfEquatableElement(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v39 = a3;
  uint64_t v40 = a4;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v35 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v16 = (char *)&v35 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = v17;
  uint64_t v18 = *(void *)(v17 + 8);
  unint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 24);
  char v19 = v36(v5, a1, v13, v18);
  uint64_t v37 = v14;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  v20(v16, a1, v13);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v11, v5, a2);
  if ((v19 & 1) != 0)
  {
    uint64_t v35 = (void (*)(uint64_t, uint64_t, uint64_t))v20;
    char v21 = v36((uint64_t)v16, (uint64_t)&v11[*(int *)(a2 + 36)], v13, v18);
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, a2);
    uint64_t v22 = v37;
    (*(void (**)(char *, uint64_t))(v37 + 8))(v16, v13);
    uint64_t v24 = v39;
    uint64_t v23 = v40;
    uint64_t v25 = v38;
    if ((v21 & 1) != 0)
    {
      v35(v40, a1, v13);
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v22 + 56))(v23, 0LL, 1LL, v13);
      uint64_t v26 = type metadata accessor for ClosedRange<>.Index(0LL, v13, v25, v24);
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v26 - 8) + 56LL))(v23, 0LL, 1LL, v26);
      uint64_t v29 = type metadata accessor for Optional(0LL, v26, v27, v28);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v29 - 8) + 56LL))( v23,  0LL,  1LL,  v29);
    }
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, a2);
    (*(void (**)(char *, uint64_t))(v37 + 8))(v16, v13);
    uint64_t v24 = v39;
    uint64_t v23 = v40;
    uint64_t v25 = v38;
  }

  uint64_t v31 = type metadata accessor for ClosedRange<>.Index(255LL, v13, v25, v24);
  uint64_t v34 = type metadata accessor for Optional(0LL, v31, v32, v33);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v34 - 8) + 56LL))( v23,  1LL,  1LL,  v34);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return ClosedRange<>.endIndex.getter(a1, a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> ClosedRange<A>( uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = (uint64_t *)malloc(0x28uLL);
  *a1 = v8;
  v8[4] = (uint64_t)ClosedRange<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*ClosedRange<>.subscript.read( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(void *a1)
{
  uint64_t v7 = *(void *)(a3 + 16);
  *a1 = v7;
  uint64_t v8 = type metadata accessor for ClosedRange<>.Index(0LL, v7, a4, a5);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = malloc(*(void *)(v9 + 64));
  uint64_t v11 = *(void *)(v7 - 8);
  a1[1] = (uint64_t)v10;
  a1[2] = v11;
  uint64_t v12 = malloc(*(void *)(v11 + 64));
  a1[3] = (uint64_t)v12;
  (*(void (**)(void *, uint64_t, uint64_t))(v9 + 16))(v10, a2, v8);
  if ((*(unsigned int (**)(void *, uint64_t, uint64_t))(v11 + 48))(v10, 1LL, v7) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x12DuLL,  0);
  }
  (*(void (**)(void *, void *, uint64_t))(v11 + 32))(v12, v10, v7);
  return ClosedRange<>.subscript.read;
}

void ClosedRange<>.subscript.read(void *a1)
{
  uint64_t v1 = (void *)a1[3];
  uint64_t v2 = (void *)a1[1];
  (*(void (**)(void *, void))(a1[2] + 8LL))(v1, *a1);
  free(v1);
  free(v2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return ClosedRange<>.subscript.getter(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16), a4);
}

uint64_t Collection<>.indices.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void (**)(uint64_t, uint64_t))(a2 + 64);
  type metadata accessor for DefaultIndices(0LL, a1, a2, v7);
  v6(a1, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 72))(a1, a2);
}

uint64_t protocol witness for Collection.isEmpty.getter in conformance <> ClosedRange<A>()
{
  return 0LL;
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return ClosedRange<>._customIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 16), a4);
}

uint64_t protocol witness for Collection._customLastIndexOfEquatableElement(_:) in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ClosedRange<>._customLastIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> ClosedRange<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  a6);
}

uint64_t protocol witness for Collection.index(after:) in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return ClosedRange<>.index(after:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16), a4);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance <> ClosedRange<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t, uint64_t))ClosedRange<>.index(after:));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return ClosedRange<>.index(before:)(a1, a2, *(const char **)(a3 - 8), *(void *)(a3 - 16), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance <> ClosedRange<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t, uint64_t))ClosedRange<>.index(before:));
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v8 = *(void *)(a3 - 16);
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v9 = type metadata accessor for ClosedRange<>.Index(0LL, *(void *)(a2 + 16), v7, v8);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v14 - v11;
  a4(a1, a2, v7, v8);
  (*(void (**)(uint64_t, uint64_t))(v10 + 8))(a1, v9);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v10 + 32))(a1, v12, v9);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return ClosedRange<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16), a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ClosedRange<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16));
}

uint64_t static Comparable.... infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static Comparable...< infix(_:_:)( a1,  a2,  a3,  a4,  "Swift/ClosedRange.swift",  23LL,  0x15BuLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for ClosedRange,  a5);
}

uint64_t static Comparable...< infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t (*a8)(void, uint64_t, uint64_t)@<X7>, uint64_t a9@<X8>)
{
  uint64_t v43 = a8;
  unint64_t v37 = a7;
  uint64_t v38 = a5;
  uint64_t v39 = a6;
  uint64_t v45 = a9;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, a3, "lower upper ", 0LL);
  uint64_t v13 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v15 = (char *)&v36 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v36 - v17;
  char v19 = *(void **)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v16);
  uint64_t v22 = (char *)&v36 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v36 - v23;
  uint64_t v25 = (void (*)(char *, uint64_t, uint64_t))v19[2];
  uint64_t v41 = a1;
  v25((char *)&v36 - v23, a1, a3);
  uint64_t v42 = a2;
  v25(v22, a2, a3);
  uint64_t v26 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a4 + 24);
  uint64_t v44 = a4;
  if ((v26(v24, v22, a3, a4) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  v38,  v39,  2,  v37,  0);
  }
  uint64_t v27 = (void (*)(char *, uint64_t))v19[1];
  v27(v22, a3);
  v27(v24, a3);
  uint64_t v28 = TupleTypeMetadata2;
  uint64_t v29 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  v25(v18, v41, a3);
  v25(v29, v42, a3);
  char v30 = &v15[*((int *)v28 + 12)];
  v25(v15, (uint64_t)v18, a3);
  v25(v30, (uint64_t)v29, a3);
  uint64_t v31 = (void (*)(uint64_t, char *, uint64_t))v19[4];
  uint64_t v32 = v45;
  v31(v45, v15, a3);
  v27(v30, a3);
  uint64_t v33 = &v15[*((int *)v28 + 12)];
  v31((uint64_t)v15, v18, a3);
  v31((uint64_t)v33, v29, a3);
  uint64_t v34 = v43(0LL, a3, v44);
  v31(v32 + *(int *)(v34 + 36), v33, a3);
  return ((uint64_t (*)(char *, uint64_t))v27)(v15, a3);
}

uint64_t static ClosedRange.== infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4)
{
  return static ClosedRange.== infix(_:_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for ClosedRange);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance ClosedRange<A>( char *a1, char *a2, uint64_t a3)
{
  return static ClosedRange.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2)
{
  return ClosedRange<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ClosedRange<>.hash(into:)(a1, a2, *(void *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))ClosedRange<>.hash(into:));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *, uint64_t, uint64_t))
{
  uint64_t v4 = *(void *)(a3 - 8);
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  a4(v6, a2, v4);
  return Hasher._finalize()();
}

unint64_t ClosedRange.description.getter(uint64_t a1)
{
  uint64_t v2 = v1;
  unint64_t v14 = specialized static String._createEmpty(withInitialCapacity:)(7LL);
  unint64_t v15 = v4;
  uint64_t v5 = *(swift **)(a1 + 16);
  _print_unlocked<A, B>(_:_:)( v1,  (uint64_t)&v14,  v5,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  uint64_t v6 = v15;
  unint64_t v7 = HIBYTE(v15) & 0xF;
  if ((v15 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = v14 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 || (v14 & ~v15 & 0x2000000000000000LL) != 0)
  {
    if ((v15 & 0x2000000000000000LL) == 0
      || (unint64_t v8 = specialized _SmallString.init(_:appending:)(v14, v15, 0x2E2E2EuLL, 0xE300000000000000LL), (v10 & 1) != 0))
    {
      _StringGuts.append(_:)(3026478LL, 0xE300000000000000LL, 0LL, 3LL);
    }

    else
    {
      unint64_t v11 = v8;
      unint64_t v12 = v9;
      swift_bridgeObjectRelease(v6);
      unint64_t v14 = v11;
      unint64_t v15 = v12;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v15);
    unint64_t v14 = 3026478LL;
    unint64_t v15 = 0xE300000000000000LL;
  }

  _print_unlocked<A, B>(_:_:)( v2 + *(int *)(a1 + 36),  (uint64_t)&v14,  v5,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  return v14;
}

unint64_t ClosedRange.debugDescription.getter(uint64_t a1)
{
  uint64_t v262 = a1;
  uint64_t v265 = *(swift **)(a1 + 16);
  unint64_t v1 = *((void *)v265 - 1);
  MEMORY[0x1895F8858](a1);
  char v264 = (char *)&v258 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(14LL);
  unint64_t v5 = (unint64_t)v4;
  v268._unint64_t countAndFlagsBits = v3;
  v268._uint64_t object = v4;
  Swift::String v8 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ClosedRange(", 0xCuLL, 1);
  unint64_t countAndFlagsBits = v8._countAndFlagsBits;
  uint64_t object = (uint64_t)v8._object;
  uint64_t v11 = HIBYTE(v5) & 0xF;
  if ((v5 & 0x2000000000000000LL) != 0) {
    uint64_t v12 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v12 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v12 && (v3 & ~v5 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v5);
    Swift::String v268 = v8;
    goto LABEL_52;
  }

  uint64_t v13 = (uint64_t)v8._object & 0x2000000000000000LL;
  int64_t v14 = ((unint64_t)v8._object >> 56) & 0xF;
  if ((v5 & 0x2000000000000000LL) != 0 && v13)
  {
    int64_t v50 = v14 + v11;
    if ((unint64_t)(v14 + v11) <= 0xF)
    {
      if (v14)
      {
        char v51 = 0;
        unint64_t v52 = 0LL;
        unint64_t v53 = v5;
        do
        {
          unint64_t v54 = v11 + v52;
          unint64_t v55 = v52 + 1;
          if (v52 >= 8) {
            unint64_t v56 = (unint64_t)v8._object;
          }
          else {
            unint64_t v56 = v8._countAndFlagsBits;
          }
          unint64_t v57 = v56 >> (v51 & 0x38);
          char v58 = (8 * v11 + v51) & 0x38;
          uint64_t v59 = (-255LL << v58) - 1;
          unint64_t v60 = (unint64_t)v57 << v58;
          unint64_t v61 = v60 | v59 & v53;
          unint64_t v62 = v60 | v59 & v3;
          if (v54 < 8) {
            uint64_t v3 = v62;
          }
          else {
            unint64_t v53 = v61;
          }
          v51 += 8;
          unint64_t v52 = v55;
        }

        while (v14 != v55);
      }

      else
      {
        unint64_t v53 = v5;
      }

      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      unint64_t v67 = 0xA000000000000000LL;
      if (!(v3 & 0x8080808080808080LL | v53 & 0x80808080808080LL)) {
        unint64_t v67 = 0xE000000000000000LL;
      }
      v268._unint64_t countAndFlagsBits = v3;
      v268._uint64_t object = (void *)(v67 & 0xFF00000000000000LL | (v50 << 56) | v53 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_52;
    }

    unint64_t v261 = v1;
    uint64_t v13 = 1LL;
  }

  else
  {
    unint64_t v261 = v1;
  }

  uint64_t v15 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v13) {
    uint64_t v16 = ((unint64_t)v8._object >> 56) & 0xF;
  }
  else {
    uint64_t v16 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n((uint64_t)v8._object, 2LL, v6, v7);
  if (((uint64_t)v8._object & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n((uint64_t)v8._object, 4LL, v17, v18);
    Swift::Int v21 = v16;
    if ((v5 & 0x1000000000000000LL) == 0) {
      goto LABEL_14;
    }
LABEL_159:
    Swift::Int v164 = String.UTF8View._foreignCount()();
    int64_t v23 = v164 + v21;
    if (!__OFADD__(v164, v21)) {
      goto LABEL_15;
    }
LABEL_161:
    __break(1u);
    goto LABEL_162;
  }

  swift_bridgeObjectRetain_n((uint64_t)v8._object, 5LL, v17, v18);
  v160._Swift::UInt64 rawBits = 1LL;
  v161._Swift::UInt64 rawBits = (v16 << 16) | 1;
  v162._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v160, v161, v8._countAndFlagsBits, (unint64_t)v8._object);
  if (v162._rawBits < 0x10000) {
    v162._rawBits |= 3;
  }
  Swift::Int v21 = specialized Collection.count.getter(v162, v163, v8._countAndFlagsBits, (unint64_t)v8._object);
  swift_bridgeObjectRelease((uint64_t)v8._object);
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_159;
  }
LABEL_14:
  BOOL v22 = __OFADD__(v12, v21);
  int64_t v23 = v12 + v21;
  if (v22) {
    goto LABEL_161;
  }
LABEL_15:
  if ((v3 & ~v5 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
    if ((v25 & 1) != 0) {
      goto LABEL_265;
    }
    uint64_t v26 = (v5 >> 61) & 1;
    if (v24 < v21) {
      LODWORD(v26) = 1;
    }
    if (v23 <= 15 && (_DWORD)v26) {
      goto LABEL_22;
    }
  }

  else if (v23 <= 15)
  {
LABEL_22:
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
    swift_bridgeObjectRetain(v5, v27, v28, v29);
    unint64_t v30 = _StringGuts._convertedToSmall()(v3, v5);
    unint64_t v32 = v31;
    swift_bridgeObjectRelease(v5);
    v33._Swift::UInt64 rawBits = (v16 << 16) | 1;
    v34._Swift::UInt64 rawBits = 1LL;
    v35._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v34, v33, v8._countAndFlagsBits, (unint64_t)v8._object);
    if (v35._rawBits < 0x10000) {
      v35._rawBits |= 3;
    }
    unint64_t v37 = specialized String.init(_:)(v35, v36, v8._countAndFlagsBits, (unint64_t)v8._object);
    unint64_t v39 = v38;
    swift_bridgeObjectRelease((uint64_t)v8._object);
    unint64_t v40 = _StringGuts._convertedToSmall()(v37, v39);
    unint64_t v42 = v41;
    swift_bridgeObjectRelease(v39);
    unint64_t v43 = specialized _SmallString.init(_:appending:)(v30, v32, v40, v42);
    if ((v45 & 1) != 0) {
      goto LABEL_264;
    }
    uint64_t v46 = v43;
    uint64_t v47 = v44;
    swift_bridgeObjectRelease(v5);
    swift_bridgeObjectRelease((uint64_t)v8._object);
    v268._unint64_t countAndFlagsBits = v46;
    v268._uint64_t object = v47;
    unint64_t v1 = v261;
    goto LABEL_52;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v23, v21);
  swift_bridgeObjectRelease_n((uint64_t)v8._object, 4LL);
  if (((uint64_t)v8._object & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v8._object);
    _StringGuts._foreignAppendInPlace(_:)(v8._countAndFlagsBits, (unint64_t)v8._object, 0LL, v16);
  }

  else
  {
    if (v13)
    {
      swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
      uint64_t v266 = v8._countAndFlagsBits;
      unint64_t v267 = (uint64_t)v8._object & 0xFFFFFFFFFFFFFFLL;
      unint64_t v48 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v8._object >> 56) & 0xF,  (uint64_t)&v266,  ((unint64_t)v8._object >> 56) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v48, v49, ((uint64_t)v8._object & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      unint64_t v1 = v261;
      goto LABEL_52;
    }

    if ((v8._countAndFlagsBits & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v8._object);
      id v63 = (id)(((uint64_t)v8._object & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v64 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      id v63 = _StringObject.sharedUTF8.getter(v8._countAndFlagsBits, (uint64_t)v8._object);
      uint64_t v64 = v252;
      swift_bridgeObjectRelease((uint64_t)v8._object);
      if (v64 < v15) {
        goto LABEL_263;
      }
    }

    uint64_t v65 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL,  (uint64_t)v63,  v64);
    _StringGuts.appendInPlace(_:isASCII:)(v65, v66, v8._countAndFlagsBits < 0);
  }

  swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
  unint64_t v1 = v261;
LABEL_52:
  int64_t v14 = *(void *)(v1 + 16);
  uint64_t v68 = (uint64_t)v264;
  uint64_t v69 = v265;
  ((void (*)(char *, uint64_t, swift *))v14)(v264, v263, v265);
  uint64_t v266 = 0LL;
  unint64_t v267 = 0xE000000000000000LL;
  _debugPrint_unlocked<A, B>(_:_:)( v68,  (uint64_t)&v266,  v69,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  uint64_t v13 = *(void *)(v1 + 8);
  ((void (*)(uint64_t, swift *))v13)(v68, v69);
  uint64_t v3 = v266;
  uint64_t object = v267;
  unint64_t countAndFlagsBits = v268._countAndFlagsBits;
  unint64_t v5 = (unint64_t)v268._object;
  unint64_t v72 = ((unint64_t)v268._object >> 56) & 0xF;
  uint64_t v16 = v268._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  else {
    int64_t v23 = v268._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v23 && (v268._countAndFlagsBits & ~(uint64_t)v268._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v268._object);
    v268._unint64_t countAndFlagsBits = v3;
    v268._uint64_t object = (void *)object;
    goto LABEL_135;
  }

  unint64_t v261 = v13;
  uint64_t v15 = v267 & 0x2000000000000000LL;
  uint64_t v13 = HIBYTE(v267) & 0xF;
  if (((uint64_t)v268._object & 0x2000000000000000LL) != 0 && v15)
  {
    unint64_t v73 = v72 + v13;
    if (v72 + v13 <= 0xF)
    {
      if (v13)
      {
        char v116 = 0;
        unint64_t v117 = 0LL;
        unint64_t v118 = (unint64_t)v268._object;
        do
        {
          unint64_t v119 = v72 + v117;
          unint64_t v120 = v117 + 1;
          if (v117 >= 8) {
            unint64_t v121 = v267;
          }
          else {
            unint64_t v121 = v266;
          }
          unint64_t v122 = v121 >> (v116 & 0x38);
          char v123 = (8 * v72 + v116) & 0x38;
          uint64_t v124 = (-255LL << v123) - 1;
          unint64_t v125 = (unint64_t)v122 << v123;
          unint64_t v126 = v125 | v124 & v118;
          unint64_t v127 = v125 | v124 & countAndFlagsBits;
          if (v119 < 8) {
            unint64_t countAndFlagsBits = v127;
          }
          else {
            unint64_t v118 = v126;
          }
          v116 += 8;
          unint64_t v117 = v120;
        }

        while (v13 != v120);
      }

      else
      {
        unint64_t v118 = (unint64_t)v268._object;
      }

      swift_bridgeObjectRelease((uint64_t)v268._object);
      swift_bridgeObjectRelease(object);
      unint64_t v133 = 0xA000000000000000LL;
      if (!(countAndFlagsBits & 0x8080808080808080LL | v118 & 0x80808080808080LL)) {
        unint64_t v133 = 0xE000000000000000LL;
      }
      v268._unint64_t countAndFlagsBits = countAndFlagsBits;
      v268._uint64_t object = (void *)(v133 & 0xFF00000000000000LL | (v73 << 56) | v118 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_134;
    }

    uint64_t v15 = 1LL;
  }

  int64_t v260 = v14;
  uint64_t v258 = v266 & 0xFFFFFFFFFFFFLL;
  if (v15) {
    int64_t v14 = HIBYTE(v267) & 0xF;
  }
  else {
    int64_t v14 = v266 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v267, 2LL, v70, v71);
  uint64_t v259 = v14;
  if ((object & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(object, 4LL, v19, v20);
    if ((v5 & 0x1000000000000000LL) == 0) {
      goto LABEL_66;
    }
LABEL_165:
    Swift::Int v169 = String.UTF8View._foreignCount()();
    Swift::Int v74 = v169 + v14;
    if (!__OFADD__(v169, v14)) {
      goto LABEL_67;
    }
LABEL_167:
    __break(1u);
    goto LABEL_168;
  }

LABEL_162:
  swift_bridgeObjectRetain_n(object, 5LL, v19, v20);
  v165._Swift::UInt64 rawBits = 1LL;
  v166._Swift::UInt64 rawBits = (v14 << 16) | 1;
  v167._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v165, v166, v3, object);
  if (v167._rawBits < 0x10000) {
    v167._rawBits |= 3;
  }
  int64_t v14 = specialized Collection.count.getter(v167, v168, v3, object);
  swift_bridgeObjectRelease(object);
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_165;
  }
LABEL_66:
  BOOL v22 = __OFADD__(v23, v14);
  Swift::Int v74 = v23 + v14;
  if (v22) {
    goto LABEL_167;
  }
LABEL_67:
  unint64_t v75 = countAndFlagsBits & ~v5;
  if ((v75 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v76 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, v5);
    if ((v77 & 1) != 0) {
      goto LABEL_265;
    }
    if (v74 <= 15)
    {
      if ((v5 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(object, 5LL);
        unint64_t v85 = v5;
        int64_t v14 = v260;
        uint64_t v13 = v261;
LABEL_86:
        v86._Swift::UInt64 rawBits = (v259 << 16) | 1;
        v87._Swift::UInt64 rawBits = 1LL;
        v88._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v87, v86, v3, object);
        if (v88._rawBits < 0x10000) {
          v88._rawBits |= 3;
        }
        uint64_t v90 = specialized String.init(_:)(v88, v89, v3, object);
        uint64_t v92 = v91;
        swift_bridgeObjectRelease(object);
        if ((v92 & 0x2000000000000000LL) == 0) {
          goto LABEL_249;
        }
        swift_bridgeObjectRelease(v92);
        goto LABEL_90;
      }

      if (v76 >= v14) {
        goto LABEL_73;
      }
LABEL_84:
      swift_bridgeObjectRelease_n(object, 5LL);
      uint64_t v13 = v261;
      if ((v5 & 0x2000000000000000LL) != 0)
      {
        unint64_t v85 = v5;
        int64_t v14 = v260;
      }

      else
      {
        int64_t v14 = v260;
        if ((v5 & 0x1000000000000000LL) != 0)
        {
          unint64_t countAndFlagsBits = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, v5);
          unint64_t v85 = v257;
        }

        else
        {
          if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
          {
            uint64_t v250 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            uint64_t v250 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, v5);
            uint64_t v16 = v82;
          }

          swift_bridgeObjectRetain(v5, v82, v83, v84);
          closure #1 in _StringGuts._convertedToSmall()(v250, v16, &v266);
          swift_bridgeObjectRelease(v5);
          unint64_t countAndFlagsBits = v266;
          unint64_t v85 = v267;
        }
      }

      goto LABEL_86;
    }
  }

  else if (v74 <= 15)
  {
    goto LABEL_84;
  }

      uint64_t v129 = v84 - 8;
      uint64_t v130 = 8LL;
      if (v84 < 8) {
        uint64_t v130 = v84;
      }
      if ((v130 & 0x8000000000000000LL) == 0)
      {
        if (v130 >= 8)
        {
          if (v130 >= 0x10)
          {
            size_t v131 = v130 & 0xFFFFFFFFFFFFFFF0LL;
            unint64_t v156 = vmovl_high_u8(*TypeName);
            char v157 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v156.i8);
            unint64_t v158 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            unint64_t v159 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v158.i8);
            Swift::String::Index v160 = (int8x16_t)vmovl_high_u16(v156);
            Swift::String::Index v161 = (int8x8_t)vextq_s8(v160, v160, 8uLL).u64[0];
            Swift::String::Index v162 = (int8x16_t)vmovl_high_u16(v158);
            Swift::String::Index v163 = (int8x8_t)vextq_s8(v162, v162, 8uLL).u64[0];
            *(int8x8_t *)v162.i8 = vorr_s8(*(int8x8_t *)v162.i8, *(int8x8_t *)v160.i8);
            v164.i64[0] = v162.u32[0];
            v164.i64[1] = v162.u32[1];
            Swift::String::Index v165 = (int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1817FFCE0);
            *(int8x8_t *)v160.i8 = vorr_s8(*(int8x8_t *)v159.i8, *(int8x8_t *)v157.i8);
            v164.i64[0] = v160.u32[0];
            v164.i64[1] = v160.u32[1];
            Swift::String::Index v166 = vorrq_s8((int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1817FFCD0), v165);
            *(int8x8_t *)v160.i8 = vorr_s8(v163, v161);
            v164.i64[0] = v160.u32[0];
            v164.i64[1] = v160.u32[1];
            Swift::String::Index v167 = (int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1817FFCC0);
            *(int8x8_t *)v157.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v159, v159, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v157, v157, 8uLL));
            v164.i64[0] = v157.u32[0];
            v164.i64[1] = v157.u32[1];
            Swift::String::Index v168 = vorrq_s8(v166, vorrq_s8((int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1817FFCB0), v167));
            unint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v168.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v168, v168, 8uLL));
            if (v130 == (v130 & 0xFFFFFFFFFFFFFFF0LL)) {
              goto LABEL_179;
            }
            size_t v132 = 8 * v131;
            if ((v130 & 8) == 0) {
              goto LABEL_177;
            }
          }

          else
          {
            unint64_t countAndFlagsBits = 0LL;
            size_t v132 = 0LL;
            size_t v131 = 0LL;
          }

          unint64_t v133 = v131;
          unint64_t v134 = vdupq_n_s64(v132);
          size_t v131 = v130 & 0xFFFFFFFFFFFFFFF8LL;
          size_t v132 = 8 * (v130 & 0xFFFFFFFFFFFFFFF8LL);
          int64_t v135 = 0uLL;
          unint64_t v136 = (int8x16_t)(unint64_t)countAndFlagsBits;
          unint64_t v137 = vaddq_s64(v134, (int64x2_t)xmmword_1817FFCC0);
          char v138 = vaddq_s64(v134, (int64x2_t)xmmword_1817FFCE0);
          uint64_t v139 = vaddq_s64(v134, (int64x2_t)xmmword_1817FFCB0);
          uint64_t v140 = vaddq_s64(v134, (int64x2_t)xmmword_1817FFCD0);
          unint64_t v141 = (uint8x8_t *)&TypeName->i8[v133];
          unint64_t v142 = (int8x16_t)vdupq_n_s64(0x38uLL);
          unint64_t v143 = v133 - (v130 & 0xFFFFFFFFFFFFFFF8LL);
          unint64_t v144 = vdupq_n_s64(0x40uLL);
          Swift::String::Index v145 = 0uLL;
          Swift::String::Index v146 = 0uLL;
          do
          {
            Swift::String::Index v147 = *v141++;
            Swift::String::Index v148 = vmovl_u8(v147);
            unint64_t v149 = vmovl_high_u16(v148);
            v150.i64[0] = v149.u32[2];
            v150.i64[1] = v149.u32[3];
            unint64_t v151 = v150;
            v150.i64[0] = v149.u32[0];
            v150.i64[1] = v149.u32[1];
            unint64_t v152 = v150;
            unint64_t v153 = vmovl_u16(*(uint16x4_t *)v148.i8);
            v150.i64[0] = v153.u32[2];
            v150.i64[1] = v153.u32[3];
            unint64_t v154 = v150;
            v150.i64[0] = v153.u32[0];
            v150.i64[1] = v153.u32[1];
            Swift::String::Index v146 = vorrq_s8((int8x16_t)vshlq_u64(v151, (uint64x2_t)vandq_s8((int8x16_t)v137, v142)), v146);
            Swift::String::Index v145 = vorrq_s8((int8x16_t)vshlq_u64(v152, (uint64x2_t)vandq_s8((int8x16_t)v138, v142)), v145);
            int64_t v135 = vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)vandq_s8((int8x16_t)v139, v142)), v135);
            unint64_t v136 = vorrq_s8((int8x16_t)vshlq_u64(v150, (uint64x2_t)vandq_s8((int8x16_t)v140, v142)), v136);
            char v138 = vaddq_s64(v138, v144);
            uint64_t v139 = vaddq_s64(v139, v144);
            uint64_t v140 = vaddq_s64(v140, v144);
            unint64_t v137 = vaddq_s64(v137, v144);
            v143 += 8LL;
          }

          while (v143);
          unint64_t v155 = vorrq_s8(vorrq_s8(v136, v145), vorrq_s8(v135, v146));
          unint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v155.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v155, v155, 8uLL));
          if (v130 == v131)
          {
LABEL_179:
            if (v84 < 9)
            {
              unint64_t v173 = 0LL;
LABEL_195:
              unint64_t v237 = 0xA000000000000000LL;
              if (((*(void *)&v173 | countAndFlagsBits) & 0x8080808080808080LL) == 0) {
                unint64_t v237 = 0xE000000000000000LL;
              }
              uint64_t v0 = v237 | (v84 << 56) | *(void *)&v173;
              goto LABEL_198;
            }

            if (v129 < 8)
            {
              uint64_t v172 = 0LL;
              unint64_t v173 = 0LL;
              uint64_t v174 = 0LL;
LABEL_193:
              uint64_t v234 = v84 - v172 - 8;
              unint64_t v235 = &TypeName->u8[v172 + 8];
              do
              {
                unint64_t v236 = *v235++;
                *(void *)&v173 |= (unint64_t)v236 << (v174 & 0x38);
                v174 += 8LL;
                --v234;
              }

              while (v234);
              goto LABEL_195;
            }

            if (v129 >= 0x10)
            {
              Swift::String::Index v198 = (uint8x16_t *)&TypeName->u64[1];
              uint64_t v172 = v129 & 0xFFFFFFFFFFFFFFF0LL;
              Swift::String::Index v199 = (int64x2_t)xmmword_1817FFD60;
              Swift::String::Index v200 = (int64x2_t)xmmword_1817FFD70;
              Swift::String::Index v201 = (int64x2_t)xmmword_1817FFD80;
              unint64_t v202 = (int64x2_t)xmmword_1817FFD90;
              unint64_t v203 = (int64x2_t)xmmword_1817FFCC0;
              unint64_t v204 = (int64x2_t)xmmword_1817FFCE0;
              unint64_t v205 = (int8x16_t)vdupq_n_s64(0x38uLL);
              unint64_t v206 = vdupq_n_s64(0x80uLL);
              unint64_t v207 = (int64x2_t)xmmword_1817FFCB0;
              uint64_t v174 = 8 * (v129 & 0xFFFFFFFFFFFFFFF0LL);
              unint64_t v208 = 0uLL;
              uint64_t v209 = 0uLL;
              char v210 = (int64x2_t)xmmword_1817FFCD0;
              uint64_t v211 = v129 & 0xFFFFFFFFFFFFFFF0LL;
              uint64_t v212 = 0uLL;
              uint64_t v213 = 0uLL;
              uint64_t v214 = 0uLL;
              uint64_t v215 = 0uLL;
              __int128 v216 = 0uLL;
              size_t v217 = 0uLL;
              do
              {
                unint64_t v218 = *v198++;
                uint64_t v219 = vmovl_u8(*(uint8x8_t *)v218.i8);
                unint64_t v220 = vmovl_high_u16(v219);
                v221.i64[0] = v220.u32[2];
                v221.i64[1] = v220.u32[3];
                uint64_t v222 = v221;
                uint64_t v223 = vmovl_high_u8(v218);
                unint64_t v224 = vmovl_u16(*(uint16x4_t *)v223.i8);
                v221.i64[0] = v224.u32[2];
                v221.i64[1] = v224.u32[3];
                unint64_t v225 = v221;
                v221.i64[0] = v224.u32[0];
                v221.i64[1] = v224.u32[1];
                char v226 = v221;
                v221.i64[0] = v220.u32[0];
                v221.i64[1] = v220.u32[1];
                unint64_t v227 = v221;
                unint64_t v228 = vmovl_u16(*(uint16x4_t *)v219.i8);
                v221.i64[0] = v228.u32[2];
                v221.i64[1] = v228.u32[3];
                unint64_t v229 = v221;
                unint64_t v230 = vmovl_high_u16(v223);
                v221.i64[0] = v230.u32[0];
                v221.i64[1] = v230.u32[1];
                unint64_t v231 = v221;
                v221.i64[0] = v228.u32[0];
                v221.i64[1] = v228.u32[1];
                unint64_t v232 = v221;
                v221.i64[0] = v230.u32[2];
                v221.i64[1] = v230.u32[3];
                uint64_t v213 = vorrq_s8((int8x16_t)vshlq_u64(v222, (uint64x2_t)vandq_s8((int8x16_t)v203, v205)), v213);
                uint64_t v215 = vorrq_s8((int8x16_t)vshlq_u64(v225, (uint64x2_t)vandq_s8((int8x16_t)v201, v205)), v215);
                uint64_t v214 = vorrq_s8((int8x16_t)vshlq_u64(v226, (uint64x2_t)vandq_s8((int8x16_t)v202, v205)), v214);
                uint64_t v212 = vorrq_s8((int8x16_t)vshlq_u64(v227, (uint64x2_t)vandq_s8((int8x16_t)v204, v205)), v212);
                uint64_t v209 = vorrq_s8((int8x16_t)vshlq_u64(v229, (uint64x2_t)vandq_s8((int8x16_t)v207, v205)), v209);
                __int128 v216 = vorrq_s8((int8x16_t)vshlq_u64(v231, (uint64x2_t)vandq_s8((int8x16_t)v200, v205)), v216);
                unint64_t v208 = vorrq_s8((int8x16_t)vshlq_u64(v232, (uint64x2_t)vandq_s8((int8x16_t)v210, v205)), v208);
                size_t v217 = vorrq_s8((int8x16_t)vshlq_u64(v221, (uint64x2_t)vandq_s8((int8x16_t)v199, v205)), v217);
                unint64_t v204 = vaddq_s64(v204, v206);
                unint64_t v207 = vaddq_s64(v207, v206);
                char v210 = vaddq_s64(v210, v206);
                unint64_t v203 = vaddq_s64(v203, v206);
                unint64_t v202 = vaddq_s64(v202, v206);
                Swift::String::Index v201 = vaddq_s64(v201, v206);
                Swift::String::Index v200 = vaddq_s64(v200, v206);
                Swift::String::Index v199 = vaddq_s64(v199, v206);
                v211 -= 16LL;
              }

              while (v211);
              char v233 = vorrq_s8( vorrq_s8(vorrq_s8(v208, v214), vorrq_s8(v212, v216)),  vorrq_s8(vorrq_s8(v209, v215), vorrq_s8(v213, v217)));
              unint64_t v173 = vorr_s8(*(int8x8_t *)v233.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v233, v233, 8uLL));
              if (v129 == v172) {
                goto LABEL_195;
              }
              if ((v129 & 8) == 0) {
                goto LABEL_193;
              }
            }

            else
            {
              unint64_t v173 = 0LL;
              uint64_t v174 = 0LL;
              uint64_t v172 = 0LL;
            }

            unint64_t v175 = v172;
            uint64_t v172 = v129 & 0xFFFFFFFFFFFFFFF8LL;
            uint64_t v176 = vdupq_n_s64(v174);
            uint64_t v174 = 8 * (v129 & 0xFFFFFFFFFFFFFFF8LL);
            uint64_t v177 = (int8x16_t)(unint64_t)v173;
            unint64_t v178 = 0uLL;
            unint64_t v179 = vaddq_s64(v176, (int64x2_t)xmmword_1817FFCC0);
            uint64_t v180 = vaddq_s64(v176, (int64x2_t)xmmword_1817FFCE0);
            uint64_t v181 = vaddq_s64(v176, (int64x2_t)xmmword_1817FFCB0);
            uint64_t v182 = vaddq_s64(v176, (int64x2_t)xmmword_1817FFCD0);
            unint64_t v183 = (uint8x8_t *)((char *)&TypeName->u64[1] + v175);
            uint64_t v184 = (int8x16_t)vdupq_n_s64(0x38uLL);
            uint64_t v185 = v175 - (v129 & 0xFFFFFFFFFFFFFFF8LL);
            uint64_t v186 = vdupq_n_s64(0x40uLL);
            uint64_t v187 = 0uLL;
            Swift::String::Index v188 = 0uLL;
            do
            {
              int64_t v189 = *v183++;
              char v190 = vmovl_u8(v189);
              uint64_t v191 = vmovl_high_u16(v190);
              v192.i64[0] = v191.u32[2];
              v192.i64[1] = v191.u32[3];
              uint64_t v193 = v192;
              v192.i64[0] = v191.u32[0];
              v192.i64[1] = v191.u32[1];
              unint64_t v194 = v192;
              unint64_t v195 = vmovl_u16(*(uint16x4_t *)v190.i8);
              v192.i64[0] = v195.u32[2];
              v192.i64[1] = v195.u32[3];
              unint64_t v196 = v192;
              v192.i64[0] = v195.u32[0];
              v192.i64[1] = v195.u32[1];
              Swift::String::Index v188 = vorrq_s8((int8x16_t)vshlq_u64(v193, (uint64x2_t)vandq_s8((int8x16_t)v179, v184)), v188);
              uint64_t v187 = vorrq_s8((int8x16_t)vshlq_u64(v194, (uint64x2_t)vandq_s8((int8x16_t)v180, v184)), v187);
              unint64_t v178 = vorrq_s8((int8x16_t)vshlq_u64(v196, (uint64x2_t)vandq_s8((int8x16_t)v181, v184)), v178);
              uint64_t v177 = vorrq_s8((int8x16_t)vshlq_u64(v192, (uint64x2_t)vandq_s8((int8x16_t)v182, v184)), v177);
              uint64_t v180 = vaddq_s64(v180, v186);
              uint64_t v181 = vaddq_s64(v181, v186);
              uint64_t v182 = vaddq_s64(v182, v186);
              unint64_t v179 = vaddq_s64(v179, v186);
              v185 += 8LL;
            }

            while (v185);
            unint64_t v197 = vorrq_s8(vorrq_s8(v177, v187), vorrq_s8(v178, v188));
            unint64_t v173 = vorr_s8(*(int8x8_t *)v197.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v197, v197, 8uLL));
            if (v129 == v172) {
              goto LABEL_195;
            }
            goto LABEL_193;
          }
        }

        else
        {
          size_t v131 = 0LL;
          unint64_t countAndFlagsBits = 0LL;
          size_t v132 = 0LL;
        }

          abort();
        }

        if (v49 < 0)
        {
          char v51 = *(unsigned int *)(a6 + 8);
          if (v51 >= *(unsigned int *)(a6 + 12))
          {
            unint64_t v54 = v47;
            uint64_t v103 = v40;
            __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v47, v51 + 1, 8LL);
            uint64_t v47 = v54;
            unint64_t v40 = v103;
            char v51 = *(unsigned int *)(a6 + 8);
          }

          *(void *)(*(void *)a6 + 8 * v51) = v48;
          ++*(_DWORD *)(a6 + 8);
        }
      }

      if (v37 == ++v45)
      {
        BOOL v22 = v104;
        a4 = v105;
        unint64_t v41 = (const char *)v104[2];
        a8 = v106;
        goto LABEL_91;
      }
    }
  }

  unint64_t v40 = &v39[2 * (v22[5] & 1)];
  if (v22[2]) {
    goto LABEL_72;
  }
LABEL_68:
  unint64_t v41 = 0LL;
LABEL_91:
  v118[0] = &v119;
  v118[1] = a5;
  unint64_t v55 = v22[3];
  v113[0] = off_189B8DBD8;
  v113[1] = v118;
  uint64_t v114 = v113;
  v111[0] = off_189B8DC20;
  v111[1] = v118;
  uint64_t v112 = v111;
  v109[0] = off_189B8DC68;
  v109[1] = v118;
  uint64_t v110 = v109;
  swift::_checkGenericRequirements( v38,  v41,  (unint64_t)&v41[v38 + 3] & 0xFFFFFFFFFFFFFFFCLL,  v55,  a6,  v113,  (uint64_t)v111,  v109,  (uint64_t)&v115);
  unint64_t v56 = v110;
  if (v110 == v109)
  {
    char v58 = 4LL;
    unint64_t v56 = v109;
    unint64_t v57 = v22;
  }

  else
  {
    unint64_t v57 = v22;
    if (!v110) {
      goto LABEL_96;
    }
    char v58 = 5LL;
  }

  (*(void (**)(void))(*v56 + 8 * v58))();
LABEL_96:
  uint64_t v59 = v112;
  if (v112 == v111)
  {
    unint64_t v60 = 4LL;
    uint64_t v59 = v111;
  }

  else
  {
    if (!v112) {
      goto LABEL_101;
    }
    unint64_t v60 = 5LL;
  }

  (*(void (**)(void))(*v59 + 8 * v60))();
LABEL_101:
  unint64_t v61 = v114;
  if (v114 == v113)
  {
    unint64_t v62 = 4LL;
    unint64_t v61 = v113;
  }

  else
  {
    if (!v114) {
      goto LABEL_106;
    }
    unint64_t v62 = 5LL;
  }

  (*(void (**)(void))(*v61 + 8 * v62))();
LABEL_106:
  if (!v117)
  {
    size_t v66 = v57[4];
    unint64_t v67 = *(unsigned int *)(a6 + 8);
    if ((_DWORD)v67 == v66)
    {
      uint64_t v65 = 0;
      goto LABEL_155;
    }

    if (a3 < 0) {
      goto LABEL_162;
    }
    unint64_t v43 = operator new(0x30uLL);
    *unint64_t v43 = a1;
    v43[1] = v108;
    v43[2] = a3;
    v43[3] = a4;
    v43[4] = v22;
    v43[5] = v67;
    uint64_t v44 = swift::TypeLookupError::TypeLookupError<_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_9>(_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_9 const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
    goto LABEL_154;
  }

  id v63 = v115;
  uint64_t v64 = v116;
  *(void *)(a8 + 8) = v116;
  *(void *)a8 = v64(v63, 2LL, 0LL);
  uint64_t v65 = 1;
  *(_BYTE *)(a8 + 16) = 1;
  if (v117) {
    v116(v115, 3LL, 0LL);
  }
LABEL_155:
  if (v119 != (void *)v121) {
    free(v119);
  }
  if (!v65) {
    goto LABEL_158;
  }
}

LABEL_104:
    uint64_t v110 = _StringGuts.nativeCapacity.getter(countAndFlagsBits, v5);
    if ((v111 & 1) != 0) {
      uint64_t v112 = 0LL;
    }
    else {
      uint64_t v112 = v110;
    }
    if (v112 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_258;
    }

    uint64_t v113 = 2 * v112;
    if (v113 > v74) {
      Swift::Int v74 = v113;
    }
    goto LABEL_110;
  }

  int64_t v14 = v260;
  if (!v81) {
    goto LABEL_104;
  }
LABEL_111:
  swift_bridgeObjectRelease_n(object, 4LL);
  if ((object & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(object);
    _StringGuts._foreignAppendInPlace(_:)(v3, object, 0LL, v259);
    swift_bridgeObjectRelease_n(object, 2LL);
    goto LABEL_134;
  }

  if (!v15)
  {
    if ((v3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(object);
      id v128 = (id)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v129 = v258;
      uint64_t v130 = v258;
      uint64_t v13 = v261;
      goto LABEL_128;
    }

                        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
                      }

                      uint64_t v65 = (void (*)(char *, const char *, swift *))v268;
                      if (v217 >= 64) {
                        goto LABEL_92;
                      }
                    }

                    char v226 = v285;
                    ((void (*)(char *, char *, uint64_t))v287)(v285, v205, v78);
                    unint64_t v227 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                    ((void (*)(char *, uint64_t))v288)(v226, v78);
                    if (v227 < v291) {
                      goto LABEL_112;
                    }
                    goto LABEL_92;
                  }
                }

                else
                {
                  uint64_t v181 = v77((unint64_t *)v78, v68);
                  Swift::String::Index v167 = v256(v78, v68);
                  size_t v66 = v254;
                  if ((v181 & 1) == 0)
                  {
                    uint64_t v193 = *(void (**)(char *, char *, uint64_t))(v84 + 16);
                    if (v167 >= 64)
                    {
                      Swift::String::Index v201 = v259;
                      Swift::String::Index v166 = v287;
                      v193(v259, v287, v78);
                      ((void (*)(char *, uint64_t))v288)(v201, v78);
                      goto LABEL_74;
                    }

                    Swift::String::Index v166 = v287;
                    v193(v83, v287, v78);
                    goto LABEL_69;
                  }

                  if (v167 <= 64)
                  {
                    unint64_t v195 = v266;
                    unint64_t v196 = v265;
                    unint64_t v197 = swift_getAssociatedConformanceWitness( (uint64_t)v266,  v78,  v265,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    Swift::String::Index v198 = v264;
                    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v197 + 8))( &qword_18180BE68,  256LL,  v196,  v197);
                    Swift::String::Index v199 = v198;
                    uint64_t v84 = v284;
                    (*((void (**)(char *, uint64_t, const char *))v195 + 3))(v199, v78, v195);
                    Swift::String::Index v166 = v287;
                    LOBYTE(v196) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                                  + 8LL)
                                                                                      + 16LL))( v287,  v83,  v78);
                    ((void (*)(char *, uint64_t))v288)(v83, v78);
                    Swift::String::Index v200 = v260;
                    (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v260, v166, v78);
                    if ((v196 & 1) != 0)
                    {
                      ((void (*)(char *, uint64_t))v288)(v200, v78);
                    }

                    else
                    {
                      unint64_t v224 = v291;
                      unint64_t v225 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                      ((void (*)(char *, uint64_t))v288)(v200, v78);
                      Swift::String::Index v165 = v225 < v224;
                      Swift::String::Index v166 = v287;
                      if (!v165) {
                        goto LABEL_74;
                      }
                    }

          char v79 = _StringGuts.nativeCapacity.getter(v73, v9);
          if ((v80 & 1) != 0) {
            BOOL v81 = 0LL;
          }
          else {
            BOOL v81 = v79;
          }
          if (v81 + 0x4000000000000000LL >= 0)
          {
            uint64_t v82 = 2 * v81;
            if (v82 > v1) {
              unint64_t v1 = v82;
            }
            goto LABEL_110;
          }

          __break(1u);
LABEL_201:
          if ((v45 & 0x1000000000000000LL) != 0)
          {
            unint64_t v43 = _StringGuts._foreignConvertedToSmall()(v43, v45);
            uint64_t v182 = v181;
            swift_bridgeObjectRelease(v45);
            char v45 = v182;
          }

          else
          {
            if ((v43 & 0x1000000000000000LL) != 0)
            {
              unint64_t v173 = (unsigned __int8 *)((v45 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v174 = v43 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              unint64_t v173 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v43, v45);
            }

            closure #1 in _StringGuts._convertedToSmall()(v173, v174, v186);
            swift_bridgeObjectRelease(v45);
            char v45 = *((void *)&v186[0] + 1);
            unint64_t v43 = *(void *)&v186[0];
          }

            if ((unint64_t)v78 < v16 + (a1 & 0xFFFFFFFFFFFFFFFELL))
            {
              if ((*(_WORD *)v78 & 0x8080) != 0) {
                goto LABEL_144;
              }
              int64_t v78 = (uint64_t *)((char *)v78 + 2);
            }

            if ((unint64_t)v78 >= v16 + a1 || (*(char *)v78 & 0x80000000) == 0)
            {
              if (a1 > 15)
              {
                uint64_t v80 = 1;
LABEL_111:
                a1 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)v16,  a1,  a1,  v80 & 1);
                unint64_t v9 = 0LL;
                uint64_t v12 = *(void *)(a1 + 24);
                goto LABEL_91;
              }

  uint64_t v314 = a4;
  if (v72 == v74)
  {
LABEL_486:
    uint64_t v253 = *(_DWORD *)(v5 + 12736);
    unint64_t v254 = *(unsigned int *)(v5 + 12740);
    uint64_t v255 = *(_BYTE **)(v5 + 12728);
    if (v253 < v254)
    {
LABEL_505:
      LODWORD(v14) = 0;
      unint64_t v4 = 0LL;
      unint64_t v48 = 0;
      *(_DWORD *)(v5 + 12736) = v253 + 1;
      v255[v253] = 95;
      goto LABEL_506;
    }

    uint64_t v256 = *(void **)(v5 + 12744);
    unint64_t v257 = (_BYTE *)v256[1];
    if (&v255[v254] == v257)
    {
      uint64_t v259 = (unint64_t)&v255[v254 + 1];
      uint64_t v258 = v256[2];
      if (v259 <= v258)
      {
        v256[1] = v259;
        LODWORD(v26swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = 1;
LABEL_504:
        *(_DWORD *)(v5 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v254 + v260;
        goto LABEL_505;
      }
    }

    else
    {
      uint64_t v258 = v256[2];
    }

    else {
      int64_t v260 = (2 * v254);
    }
    unint64_t v261 = v260 + v254;
    if (v257) {
      uint64_t v262 = (unint64_t)&v257[v260 + v254] > v258;
    }
    else {
      uint64_t v262 = 1;
    }
    uint64_t v255 = (_BYTE *)v256[1];
    if (v262)
    {
      uint64_t v263 = 2LL * v256[4];
      if (v263 <= v261 + 1) {
        uint64_t v263 = v261 + 1;
      }
      v256[4] = v263;
      char v264 = v263 + 8;
      this = (uint64_t *)malloc(v263 + 8);
      uint64_t v265 = (char *)this + v264;
      *this = v256[3];
      uint64_t v255 = this + 1;
      v256[2] = v265;
      v256[3] = this;
    }

    v256[1] = &v255[v261];
    if ((_DWORD)v254)
    {
      this = (uint64_t *)memcpy(v255, *(const void **)(v5 + 12728), v254);
      LODWORD(v254) = *(_DWORD *)(v5 + 12740);
      uint64_t v253 = *(_DWORD *)(v5 + 12736);
    }

    a4 = v314;
    void *v316 = v255;
    goto LABEL_504;
  }

  char v310 = v74;
  while (2)
  {
    unint64_t v4 = *v72;
    switch(*((_WORD *)*v72 + 8))
    {
      case 'i':
        char v77 = *(_DWORD *)(v5 + 12736);
        int64_t v78 = *(unsigned int *)(v5 + 12740);
        unint64_t v75 = *(char **)(v5 + 12728);
        if (v77 < v78)
        {
          char v79 = 101;
          goto LABEL_109;
        }

        unint64_t v106 = *(void **)(v5 + 12744);
        uint64_t v107 = (char *)v106[1];
        if (&v75[v78] == v107)
        {
          unint64_t v202 = (unint64_t)&v75[v78 + 1];
          uint64_t v108 = v106[2];
          if (v202 <= v108)
          {
            v106[1] = v202;
            LODWORD(v203) = 1;
            goto LABEL_355;
          }
        }

        else
        {
          uint64_t v108 = v106[2];
        }

        else {
          unint64_t v203 = (2 * v78);
        }
        unint64_t v204 = v203 + v78;
        if (v107) {
          unint64_t v205 = (unint64_t)&v107[v203 + v78] > v108;
        }
        else {
          unint64_t v205 = 1;
        }
        unint64_t v75 = (char *)v106[1];
        if (v205)
        {
          unint64_t v206 = 2LL * v106[4];
          if (v206 <= v204 + 1) {
            unint64_t v206 = v204 + 1;
          }
          v106[4] = v206;
          unint64_t v207 = v206 + 8;
          this = (uint64_t *)malloc(v206 + 8);
          unint64_t v208 = (char *)this + v207;
          *this = v106[3];
          unint64_t v75 = (char *)(this + 1);
          v106[2] = v208;
          v106[3] = this;
        }

        v106[1] = &v75[v204];
        if ((_DWORD)v78)
        {
          this = (uint64_t *)memcpy(v75, *(const void **)(v5 + 12728), v78);
          LODWORD(v78) = *(_DWORD *)(v5 + 12740);
          char v77 = *(_DWORD *)(v5 + 12736);
        }

        a4 = v314;
        void *v316 = v75;
LABEL_355:
        int64_t v76 = v78 + v203;
        char v79 = 101;
        goto LABEL_108;
      case 'j':
        unint64_t v48 = 2059;
        LODWORD(v14) = 15;
        uint64_t v80 = *(swift::Demangle::__runtime::Node ***)v4;
        switch(*((void *)v4 + 1))
        {
          case 0xDLL:
            if (*v80 != (swift::Demangle::__runtime::Node *)0x5F65656C6C616340LL
              || *(swift::Demangle::__runtime::Node **)((char *)v80 + 5) != (swift::Demangle::__runtime::Node *)0x64656E776F5F6565LL)
            {
              goto LABEL_576;
            }

            char v79 = 120;
            goto LABEL_190;
          case 0xFLL:
            if (*v80 != (swift::Demangle::__runtime::Node *)0x5F65656C6C616340LL
              || *(swift::Demangle::__runtime::Node **)((char *)v80 + 7) != (swift::Demangle::__runtime::Node *)0x64656E776F6E755FLL)
            {
              goto LABEL_576;
            }

            char v79 = 121;
            goto LABEL_190;
          case 0x11LL:
            unint64_t v122 = *v80;
            char v123 = v80[1];
            uint64_t v124 = *((unsigned __int8 *)v80 + 16);
            if (v122 != (swift::Demangle::__runtime::Node *)0x746E65766E6F6340LL
              || v123 != (swift::Demangle::__runtime::Node *)0x6E696874286E6F69LL
              || v124 != 41)
            {
              goto LABEL_576;
            }

            char v79 = 116;
            goto LABEL_190;
          case 0x12LL:
            unint64_t v127 = *v80;
            id v128 = v80[1];
            uint64_t v129 = *((unsigned __int16 *)v80 + 8);
            if (v127 != (swift::Demangle::__runtime::Node *)0x5F65656C6C616340LL
              || v128 != (swift::Demangle::__runtime::Node *)0x65746E6172617567LL
              || v129 != 25701)
            {
LABEL_576:
              unint64_t v48 = 2059;
              LODWORD(v14) = 15;
              goto LABEL_506;
            }

            char v79 = 103;
LABEL_190:
            char v77 = *(_DWORD *)(v5 + 12736);
            uint64_t v82 = *(unsigned int *)(v5 + 12740);
            unint64_t v75 = *(char **)(v5 + 12728);
            size_t v132 = *(void **)(v5 + 12744);
            unint64_t v133 = (char *)v132[1];
            if (&v75[v82] == v133)
            {
              uint64_t v223 = (unint64_t)&v75[v82 + 1];
              unint64_t v134 = v132[2];
              if (v223 <= v134)
              {
                v132[1] = v223;
                LODWORD(v136) = 1;
                Swift::Int v74 = v310;
                goto LABEL_107;
              }
            }

            else
            {
              unint64_t v134 = v132[2];
            }

            else {
              unint64_t v136 = (2 * v82);
            }
            unint64_t v224 = v136 + v82;
            if (!v133 || (unint64_t)&v133[v224] > v134)
            {
              unint64_t v225 = 2LL * v132[4];
              if (v225 <= v224 + 1) {
                unint64_t v225 = v224 + 1;
              }
              v132[4] = v225;
              char v226 = v225 + 8;
              this = (uint64_t *)malloc(v225 + 8);
              *this = v132[3];
              unint64_t v133 = (char *)(this + 1);
              v132[2] = (char *)this + v226;
              v132[3] = this;
            }

            v132[1] = &v133[v224];
            if ((_DWORD)v82)
            {
              this = (uint64_t *)memcpy(v133, *(const void **)(v5 + 12728), v82);
              LODWORD(v82) = *(_DWORD *)(v5 + 12740);
              char v77 = *(_DWORD *)(v5 + 12736);
            }

            Swift::Int v74 = v310;
            a4 = v314;
            void *v316 = v133;
            unint64_t v75 = v133;
LABEL_107:
            int64_t v76 = v82 + v136;
LABEL_108:
            *(_DWORD *)(v5 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v76;
LABEL_109:
            *(_DWORD *)(v5 + 12736) = v77 + 1;
            v75[v77] = v79;
            break;
          default:
            goto LABEL_506;
        }

        goto LABEL_110;
      case 'k':
        char v79 = *(_BYTE *)v4;
        char v77 = *(_DWORD *)(v5 + 12736);
        uint64_t v82 = *(unsigned int *)(v5 + 12740);
        unint64_t v75 = *(char **)(v5 + 12728);
        uint64_t v83 = *(void **)(v5 + 12744);
        uint64_t v84 = (char *)v83[1];
        if (&v75[v82] == v84)
        {
          int64_t v135 = (unint64_t)&v75[v82 + 1];
          unint64_t v85 = v83[2];
          if (v135 <= v85)
          {
            v83[1] = v135;
            LODWORD(v136) = 1;
            goto LABEL_107;
          }
        }

        else
        {
          unint64_t v85 = v83[2];
        }

        else {
          unint64_t v136 = (2 * v82);
        }
        unint64_t v137 = v136 + v82;
        if (v84) {
          char v138 = (unint64_t)&v84[v136 + v82] > v85;
        }
        else {
          char v138 = 1;
        }
        unint64_t v75 = (char *)v83[1];
        if (v138)
        {
          uint64_t v139 = 2LL * v83[4];
          if (v139 <= v137 + 1) {
            uint64_t v139 = v137 + 1;
          }
          v83[4] = v139;
          uint64_t v140 = v139 + 8;
          this = (uint64_t *)malloc(v139 + 8);
          unint64_t v141 = (char *)this + v140;
          *this = v83[3];
          unint64_t v75 = (char *)(this + 1);
          v83[2] = v141;
          v83[3] = this;
        }

        v83[1] = &v75[v137];
        if ((_DWORD)v82)
        {
          this = (uint64_t *)memcpy(v75, *(const void **)(v5 + 12728), v82);
          LODWORD(v82) = *(_DWORD *)(v5 + 12740);
          char v77 = *(_DWORD *)(v5 + 12736);
        }

        a4 = v314;
        void *v316 = v75;
        goto LABEL_107;
      case 'l':
        char v77 = *(_DWORD *)(v5 + 12736);
        Swift::String::Index v86 = *(unsigned int *)(v5 + 12740);
        unint64_t v75 = *(char **)(v5 + 12728);
        if (v77 < v86)
        {
          char v79 = 65;
          goto LABEL_109;
        }

        unint64_t v109 = *(void **)(v5 + 12744);
        uint64_t v110 = (char *)v109[1];
        if (&v75[v86] == v110)
        {
          uint64_t v209 = (unint64_t)&v75[v86 + 1];
          char v111 = v109[2];
          if (v209 <= v111)
          {
            v109[1] = v209;
            LODWORD(v21swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = 1;
            goto LABEL_371;
          }
        }

        else
        {
          char v111 = v109[2];
        }

        else {
          char v210 = (2 * v86);
        }
        uint64_t v211 = v210 + v86;
        if (v110) {
          uint64_t v212 = (unint64_t)&v110[v210 + v86] > v111;
        }
        else {
          uint64_t v212 = 1;
        }
        unint64_t v75 = (char *)v109[1];
        if (v212)
        {
          uint64_t v213 = 2LL * v109[4];
          if (v213 <= v211 + 1) {
            uint64_t v213 = v211 + 1;
          }
          v109[4] = v213;
          uint64_t v214 = v213 + 8;
          this = (uint64_t *)malloc(v213 + 8);
          uint64_t v215 = (char *)this + v214;
          *this = v109[3];
          unint64_t v75 = (char *)(this + 1);
          v109[2] = v215;
          v109[3] = this;
        }

        v109[1] = &v75[v211];
        if ((_DWORD)v86)
        {
          this = (uint64_t *)memcpy(v75, *(const void **)(v5 + 12728), v86);
          LODWORD(v86) = *(_DWORD *)(v5 + 12740);
          char v77 = *(_DWORD *)(v5 + 12736);
        }

        a4 = v314;
        void *v316 = v75;
LABEL_371:
        int64_t v76 = v86 + v210;
        char v79 = 65;
        goto LABEL_108;
      case 'm':
        char v77 = *(_DWORD *)(v5 + 12736);
        Swift::String::Index v87 = *(unsigned int *)(v5 + 12740);
        unint64_t v75 = *(char **)(v5 + 12728);
        if (v77 < v87)
        {
          char v79 = 84;
          goto LABEL_109;
        }

        uint64_t v112 = *(void **)(v5 + 12744);
        uint64_t v113 = (char *)v112[1];
        if (&v75[v87] == v113)
        {
          __int128 v216 = (unint64_t)&v75[v87 + 1];
          uint64_t v114 = v112[2];
          if (v216 <= v114)
          {
            v112[1] = v216;
            LODWORD(v217) = 1;
            goto LABEL_387;
          }
        }

        else
        {
          uint64_t v114 = v112[2];
        }

        else {
          size_t v217 = (2 * v87);
        }
        unint64_t v218 = v217 + v87;
        if (v113) {
          uint64_t v219 = (unint64_t)&v113[v217 + v87] > v114;
        }
        else {
          uint64_t v219 = 1;
        }
        unint64_t v75 = (char *)v112[1];
        if (v219)
        {
          unint64_t v220 = 2LL * v112[4];
          if (v220 <= v218 + 1) {
            unint64_t v220 = v218 + 1;
          }
          v112[4] = v220;
          unint64_t v221 = v220 + 8;
          this = (uint64_t *)malloc(v220 + 8);
          uint64_t v222 = (char *)this + v221;
          *this = v112[3];
          unint64_t v75 = (char *)(this + 1);
          v112[2] = v222;
          v112[3] = this;
        }

        v112[1] = &v75[v218];
        if ((_DWORD)v87)
        {
          this = (uint64_t *)memcpy(v75, *(const void **)(v5 + 12728), v87);
          LODWORD(v87) = *(_DWORD *)(v5 + 12740);
          char v77 = *(_DWORD *)(v5 + 12736);
        }

        a4 = v314;
        void *v316 = v75;
LABEL_387:
        int64_t v76 = v87 + v217;
        char v79 = 84;
        goto LABEL_108;
      case 'p':
        Swift::String::Index v88 = *(swift::Demangle::__runtime::Node ***)v4;
        Swift::String::Index v89 = *((void *)v4 + 1);
        switch(v89)
        {
          case 6LL:
            size_t v115 = *(_DWORD *)v88;
            char v116 = *((unsigned __int16 *)v88 + 2);
            if (v115 != 2037604672 || v116 != 25454)
            {
LABEL_573:
              unint64_t v48 = 2076;
              LODWORD(v14) = 17;
              goto LABEL_506;
            }

            char v79 = 72;
            break;
          case 9LL:
            unint64_t v118 = *v88;
            unint64_t v119 = *((unsigned __int8 *)v88 + 8);
            if (v118 != (swift::Demangle::__runtime::Node *)0x6C6261646E655340LL || v119 != 101) {
              goto LABEL_573;
            }
            char v79 = 104;
            break;
          case 11LL:
            if (*v88 == (swift::Demangle::__runtime::Node *)0x6F5F646C65697940LL
              && *(swift::Demangle::__runtime::Node **)((char *)v88 + 3) == (swift::Demangle::__runtime::Node *)0x65636E6F5F646C65LL)
            {
              char v79 = 65;
            }

            else
            {
              uint64_t v91 = *v88;
              uint64_t v92 = *(uint64_t *)((char *)v88 + 3);
              if (v91 != (swift::Demangle::__runtime::Node *)0x6D5F646C65697940LL || v92 != 0x796E616D5F646C65LL) {
                goto LABEL_573;
              }
              char v79 = 71;
            }

            break;
          default:
            goto LABEL_573;
        }

        char v77 = *(_DWORD *)(v5 + 12736);
        unint64_t v227 = *(unsigned int *)(v5 + 12740);
        unint64_t v75 = *(char **)(v5 + 12728);
        unint64_t v228 = *(void **)(v5 + 12744);
        unint64_t v229 = (char *)v228[1];
        if (&v75[v227] == v229)
        {
          unint64_t v231 = (unint64_t)&v75[v227 + 1];
          unint64_t v230 = v228[2];
          if (v231 <= v230)
          {
            v228[1] = v231;
            LODWORD(v232) = 1;
            Swift::Int v74 = v310;
            goto LABEL_416;
          }
        }

        else
        {
          unint64_t v230 = v228[2];
        }

        else {
          unint64_t v232 = (2 * v227);
        }
        char v233 = v232 + v227;
        if (!v229 || (unint64_t)&v229[v233] > v230)
        {
          uint64_t v234 = 2LL * v228[4];
          if (v234 <= v233 + 1) {
            uint64_t v234 = v233 + 1;
          }
          v228[4] = v234;
          unint64_t v235 = v234 + 8;
          this = (uint64_t *)malloc(v234 + 8);
          *this = v228[3];
          unint64_t v229 = (char *)(this + 1);
          v228[2] = (char *)this + v235;
          v228[3] = this;
        }

        v228[1] = &v229[v233];
        if ((_DWORD)v227)
        {
          this = (uint64_t *)memcpy(v229, *(const void **)(v5 + 12728), v227);
          LODWORD(v227) = *(_DWORD *)(v5 + 12740);
          char v77 = *(_DWORD *)(v5 + 12736);
        }

        Swift::Int v74 = v310;
        a4 = v314;
        void *v316 = v229;
        unint64_t v75 = v229;
LABEL_416:
        int64_t v76 = v227 + v232;
        goto LABEL_108;
      case 'q':
        goto LABEL_483;
      case 'v':
        goto LABEL_225;
      case 'x':
        goto LABEL_290;
      case 'y':
        uint64_t v94 = *(_DWORD *)(v5 + 12736);
        uint64_t v95 = *(unsigned int *)(v5 + 12740);
        char v96 = *(char **)(v5 + 12728);
        unint64_t v97 = *(void **)(v5 + 12744);
        unint64_t v98 = (char *)v97[1];
        if (&v96[v95] == v98)
        {
          unint64_t v142 = (unint64_t)&v96[v95 + 1];
          unint64_t v99 = v97[2];
          if (v142 <= v99)
          {
            v97[1] = v142;
            LODWORD(v143) = 1;
            goto LABEL_223;
          }
        }

        else
        {
          unint64_t v99 = v97[2];
        }

        else {
          unint64_t v143 = (2 * v95);
        }
        unint64_t v144 = v143 + v95;
        if (v98) {
          Swift::String::Index v145 = (unint64_t)&v98[v143 + v95] > v99;
        }
        else {
          Swift::String::Index v145 = 1;
        }
        char v96 = (char *)v97[1];
        if (v145)
        {
          Swift::String::Index v146 = 2LL * v97[4];
          if (v146 <= v144 + 1) {
            Swift::String::Index v146 = v144 + 1;
          }
          v97[4] = v146;
          Swift::String::Index v147 = v146 + 8;
          Swift::String::Index v148 = malloc(v146 + 8);
          unint64_t v149 = (char *)v148 + v147;
          *Swift::String::Index v148 = v97[3];
          char v96 = (char *)(v148 + 1);
          v97[2] = v149;
          v97[3] = v148;
        }

        v97[1] = &v96[v144];
        if ((_DWORD)v95)
        {
          memcpy(v96, *(const void **)(v5 + 12728), v95);
          LODWORD(v95) = *(_DWORD *)(v5 + 12740);
          uint64_t v94 = *(_DWORD *)(v5 + 12736);
        }

        a4 = v314;
        void *v316 = v96;
LABEL_223:
        *(_DWORD *)(v5 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v95 + v143;
LABEL_224:
        *(_DWORD *)(v5 + 12736) = v94 + 1;
        v96[v94] = 89;
LABEL_225:
        unint64_t v150 = *((unsigned __int8 *)v4 + 18);
        unint64_t v151 = (swift::Demangle::__runtime::Node **)v4;
        break;
      case 'z':
        unint64_t v100 = *(_DWORD *)(v5 + 12736);
        unint64_t v101 = *(unsigned int *)(v5 + 12740);
        char v102 = *(char **)(v5 + 12728);
        uint64_t v103 = *(void **)(v5 + 12744);
        unint64_t v104 = (char *)v103[1];
        if (&v102[v101] == v104)
        {
          Swift::Int v164 = (unint64_t)&v102[v101 + 1];
          unint64_t v105 = v103[2];
          if (v164 <= v105)
          {
            v103[1] = v164;
            LODWORD(v165) = 1;
            goto LABEL_288;
          }
        }

        else
        {
          unint64_t v105 = v103[2];
        }

        else {
          Swift::String::Index v165 = (2 * v101);
        }
        Swift::String::Index v166 = v165 + v101;
        if (v104) {
          Swift::String::Index v167 = (unint64_t)&v104[v165 + v101] > v105;
        }
        else {
          Swift::String::Index v167 = 1;
        }
        char v102 = (char *)v103[1];
        if (v167)
        {
          Swift::String::Index v168 = 2LL * v103[4];
          if (v168 <= v166 + 1) {
            Swift::String::Index v168 = v166 + 1;
          }
          v103[4] = v168;
          Swift::Int v169 = v168 + 8;
          this = (uint64_t *)malloc(v168 + 8);
          unint64_t v170 = (char *)this + v169;
          *this = v103[3];
          char v102 = (char *)(this + 1);
          v103[2] = v170;
          v103[3] = this;
        }

        v103[1] = &v102[v166];
        if ((_DWORD)v101)
        {
          this = (uint64_t *)memcpy(v102, *(const void **)(v5 + 12728), v101);
          LODWORD(v101) = *(_DWORD *)(v5 + 12740);
          unint64_t v100 = *(_DWORD *)(v5 + 12736);
        }

        a4 = v314;
        void *v316 = v102;
LABEL_288:
        *(_DWORD *)(v5 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v101 + v165;
LABEL_289:
        *(_DWORD *)(v5 + 12736) = v100 + 1;
        v102[v100] = 122;
LABEL_290:
        size_t v171 = *((unsigned __int8 *)v4 + 18);
        uint64_t v172 = (swift::Demangle::__runtime::Node **)v4;
        unint64_t v173 = *v172;
        uint64_t v174 = *((void *)v173 + 1) - 4LL;
        unint64_t v175 = *(int **)v173;
        switch(v174)
        {
          case 0LL:
            if (*v175 != 1953853248) {
              goto LABEL_508;
            }
            unint64_t v152 = 114;
            goto LABEL_324;
          case 2LL:
            uint64_t v176 = *v175;
            uint64_t v177 = *((unsigned __int16 *)v175 + 2);
            if (v176 != 1853321024 || v177 != 25701) {
              goto LABEL_508;
            }
            unint64_t v152 = 111;
            goto LABEL_324;
          case 4LL:
            if (*(void *)v175 != 0x64656E776F6E7540LL) {
              goto LABEL_508;
            }
            unint64_t v152 = 100;
            goto LABEL_324;
          case 5LL:
            unint64_t v179 = *(void *)v175;
            uint64_t v180 = *((unsigned __int8 *)v175 + 8);
            if (v179 != 0x756F5F6B63617040LL || v180 != 116) {
              goto LABEL_508;
            }
            unint64_t v152 = 107;
            goto LABEL_324;
          case 9LL:
            uint64_t v182 = *(void *)v175;
            unint64_t v183 = *(void *)((char *)v175 + 5);
            if (v182 != 0x6C65726F74756140LL || v183 != 0x64657361656C6572LL) {
              goto LABEL_508;
            }
            unint64_t v152 = 97;
            goto LABEL_324;
          case 18LL:
            uint64_t v185 = *(void *)v175;
            uint64_t v186 = *((void *)v175 + 1);
            uint64_t v187 = *(void *)((char *)v175 + 14);
            if (v185 != 0x64656E776F6E7540LL || v186 != 0x705F72656E6E695FLL || v187 != 0x7265746E696F705FLL) {
              goto LABEL_508;
            }
            unint64_t v152 = 117;
LABEL_324:
            char v190 = *(_DWORD *)(v5 + 12736);
            uint64_t v191 = *(unsigned int *)(v5 + 12740);
            uint64_t v192 = *(char **)(v5 + 12728);
            uint64_t v193 = *(void **)(v5 + 12744);
            unint64_t v194 = (char *)v193[1];
            if (&v192[v191] == v194)
            {
              unint64_t v196 = (unint64_t)&v192[v191 + 1];
              unint64_t v195 = v193[2];
              if (v196 <= v195)
              {
                v193[1] = v196;
                LODWORD(v197) = 1;
                Swift::Int v74 = v310;
                goto LABEL_339;
              }
            }

            else
            {
              unint64_t v195 = v193[2];
            }

            else {
              unint64_t v197 = (2 * v191);
            }
            Swift::String::Index v198 = v197 + v191;
            if (!v194 || (unint64_t)&v194[v198] > v195)
            {
              Swift::String::Index v199 = 2LL * v193[4];
              if (v199 <= v198 + 1) {
                Swift::String::Index v199 = v198 + 1;
              }
              v193[4] = v199;
              Swift::String::Index v200 = v199 + 8;
              this = (uint64_t *)malloc(v199 + 8);
              Swift::String::Index v201 = (char *)this + v200;
              *this = v193[3];
              unint64_t v194 = (char *)(this + 1);
              v193[2] = v201;
              v193[3] = this;
            }

            v193[1] = &v194[v198];
            if ((_DWORD)v191)
            {
              this = (uint64_t *)memcpy(v194, *(const void **)(v5 + 12728), v191);
              LODWORD(v191) = *(_DWORD *)(v5 + 12740);
              char v190 = *(_DWORD *)(v5 + 12736);
            }

            Swift::Int v74 = v310;
            a4 = v314;
            void *v316 = v194;
            uint64_t v192 = v194;
LABEL_339:
            *(_DWORD *)(v5 + 1274swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v191 + v197;
            break;
          default:
LABEL_508:
            if (v171 == 5 && *((_DWORD *)v4 + 2))
            {
              unint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
LABEL_512:
              unint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
            }

            else
            {
              unint64_t v4 = 0LL;
            }

            unint64_t v48 = 2132;
            LODWORD(v14) = 18;
            goto LABEL_506;
        }

        goto LABEL_473;
      default:
        goto LABEL_110;
    }

    unint64_t v152 = 0;
    unint64_t v153 = *v151;
    this = *(uint64_t **)v153;
    unint64_t v154 = *((void *)v153 + 1);
    unint64_t v155 = 1;
    switch(v154)
    {
      case 3uLL:
        if (*(_WORD *)this != 26944 || *((_BYTE *)this + 2) != 110) {
          goto LABEL_514;
        }
        unint64_t v155 = 0;
        unint64_t v152 = 105;
        goto LABEL_420;
      case 6uLL:
        if (*(_DWORD *)this == 1869506880 && *((_WORD *)this + 2) == 29813)
        {
          unint64_t v155 = 0;
          unint64_t v152 = 108;
        }

        else
        {
          if (*(_DWORD *)this == 1853321024 && *((_WORD *)this + 2) == 25701)
          {
            unint64_t v152 = 120;
            goto LABEL_457;
          }

LABEL_258:
    id v128 = _StringObject.sharedUTF8.getter(v3, object);
    uint64_t v130 = v251;
    swift_bridgeObjectRelease(object);
    if (v130 < v258) {
      goto LABEL_263;
    }
    int64_t v14 = v260;
    uint64_t v13 = v261;
    uint64_t v129 = v258;
LABEL_128:
    size_t v131 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v129, (uint64_t)v128, v130);
    _StringGuts.appendInPlace(_:isASCII:)(v131, v132, v3 < 0);
    swift_bridgeObjectRelease_n(object, 2LL);
    goto LABEL_135;
  }

  swift_bridgeObjectRelease_n(object, 2LL);
  uint64_t v266 = v3;
  unint64_t v267 = object & 0xFFFFFFFFFFFFFFLL;
  uint64_t v114 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v13, (uint64_t)&v266, v13);
  _StringGuts.appendInPlace(_:isASCII:)(v114, v115, (object & 0x4000000000000000LL) != 0);
  swift_bridgeObjectRelease(object);
LABEL_134:
  uint64_t v13 = v261;
  while (1)
  {
LABEL_135:
    unint64_t countAndFlagsBits = v268._countAndFlagsBits;
    unint64_t v5 = (unint64_t)v268._object;
    unint64_t v134 = ((unint64_t)v268._object >> 56) & 0xF;
    int64_t v135 = v268._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    else {
      unint64_t v136 = v268._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v136 && (v268._countAndFlagsBits & ~(uint64_t)v268._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v268._object);
      unint64_t countAndFlagsBits = 0LL;
      v268._unint64_t countAndFlagsBits = 0LL;
      unint64_t v158 = 0xE000000000000000LL;
      goto LABEL_171;
    }

    if (((uint64_t)v268._object & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v268._object);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v159 = 0xA000000000000000LL;
      if (!(v5 & 0x80808080808080LL | countAndFlagsBits & 0x8080808080808080LL)) {
        unint64_t v159 = 0xE000000000000000LL;
      }
      unint64_t v158 = v159 & 0xFF00000000000000LL | (v134 << 56) | v5 & 0xFFFFFFFFFFFFFFLL;
LABEL_154:
      v268._unint64_t countAndFlagsBits = countAndFlagsBits;
      goto LABEL_171;
    }

    swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v107, v108);
    if ((v5 & 0x1000000000000000LL) != 0)
    {
LABEL_168:
      int64_t v135 = String.UTF8View._foreignCount()();
      if ((countAndFlagsBits & ~v5 & 0x2000000000000000LL) == 0) {
        goto LABEL_169;
      }
    }

    else if ((countAndFlagsBits & ~v5 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_169;
    }

    if (swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v137 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, v5);
      if ((v138 & 1) != 0) {
        goto LABEL_265;
      }
      if (v135 <= 15 && (v137 & 0x8000000000000000LL) != 0)
      {
LABEL_147:
        swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
        swift_bridgeObjectRetain(v5, v139, v140, v141);
        unint64_t v142 = _StringGuts._convertedToSmall()(countAndFlagsBits, v5);
        unint64_t v144 = v143;
        swift_bridgeObjectRelease(v5);
        v145._Swift::UInt64 rawBits = 1LL;
        v146._Swift::UInt64 rawBits = 1LL;
        v147._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v145, v146, 0LL, 0xE000000000000000LL);
        if (v147._rawBits < 0x10000) {
          v147._rawBits |= 3;
        }
        unint64_t v149 = specialized String.init(_:)(v147, v148, 0LL, 0xE000000000000000LL);
        unint64_t v151 = v150;
        swift_bridgeObjectRelease(0xE000000000000000LL);
        unint64_t v152 = _StringGuts._convertedToSmall()(v149, v151);
        unint64_t v154 = v153;
        swift_bridgeObjectRelease(v151);
        unint64_t v155 = specialized _SmallString.init(_:appending:)(v142, v144, v152, v154);
        if ((v157 & 1) != 0) {
          goto LABEL_264;
        }
        unint64_t countAndFlagsBits = v155;
        unint64_t v158 = v156;
        swift_bridgeObjectRelease(v5);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        goto LABEL_154;
      }

      goto LABEL_170;
    }

    unint64_t v229 = v84 & 0xFFFFFFFFFFFFLL;
    goto LABEL_263;
  }

  if ((v110 & 0x2000000000000000LL) == 0) {
    goto LABEL_258;
  }
LABEL_262:
  unint64_t v229 = HIBYTE(v110) & 0xF;
LABEL_263:
  swift_bridgeObjectRetain(v110, v225, v226, v227);
  _StringGuts.append(_:)(v84, v110, 0LL, v229);
  swift_bridgeObjectRelease_n(v110, 2LL);
  uint64_t v84 = v261._countAndFlagsBits;
  uint64_t v110 = (unint64_t)v261._object;
LABEL_264:
  char v233 = HIBYTE(v110) & 0xF;
  if ((v110 & 0x2000000000000000LL) == 0) {
    char v233 = v84 & 0xFFFFFFFFFFFFLL;
  }
  if (v233 || (v84 & ~v110 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x29uLL, 0xE100000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    return v261._countAndFlagsBits;
  }

  else
  {
    swift_bridgeObjectRelease(v110);
    return 41LL;
  }

    unint64_t v229 = v84 & 0xFFFFFFFFFFFFLL;
    goto LABEL_263;
  }

  if ((v110 & 0x2000000000000000LL) == 0) {
    goto LABEL_258;
  }
LABEL_262:
  unint64_t v229 = HIBYTE(v110) & 0xF;
LABEL_263:
  swift_bridgeObjectRetain(v110, v225, v226, v227);
  _StringGuts.append(_:)(v84, v110, 0LL, v229);
  swift_bridgeObjectRelease_n(v110, 2LL);
  uint64_t v84 = v261._countAndFlagsBits;
  uint64_t v110 = (unint64_t)v261._object;
LABEL_264:
  char v233 = HIBYTE(v110) & 0xF;
  if ((v110 & 0x2000000000000000LL) == 0) {
    char v233 = v84 & 0xFFFFFFFFFFFFLL;
  }
  if (v233 || (v84 & ~v110 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x29uLL, 0xE100000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    return v261._countAndFlagsBits;
  }

  else
  {
    swift_bridgeObjectRelease(v110);
    return 41LL;
  }

          if (*((_WORD *)v104 + 8) == 229)
          {
            switch(v104[18])
            {
              case 1:
                __int128 v216 = 0;
                size_t v217 = "";
                unint64_t v106 = 1LL;
                goto LABEL_660;
              case 2:
                goto LABEL_262;
              case 3:
                unint64_t v106 = 0LL;
                __int128 v216 = *((_DWORD *)v104 + 2);
                size_t v217 = *(const char **)v104;
                goto LABEL_660;
              case 5:
                unint64_t v106 = *((unsigned int *)v104 + 2);
                if (v106 <= 1)
                {
                  __int128 v216 = 0;
LABEL_659:
                  size_t v217 = "";
LABEL_660:
                  unint64_t v5 = (uint64_t)operator new(0x28uLL);
                  *(void *)unint64_t v5 = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (2)";
                  *(void *)(v5 + 8) = 0xE5000005EBLL;
                  *(_DWORD *)(v5 + 16) = v216;
                  *(void *)(v5 + 24) = v217;
                  *(void *)(v5 + 32) = v106;
                  char v10 = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
LABEL_661:
                  *((_WORD *)a4 + 8) = 1;
                  a4[1] = (unint64_t)v10;
                  *a4 = ((uint64_t (*)(uint64_t, uint64_t, void))v10)(v5, 2LL, 0LL);
                  ((void (*)(uint64_t, uint64_t, void))v10)(v5, 3LL, 0LL);
LABEL_662:
                  uint64_t v251 = (void *)v541;
                  goto LABEL_1084;
                }

                unint64_t v104 = *(const char **)v104;
LABEL_262:
                uint64_t v107 = *(const char **)v104;
                if (LOWORD(v547[0]) == 1)
                {
                  char v10 = (void (*)(uint64_t, int))v546;
                  unint64_t v5 = ((uint64_t (*)(void *, uint64_t, void))v546)(v545, 2LL, 0LL);
                  uint64_t v110 = 0;
                  char v111 = 1;
                }

                else
                {
                  size_t v115 = v5;
                  if (LOWORD(v547[0])) {
                    char v116 = 0LL;
                  }
                  else {
                    char v116 = (uint64_t)v545;
                  }
                  if (v117)
                  {
                    unint64_t v120 = v117;
                    unint64_t v121 = 0LL;
                    char v111 = 0;
                    while (1)
                    {
                      unint64_t v122 = (*v11)[11];
                      if ((*v11)[10] == v122) {
LABEL_1195:
                      }
                        swift::fatalError(0LL, "advancePackExpansion() without beginPackExpansion()\n", v118, v119);
                      *(void *)(v122 - 8) = v121;
                      char v123 = v539[0];
                      if (v539[0] == 1)
                      {
                        char v10 = (void (*)(uint64_t, int))*((void *)&v538 + 1);
                        size_t v115 = (*((uint64_t (**)(void, uint64_t, void))&v538 + 1))(v538, 2LL, 0LL);
                        char v111 = 1;
                      }

                      else
                      {
                        uint64_t v124 = v11;
                        if (v539[0]) {
                          unint64_t v125 = 0LL;
                        }
                        else {
                          unint64_t v125 = v538;
                        }
                        unint64_t v126 = DWORD2(v541);
                        if (DWORD2(v541) >= (unint64_t)HIDWORD(v541))
                        {
                          __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod( (uint64_t)&v541,  &v542,  DWORD2(v541) + 1LL,  8LL);
                          unint64_t v126 = DWORD2(v541);
                        }

                        *(void *)(v541 + 8 * v126) = v125;
                        ++DWORD2(v541);
                        uint64_t v11 = v124;
                      }

                      if (v539[0] == 1) {
                        (*((void (**)(void, uint64_t, void))&v538 + 1))(v538, 3LL, 0LL);
                      }
                      if (v123 == 1) {
                        break;
                      }
                      if (v120 == ++v121) {
                        goto LABEL_296;
                      }
                    }

                    uint64_t v110 = 0;
                    uint64_t v94 = v516;
                    unint64_t v5 = v115;
                  }

                  else
                  {
                    char v111 = 0;
LABEL_296:
                    unint64_t v127 = (*v11)[11];
                    uint64_t v94 = v516;
                    if ((*v11)[10] == v127) {
LABEL_1196:
                    }
                      swift::fatalError(0LL, "endPackExpansion() without beginPackExpansion()\n", v118, v119);
                    unint64_t v5 = v115;
                    (*v11)[11] = v127 - 16;
                    uint64_t v110 = 1;
                  }
                }

                if (LOWORD(v547[0]) == 1) {
                  ((void (*)(void *, uint64_t, void))v546)(v545, 3LL, 0LL);
                }
                if ((v110 & 1) == 0) {
                  goto LABEL_302;
                }
                goto LABEL_249;
              default:
                __int128 v216 = 0;
                unint64_t v106 = 0LL;
                goto LABEL_659;
            }
          }

          uint64_t v112 = LOWORD(v547[0]);
          if (LOWORD(v547[0]) == 1)
          {
            char v10 = (void (*)(uint64_t, int))v546;
            unint64_t v5 = ((uint64_t (*)(void *, uint64_t, void))v546)(v545, 2LL, 0LL);
            char v111 = 1;
          }

          else
          {
            if (LOWORD(v547[0])) {
              uint64_t v113 = 0LL;
            }
            else {
              uint64_t v113 = v545;
            }
            uint64_t v114 = DWORD2(v541);
            if (DWORD2(v541) >= (unint64_t)HIDWORD(v541))
            {
              __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod( (uint64_t)&v541,  &v542,  DWORD2(v541) + 1LL,  8LL);
              uint64_t v114 = DWORD2(v541);
            }

            char v111 = 0;
            *(void *)(v541 + 8 * v114) = v113;
            ++DWORD2(v541);
          }

          if (LOWORD(v547[0]) == 1) {
            ((void (*)(void *, uint64_t, void))v546)(v545, 3LL, 0LL);
          }
          if (v112 == 1)
          {
LABEL_302:
            if (v111) {
              goto LABEL_661;
            }
          }

          else
          {
LABEL_249:
            v5 &= 0xFFFFFFFFFFFFFF00LL;
          }

          v33 += 8;
          if (v33 == v94)
          {
            uint64_t v12 = *v507;
LABEL_305:
            if (v12 == 228)
            {
              id v128 = a4;
            }

            else
            {
              id v128 = a4;
              if (v12 != 227)
              {
                goto LABEL_662;
              }
            }

            *((_WORD *)v128 + 8) = 1;
            v128[1] = (unint64_t)_ZZN5swift15TypeLookupErrorC1IZNS_L19TypeLookupErrorImplIJEEES0_PKcDpT_EUlvE_EERKT_ENUlPvNS0_7CommandESB_E_8__invokeESB_SC_SB_;
            uint64_t v129 = operator new(8uLL);
            *uint64_t v129 = "Lowered SILPackType cannot be demangled";
            *id v128 = (unint64_t)v129;
            goto LABEL_662;
          }
        }

      case 0xE5:
        if (*((_BYTE *)v10 + 18) == 3)
        {
          Swift::String::Index v88 = *((_DWORD *)v10 + 2);
          char v45 = *(const char **)v10;
        }

        else
        {
          Swift::String::Index v88 = 0;
          char v45 = "";
        }

        unint64_t v97 = operator new(0x28uLL);
        unint64_t v40 = v97;
        *unint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
        v97[1] = 0xE5000004D0LL;
        *((_DWORD *)v97 + 4) = v88;
        unint64_t v100 = "pack expansion type in unsupported position";
        goto LABEL_459;
      case 0xE8:
        uint64_t v19 = *((unsigned __int8 *)v10 + 18);
        if (v19 != 5)
        {
          if (v19 == 3)
          {
            char v96 = *((_DWORD *)v10 + 2);
            char v45 = *(const char **)v10;
          }

          else
          {
LABEL_226:
            char v96 = 0;
            char v45 = "";
          }

          unint64_t v97 = operator new(0x28uLL);
          unint64_t v40 = v97;
          *unint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
          unint64_t v99 = 0xE800000261LL;
          goto LABEL_230;
        }

        if (!*((_DWORD *)v10 + 2)) {
          goto LABEL_226;
        }
        goto LABEL_49;
      case 0xEC:
        BOOL v22 = *((unsigned __int8 *)v10 + 18);
        if (v22 != 5)
        {
          if (v22 == 3)
          {
            char v96 = *((_DWORD *)v10 + 2);
            char v45 = *(const char **)v10;
          }

          else
          {
LABEL_228:
            char v96 = 0;
            char v45 = "";
          }

          unint64_t v97 = operator new(0x28uLL);
          unint64_t v40 = v97;
          *unint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
          unint64_t v99 = 0xEC0000025CLL;
LABEL_230:
          v97[1] = v99;
          *((_DWORD *)v97 + 4) = v96;
          unint64_t v100 = "no children.";
LABEL_459:
          v97[3] = v45;
LABEL_768:
          v97[4] = v100;
          *((_WORD *)v6 + 8) = 1;
          uint64_t v211 = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
LABEL_769:
          v6[1] = (unint64_t)v211;
          unint64_t v297 = operator new(0x28uLL);
          unint64_t v298 = *((_OWORD *)v40 + 1);
          *unint64_t v297 = *(_OWORD *)v40;
          v297[1] = v298;
          *((void *)v297 + 4) = *((void *)v40 + 4);
          *uint64_t v6 = (unint64_t)v297;
LABEL_770:
          operator delete(v40);
          return;
        }

        if (!*((_DWORD *)v10 + 2)) {
          goto LABEL_228;
        }
        goto LABEL_49;
      case 0xF7:
        uint64_t v26 = 0;
        uint64_t v27 = "";
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
          case 2:
            goto LABEL_515;
          case 3:
            uint64_t v26 = *((_DWORD *)v10 + 2);
            uint64_t v27 = *(const char **)v10;
            goto LABEL_761;
          case 5:
            if (!*((_DWORD *)v10 + 2))
            {
              uint64_t v26 = 0;
LABEL_761:
              unint64_t v97 = operator new(0x28uLL);
              unint64_t v40 = v97;
              *unint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
              unint64_t v197 = 0xF70000050CLL;
              goto LABEL_766;
            }

            char v10 = *(void (**)(uint64_t, int))v10;
LABEL_515:
            unint64_t v207 = *v11;
            if ((_WORD)v542)
            {
              *((_BYTE *)v207 + 72) |= 1u;
              goto LABEL_317;
            }

            unint64_t v295 = v541;
            uint64_t v296 = *((_BYTE *)v207 + 72) | 1;
            break;
          default:
            goto LABEL_761;
        }

        goto LABEL_755;
      case 0xF8:
        uint64_t v26 = 0;
        uint64_t v27 = "";
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
          case 2:
            goto LABEL_500;
          case 3:
            uint64_t v26 = *((_DWORD *)v10 + 2);
            uint64_t v27 = *(const char **)v10;
            goto LABEL_759;
          case 5:
            if (!*((_DWORD *)v10 + 2))
            {
              uint64_t v26 = 0;
LABEL_759:
              unint64_t v97 = operator new(0x28uLL);
              unint64_t v40 = v97;
              *unint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
              unint64_t v197 = 0xF8000004FALL;
              goto LABEL_766;
            }

            char v10 = *(void (**)(uint64_t, int))v10;
LABEL_500:
            unint64_t v207 = *v11;
            if ((_WORD)v542)
            {
              *((_BYTE *)v207 + 72) |= 2u;
              goto LABEL_317;
            }

            unint64_t v295 = v541;
            uint64_t v296 = *((_BYTE *)v207 + 72) | 2;
            break;
          default:
            goto LABEL_759;
        }

        goto LABEL_755;
      case 0xF9:
        uint64_t v26 = 0;
        uint64_t v27 = "";
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
          case 2:
            goto LABEL_520;
          case 3:
            uint64_t v26 = *((_DWORD *)v10 + 2);
            uint64_t v27 = *(const char **)v10;
            goto LABEL_763;
          case 5:
            if (!*((_DWORD *)v10 + 2))
            {
              uint64_t v26 = 0;
LABEL_763:
              unint64_t v97 = operator new(0x28uLL);
              unint64_t v40 = v97;
              *unint64_t v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
              unint64_t v197 = 0xF900000503LL;
              goto LABEL_766;
            }

            char v10 = *(void (**)(uint64_t, int))v10;
LABEL_520:
            if ((unsigned __int16)v542 == 1)
            {
LABEL_521:
              *((_WORD *)v6 + 8) = 1;
              *(_OWORD *)uint64_t v6 = v541;
              return;
            }

            unint64_t v207 = *v11;
            if ((_WORD)v542)
            {
              *((_BYTE *)v207 + 72) |= 4u;
              goto LABEL_317;
            }

            unint64_t v295 = v541;
            uint64_t v296 = *((_BYTE *)v207 + 72) | 4;
            break;
          default:
            goto LABEL_763;
        }

LABEL_169:
    if (v135 <= 15) {
      goto LABEL_147;
    }
LABEL_170:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v135, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    uint64_t v266 = 0LL;
    unint64_t v267 = 0LL;
    unint64_t v170 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v266, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v170, v171, 1);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t countAndFlagsBits = v268._countAndFlagsBits;
    unint64_t v158 = (unint64_t)v268._object;
LABEL_171:
    uint64_t v172 = specialized static String._createEmpty(withInitialCapacity:)(6LL);
    uint64_t v176 = v173;
    v268._unint64_t countAndFlagsBits = v172;
    v268._uint64_t object = (void *)v173;
    uint64_t v177 = HIBYTE(v173) & 0xF;
    if ((v173 & 0x2000000000000000LL) == 0) {
      uint64_t v177 = v172 & 0xFFFFFFFFFFFFLL;
    }
    if (v177 || (v172 & ~v173 & 0x2000000000000000LL) != 0)
    {
      if ((v173 & 0x2000000000000000LL) == 0
        || (unint64_t v178 = specialized _SmallString.init(_:appending:)(v172, v173, 0x2E2E2EuLL, 0xE300000000000000LL),
            (v174 & 1) != 0))
      {
        swift_bridgeObjectRetain(0xE300000000000000LL, v173, v174, v175);
        _StringGuts.append(_:)(3026478LL, 0xE300000000000000LL, 0LL, 3LL);
        swift_bridgeObjectRelease_n(0xE300000000000000LL, 2LL);
        uint64_t v90 = v268._countAndFlagsBits;
        unint64_t v5 = (unint64_t)v268._object;
        goto LABEL_181;
      }

      uint64_t v90 = v178;
      unint64_t v5 = v173;
      swift_bridgeObjectRelease(v176);
      swift_bridgeObjectRelease(0xE300000000000000LL);
    }

    else
    {
      uint64_t v90 = 3026478LL;
      swift_bridgeObjectRelease(v173);
      unint64_t v5 = 0xE300000000000000LL;
    }

    v268._unint64_t countAndFlagsBits = v90;
    v268._uint64_t object = (void *)v5;
LABEL_181:
    uint64_t v180 = (uint64_t)v264;
    unint64_t v179 = v265;
    ((void (*)(char *, uint64_t, swift *))v14)(v264, v263 + *(int *)(v262 + 36), v265);
    uint64_t v266 = 0LL;
    unint64_t v267 = 0xE000000000000000LL;
    _debugPrint_unlocked<A, B>(_:_:)( v180,  (uint64_t)&v266,  v179,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
    ((void (*)(uint64_t, swift *))v13)(v180, v179);
    uint64_t v184 = v266;
    unint64_t v183 = v267;
    uint64_t v185 = HIBYTE(v5) & 0xF;
    uint64_t v186 = (v5 & 0x2000000000000000LL) != 0 ? HIBYTE(v5) & 0xF : v90 & 0xFFFFFFFFFFFFLL;
    if (!v186 && (v90 & ~v5 & 0x2000000000000000LL) == 0) {
      break;
    }
    uint64_t object = v267 & 0x2000000000000000LL;
    unint64_t v85 = HIBYTE(v267) & 0xF;
    unint64_t v261 = v158;
    if ((v5 & 0x2000000000000000LL) != 0 && object)
    {
      unint64_t v218 = v185 + v85;
      if (v185 + v85 <= 0xF)
      {
        if (v85)
        {
          char v226 = 0;
          unint64_t v227 = 0LL;
          unint64_t v228 = v5;
          do
          {
            unint64_t v229 = v185 + v227;
            unint64_t v230 = v227 + 1;
            if (v227 >= 8) {
              unint64_t v231 = v267;
            }
            else {
              unint64_t v231 = v266;
            }
            unint64_t v232 = v231 >> (v226 & 0x38);
            char v233 = (8 * v185 + v226) & 0x38;
            uint64_t v234 = (-255LL << v233) - 1;
            unint64_t v235 = (unint64_t)v232 << v233;
            unint64_t v236 = v235 | v234 & v228;
            unint64_t v237 = v235 | v234 & v90;
            if (v229 < 8) {
              uint64_t v90 = v237;
            }
            else {
              unint64_t v228 = v236;
            }
            v226 += 8;
            unint64_t v227 = v230;
          }

          while (v85 != v230);
        }

        else
        {
          unint64_t v228 = v5;
        }

        swift_bridgeObjectRelease(v5);
        swift_bridgeObjectRelease(v183);
        unint64_t v242 = 0xA000000000000000LL;
        if (!(v90 & 0x8080808080808080LL | v228 & 0x80808080808080LL)) {
          unint64_t v242 = 0xE000000000000000LL;
        }
        v268._unint64_t countAndFlagsBits = v90;
        v268._uint64_t object = (void *)(v242 & 0xFF00000000000000LL | (v218 << 56) | v228 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_214;
      }

      uint64_t v265 = (swift *)countAndFlagsBits;
      uint64_t object = 1LL;
    }

    else
    {
      uint64_t v265 = (swift *)countAndFlagsBits;
    }

    uint64_t v92 = v266 & 0xFFFFFFFFFFFFLL;
    if (object) {
      unint64_t countAndFlagsBits = HIBYTE(v267) & 0xF;
    }
    else {
      unint64_t countAndFlagsBits = v266 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v267, 2LL, v181, v182);
    if ((v183 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v183, 5LL, v187, v188);
      v243._Swift::UInt64 rawBits = 1LL;
      v244._Swift::UInt64 rawBits = (countAndFlagsBits << 16) | 1;
      v245._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v243, v244, v184, v183);
      if (v245._rawBits < 0x10000) {
        v245._rawBits |= 3;
      }
      int64_t v14 = specialized Collection.count.getter(v245, v246, v184, v183);
      swift_bridgeObjectRelease(v183);
      if ((v5 & 0x1000000000000000LL) != 0)
      {
LABEL_246:
        Swift::Int v247 = String.UTF8View._foreignCount()();
        uint64_t v13 = v247 + v14;
        if (__OFADD__(v247, v14)) {
          goto LABEL_248;
        }
LABEL_195:
        if ((v90 & ~v5 & 0x2000000000000000LL) == 0
          || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v13 <= 15) {
            goto LABEL_202;
          }
          goto LABEL_207;
        }

        int64_t v189 = _StringGuts.nativeUnusedCapacity.getter(v90, v5);
        if ((v190 & 1) == 0)
        {
          uint64_t v191 = (v5 >> 61) & 1;
          if (v189 < v14) {
            LODWORD(v191) = 1;
          }
          if (v13 <= 15 && (_DWORD)v191)
          {
LABEL_202:
            swift_bridgeObjectRelease_n(v183, 5LL);
            swift_bridgeObjectRetain(v5, v192, v193, v194);
            unint64_t v195 = _StringGuts._convertedToSmall()(v90, v5);
            unint64_t v197 = v196;
            swift_bridgeObjectRelease(v5);
            v198._Swift::UInt64 rawBits = (countAndFlagsBits << 16) | 1;
            v199._Swift::UInt64 rawBits = 1LL;
            v200._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v199, v198, v184, v183);
            if (v200._rawBits < 0x10000) {
              v200._rawBits |= 3;
            }
            unint64_t v202 = specialized String.init(_:)(v200, v201, v184, v183);
            unint64_t v204 = v203;
            swift_bridgeObjectRelease(v183);
            unint64_t v205 = _StringGuts._convertedToSmall()(v202, v204);
            unint64_t v207 = v206;
            swift_bridgeObjectRelease(v204);
            unint64_t v208 = specialized _SmallString.init(_:appending:)(v195, v197, v205, v207);
            if ((v210 & 1) == 0)
            {
              uint64_t v211 = v208;
              uint64_t v212 = v209;
              swift_bridgeObjectRelease(v5);
              swift_bridgeObjectRelease(v183);
              v268._unint64_t countAndFlagsBits = v211;
              v268._uint64_t object = v212;
              goto LABEL_213;
            }

    dword_18C471474 = v6;
    return;
  }

LABEL_264:
            unint64_t v254 = 266LL;
LABEL_266:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v254,  0);
          }

LABEL_214:
          unint64_t v158 = v261;
          goto LABEL_215;
        }

LABEL_265:
        unint64_t v254 = 258LL;
        goto LABEL_266;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(v183, 4LL, v187, v188);
      int64_t v14 = countAndFlagsBits;
      if ((v5 & 0x1000000000000000LL) != 0) {
        goto LABEL_246;
      }
    }

    BOOL v22 = __OFADD__(v186, v14);
    uint64_t v13 = v186 + v14;
    if (!v22) {
      goto LABEL_195;
    }
LABEL_248:
    __break(1u);
LABEL_249:
    if ((v92 & 0x1000000000000000LL) != 0)
    {
      uint64_t v90 = _StringGuts._foreignConvertedToSmall()(v90, v92);
      uint64_t v256 = v255;
      swift_bridgeObjectRelease(v92);
      uint64_t v92 = v256;
    }

    else
    {
      if ((v90 & 0x1000000000000000LL) != 0)
      {
        uint64_t v248 = (unsigned __int8 *)((v92 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v249 = v90 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v248 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v90, v92);
      }

      closure #1 in _StringGuts._convertedToSmall()(v248, v249, &v266);
      swift_bridgeObjectRelease(v92);
      uint64_t v90 = v266;
      uint64_t v92 = v267;
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  unint64_t v41 = HIBYTE(a2) & 0xF;
  v162[0] = a1;
  v162[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v41) {
    goto LABEL_265;
  }
  if (a1 == 43)
  {
    char v10 = 1;
    size_t v115 = specialized Collection.subscript.getter(1LL, (uint64_t)v162, v41);
    unint64_t v119 = specialized UnsafeBufferPointer.init(rebasing:)(v115, v116, v117, v118);
    if (v120)
    {
      unint64_t v122 = (unsigned __int8 *)v119;
      char v123 = a3 + 48;
      uint64_t v124 = a3 + 55;
      unint64_t v125 = a3 + 87;
      if (a3 > 10)
      {
        char v123 = 58;
      }

      else
      {
        unint64_t v125 = 97;
        uint64_t v124 = 65;
      }

      if (v119)
      {
        unint64_t v126 = v120;
        int64_t v23 = 0LL;
        unint64_t v127 = 0LL;
        id v128 = abs64(a3);
        uint64_t v129 = -(v121 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
        while (1)
        {
          uint64_t v130 = *v122;
          if (v130 < 0x30 || v130 >= v123)
          {
            if (v130 < 0x41 || v130 >= v124)
            {
              uint64_t result = 0LL;
              char v10 = 1;
              if (v130 < 0x61 || v130 >= v125) {
                goto LABEL_261;
              }
              size_t v131 = -87;
            }

            else
            {
              size_t v131 = -55;
            }
          }

          else
          {
            size_t v131 = -48;
          }

          if ((__PAIR128__(v127 ^ (unint64_t)(v127 >> 63), v23 ^ (v127 >> 63))
              - __PAIR128__(v127 >> 63, v127 >> 63)) >> 64)
            unint64_t v133 = v129 == 0;
          else {
            unint64_t v133 = 1;
          }
          unint64_t v136 = !v133
              || (*((unint64_t *)&v132 + 1) * (unsigned __int128)v128) >> 64 != 0
              || (v129 * (unsigned __int128)(unint64_t)v132) >> 64 != 0;
          unint64_t v137 = (__PAIR128__(v129, v128) * v132) >> 64;
          if (__CFADD__( ((unint64_t)v132 * (unsigned __int128)v128) >> 64,  v129 * v132 + *((void *)&v132 + 1) * v128))
          {
            char v138 = 1;
          }

          else
          {
            char v138 = v136;
          }

          uint64_t v139 = v132 * v128;
          if ((v127 ^ (a3 >> 63)) < 0)
          {
            if ((v138 & 1) != 0)
            {
LABEL_260:
              uint64_t result = 0LL;
              char v10 = 1;
              goto LABEL_261;
            }

            unint64_t v39 = v139 == 0;
            uint64_t v139 = -(uint64_t)v139;
            unint64_t v137 = -(uint64_t)(v137 + !v39);
            LOBYTE(v14swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v139 != 0;
          }

          else
          {
            if ((v138 & 1) != 0) {
              goto LABEL_260;
            }
            uint64_t v140 = v137 >> 63;
          }

          uint64_t result = 0LL;
          unint64_t v39 = __CFADD__(v139, (v130 + v131));
          unint64_t v127 = (__PAIR128__(v137, v139) + (v130 + v131)) >> 64;
          int64_t v23 = v139 + (v130 + v131);
          unint64_t v141 = __OFADD__(v39, v137);
          char v10 = 1;
          if ((v140 & 1) != 0 || v141) {
            goto LABEL_261;
          }
          ++v122;
          if (!--v126)
          {
LABEL_217:
            char v10 = 0;
            uint64_t result = v23;
            goto LABEL_261;
          }
        }
      }

      goto LABEL_218;
    }

    goto LABEL_267;
  }

  if (a1 != 45)
  {
    char v96 = 0LL;
    unint64_t v142 = 0LL;
    unint64_t v143 = a3 + 48;
    unint64_t v144 = a3 + 55;
    Swift::String::Index v145 = a3 + 87;
    if (a3 > 10)
    {
      unint64_t v143 = 58;
    }

    else
    {
      Swift::String::Index v145 = 97;
      unint64_t v144 = 65;
    }

    Swift::String::Index v146 = abs64(a3);
    Swift::String::Index v147 = -(v3 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
    Swift::String::Index v148 = (unsigned __int8 *)v162;
    while (1)
    {
      unint64_t v149 = *v148;
      if (v149 < 0x30 || v149 >= v143)
      {
        if (v149 < 0x41 || v149 >= v144)
        {
          uint64_t result = 0LL;
          char v10 = 1;
          if (v149 < 0x61 || v149 >= v145) {
            goto LABEL_261;
          }
          unint64_t v150 = -87;
        }

        else
        {
          unint64_t v150 = -55;
        }
      }

      else
      {
        unint64_t v150 = -48;
      }

      unint64_t v152 = !((__PAIR128__(v142 ^ (unint64_t)(v142 >> 63), v96 ^ (v142 >> 63))
              - __PAIR128__(v142 >> 63, v142 >> 63)) >> 64)
          || v147 == 0;
      unint64_t v153 = v152 && (*((unint64_t *)&v151 + 1) * (unsigned __int128)v146) >> 64 == 0;
      unint64_t v154 = v153 && (v147 * (unsigned __int128)(unint64_t)v151) >> 64 == 0;
      unint64_t v155 = !v154;
      unint64_t v156 = (__PAIR128__(v147, v146) * v151) >> 64;
      char v157 = __CFADD__( ((unint64_t)v151 * (unsigned __int128)v146) >> 64,  v147 * v151 + *((void *)&v151 + 1) * v146)
          || v155;
      unint64_t v158 = v151 * v146;
      if ((v142 ^ (a3 >> 63)) < 0)
      {
        if ((v157 & 1) != 0) {
          goto LABEL_260;
        }
        unint64_t v39 = v158 == 0;
        unint64_t v158 = -(uint64_t)v158;
        unint64_t v156 = -(uint64_t)(v156 + !v39);
        LOBYTE(v159) = v158 != 0;
      }

      else
      {
        if ((v157 & 1) != 0) {
          goto LABEL_260;
        }
        unint64_t v159 = v156 >> 63;
      }

      uint64_t result = 0LL;
      unint64_t v39 = __CFADD__(v158, (v149 + v150));
      unint64_t v142 = (__PAIR128__(v156, v158) + (v149 + v150)) >> 64;
      char v96 = v158 + (v149 + v150);
      Swift::String::Index v160 = __OFADD__(v39, v156);
      char v10 = 1;
      if ((v159 & 1) != 0 || v160) {
        goto LABEL_261;
      }
      ++v148;
      if (!--v41)
      {
LABEL_258:
        char v10 = 0;
        uint64_t result = v96;
        goto LABEL_261;
      }
    }
  }

  char v10 = 1;
  unint64_t v42 = specialized Collection.subscript.getter(1LL, (uint64_t)v162, v41);
  uint64_t v46 = specialized UnsafeBufferPointer.init(rebasing:)(v42, v43, v44, v45);
  if (v47)
  {
    size_t v49 = (unsigned __int8 *)v46;
    int64_t v50 = a3 + 48;
    char v51 = a3 + 55;
    unint64_t v52 = a3 + 87;
    if (a3 > 10)
    {
      int64_t v50 = 58;
    }

    else
    {
      unint64_t v52 = 97;
      char v51 = 65;
    }

    if (v46)
    {
      unint64_t v53 = v47;
      int64_t v23 = 0LL;
      unint64_t v54 = 0LL;
      unint64_t v55 = abs64(a3);
      unint64_t v56 = -(v48 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
      while (1)
      {
        unint64_t v57 = *v49;
        if (v57 < 0x30 || v57 >= v50)
        {
          if (v57 < 0x41 || v57 >= v51)
          {
            uint64_t result = 0LL;
            char v10 = 1;
            if (v57 < 0x61 || v57 >= v52) {
              goto LABEL_261;
            }
            char v58 = -87;
          }

          else
          {
            char v58 = -55;
          }
        }

        else
        {
          char v58 = -48;
        }

        uint64_t v59 = __PAIR128__(v54 ^ (unint64_t)(v54 >> 63), v23 ^ (v54 >> 63)) - __PAIR128__(v54 >> 63, v54 >> 63);
        unint64_t v61 = v60 && (*((unint64_t *)&v59 + 1) * (unsigned __int128)v55) >> 64 == 0;
        unint64_t v62 = v61 && (v56 * (unsigned __int128)(unint64_t)v59) >> 64 == 0;
        id v63 = !v62;
        uint64_t v64 = (__PAIR128__(v56, v55) * v59) >> 64;
        size_t v66 = v59 * v55;
        if ((v54 ^ (a3 >> 63)) < 0)
        {
          if ((v65 & 1) != 0) {
            goto LABEL_260;
          }
          unint64_t v39 = v66 == 0;
          size_t v66 = -(uint64_t)v66;
          uint64_t v64 = -(uint64_t)(v64 + !v39);
          LOBYTE(v67) = v66 != 0;
        }

        else
        {
          if ((v65 & 1) != 0) {
            goto LABEL_260;
          }
          unint64_t v67 = v64 >> 63;
        }

        uint64_t result = 0LL;
        unint64_t v39 = v66 >= (v57 + v58);
        unint64_t v54 = (__PAIR128__(v64, v66) - (v57 + v58)) >> 64;
        int64_t v23 = v66 - (v57 + v58);
        uint64_t v68 = __OFSUB__(v64, !v39);
        char v10 = 1;
        if ((v67 & 1) != 0 || v68) {
          goto LABEL_261;
        }
        ++v49;
        if (!--v53) {
          goto LABEL_217;
        }
      }
    }

    goto LABEL_218;
  }

uint64_t String.init<A>(reflecting:)(uint64_t a1, swift *a2)
{
  v5[0] = 0LL;
  v5[1] = 0xE000000000000000LL;
  _debugPrint_unlocked<A, B>(_:_:)( a1,  (uint64_t)v5,  a2,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  (*(void (**)(uint64_t, swift *))(*((void *)a2 - 1) + 8LL))(a1, a2);
  return v5[0];
}

uint64_t specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)@<X0>( __int128 *a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int128 v12 = a1[1];
  __int128 v29 = *a1;
  v30[0] = v12;
  *(_OWORD *)((char *)v30 + 9) = *(__int128 *)((char *)a1 + 25);
  *(void *)&__int128 v27 = a4;
  *((void *)&v27 + 1) = a5;
  uint64_t v13 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v29, (uint64_t)&v27, (swift *)&type metadata for Mirror);
  uint64_t v15 = v14;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v16 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  uint64_t v17 = swift_allocObject(v16, 0x48uLL, 7uLL);
  v17[6] = a2;
  v17[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v17[8] = 0LL;
  uint64_t v18 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v19 = swift_allocObject(v18, 0x18uLL, 7uLL);
  _OWORD v19[2] = 0LL;
  uint64_t v20 = *(void *)(a2 + 16);
  Swift::Int v21 = swift_allocObject(v18, 0x18uLL, 7uLL);
  _OWORD v21[2] = v20;
  void v17[2] = v19;
  v17[3] = &protocol witness table for _IndexBox<A>;
  v17[4] = v21;
  v17[5] = &protocol witness table for _IndexBox<A>;
  __int128 v22 = a1[1];
  __int128 v27 = *a1;
  v28[0] = v22;
  *(_OWORD *)((char *)v28 + 9) = *(__int128 *)((char *)a1 + 25);
  int64_t v23 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v26, (uint64_t *)&v27, (swift *)&type metadata for Mirror, v23, 6uLL);
  char v25 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v26);
  }
  *(void *)a6 = &type metadata for Mirror;
  *(void *)(a6 + 8) = v17;
  *(_BYTE *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = v13;
  *(void *)(a6 + 32) = v15;
  *(_BYTE *)(a6 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v25;
  return result;
}

uint64_t specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  *(void *)&v26[0] = a4;
  *((void *)&v26[0] + 1) = a5;
  __int128 v12 = static Mirror._superclassIterator<A>(_:_:)(a1, (uint64_t)v26, (swift *)&type metadata for AnyHashable);
  uint64_t v14 = v13;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  uint64_t v16 = swift_allocObject(v15, 0x48uLL, 7uLL);
  v16[6] = a2;
  v16[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v16[8] = 0LL;
  uint64_t v17 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v18 = swift_allocObject(v17, 0x18uLL, 7uLL);
  void v18[2] = 0LL;
  uint64_t v19 = *(void *)(a2 + 16);
  uint64_t v20 = swift_allocObject(v17, 0x18uLL, 7uLL);
  void v20[2] = v19;
  v16[2] = v18;
  v16[3] = &protocol witness table for _IndexBox<A>;
  v16[4] = v20;
  v16[5] = &protocol witness table for _IndexBox<A>;
  __int128 v21 = *(_OWORD *)(a1 + 16);
  v26[0] = *(_OWORD *)a1;
  v26[1] = v21;
  uint64_t v27 = *(void *)(a1 + 32);
  __int128 v22 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v25, (uint64_t *)v26, (swift *)&type metadata for AnyHashable, v22, 6uLL);
  char v24 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v25);
  }
  *(void *)a6 = &type metadata for AnyHashable;
  *(void *)(a6 + 8) = v16;
  *(_BYTE *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = v12;
  *(void *)(a6 + 32) = v14;
  *(_BYTE *)(a6 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v24;
  return result;
}

uint64_t specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, unint64_t a4@<X3>, uint64_t a5@<X4>, swift *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v28 = a1;
  v26[0] = a4;
  v26[1] = a5;
  uint64_t v14 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v28, (uint64_t)v26, a6);
  uint64_t v16 = v15;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  uint64_t v18 = swift_allocObject(v17, 0x48uLL, 7uLL);
  v18[6] = a2;
  v18[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v18[8] = 0LL;
  uint64_t v19 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v20 = swift_allocObject(v19, 0x18uLL, 7uLL);
  void v20[2] = 0LL;
  uint64_t v21 = *(void *)(a2 + 16);
  __int128 v22 = swift_allocObject(v19, 0x18uLL, 7uLL);
  v22[2] = v21;
  void v18[2] = v20;
  v18[3] = &protocol witness table for _IndexBox<A>;
  v18[4] = v22;
  v18[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v27 = a1;
  int64_t v23 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v26, &v27, a6, v23, 6uLL);
  char v25 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v26);
  }
  *(void *)a7 = a6;
  *(void *)(a7 + 8) = v18;
  *(_BYTE *)(a7 + 16) = a3;
  *(void *)(a7 + 24) = v14;
  *(void *)(a7 + 32) = v16;
  *(_BYTE *)(a7 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v25;
  return result;
}

uint64_t Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, swift *a3@<X4>, uint64_t a4@<X8>)
{
  uint64_t v8 = *((void *)a3 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (uint64_t *)((char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  int v30 = *v12;
  uint64_t v15 = v13[1];
  v31[0] = *v13;
  unint64_t v14 = v31[0];
  v31[1] = v15;
  __int128 v29 = static Mirror._superclassIterator<A>(_:_:)(v9, (uint64_t)v31, v16);
  uint64_t v18 = v17;
  outlined consume of Mirror.AncestorRepresentation(v14, v15);
  uint64_t v19 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  uint64_t v20 = swift_allocObject(v19, 0x48uLL, 7uLL);
  v20[6] = a2;
  v20[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v20[8] = 0LL;
  uint64_t v21 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  __int128 v22 = swift_allocObject(v21, 0x18uLL, 7uLL);
  v22[2] = 0LL;
  uint64_t v23 = *(void *)(a2 + 16);
  char v24 = swift_allocObject(v21, 0x18uLL, 7uLL);
  v24[2] = v23;
  void v20[2] = v22;
  v20[3] = &protocol witness table for _IndexBox<A>;
  _OWORD v20[4] = v24;
  v20[5] = &protocol witness table for _IndexBox<A>;
  (*(void (**)(uint64_t *, uint64_t, swift *))(v8 + 32))(v11, a1, a3);
  char v25 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v31, v11, a3, v25, 6uLL);
  char v27 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v31);
  }
  *(void *)a4 = a3;
  *(void *)(a4 + 8) = v20;
  *(_BYTE *)(a4 + 16) = v30;
  *(void *)(a4 + 24) = v29;
  *(void *)(a4 + 32) = v18;
  *(_BYTE *)(a4 + 4swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL, 0) = v27;
  return result;
}

uint64_t ClosedRange<>.init(_:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  char v58 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a2, a2, "lower upper ", 0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v57 = (char *)&v47 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  unint64_t v55 = (char *)&v47 - v9;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v51 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64_t v50 = (char *)&v47 - v11;
  uint64_t v12 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v47 = (char *)&v47 - v15;
  uint64_t v52 = *(void *)(a2 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  size_t v49 = (char *)&v47 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  unint64_t v48 = (char *)&v47 - v18;
  uint64_t v54 = a3;
  uint64_t v19 = *(void *)(a3 + 8);
  uint64_t v21 = type metadata accessor for Range(0LL, a2, v19, v20);
  uint64_t v22 = *(void *)(v21 - 8);
  MEMORY[0x1895F8858](v21);
  char v24 = (char *)&v47 - v23;
  char v25 = a1;
  (*(void (**)(char *, char *, uint64_t))(v22 + 16))((char *)&v47 - v23, a1, v21);
  uint64_t v26 = &v24[*(int *)(v21 + 36)];
  uint64_t v53 = v19;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v19 + 8) + 8LL))(v24, v26, a2) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form an empty closed range",  32LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x1C6uLL,  0);
  }
  char v27 = *(void (**)(char *, uint64_t))(v22 + 8);
  v27(v24, v21);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v12,  AssociatedTypeWitness,  v13,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  __int128 v29 = v47;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE78,  257LL,  v13,  AssociatedConformanceWitness);
  int v30 = v50;
  (*(void (**)(char *, unint64_t, uint64_t))(v12 + 24))(v29, AssociatedTypeWitness, v12);
  unint64_t v31 = v48;
  (*(void (**)(char *, uint64_t))(v54 + 48))(v30, a2);
  (*(void (**)(char *, unint64_t))(v51 + 8))(v30, AssociatedTypeWitness);
  uint64_t v32 = v52;
  Swift::String::Index v33 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
  Swift::String::Index v34 = v49;
  v33(v49, (uint64_t)v25, a2);
  v27(v25, v21);
  Swift::String::Index v36 = v55;
  Swift::String::Index v35 = TupleTypeMetadata2;
  unint64_t v37 = &v55[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v38 = *(void (**)(char *, char *, uint64_t))(v32 + 32);
  v38(v55, v34, a2);
  v38(v37, v31, a2);
  unint64_t v39 = v57;
  unint64_t v40 = &v57[*((int *)v35 + 12)];
  v33(v57, (uint64_t)v36, a2);
  v33(v40, (uint64_t)v37, a2);
  unint64_t v41 = v58;
  v38(v58, v39, a2);
  unint64_t v42 = *(void (**)(char *, uint64_t))(v32 + 8);
  v42(v40, a2);
  unint64_t v43 = &v39[*((int *)v35 + 12)];
  v38(v39, v36, a2);
  v38(v43, v37, a2);
  uint64_t v45 = type metadata accessor for ClosedRange(0LL, a2, v53, v44);
  v38(&v41[*(int *)(v45 + 36)], v43, a2);
  return ((uint64_t (*)(char *, uint64_t))v42)(v39, a2);
}

uint64_t ClosedRange.overlaps(_:)(char *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v22 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v22 - v11;
  uint64_t v14 = *(void *)(v13 + 16);
  uint64_t v15 = *(void *)(v13 + 24);
  uint64_t v16 = *(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v15 + 16);
  char v17 = v16(v10 + *(int *)(v13 + 36), v3, v14, v15);
  uint64_t v23 = v6;
  uint64_t v18 = *(void (**)(char *, char *, uint64_t))(v6 + 16);
  v18(v12, v3, a2);
  v18(v9, a1, a2);
  if ((v17 & 1) != 0) {
    char v19 = 0;
  }
  else {
    char v19 = v16((uint64_t)&v12[*(int *)(a2 + 36)], v9, v14, v15) ^ 1;
  }
  uint64_t v20 = *(void (**)(char *, uint64_t))(v23 + 8);
  v20(v9, a2);
  v20(v12, a2);
  return v19 & 1;
}

uint64_t ClosedRange.overlaps(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for Range(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  return Range.overlaps(_:)(v4, v5, v6, v7) & 1;
}

uint64_t Range.overlaps(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = a1;
  uint64_t v28 = a1;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = *(void *)(a2 + 24);
  uint64_t v10 = type metadata accessor for ClosedRange(0LL, v8, v9, a4);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v28 - v13;
  uint64_t v15 = *(void *)(a2 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v12);
  unint64_t v31 = (char *)&v28 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v28 - v19;
  LOBYTE(v7) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 16))( v7 + *(int *)(v18 + 36),  v5,  v8,  v9);
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v15 + 16);
  uint64_t v33 = v5;
  __int128 v29 = v21;
  uint64_t v30 = v15;
  v21(v20, v5, a2);
  uint64_t v32 = v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, v28, v10);
  if ((v7 & 1) != 0) {
    char v22 = 1;
  }
  else {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v9 + 24))(&v20[*(int *)(a2 + 36)], v14, v8, v9);
  }
  uint64_t v23 = v9;
  (*(void (**)(char *, uint64_t))(v32 + 8))(v14, v10);
  char v24 = *(void (**)(char *, uint64_t))(v30 + 8);
  v24(v20, a2);
  char v25 = v31;
  v29(v31, v33, a2);
  if ((v22 & 1) != 0) {
    char v26 = 0;
  }
  else {
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v23 + 8) + 8LL))( v25,  &v25[*(int *)(a2 + 36)],  v8) ^ 1;
  }
  v24(v25, a2);
  return v26 & 1;
}

uint64_t ClosedRange<>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  return ClosedRange<>.init(from:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for ClosedRange,  a5);
}

uint64_t protocol witness for Decodable.init(from:) in conformance <> ClosedRange<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return ClosedRange<>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a2 + 24), *(void **)(a3 - 8), a4);
}

uint64_t ClosedRange<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return ClosedRange<>.encode(to:)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16[3];
  uint64_t v17;
  uint64_t v18;
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 32))(v16, v7, v8);
  uint64_t v9 = v17;
  uint64_t v10 = v18;
  __swift_mutable_project_boxed_opaque_existential_1(v16, v17);
  uint64_t v11 = *(void *)(a2 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 160))(v3, v11, a3, v9, v10);
  if (!v4)
  {
    uint64_t v12 = v3 + *(int *)(a2 + 36);
    uint64_t v13 = v17;
    uint64_t v14 = v18;
    __swift_mutable_project_boxed_opaque_existential_1(v16, v17);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 160))(v12, v11, a3, v13, v14);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v16);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> ClosedRange<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return ClosedRange<>.encode(to:)(a1, a2, *(void *)(a3 - 8));
}

void __EmptyArrayStorage.init(_doNotCallMe:)()
{
}

uint64_t __EmptyArrayStorage._withVerbatimBridgedUnsafeBuffer<A>(_:)@<X0>( uint64_t (*a1)(void, void)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t result = a1(0LL, 0LL);
  if (!v3) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))(a3, 0LL, 1LL, a2);
  }
  return result;
}

void *__EmptyArrayStorage._getNonVerbatimBridgingBuffer()()
{
  unint64_t v0 = type metadata accessor for __BridgingBufferStorage(0LL);
  uint64_t result = swift_bufferAllocate(v0, 0x18uLL, 7uLL);
  result[2] = 0LL;
  return result;
}

uint64_t __EmptyArrayStorage.canStoreElements(ofDynamicType:)()
{
  return 0LL;
}

void *__EmptyArrayStorage.staticElementType.getter()
{
  return &unk_189B8D178;
}

void __EmptyArrayStorage.__allocating_init(_doNotCallMeBase:)()
{
}

void __EmptyArrayStorage.init(_doNotCallMeBase:)()
{
}

uint64_t __EmptyArrayStorage.deinit()
{
  return v0;
}

uint64_t __ContiguousArrayStorageBase.deinit()
{
  return v0;
}

void __EmptyArrayStorage.__deallocating_deinit()
{
}

void __ContiguousArrayStorageBase.__allocating_init()()
{
}

uint64_t __ContiguousArrayStorageBase.withUnsafeBufferOfObjects<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v11 = type metadata accessor for Optional(0LL, a3, a3, a4);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v17 - v13;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 112LL))(a1, a2, a3);
  if (!v6)
  {
    uint64_t v16 = *(void *)(a3 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48))(v14, 1LL, a3) == 1)
    {
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v14, v11);
      __break(1u);
    }

    else
    {
      return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v16 + 32))(a5, v14, a3);
    }
  }

  return result;
}

void __StaticArrayStorage.init(_doNotCallMe:)()
{
}

void __StaticArrayStorage._getNonVerbatimBridgingBuffer()()
{
}

void __StaticArrayStorage.staticElementType.getter()
{
}

void __StaticArrayStorage.__allocating_init(_doNotCallMeBase:)()
{
}

void __StaticArrayStorage.init(_doNotCallMeBase:)()
{
}

uint64_t __StaticArrayStorage.deinit()
{
  return v0;
}

uint64_t *_ContiguousArrayStorage.deinit()
{
  uint64_t v1 = *(void *)(*v0 + 144);
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(v1 - 8) + 80LL);
  swift_arrayDestroy((uint64_t)v0 + ((v2 + 32) & ~v2), v0[2], v1);
  return v0;
}

uint64_t _ContiguousArrayStorage._elementPointer.getter()
{
  uint64_t v1 = *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)v0 + 144LL) - 8LL) + 80LL);
  return v0 + ((v1 + 32) & ~v1);
}

void _ContiguousArrayStorage.__deallocating_deinit()
{
  uint64_t v1 = *(void *)(*v0 + 144);
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(v1 - 8) + 80LL);
  swift_arrayDestroy((uint64_t)v0 + ((v2 + 32) & ~v2), v0[2], v1);
  swift_deallocClassInstance((uint64_t)v0);
}

uint64_t _ContiguousArrayStorage.withUnsafeBufferOfObjects<A>(_:)(uint64_t (*a1)(char *, void))
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)v1 + 144LL) - 8LL) + 80LL);
  return a1(&v1[(v2 + 32) & ~v2], *((void *)v1 + 2));
}

uint64_t UnsafeRawPointer.assumingMemoryBound<A>(to:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t @objc _ContiguousArrayStorage.countByEnumerating(with:objects:count:)( uint64_t a1, uint64_t a2, void *a3)
{
  return specialized _ContiguousArrayStorage.countByEnumerating(with:objects:count:)(a3);
}

Swift::Bool __swiftcall _isValidArraySubscript(_:count:)(Swift::Int _, Swift::Int count)
{
  return _ >= 0 && _ < count;
}

uint64_t UnsafeBufferPointer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return UnsafeBufferPointer.subscript.getter(a1, a2, a3, a4, 0x6F5uLL, 0x6F6uLL, a5);
}

uint64_t @objc _ContiguousArrayStorage.objectAtSubscript(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _ContiguousArrayStorage.objectAtSubscript(_:)(a3);
}

uint64_t _ContiguousArrayStorage.objectAtSubscript(_:)(uint64_t a1)
{
  if (a1 < 0 || v1[2] <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index out of range",  24LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0xBCuLL,  0);
  }
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(*(void *)(*v1 + 144LL) - 8LL) + 80LL);
  return *(void *)((char *)&v1[a1] + ((v2 + 32) & ~v2));
}

uint64_t @objc _ContiguousArrayStorage.objectAt(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _ContiguousArrayStorage.objectAtSubscript(_:)(a3);
}

uint64_t @objc _ContiguousArrayStorage.count.getter()
{
  return _ContiguousArrayStorage.count.getter();
}

uint64_t _ContiguousArrayStorage.count.getter()
{
  return *(void *)(v0 + 16);
}

void *_ContiguousArrayStorage.getObjects(_:range:)(void *result, uint64_t a2, uint64_t a3)
{
  if (a2 < 0 || (uint64_t v4 = v3[2], v4 < a2))
  {
    unint64_t v8 = 219LL;
    goto LABEL_12;
  }

  uint64_t v5 = a2 + a3;
  if (__OFADD__(a2, a3))
  {
    __break(1u);
    goto LABEL_15;
  }

  if (v5 < 0 || v4 < v5)
  {
    unint64_t v8 = 223LL;
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index out of range",  24LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  v8,  0);
  }

  if (v4)
  {
    if ((unint64_t)(a3 - 0x1000000000000000LL) >> 61 == 7)
    {
      size_t v6 = 8 * a3;
      if ((v6 & 0x8000000000000000LL) == 0)
      {
        uint64_t v7 = *(unsigned __int8 *)(*(void *)(*(void *)(*v3 + 144LL) - 8LL) + 80LL);
        return memmove(result, (char *)&v3[a2] + ((v7 + 32) & ~v7), v6);
      }

Swift::Bool __swiftcall _isValidArrayIndex(_:count:)(Swift::Int _, Swift::Int count)
{
  return _ >= 0 && count >= _;
}

BOOL UnsafeBufferPointer.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return a2 == 0;
}

Swift::Void __swiftcall UnsafeMutableRawPointer.copyMemory(from:byteCount:)( Swift::UnsafeRawPointer from, Swift::Int byteCount)
{
  if (byteCount < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
  }
  memmove(v2, from._rawValue, byteCount);
}

void *@objc _ContiguousArrayStorage.getObjects(_:range:)( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  return _ContiguousArrayStorage.getObjects(_:range:)(a3, a4, a5);
}

uint64_t _ContiguousArrayStorage._withVerbatimBridgedUnsafeBuffer<A>(_:)@<X0>( uint64_t (*a1)(char *, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v18[1] = a2;
  uint64_t v19 = a1;
  uint64_t v9 = *(void *)v5;
  uint64_t v10 = type metadata accessor for Optional(0LL, a3, a3, a4);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)v18 - v12;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL);
  v14(a5, 1LL, 1LL, a3);
  uint64_t v15 = *(uint64_t **)(v9 + 144);
  uint64_t result = _swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
  if ((result & 1) != 0)
  {
    (*(void (**)(uint64_t, uint64_t))(v11 + 8))(a5, v10);
    uint64_t v17 = *(unsigned __int8 *)(*(v15 - 1) + 80);
    uint64_t result = v19(&v5[(v17 + 32) & ~v17], *((void *)v5 + 2));
    if (!v6)
    {
      v14((uint64_t)v13, 0LL, 1LL, a3);
      return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v11 + 32))(a5, v13, v10);
    }
  }

  return result;
}

unint64_t _ContiguousArrayStorage._getNonVerbatimBridgingBuffer()(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(*v1 + 144LL);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = *(void *)(v3 + 64);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v21 = (id *)((char *)&v21 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v5);
  uint64_t v7 = (id *)((char *)&v21 - v6);
  unint64_t v8 = v1[2];
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if (v8 >> 60)
  {
    __break(1u);
    goto LABEL_14;
  }

  if (__OFADD__(8 * v8, 24LL))
  {
LABEL_14:
    __break(1u);
    return result;
  }

  char v22 = swift_bufferAllocate(result, 8 * v8 + 24, 7uLL);
  v22[2] = v8;
  if (v8)
  {
    uint64_t v10 = v22 + 3;
    uint64_t v11 = (char *)v1 + ((*(unsigned __int8 *)(v3 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
    uint64_t v12 = *(void *)(v3 + 72);
    uint64_t v13 = *(void (**)(id *, char *, uint64_t *))(v3 + 16);
    do
    {
      v13(v7, v11, v2);
      if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
      {
        if (v4 != 8) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }
        uint64_t v17 = *v7;
        swift_unknownObjectRetain(*v7, v14, v15, v16);
        (*(void (**)(id *, uint64_t *))(v3 + 8))(v7, v2);
      }

      else
      {
        uint64_t v18 = v21;
        (*(void (**)(id *, id *, uint64_t *))(v3 + 32))(v21, v7, v2);
        uint64_t v17 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v18, v2, v19, v20);
      }

      *v10++ = v17;
      v11 += v12;
      --v8;
    }

    while (v8);
  }

  return (unint64_t)v22;
}

BOOL _ContiguousArrayStorage.canStoreElements(ofDynamicType:)(uint64_t *a1)
{
  return swift_dynamicCastMetatype(a1, *(uint64_t **)(*(void *)v1 + 144LL)) != 0LL;
}

uint64_t _ContiguousArrayStorage.staticElementType.getter()
{
  return *(void *)(*(void *)v0 + 144LL);
}

void _ContiguousArrayStorage.init(_doNotCallMeBase:)()
{
}

void __ContiguousArrayStorageBase.init(_doNotCallMeBase:)()
{
}

uint64_t (*_ContiguousArrayBuffer._storage.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Void __swiftcall _ContiguousArrayBuffer._initStorageHeader(count:capacity:)( Swift::Int count, Swift::Int capacity)
{
  uint64_t v4 = v2;
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v3, v3);
  *(void *)(v4 + 16) = count;
  *(void *)(v4 + 24) = isClassOrObjCExistentialType | (unint64_t)(2 * capacity);
}

uint64_t _ContiguousArrayBuffer.arrayPropertyIsNativeTypeChecked.getter()
{
  return 1LL;
}

uint64_t _ContiguousArrayBuffer.withUnsafeMutableBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t, void), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 80LL);
  return a1(*(void *)v3 + ((v4 + 32) & ~v4), *(void *)(*(void *)v3 + 16LL));
}

unint64_t *_ContiguousArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:)( int64_t a1)
{
  else {
    return 0LL;
  }
}

uint64_t key path getter for _ContiguousArrayBuffer.subscript(_:) : <A>_ContiguousArrayBuffer<A>A@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void *)(*(void *)((char *)a2 + a3 - 8) - 8LL);
  return (*(uint64_t (**)(uint64_t, unint64_t))(v4 + 16))( a4,  *a1 + ((*(unsigned __int8 *)(v4 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80))
         + *(void *)(v4 + 72) * *a2);
}

uint64_t key path setter for _ContiguousArrayBuffer.subscript(_:) : <A>_ContiguousArrayBuffer<A>A( uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)((char *)a3 + a4 - 8);
  return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 24LL))( *a2 + ((*(unsigned __int8 *)(*(void *)(v4 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v4 - 8) + 80LL))
         + *(void *)(*(void *)(v4 - 8) + 72LL) * *a3,
           a1,
           v4);
}

void (*_ContiguousArrayBuffer.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(void **a1, char a2)
{
  unint64_t v8 = malloc(0x48uLL);
  *a1 = v8;
  *unint64_t v8 = a2;
  v8[1] = a3;
  uint64_t v9 = *(void *)(a4 - 8);
  v8[2] = a4;
  uint64_t v8[3] = v9;
  size_t v10 = *(void *)(v9 + 64);
  v8[4] = malloc(v10);
  uint64_t v11 = malloc(v10);
  *((_DWORD *)v8 + 16) = *(_DWORD *)(v9 + 80);
  uint64_t v12 = *(void *)(v9 + 72);
  void v8[5] = v11;
  v8[6] = v12;
  uint64_t v13 = *(void (**)(void))(v9 + 16);
  v8[7] = v13;
  v13();
  return _ContiguousArrayBuffer.subscript.modify;
}

void _ContiguousArrayBuffer.subscript.modify(void **a1, char a2)
{
  uint64_t v2 = *a1;
  if ((a2 & 1) != 0)
  {
    uint64_t v3 = (void *)v2[5];
    uint64_t v5 = v2[3];
    uint64_t v4 = (void *)v2[4];
    uint64_t v6 = v2[2];
    (*(void (**)(unint64_t, void *, uint64_t))(v5 + 24))( v2[1] + ((*((unsigned __int8 *)v2 + 64) + 32LL) & ~(unint64_t)*((unsigned __int8 *)v2 + 64)) + *v2 * v2[6],  v3,  v6);
    (*(void (**)(void *, uint64_t))(v5 + 8))(v3, v6);
  }

  else
  {
    uint64_t v7 = (void (*)(void *, unint64_t, uint64_t))v2[7];
    uint64_t v4 = (void *)v2[4];
    uint64_t v3 = (void *)v2[5];
    uint64_t v8 = v2[2];
    uint64_t v9 = v2[3];
    unint64_t v10 = v2[1]
    (*(void (**)(void *, void *, uint64_t))(v9 + 32))(v4, v3, v8);
    v7(v3, v10, v8);
    (*(void (**)(void *, uint64_t))(v9 + 8))(v3, v8);
    (*(void (**)(unint64_t, void *, uint64_t))(v9 + 40))(v10, v4, v8);
  }

  free(v3);
  free(v4);
  free(v2);
}

uint64_t key path getter for _ContiguousArrayBuffer.count : <A>_ContiguousArrayBuffer<A>@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = _ContiguousArrayBuffer.count.getter(*a1);
  *a2 = result;
  return result;
}

uint64_t key path setter for _ContiguousArrayBuffer.count : <A>_ContiguousArrayBuffer<A>( uint64_t *a1, uint64_t *a2)
{
  return _ContiguousArrayBuffer.count.setter(*a1, *a2);
}

void *(*_ContiguousArrayBuffer.count.modify(void *a1, uint64_t a2))(void *result)
{
  *a1 = *(void *)(a2 + 16);
  a1[1] = a2;
  return _ContiguousArrayBuffer.count.modify;
}

void *_ContiguousArrayBuffer.count.modify(void *result)
{
  *(void *)(result[1] + 16LL) = *result;
  return result;
}

uint64_t key path getter for _ContiguousArrayBuffer.mutableCount : <A>_ContiguousArrayBuffer<A>@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(*(void *)result + 16LL);
  return result;
}

void *key path setter for _ContiguousArrayBuffer.mutableCount : <A>_ContiguousArrayBuffer<A>( void *result, uint64_t a2)
{
  *(void *)(*(void *)a2 + 16LL) = *result;
  return result;
}

id key path getter for _ContiguousArrayBuffer.subscript(_:) : <A>_ContiguousArrayBuffer<A>A@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = (void *)specialized _ContiguousArrayBuffer.subscript.getter(*a2, a2[1], *a1);
  *a3 = v4;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

uint64_t key path setter for _ContiguousArrayBuffer.subscript(_:) : <A>_ContiguousArrayBuffer<A>A( void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for _ArrayBuffer.subscript(_:) : <A>_ArrayBuffer<A>A( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void))type metadata accessor for _ContiguousArrayBuffer,  (uint64_t (*)(uint64_t))specialized _ContiguousArrayBuffer.subscript.setter);
}

uint64_t key path setter for _ArrayBuffer.subscript(_:) : <A>_ArrayBuffer<A>A( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void), uint64_t (*a6)(uint64_t))
{
  uint64_t v7 = *a1;
  uint64_t v8 = a5(0LL, *(void *)(a4 + a3 - 8));
  swift_unknownObjectRetain(v7, v9, v10, v11);
  return a6(v8);
}

void _ContiguousArrayBuffer.subscript.setter()
{
}

void (*_ContiguousArrayBuffer.subscript.modify( unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4))(id *a1, char a2)
{
  if (a3 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  uint64_t v6 = *v4;
  uint64_t v7 = *(unsigned __int8 *)(*(void *)(*(void *)(a4 + 16) - 8LL) + 80LL);
  uint64_t v8 = (uint64_t)*v4 + ((v7 + 32) & ~v7);
  *a1 = *v4;
  a1[1] = (unint64_t *)v8;
  a1[2] = (unint64_t *)a2;
  a1[3] = (unint64_t *)((2 * a3) | 1);
  swift_retain(v6, a2, a3, (char *)a4);
  return _ContiguousArrayBuffer.subscript.modify;
}

void _ContiguousArrayBuffer.subscript.modify(id *a1, char a2)
{
}

void *__SwiftDeferredStaticNSArray.__allocating_init(_nativeStorage:)(uint64_t a1)
{
  uint64_t result = swift_allocObject(v1, 0x20uLL, 7uLL);
  result[2] = 0LL;
  result[3] = a1;
  return result;
}

void *__SwiftDeferredNSArray.__allocating_init(_nativeStorage:)(uint64_t a1)
{
  uint64_t result = swift_allocObject(v1, 0x20uLL, 7uLL);
  result[2] = 0LL;
  result[3] = a1;
  return result;
}

uint64_t _ContiguousArrayBuffer.canStoreElements(ofDynamicType:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)a2 + 128LL))() & 1;
}

char *protocol witness for _ArrayBufferProtocol._copyContents(subRange:initializing:) in conformance _ContiguousArrayBuffer<A>( uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v5 = *v4;
  uint64_t v6 = specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)(a1, a2, a3, *v4, *(void *)(a4 + 16));
  swift_release(v5);
  return v6;
}

unint64_t *protocol witness for _ArrayBufferProtocol.requestNativeBuffer() in conformance _ContiguousArrayBuffer<A>()
{
  uint64_t v0 = (unint64_t *)EnumeratedSequence._base.modify();
  return swift_retain(v0, v1, v2, v3);
}

id protocol witness for _ArrayBufferProtocol.subscript.getter in conformance _ContiguousArrayBuffer<A>( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)specialized _ContiguousArrayBuffer.subscript.getter(a1, a2, *v2);
  return swift_unknownObjectRetain(v3, v4, v5, v6);
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:) in conformance _ContiguousArrayBuffer<A>( uint64_t (*a1)(uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _ContiguousArrayBuffer.withUnsafeBufferPointer<A>(_:)(a1, a2, *v4, *(void *)(a4 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:) in conformance _ContiguousArrayBuffer<A>( uint64_t (*a1)(uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _ContiguousArrayBuffer.withUnsafeMutableBufferPointer<A>(_:)(a1, a2, a4);
}

uint64_t protocol witness for _ArrayBufferProtocol.count.setter in conformance _ContiguousArrayBuffer<A>( uint64_t a1)
{
  return _ContiguousArrayBuffer.count.setter(a1, *v1);
}

void *(*protocol witness for _ArrayBufferProtocol.count.modify in conformance _ContiguousArrayBuffer<A>( void *a1))(void *result)
{
  uint64_t v2 = *v1;
  a1[1] = *v1;
  *a1 = *(void *)(v2 + 16);
  return _ContiguousArrayBuffer.count.modify;
}

uint64_t protocol witness for _ArrayBufferProtocol.capacity.getter in conformance _ContiguousArrayBuffer<A>()
{
  return _ContiguousArrayBuffer.capacity.getter(*v0);
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddress.getter in conformance _ContiguousArrayBuffer<A>( uint64_t a1)
{
  return _ContiguousArrayBuffer.firstElementAddress.getter(*v1, *(void *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddressIfContiguous.getter in conformance _ContiguousArrayBuffer<A>( uint64_t a1)
{
  return _ContiguousArrayBuffer.firstElementAddressIfContiguous.getter(*v1, *(void *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.identity.getter in conformance _ContiguousArrayBuffer<A>( uint64_t a1)
{
  return ContiguousArray._baseAddress.getter(*v1, *(void *)(a1 + 16));
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _ContiguousArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *v9;
  uint64_t v11 = *v3;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 32))(v8, a1, v5);
  unint64_t v12 = v11
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v6 + 16))(a1, v12, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5);
  return (*(uint64_t (**)(unint64_t, char *, uint64_t))(v6 + 40))(v12, v8, v5);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _ContiguousArrayBuffer<A>( void *a1, uint64_t *a2, uint64_t a3))(void **a1, char a2)
{
  uint64_t v7 = malloc(0x48uLL);
  *a1 = v7;
  uint64_t v8 = *(void *)(a3 + 16);
  *uint64_t v7 = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  v7[1] = v9;
  size_t v10 = *(void *)(v9 + 64);
  v7[2] = malloc(v10);
  uint64_t v11 = malloc(v10);
  uint64_t v12 = *a2;
  v7[3] = v11;
  _OWORD v7[4] = v12;
  uint64_t v13 = *v3;
  *((_DWORD *)v7 + 16) = *(_DWORD *)(v9 + 80);
  uint64_t v14 = *(void *)(v9 + 72);
  v7[5] = v13;
  v7[6] = v14;
  uint64_t v15 = *(void (**)(void))(v9 + 16);
  v7[7] = v15;
  v15();
  return protocol witness for MutableCollection.subscript.modify in conformance _ContiguousArrayBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _ContiguousArrayBuffer<A>( void **a1, char a2)
{
  uint64_t v2 = *a1;
  if ((a2 & 1) != 0)
  {
    uint64_t v3 = (void *)v2[3];
    uint64_t v4 = (void *)v2[2];
    (*(void (**)(unint64_t, void *, void))(v2[1] + 40LL))( v2[5] + ((*((unsigned __int8 *)v2 + 64) + 32LL) & ~(unint64_t)*((unsigned __int8 *)v2 + 64))
    + v2[4] * v2[6],
      v3,
      *v2);
  }

  else
  {
    uint64_t v5 = (void (*)(void *, unint64_t, uint64_t))v2[7];
    uint64_t v4 = (void *)v2[2];
    uint64_t v3 = (void *)v2[3];
    uint64_t v6 = *v2;
    uint64_t v7 = v2[1];
    unint64_t v8 = v2[5]
    (*(void (**)(void *, void *, void))(v7 + 32))(v4, v3, *v2);
    v5(v3, v8, v6);
    (*(void (**)(void *, uint64_t))(v7 + 8))(v3, v6);
    (*(void (**)(unint64_t, void *, uint64_t))(v7 + 40))(v8, v4, v6);
  }

  free(v3);
  free(v4);
  free(v2);
}

void protocol witness for MutableCollection.subscript.setter in conformance _ContiguousArrayBuffer<A>()
{
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _ContiguousArrayBuffer<A>( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4))(id *a1, char a2)
{
  uint64_t v5 = a2[1];
  if (((unint64_t)v5 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  uint64_t v7 = *a2;
  unint64_t v8 = *v4;
  uint64_t v9 = *(unsigned __int8 *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 80LL);
  uint64_t v10 = (uint64_t)*v4 + ((v9 + 32) & ~v9);
  *a1 = *v4;
  a1[1] = (unint64_t *)v10;
  a1[2] = v7;
  a1[3] = (unint64_t *)((2LL * (void)v5) | 1);
  swift_retain(v8, (uint64_t)a2, a3, a4);
  return protocol witness for MutableCollection.subscript.modify in conformance _ContiguousArrayBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _ContiguousArrayBuffer<A>( id *a1, char a2)
{
  if ((a2 & 1) == 0) {
    swift_unknownObjectRelease(*a1);
  }
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x304uLL,  0);
}

void *protocol witness for MutableCollection.partition(by:) in conformance _ContiguousArrayBuffer<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

uint64_t += infix<A, B>(_:_:)(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v55 = a3;
  uint64_t v51 = type metadata accessor for Optional(0LL, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v53 = *(void *)(v51 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v51);
  uint64_t v11 = (char *)&v45 - v10;
  uint64_t v12 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = *(const char **)(a5 + 8);
  size_t v49 = (char *)&v45 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int64_t v50 = v14;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v14,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v48 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v45 - v15;
  uint64_t v47 = a1;
  uint64_t v16 = *a1;
  uint64_t v17 = *(void *)(*a1 + 16);
  uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 112);
  uint64_t v56 = a2;
  uint64_t result = v18(a4, a5);
  uint64_t v22 = v17 + result;
  if (__OFADD__(v17, result))
  {
    __break(1u);
  }

  else
  {
    unint64_t v20 = *(void *)(v16 + 24);
    unint64_t v21 = v20 >> 1;
    if ((uint64_t)(v20 >> 1) >= v22)
    {
      uint64_t v23 = v18;
      uint64_t v24 = v17;
      uint64_t v45 = v11;
      uint64_t v25 = a5;
      uint64_t v26 = *(v55 - 1);
      uint64_t v27 = *(unsigned __int8 *)(v26 + 80);
      uint64_t v28 = *(void *)(v26 + 72);
      uint64_t v29 = v23(a4, v25);
      if (v29 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
      }
      uint64_t v46 = (__objc2_class **)v29;
      uint64_t v47 = (uint64_t *)v26;
      uint64_t v30 = v16 + ((v27 + 32) & ~v27) + v28 * v24;
      *(void *)(v16 + 16) = v22;
      uint64_t v11 = v45;
      goto LABEL_5;
    }
  }

  if ((uint64_t)(v21 + 0x4000000000000000LL) < 0)
  {
    __break(1u);
    return result;
  }

  unint64_t v38 = v55;
  uint64_t v46 = _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v17 + result, v20 & 0xFFFFFFFFFFFFFFFELL, v55);
  uint64_t v39 = *(v38 - 1);
  unint64_t v40 = (*(unsigned __int8 *)(v39 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v39 + 80);
  unint64_t v41 = (char *)v46 + v40;
  UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v16 + v40), v17, (char *)v46 + v40, (uint64_t)v38);
  *(void *)(v16 + 16) = 0LL;
  swift_release(v16);
  *uint64_t v47 = (uint64_t)v46;
  uint64_t v47 = (uint64_t *)v39;
  uint64_t v42 = (uint64_t)&v41[*(void *)(v39 + 72) * v17];
  uint64_t v43 = v18(a4, a5);
  uint64_t v30 = UnsafeMutableBufferPointer.init(start:count:)(v42, v43);
  uint64_t v46 = v44;
LABEL_5:
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v49, v56, a4);
  uint64_t v31 = (uint64_t)v50;
  uint64_t v32 = v46;
  uint64_t v33 = (*((uint64_t (**)(char *, uint64_t, __objc2_class **, uint64_t, const char *))v50 + 8))( v54,  v30,  v46,  a4,  v50);
  uint64_t v34 = v31;
  unint64_t v35 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v34,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( v35,  AssociatedConformanceWitness);
  int v37 = ((uint64_t (*)(char *, uint64_t, uint64_t *))v47[6])(v11, 1LL, v55);
  (*(void (**)(char *, uint64_t))(v53 + 8))(v11, v51);
  if (v37 != 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "rhs underreported its count",  27LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x3F9uLL,  0);
  }
  if ((__objc2_class **)v33 != v32) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "rhs overreported its count",  26LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x3FAuLL,  0);
  }
  (*(void (**)(uint64_t, uint64_t))(v12 + 8))(v56, a4);
  return (*(uint64_t (**)(char *, unint64_t))(v48 + 8))(v54, v35);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _ContiguousArrayBuffer<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _ContiguousArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for _ContiguousArrayBuffer<A>,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _ContiguousArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _ContiguousArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _ContiguousArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance _ContiguousArrayBuffer<A>@<X0>( Swift::Int *a1@<X8>)
{
  Swift::Int result = ContiguousArray._getCount()();
  *a1 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _ContiguousArrayBuffer<A>( void *a1))()
{
  uint64_t v2 = malloc(0x28uLL);
  *a1 = v2;
  v2[4] = _ContiguousArrayBuffer.subscript.read();
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*_ContiguousArrayBuffer.subscript.read())(void, void)
{
  return EnumeratedSequence._base.modify;
}

id protocol witness for Collection.subscript.getter in conformance _ContiguousArrayBuffer<A>@<X0>( uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (void *)specialized _ContiguousArrayBuffer.subscript.getter(*a1, a1[1], *v2);
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

uint64_t protocol witness for Collection.indices.getter in conformance _ContiguousArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.count.getter in conformance _ContiguousArrayBuffer<A>()
{
  return _ContiguousArrayBuffer.count.getter(*v0);
}

uint64_t protocol witness for Collection.index(after:) in conformance _ContiguousArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance _ContiguousArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for _ContiguousArrayBuffer<A>,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _ContiguousArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _ContiguousArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, void, void))_ContiguousArrayBuffer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _ArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, void, void))
{
  *a1 = a6(a2, a3, *v6, *(void *)(a4 + 16));
  a1[1] = v8;
  return v9;
}

void specialized _copySequenceToContiguousArray<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = &_swiftEmptyArrayStorage;
  swift_bridgeObjectRetain((unint64_t)a4, a2, a3, a4);
  unint64_t v5 = specialized Unicode._InternalNFD.Iterator.next()();
  if ((v5 & 0x1000000000000LL) == 0)
  {
    int v6 = v5;
    unint64_t v7 = 0LL;
    uint64_t v8 = &_swiftEmptySetSingleton;
    while (1)
    {
      if (!v7)
      {
        unint64_t v9 = (unint64_t)v4[3];
        int64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
        if (v10 <= 1) {
          uint64_t v11 = 1LL;
        }
        else {
          uint64_t v11 = v10;
        }
        uint64_t v12 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Unicode.Scalar>();
        uint64_t v13 = (__objc2_class **)swift_allocObject(v12, 4 * v11 + 32, 7uLL);
        int64_t v14 = _swift_stdlib_malloc_size(v13);
        uint64_t v15 = v14 - 32;
        if (v14 < 32) {
          uint64_t v15 = v14 - 29;
        }
        uint64_t v16 = v15 >> 2;
        void v13[2] = (__objc2_class *)v11;
        uint64_t v13[3] = (__objc2_class *)(2 * (v15 >> 2));
        unint64_t v17 = (unint64_t)(v13 + 4);
        unint64_t v18 = (unint64_t)v4[3] >> 1;
        if (v4[2])
        {
          v4[2] = 0LL;
        }

        uint64_t v8 = (__objc2_class **)(v17 + 4 * v18);
        unint64_t v7 = (v16 & 0x7FFFFFFFFFFFFFFFLL) - v18;
        swift_release((uint64_t)v4);
        uint64_t v4 = v13;
      }

      BOOL v20 = __OFSUB__(v7--, 1LL);
      if (v20) {
        break;
      }
      *(_DWORD *)uint64_t v8 = v6;
      uint64_t v8 = (__objc2_class **)((char *)v8 + 4);
      unint64_t v21 = specialized Unicode._InternalNFD.Iterator.next()();
      int v6 = v21;
      if ((v21 & 0x1000000000000LL) != 0) {
        goto LABEL_23;
      }
    }

    __break(1u);
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }

  unint64_t v7 = 0LL;
LABEL_23:
  swift_bridgeObjectRelease((uint64_t)a4);
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  unint64_t v22 = (unint64_t)v4[3];
  if (v22 >= 2)
  {
    unint64_t v23 = v22 >> 1;
    BOOL v20 = __OFSUB__(v23, v7);
    uint64_t v24 = (__objc2_class *)(v23 - v7);
    if (v20)
    {
LABEL_29:
      __break(1u);
      return;
    }

    v4[2] = v24;
  }

{
  __objc2_class **v4;
  char v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  __objc2_class **v9;
  __objc2_class **v10;
  __objc2_class *v11;
  unint64_t v12;
  __objc2_class *v13;
  __objc2_class *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  __objc2_class **v18;
  char *v19;
  unint64_t Composition;
  unint64_t v21;
  __int16 v22;
  __objc2_class *v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  __objc2_class **v27;
  int64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  unint64_t v36;
  __objc2_class **v37;
  char *v38;
  BOOL v39;
  unint64_t v40;
  int64_t v41;
  uint64_t v42;
  uint64_t v43;
  __objc2_class **v44;
  int64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  const void *v50;
  BOOL v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  __objc2_class *v55;
  unint64_t v56;
  __objc2_class **v57;
  int v58;
  __objc2_class **v59;
  __objc2_class **v60;
  BOOL v61;
  __objc2_class **v62;
  uint64_t v4 = &_swiftEmptyArrayStorage;
  unint64_t v62 = &_swiftEmptyArrayStorage;
  unint64_t v5 = 1;
  swift_bridgeObjectRetain((unint64_t)a4, a2, a3, a4);
  int v6 = 0LL;
  unint64_t v7 = 0LL;
  uint64_t v8 = 0;
  unint64_t v9 = &_swiftEmptySetSingleton;
  int64_t v10 = &_swiftEmptyArrayStorage;
LABEL_2:
  uint64_t v11 = v10[2];
  unint64_t v61 = v11 != 0LL;
  if (v11)
  {
    uint64_t v12 = (unint64_t)&v11[-1].info + 7;
    if (v8 & 1 | (v11 == (__objc2_class *)1)) {
      goto LABEL_4;
    }
    uint64_t v56 = v6;
    unint64_t v57 = v4;
    uint64_t v29 = 0LL;
    uint64_t v30 = 8LL * (void)v11 + 24;
    uint64_t v31 = 1LL;
    while (1)
    {
      uint64_t v32 = (unint64_t)v10[2];
      if (v31 - 1 >= v32 || v12 >= v32) {
        break;
      }
      unint64_t v60 = v9;
      char v58 = (int)v10[v29 + 4];
      uint64_t v33 = WORD2(v10[v29 + 4]);
      uint64_t v34 = *(_DWORD *)((char *)v10 + v30);
      unint64_t v35 = *(_WORD *)((char *)v10 + v30 + 4);
      Swift::String::Index v36 = (unint64_t)v10[2];
      if (v31 - 1 >= v36) {
        goto LABEL_97;
      }
      int v37 = &v10[v29];
      *((_DWORD *)v37 + 8) = v34;
      *((_WORD *)v37 + 18) = v35;
      if (v12 >= v36) {
        goto LABEL_97;
      }
      unint64_t v38 = (char *)v10 + v30;
      *(_DWORD *)unint64_t v38 = v58;
      *((_WORD *)v38 + 2) = v33;
      --v12;
      v30 -= 8LL;
      ++v29;
      uint64_t v39 = v31++ < (uint64_t)v12;
      unint64_t v9 = v60;
      if (!v39)
      {
        int v6 = v56;
        uint64_t v4 = v57;
        unint64_t v7 = v7;
        if (!v10[2]) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x363uLL,  0);
        }
LABEL_4:
        if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v10))
        {
          uint64_t v13 = v10[2];
          if (v13) {
            goto LABEL_6;
          }
LABEL_89:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty Array",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x51CuLL,  0);
        }

        int64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v10);
        uint64_t v13 = v10[2];
        if (!v13) {
          goto LABEL_89;
        }
LABEL_6:
        int64_t v14 = (__objc2_class *)((char *)v13 - 1);
        LODWORD(v15) = v10[(void)v14 + 4];
        void v10[2] = v14;
        unint64_t v62 = v10;
        if (v6)
        {
          uint64_t v8 = 1;
          uint64_t v16 = v7;
          goto LABEL_84;
        }

        uint64_t v16 = v7;
LABEL_72:
        unint64_t v40 = (unint64_t)v4[3];
        if ((uint64_t)((v40 >> 1) + 0x4000000000000000LL) >= 0)
        {
          unint64_t v41 = v40 & 0xFFFFFFFFFFFFFFFELL;
          if (v41 <= 1) {
            uint64_t v42 = 1LL;
          }
          else {
            uint64_t v42 = v41;
          }
          uint64_t v43 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Unicode.Scalar>();
          uint64_t v44 = (__objc2_class **)swift_allocObject(v43, 4 * v42 + 32, 7uLL);
          uint64_t v45 = _swift_stdlib_malloc_size(v44);
          uint64_t v46 = v45 - 32;
          if (v45 < 32) {
            uint64_t v46 = v45 - 29;
          }
          uint64_t v47 = v46 >> 2;
          v44[2] = (__objc2_class *)v42;
          v44[3] = (__objc2_class *)(2 * (v46 >> 2));
          uint64_t v48 = (unint64_t)(v44 + 4);
          size_t v49 = (unint64_t)v4[3] >> 1;
          if (v4[2])
          {
            int64_t v50 = v4 + 4;
            v4[2] = 0LL;
          }

          unint64_t v9 = (__objc2_class **)(v48 + 4 * v49);
          int v6 = (v47 & 0x7FFFFFFFFFFFFFFFLL) - v49;
          swift_release((uint64_t)v4);
          uint64_t v4 = v44;
          uint64_t v8 = v61;
          goto LABEL_84;
        }

        __break(1u);
LABEL_99:
        __break(1u);
        return;
      }
    }

    uint64_t v52 = 675LL;
    goto LABEL_91;
  }

  unint64_t v17 = specialized Unicode._InternalNFD.Iterator.next()();
  if ((v17 & 0x1000000000000LL) == 0)
  {
    uint64_t v15 = v17;
    uint64_t v59 = v9;
    unint64_t v18 = v4;
    uint64_t v16 = v7;
    while (1)
    {
      uint64_t v19 = (char *)v10 + 36;
      if ((v5 & 1) != 0)
      {
        if ((v15 & 0x7F800000000LL) == 0)
        {
          Composition = v15;
LABEL_13:
          unint64_t v21 = specialized Unicode._InternalNFD.Iterator.next()();
          if ((v21 & 0x1000000000000LL) == 0)
          {
            uint64_t v15 = v21;
            do
            {
              uint64_t v16 = Composition;
              unint64_t v22 = WORD2(v15);
              unint64_t v23 = v10[2];
              if (v23)
              {
                uint64_t v24 = (v15 >> 35);
                if ((v15 & 0x600000000LL) == 0) {
                  goto LABEL_38;
                }
                Composition = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v16, v15);
                if ((Composition & 0x100000000LL) != 0)
                {
                  Composition = _swift_stdlib_getComposition(v16, v15);
                  if ((_DWORD)Composition == -1) {
                    goto LABEL_38;
                  }
                }
              }

              else
              {
                if ((v15 & 0x600000000LL) == 0) {
                  goto LABEL_37;
                }
                Composition = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v16, v15);
                if ((Composition & 0x100000000LL) != 0)
                {
                  Composition = _swift_stdlib_getComposition(v16, v15);
                  if ((_DWORD)Composition == -1) {
                    goto LABEL_37;
                  }
                }
              }

              uint64_t v15 = specialized Unicode._InternalNFD.Iterator.next()();
            }

            while ((v15 & 0x1000000000000LL) == 0);
          }

          uint64_t v15 = 0LL;
          unint64_t v5 = 1;
          LODWORD(v16) = Composition;
          uint64_t v4 = v18;
LABEL_70:
          LODWORD(v7) = v16;
          uint64_t v16 = v15;
          unint64_t v9 = v59;
          if (!v6)
          {
LABEL_71:
            LODWORD(v15) = v7;
            goto LABEL_72;
          }

LABEL_39:
      uint64_t v26 = (unint64_t)v10[2];
      uint64_t v25 = (unint64_t)v10[3];
      if (v26 >= v25 >> 1) {
        int64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v25 > 1),  v26 + 1,  1,  (uint64_t)v10);
      }
      void v10[2] = (__objc2_class *)(v26 + 1);
      uint64_t v27 = &v10[v26];
      *((_DWORD *)v27 + 8) = v15;
      *((_WORD *)v27 + 18) = v22;
      unint64_t v62 = v10;
      uint64_t v15 = specialized Unicode._InternalNFD.Iterator.next()();
      unint64_t v5 = 0;
      if ((v15 & 0x1000000000000LL) != 0)
      {
        uint64_t v15 = 0LL;
        unint64_t v5 = 1;
        uint64_t v4 = v18;
        goto LABEL_70;
      }
    }

    if ((v15 & 0x600000000LL) != 0 && v15 >= 0x300)
    {
      Composition = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v16, v15);
      if ((Composition & 0x100000000LL) == 0) {
        goto LABEL_13;
      }
      Composition = _swift_stdlib_getComposition(v16, v15);
      if ((_DWORD)Composition != -1) {
        goto LABEL_13;
      }
    }

  __break(1u);
LABEL_40:
  __break(1u);
LABEL_41:
  __break(1u);
}

      uint64_t v33 = v9[2];
      uint64_t v32 = (unint64_t)v9[3];
      if ((unint64_t)v33 >= v32 >> 1) {
        unint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v32 > 1),  (int64_t)&v33->isa + 1,  1,  (uint64_t)v9);
      }
      void v9[2] = (__objc2_class *)((char *)&v33->isa + 1);
      *((_BYTE *)&v33->info + (void)v9) = v31;
      if (!(v8 | v7)) {
        goto LABEL_13;
      }
    }
  }

  return 48LL;
}

          v213(v122, a4);
LABEL_40:
          char v123 = v215;
          uint64_t v124 = v114(a4, a6);
          v116(v84, (uint64_t)v123, (uint64_t)a4);
          if (v124 < 65)
          {
            unint64_t v125 = v114(a4, a6);
            unint64_t v126 = v213;
            v213(v84, a4);
            if (v125 != 64 || (v74(a4, a6) & 1) != 0) {
              goto LABEL_56;
            }
          }

          else
          {
            v213(v84, a4);
          }

          unint64_t v127 = v209;
          id v128 = v229;
          v229(v209, (uint64_t)v215, (uint64_t)a4);
          v232[0] = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v129 = v74(a4, a6);
          uint64_t v130 = v114(a4, a6);
          if ((v129 & 1) != 0)
          {
            if (v130 > 64)
            {
              unint64_t v133 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
              unint64_t v134 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
              int64_t v135 = v232;
LABEL_54:
              v133(v135, &type metadata for Int, v134, a4, a6);
              unint64_t v137 = (*(uint64_t (**)(uint64_t, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v56,  v127,  a4);
              char v138 = v127;
              unint64_t v126 = v213;
              v213((char *)v56, a4);
              if ((v137 & 1) != 0) {
                goto LABEL_89;
              }
              v126(v138, a4);
              goto LABEL_56;
            }
          }

          else if (v130 > 63)
          {
            unint64_t v231 = 0x7FFFFFFFFFFFFFFFLL;
            unint64_t v133 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
            unint64_t v134 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
            int64_t v135 = &v231;
            goto LABEL_54;
          }

          v128((char *)v56, (uint64_t)v127, (uint64_t)a4);
          (*(void (**)(void *, uint64_t))(a6 + 120))(a4, a6);
          unint64_t v136 = v127;
          unint64_t v126 = v213;
          v213((char *)v56, a4);
          v126(v136, a4);
LABEL_56:
          uint64_t v139 = v215;
          uint64_t v222 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
          v126(v139, a4);
          uint64_t v44 = v223;
          goto LABEL_57;
        }

        unint64_t v85 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
        Swift::String::Index v86 = v229;
        v85((char *)v56, (uint64_t)v229, (uint64_t)a4);
        Swift::String::Index v87 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
        v213((char *)v56, a4);
        unint64_t v60 = v73 < v87;
        uint64_t v82 = v86;
        uint64_t v84 = v212;
        if (v60) {
          goto LABEL_52;
        }
        goto LABEL_32;
      }

      (*(void (**)(uint64_t, void, void (*)(char *, uint64_t)))(v24 + 16))(v222, v229, a4);
      unint64_t v72 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
      char v58 = *(void (**)(char *, void *))(v24 + 8);
      v58((char *)v56, a4);
      unint64_t v60 = v72 < v49;
      goto LABEL_15;
    }

    uint64_t v56 = v222;
    if (v62 <= 64)
    {
      Swift::String::Index v88 = v208;
      Swift::String::Index v89 = v207;
      uint64_t v90 = swift_getAssociatedConformanceWitness( (uint64_t)v208,  (uint64_t)a4,  v207,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v91 = v206;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v90 + 8))( &unk_18180BE68,  256LL,  v89,  v90);
      (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v88 + 3))(v91, a4, v88);
      uint64_t v92 = v229;
      LOBYTE(v89) = (*(uint64_t (**)(void, uint64_t, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v229,  v56,  a4);
      char v58 = *(void (**)(char *, void *))(v24 + 8);
      v58((char *)v56, a4);
      (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v24 + 16))(v44, v92, a4);
      if ((v89 & 1) != 0)
      {
        v58(v44, a4);
        uint64_t v44 = v223;
        unint64_t v71 = v225;
        goto LABEL_28;
      }

      unint64_t v57 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
      uint64_t v59 = v44;
      goto LABEL_5;
    }

    v232[0] = v49;
    uint64_t v65 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
    size_t v66 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
    v65(v232, &type metadata for Int, v66, a4, a6);
    unint64_t v67 = (*(uint64_t (**)(void, uint64_t, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                           + 16LL))( v229,  v56,  a4);
LABEL_10:
    uint64_t v70 = v67;
    char v58 = *(void (**)(char *, void *))(v24 + 8);
    v58((char *)v56, a4);
    uint64_t v44 = v223;
    unint64_t v71 = v225;
    if ((v70 & 1) == 0) {
      goto LABEL_16;
    }
    goto LABEL_28;
  }

  uint64_t v52 = v229;
  uint64_t v214 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
  uint64_t v53 = v214(a4, a6);
  if (v53 >= 64)
  {
    v232[0] = v49;
    uint64_t v68 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
    uint64_t v69 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    uint64_t v56 = v222;
    v68(v232, &type metadata for Int, v69, a4, a6);
    unint64_t v67 = (*(uint64_t (**)(void, uint64_t, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                           + 16LL))( v52,  v56,  a4);
    goto LABEL_10;
  }

  uint64_t v56 = v222;
  (*(void (**)(uint64_t, void, void (*)(char *, uint64_t)))(v24 + 16))(v222, v52, a4);
  unint64_t v57 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
  char v58 = *(void (**)(char *, void *))(v24 + 8);
  uint64_t v59 = (char *)v56;
LABEL_5:
  v58(v59, a4);
  unint64_t v60 = v57 < v49;
  uint64_t v44 = v223;
LABEL_15:
  unint64_t v71 = v225;
  if (!v60) {
    goto LABEL_16;
  }
LABEL_28:
  unint64_t v99 = v230(a3, v44);
  if (__OFSUB__(0LL, v99))
  {
    __break(1u);
LABEL_88:
    __break(1u);
LABEL_89:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

  uint64_t v222 = -v99;
  unint64_t v100 = v228;
LABEL_58:
  uint64_t v140 = v219;
  unint64_t v141 = *(void (**)(char *, uint64_t, uint64_t))(v219 + 32);
  v141(v100, v227, a3);
  a6 = v221;
  unint64_t v142 = (*(uint64_t (**)(uint64_t, uint64_t))(v221 + 64))(a3, v221);
  unint64_t v143 = v220;
  unint64_t v229 = v141;
  if ((v142 & 1) != 0)
  {
    unint64_t v144 = v230(a3, v44);
    if (!__OFSUB__(v144, 1LL))
    {
      v232[0] = v144 - 1;
      Swift::String::Index v147 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      Swift::String::Index v148 = lazy protocol witness table accessor for type Int and conformance Int(v144, v145, v146);
      unint64_t v149 = v224;
      v147(v232, &type metadata for Int, v148, a3, a6);
      (*((void (**)(char *, char *, uint64_t, char *))v44 + 25))(v100, v149, a3, v44);
      unint64_t v150 = v149;
      size_t v49 = (uint64_t)v225;
      (*(void (**)(char *, uint64_t))(v140 + 8))(v150, a3);
      unint64_t v151 = AssociatedTypeWitness;
      unint64_t v152 = swift_getAssociatedConformanceWitness( (uint64_t)v143,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v153 = v217;
      goto LABEL_62;
    }

    goto LABEL_88;
  }

  unint64_t v154 = (uint64_t)v71;
  unint64_t v155 = AssociatedTypeWitness;
  unint64_t v152 = swift_getAssociatedConformanceWitness( (uint64_t)v220,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v153 = v217;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v152 + 8))( &unk_18180BE68,  256LL,  v155,  v152);
  (*((void (**)(char *, uint64_t, const char *))v143 + 3))(v153, a3, v143);
  unint64_t v151 = v155;
  size_t v49 = v154;
LABEL_62:
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v152 + 8))( &unk_18180BE68,  256LL,  v151,  v152);
  (*((void (**)(char *, uint64_t, const char *))v143 + 3))(v153, a3, v143);
  a4 = *(void (**)(char *, uint64_t))(v140 + 8);
  unint64_t v21 = v222;
  if (v222 < 0)
  {
LABEL_82:
    a4(v226, a3);
    unint64_t v194 = v230(a3, v44);
    char v157 = v228;
    if (__OFSUB__(0LL, v194))
    {
      __break(1u);
    }

    else if (-v194 < v21)
    {
      unint64_t v195 = ((uint64_t (*)(uint64_t, uint64_t))a4)(v49, a3);
      v232[0] = -v21;
      unint64_t v196 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      Swift::String::Index v199 = lazy protocol witness table accessor for type Int and conformance Int(v195, v197, v198);
      Swift::String::Index v163 = v224;
      v196(v232, &type metadata for Int, v199, a3, a6);
      Swift::Int v164 = (void (*)(char *, char *, uint64_t, char *))*((void *)v44 + 27);
      goto LABEL_65;
    }

    a4(v157, a3);
    Swift::String::Index v201 = (char *)v49;
    Swift::String::Index v165 = v216;
    Swift::String::Index v200 = v216;
LABEL_86:
    Swift::String::Index v166 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v229;
    v229((char *)v200, (uint64_t)v201, a3);
    return v166(v227, v165, a3);
  }

  a4((char *)v49, a3);
  unint64_t v156 = v230(a3, v44);
  char v157 = v228;
  if (v21 >= v156)
  {
    a4(v228, a3);
    Swift::String::Index v165 = v216;
    Swift::String::Index v200 = v216;
    Swift::String::Index v201 = v226;
    goto LABEL_86;
  }

  unint64_t v158 = ((uint64_t (*)(char *, uint64_t))a4)(v226, a3);
  v232[0] = v21;
  unint64_t v159 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  Swift::String::Index v162 = lazy protocol witness table accessor for type Int and conformance Int(v158, v160, v161);
  Swift::String::Index v163 = v224;
  v159(v232, &type metadata for Int, v162, a3, a6);
  Swift::Int v164 = (void (*)(char *, char *, uint64_t, char *))*((void *)v44 + 25);
LABEL_65:
  Swift::String::Index v165 = v216;
  v164(v157, v163, a3, v44);
  a4(v163, a3);
  a4(v157, a3);
  Swift::String::Index v166 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v229;
  return v166(v227, v165, a3);
}

          v213(v122, a4);
LABEL_40:
          char v123 = v215;
          uint64_t v124 = v114(a4, a6);
          v116(v84, (uint64_t)v123, (uint64_t)a4);
          if (v124 < 65)
          {
            unint64_t v125 = v114(a4, a6);
            unint64_t v126 = v213;
            v213(v84, a4);
            if (v125 != 64 || (v74(a4, a6) & 1) != 0) {
              goto LABEL_56;
            }
          }

          else
          {
            v213(v84, a4);
          }

          unint64_t v127 = v209;
          id v128 = v229;
          v229(v209, (uint64_t)v215, (uint64_t)a4);
          v232[0] = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v129 = v74(a4, a6);
          uint64_t v130 = v114(a4, a6);
          if ((v129 & 1) != 0)
          {
            if (v130 > 64)
            {
              unint64_t v133 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
              unint64_t v134 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
              int64_t v135 = v232;
LABEL_54:
              v133(v135, &type metadata for Int, v134, a4, a6);
              unint64_t v137 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v56,  v127,  a4);
              char v138 = v127;
              unint64_t v126 = v213;
              v213(v56, a4);
              if ((v137 & 1) != 0) {
                goto LABEL_89;
              }
              v126(v138, a4);
              goto LABEL_56;
            }
          }

          else if (v130 > 63)
          {
            unint64_t v231 = 0x7FFFFFFFFFFFFFFFLL;
            unint64_t v133 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
            unint64_t v134 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
            int64_t v135 = &v231;
            goto LABEL_54;
          }

          v128(v56, (uint64_t)v127, (uint64_t)a4);
          (*(void (**)(void *, uint64_t))(a6 + 120))(a4, a6);
          unint64_t v136 = v127;
          unint64_t v126 = v213;
          v213(v56, a4);
          v126(v136, a4);
LABEL_56:
          uint64_t v139 = v215;
          unint64_t v21 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
          v126(v139, a4);
          uint64_t v44 = v222;
          goto LABEL_57;
        }

        unint64_t v85 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
        Swift::String::Index v86 = v229;
        v85(v56, (uint64_t)v229, (uint64_t)a4);
        Swift::String::Index v87 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
        v213(v56, a4);
        unint64_t v60 = v73 < v87;
        uint64_t v82 = v86;
        uint64_t v84 = v212;
        if (v60) {
          goto LABEL_52;
        }
        goto LABEL_32;
      }

      (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v24 + 16))(v221, v229, a4);
      unint64_t v72 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
      char v58 = *(void (**)(char *, void *))(v24 + 8);
      v58(v56, a4);
      unint64_t v60 = v72 < v49;
      goto LABEL_15;
    }

    uint64_t v56 = v221;
    if (v62 <= 64)
    {
      Swift::String::Index v88 = v208;
      Swift::String::Index v89 = v207;
      uint64_t v90 = swift_getAssociatedConformanceWitness( (uint64_t)v208,  (uint64_t)a4,  v207,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v91 = v206;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v90 + 8))( &unk_18180BE68,  256LL,  v89,  v90);
      (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v88 + 3))(v91, a4, v88);
      uint64_t v92 = v229;
      LOBYTE(v89) = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v229,  v56,  a4);
      char v58 = *(void (**)(char *, void *))(v24 + 8);
      v58(v56, a4);
      (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v24 + 16))(v44, v92, a4);
      if ((v89 & 1) != 0)
      {
        v58(v44, a4);
        uint64_t v44 = v222;
        unint64_t v71 = v224;
        goto LABEL_28;
      }

      unint64_t v57 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
      uint64_t v59 = v44;
      goto LABEL_5;
    }

    v232[0] = v49;
    uint64_t v65 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
    size_t v66 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
    v65(v232, &type metadata for Int, v66, a4, a6);
    unint64_t v67 = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                          + 16LL))( v229,  v56,  a4);
LABEL_10:
    uint64_t v70 = v67;
    char v58 = *(void (**)(char *, void *))(v24 + 8);
    v58(v56, a4);
    uint64_t v44 = v222;
    unint64_t v71 = v224;
    if ((v70 & 1) == 0) {
      goto LABEL_16;
    }
    goto LABEL_28;
  }

  uint64_t v52 = v229;
  uint64_t v214 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
  uint64_t v53 = v214(a4, a6);
  if (v53 >= 64)
  {
    v232[0] = v49;
    uint64_t v68 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
    uint64_t v69 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    uint64_t v56 = v221;
    v68(v232, &type metadata for Int, v69, a4, a6);
    unint64_t v67 = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                          + 16LL))( v52,  v56,  a4);
    goto LABEL_10;
  }

  uint64_t v56 = v221;
  (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v24 + 16))(v221, v52, a4);
  unint64_t v57 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
  char v58 = *(void (**)(char *, void *))(v24 + 8);
  uint64_t v59 = v56;
LABEL_5:
  v58(v59, a4);
  unint64_t v60 = v57 < v49;
  uint64_t v44 = v222;
LABEL_15:
  unint64_t v71 = v224;
  if (!v60) {
    goto LABEL_16;
  }
LABEL_28:
  unint64_t v99 = v230(a3, v44);
  unint64_t v21 = -v99;
  if (__OFSUB__(0LL, v99))
  {
    __break(1u);
LABEL_88:
    __break(1u);
LABEL_89:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

  unint64_t v100 = v227;
LABEL_58:
  uint64_t v140 = v219;
  unint64_t v141 = *(void (**)(char *, uint64_t, uint64_t))(v219 + 32);
  v141(v100, v228, a3);
  a6 = v220;
  unint64_t v142 = (*(uint64_t (**)(uint64_t, uint64_t))(v220 + 64))(a3, v220);
  unint64_t v229 = v141;
  if ((v142 & 1) != 0)
  {
    unint64_t v143 = v230(a3, v44);
    if (!__OFSUB__(v143, 1LL))
    {
      v232[0] = v143 - 1;
      Swift::String::Index v146 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      Swift::String::Index v147 = lazy protocol witness table accessor for type Int and conformance Int(v143, v144, v145);
      Swift::String::Index v148 = v223;
      v146(v232, &type metadata for Int, v147, a3, a6);
      (*((void (**)(char *, char *, uint64_t, char *))v44 + 25))(v100, v148, a3, v44);
      unint64_t v149 = v224;
      (*(void (**)(char *, uint64_t))(v140 + 8))(v148, a3);
      unint64_t v150 = AssociatedTypeWitness;
      unint64_t v151 = swift_getAssociatedConformanceWitness( (uint64_t)v149,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v152 = v217;
      goto LABEL_62;
    }

    goto LABEL_88;
  }

  unint64_t v153 = (uint64_t)v71;
  unint64_t v149 = v71;
  unint64_t v154 = AssociatedTypeWitness;
  unint64_t v151 = swift_getAssociatedConformanceWitness( v153,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v152 = v217;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v151 + 8))( &unk_18180BE68,  256LL,  v154,  v151);
  (*((void (**)(char *, uint64_t, const char *))v149 + 3))(v152, a3, v149);
  unint64_t v150 = v154;
LABEL_62:
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v151 + 8))( &unk_18180BE68,  256LL,  v150,  v151);
  (*((void (**)(char *, uint64_t, const char *))v149 + 3))(v152, a3, v149);
  a4 = *(void (**)(char *, uint64_t))(v140 + 8);
  if (v21 < 0)
  {
LABEL_82:
    a4(v226, a3);
    unint64_t v194 = v230(a3, v44);
    unint64_t v156 = v227;
    char v157 = v228;
    if (__OFSUB__(0LL, v194))
    {
      __break(1u);
    }

    else if (-v194 < v21)
    {
      unint64_t v195 = ((uint64_t (*)(char *, uint64_t))a4)(v225, a3);
      v232[0] = -v21;
      unint64_t v196 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      Swift::String::Index v199 = lazy protocol witness table accessor for type Int and conformance Int(v195, v197, v198);
      Swift::String::Index v163 = v223;
      v196(v232, &type metadata for Int, v199, a3, a6);
      Swift::Int v164 = (void (*)(char *, char *, uint64_t, char *))*((void *)v44 + 25);
      goto LABEL_65;
    }

    a4(v156, a3);
    Swift::String::Index v165 = v216;
    Swift::String::Index v200 = v216;
    Swift::String::Index v201 = v225;
LABEL_86:
    Swift::String::Index v166 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v229;
    v229((char *)v200, (uint64_t)v201, a3);
    return v166(v157, v165, a3);
  }

  a4(v225, a3);
  unint64_t v155 = v230(a3, v44);
  unint64_t v156 = v227;
  char v157 = v228;
  if (v21 >= v155)
  {
    a4(v227, a3);
    Swift::String::Index v165 = v216;
    Swift::String::Index v200 = v216;
    Swift::String::Index v201 = v226;
    goto LABEL_86;
  }

  unint64_t v158 = ((uint64_t (*)(char *, uint64_t))a4)(v226, a3);
  v232[0] = v21;
  unint64_t v159 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  Swift::String::Index v162 = lazy protocol witness table accessor for type Int and conformance Int(v158, v160, v161);
  Swift::String::Index v163 = v223;
  v159(v232, &type metadata for Int, v162, a3, a6);
  Swift::Int v164 = (void (*)(char *, char *, uint64_t, char *))*((void *)v44 + 27);
LABEL_65:
  Swift::String::Index v165 = v216;
  v164(v156, v163, a3, v44);
  a4(v163, a3);
  a4(v156, a3);
  Swift::String::Index v166 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v229;
  return v166(v157, v165, a3);
}

      uint64_t v48 = _StringGuts.nativeUnusedCapacity.getter(v26, a2);
      int64_t v10 = (v49 & 1) == 0 && v48 >= v39;
      if ((v45 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(a2 & 0xFFFFFFFFFFFFFFFLL))
      {
        a1 = v44;
        a4 = v245;
        if ((v10 & 1) != 0)
        {
LABEL_57:
          swift_bridgeObjectRelease(v11);
          if ((v11 & 0x1000000000000000LL) != 0)
          {
            _StringGuts._foreignAppendInPlace(_:)(a1, v11, to, v38);
          }

          else
          {
            if ((v11 & 0x2000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v11);
              uint64_t v92 = HIBYTE(v11) & 0xF;
              Swift::Int v247 = a1;
              uint64_t v248 = v11 & 0xFFFFFFFFFFFFFFLL;
              if (v92 >= v38)
              {
                uint64_t v93 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(to, v38, (uint64_t)&v247, v92);
                _StringGuts.appendInPlace(_:isASCII:)(v93, v94, (v11 & 0x4000000000000000LL) != 0);
                goto LABEL_97;
              }

              goto LABEL_253;
            }

            if ((a1 & 0x1000000000000000LL) != 0)
            {
              unint64_t v55 = (id)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v56 = a1 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              unint64_t v55 = _StringObject.sharedUTF8.getter(a1, v11);
              uint64_t v56 = v230;
            }

            unint64_t v57 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(to, v38, (uint64_t)v55, v56);
            _StringGuts.appendInPlace(_:isASCII:)(v57, v58, (a1 & 0x8000000000000000LL) != 0LL);
          }

          swift_bridgeObjectRelease(v11);
          goto LABEL_97;
        }
      }

      else
      {
        a1 = v44;
        a4 = v245;
        if ((v10 & 1) != 0)
        {
LABEL_56:
          _StringGuts.grow(_:)(v43);
          goto LABEL_57;
        }
      }

      uint64_t v51 = _StringGuts.nativeCapacity.getter(v26, a2);
      if ((v52 & 1) != 0) {
        uint64_t v53 = 0LL;
      }
      else {
        uint64_t v53 = v51;
      }
      if (v53 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_242;
      }

      uint64_t v54 = 2 * v53;
      if (v54 > v43) {
        uint64_t v43 = v54;
      }
      goto LABEL_56;
    }
  }

  else
  {
    if (v43 > 15) {
      goto LABEL_39;
    }
    if ((a2 & 0x2000000000000000LL) == 0) {
      goto LABEL_63;
    }
  }

  swift_bridgeObjectRelease(v11);
  a1 = v249;
  unint64_t v38 = a2;
LABEL_70:
  v67._Swift::UInt64 rawBits = v5 & 0xFFFFFFFFFFFF0000LL | 1;
  v68._Swift::UInt64 rawBits = a3 & 0xFFFFFFFFFFFF0000LL | 1;
  v69._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v67, v68, v44, v11);
  if (v69._rawBits < 0x10000) {
    v69._rawBits |= 3;
  }
  a3 = specialized String.init(_:)(v69, v70, v44, v11);
  unint64_t v72 = v71;
  swift_bridgeObjectRelease(v11);
  if ((v72 & 0x2000000000000000LL) == 0) {
    goto LABEL_232;
  }
  swift_bridgeObjectRelease(v72);
  a4 = v245;
  while (1)
  {
    unint64_t v73 = HIBYTE(v38) & 0xF;
    Swift::Int v74 = HIBYTE(v72) & 0xF;
    unint64_t v75 = v74 + v73;
    if (v74)
    {
      int64_t v76 = 0;
      char v77 = 0LL;
      do
      {
        int64_t v78 = v73 + v77;
        char v79 = v77 + 1;
        if (v77 >= 8) {
          uint64_t v80 = v72;
        }
        else {
          uint64_t v80 = a3;
        }
        BOOL v81 = v80 >> (v76 & 0x38);
        uint64_t v82 = (8 * v73 + v76) & 0x38;
        uint64_t v83 = (-255LL << v82) - 1;
        uint64_t v84 = (unint64_t)v81 << v82;
        unint64_t v85 = v84 | v83 & v38;
        Swift::String::Index v86 = v84 | v83 & a1;
        if (v78 < 8) {
          a1 = v86;
        }
        else {
          unint64_t v38 = v85;
        }
        v76 += 8;
        char v77 = v79;
      }

      while (v74 != v79);
    }

    swift_bridgeObjectRelease(a2);
    Swift::String::Index v87 = 0xA000000000000000LL;
    if (!(a1 & 0x8080808080808080LL | v38 & 0x80808080808080LL)) {
      Swift::String::Index v87 = 0xE000000000000000LL;
    }
    uint64_t v249 = a1;
    uint64_t v250 = v87 & 0xFF00000000000000LL | (v75 << 56) | v38 & 0xFFFFFFFFFFFFFFLL;
LABEL_97:
    a1 = v249;
    a2 = v250;
    uint64_t v95 = HIBYTE(v250) & 0xF;
    if ((v250 & 0x2000000000000000LL) != 0) {
      unint64_t v38 = HIBYTE(v250) & 0xF;
    }
    else {
      unint64_t v38 = v249 & 0xFFFFFFFFFFFFLL;
    }
    Swift::String::Index v245 = v38;
    if (!v38 && (v249 & ~v250 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain(a4, v64, v65, v66);
      swift_bridgeObjectRelease(a2);
      uint64_t v249 = v246;
      uint64_t v250 = a4;
      goto LABEL_147;
    }

    uint64_t v43 = a4 & 0x2000000000000000LL;
    if ((v250 & 0x2000000000000000LL) != 0 && v43)
    {
      char v96 = HIBYTE(a4) & 0xF;
      unint64_t v97 = v95 + v96;
      if (v95 + v96 <= 0xF)
      {
        if (v96)
        {
          size_t v132 = 0;
          unint64_t v133 = 0LL;
          unint64_t v134 = v250;
          do
          {
            int64_t v135 = v95 + v133;
            unint64_t v136 = v133 + 1;
            if (v133 >= 8) {
              unint64_t v137 = a4;
            }
            else {
              unint64_t v137 = v246;
            }
            char v138 = v137 >> (v132 & 0x38);
            uint64_t v139 = (8 * v95 + v132) & 0x38;
            uint64_t v140 = (-255LL << v139) - 1;
            unint64_t v141 = (unint64_t)v138 << v139;
            unint64_t v142 = v141 | v140 & v134;
            unint64_t v143 = v141 | v140 & a1;
            if (v135 < 8) {
              a1 = v143;
            }
            else {
              unint64_t v134 = v142;
            }
            v132 += 8;
            unint64_t v133 = v136;
          }

          while (v96 != v136);
        }

        else
        {
          unint64_t v134 = v250;
        }

        swift_bridgeObjectRelease(v250);
        Swift::String::Index v148 = 0xA000000000000000LL;
        if (!(a1 & 0x8080808080808080LL | v134 & 0x80808080808080LL)) {
          Swift::String::Index v148 = 0xE000000000000000LL;
        }
        uint64_t v249 = a1;
        uint64_t v250 = v148 & 0xFF00000000000000LL | (v97 << 56) | v134 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_147;
      }

      uint64_t v43 = 1LL;
    }

    unint64_t v5 = HIBYTE(a4) & 0xF;
    unint64_t v72 = v246 & 0xFFFFFFFFFFFFLL;
    if (v43) {
      a3 = HIBYTE(a4) & 0xF;
    }
    else {
      a3 = v246 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v98 = a3;
    if ((a4 & 0x1000000000000000LL) != 0) {
      goto LABEL_225;
    }
    unint64_t v99 = v38;
    if ((v250 & 0x1000000000000000LL) != 0) {
      break;
    }
LABEL_111:
    unint64_t v100 = v99 + v98;
    if (!__OFADD__(v99, v98)) {
      goto LABEL_112;
    }
LABEL_231:
    __break(1u);
LABEL_232:
    a4 = v245;
    if ((v72 & 0x1000000000000000LL) != 0)
    {
      a3 = _StringGuts._foreignConvertedToSmall()(a3, v72);
      unint64_t v236 = v235;
      swift_bridgeObjectRelease(v72);
      unint64_t v72 = v236;
    }

    else
    {
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        uint64_t v223 = (unsigned __int8 *)((v72 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v224 = a3 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v223 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a3, v72);
      }

      closure #1 in _StringGuts._convertedToSmall()(v223, v224, &v247);
      swift_bridgeObjectRelease(v72);
      a3 = v247;
      unint64_t v72 = v248;
    }
  }

  while (2)
  {
    uint64_t v222 = String.UTF8View._foreignCount()();
    unint64_t v100 = v222 + v98;
    if (__OFADD__(v222, v98)) {
      goto LABEL_231;
    }
LABEL_112:
    if ((a1 & ~a2 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(a2 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v101 = _StringGuts.nativeUnusedCapacity.getter(a1, a2);
      if ((v64 & 1) != 0) {
        goto LABEL_255;
      }
      char v102 = (a2 >> 61) & 1;
      if (v101 < v98) {
        LODWORD(v102) = 1;
      }
      if (v100 > 15 || !(_DWORD)v102)
      {
LABEL_125:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v100, v98);
        uint64_t v129 = v246;
        if ((a4 & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v246, a4, 0LL, a3);
        }

        else if (v43)
        {
          Swift::Int v247 = v246;
          uint64_t v248 = a4 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v130 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v5, (uint64_t)&v247, v5);
          _StringGuts.appendInPlace(_:isASCII:)(v130, v131, (a4 & 0x4000000000000000LL) != 0);
        }

        else
        {
          if ((v246 & 0x1000000000000000LL) != 0)
          {
            unint64_t v144 = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
            Swift::String::Index v145 = v72;
          }

          else
          {
            unint64_t v232 = _StringObject.sharedUTF8.getter(v246, a4);
            if (v233 < v72) {
              goto LABEL_253;
            }
            unint64_t v144 = (uint64_t)v232;
            Swift::String::Index v145 = v233;
            uint64_t v129 = v246;
          }

          Swift::String::Index v146 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v72, v144, v145);
          _StringGuts.appendInPlace(_:isASCII:)(v146, v147, v129 < 0);
        }

        goto LABEL_147;
      }
    }

    else if (v100 > 15)
    {
      goto LABEL_125;
    }

    swift_bridgeObjectRetain(a2, v64, v65, v66);
    uint64_t v103 = _StringGuts._convertedToSmall()(a1, a2);
    unint64_t v105 = v104;
    swift_bridgeObjectRelease(a2);
    v106._Swift::UInt64 rawBits = (a3 << 16) | 1;
    v107._Swift::UInt64 rawBits = 1LL;
    uint64_t v108 = _StringGuts.validateScalarRange(_:)(v107, v106, v246, a4);
    uint64_t v112 = v109;
    if (v108 >= 0x10000) {
      uint64_t v113 = v108;
    }
    else {
      uint64_t v113 = v108 | 3;
    }
    swift_bridgeObjectRetain(a4, v109, v110, v111);
    v114._Swift::UInt64 rawBits = v113;
    v115._Swift::UInt64 rawBits = v112;
    char v116 = specialized String.init(_:)(v114, v115, v246, a4);
    unint64_t v118 = v117;
    swift_bridgeObjectRelease(a4);
    unint64_t v119 = _StringGuts._convertedToSmall()(v116, v118);
    unint64_t v121 = v120;
    swift_bridgeObjectRelease(v118);
    unint64_t v122 = specialized _SmallString.init(_:appending:)(v103, v105, v119, v121);
    if ((v124 & 1) != 0) {
      goto LABEL_254;
    }
    unint64_t v125 = v122;
    unint64_t v126 = v123;
    swift_bridgeObjectRelease(a2);
    uint64_t v249 = v125;
    uint64_t v250 = v126;
LABEL_147:
    uint64_t v39 = v249;
    a2 = v250;
    unint64_t v149 = HIBYTE(v250) & 0xF;
    if ((v250 & 0x2000000000000000LL) == 0) {
      unint64_t v149 = v249 & 0xFFFFFFFFFFFFLL;
    }
    Swift::String::Index v246 = v149;
    swift_bridgeObjectRetain_n(v250, 3LL, v127, v128);
    v150._Swift::UInt64 rawBits = v244;
    unint64_t v38 = specialized Collection.subscript.getter(v150, v243, v242);
    uint64_t v43 = v151;
    a3 = v40;
    a1 = v41;
    a4 = v38 >> 16;
    unint64_t v5 = v151 >> 16;
    if ((v41 & 0x1000000000000000LL) != 0)
    {
LABEL_221:
      swift_bridgeObjectRetain_n(a1, 3LL, v40, (char *)v41);
      v209._Swift::UInt64 rawBits = v38 & 0xFFFFFFFFFFFF0000LL | 1;
      v210._Swift::UInt64 rawBits = v43 & 0xFFFFFFFFFFFF0000LL | 1;
      v211._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v209, v210, a3, a1);
      if (v211._rawBits < 0x10000) {
        v211._rawBits |= 3;
      }
      unint64_t v152 = specialized Collection.count.getter(v211, v212, a3, a1);
      swift_bridgeObjectRelease(a2);
      unint64_t v153 = a1;
    }

    else
    {
      unint64_t v152 = v5 - a4;
      swift_bridgeObjectRetain_n(v41, 2LL, v40, (char *)v41);
      unint64_t v153 = a2;
    }

    swift_bridgeObjectRelease(a2);
    swift_bridgeObjectRelease(v153);
    unint64_t v154 = v246;
    if ((a2 & 0x1000000000000000LL) != 0) {
      unint64_t v154 = String.UTF8View._foreignCount()();
    }
    swift_bridgeObjectRelease(a2);
    unint64_t v155 = __OFADD__(v154, v152);
    unint64_t v72 = v154 + v152;
    if (v155)
    {
      __break(1u);
LABEL_225:
      v213._Swift::UInt64 rawBits = (a3 << 16) | 1;
      v214._Swift::UInt64 rawBits = 1LL;
      uint64_t v215 = _StringGuts.validateScalarRange(_:)(v214, v213, v246, a4);
      toa = v216;
      if (v215 >= 0x10000) {
        uint64_t v219 = v215;
      }
      else {
        uint64_t v219 = v215 | 3;
      }
      swift_bridgeObjectRetain(a4, v216, v217, v218);
      v220._Swift::UInt64 rawBits = v219;
      v221._Swift::UInt64 rawBits = toa;
      unint64_t v98 = specialized Collection.count.getter(v220, v221, v246, a4);
      swift_bridgeObjectRelease(a4);
      unint64_t v99 = v38;
      if ((a2 & 0x1000000000000000LL) != 0) {
        continue;
      }
      goto LABEL_111;
    }

    break;
  }

  if ((v39 & ~a2 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(a2 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v72 >= 16)
    {
      int64_t v10 = v249;
      a2 = v250;
      goto LABEL_163;
    }

    a2 = v250;
    if ((v250 & 0x2000000000000000LL) == 0)
    {
LABEL_187:
      swift_bridgeObjectRelease(a1);
      if ((a2 & 0x1000000000000000LL) != 0)
      {
        uint64_t v174 = _StringGuts._foreignConvertedToSmall()(v249, a2);
        unint64_t v175 = v229;
      }

      else
      {
        if ((v249 & 0x1000000000000000LL) != 0)
        {
          uint64_t v172 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
          unint64_t v173 = v249 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v172 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v249, a2);
          unint64_t v173 = v169;
        }

        swift_bridgeObjectRetain(a2, v169, v170, v171);
        closure #1 in _StringGuts._convertedToSmall()(v172, v173, &v247);
        swift_bridgeObjectRelease(a2);
        uint64_t v174 = v247;
        unint64_t v175 = v248;
      }

      goto LABEL_194;
    }

          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
        }
      }

          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
        }
      }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      }

      if (v41 < 64)
      {
        uint64_t v47 = v75;
        uint64_t v32 = v77;
        v77(v75, v42, a2);
        uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        unint64_t v38 = v48 < v81;
        unint64_t v35 = v71;
        goto LABEL_19;
      }

      v31(v33, a2);
    }

    uint64_t v32 = v77;
    uint64_t v39 = v78;
    unint64_t v35 = v71;
  }

  else
  {
    uint64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    unint64_t v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v32 = v77;
    uint64_t v39 = v78;
  }

  uint64_t v46 = v79;
LABEL_23:
  uint64_t v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 65)
  {
    v31(v20, a2);
    goto LABEL_25;
  }

  unint64_t v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 64 && (v39(a2, a3) & 1) == 0)
  {
LABEL_25:
    unint64_t v57 = v74;
    v32(v74, v46, a2);
    BOOL v81 = 0x7FFFFFFFFFFFFFFFLL;
    char v58 = v39(a2, a3);
    uint64_t v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 64)
      {
        unint64_t v60 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        unint64_t v61 = &v81;
        goto LABEL_34;
      }
    }

    else if (v59 > 63)
    {
      uint64_t v80 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v60 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v61 = &v80;
LABEL_34:
      uint64_t v64 = v75;
      v60(v61, v72, v73, a2, a3);
      uint64_t v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v64,  v57,  a2);
      v31(v64, a2);
      if ((v65 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_35;
    }

    id v63 = v75;
    v32(v75, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_35:
    v31(v57, a2);
  }

  size_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  Swift::Int result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *int64_t v76 = v66;
  return result;
}

      --v13;
      goto LABEL_40;
    }

    if (!v11) {
      goto LABEL_46;
    }
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

  if (v19 < 0) {
    goto LABEL_39;
  }
  uint64_t v4 = 0;
  v1.high = -(uint64_t)v18;
  if (v18) {
    low = ~v19;
  }
  else {
    low = -v19;
  }
LABEL_38:
  uint64_t v15 = v1.high;
  uint64_t v16 = low;
  unint64_t v17 = v4;
  result.partialValue.high = v16;
  result.partialValue.low = v15;
  result.overflow = v17;
  return result;
}

    __break(1u);
    goto LABEL_40;
  }

  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

  operator delete(v62.__r_.__value_.__l.__data_);
  if ((*(char *)(v34 - 137) & 0x80000000) == 0)
  {
LABEL_25:
    goto LABEL_41;
  }

  if (v3 < 2) {
    return 0LL;
  }
  uint64_t v12 = &a2[v3];
  if (*(_WORD *)&a2[v3 - 2] != 16724
    && *((_WORD *)v12 - 1) != 24916
    && *((_WORD *)v12 - 1) != 28500
    && *((_WORD *)v12 - 1) != 20308
    && *((_WORD *)v12 - 1) != 21076
    && *((_WORD *)v12 - 1) != 29268
    && *((_WORD *)v12 - 1) != 22356
    && *((_WORD *)v12 - 1) != 17254)
  {
    return 0LL;
  }

  uint64_t v13 = *a1;
  unint64_t v23 = 0LL;
  int64_t v14 = swift::Demangle::__runtime::Demangler::demangleSymbol(v13, a2, v3, v22);
  uint64_t v15 = v23;
  if (v23 == v22)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = v22;
    goto LABEL_52;
  }

  if (v23)
  {
    uint64_t v16 = 5LL;
LABEL_52:
    (*(void (**)(void))(*v15 + 8 * v16))();
  }

  if (v14 && *(_WORD *)(v14 + 16) == 99)
  {
    unint64_t v17 = *(unsigned __int8 *)(v14 + 18);
    if (v17 == 5 && *(_DWORD *)(v14 + 8))
    {
      int64_t v14 = *(void *)v14;
LABEL_59:
      unint64_t v18 = *(unsigned __int16 *)(*(void *)v14 + 16LL);
      return (v18 - 160) <= 0x29 && ((1LL << (v18 + 96)) & 0x31000000C11LL) != 0
          || v18 == 0;
    }
  }

  return 0LL;
}

  if (v18 == v20) {
    goto LABEL_43;
  }
  unint64_t v21 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v18 == v20) {
      goto LABEL_43;
    }
  }

    NodeWithAllocatedText = 0LL;
  }

__objc2_class **specialized _copySequenceToContiguousArray<A>(_:)(void *a1)
{
  uint64_t v2 = type metadata accessor for __CocoaDictionary.Iterator();
  uint64_t v3 = swift_allocObject(v2, 0xE8uLL, 7uLL);
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  v3[27] = 0LL;
  uint64_t v4 = v3 + 27;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000039LL,  0x80000001818B5E60LL,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x77uLL, 0) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  v3[28] = 0LL;
  v3[26] = a1;
  swift_unknownObjectRetain(a1, v5, v6, v7);
  uint64_t v11 = 0LL;
  unint64_t v12 = 0LL;
  uint64_t v13 = &_swiftEmptyArrayStorage;
  int64_t v14 = &_swiftEmptySetSingleton;
  p_ivar_lyt = &_SwiftValue__classData.ivar_lyt;
  while (1)
  {
    uint64_t v16 = (void *)v3[26];
    if (v11 != v3[28]) {
      goto LABEL_5;
    }
    id v17 = objc_msgSend((id)v3[26], sel_countByEnumeratingWithState_objects_count_, v3 + 2, v3 + 10, 16);
    v3[28] = v17;
    if (!v17) {
      break;
    }
    uint64_t v11 = 0LL;
    uint64_t *v4 = 0LL;
LABEL_5:
    uint64_t v18 = v3[3];
    if (!v18) {
      goto LABEL_35;
    }
    if ((unint64_t)(v11 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_31:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    uint64_t v19 = (__objc2_class **)(v18 + 8 * v11);
    BOOL v20 = *v19;
    uint64_t *v4 = v11 + 1;
    unint64_t v21 = (const char *)p_ivar_lyt[281];
    swift_unknownObjectRetain(v20, v8, v9, v10);
    unint64_t v22 = (__objc2_class *)objc_msgSend(v16, v21, v20);
    if (!v22)
    {
      unint64_t v40 = 784LL;
      goto LABEL_37;
    }

    unint64_t v23 = v22;
    if (!v12)
    {
      unint64_t v24 = (unint64_t)v13[3];
      int64_t v25 = v24 & 0xFFFFFFFFFFFFFFFELL;
      if (v25 <= 1) {
        uint64_t v26 = 1LL;
      }
      else {
        uint64_t v26 = v25;
      }
      uint64_t v27 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(key: Swift.AnyObject, value: Swift.AnyObject)>);
      uint64_t v28 = (__objc2_class **)swift_allocObject(v27, 16 * v26 + 32, 7uLL);
      int64_t v29 = _swift_stdlib_malloc_size(v28);
      uint64_t v30 = v29 - 32;
      if (v29 < 32) {
        uint64_t v30 = v29 - 17;
      }
      uint64_t v31 = v30 >> 4;
      _OWORD v28[2] = (__objc2_class *)v26;
      v28[3] = (__objc2_class *)(2 * (v30 >> 4));
      unint64_t v32 = (unint64_t)(v28 + 4);
      unint64_t v33 = (unint64_t)v13[3] >> 1;
      if (v13[2])
      {
        uint64_t v34 = v13 + 4;
        void v13[2] = 0LL;
      }

      int64_t v14 = (__objc2_class **)(v32 + 16 * v33);
      unint64_t v12 = (v31 & 0x7FFFFFFFFFFFFFFFLL) - v33;
      swift_release((uint64_t)v13);
      uint64_t v13 = v28;
      p_ivar_lyt = (void **)(&_SwiftValue__classData + 16);
    }

    BOOL v35 = __OFSUB__(v12--, 1LL);
    if (v35)
    {
      __break(1u);
LABEL_33:
      __break(1u);
LABEL_34:
      __break(1u);
LABEL_35:
      unint64_t v40 = 773LL;
LABEL_37:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v40,  0);
    }

    *int64_t v14 = v20;
    v14[1] = v23;
    v14 += 2;
    uint64_t v11 = *v4;
    if (*v4 < 0) {
      goto LABEL_26;
    }
  }

  uint64_t *v4 = -1LL;
LABEL_26:
  swift_release((uint64_t)v3);
  unint64_t v36 = (unint64_t)v13[3];
  if (v36 >= 2)
  {
    unint64_t v37 = v36 >> 1;
    BOOL v35 = __OFSUB__(v37, v12);
    unint64_t v38 = (__objc2_class *)(v37 - v12);
    if (v35) {
      goto LABEL_34;
    }
    void v13[2] = v38;
  }

  return v13;
}

{
  uint64_t v2;
  void *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  __objc2_class **v13;
  __objc2_class **v14;
  id v15;
  uint64_t v16;
  __objc2_class **v17;
  __objc2_class *v18;
  unint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  __objc2_class **v23;
  int64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  const void *v29;
  BOOL v30;
  unint64_t v31;
  unint64_t v32;
  __objc2_class *v33;
  uint64_t v2 = type metadata accessor for __CocoaSet.Iterator();
  uint64_t v3 = swift_allocObject(v2, 0xE8uLL, 7uLL);
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  v3[27] = 0LL;
  uint64_t v4 = v3 + 27;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000039LL,  0x80000001818B5E60LL,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x77uLL, 0) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  v3[28] = 0LL;
  v3[26] = a1;
  swift_unknownObjectRetain(a1, v5, v6, v7);
  uint64_t v11 = 0LL;
  unint64_t v12 = 0LL;
  uint64_t v13 = &_swiftEmptyArrayStorage;
  int64_t v14 = &_swiftEmptySetSingleton;
  while (1)
  {
    if (v11 != v3[28]) {
      goto LABEL_5;
    }
    uint64_t v15 = objc_msgSend((id)v3[26], sel_countByEnumeratingWithState_objects_count_, v3 + 2, v3 + 10, 16);
    v3[28] = v15;
    if (!v15) {
      break;
    }
    uint64_t v11 = 0LL;
    uint64_t *v4 = 0LL;
LABEL_5:
    uint64_t v16 = v3[3];
    if (!v16) {
      goto LABEL_34;
    }
    if ((unint64_t)(v11 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_30:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    id v17 = (__objc2_class **)(v16 + 8 * v11);
    uint64_t v18 = *v17;
    uint64_t *v4 = v11 + 1;
    swift_unknownObjectRetain(v18, v8, v9, v10);
    if (!v12)
    {
      uint64_t v19 = (unint64_t)v13[3];
      BOOL v20 = v19 & 0xFFFFFFFFFFFFFFFELL;
      if (v20 <= 1) {
        unint64_t v21 = 1LL;
      }
      else {
        unint64_t v21 = v20;
      }
      unint64_t v22 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
      unint64_t v23 = (__objc2_class **)swift_allocObject(v22, 8 * v21 + 32, 7uLL);
      unint64_t v24 = _swift_stdlib_malloc_size(v23);
      int64_t v25 = v24 - 32;
      if (v24 < 32) {
        int64_t v25 = v24 - 25;
      }
      uint64_t v26 = v25 >> 3;
      v23[2] = (__objc2_class *)v21;
      uint64_t v23[3] = (__objc2_class *)((2 * (v25 >> 3)) | 1);
      uint64_t v27 = (unint64_t)(v23 + 4);
      uint64_t v28 = (unint64_t)v13[3] >> 1;
      if (v13[2])
      {
        int64_t v29 = v13 + 4;
        void v13[2] = 0LL;
      }

      int64_t v14 = (__objc2_class **)(v27 + 8 * v28);
      unint64_t v12 = (v26 & 0x7FFFFFFFFFFFFFFFLL) - v28;
      swift_release((uint64_t)v13);
      uint64_t v13 = v23;
    }

    uint64_t v30 = __OFSUB__(v12--, 1LL);
    if (v30)
    {
      __break(1u);
LABEL_32:
      __break(1u);
LABEL_33:
      __break(1u);
LABEL_34:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
    }

    *v14++ = v18;
    uint64_t v11 = *v4;
    if (*v4 < 0) {
      goto LABEL_25;
    }
  }

  uint64_t *v4 = -1LL;
LABEL_25:
  swift_release((uint64_t)v3);
  uint64_t v31 = (unint64_t)v13[3];
  if (v31 >= 2)
  {
    unint64_t v32 = v31 >> 1;
    uint64_t v30 = __OFSUB__(v32, v12);
    unint64_t v33 = (__objc2_class *)(v32 - v12);
    if (v30) {
      goto LABEL_33;
    }
    void v13[2] = v33;
  }

  return v13;
}

uint64_t specialized _copySequenceToContiguousArray<A>(_:)(uint64_t result)
{
  uint64_t v1 = &_swiftEmptyArrayStorage;
  if ((_DWORD)result)
  {
    unsigned int v2 = result;
    size_t v3 = 0LL;
    uint64_t v4 = &_swiftEmptySetSingleton;
    while (1)
    {
      if (!v3)
      {
        unint64_t v5 = (unint64_t)v1[3];
        int64_t v6 = v5 & 0xFFFFFFFFFFFFFFFELL;
        if (v6 <= 1) {
          uint64_t v7 = 1LL;
        }
        else {
          uint64_t v7 = v6;
        }
        uint64_t v8 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
        uint64_t v9 = (__objc2_class **)swift_allocObject(v8, v7 + 32, 7uLL);
        size_t v10 = 2 * _swift_stdlib_malloc_size(v9) - 64;
        void v9[2] = (__objc2_class *)v7;
        uint64_t v9[3] = (__objc2_class *)v10;
        unint64_t v11 = (unint64_t)(v9 + 4);
        size_t v12 = (unint64_t)v1[3] >> 1;
        if (v1[2])
        {
          v1[2] = 0LL;
        }

        uint64_t v4 = (__objc2_class **)(v11 + v12);
        size_t v3 = (v10 >> 1) - v12;
        Swift::Int result = swift_release((uint64_t)v1);
        uint64_t v1 = v9;
      }

      BOOL v14 = __OFSUB__(v3--, 1LL);
      if (v14) {
        break;
      }
      *(_BYTE *)uint64_t v4 = v2 - 1;
      uint64_t v4 = (__objc2_class **)((char *)v4 + 1);
      BOOL v15 = v2 > 0xFF;
      v2 >>= 8;
      if (!v15) {
        goto LABEL_21;
      }
    }

    __break(1u);
LABEL_26:
    __break(1u);
    goto LABEL_27;
  }

  size_t v3 = 0LL;
LABEL_21:
  unint64_t v16 = (unint64_t)v1[3];
  if (v16 < 2) {
    return (uint64_t)v1;
  }
  unint64_t v17 = v16 >> 1;
  BOOL v14 = __OFSUB__(v17, v3);
  uint64_t v18 = (__objc2_class *)(v17 - v3);
  if (!v14)
  {
    v1[2] = v18;
    return (uint64_t)v1;
  }

__objc2_class **specialized _copySequenceToContiguousArray<A>(_:)(unint64_t *a1, uint64_t a2)
{
  if (a2 < 0) {
    goto LABEL_71;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = 0LL;
  while (a2 != v5)
  {
    int8x8_t v6 = (int8x8_t)a1[v5++];
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
    v7.i16[0] = vaddlv_u8(v7);
    BOOL v8 = __OFADD__(v4, v7.u32[0]);
    v4 += v7.u32[0];
    if (v8)
    {
      __break(1u);
      break;
    }
  }

  if (v4)
  {
    Swift::Int result = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v4, 0LL);
    if (a2)
    {
      if (v4 < 0) {
        goto LABEL_71;
      }
      unint64_t v10 = *a1;
    }

    else
    {
      if (v4 < 0) {
        goto LABEL_71;
      }
      unint64_t v10 = 0LL;
    }

    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    size_t v12 = result + 4;
    unint64_t v11 = ((unint64_t)result[3] >> 1) - v4;
    while (1)
    {
      if (v14 == v4) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
      }
      if (v10)
      {
        unint64_t v15 = __clz(__rbit64(v10));
        v10 &= v10 - 1;
        unint64_t v16 = v15 | (v13 << 6);
      }

      else
      {
        BOOL v8 = __OFADD__(v13++, 1LL);
        if (v8) {
          goto LABEL_73;
        }
        if (v13 >= a2) {
          goto LABEL_75;
        }
        unint64_t v17 = a1[v13];
        if (!v17)
        {
          uint64_t v18 = v13 + 1;
          if (v13 + 1 >= a2) {
            goto LABEL_75;
          }
          unint64_t v17 = a1[v18];
          if (!v17)
          {
            while (1)
            {
              uint64_t v13 = v18 + 1;
              if (__OFADD__(v18, 1LL)) {
                break;
              }
              if (v13 >= a2) {
                goto LABEL_75;
              }
              unint64_t v17 = a1[v13];
              ++v18;
              if (v17) {
                goto LABEL_29;
              }
            }

            __break(1u);
LABEL_73:
            __break(1u);
            goto LABEL_74;
          }

          ++v13;
        }

__objc2_class **specialized _copySequenceToContiguousArray<A>(_:)(unint64_t a1)
{
  if (a1)
  {
    unint64_t v1 = a1;
    uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
    v2.i16[0] = vaddlv_u8(v2);
    uint64_t v3 = v2.u32[0];
    uint64_t v4 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v2.u32[0], 0LL);
    uint64_t v5 = v4 + 4;
    unint64_t v6 = (unint64_t)v4[3];
    unint64_t v7 = (v6 >> 1) - v3;
    unint64_t v8 = (v6 >> 1) | 0x8000000000000000LL;
    do
    {
      if (!v1) {
        goto LABEL_35;
      }
      if (!v8)
      {
        __break(1u);
        goto LABEL_32;
      }

      unint64_t v9 = (v1 - 1) & v1;
      *v5++ = __clz(__rbit64(v1));
      --v8;
      unint64_t v1 = v9;
      --v3;
    }

    while (v3);
    if (v9)
    {
      while (1)
      {
        if (!v7)
        {
          unint64_t v10 = (unint64_t)v4[3];
          int64_t v11 = v10 & 0xFFFFFFFFFFFFFFFELL;
          if (v11 <= 1) {
            uint64_t v12 = 1LL;
          }
          else {
            uint64_t v12 = v11;
          }
          uint64_t v13 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>();
          uint64_t v14 = (__objc2_class **)swift_allocObject(v13, 8 * v12 + 32, 7uLL);
          int64_t v15 = _swift_stdlib_malloc_size(v14);
          uint64_t v16 = v15 - 32;
          if (v15 < 32) {
            uint64_t v16 = v15 - 25;
          }
          uint64_t v17 = v16 >> 3;
          uint64_t v14[2] = (__objc2_class *)v12;
          v14[3] = (__objc2_class *)(2 * (v16 >> 3));
          unint64_t v18 = (unint64_t)(v14 + 4);
          unint64_t v19 = (unint64_t)v4[3] >> 1;
          if (v4[2])
          {
            v4[2] = 0LL;
          }

          uint64_t v5 = (void *)(v18 + 8 * v19);
          unint64_t v7 = (v17 & 0x7FFFFFFFFFFFFFFFLL) - v19;
          swift_release((uint64_t)v4);
          uint64_t v4 = v14;
        }

        BOOL v21 = __OFSUB__(v7--, 1LL);
        if (v21) {
          break;
        }
        *v5++ = __clz(__rbit64(v9));
        v9 &= v9 - 1;
        if (!v9) {
          goto LABEL_27;
        }
      }

LABEL_32:
      __break(1u);
LABEL_33:
      __break(1u);
LABEL_34:
      __break(1u);
LABEL_35:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x429uLL,  0);
    }
  }

  else
  {
    uint64_t v4 = &_swiftEmptyArrayStorage;
    unint64_t v7 = (unint64_t)qword_18C565BD0 >> 1;
  }

  __break(1u);
  return result;
}

    if (v162 == 1)
    {
      uint64_t v107 = v65;
      uint64_t v108 = v158;
      uint64_t v176 = v153;
      (*(void (**)(char *, unint64_t *, ValueMetadata *, unint64_t, unint64_t, unint64_t))(v60 + 240))( v165,  &v176,  &type metadata for Int,  v163,  AssociatedTypeWitness,  v60);
      unint64_t v109 = swift_getAssociatedConformanceWitness( (uint64_t)v89,  AssociatedTypeWitness,  v108,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v109 + 8))( &qword_18180BE70,  512LL,  v108,  v109);
      uint64_t v110 = v155;
      (*((void (**)(char *, unint64_t, const char *))v89 + 3))(v170, AssociatedTypeWitness, v89);
      char v111 = v172;
      uint64_t v112 = v107;
      char v77 = v165;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 40LL))( v112,  v110,  AssociatedTypeWitness);
      v97(v110, AssociatedTypeWitness);
      unint64_t v73 = v159;
      (*(void (**)(char *, char *, unint64_t, unint64_t))(v60 + 192))( v77,  v111,  AssociatedTypeWitness,  v60);
      v97(v111, AssociatedTypeWitness);
    }

    else
    {
      (*(void (**)(char *, char *, char *, unint64_t, unint64_t))(v60 + 272))( v85,  &v85[*((int *)v84 + 12)],  v65,  AssociatedTypeWitness,  v60);
    }

    v97(v77, AssociatedTypeWitness);
    uint64_t v113 = &v85[*((int *)v84 + 12)];
    uint64_t v114 = v85;
    size_t v115 = (void (*)(char *, char *, unint64_t))v175[4];
    v115(v174, v114, AssociatedTypeWitness);
    v115(v73, v113, AssociatedTypeWitness);
    char v116 = (*(uint64_t (**)(unint64_t, unint64_t))(v60 + 120))(AssociatedTypeWitness, v60);
    v97(v73, AssociatedTypeWitness);
    else {
      unint64_t v118 = 48;
    }
    unint64_t v119 = v177;
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v177)) {
      unint64_t v119 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v119[2]->isa + 1,  1,  (uint64_t)v119);
    }
    unint64_t v121 = v119[2];
    unint64_t v120 = (unint64_t)v119[3];
    if ((unint64_t)v121 >= v120 >> 1) {
      unint64_t v119 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v120 > 1),  (int64_t)&v121->isa + 1,  1,  (uint64_t)v119);
    }
    v119[2] = (__objc2_class *)((char *)&v121->isa + 1);
    *((_BYTE *)&v121->info + (void)v119) = v118 + v116;
    uint64_t v177 = v119;
    v115(v77, v174, AssociatedTypeWitness);
    unint64_t v75 = v172;
    Swift::Int v74 = v173;
    uint64_t v65 = v169;
  }

  if (v88 < 64)
  {
    Swift::Int v74 = v173;
    Swift::String::Index v86 = (*(uint64_t (**)(unint64_t, unint64_t))(v60 + 120))(AssociatedTypeWitness, v60);
LABEL_28:
    uint64_t v103 = v86;
    unint64_t v97 = (void (*)(char *, unint64_t))v175[1];
    v97(v74, AssociatedTypeWitness);
    Swift::String::Index v89 = v166;
    if (!v103) {
      goto LABEL_47;
    }
    goto LABEL_32;
  }

          uint64_t v110 = v215;
          v85(v215, (uint64_t)v82, (uint64_t)a4);
          char v111 = v74(a4, a6);
          uint64_t v112 = v85;
          uint64_t v113 = v210;
          unint64_t v229 = v112;
          v112(v210, (uint64_t)v110, (uint64_t)a4);
          if ((v111 & 1) != 0)
          {
            uint64_t v114 = v214;
            size_t v115 = v214(a4, a6);
            v213(v113, a4);
            char v116 = v229;
            if (v115 < 65) {
              goto LABEL_40;
            }
            unint64_t v117 = v204;
            v229(v204, (uint64_t)v215, (uint64_t)a4);
            v232[0] = 0x8000000000000000LL;
            if ((v74(a4, a6) & 1) != 0)
            {
              unint64_t v118 = v214(a4, a6);
              if (v118 < 64)
              {
                v116((char *)v56, (uint64_t)v117, (uint64_t)a4);
                unint64_t v121 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                v213((char *)v56, a4);
                unint64_t v122 = v117;
                uint64_t v114 = v214;
                if (v121 < v232[0]) {
                  goto LABEL_91;
                }
                goto LABEL_39;
              }

              uint64_t v177 = v74;
              unint64_t v178 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
              unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
              v178(v232, &type metadata for Int, v179, a4, a6);
              Swift::Int v74 = v177;
              uint64_t v56 = v222;
              uint64_t v180 = (*(uint64_t (**)(char *, uint64_t, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v117,  v222,  a4);
              v213((char *)v56, a4);
              unint64_t v122 = v117;
              uint64_t v114 = v214;
              if ((v180 & 1) != 0) {
LABEL_91:
              }
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
            }

            else
            {
              Swift::String::Index v168 = v74(a4, a6);
              uint64_t v114 = v214;
              Swift::Int v169 = v214(a4, a6);
              if ((v168 & 1) != 0)
              {
                if (v169 <= 64)
                {
                  unint64_t v183 = v208;
                  uint64_t v184 = v207;
                  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v208,  (uint64_t)a4,  v207,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  uint64_t v186 = v206;
                  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                              + 8))( &unk_18180BE68,  256LL,  v184,  AssociatedConformanceWitness);
                  (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v183 + 3))( v186,  a4,  v183);
                  uint64_t v187 = v204;
                  Swift::String::Index v188 = (*(uint64_t (**)(char *, uint64_t, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v204,  v56,  a4);
                  int64_t v189 = v116;
                  char v190 = v213;
                  v213((char *)v56, a4);
                  uint64_t v191 = v203;
                  v189(v203, (uint64_t)v187, (uint64_t)a4);
                  uint64_t v84 = v212;
                  if ((v188 & 1) != 0)
                  {
                    v190(v191, a4);
                    goto LABEL_91;
                  }

                  uint64_t v192 = v232[0];
                  uint64_t v193 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                  v190(v191, a4);
                  unint64_t v60 = v193 < v192;
                  Swift::Int v74 = v211;
                  unint64_t v122 = v204;
                  char v116 = v229;
                  if (v60) {
                    goto LABEL_91;
                  }
                }

                else
                {
                  uint64_t v172 = v74;
                  unint64_t v173 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
                  uint64_t v174 = lazy protocol witness table accessor for type Int and conformance Int(v169, v170, v171);
                  v173(v232, &type metadata for Int, v174, a4, a6);
                  Swift::Int v74 = v172;
                  unint64_t v175 = v204;
                  uint64_t v176 = (*(uint64_t (**)(char *, uint64_t, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v204,  v56,  a4);
                  v213((char *)v56, a4);
                  unint64_t v122 = v175;
                  uint64_t v84 = v212;
                  if ((v176 & 1) != 0) {
                    goto LABEL_91;
                  }
                }
              }

              else if (v169 < 64)
              {
                uint64_t v181 = v204;
                v116((char *)v56, (uint64_t)v204, (uint64_t)a4);
                uint64_t v182 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                v213((char *)v56, a4);
                unint64_t v122 = v181;
                uint64_t v84 = v212;
                if (v182 < v232[0]) {
                  goto LABEL_91;
                }
              }

              else
              {
                uint64_t v84 = v212;
                unint64_t v122 = v204;
              }
            }
          }

          else
          {
            unint64_t v122 = v113;
            uint64_t v114 = v214;
            char v116 = v229;
          }

          uint64_t v110 = v215;
          v85(v215, (uint64_t)v82, (uint64_t)a4);
          char v111 = v74(a4, a6);
          uint64_t v112 = v85;
          uint64_t v113 = v210;
          unint64_t v229 = v112;
          v112(v210, (uint64_t)v110, (uint64_t)a4);
          if ((v111 & 1) != 0)
          {
            uint64_t v114 = v214;
            size_t v115 = v214(a4, a6);
            v213(v113, a4);
            char v116 = v229;
            if (v115 < 65) {
              goto LABEL_40;
            }
            unint64_t v117 = v204;
            v229(v204, (uint64_t)v215, (uint64_t)a4);
            v232[0] = 0x8000000000000000LL;
            if ((v74(a4, a6) & 1) != 0)
            {
              unint64_t v118 = v214(a4, a6);
              if (v118 < 64)
              {
                v116(v56, (uint64_t)v117, (uint64_t)a4);
                unint64_t v121 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                v213(v56, a4);
                unint64_t v122 = v117;
                uint64_t v114 = v214;
                if (v121 < v232[0]) {
                  goto LABEL_91;
                }
                goto LABEL_39;
              }

              uint64_t v177 = v74;
              unint64_t v178 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
              unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
              v178(v232, &type metadata for Int, v179, a4, a6);
              Swift::Int v74 = v177;
              uint64_t v56 = v221;
              uint64_t v180 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v117,  v221,  a4);
              v213(v56, a4);
              unint64_t v122 = v117;
              uint64_t v114 = v214;
              if ((v180 & 1) != 0) {
LABEL_91:
              }
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
            }

            else
            {
              Swift::String::Index v168 = v74(a4, a6);
              uint64_t v114 = v214;
              Swift::Int v169 = v214(a4, a6);
              if ((v168 & 1) != 0)
              {
                if (v169 <= 64)
                {
                  unint64_t v183 = v208;
                  uint64_t v184 = v207;
                  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v208,  (uint64_t)a4,  v207,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  uint64_t v186 = v206;
                  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                              + 8))( &unk_18180BE68,  256LL,  v184,  AssociatedConformanceWitness);
                  (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v183 + 3))( v186,  a4,  v183);
                  uint64_t v187 = v204;
                  Swift::String::Index v188 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v204,  v56,  a4);
                  int64_t v189 = v116;
                  char v190 = v213;
                  v213(v56, a4);
                  uint64_t v191 = v203;
                  v189(v203, (uint64_t)v187, (uint64_t)a4);
                  uint64_t v84 = v212;
                  if ((v188 & 1) != 0)
                  {
                    v190(v191, a4);
                    goto LABEL_91;
                  }

                  uint64_t v192 = v232[0];
                  uint64_t v193 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                  v190(v191, a4);
                  unint64_t v60 = v193 < v192;
                  Swift::Int v74 = v211;
                  unint64_t v122 = v204;
                  char v116 = v229;
                  if (v60) {
                    goto LABEL_91;
                  }
                }

                else
                {
                  uint64_t v172 = v74;
                  unint64_t v173 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
                  uint64_t v174 = lazy protocol witness table accessor for type Int and conformance Int(v169, v170, v171);
                  v173(v232, &type metadata for Int, v174, a4, a6);
                  Swift::Int v74 = v172;
                  unint64_t v175 = v204;
                  uint64_t v176 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v204,  v56,  a4);
                  v213(v56, a4);
                  unint64_t v122 = v175;
                  uint64_t v84 = v212;
                  if ((v176 & 1) != 0) {
                    goto LABEL_91;
                  }
                }
              }

              else if (v169 < 64)
              {
                uint64_t v181 = v204;
                v116(v56, (uint64_t)v204, (uint64_t)a4);
                uint64_t v182 = (*(uint64_t (**)(void *, uint64_t))(a6 + 120))(a4, a6);
                v213(v56, a4);
                unint64_t v122 = v181;
                uint64_t v84 = v212;
                if (v182 < v232[0]) {
                  goto LABEL_91;
                }
              }

              else
              {
                uint64_t v84 = v212;
                unint64_t v122 = v204;
              }
            }
          }

          else
          {
            unint64_t v122 = v113;
            uint64_t v114 = v214;
            char v116 = v229;
          }

      RawKeyPathComponent.value.getter(v15, v17, v19, (uint64_t *)v186);
      outlined init with take of KeyPathComponent(v186, (uint64_t)&v187);
      if ((v188 >> 61) - 2 < 3)
      {
        v188 &= 0x1FFFFFFFFFFFFFFFuLL;
        uint64_t v33 = (swift::SymbolInfo *)ComputedAccessorsPtr.getter<A, B>()(v189);
        uint64_t v34 = swift_keyPath_copySymbolName(v33);
        if (v34)
        {
          unint64_t v35 = v34;
          unint64_t v36 = swift_keyPathSourceString(v34);
          if (v36)
          {
            unint64_t v37 = (uint8x16_t *)v36;
            unint64_t v38 = _swift_stdlib_strlen(v36);
            if ((v38 & 0x8000000000000000LL) != 0) {
              goto LABEL_203;
            }
            unint64_t v39 = v38;
            unint64_t v40 = validateUTF8(_:)(v37->i64, v38);
            if ((v42 & 1) != 0) {
              uint64_t v43 = repairUTF8(_:firstKnownBrokenRange:)(v37->i8, v39, v40, v41);
            }
            else {
              uint64_t v43 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v37, v39, v40 & 1);
            }
            uint64_t v83 = v43;
            uint64_t v84 = v44;
            swift_slowDealloc(v37);
            swift_keyPath_freeSymbolName(v35);
LABEL_133:
            unint64_t v126 = *a2;
            unint64_t v67 = a2[1];
            unint64_t v127 = HIBYTE(v67) & 0xF;
            if ((v67 & 0x2000000000000000LL) == 0) {
              unint64_t v127 = *a2 & 0xFFFFFFFFFFFFLL;
            }
            if (!v127 && (v126 & ~v67 & 0x2000000000000000LL) == 0)
            {
              *a2 = v83;
              a2[1] = v84;
              goto LABEL_197;
            }

            if ((v67 & 0x2000000000000000LL) != 0)
            {
              if ((v84 & 0x2000000000000000LL) == 0) {
                goto LABEL_4;
              }
              id v128 = specialized _SmallString.init(_:appending:)(v126, v67, v83, v84);
              if ((v130 & 1) == 0)
              {
                size_t v131 = v128;
                size_t v132 = v129;
                swift_bridgeObjectRelease(v84);
                swift_bridgeObjectRelease(a2[1]);
                *a2 = v131;
                a2[1] = v132;
                goto LABEL_8;
              }

    unint64_t v1 = *(void *)v0;
    if (*(void *)(*(void *)v0 + 16LL)) {
      goto LABEL_82;
    }
    unint64_t v20 = 1;
LABEL_34:
    unint64_t v22 = *(void *)(v0 + 40);
    BOOL v21 = *(void *)(v0 + 48);
    Swift::UInt64 rawBits = *(void *)(v0 + 16);
    int64_t v24 = (v21 & 0x1000000000000000LL) == 0 || (v22 & 0x800000000000000LL) != 0;
    uint64_t v25 = *(void *)(v0 + 16) & 0xCLL;
    uint64_t v26 = 4LL << v24;
    if ((rawBits & 1) != 0 && v25 != v26)
    {
      uint64_t v27 = v22 & 0xFFFFFFFFFFFFLL;
      if ((v21 & 0x2000000000000000LL) != 0) {
        uint64_t v27 = HIBYTE(v21) & 0xF;
      }
      if (v27 <= rawBits >> 16)
      {
        unint64_t v57 = 121LL;
        goto LABEL_106;
      }

  swift_bridgeObjectRelease(v28);
  return v41;
}

        __break(1u);
        return result;
      }

      return 1LL;
    }
  }

    if (v7 == a4) {
      break;
    }
    unint64_t v19 = 0LL;
    unint64_t v20 = &a1[v7];
    BOOL v21 = (unsigned __int8 *)v15;
    unint64_t v22 = (unsigned __int8 *)v15;
    while (1)
    {
      int64_t v24 = (char)*v22++;
      unint64_t v23 = v24;
      if ((v24 & 0x80000000) == 0)
      {
        uint64_t v25 = 1LL;
        goto LABEL_36;
      }

      if (v23 <= 0xDFu)
      {
        unint64_t v22 = v21 + 2;
        uint64_t v25 = 2LL;
        goto LABEL_36;
      }

      if (v23 == 224) {
        break;
      }
      if (v23 <= 0xECu) {
        goto LABEL_61;
      }
      if (v23 == 237)
      {
        uint64_t v28 = v21[1];
        if (v28 > 0x9F) {
          goto LABEL_79;
        }
LABEL_63:
        if ((v28 & 0xC0) != 0x80) {
          goto LABEL_79;
        }
        uint64_t v26 = (char *)(v21 + 2);
LABEL_65:
        if ((*v26 & 0xC0) != 0x80) {
          goto LABEL_79;
        }
        unint64_t v22 = v21 + 3;
        uint64_t v25 = 3LL;
        goto LABEL_36;
      }

      if ((v23 + 16) >= 0xFEu)
      {
LABEL_61:
        LOBYTE(v28) = v21[1];
        goto LABEL_63;
      }

      if (v23 == 240)
      {
      }

      else
      {
        if ((v23 + 12) >= 0xFDu)
        {
          LOBYTE(v29) = v21[1];
        }

        else
        {
          int64_t v29 = v21[1];
          if (v29 > 0x8F) {
            goto LABEL_79;
          }
        }

        if ((v29 & 0xC0) != 0x80) {
          goto LABEL_79;
        }
      }

      if (v21 + 2 == (unsigned __int8 *)v20
        || (v21[2] & 0xC0) != 0x80
        || v21 + 3 == (unsigned __int8 *)v20
        || (v21[3] & 0xC0) != 0x80)
      {
        goto LABEL_79;
      }

      unint64_t v22 = v21 + 4;
      uint64_t v25 = 4LL;
LABEL_36:
      v19 += v25;
      BOOL v21 = v22;
    }

    if (v22 != (unsigned __int8 *)v20)
    {
      uint64_t v26 = (char *)(v21 + 2);
    }

    unint64_t v20 = v19;
LABEL_33:
    if (v12 != 8205)
    {
      if (v12 != 39)
      {
        if (v12 == 34) {
          goto LABEL_36;
        }
LABEL_65:
        WordBreakProperty = _swift_stdlib_getWordBreakProperty(v12);
        BOOL v21 = 0;
        unint64_t v22 = 0;
        unint64_t v23 = 8;
        uint64_t v25 = 1;
        switch(WordBreakProperty)
        {
          case 0:
          case 1:
            goto LABEL_66;
          case 2:
            break;
          case 3:
            BOOL v21 = 0;
            unint64_t v23 = 7;
            unint64_t v22 = 1;
            break;
          case 4:
            BOOL v21 = 0;
            unint64_t v22 = 0;
            unint64_t v23 = 0;
            break;
          case 5:
            BOOL v21 = 0;
            unint64_t v22 = 0;
            unint64_t v23 = 11;
            break;
          case 6:
            BOOL v21 = 0;
            unint64_t v22 = 0;
            unint64_t v23 = 9;
            break;
          case 7:
            BOOL v21 = 0;
            unint64_t v22 = 0;
            unint64_t v23 = 10;
            break;
          case 8:
            unint64_t v22 = 0;
            unint64_t v23 = 13;
            BOOL v21 = 1;
            break;
          case 9:
            BOOL v21 = 0;
            unint64_t v22 = 0;
            unint64_t v23 = 5;
            break;
          case 10:
            if (v20 == 16) {
              goto LABEL_8;
            }
            BOOL v21 = 0;
            unint64_t v22 = 0;
            unint64_t v23 = 16;
            break;
          case 11:
            if (v20 == 17) {
              goto LABEL_8;
            }
            BOOL v21 = 0;
            unint64_t v22 = 0;
            unint64_t v23 = 4;
            break;
          default:
            if (v20 == 1) {
              goto LABEL_258;
            }
            BOOL v21 = 0;
            unint64_t v22 = 0;
            uint64_t v25 = 1;
            unint64_t v23 = 1;
            break;
        }

  int64_t v11 = 0LL;
  uint64_t v17 = v13 & 0xFFFFFFFFFFFFFF00LL;
  uint64_t v16 = v13;
LABEL_33:
  BOOL v21 = **(char ***)(v5 + 24);
  unint64_t v22 = v17 | v16;
  if (v15) {
    unint64_t v23 = v22 == 255;
  }
  else {
    unint64_t v23 = 0;
  }
  int64_t v24 = v23;
  if (*v21) {
    int64_t v24 = 1;
  }
  *BOOL v21 = v24;
  if (v11)
  {
    uint64_t WitnessTable = swift::TargetProtocolConformanceDescriptor<swift::InProcess>::getWitnessTable( (uint64_t)a2,  (uint64_t)v11,  a3,  a4);
    ConformanceState::cacheResult(*(void *)(v5 + 32), (uint64_t)v11, **(void **)v5);
    Swift::Int result = *(void *)(v5 + 40);
    unint64_t v37 = v11;
    unint64_t v38 = WitnessTable;
    uint64_t v26 = result + 8;
    if ((*(_BYTE *)result & 1) != 0)
    {
      uint64_t v27 = 4;
    }

    else
    {
      uint64_t v27 = *(_DWORD *)(result + 16);
      if (!v27)
      {
        uint64_t v32 = 0LL;
        return (uint64_t)__swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::SmallDenseMap<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*,4u,__swift::__runtime::llvm::DenseMapInfo<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::detail::DenseMapPair<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*>>,swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*,__swift::__runtime::llvm::DenseMapInfo<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::detail::DenseMapPair<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*>>::InsertIntoBucket<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*>( result,  v32,  &v37,  &v38);
      }

      uint64_t v26 = *(void *)(result + 8);
    }

    uint64_t v28 = v27 - 1;
    int64_t v29 = v28 & ((v11 >> 4) ^ (v11 >> 9));
    BOOL v30 = (const char **)(v26 + 16LL * v29);
    uint64_t v31 = *v30;
    if (v11 == *v30) {
      return result;
    }
    uint64_t v33 = 0LL;
    uint64_t v34 = 1;
    while (v31 != (const char *)-4096LL)
    {
      if (v33) {
        unint64_t v35 = 0;
      }
      else {
        unint64_t v35 = v31 == (const char *)-8192LL;
      }
      if (v35) {
        uint64_t v33 = v30;
      }
      unint64_t v36 = v29 + v34++;
      int64_t v29 = v36 & v28;
      BOOL v30 = (const char **)(v26 + 16LL * v29);
      uint64_t v31 = *v30;
      if (v11 == *v30) {
        return result;
      }
    }

    if (v33) {
      uint64_t v32 = v33;
    }
    else {
      uint64_t v32 = v30;
    }
    return (uint64_t)__swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::SmallDenseMap<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*,4u,__swift::__runtime::llvm::DenseMapInfo<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::detail::DenseMapPair<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*>>,swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*,__swift::__runtime::llvm::DenseMapInfo<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::detail::DenseMapPair<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*>>::InsertIntoBucket<swift::TargetMetadata<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*>( result,  v32,  &v37,  &v38);
  }

  return result;
}

  if (*from) {
    BOOL v21 = ((unint64_t)*from & 0x8000000000000001LL) == 1;
  }
  else {
    BOOL v21 = 1;
  }
  if (v21)
  {
    unint64_t v22 = (unint64_t)*from & 0x7FFFFFFFFFFFFFFELL;
    if (v22)
    {
      unint64_t v23 = (unsigned __int128 *)(v22 + 16);
      do
        int64_t v24 = __ldxp(v23);
      while (__stxp(v24, v23));
      if ((v24 & 0x100000000LL) != 0)
      {
        unint64_t v22 = 0LL;
      }

      else
      {
        do
        {
          uint64_t v26 = __ldxp(v23);
          uint64_t v25 = v26;
        }

        while (__stxp(v26, v23));
        if (DWORD2(v26) == -1) {
LABEL_56:
        }
          swift::swift_abortWeakRetainOverflow((swift *)v20, (uint64_t)from, a3, a4);
        uint64_t v27 = DWORD2(v26);
        uint64_t v28 = HIDWORD(*((void *)&v26 + 1));
        while (1)
        {
          int64_t v29 = v27 + 1;
          BOOL v30 = v27 | (unint64_t)(v28 << 32);
          uint64_t v31 = (unsigned __int128 *)(v22 + 16);
          do
          {
            while (1)
            {
              uint64_t v32 = __ldxp(v31);
              uint64_t v27 = DWORD2(v32);
              uint64_t v33 = (void)v32 != v25;
              if (*((void *)&v32 + 1) != v30) {
                ++v33;
              }
              if (!v33) {
                break;
              }
              if (!__stxp(v32, v31)) {
                goto LABEL_51;
              }
            }
          }

          while (__stxp(__PAIR128__(v29, v25), v31));
LABEL_51:
          if ((void)v32 == v25 && *((void *)&v32 + 1) == v30) {
            break;
          }
          uint64_t v28 = HIDWORD(*((void *)&v32 + 1));
          uint64_t v25 = v32;
          if (DWORD2(v32) == -1) {
            goto LABEL_56;
          }
        }
      }
    }

    if (v22) {
      unint64_t v35 = (void *)(v22 | 1);
    }
    else {
      unint64_t v35 = 0LL;
    }
    *location = v35;
  }

  else
  {
    objc_copyWeak(location, from);
  }

            unint64_t v20 = 0LL;
LABEL_33:
            setParentForOpaqueReturnTypeNodes(a1, a2, v20);
            if (v14 == ++v19) {
              return a2;
            }
          }

          if ((_DWORD)v21 != 2) {
            goto LABEL_32;
          }
          BOOL v21 = 2LL;
LABEL_38:
          if (v21 > v19) {
            goto LABEL_41;
          }
          goto LABEL_32;
        case 5:
          uint64_t v14 = *((unsigned int *)a3 + 2);
          if ((_DWORD)v14) {
            goto LABEL_31;
          }
          break;
        case 2:
          uint64_t v14 = 2LL;
          goto LABEL_31;
      }

      return a2;
    }

    unint64_t v10 = *((unsigned __int8 *)a3 + 18);
    switch(v10)
    {
      case 1:
        uint64_t v12 = 0LL;
        break;
      case 2:
        uint64_t v12 = 1LL;
        break;
      case 5:
        int64_t v11 = *((unsigned int *)a3 + 2);
        if (!(_DWORD)v11) {
          goto LABEL_22;
        }
        uint64_t v12 = v11 - 1;
        uint64_t v13 = *(swift::Demangle::__runtime::Node **)a3;
LABEL_21:
        if (*(_WORD *)(*((void *)v13 + v12) + 16LL) == 342) {
          return a2;
        }
LABEL_22:
        int64_t v15 = (*((void *)a1 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v15 || v15 + 24 > *((void *)a1 + 2))
        {
          uint64_t v16 = 2LL * *((void *)a1 + 4);
          if (v16 <= 0x20) {
            uint64_t v16 = 32LL;
          }
          *((void *)a1 + 4) = v16;
          uint64_t v17 = v16 + 8;
          unint64_t v18 = malloc(v16 + 8);
          *unint64_t v18 = *((void *)a1 + 3);
          int64_t v15 = ((unint64_t)v18 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)a1 + 2) = (char *)v18 + v17;
          *((void *)a1 + 3) = v18;
        }

        *((void *)a1 + 1) = v15 + 24;
        *(_WORD *)(v15 + 16) = 342;
        *(_BYTE *)(v15 + 18) = 4;
        *(void *)int64_t v15 = a2;
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)a3,  (swift::Demangle::__runtime::Node *)v15,  a1,  a4,  a5);
        return a2;
      default:
        goto LABEL_22;
    }

    uint64_t v13 = a3;
    goto LABEL_21;
  }

  return result;
}

  *(_DWORD *)(v6 + 12736) = v12 + 1;
  v14[v12] = v11;
  uint64_t v27 = *((unsigned __int8 *)v8 + 18);
  if (v27 != 2)
  {
    if (v27 != 5 || (uint64_t v27 = *((_DWORD *)v8 + 2), v27 <= 1))
    {
      *(_DWORD *)a4 = 1;
      *(void *)(a4 + 8) = v8;
      uint64_t v32 = 1465;
      goto LABEL_51;
    }
  }

  uint64_t v28 = 0;
  ++a3;
  while (1)
  {
    int64_t v29 = v8;
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v28 > v27 - 2)
    {
      BOOL v30 = (swift::Demangle::__runtime::Node **)*((void *)v8 + v27 - 1);
      if (*((_WORD *)v30 + 8) != 207)
      {
        *(_DWORD *)a4 = 1;
        *(void *)(a4 + 8) = v30;
        uint64_t v32 = 1471;
        goto LABEL_51;
      }

      uint64_t v31 = *((unsigned __int8 *)v30 + 18);
      if (v31 != 1)
      {
        if (v31 != 5 || *((_DWORD *)v30 + 2) != 1)
        {
          *(_DWORD *)a4 = 1;
          *(void *)(a4 + 8) = v30;
          uint64_t v32 = 1472;
          goto LABEL_51;
        }

        BOOL v30 = (swift::Demangle::__runtime::Node **)*v30;
      }

      a2 = (swift::Demangle::__runtime::Node **)*v30;
      if (*((_WORD *)*v30 + 8) == 232) {
        goto LABEL_3;
      }
      goto LABEL_50;
    }
  }