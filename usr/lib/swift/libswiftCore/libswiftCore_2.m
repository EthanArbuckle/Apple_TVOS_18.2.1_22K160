void *specialized _copySequenceToContiguousArray<A>(_:)(void *result, uint64_t a2)
{
  void *v2;
  unint64_t v3;
  int64_t v4;
  uint64_t v5;
  unint64_t v6;
  __objc2_class **v7;
  __objc2_class **v8;
  int64_t v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  int64_t v14;
  unint64_t v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  __objc2_class **v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  const void *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  __objc2_class *v29;
  int64_t v30;
  v2 = result;
  v3 = 0LL;
  v4 = 0LL;
  if (a2 + 1 < 64) {
    v5 = ~(-1LL << (a2 + 1));
  }
  else {
    v5 = -1LL;
  }
  v6 = *result & v5;
  v7 = &_swiftEmptyArrayStorage;
  v8 = &_swiftEmptySetSingleton;
  v9 = (unint64_t)(a2 + 64) >> 6;
  v30 = v9;
  if (!v6) {
    goto LABEL_9;
  }
LABEL_5:
  v10 = __clz(__rbit64(v6));
  v6 &= v6 - 1;
  v11 = v10 | (v4 << 6);
  if (v3)
  {
LABEL_6:
    v12 = __OFSUB__(v3--, 1LL);
    if (!v12) {
      goto LABEL_31;
    }
LABEL_37:
    __break(1u);
LABEL_38:
    __break(1u);
LABEL_39:
    __break(1u);
  }

  else
  {
    while (1)
    {
      v15 = (unint64_t)v7[3];
      v16 = v15 & 0xFFFFFFFFFFFFFFFELL;
      if (v16 <= 1) {
        v17 = 1LL;
      }
      else {
        v17 = v16;
      }
      v18 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_HashTable.Bucket>();
      v19 = (__objc2_class **)swift_allocObject(v18, 8 * v17 + 32, 7uLL);
      v20 = _swift_stdlib_malloc_size(v19);
      v21 = v20 - 32;
      if (v20 < 32) {
        v21 = v20 - 25;
      }
      v22 = v21 >> 3;
      v19[2] = (__objc2_class *)v17;
      v19[3] = (__objc2_class *)(2 * (v21 >> 3));
      v23 = (unint64_t)(v19 + 4);
      v24 = (unint64_t)v7[3] >> 1;
      if (v7[2])
      {
        v25 = v7 + 4;
        v7[2] = 0LL;
      }

      v8 = (__objc2_class **)(v23 + 8 * v24);
      v26 = (v22 & 0x7FFFFFFFFFFFFFFFLL) - v24;
      result = (void *)swift_release((uint64_t)v7);
      v7 = v19;
      v9 = v30;
      v12 = __OFSUB__(v26, 1LL);
      v3 = v26 - 1;
      if (v12) {
        goto LABEL_37;
      }
LABEL_31:
      *v8++ = (__objc2_class *)v11;
      if (v6) {
        goto LABEL_5;
      }
LABEL_9:
      v12 = __OFADD__(v4++, 1LL);
      if (v12) {
        goto LABEL_39;
      }
      if (v4 >= v9)
      {
LABEL_33:
        v27 = (unint64_t)v7[3];
        if (v27 >= 2)
        {
          v28 = v27 >> 1;
          v12 = __OFSUB__(v28, v3);
          v29 = (__objc2_class *)(v28 - v3);
          if (v12) {
            goto LABEL_41;
          }
          v7[2] = v29;
        }

        return v7;
      }

      v13 = v2[v4];
      if (!v13)
      {
        v14 = v4 + 1;
        if (v4 + 1 >= v9) {
          goto LABEL_33;
        }
        v13 = v2[v14];
        if (!v13)
        {
          while (1)
          {
            v4 = v14 + 1;
            if (__OFADD__(v14, 1LL)) {
              goto LABEL_38;
            }
            if (v4 >= v9) {
              goto LABEL_33;
            }
            v13 = v2[v4];
            ++v14;
            if (v13) {
              goto LABEL_18;
            }
          }
        }

        ++v4;
      }

__objc2_class **specialized _copySequenceToContiguousArray<A>(_:)(char *a1, char *a2)
{
  if (a1)
  {
    v2 = a1;
    size_t v5 = 0LL;
    v6 = &_swiftEmptyArrayStorage;
    v3 = &_swiftEmptySetSingleton;
    if (a2) {
      goto LABEL_6;
    }
  }

  else
  {
    size_t v5 = 0LL;
    v6 = &_swiftEmptyArrayStorage;
    if (!a2) {
      goto LABEL_7;
    }
    v3 = &_swiftEmptySetSingleton;
    v2 = 0LL;
  }

  while (1)
  {
    do
    {
      if (!v2 || !a2) {
        goto LABEL_35;
      }
      if (v2 >= a2) {
        goto LABEL_33;
      }
      char v13 = *v2++;
      char v12 = v13;
      if (v5)
      {
        v14 = v6;
        BOOL v9 = __OFSUB__(v5--, 1LL);
        if (v9) {
          goto LABEL_32;
        }
      }

      else
      {
        unint64_t v15 = (unint64_t)v6[3];
        if ((uint64_t)((v15 >> 1) + 0x4000000000000000LL) < 0)
        {
          __break(1u);
LABEL_35:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x4BAuLL,  0);
        }

        int64_t v16 = v15 & 0xFFFFFFFFFFFFFFFELL;
        if (v16 <= 1) {
          uint64_t v17 = 1LL;
        }
        else {
          uint64_t v17 = v16;
        }
        uint64_t v18 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
        v14 = (__objc2_class **)swift_allocObject(v18, v17 + 32, 7uLL);
        size_t v19 = 2 * _swift_stdlib_malloc_size(v14) - 64;
        v14[2] = (__objc2_class *)v17;
        v14[3] = (__objc2_class *)v19;
        v20 = (char *)(v14 + 4);
        size_t v21 = (unint64_t)v6[3] >> 1;
        v3 = (__objc2_class **)((char *)v14 + v21 + 32);
        size_t v22 = (v19 >> 1) - v21;
        if (v6[2])
        {
          v6[2] = 0LL;
        }

        swift_release((uint64_t)v6);
        BOOL v9 = __OFSUB__(v22, 1LL);
        size_t v5 = v22 - 1;
        if (v9)
        {
LABEL_32:
          __break(1u);
LABEL_33:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x4BAuLL,  0);
        }
      }

      *(_BYTE *)v3 = v12;
      v3 = (__objc2_class **)((char *)v3 + 1);
      v6 = v14;
LABEL_6:
      ;
    }

    while (a2 != v2);
LABEL_7:
    unint64_t v7 = (unint64_t)v6[3];
    if (v7 < 2) {
      return v6;
    }
    unint64_t v8 = v7 >> 1;
    BOOL v9 = __OFSUB__(v8, v5);
    v10 = (__objc2_class *)(v8 - v5);
    if (!v9) {
      break;
    }
    __break(1u);
  }

  v6[2] = v10;
  return v6;
}

__objc2_class **_copySequenceToContiguousArray<A>(_:)( unsigned int (*a1)(char *, uint64_t, uint64_t *), uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v7 = *(AssociatedTypeWitness - 1);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v77 = (char *)&v71 - v8;
  uint64_t v11 = type metadata accessor for Optional(0LL, (uint64_t)AssociatedTypeWitness, v9, v10);
  uint64_t v73 = *(void *)(v11 - 8);
  uint64_t v74 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  v78 = (char *)&v71 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  int64_t v16 = (char *)&v71 - v15;
  uint64_t v17 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v14);
  size_t v19 = (char *)&v71 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v82 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v72 = *(void *)(v82 - 8);
  MEMORY[0x1895F8858](v82);
  v83 = (char *)&v71 - v20;
  uint64_t v84 = a3;
  size_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 40);
  v81 = a1;
  uint64_t v22 = v21(a2, a3);
  if (v22 <= 0)
  {
    uint64_t v34 = *(unsigned __int8 *)(v7 + 80);
    uint64_t v75 = ~v34;
    uint64_t v76 = v34;
    uint64_t v79 = (v34 + 32) & ~v34;
    v26 = &_swiftEmptyArrayStorage;
  }

  else
  {
    uint64_t v23 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
    uint64_t v24 = *(void *)(v7 + 72);
    uint64_t v25 = *(unsigned __int8 *)(v7 + 80);
    v26 = (__objc2_class **)swift_allocObject( v23,  ((v25 + *(unsigned int *)(v23 + 48)) & ~v25) + v24 * v22,  v25 | *(unsigned __int16 *)(v23 + 52));
    size_t v27 = _swift_stdlib_malloc_size(v26);
    if (!v24) {
      goto LABEL_47;
    }
    uint64_t v75 = ~v25;
    uint64_t v76 = v25;
    uint64_t v79 = (v25 + 32) & ~v25;
    if (v27 - v79 == 0x8000000000000000LL && v24 == -1) {
LABEL_49:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
    uint64_t v32 = (uint64_t)(v27 - v79) / v24;
    swift_retain((unint64_t *)v26, v28, v29, v30);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( (uint64_t)AssociatedTypeWitness,  AssociatedTypeWitness);
    v26[2] = (__objc2_class *)v22;
    v26[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v32));
    swift_release((uint64_t)v26);
  }

  unint64_t v35 = (unint64_t)v26[3];
  (*(void (**)(char *, unsigned int (*)(char *, uint64_t, uint64_t *), uint64_t))(v17 + 16))( v19,  v81,  a2);
  uint64_t v36 = v84;
  (*(void (**)(uint64_t, uint64_t))(v84 + 32))(a2, v84);
  if (v22 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v37 = (char *)v26 + v79;
  uint64_t v38 = v36;
  unint64_t v39 = v35 >> 1;
  unint64_t v40 = v82;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v38,  a2,  v82,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v84 = *(void *)(AssociatedConformanceWitness + 16);
  if (v22)
  {
    v39 -= v22;
    while (1)
    {
      ((void (*)(unint64_t, unint64_t))v84)(v40, AssociatedConformanceWitness);
      (*(void (**)(char *, char *, uint64_t *))(v7 + 32))(v37, v16, AssociatedTypeWitness);
      v37 += *(void *)(v7 + 72);
      if (!--v22) {
        goto LABEL_14;
      }
    }

__objc2_class **_UnsafePartiallyInitializedContiguousArrayBuffer.init(initialCapacity:)( uint64_t a1, uint64_t *a2)
{
  if (a1 <= 0) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = getContiguousArrayStorageType<A>(for:)((uint64_t)a2, a2);
  uint64_t v5 = *(a2 - 1);
  uint64_t v6 = *(void *)(v5 + 72);
  uint64_t v7 = *(unsigned __int8 *)(v5 + 80);
  uint64_t v8 = swift_allocObject(v4, ((v7 + *(unsigned int *)(v4 + 48)) & ~v7) + v6 * a1, v7 | *(unsigned __int16 *)(v4 + 52));
  size_t v9 = _swift_stdlib_malloc_size(v8);
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  int64_t v13 = v9 - ((v7 + 32) & ~v7);
  if (v13 == 0x8000000000000000LL && v6 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  uint64_t v15 = v13 / v6;
  swift_retain(v8, v10, v11, v12);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  v8[2] = a1;
  v8[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v15);
  swift_release((uint64_t)v8);
  return (__objc2_class **)v8;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.addWithExistingCapacity(_:)( uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(v2 + 16);
  BOOL v4 = __OFSUB__(v3, 1LL);
  uint64_t v5 = v3 - 1;
  if (v4)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v2 + 16) = v5;
    uint64_t v6 = *(void *)(v2 + 8);
    uint64_t v7 = *(void *)(*(void *)(a2 + 16) - 8LL);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 16))(v6, result);
    *(void *)(v2 + 8) = v6 + *(void *)(v7 + 72);
  }

  return result;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.add(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = v2[2];
  if (!v5)
  {
    uint64_t v6 = *v2;
    unint64_t v7 = *(void *)(*v2 + 24);
    if ((uint64_t)((v7 >> 1) + 0x4000000000000000LL) < 0)
    {
LABEL_17:
      __break(1u);
      goto LABEL_18;
    }

    int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if (v8 <= 1) {
      uint64_t v9 = 1LL;
    }
    else {
      uint64_t v9 = v8;
    }
    uint64_t v10 = *(uint64_t **)(a2 + 16);
    uint64_t v11 = getContiguousArrayStorageType<A>(for:)((uint64_t)v10, v10);
    uint64_t v12 = *(v10 - 1);
    uint64_t v13 = *(void *)(v12 + 72);
    uint64_t v14 = *(unsigned __int8 *)(v12 + 80);
    uint64_t v15 = swift_allocObject( v11,  ((v14 + *(unsigned int *)(v11 + 48)) & ~v14) + v13 * v9,  v14 | *(unsigned __int16 *)(v11 + 52));
    size_t v16 = _swift_stdlib_malloc_size(v15);
    if (!v13) {
LABEL_18:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    uint64_t v20 = (v14 + 32) & ~v14;
    if (v16 - v20 == 0x8000000000000000LL && v13 == -1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
    }
    uint64_t v22 = (uint64_t)(v16 - v20) / v13;
    swift_retain(v15, v17, v18, v19);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
    v15[2] = v9;
    v15[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v22);
    swift_release((uint64_t)v15);
    uint64_t v24 = *(void *)(v6 + 24) >> 1;
    uint64_t v5 = (v15[3] >> 1) - v24;
    v2[1] = (uint64_t)v15 + v20 + v24 * v13;
    v2[2] = v5;
    if (*(void *)(v6 + 16))
    {
      UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v6 + v20), v24, (char *)v15 + v20, (uint64_t)v10);
      *(void *)(v6 + 16) = 0LL;
    }

    swift_release(v6);
    uint64_t *v2 = (uint64_t)v15;
  }

  if (__OFSUB__(v5, 1LL))
  {
    __break(1u);
    goto LABEL_17;
  }

  v2[2] = v5 - 1;
  uint64_t v25 = v2[1];
  uint64_t v26 = *(void *)(*(void *)(a2 + 16) - 8LL);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 16))(v25, a1);
  v2[1] = v25 + *(void *)(v26 + 72);
  return result;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.finish()()
{
  uint64_t result = *v0;
  unint64_t v2 = *(void *)(*v0 + 24LL);
  if (v2 < 2) {
    goto LABEL_4;
  }
  unint64_t v3 = v2 >> 1;
  uint64_t v4 = v0[2];
  BOOL v5 = __OFSUB__(v3, v4);
  uint64_t v6 = v3 - v4;
  if (!v5)
  {
    *(void *)(result + 16) = v6;
LABEL_4:
    void *v0 = &_swiftEmptyArrayStorage;
    v0[2] = 0LL;
    return result;
  }

  __break(1u);
  return result;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.result.setter(uint64_t a1)
{
  uint64_t result = swift_release(*v1);
  uint64_t *v1 = a1;
  return result;
}

uint64_t (*_UnsafePartiallyInitializedContiguousArrayBuffer.result.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.p.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.p.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*_UnsafePartiallyInitializedContiguousArrayBuffer.p.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity.getter( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*_UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UnsafePartiallyInitializedContiguousArrayBuffer.finishWithOriginalCount()()
{
  uint64_t result = *v0;
  uint64_t *v0 = (uint64_t)&_swiftEmptyArrayStorage;
  v0[2] = 0LL;
  return result;
}

uint64_t String.init(cString:)(uint8x16_t *a1)
{
  size_t v2 = _swift_stdlib_strlen(a1->i8);
  if ((v2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  int64_t v3 = v2;
  int64_t v4 = validateUTF8(_:)(a1->i64, v2);
  if ((v6 & 1) != 0) {
    return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v3, v4, v5);
  }
  else {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v3, v4 & 1);
  }
}

{
  size_t v2;
  int64_t v3;
  int64_t v4;
  int64_t v5;
  char v6;
  size_t v2 = _swift_stdlib_strlen(a1->i8);
  if ((v2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  int64_t v3 = v2;
  int64_t v4 = validateUTF8(_:)(a1->i64, v2);
  if ((v6 & 1) != 0) {
    return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v3, v4, v5);
  }
  else {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v3, v4 & 1);
  }
}

uint64_t static String._fromUTF8Repairing(_:)(uint8x16_t *a1, uint64_t a2)
{
  int64_t v4 = validateUTF8(_:)(a1->i64, a2);
  if ((v6 & 1) != 0) {
    return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, a2, v4, v5);
  }
  else {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v4 & 1);
  }
}

uint64_t *_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n( uint64_t *result, uint64_t a2)
{
  if (result)
  {
    if (a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    int64_t v3 = (uint8x16_t *)result;
    int64_t v4 = validateUTF8(_:)(result, a2);
    if ((v6 & 1) != 0) {
      return (uint64_t *)repairUTF8(_:firstKnownBrokenRange:)(v3->i8, a2, v4, v5);
    }
    else {
      return (uint64_t *)specialized static String._uncheckedFromUTF8(_:isASCII:)(v3, a2, v4 & 1);
    }
  }

  return result;
}

uint64_t _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5( uint64_t (*a1)(uint64_t, uint64_t, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    return a1(0LL, 0LL, &v13);
  }
  uint64_t v6 = *(void *)(a6 - 8);
  if ((*(_BYTE *)(v6 + 80) & a3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "baseAddress must be a properly aligned pointer for types Element and T",  70LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x7E7uLL,  0);
  }
  uint64_t v7 = *(void *)(v6 + 72);
  uint64_t v8 = *(void *)(*(void *)(a5 - 8) + 72LL);
  if (v7 != v8)
  {
    uint64_t v9 = a4 * v8;
    if ((unsigned __int128)(a4 * (__int128)v8) >> 64 == (a4 * v8) >> 63)
    {
      if (v7)
      {
        if (v7 == -1 && v9 == 0x8000000000000000LL) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
        }
        if (v8 >= v7)
        {
          if (v7 != -1 || v8 != 0x8000000000000000LL)
          {
            uint64_t v11 = v8 % v7;
            goto LABEL_19;
          }
        }

        else
        {
          if (!v8) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x390EuLL,  0);
          }
          if (v7 != 0x8000000000000000LL || v8 != -1)
          {
            uint64_t v11 = v7 % v8;
LABEL_19:
            if (v11) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Buffer must contain a whole number of Element instances",  55LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x7F1uLL,  0);
            }
            a4 = v9 / v7;
            goto LABEL_21;
          }
        }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3913uLL,  0);
      }
    }

    else
    {
      __break(1u);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }

BOOL static Int8.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

uint64_t specialized String.withCString<A>(_:)( unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  if ((a2 & 0x1000000000000000LL) != 0 || !(a2 & 0x2000000000000000LL | a1 & 0x1000000000000000LL))
  {
    LOBYTE(v7) = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, a3, a4);
  }

  else if ((a2 & 0x2000000000000000LL) != 0)
  {
    v9[0] = a1;
    v9[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (a1 <= 0x20u && ((0x100003E01uLL >> a1) & 1) != 0)
    {
      LOBYTE(v7) = 0;
    }

    else
    {
      uint64_t v7 = ((uint64_t (*)(void *, uint64_t))a4)(v9, a3);
      if (v7) {
        LOBYTE(v7) = *(_BYTE *)v7 == 0;
      }
    }
  }

  else
  {
    if ((a1 & 0x1000000000000000LL) != 0) {
      int64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      int64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
    }
    unint64_t v6 = *v5;
    if (v6 <= 0x20 && ((0x100003E01uLL >> v6) & 1) != 0)
    {
      LOBYTE(v7) = 0;
    }

    else
    {
      uint64_t v7 = ((uint64_t (*)(void))a4)();
      if (v7) {
        LOBYTE(v7) = *(_BYTE *)v7 == 0;
      }
    }
  }

  return v7 & 1;
}

uint64_t String.withCString<A>(_:)( void (*a1)(__objc2_class **), uint64_t a2, unint64_t a3, char *a4)
{
  if (((unint64_t)a4 & 0x1000000000000000LL) != 0
    || !((unint64_t)a4 & 0x2000000000000000LL | a3 & 0x1000000000000000LL))
  {
    return _StringGuts._slowWithCString<A>(_:)(a1, a2, a3, a4);
  }

  MEMORY[0x1895F8858](a1);
  if ((v5 & 0x2000000000000000LL) != 0)
  {
    v9[0] = v4;
    v9[1] = v5 & 0xFFFFFFFFFFFFFFLL;
    return v6(v9);
  }

  else
  {
    if ((v4 & 0x1000000000000000LL) == 0 && _StringObject.sharedUTF8.getter(v4, v5) && v8 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    return partial apply for closure #1 in _StringGuts.withCString<A>(_:)();
  }

BOOL static UInt8.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

uint64_t static String._tryFromUTF8(_:)(uint8x16_t *a1, uint64_t a2)
{
  char v4 = validateUTF8(_:)(a1->i64, a2);
  if ((v5 & 1) != 0) {
    return 0LL;
  }
  else {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v4 & 1);
  }
}

unint64_t static String.decodeCString<A>(_:as:repairingInvalidCodeUnits:)( uint8x16_t *a1, ValueMetadata *a2, int a3, ValueMetadata *a4, const char *a5)
{
  int v73 = a3;
  uint64_t v72 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a5,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v9 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)a5,  (uint64_t)a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)
                 + 8);
  uint64_t v71 = *(const char **)(*(void *)(v9 + 24) + 16LL);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v71,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v10);
  uint64_t v12 = (char *)&v64 - v11;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v14 = *(v13 - 1);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v64 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v64 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v64 - v22;
  if (a4 == &type metadata for Unicode.UTF8)
  {
    if (!a1) {
      return 0LL;
    }
    size_t v28 = _swift_stdlib_strlen(a1->i8);
    if ((v28 & 0x8000000000000000LL) != 0) {
      goto LABEL_33;
    }
    uint64_t v25 = v28;
    goto LABEL_18;
  }

  if (a4 != &type metadata for Unicode.UTF16)
  {
    if (!a1) {
      return 0LL;
    }
    if (v72 == &type metadata for Unicode.UTF8)
    {
      int64_t v24 = _swift_stdlib_strlen(a1->i8);
      if (v24 < 0) {
        goto LABEL_33;
      }
      uint64_t v25 = v24;
      uint64_t v26 = *(void *)(v14 + 72);
      if (v26 != 1)
      {
        if ((unsigned __int128)(v24 * (__int128)v26) >> 64 != (v24 * v26) >> 63)
        {
          __break(1u);
          return 0LL;
        }

        if (v26 < 1 && v26 != -1)
        {
          if (!v26) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x390EuLL,  0);
          }
          LODWORD(v66) = 0;
          uint64_t v65 = 2033LL;
          LOBYTE(v64) = 2;
          uint64_t v38 = "Buffer must contain a whole number of Element instances";
          uint64_t v39 = 55LL;
LABEL_34:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  v38,  v39,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  v61,  v62,  v63);
        }

        uint64_t v25 = v24 * v26;
        if (v24 * v26 < 0)
        {
LABEL_33:
          int v63 = 0;
          unint64_t v62 = 1343LL;
          char v61 = 2;
          uint64_t v38 = "UnsafeBufferPointer with negative count";
          uint64_t v39 = 39LL;
          goto LABEL_34;
        }
      }

BOOL static BinaryInteger.!= infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v104 = a1;
  uint64_t v105 = a2;
  v99 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v99,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v96 = (char *)&v87 - v10;
  v95 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t v94 = swift_getAssociatedTypeWitness( 0LL,  v95,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v94);
  v93 = (char *)&v87 - v12;
  uint64_t v103 = *(void *)(a4 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  v98 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v87 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  v101 = (char *)&v87 - v19;
  uint64_t v102 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v87 - v24;
  MEMORY[0x1895F8858](v23);
  v100 = (char *)&v87 - v26;
  size_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  int v28 = v27(a3, a5);
  if (((v28 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a6 + 64))(a4, a6)) & 1) != 0)
  {
    v87 = v25;
    v88 = v22;
    int64_t v29 = v99;
    v89 = v17;
    char v30 = v27(a3, a5);
    char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v91 = a5;
    uint64_t v32 = v31(a3, a5);
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    uint64_t v92 = a4;
    uint64_t v90 = a6;
    uint64_t v34 = v33(a4, a6);
    uint64_t v35 = a3;
    if ((v30 & 1) != 0)
    {
      if (v34 >= v32)
      {
        unint64_t v54 = v94;
        uint64_t v55 = v95;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v95,  a3,  v94,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v57 = v93;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v54,  AssociatedConformanceWitness);
        uint64_t v58 = v100;
        (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
        uint64_t v59 = v91;
        uint64_t v60 = v104;
        LOBYTE(v54) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v91 + 32) + 8LL)
                                                                          + 32LL))( v104,  v58,  a3);
        uint64_t v61 = v102;
        unint64_t v62 = *(void (**)(char *, uint64_t))(v102 + 8);
        v62(v58, v35);
        int v63 = v87;
        (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v87, v60, v35);
        uint64_t v64 = v103;
        uint64_t v65 = v89;
        uint64_t v66 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v89, v105, v92);
        if ((v54 & 1) != 0)
        {
          uint64_t v67 = v90;
          unint64_t v68 = v101;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v63, v35, v59, v66, v90);
          char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 16) + 8LL) + 8LL))( v68,  v65,  v66);
          uint64_t v69 = *(void (**)(char *, uint64_t))(v64 + 8);
          v69(v68, v66);
          v69(v65, v66);
        }

        else
        {
          (*(void (**)(char *, uint64_t))(v64 + 8))(v65, v66);
          v62(v63, v35);
          char v40 = 0;
        }
      }

      else
      {
        uint64_t v36 = v101;
        uint64_t v37 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v105, v92);
        uint64_t v38 = v91;
        uint64_t v39 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v36, v37, v90, a3, v91);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v38 + 16) + 8LL) + 8LL))( v104,  v39,  a3);
        (*(void (**)(char *, uint64_t))(v102 + 8))(v39, a3);
      }
    }

    else if (v32 >= v34)
    {
      uint64_t v70 = v92;
      unint64_t v71 = AssociatedTypeWitness;
      unint64_t v72 = swift_getAssociatedConformanceWitness( (uint64_t)v29,  v92,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      int v73 = v96;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v72 + 8))( &unk_18180BE68,  256LL,  v71,  v72);
      uint64_t v74 = v101;
      (*((void (**)(char *, uint64_t, const char *))v29 + 3))(v73, v70, v29);
      uint64_t v75 = v90;
      uint64_t v76 = v105;
      LOBYTE(v71) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8LL) + 32LL))( v105,  v74,  v70);
      uint64_t v77 = v103;
      v78 = *(void (**)(char *, uint64_t))(v103 + 8);
      v78(v74, v70);
      uint64_t v79 = v102;
      unint64_t v80 = v88;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v88, v104, v35);
      v81 = *(void (**)(char *, uint64_t, uint64_t))(v77 + 16);
      unint64_t v82 = v98;
      v81(v98, v76, v70);
      if ((v71 & 1) != 0)
      {
        uint64_t v83 = v75;
        uint64_t v84 = v91;
        v85 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v82, v70, v83, v35, v91);
        char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v84 + 16) + 8LL) + 8LL))( v80,  v85,  v35);
        v86 = *(void (**)(char *, uint64_t))(v79 + 8);
        v86(v85, v35);
        v86(v80, v35);
      }

      else
      {
        v78(v82, v70);
        (*(void (**)(char *, uint64_t))(v79 + 8))(v80, v35);
        char v40 = 0;
      }
    }

    else
    {
      uint64_t v46 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v104, a3);
      uint64_t v47 = v90;
      uint64_t v48 = v101;
      uint64_t v49 = v46;
      uint64_t v50 = v92;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v49, a3, v91, v92, v90);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v47 + 16) + 8LL) + 8LL))( v48,  v105,  v50);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v48, v50);
    }
  }

  else
  {
    uint64_t v41 = v104;
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
    uint64_t v43 = v105;
    if (v42 >= (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6))
    {
      uint64_t v51 = v101;
      (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v43, a4);
      unint64_t v52 = v100;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v51, a4, a6, a3, a5);
      char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 16) + 8LL) + 8LL))( v41,  v52,  a3);
      (*(void (**)(char *, uint64_t))(v102 + 8))(v52, a3);
    }

    else
    {
      v44 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v41, a3);
      uint64_t v45 = v101;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v44, a3, a5, a4, a6);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a6 + 16) + 8LL) + 8LL))( v45,  v43,  a4);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v45, a4);
    }
  }

  return (v40 & 1) == 0;
}

unint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)( uint8x16_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for UnsafeBufferPointer<UInt8>
    && &full type metadata for Unicode.UTF16 == &full type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, a2, a3 & 1);
  }

  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for [UInt8]
    && &full type metadata for Unicode.UTF16 == &full type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)((unint64_t)a1, a3 & 1, a3, a4);
  }

  return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)((unsigned __int16 *)a1, a2, a3 & 1);
}

unint64_t static String._fromCodeUnits<A, B>(_:encoding:repair:)( uint64_t a1, uint64_t a2, char a3, swift *a4, ValueMetadata *a5, uint64_t a6, const char *a7)
{
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v21 = (uint64_t *)((char *)&v44 - v20);
  if (v18 == (char *)&unk_189B88C10 && a5 == &type metadata for Unicode.ASCII) {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)( *(uint8x16_t **)a1,  *(void *)(a1 + 8),  a3 & 1);
  }
  if (a4 == (swift *)&unk_189B88B80 && a5 == &type metadata for Unicode.ASCII) {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(*(void *)a1, a3 & 1, v17, v18);
  }
  if (v16 != &type metadata for Unicode.ASCII)
  {
    int v38 = a3 & 1;
    uint64_t v39 = a1;
    uint64_t v40 = (uint64_t)a4;
    uint64_t v41 = (uint64_t)a5;
    uint64_t v42 = a6;
    uint64_t v37 = a7;
    return static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(v39, v38, v40, v41, v42, v37);
  }

  uint64_t v45 = *(void (**)(char *, uint64_t, swift *))(v19 + 16);
  v45((char *)&v44 - v20, a1, a4);
  uint64_t v23 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasContiguousBytes);
  if ((swift_dynamicCast((char *)v47, v21, a4, v23, 6uLL) & 1) == 0)
  {
    uint64_t v48 = 0LL;
    memset(v47, 0, sizeof(v47));
    uint64_t HasContiguous = outlined destroy of _HasContiguousBytes?( (uint64_t)v47,  &demangling cache variable for type metadata for _HasContiguousBytes?);
    goto LABEL_14;
  }

  uint64_t v24 = a7;
  outlined init with take of MirrorPath(v47, (uint64_t)&v49);
  uint64_t v25 = v51;
  uint64_t v26 = v52;
  __swift_project_boxed_opaque_existential_0Tm(&v49, v51);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v26 + 16))(v25, v26) & 1) == 0)
  {
    uint64_t HasContiguous = __swift_destroy_boxed_opaque_existential_1Tm(&v49);
    a7 = v24;
LABEL_14:
    uint64_t v46 = a7;
    MEMORY[0x1895F8858](HasContiguous);
    *(&v44 - 4) = (uint64_t)a4;
    *(&v44 - 3) = (uint64_t)a5;
    *(&v44 - 2) = a6;
    *(&v44 - 1) = (uint64_t)a7;
    uint64_t v31 = *(void *)(a6 + 8);
    (*(void (**)(uint64_t *__return_ptr, unint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, unint64_t *@<X8>)))(v31 + 72))( &v49,  partial apply for closure #2 in static String._fromCodeUnits<A, B>(_:encoding:repair:));
    if (v50 == 1)
    {
      v45(v15, a1, a4);
      int64_t v32 = (*(uint64_t (**)(swift *, uint64_t))(v31 + 56))(a4, v31);
      MEMORY[0x1895F8858](v32);
      *(&v44 - 4) = (uint64_t)a4;
      *(&v44 - 3) = (uint64_t)a5;
      v33 = v46;
      *(&v44 - 2) = a6;
      *(&v44 - 1) = (uint64_t)v33;
      unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  (const char *)v31,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
      uint64_t v29 = (uint64_t)_ss12_ArrayBufferV010withUnsafeB7Pointeryqd__qd__SRyxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxSSSgIsgyrzo_AByxGAFsAE_pAFRsd__r__lIetMggozo_Tp5( (void *(*)(uint64_t *__return_ptr, uint64_t, unint64_t))partial apply for closure #2 in static String._fromCodeUnits<A, B>(_:encoding:repair:),  (uint64_t)(&v44 - 6),  v32,  AssociatedTypeWitness);
      uint64_t v36 = v35;
      swift_release(v32);
      if (v36) {
        return v29;
      }
      int v38 = a3 & 1;
      uint64_t v39 = a1;
      uint64_t v40 = (uint64_t)a4;
      uint64_t v41 = (uint64_t)a5;
      uint64_t v42 = a6;
      uint64_t v37 = v46;
    }

    else
    {
      uint64_t v37 = v46;
      if (v50) {
        return v49;
      }
      int v38 = a3 & 1;
      uint64_t v39 = a1;
      uint64_t v40 = (uint64_t)a4;
      uint64_t v41 = (uint64_t)a5;
      uint64_t v42 = a6;
    }

    return static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(v39, v38, v40, v41, v42, v37);
  }

  uint64_t v27 = v51;
  uint64_t v28 = v52;
  __swift_project_boxed_opaque_existential_0Tm(&v49, v51);
  (*(void (**)(__int128 *__return_ptr, unint64_t (*)@<X0>(uint8x16_t *@<X0>, uint64_t@<X1>, unint64_t *@<X8>), void, void *, uint64_t, uint64_t))(v28 + 8))( v47,  closure #1 in static String._fromCodeUnits<A, B>(_:encoding:repair:),  0LL,  &unk_189B88B50,  v27,  v28);
  if (*((void *)&v47[0] + 1)) {
    uint64_t v29 = *(void *)&v47[0];
  }
  else {
    uint64_t v29 = static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1, a3 & 1, (uint64_t)a4, (uint64_t)a5, a6, v24);
  }
  __swift_destroy_boxed_opaque_existential_1Tm(&v49);
  return v29;
}

void String.withCString<A, B>(encodedAs:_:)( ValueMetadata *a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  if (a1 == &type metadata for Unicode.UTF8)
  {
    MEMORY[0x1895F8858](a1);
    v12[2] = v5;
    v12[3] = v6;
    v12[4] = v8;
    v12[5] = v7;
    v12[6] = v9;
    String.withCString<A>(_:)( (void (*)(__objc2_class **))partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:),  (uint64_t)v12,  v10,  v11);
  }

  else
  {
    String._slowWithCString<A, B>(encodedAs:_:)((uint64_t)a1, a2, a3, a4, a5);
  }

unint64_t String.init<A>(decodingCString:as:)( uint8x16_t *a1, ValueMetadata *a2, ValueMetadata *a3, const char *a4)
{
  uint64_t v64 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v8 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)a4,  (uint64_t)a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)
                 + 8);
  int v63 = *(const char **)(*(void *)(v8 + 24) + 16LL);
  unint64_t v62 = swift_getAssociatedTypeWitness( 0LL,  v63,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v62);
  unint64_t v10 = (char *)&v57 - v9;
  uint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v12 = *(v11 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v57 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v57 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v57 - v19;
  if (a3 == &type metadata for Unicode.UTF8)
  {
    size_t v25 = _swift_stdlib_strlen(a1->i8);
    if ((v25 & 0x8000000000000000LL) != 0) {
      goto LABEL_25;
    }
    uint64_t v22 = v25;
    goto LABEL_16;
  }

  if (a3 == &type metadata for Unicode.UTF16)
  {
    char v30 = a1;
    if (a1->i16[0])
    {
      char v30 = a1;
      do
      {
        int v31 = v30->u16[1];
        char v30 = (uint8x16_t *)((char *)v30 + 2);
      }

      while (v31);
    }

    uint64_t v32 = (char *)v30 - (char *)a1;
    if (v32 > -2)
    {
      unint64_t result = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, v32 / 2, v64, (char *)1);
      if (!v33) {
        goto LABEL_45;
      }
      return result;
    }

    goto LABEL_25;
  }

  if (v64 == &type metadata for Unicode.UTF8)
  {
    int64_t v21 = _swift_stdlib_strlen(a1->i8);
    if (v21 < 0) {
      goto LABEL_25;
    }
    uint64_t v22 = v21;
    uint64_t v23 = *(void *)(v12 + 72);
    if (v23 != 1)
    {
      if ((unsigned __int128)(v21 * (__int128)v23) >> 64 != (v21 * v23) >> 63)
      {
        __break(1u);
LABEL_47:
        if (!v23) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x390EuLL,  0);
        }
        LODWORD(v59) = 0;
        uint64_t v58 = 2033LL;
        LOBYTE(v57) = 2;
        uint64_t v34 = "Buffer must contain a whole number of Element instances";
        uint64_t v35 = 55LL;
LABEL_26:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  v34,  v35,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  v54,  v55,  v56);
      }

      if (v23 < 1 && v23 != -1) {
        goto LABEL_47;
      }
      uint64_t v22 = v21 * v23;
      if (v21 * v23 < 0)
      {
LABEL_25:
        int v56 = 0;
        unint64_t v55 = 1343LL;
        char v54 = 2;
        uint64_t v34 = "UnsafeBufferPointer with negative count";
        uint64_t v35 = 39LL;
        goto LABEL_26;
      }
    }

uint64_t OpaquePointer._rawValue.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*OpaquePointer._rawValue.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Int OpaquePointer.hashValue.getter(Swift::UInt a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance OpaquePointer()
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance OpaquePointer()
{
  return Hasher._finalize()();
}

unint64_t specialized _Pointer.debugDescription.getter(Swift::UInt64 a1)
{
  Swift::String v1 = _uint64ToString(_:radix:uppercase:)(a1, 16LL, 0);
  uint64_t countAndFlagsBits = v1._countAndFlagsBits;
  unint64_t object = (unint64_t)v1._object;
  if (((uint64_t)v1._object & 0x1000000000000000LL) != 0)
  {
    Swift::Int v5 = String.UTF16View._foreignCount()();
  }

  else
  {
    unint64_t v4 = ((unint64_t)v1._object >> 56) & 0xF;
    Swift::Int v5 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v4 << 16) | 7));
  }

  Swift::Int v6 = 16 - v5;
  if (__OFSUB__(16LL, v5))
  {
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (v6 < 0) {
    goto LABEL_20;
  }
  if (v6)
  {
    Swift::Int v7 = v5 - 16;
    do
    {
      while ((object & 0x2000000000000000LL) != 0)
      {
        unint64_t v10 = specialized _SmallString.init(_:appending:)(0x30uLL, 0xE100000000000000LL, countAndFlagsBits, object);
        if ((v12 & 1) != 0) {
          break;
        }
        unint64_t v13 = v10;
        unint64_t v14 = v11;
        swift_bridgeObjectRelease(object);
        unint64_t object = v14;
        uint64_t countAndFlagsBits = v13;
        BOOL v9 = __CFADD__(v7++, 1LL);
        if (v9) {
          goto LABEL_17;
        }
      }

      if ((object & 0x2000000000000000LL) != 0) {
        uint64_t v8 = HIBYTE(object) & 0xF;
      }
      else {
        uint64_t v8 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }
      _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v8);
      swift_bridgeObjectRelease(object);
      uint64_t countAndFlagsBits = 48LL;
      unint64_t object = 0xE100000000000000LL;
      BOOL v9 = __CFADD__(v7++, 1LL);
    }

    while (!v9);
  }

Swift::String __swiftcall _rawPointerToString(_:)(Builtin::RawPointer a1)
{
  Swift::String v1 = _uint64ToString(_:radix:uppercase:)((Swift::UInt64)a1, 16LL, 0);
  uint64_t countAndFlagsBits = v1._countAndFlagsBits;
  unint64_t object = (unint64_t)v1._object;
  if (((uint64_t)v1._object & 0x1000000000000000LL) != 0)
  {
    Swift::Int v5 = String.UTF16View._foreignCount()();
  }

  else
  {
    unint64_t v4 = ((unint64_t)v1._object >> 56) & 0xF;
    Swift::Int v5 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v4 << 16) | 7));
  }

  Swift::Int v6 = 16 - v5;
  if (__OFSUB__(16LL, v5))
  {
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (v6 < 0) {
    goto LABEL_20;
  }
  if (v6)
  {
    Swift::Int v7 = v5 - 16;
    do
    {
      while ((object & 0x2000000000000000LL) != 0)
      {
        unint64_t v10 = specialized _SmallString.init(_:appending:)(0x30uLL, 0xE100000000000000LL, countAndFlagsBits, object);
        if ((v12 & 1) != 0) {
          break;
        }
        unint64_t v13 = v10;
        unint64_t v14 = v11;
        swift_bridgeObjectRelease(object);
        unint64_t object = v14;
        uint64_t countAndFlagsBits = v13;
        BOOL v9 = __CFADD__(v7++, 1LL);
        if (v9) {
          goto LABEL_17;
        }
      }

      if ((object & 0x2000000000000000LL) != 0) {
        uint64_t v8 = HIBYTE(object) & 0xF;
      }
      else {
        uint64_t v8 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }
      _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v8);
      swift_bridgeObjectRelease(object);
      uint64_t countAndFlagsBits = 48LL;
      unint64_t object = 0xE100000000000000LL;
      BOOL v9 = __CFADD__(v7++, 1LL);
    }

    while (!v9);
  }

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance OpaquePointer()
{
  return OpaquePointer.debugDescription.getter(*v0);
}

uint64_t Int.init<A>(bitPattern:)(const void *a1, uint64_t a2, uint64_t a3)
{
  size_t v6 = *(void *)(*(void *)(a2 - 8) + 64LL);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v8 + 48))(v7, 1LL, a2) == 1)
  {
    uint64_t v11 = type metadata accessor for Optional(0LL, a2, v9, v10);
    (*(void (**)(const void *, uint64_t))(*(void *)(v11 - 8) + 8LL))(a1, v11);
    return 0LL;
  }

  else
  {
    memcpy((char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, v6);
    return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 48))(a2, a3);
  }

uint64_t CVaListPointer._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*CVaListPointer._value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t CVaListPointer.debugDescription.getter(Swift::UInt64 a1)
{
  return specialized _Pointer.debugDescription.getter(a1);
}

uint64_t specialized static Optional<A>.== infix(_:_:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = (a2 | a4) == 0;
  if (!a2 || !a4) {
    return v4;
  }
  if (a1 == a3 && a2 == a4) {
    return 1LL;
  }
  if ((~a2 & 0x6000000000000000LL) == 0 && (a4 & 0x2000000000000000LL) != 0 && (a4 & 0x4000000000000000LL) != 0) {
    return 0LL;
  }
  return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, 0);
}

uint64_t specialized static Optional<A>.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  if (!v23[3])
  {
    if (!*((void *)&v25 + 1))
    {
      outlined destroy of AnyHashable?(v23);
      return 1LL;
    }

uint64_t static Optional<A>.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = a4;
  uint64_t v34 = a2;
  uint64_t v6 = *(void **)(a3 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  int v31 = (char *)&v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  char v30 = (char *)&v29 - v9;
  uint64_t v12 = type metadata accessor for Optional(0LL, v10, v10, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  __int128 v15 = (char *)&v29 - v14;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v12, v12, 0LL, 0LL);
  uint64_t v33 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v19 = (char *)&v29 - v18;
  __int128 v20 = (char *)&v29 + *(int *)(v17 + 48) - v18;
  __int128 v21 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v21((char *)&v29 - v18, a1, v12);
  v21(v20, v34, v12);
  uint64_t v22 = (unsigned int (*)(char *, uint64_t, uint64_t))v6[6];
  if (v22(v19, 1LL, a3) == 1)
  {
    char v23 = 1;
    if (v22(v20, 1LL, a3) == 1) {
      goto LABEL_8;
    }
  }

  else
  {
    v21(v15, (uint64_t)v19, v12);
    if (v22(v20, 1LL, a3) != 1)
    {
      __int128 v24 = (void (*)(char *, char *, uint64_t))v6[4];
      __int128 v25 = v30;
      v24(v30, v15, a3);
      uint64_t v26 = v31;
      v24(v31, v20, a3);
      char v23 = (*(uint64_t (**)(char *, char *, uint64_t))(v32 + 8))(v25, v26, a3);
      int64_t v27 = (void (*)(char *, uint64_t))v6[1];
      v27(v26, a3);
      v27(v25, a3);
      goto LABEL_8;
    }

    ((void (*)(char *, uint64_t))v6[1])(v15, a3);
  }

  char v23 = 0;
  uint64_t v13 = v33;
  uint64_t v12 = (uint64_t)TupleTypeMetadata2;
LABEL_8:
  (*(void (**)(char *, uint64_t))(v13 + 8))(v19, v12);
  return v23 & 1;
}

void *ObjectIdentifier.init(_:)(void *a1)
{
  return a1;
}

uint64_t String.init<A>(_:radix:uppercase:)(uint64_t a1, Swift::Int radix, Swift::Bool uppercase, uint64_t a4)
{
  uint64_t countAndFlagsBits = BinaryInteger._description(radix:uppercase:)(radix, uppercase)._countAndFlagsBits;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8LL))(a1, a4);
  return countAndFlagsBits;
}

uint64_t static _DebuggerSupport.ivarCount(mirror:)(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  void (*v6)(uint64_t *__return_ptr, unint64_t *);
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t result;
  void v21[2];
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v4 = (unint64_t *)a1[1];
  uint64_t v6 = (void (*)(uint64_t *__return_ptr, unint64_t *))a1[3];
  uint64_t v5 = (unint64_t *)a1[4];
  swift_retain(v4, a2, a3, a4);
  uint64_t v10 = swift_retain(v5, v7, v8, v9);
  v6(&v26, v10);
  swift_release((uint64_t)v5);
  uint64_t v11 = swift_release((uint64_t)v4);
  uint64_t v12 = v26;
  if (v26)
  {
    uint64_t v14 = v29;
    uint64_t v13 = v30;
    __int128 v16 = v27;
    __int128 v15 = v28;
    v21[0] = v26;
    v21[1] = v27;
    uint64_t v22 = v28;
    char v23 = v29;
    __int128 v24 = v30;
    __int128 v25 = v31 & 1;
    uint64_t v17 = static _DebuggerSupport.ivarCount(mirror:)(v21);
    uint64_t v11 = outlined consume of Mirror?(v12, v16, v15, v14, v13);
  }

  else
  {
    uint64_t v17 = 0LL;
  }

  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*v4 + 320))(v11);
  uint64_t v19 = __OFADD__(v17, v18);
  Swift::String result = v17 + v18;
  if (v19) {
    __break(1u);
  }
  return result;
}

uint64_t Mirror.superclassMirror.getter()
{
  return (*(uint64_t (**)(void))(v0 + 24))();
}

uint64_t AnyCollection.count.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 320LL))();
}

uint64_t specialized static _DebuggerSupport.printForDebuggerImpl<A>(value:mirror:name:indent:maxDepth:isRoot:parentCollectionStatus:refsAlreadySeen:maxItemCounter:target:)( uint64_t result, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, int a7, char a8, uint64_t a9, uint64_t *a10, unint64_t *a11)
{
  void (*v21)(__int128 *__return_ptr, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  unint64_t v32;
  uint64_t v33;
  BOOL v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unint64_t v39;
  BOOL v40;
  unint64_t v41;
  uint64_t v42;
  void *v43;
  int v44;
  void *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  char v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  char v69;
  unint64_t v70;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __int128 v84;
  uint64_t v74 = result;
  uint64_t v11 = a10;
  uint64_t v12 = *a10 - 1;
  if (*a10 >= 1)
  {
    unint64_t v14 = a5;
    uint64_t v17 = a2;
    if ((a7 & 1) == 0
      && !a8
      && (specialized static AnyIndex.== infix(_:_:)( *(void *)(*(void *)(a2 + 8) + 16LL),  *(void *)(*(void *)(a2 + 8) + 24LL),  *(void *)(*(void *)(a2 + 8) + 32LL),  *(void *)(*(void *)(a2 + 8) + 40LL)) & 1) != 0 && *(_BYTE *)(v17 + 16) != 1)
    {
      __int128 v21 = *(void (**)(__int128 *__return_ptr, uint64_t))(v17 + 24);
      uint64_t v22 = outlined retain of Mirror(v17, v18, v19, v20);
      v21(&v79, v22);
      outlined release of Mirror(v17);
      uint64_t v26 = v79;
      if ((void)v79)
      {
        int64_t v27 = v81;
        uint64_t v77 = v82;
        uint64_t v29 = *((void *)&v79 + 1);
        char v28 = v80;
        LOBYTE(v83) = v83 & 1;
        uint64_t v75 = static _DebuggerSupport.ivarCount(mirror:)(&v79, v23, v24, v25);
        char v30 = v28;
        uint64_t v11 = a10;
        uint64_t v17 = a2;
        Swift::String result = outlined consume of Mirror?(v26, v29, v30, v27, v77);
        unint64_t v14 = a5;
        if (v75 <= 0) {
          return result;
        }
      }

      else
      {
        unint64_t v14 = a5;
      }
    }

    *uint64_t v11 = v12;
    int v73 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    int v31 = swift_allocObject(v73, 0x40uLL, 7uLL);
    *((_OWORD *)v31 + 1) = xmmword_1817FFC60;
    uint64_t v32 = specialized String.init(repeating:count:)(0x20uLL, 0xE100000000000000LL, v14);
    v31[7] = &type metadata for String;
    v31[4] = v32;
    v31[5] = v33;
    specialized _print<A>(_:separator:terminator:to:)( (uint64_t)v31,  0x20uLL,  0xE100000000000000LL,  0LL,  (void *)0xE000000000000000LL,  a11);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    swift_setDeallocating((uint64_t)v31);
    swift_arrayDestroy((uint64_t)(v31 + 4), 1LL, (uint64_t)byte_189B8D218);
    swift_deallocClassInstance((uint64_t)v31);
    uint64_t v34 = *(unsigned __int8 *)(v17 + 16) == 1;
    outlined init with copy of Any?(v74, (uint64_t)&v79);
    if (v81)
    {
      outlined init with take of Any(&v79, &v78);
      outlined init with take of Any(&v78, &v84);
      uint64_t v35 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v79);
    }

    else
    {
      outlined destroy of Any?((uint64_t *)&v79);
    }

    uint64_t v34 = 0;
LABEL_15:
    uint64_t v36 = (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 320LL))();
    uint64_t v37 = 549033698LL;
    if (a6 > 0) {
      uint64_t v37 = 549426914LL;
    }
    if (v36) {
      unint64_t v38 = v34;
    }
    else {
      unint64_t v38 = 1;
    }
    if (!v36) {
      uint64_t v37 = 8237LL;
    }
    uint64_t v39 = 0xA400000000000000LL;
    if (!v36) {
      uint64_t v39 = 0xE200000000000000LL;
    }
    uint64_t v40 = (a7 & v38) == 0;
    if ((a7 & v38) != 0) {
      uint64_t v41 = 0xE000000000000000LL;
    }
    else {
      uint64_t v41 = v39;
    }
    if (v40) {
      uint64_t v42 = v37;
    }
    else {
      uint64_t v42 = 0LL;
    }
    unint64_t v43 = swift_allocObject(v73, 0x40uLL, 7uLL);
    *((_OWORD *)v43 + 1) = xmmword_1817FFC60;
    v43[7] = &type metadata for String;
    v43[4] = v42;
    v43[5] = v41;
    specialized _print<A>(_:separator:terminator:to:)( (uint64_t)v43,  0x20uLL,  0xE100000000000000LL,  0LL,  (void *)0xE000000000000000LL,  a11);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    swift_setDeallocating((uint64_t)v43);
    swift_arrayDestroy((uint64_t)(v43 + 4), 1LL, (uint64_t)byte_189B8D218);
    swift_deallocClassInstance((uint64_t)v43);
    uint64_t v44 = *(unsigned __int8 *)(a2 + 16);
    if (!a4) {
LABEL_63:
    }
      __asm { BR              X10 }

    uint64_t v45 = swift_allocObject(v73, 0x40uLL, 7uLL);
    *((_OWORD *)v45 + 1) = xmmword_1817FFC60;
    uint64_t v46 = specialized static String._createEmpty(withInitialCapacity:)(5LL);
    uint64_t v48 = v47;
    *(void *)&uint64_t v79 = v46;
    *((void *)&v79 + 1) = v47;
    uint64_t v49 = HIBYTE(v47) & 0xF;
    if ((v47 & 0x2000000000000000LL) == 0) {
      uint64_t v49 = v46 & 0xFFFFFFFFFFFFLL;
    }
    if (v49 || (v46 & ~v47 & 0x2000000000000000LL) != 0)
    {
      if ((v47 & 0x2000000000000000LL) == 0
        || (uint64_t v50 = specialized _SmallString.init(_:appending:)(v46, v47, 0LL, 0xE000000000000000LL), (v52 & 1) != 0))
      {
        _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        char v54 = *((void *)&v79 + 1);
        uint64_t v53 = v79;
LABEL_42:
        uint64_t v58 = HIBYTE(v54) & 0xF;
        if ((v54 & 0x2000000000000000LL) == 0) {
          uint64_t v58 = v53 & 0xFFFFFFFFFFFFLL;
        }
        if (v58 || (v53 & ~v54 & 0x2000000000000000LL) != 0)
        {
          if ((v54 & 0x2000000000000000LL) != 0
            && (a4 & 0x2000000000000000LL) != 0
            && (uint64_t v59 = specialized _SmallString.init(_:appending:)(v53, v54, a3, a4), (v61 & 1) == 0))
          {
            unint64_t v62 = v59;
            int v63 = v60;
            swift_bridgeObjectRelease(v54);
            *(void *)&uint64_t v79 = v62;
            *((void *)&v79 + 1) = v63;
            a4 = v63;
            a3 = v62;
          }

          else
          {
            if ((a4 & 0x2000000000000000LL) != 0) {
              uint64_t v64 = HIBYTE(a4) & 0xF;
            }
            else {
              uint64_t v64 = a3 & 0xFFFFFFFFFFFFLL;
            }
            _StringGuts.append(_:)(a3, a4, 0LL, v64);
            a4 = *((void *)&v79 + 1);
            a3 = v79;
          }
        }

        else
        {
          swift_bridgeObjectRetain(a4, v55, v56, v57);
          swift_bridgeObjectRelease(v54);
          *(void *)&uint64_t v79 = a3;
          *((void *)&v79 + 1) = a4;
        }

        uint64_t v65 = 2112032LL;
        uint64_t v66 = HIBYTE(a4) & 0xF;
        if ((a4 & 0x2000000000000000LL) == 0) {
          uint64_t v66 = a3 & 0xFFFFFFFFFFFFLL;
        }
        if (v66 || (a3 & ~a4 & 0x2000000000000000LL) != 0)
        {
          if ((a4 & 0x2000000000000000LL) == 0
            || (uint64_t v67 = specialized _SmallString.init(_:appending:)(a3, a4, 0x203A20uLL, 0xE300000000000000LL),
                (v69 & 1) != 0))
          {
            _StringGuts.append(_:)(2112032LL, 0xE300000000000000LL, 0LL, 3LL);
            swift_bridgeObjectRelease(0xE300000000000000LL);
            uint64_t v70 = *((void *)&v79 + 1);
            uint64_t v65 = v79;
          }

          else
          {
            uint64_t v65 = v67;
            uint64_t v70 = v68;
            swift_bridgeObjectRelease(a4);
            swift_bridgeObjectRelease(0xE300000000000000LL);
          }
        }

        else
        {
          swift_bridgeObjectRelease(a4);
          uint64_t v70 = 0xE300000000000000LL;
        }

        v45[7] = &type metadata for String;
        v45[4] = v65;
        v45[5] = v70;
        specialized _print<A>(_:separator:terminator:to:)( (uint64_t)v45,  0x20uLL,  0xE100000000000000LL,  0LL,  (void *)0xE000000000000000LL,  a11);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        swift_setDeallocating((uint64_t)v45);
        swift_arrayDestroy((uint64_t)(v45 + 4), 1LL, (uint64_t)byte_189B8D218);
        swift_deallocClassInstance((uint64_t)v45);
        uint64_t v44 = *(unsigned __int8 *)(a2 + 16);
        goto LABEL_63;
      }

      uint64_t v53 = v50;
      char v54 = v51;
      swift_bridgeObjectRelease(v48);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      *(void *)&uint64_t v79 = v53;
    }

    else
    {
      swift_bridgeObjectRelease(v47);
      uint64_t v53 = 0LL;
      char v54 = 0xE000000000000000LL;
      *(void *)&uint64_t v79 = 0LL;
    }

    *((void *)&v79 + 1) = v54;
    goto LABEL_42;
  }

  return result;
}

uint64_t print<A>(_:separator:terminator:to:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _print<A>(_:separator:terminator:to:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (void (*)(uint64_t *, uint64_t, void *, uint64_t, uint64_t))_print_unlocked<A, B>(_:_:));
}

BOOL specialized Set.contains(_:)(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 16)) {
    return 0LL;
  }
  uint64_t v4 = specialized static Hasher._hash(seed:_:)(*(void *)(a2 + 40), a1);
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = v4 & ~v5;
  if (((*(void *)(a2 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) == 0) {
    return 0LL;
  }
  uint64_t v7 = ~v5;
  do
  {
    uint64_t v8 = *(void *)(*(void *)(a2 + 48) + 8 * v6);
    BOOL result = v8 == a1;
    if (v8 == a1) {
      break;
    }
    unint64_t v6 = (v6 + 1) & v7;
  }

  while (((*(void *)(a2 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
  return result;
}

uint64_t specialized Set.contains(_:)(unint64_t a1, unint64_t a2, uint64_t a3)
{
  if (!*(void *)(a3 + 16)) {
    return 0LL;
  }
  uint64_t v6 = _swift_stdlib_Hashing_parameters ^ *(void *)(a3 + 40);
  v19[0] = 0LL;
  v19[1] = v6 ^ 0x736F6D6570736575LL;
  v19[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v19[3] = v6 ^ 0x6C7967656E657261LL;
  v19[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  String.hash(into:)(v19, a1, a2);
  Swift::Int v7 = Hasher._finalize()();
  uint64_t v8 = -1LL << *(_BYTE *)(a3 + 32);
  unint64_t v9 = v7 & ~v8;
  uint64_t v10 = a3 + 56;
  if (((*(void *)(a3 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0) {
    return 0LL;
  }
  uint64_t v11 = ~v8;
  uint64_t v12 = *(void *)(a3 + 48);
  while (1)
  {
    uint64_t v13 = (uint64_t *)(v12 + 16 * v9);
    unint64_t v14 = v13[1];
    if (*v13 == a1 && v14 == a2) {
      break;
    }
    BOOL v16 = (~v14 & 0x6000000000000000LL) != 0 || (a2 & 0x2000000000000000LL) == 0;
    BOOL v17 = v16 || (a2 & 0x4000000000000000LL) == 0;
    if (v17 && (_stringCompareInternal(_:_:expecting:)(*v13, v14, a1, a2, 0) & 1) != 0) {
      break;
    }
    unint64_t v9 = (v9 + 1) & v11;
    if (((*(void *)(v10 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t specialized Set.contains(_:)(void *a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    uint64_t v2 = a2;
    uint64_t v4 = *(void *)(a2 + 40);
    uint64_t v5 = a1[3];
    uint64_t v6 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v5);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 8))(v27, v5, v6);
    uint64_t v7 = v28;
    uint64_t v8 = v29;
    __swift_project_boxed_opaque_existential_0Tm(v27, v28);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 40))(v4, v7, v8);
    __swift_destroy_boxed_opaque_existential_1Tm(v27);
    uint64_t v10 = -1LL << *(_BYTE *)(v2 + 32);
    unint64_t v11 = v9 & ~v10;
    uint64_t v12 = v2 + 56;
    if (((*(void *)(v2 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) != 0)
    {
      uint64_t v22 = ~v10;
      do
      {
        uint64_t v13 = v2;
        outlined init with copy of AnyHashable(*(void *)(v2 + 48) + 40 * v11, (uint64_t)v27);
        uint64_t v14 = v28;
        uint64_t v15 = v29;
        __swift_project_boxed_opaque_existential_0Tm(v27, v28);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v15 + 8))(v24, v14, v15);
        uint64_t v16 = v25;
        uint64_t v17 = v26;
        __swift_project_boxed_opaque_existential_0Tm(v24, v25);
        uint64_t v18 = a1[3];
        uint64_t v19 = a1[4];
        __swift_project_boxed_opaque_existential_0Tm(a1, v18);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v19 + 8))(v23, v18, v19);
        char v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v17 + 16))(v23, v16, v17);
        __swift_destroy_boxed_opaque_existential_1Tm(v23);
        if (v20 == 2)
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v24);
          outlined destroy of AnyHashable(v27);
        }

        else
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v24);
          outlined destroy of AnyHashable(v27);
          if ((v20 & 1) != 0) {
            return 1LL;
          }
        }

        unint64_t v11 = (v11 + 1) & v22;
        uint64_t v2 = v13;
      }

      while (((*(void *)(v12 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) != 0);
    }
  }

  return 0LL;
}

uint64_t Set.contains(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(a3 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v12 = (void *)a2;
    }
    else {
      uint64_t v12 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v13 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
    id v14 = objc_msgSend(v12, sel_member_, v13);
    swift_unknownObjectRelease(v13);
    if (v14)
    {
      swift_unknownObjectRelease(v14);
      char v15 = 1;
      return v15 & 1;
    }

uint64_t AnyIterator.next()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 96LL))();
}

uint64_t Mirror.init(reflecting:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
  if ((swift_dynamicCast(v15, v17, (swift *)&unk_189B8D218, v4, 6uLL) & 1) != 0)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    outlined init with take of MirrorPath((__int128 *)v15, (uint64_t)v14);
    uint64_t v6 = *(void *)&v14[2];
    uint64_t v5 = *((void *)&v14[1] + 1);
    __swift_project_boxed_opaque_existential_0Tm(v14, *((uint64_t *)&v14[1] + 1));
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t))(v6 + 8))(v15, v5, v6);
    char v7 = v15[16];
    __int128 v12 = *(_OWORD *)&v15[24];
    __int128 v13 = *(_OWORD *)v15;
    char v8 = v16;
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v14);
    __int128 v11 = v12;
    __int128 v10 = v13;
  }

  else
  {
    memset(v15, 0, sizeof(v15));
    outlined destroy of _HasContiguousBytes?( (uint64_t)v15,  &demangling cache variable for type metadata for CustomReflectable?);
    memset(v14, 0, 41);
    uint64_t result = Mirror.init(internalReflecting:subjectType:customAncestor:)( (swift::SwiftError **)a1,  0LL,  (uint64_t)v14,  (uint64_t)v15);
    __int128 v10 = *(_OWORD *)v15;
    char v7 = v15[16];
    __int128 v11 = *(_OWORD *)&v15[24];
    char v8 = v16;
  }

  *(_OWORD *)a2 = v10;
  *(_BYTE *)(a2 + 16) = v7;
  *(_OWORD *)(a2 + 24) = v11;
  *(_BYTE *)(a2 + 40) = v8;
  return result;
}

uint64_t (*Dictionary._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Dictionary.init(_cocoa:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t Dictionary._Variant.init(cocoa:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t Dictionary.init(_immutableCocoaDictionary:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

__objc2_class **_NativeDictionary.init()()
{
  return &_swiftEmptyDictionarySingleton;
}

__objc2_class **Dictionary.init(minimumCapacity:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptyDictionarySingleton;
  }
  type metadata accessor for _DictionaryStorage(0LL, a2, a3, a4);
  return (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a1);
}

__objc2_class **_NativeDictionary.init(capacity:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptyDictionarySingleton;
  }
  type metadata accessor for _DictionaryStorage(0LL, a2, a3, a4);
  return (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a1);
}

__objc2_class **Dictionary.init<A>(uniqueKeysWithValues:)( void (*a1)(char *, uint64_t, swift *), uint64_t a2, uint64_t a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *((void *)a4 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  char v15 = (void (*)(char *, uint64_t, swift *))((char *)v28 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (void *)((char *)v28 - v16);
  unint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v18((char *)v28 - v16, (uint64_t)a1, v19);
  char v20 = (const char *)type metadata accessor for Dictionary(0LL, a2, a3, a5);
  if ((swift_dynamicCast((char *)&v29, v17, a4, v20, 6uLL) & 1) != 0)
  {
    (*(void (**)(void (*)(char *, uint64_t, swift *), swift *))(v12 + 8))(a1, a4);
  }

  else
  {
    uint64_t v21 = (*(uint64_t (**)(swift *, uint64_t))(a6 + 40))(a4, a6);
    if (v21)
    {
      uint64_t v22 = v21;
      type metadata accessor for _DictionaryStorage(0LL, a2, a3, a5);
      char v23 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(v22);
    }

    else
    {
      char v23 = &_swiftEmptyDictionarySingleton;
    }

    uint64_t v29 = v23;
    uint64_t v24 = ((uint64_t (*)(void, void, swift *))v18)(v15, a1, a4);
    v28[1] = v28;
    MEMORY[0x1895F8858](v24);
    v28[-6] = a2;
    v28[-5] = a3;
    v28[-4] = a4;
    v28[-3] = a5;
    v28[-2] = a6;
    uint64_t v25 = type metadata accessor for _NativeDictionary(0LL, a2, a3, a5);
    specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)( v15,  1,  (void (*)(char *, char *))partial apply for closure #1 in Dictionary.init<A>(uniqueKeysWithValues:),  (uint64_t)&v28[-8],  v25,  (uint64_t)a4,  a6);
    uint64_t v26 = *(void (**)(void (*)(char *, uint64_t, swift *), swift *))(v12 + 8);
    v26(v15, a4);
    v26(a1, a4);
  }

  return v29;
}

uint64_t _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)( void (*a1)(char *, uint64_t, swift *), char a2, void (*a3)(char *, char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(void (*)(char *, uint64_t, swift *), uint64_t))(*(void *)(a6 - 8) + 8LL))( a1,  a6);
}

void swift_unexpectedError(void *a1, const char *a2, uint64_t a3, char a4, unint64_t a5)
{
  unint64_t v10 = 0xD000000000000030LL;
  unint64_t v11 = specialized static String._createEmpty(withInitialCapacity:)(50LL);
  uint64_t v13 = v12;
  unint64_t v37 = v11;
  unint64_t v38 = v12;
  uint64_t v14 = HIBYTE(v12) & 0xF;
  if ((v12 & 0x2000000000000000LL) == 0) {
    uint64_t v14 = v11 & 0xFFFFFFFFFFFFLL;
  }
  if (v14 || (v11 & ~v12 & 0x2000000000000000LL) != 0)
  {
    if ((v12 & 0x2000000000000000LL) == 0
      || ((unint64_t)"Swift/CString.swift" & 0x2000000000000000LL) == 0
      || (unint64_t v16 = specialized _SmallString.init(_:appending:)(v11, v12, 0xD000000000000030LL, 0x80000001818B5FA0LL),
          (v18 & 1) != 0))
    {
      else {
        unint64_t v19 = 48LL;
      }
      _StringGuts.append(_:)(0xD000000000000030LL, 0x80000001818B5FA0LL, 0LL, v19);
      unint64_t v10 = v37;
      unint64_t v15 = v38;
LABEL_15:
      unint64_t v34 = 0LL;
      unint64_t v35 = 0xE000000000000000LL;
      uint64_t v36 = a1;
      char v20 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
      _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)&v36,  (uint64_t)&v34,  v20,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
      swift_errorRelease(a1);
      uint64_t v21 = v34;
      unint64_t v22 = v35;
      uint64_t v23 = HIBYTE(v15) & 0xF;
      if ((v15 & 0x2000000000000000LL) == 0) {
        uint64_t v23 = v10 & 0xFFFFFFFFFFFFLL;
      }
      if (!v23 && (v10 & ~v15 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v15);
        unint64_t v37 = v21;
        unint64_t v38 = v22;
        goto LABEL_29;
      }

      if ((v15 & 0x2000000000000000LL) != 0)
      {
        if ((v35 & 0x2000000000000000LL) != 0)
        {
          unint64_t v25 = specialized _SmallString.init(_:appending:)(v10, v15, v34, v35);
          if ((v27 & 1) == 0)
          {
            unint64_t v28 = v25;
            unint64_t v29 = v26;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(v22);
            unint64_t v37 = v28;
            unint64_t v38 = v29;
            unint64_t v22 = v29;
            uint64_t v21 = v28;
            goto LABEL_29;
          }

          goto LABEL_27;
        }
      }

      else if ((v35 & 0x2000000000000000LL) != 0)
      {
LABEL_27:
        uint64_t v24 = HIBYTE(v22) & 0xF;
        goto LABEL_28;
      }

      uint64_t v24 = v34 & 0xFFFFFFFFFFFFLL;
LABEL_28:
      _StringGuts.append(_:)(v21, v22, 0LL, v24);
      swift_bridgeObjectRelease(v22);
      uint64_t v21 = v37;
      unint64_t v22 = v38;
LABEL_29:
      uint64_t v30 = v21 & 0xFFFFFFFFFFFFLL;
      if ((v22 & 0x2000000000000000LL) != 0) {
        uint64_t v30 = HIBYTE(v22) & 0xF;
      }
      if (v30 || (v21 & ~v22 & 0x2000000000000000LL) != 0)
      {
        if ((v22 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v22);
          unint64_t v32 = 0xA000000000000000LL;
          if (!(v22 & 0x80808080808080LL | v21 & 0x8080808080808080LL)) {
            unint64_t v32 = 0xE000000000000000LL;
          }
          unint64_t v31 = v32 & 0xFF00000000000000LL | ((HIBYTE(v22) & 0xF) << 56) | v22 & 0xFFFFFFFFFFFFFFLL;
        }

        else
        {
          _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
          uint64_t v21 = v37;
          unint64_t v31 = v38;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v22);
        uint64_t v21 = 0LL;
        unint64_t v31 = 0xE000000000000000LL;
      }

      if ((a4 & 1) != 0) {
        char v33 = 2;
      }
      else {
        char v33 = 0;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11LL, 2LL, (char *)v21, v31, a2, a3, v33, a5, 0);
    }

    unint64_t v10 = v16;
    unint64_t v15 = v17;
    swift_bridgeObjectRelease(v13);
  }

  else
  {
    swift_bridgeObjectRelease(v12);
    unint64_t v15 = 0x80000001818B5FA0LL;
  }

  unint64_t v37 = v10;
  unint64_t v38 = v15;
  goto LABEL_15;
}

uint64_t Dictionary.init<A>(_:uniquingKeysWith:)( uint64_t a1, void (*a2)(char *, char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = a3;
  char v27 = a2;
  uint64_t v14 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v16 = (void (*)(char *, uint64_t, swift *))((char *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 40))(v18, v17);
  if (v19)
  {
    uint64_t v20 = v19;
    type metadata accessor for _DictionaryStorage(0LL, a4, a5, a7);
    uint64_t v21 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(v20);
  }

  else
  {
    uint64_t v21 = &_swiftEmptyDictionarySingleton;
  }

  uint64_t v30 = v21;
  (*(void (**)(void, uint64_t, uint64_t))(v14 + 32))(v16, a1, a6);
  uint64_t v22 = type metadata accessor for _NativeDictionary(0LL, a4, a5, a7);
  uint64_t v23 = v29;
  specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)(v16, 1, v27, v28, v22, a6, a8);
  (*(void (**)(void (*)(char *, uint64_t, swift *), uint64_t))(v14 + 8))(v16, a6);
  uint64_t v24 = (uint64_t)v30;
  if (v23) {
    swift_release((uint64_t)v30);
  }
  return v24;
}

__objc2_class **Dictionary.init<A>(grouping:by:)( void (*a1)(char *, char *, uint64_t *), void (*a2)(char *), uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = v7;
  uint64_t v77 = a3;
  v78 = a2;
  unint64_t v84 = a4;
  uint64_t v81 = *(void *)(a4 - 8);
  unint64_t v82 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v76 = (char *)&v67 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v67 - v14;
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  v16,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v69 = *(AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v68 = (char *)&v67 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v83 = (char *)&v67 - v20;
  uint64_t v23 = type metadata accessor for Optional(0LL, (uint64_t)AssociatedTypeWitness, v21, v22);
  MEMORY[0x1895F8858](v23);
  unint64_t v25 = (char *)&v67 - v24;
  uint64_t v80 = a5;
  unint64_t v26 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a7,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v67 = *(void *)(v26 - 8);
  MEMORY[0x1895F8858](v26);
  uint64_t v28 = (char *)&v67 - v27;
  v85 = &_swiftEmptyDictionarySingleton;
  (*(void (**)(uint64_t))(a7 + 32))(a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  v80,  v26,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = *(void (**)(uint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v79 = v28;
  uint64_t v80 = v26;
  uint64_t v74 = v30;
  unint64_t v75 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v30)(v26);
  uint64_t v31 = v69;
  int v73 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v69 + 48);
  if (v73(v25, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    (*(void (**)(char *, uint64_t))(v67 + 8))(v79, v80);
    return v85;
  }

  else
  {
    unint64_t v82 = *(void (**)(char *, char *, uint64_t *))(v31 + 32);
    char v33 = (unint64_t *)&_swiftEmptyDictionarySingleton;
    unint64_t v72 = v25;
    while (1)
    {
      unint64_t v38 = v83;
      v82(v83, v25, AssociatedTypeWitness);
      v78(v38);
      if (v8) {
        break;
      }
      uint64_t v39 = (uint64_t)v15;
      unint64_t v40 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, v84, a6);
      unint64_t v44 = v33[2];
      BOOL v45 = (v41 & 1) == 0;
      Swift::Int v46 = v44 + v45;
      if (__OFADD__(v44, v45))
      {
        __break(1u);
LABEL_16:
        __break(1u);
LABEL_17:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v84);
      }

      unint64_t v47 = v40;
      char v48 = v41;
      if ((uint64_t)v33[3] < v46)
      {
        uint64_t v49 = AssociatedTypeWitness;
        uint64_t v50 = type metadata accessor for Array((const char *)0xFF, (uint64_t)AssociatedTypeWitness, v42, v43);
        uint64_t v51 = v84;
        type metadata accessor for _NativeDictionary(0LL, v84, v50, a6);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v46, 1);
        char v33 = (unint64_t *)v85;
        unint64_t v52 = __RawDictionaryStorage.find<A>(_:)(v39, v51, a6);
        if ((v48 & 1) != (v53 & 1)) {
          goto LABEL_17;
        }
        unint64_t v47 = v52;
        unint64_t AssociatedTypeWitness = v49;
        unint64_t v25 = v72;
      }

      if ((v48 & 1) != 0)
      {
        uint64_t v15 = (char *)v39;
        (*(void (**)(uint64_t, unint64_t))(v81 + 8))(v39, v84);
        char v33 = (unint64_t *)v85;
        uint64_t v34 = (uint64_t)v68;
        v82(v68, v83, AssociatedTypeWitness);
        uint64_t v37 = type metadata accessor for Array(0LL, (uint64_t)AssociatedTypeWitness, v35, v36);
        Array.append(_:)(v34, v37);
      }

      else
      {
        unint64_t v54 = v84;
        unint64_t v55 = *(void (**)(unint64_t, char *, unint64_t))(v81 + 32);
        uint64_t v70 = 0LL;
        unint64_t v71 = v55;
        v55((unint64_t)v76, (char *)v39, v84);
        uint64_t v56 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        v57 = (char *)swift_allocObject( v56,  ((*(unsigned __int8 *)(v69 + 80) + (unint64_t)*(unsigned int *)(v56 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v69 + 80))
                      + *(void *)(v69 + 72),
                        *(unsigned __int8 *)(v69 + 80) | (unint64_t)*(unsigned __int16 *)(v56 + 52));
        uint64_t v58 = *(uint64_t **)(*(void *)v57 + 144LL);
        swift_retain(v33, v59, v60, v61);
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v58, v58);
        *((void *)v57 + 2) = 1LL;
        *((void *)v57 + 3) = isClassOrObjCExistentialType | 2LL;
        uint64_t v63 = *(unsigned __int8 *)(*(v58 - 1) + 80);
        v82(&v57[(v63 + 32) & ~v63], v83, AssociatedTypeWitness);
        v33[(v47 >> 6) + 8] |= 1LL << v47;
        v71(v33[6] + *(void *)(v81 + 72) * v47, v76, v54);
        *(void *)(v33[7] + 8 * v47) = v57;
        unint64_t v64 = v33[2];
        BOOL v65 = __OFADD__(v64, 1LL);
        unint64_t v66 = v64 + 1;
        if (v65) {
          goto LABEL_16;
        }
        v33[2] = v66;
        swift_release((uint64_t)v33);
        uint64_t v8 = v70;
        uint64_t v15 = (char *)v39;
        unint64_t v25 = v72;
      }

      v74(v80, v75);
      if (v73(v25, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }

    (*(void (**)(char *, uint64_t *))(v69 + 8))(v83, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v67 + 8))(v79, v80);
    return (__objc2_class **)swift_release((uint64_t)v85);
  }

__objc2_class **_NativeDictionary.init<A>(grouping:by:)( void (*a1)(char *, char *, uint64_t *), void (*a2)(char *), uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = v7;
  uint64_t v77 = a3;
  v78 = a2;
  unint64_t v84 = a4;
  uint64_t v81 = *(void *)(a4 - 8);
  unint64_t v82 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v76 = (char *)&v67 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v67 - v14;
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  v16,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v69 = *(AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v68 = (char *)&v67 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v83 = (char *)&v67 - v20;
  uint64_t v23 = type metadata accessor for Optional(0LL, (uint64_t)AssociatedTypeWitness, v21, v22);
  MEMORY[0x1895F8858](v23);
  unint64_t v25 = (char *)&v67 - v24;
  uint64_t v80 = a5;
  unint64_t v26 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a7,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v67 = *(void *)(v26 - 8);
  MEMORY[0x1895F8858](v26);
  uint64_t v28 = (char *)&v67 - v27;
  v85 = &_swiftEmptyDictionarySingleton;
  (*(void (**)(uint64_t))(a7 + 32))(a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  v80,  v26,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = *(void (**)(uint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v79 = v28;
  uint64_t v80 = v26;
  uint64_t v74 = v30;
  unint64_t v75 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v30)(v26);
  uint64_t v31 = v69;
  int v73 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v69 + 48);
  if (v73(v25, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    (*(void (**)(char *, uint64_t))(v67 + 8))(v79, v80);
    return v85;
  }

  else
  {
    unint64_t v82 = *(void (**)(char *, char *, uint64_t *))(v31 + 32);
    char v33 = (unint64_t *)&_swiftEmptyDictionarySingleton;
    unint64_t v72 = v25;
    while (1)
    {
      unint64_t v38 = v83;
      v82(v83, v25, AssociatedTypeWitness);
      v78(v38);
      if (v8) {
        break;
      }
      uint64_t v39 = (uint64_t)v15;
      unint64_t v40 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, v84, a6);
      unint64_t v44 = v33[2];
      BOOL v45 = (v41 & 1) == 0;
      Swift::Int v46 = v44 + v45;
      if (__OFADD__(v44, v45))
      {
        __break(1u);
LABEL_16:
        __break(1u);
LABEL_17:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v84);
      }

      unint64_t v47 = v40;
      char v48 = v41;
      if ((uint64_t)v33[3] < v46)
      {
        uint64_t v49 = AssociatedTypeWitness;
        uint64_t v50 = type metadata accessor for Array((const char *)0xFF, (uint64_t)AssociatedTypeWitness, v42, v43);
        uint64_t v51 = v84;
        type metadata accessor for _NativeDictionary(0LL, v84, v50, a6);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v46, 1);
        char v33 = (unint64_t *)v85;
        unint64_t v52 = __RawDictionaryStorage.find<A>(_:)(v39, v51, a6);
        if ((v48 & 1) != (v53 & 1)) {
          goto LABEL_17;
        }
        unint64_t v47 = v52;
        unint64_t AssociatedTypeWitness = v49;
        unint64_t v25 = v72;
      }

      if ((v48 & 1) != 0)
      {
        uint64_t v15 = (char *)v39;
        (*(void (**)(uint64_t, unint64_t))(v81 + 8))(v39, v84);
        char v33 = (unint64_t *)v85;
        uint64_t v34 = (uint64_t)v68;
        v82(v68, v83, AssociatedTypeWitness);
        uint64_t v37 = type metadata accessor for Array(0LL, (uint64_t)AssociatedTypeWitness, v35, v36);
        Array.append(_:)(v34, v37);
      }

      else
      {
        unint64_t v54 = v84;
        unint64_t v55 = *(void (**)(unint64_t, char *, unint64_t))(v81 + 32);
        uint64_t v70 = 0LL;
        unint64_t v71 = v55;
        v55((unint64_t)v76, (char *)v39, v84);
        uint64_t v56 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        v57 = (char *)swift_allocObject( v56,  ((*(unsigned __int8 *)(v69 + 80) + (unint64_t)*(unsigned int *)(v56 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v69 + 80))
                      + *(void *)(v69 + 72),
                        *(unsigned __int8 *)(v69 + 80) | (unint64_t)*(unsigned __int16 *)(v56 + 52));
        uint64_t v58 = *(uint64_t **)(*(void *)v57 + 144LL);
        swift_retain(v33, v59, v60, v61);
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v58, v58);
        *((void *)v57 + 2) = 1LL;
        *((void *)v57 + 3) = isClassOrObjCExistentialType | 2LL;
        uint64_t v63 = *(unsigned __int8 *)(*(v58 - 1) + 80);
        v82(&v57[(v63 + 32) & ~v63], v83, AssociatedTypeWitness);
        v33[(v47 >> 6) + 8] |= 1LL << v47;
        v71(v33[6] + *(void *)(v81 + 72) * v47, v76, v54);
        *(void *)(v33[7] + 8 * v47) = v57;
        unint64_t v64 = v33[2];
        BOOL v65 = __OFADD__(v64, 1LL);
        unint64_t v66 = v64 + 1;
        if (v65) {
          goto LABEL_16;
        }
        v33[2] = v66;
        swift_release((uint64_t)v33);
        uint64_t v8 = v70;
        uint64_t v15 = (char *)v39;
        unint64_t v25 = v72;
      }

      v74(v80, v75);
      if (v73(v25, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }

    (*(void (**)(char *, uint64_t *))(v69 + 8))(v83, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v67 + 8))(v79, v80);
    return (__objc2_class **)swift_release((uint64_t)v85);
  }

int64_t Dictionary._Variant.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001LL) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v4 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0LL;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0LL;
    uint64_t result = v5 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v9 = -1LL;
    uint64_t v10 = -1LL << *(_BYTE *)(result + 32);
    int64_t v6 = result + 64;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1LL << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 64);
  }

  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0LL;
  a2[4] = v8;
  return result;
}

__objc2_class **Dictionary.filter(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = (char *)a5;
  uint64_t v9 = (uint64_t *)a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a4, a5, "key value ", 0LL);
  uint64_t v124 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  v120 = (char *)&v98 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  v109 = (char *)&v98 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v121 = (char *)&v98 - v19;
  MEMORY[0x1895F8858](v18);
  v128 = (char *)&v98 - v20;
  uint64_t v103 = type metadata accessor for Optional(0LL, (uint64_t)v8, v21, v22);
  uint64_t v23 = *(void *)(v103 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v103);
  v100 = (char *)&v98 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v24);
  uint64_t v102 = (char *)&v98 - v26;
  uint64_t v99 = type metadata accessor for Optional(0LL, (uint64_t)v9, v27, v28);
  uint64_t v101 = *(void *)(v99 - 8);
  uint64_t v29 = MEMORY[0x1895F8858](v99);
  v98 = (char *)&v98 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v29);
  uint64_t v104 = (char *)&v98 - v31;
  uint64_t v123 = *((void *)v8 - 1);
  v131 = TupleTypeMetadata2;
  uint64_t v34 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v32, v33);
  MEMORY[0x1895F8858](v34);
  v130 = (char *)&v98 - v35;
  if ((a3 & 0xC000000000000001LL) == 0)
  {
    _NativeDictionary.filter(_:)(a1, a2, a3, (uint64_t)v9, (uint64_t)v8, a6);
    BOOL v65 = v95;
    swift_bridgeObjectRelease(a3);
    return (__objc2_class **)v65;
  }

  uint64_t v129 = v6;
  v133 = &_swiftEmptyDictionarySingleton;
  if (a3 < 0) {
    uint64_t v36 = a3;
  }
  else {
    uint64_t v36 = a3 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v37 = type metadata accessor for __CocoaDictionary.Iterator();
  unint64_t v38 = (unint64_t)swift_allocObject(v37, 0xE8uLL, 7uLL);
  *(_OWORD *)(v38 + 16) = 0u;
  *(_OWORD *)(v38 + 32) = 0u;
  *(_OWORD *)(v38 + 48) = 0u;
  *(_OWORD *)(v38 + 64) = 0u;
  *(_OWORD *)(v38 + 80) = 0u;
  *(_OWORD *)(v38 + 96) = 0u;
  *(_OWORD *)(v38 + 112) = 0u;
  *(_OWORD *)(v38 + 128) = 0u;
  *(_OWORD *)(v38 + 144) = 0u;
  *(_OWORD *)(v38 + 160) = 0u;
  *(_OWORD *)(v38 + 176) = 0u;
  *(_OWORD *)(v38 + 192) = 0u;
  *(void *)(v38 + 208) = v36;
  *(void *)(v38 + 216) = 0LL;
  *(void *)(v38 + 224) = 0LL;
  unint64_t v105 = v38 | 0x8000000000000000LL;
  uint64_t v42 = 0LL;
  uint64_t v43 = v38 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v108 = (v38 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v107 = (v38 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  v115 = (swift *)&unk_189B8D230;
  uint64_t v106 = a6;
  v118 = (uint64_t (*)(char *, char *))a1;
  uint64_t v119 = a2;
  v116 = v8;
  uint64_t v117 = v23;
  uint64_t v114 = v38 & 0x7FFFFFFFFFFFFFFFLL;
  v127 = v9;
  while (1)
  {
    unint64_t v44 = *(void **)(v43 + 208);
    if (v42 != *(void *)(v43 + 224)) {
      goto LABEL_11;
    }
    id v45 = objc_msgSend(*(id *)(v43 + 208), sel_countByEnumeratingWithState_objects_count_, v108, v107, 16);
    *(void *)(v43 + 224) = v45;
    if (!v45) {
      break;
    }
    uint64_t v42 = 0LL;
    *(void *)(v43 + 216) = 0LL;
LABEL_11:
    uint64_t v46 = *(void *)(v43 + 24);
    if (!v46)
    {
      unint64_t v97 = 773LL;
      goto LABEL_38;
    }

    if ((unint64_t)(v42 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_35:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    unint64_t v47 = (void **)(v46 + 8 * v42);
    char v48 = *v47;
    *(void *)(v43 + 216) = v42 + 1;
    swift_unknownObjectRetain(v48, v39, v40, v41);
    uint64_t v49 = (swift *)objc_msgSend(v44, sel_objectForKey_, v48);
    if (!v49)
    {
      unint64_t v97 = 784LL;
LABEL_38:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v97,  0);
    }

    uint64_t v50 = v49;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
    unint64_t v52 = v130;
    if (isClassOrObjCExistentialType)
    {
      v132 = (swift *)v48;
      swift_dynamicCast(v130, (uint64_t *)&v132, v115, (const char *)v9, 7uLL);
    }

    else
    {
      uint64_t v126 = *(v9 - 1);
      v88 = (uint64_t *)v104;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v126 + 56))(v104, 1LL, 1LL, v9);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v48, (uint64_t)v9, v88);
      swift_unknownObjectRelease(v48);
      v89 = v98;
      uint64_t v90 = v99;
      (*(void (**)(char *, char *, uint64_t))(v101 + 16))(v98, v104, v99);
      (*(void (**)(char *, uint64_t))(v101 + 8))(v104, v90);
      unint64_t v52 = v130;
      (*(void (**)(void))(v126 + 32))();
    }

    uint64_t v53 = v117;
    unint64_t v54 = &v52[*((int *)v131 + 12)];
    if (_swift_isClassOrObjCExistentialType((uint64_t)v8, (uint64_t *)v8))
    {
      v132 = v50;
      swift_dynamicCast(v54, (uint64_t *)&v132, (swift *)&unk_189B8D230, v8, 7uLL);
    }

    else
    {
      uint64_t v91 = (uint64_t *)v102;
      (*(void (**)(char *, uint64_t, uint64_t, char *))(v123 + 56))(v102, 1LL, 1LL, v8);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v50, (uint64_t)v8, v91);
      swift_unknownObjectRelease(v50);
      uint64_t v92 = v100;
      v93 = v91;
      uint64_t v94 = v123;
      (*(void (**)(char *, uint64_t *, uint64_t))(v53 + 16))(v100, v93, v103);
      if ((*(unsigned int (**)(char *, uint64_t, char *))(v94 + 48))(v92, 1LL, v8) == 1) {
LABEL_40:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      (*(void (**)(char *, uint64_t))(v53 + 8))(v102, v103);
      (*(void (**)(char *, char *, char *))(v94 + 32))(v54, v92, v8);
    }

    unint64_t v55 = v8;
    v57 = v130;
    uint64_t v56 = v131;
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v124 + 56))(v130, 0LL, 1LL, v131);
    uint64_t v58 = *((int *)v56 + 12);
    uint64_t v59 = v128;
    uint64_t v60 = &v128[v58];
    uint64_t v61 = &v57[v58];
    uint64_t v62 = *(v9 - 1);
    v125 = *(void (**)(void))(v62 + 32);
    ((void (*)(char *, char *, uint64_t *))v125)(v128, v57, v9);
    uint64_t v63 = v123;
    uint64_t v126 = *(void *)(v123 + 32);
    ((void (*)(char *, char *, char *))v126)(v60, v61, v55);
    unint64_t v64 = v121;
    BOOL v65 = &v121[*((int *)v56 + 12)];
    unint64_t v66 = *(void (**)(char *, char *, uint64_t *))(v62 + 16);
    v66(v121, v59, v9);
    uint64_t v67 = *(void (**)(char *, char *, char *))(v63 + 16);
    unint64_t v68 = v60;
    uint64_t v69 = v60;
    uint64_t v8 = v116;
    v67(v65, v69, v116);
    uint64_t v70 = v129;
    char v71 = v118(v64, v65);
    uint64_t v129 = v70;
    if (v70)
    {
      (*(void (**)(char *, unint64_t *))(v124 + 8))(v128, v131);
      outlined consume of [A : B].Iterator._Variant<A, B>(v105);
      swift_release((uint64_t)v133);
      (*(void (**)(char *, char *))(v63 + 8))(v65, v8);
      (*(void (**)(char *, uint64_t *))(v62 + 8))(v64, v127);
      return (__objc2_class **)v65;
    }

    char v72 = v71;
    v122 = *(void (**)(char *, char *))(v63 + 8);
    v122(v65, v8);
    int v73 = *(void (**)(char *, uint64_t *))(v62 + 8);
    v73(v64, v127);
    if ((v72 & 1) != 0)
    {
      uint64_t v111 = v62;
      v113 = (void (*)(char *, unint64_t))v73;
      uint64_t v74 = v131;
      uint64_t v75 = (uint64_t)v109;
      uint64_t v76 = &v109[*((int *)v131 + 12)];
      unint64_t v77 = (unint64_t)v127;
      v66(v109, v128, v127);
      v112 = v76;
      v67(v76, v68, v8);
      v78 = &v120[*((int *)v74 + 12)];
      v125();
      v110 = v78;
      ((void (*)(char *, char *, char *))v126)(v78, v68, v8);
      uint64_t v79 = v133;
      uint64_t v80 = v133[2];
      uint64_t v9 = (uint64_t *)v77;
      uint64_t v81 = v106;
      if (v133[3] <= v80)
      {
        Swift::Int v82 = (Swift::Int)&v80->isa + 1;
        type metadata accessor for _NativeDictionary(0LL, v77, (uint64_t)v8, v106);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v82, 1);
        uint64_t v79 = v133;
      }

      uint64_t v83 = (*(uint64_t (**)(__objc2_class *, unint64_t, uint64_t))(v81 + 32))(v79[5], v77, v81);
      unint64_t v84 = __RawDictionaryStorage.find<A>(_:hashValue:)(v75, v83, v77);
      uint64_t v85 = v123;
      if ((v86 & 1) != 0) {
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v77);
      }
      unint64_t v87 = v84;
      v79[(v84 >> 6) + 8] = (__objc2_class *)((unint64_t)v79[(v84 >> 6) + 8] | (1LL << v84));
      ((void (*)(char *, uint64_t, unint64_t))v125)( (char *)v79[6] + *(void *)(v111 + 72) * v84,  v75,  v77);
      ((void (*)(char *, char *, char *))v126)((char *)v79[7] + *(void *)(v85 + 72) * v87, v110, v8);
      v79[2] = (__objc2_class *)((char *)v79[2] + 1);
      v113(v120, v77);
      v122(v112, v8);
    }

    else
    {
      (*(void (**)(char *, unint64_t *))(v124 + 8))(v128, v131);
      uint64_t v9 = v127;
    }

    uint64_t v43 = v114;
    uint64_t v42 = *(void *)(v114 + 216);
    if (v42 < 0) {
      goto LABEL_32;
    }
  }

  *(void *)(v43 + 216) = -1LL;
LABEL_32:
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v124 + 56))(v130, 1LL, 1LL, v131);
  outlined consume of [A : B].Iterator._Variant<A, B>(v105);
  return v133;
}

uint64_t _NativeDictionary.insertNew(key:value:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void **)v3;
  unint64_t v8 = *(void *)(*(void *)v3 + 16LL);
  if (*(void *)(*(void *)v3 + 24LL) <= v8)
  {
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v8 + 1, 1);
    uint64_t v7 = *(void **)v3;
  }

  return _NativeDictionary._unsafeInsertNew(key:value:)( a1,  a2,  v7,  *(void *)(a3 + 16),  *(void *)(a3 + 24),  *(void *)(a3 + 32));
}

BOOL Dictionary._Variant.isNative.getter(uint64_t a1)
{
  return (a1 & 0xC000000000000001LL) == 0;
}

__objc2_class **_ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5( uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, __objc2_class **a5)
{
  uint64_t v10 = (uint64_t (*)(char *, uint64_t *))isStackAllocationSafe;
  v18[1] = *MEMORY[0x1895F89C0];
  char v11 = *(_BYTE *)(a3 + 32);
  unint64_t v12 = (unint64_t)((1LL << v11) + 63) >> 6;
  size_t v13 = 8 * v12;
  if ((v11 & 0x3Fu) <= 0xD
    || (isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1895F8858](isStackAllocationSafe);
    uint64_t v14 = (int64x2_t *)((char *)v18 - ((v13 + 15) & 0x3FFFFFFFFFFFFFF0LL));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v12, v14);
    uint64_t v15 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_Tp5( (unint64_t *)v14,  v12,  a3,  v10,  a2,  a4,  (uint64_t)a5);
    if (v5) {
      swift_willThrow();
    }
    else {
      return v15;
    }
  }

  else
  {
    uint64_t v16 = (int64x2_t *)swift_slowAlloc(v13, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v12, v16);
    a5 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_Tp5( (unint64_t *)v16,  v12,  a3,  v10,  a2,  a4,  (uint64_t)a5);
    swift_slowDealloc(v16);
  }

  return a5;
}

void _NativeDictionary.filter(_:)( uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = (uint64_t (*)(char *, char *))isStackAllocationSafe;
  v17[1] = *(__objc2_class ***)MEMORY[0x1895F89C0];
  char v10 = *(_BYTE *)(a3 + 32);
  unint64_t v11 = (unint64_t)((1LL << v10) + 63) >> 6;
  size_t v12 = 8 * v11;
  if ((v10 & 0x3Fu) <= 0xD
    || (isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    uint64_t v15 = (uint64_t)&v15;
    MEMORY[0x1895F8858](isStackAllocationSafe);
    size_t v13 = (int64x2_t *)((char *)&v15 - ((v12 + 15) & 0x3FFFFFFFFFFFFFF0LL));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v11, v13);
    closure #1 in _NativeDictionary.filter(_:)((unint64_t *)v13, v11, v9, a5, a6, &v16);
    if (v6) {
      swift_willThrow();
    }
  }

  else
  {
    uint64_t v14 = (int64x2_t *)swift_slowAlloc(v12, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v11, v14);
    closure #1 in _NativeDictionary.filter(_:)((unint64_t *)v14, v11, v9, a5, a6, v17);
    swift_slowDealloc(v14);
  }

unint64_t Dictionary._Variant.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return _NativeDictionary.startIndex.getter(a1);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      unint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_andKeys_count_, 0, v8 + 3, v6);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaDictionary.Index.Storage();
      char v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t Dictionary._Variant.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return 1LL << *(_BYTE *)(a1 + 32);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      unint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_andKeys_count_, 0, v8 + 3, v6);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaDictionary.Index.Storage();
      char v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

Swift::Int Dictionary._Variant.index(after:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = a1;
  uint64_t v9 = a3 & 1;
  if ((a4 & 0xC000000000000001LL) == 0) {
    return _NativeDictionary.index(after:)(a1, a2, v9, a4, a5, a6, a7);
  }
  if (a4 < 0) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a4 & 0xFFFFFFFFFFFFFF8LL;
  }
  if (!(_DWORD)v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  if (a1 >= 0) {
    uint64_t v11 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v11 = a1;
  }
  outlined copy of [A : B].Index._Variant<A, B>(a1, a2, 1LL, (char *)a4);
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v11, v12)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v11 + 16) != v10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E7uLL,  0);
  }
  if (*(void *)(*(void *)(v11 + 24) + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E8uLL,  0);
  }
  return v8;
}

void Dictionary._Variant.formIndex(after:)( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 16);
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    Swift::Int v21 = _NativeDictionary.index(after:)(*(void *)a1, v9, v10, a2, a3, a6, a5);
    uint64_t v19 = v22;
    char v20 = v23 & 1;
    outlined consume of [A : B].Index._Variant<A, B>(v8, v9, v10);
    *(void *)a1 = v21;
    goto LABEL_20;
  }

  if ((v10 & 1) == 0)
  {
    unint64_t v24 = 1850LL;
    goto LABEL_26;
  }

  if (v8 >= 0) {
    uint64_t v11 = v8 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v11 = *(void *)a1;
  }
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v8, v13, v14, v15);
  if (!swift_dynamicCastClass(v11, v12)) {
LABEL_23:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  outlined consume of [A : B].Index._Variant<A, B>(v8, v9, 1);
  if (v11) {
    swift_isUniquelyReferenced_nonNull_native(v11);
  }
  if (*(_BYTE *)(a1 + 16) != 1)
  {
    unint64_t v24 = 1858LL;
LABEL_26:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  v24,  0);
  }

  uint64_t v16 = *(void *)(a1 + 8);
  else {
    uint64_t v17 = *(void *)a1;
  }
  if (!swift_dynamicCastClass(v17, v12)) {
    goto LABEL_23;
  }
  uint64_t v18 = a2 & 0xFFFFFFFFFFFFFF8LL;
  if (a2 < 0) {
    uint64_t v18 = a2;
  }
  if (*(void *)(v17 + 16) != v18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E7uLL,  0);
  }
  if (v16 >= *(void *)(*(void *)(v17 + 24) + 16LL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E8uLL,  0);
  }
  uint64_t v19 = v16 + 1;
  char v20 = 1;
LABEL_20:
  *(void *)(a1 + 8) = v19;
  *(_BYTE *)(a1 + 16) = v20;
}

void *Dictionary._Variant.index(forKey:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v30 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if ((v31 & 1) != 0) {
        return (void *)v30;
      }
    }

    return 0LL;
  }

  unint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v8 = objc_msgSend(v7, sel_objectForKey_, v6);
  if (!v8)
  {
    swift_unknownObjectRelease(v6);
    return 0LL;
  }

  swift_unknownObjectRelease(v8);
  unint64_t v12 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v7, v9, v10, v11), sel_count);
  unint64_t v13 = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v12 - 0x1000000000000000LL) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_19;
  }

  if (__OFADD__(8 * v12, 24LL))
  {
LABEL_19:
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v14 = swift_bufferAllocate(v13, 8 * v12 + 24, 7uLL);
  v14[2] = v12;
  objc_msgSend(v7, sel_getObjects_andKeys_count_, 0, v14 + 3, v12);
  swift_bridgeObjectRelease(a2);
  if ((v14[2] & 0x8000000000000000LL) != 0) {
    goto LABEL_20;
  }
  swift_unknownObjectRetain(v14, v15, v16, v17);
  uint64_t v21 = 0LL;
  do
  {
    uint64_t v22 = v21 + 1;
    char v23 = (void *)v14[v21 + 3];
    swift_unknownObjectRetain(v23, v18, v19, v20);
    char isEqual = swift_stdlib_NSObject_isEqual(v6, v23);
    swift_unknownObjectRelease(v23);
    uint64_t v21 = v22;
  }

  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v14);
  uint64_t v25 = type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t v26 = swift_allocObject(v25, 0x20uLL, 7uLL);
  v26[2] = v7;
  v26[3] = v14;
  swift_unknownObjectRetain(v7, v27, v28, v29);
  swift_unknownObjectRelease(v6);
  return v26;
}

void Dictionary.subscript.getter( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, char *a8, uint64_t a9)
{
  uint64_t v15 = *((void *)a7 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](a1);
  uint64_t v19 = (char *)&v45 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v20 & 0xC000000000000001LL) == 0)
  {
    if ((v17 & 1) != 0)
    {
      uint64_t v45 = v16;
      uint64_t v46 = a2;
      if (a3 >= 0) {
        uint64_t v33 = a3 & 0xFFFFFFFFFFFFFF8LL;
      }
      else {
        uint64_t v33 = a3;
      }
      uint64_t v34 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(a3, v35, v36, v37);
      if (!swift_dynamicCastClass(v33, v34)) {
        goto LABEL_32;
      }
      if (!swift_dynamicCastClass(v33, v34)) {
        goto LABEL_32;
      }
      uint64_t v41 = *(void *)(v33 + 24);
      if (*(void *)(v41 + 16) <= a4) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
      }
      uint64_t v42 = *(void **)(v41 + 8 * a4 + 24);
      swift_unknownObjectRetain(v42, v38, v39, v40);
      outlined consume of [A : B].Index._Variant<A, B>(a3, a4, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v42, a7, v43, v19);
      swift_unknownObjectRelease(v42);
      a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v19, (uint64_t)a7, a9);
      LOBYTE(v42) = v44;
      (*(void (**)(char *, char *))(v15 + 8))(v19, a7);
      if ((v42 & 1) == 0)
      {
LABEL_35:
        unint64_t v32 = 303LL;
LABEL_19:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v32,  0);
      }

      uint64_t v16 = v45;
      a2 = v46;
    }

    else if (a3 < 0 {
           || 1LL << *(_BYTE *)(a6 + 32) <= a3
    }
           || ((*(void *)(a6 + (((unint64_t)a3 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> a3) & 1) == 0
           || *(_DWORD *)(a6 + 36) != (_DWORD)a4)
    {
      unint64_t v32 = 281LL;
      goto LABEL_19;
    }

    (*(void (**)(uint64_t, uint64_t, char *))(v15 + 16))( v16,  *(void *)(a6 + 48) + *(void *)(v15 + 72) * a3,  a7);
    (*(void (**)(char *, uint64_t, char *))(*((void *)a8 - 1) + 16LL))( a2,  *(void *)(a6 + 56) + *(void *)(*((void *)a8 - 1) + 72LL) * a3,  a8);
    return;
  }

  if (a6 >= 0) {
    a6 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v17 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  uint64_t v21 = (char *)v16;
  if (a3 >= 0) {
    uint64_t v22 = a3 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v22 = a3;
  }
  uint64_t v23 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v22, v23)) {
    goto LABEL_32;
  }
  if (*(void *)(v22 + 16) != a6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x21CuLL,  0);
  }
  uint64_t v27 = *(void **)(*(void *)(v22 + 24) + 8 * a4 + 24);
  swift_unknownObjectRetain(v27, v24, v25, v26);
  if (!swift_dynamicCastClass(v22, v23)) {
LABEL_32:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  id v28 = objc_msgSend((id)a6, sel_objectForKey_, v27);
  if (!v28) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x21EuLL,  0);
  }
  unint64_t v30 = v28;
  _forceBridgeFromObjectiveC<A>(_:_:)(v27, a7, v29, v21);
  swift_unknownObjectRelease(v27);
  _forceBridgeFromObjectiveC<A>(_:_:)(v30, a8, v31, a2);
  swift_unknownObjectRelease(v30);
}

void Dictionary._Variant.lookup(_:)( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, char *a8, uint64_t a9)
{
  uint64_t v15 = *((void *)a7 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](a1);
  uint64_t v19 = (char *)&v45 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v20 & 0xC000000000000001LL) == 0)
  {
    if ((v17 & 1) != 0)
    {
      uint64_t v45 = v16;
      uint64_t v46 = a2;
      if (a3 >= 0) {
        uint64_t v33 = a3 & 0xFFFFFFFFFFFFFF8LL;
      }
      else {
        uint64_t v33 = a3;
      }
      uint64_t v34 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(a3, v35, v36, v37);
      if (!swift_dynamicCastClass(v33, v34)) {
        goto LABEL_32;
      }
      if (!swift_dynamicCastClass(v33, v34)) {
        goto LABEL_32;
      }
      uint64_t v41 = *(void *)(v33 + 24);
      if (*(void *)(v41 + 16) <= a4) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
      }
      uint64_t v42 = *(void **)(v41 + 8 * a4 + 24);
      swift_unknownObjectRetain(v42, v38, v39, v40);
      outlined consume of [A : B].Index._Variant<A, B>(a3, a4, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v42, a7, v43, v19);
      swift_unknownObjectRelease(v42);
      a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v19, (uint64_t)a7, a9);
      LOBYTE(v42) = v44;
      (*(void (**)(char *, char *))(v15 + 8))(v19, a7);
      if ((v42 & 1) == 0)
      {
LABEL_35:
        unint64_t v32 = 303LL;
LABEL_19:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v32,  0);
      }

      uint64_t v16 = v45;
      a2 = v46;
    }

    else if (a3 < 0 {
           || 1LL << *(_BYTE *)(a6 + 32) <= a3
    }
           || ((*(void *)(a6 + (((unint64_t)a3 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> a3) & 1) == 0
           || *(_DWORD *)(a6 + 36) != (_DWORD)a4)
    {
      unint64_t v32 = 281LL;
      goto LABEL_19;
    }

    (*(void (**)(uint64_t, uint64_t, char *))(v15 + 16))( v16,  *(void *)(a6 + 48) + *(void *)(v15 + 72) * a3,  a7);
    (*(void (**)(char *, uint64_t, char *))(*((void *)a8 - 1) + 16LL))( a2,  *(void *)(a6 + 56) + *(void *)(*((void *)a8 - 1) + 72LL) * a3,  a8);
    return;
  }

  if (a6 >= 0) {
    a6 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v17 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  uint64_t v21 = (char *)v16;
  if (a3 >= 0) {
    uint64_t v22 = a3 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v22 = a3;
  }
  uint64_t v23 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v22, v23)) {
    goto LABEL_32;
  }
  if (*(void *)(v22 + 16) != a6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x21CuLL,  0);
  }
  uint64_t v27 = *(void **)(*(void *)(v22 + 24) + 8 * a4 + 24);
  swift_unknownObjectRetain(v27, v24, v25, v26);
  if (!swift_dynamicCastClass(v22, v23)) {
LABEL_32:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  id v28 = objc_msgSend((id)a6, sel_objectForKey_, v27);
  if (!v28) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x21EuLL,  0);
  }
  unint64_t v30 = v28;
  _forceBridgeFromObjectiveC<A>(_:_:)(v27, a7, v29, v21);
  swift_unknownObjectRelease(v27);
  _forceBridgeFromObjectiveC<A>(_:_:)(v30, a8, v31, a2);
  swift_unknownObjectRelease(v30);
}

id Dictionary._Variant.count.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 16);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

uint64_t (*Dictionary.subscript.read( unint64_t **a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, char *a6, char *a7, uint64_t a8))()
{
  uint64_t v15 = a4 & 1;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a6, (uint64_t)a7, "key value ", 0LL);
  *a1 = TupleTypeMetadata2;
  char v17 = (unint64_t *)*(TupleTypeMetadata2 - 1);
  a1[1] = v17;
  uint64_t v18 = (char *)malloc(v17[8]);
  a1[2] = (unint64_t *)v18;
  Dictionary.subscript.getter((uint64_t)v18, &v18[*((int *)TupleTypeMetadata2 + 12)], a2, a3, v15, a5, a6, a7, a8);
  return _ArrayBuffer.subscript.read;
}

uint64_t Dictionary._Variant.lookup(_:)@<X0>( id *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, char *a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v15 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if ((v16 & 1) != 0)
      {
        uint64_t v17 = *(void *)(a2 + 56);
        uint64_t v14 = *((void *)a4 - 1);
        (*(void (**)(char *, unint64_t, char *))(v14 + 16))(a6, v17 + *(void *)(v14 + 72) * v15, a4);
        uint64_t v13 = 0LL;
        return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56))(a6, v13, 1LL, a4);
      }
    }

void specialized Dictionary._Variant.setValue(_:forKey:)( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
  uint64_t v11 = *v4;
  *uint64_t v4 = 0x8000000000000000LL;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, a4, isUniquelyReferenced_nonNull_native);
  uint64_t v10 = *v4;
  *uint64_t v4 = v11;
  swift_bridgeObjectRelease(v10);
}

void specialized Dictionary._Variant.setValue(_:forKey:)( uint64_t a1, unint64_t a2, unint64_t a3)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v9 = *v3;
  *uint64_t v3 = 0x8000000000000000LL;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, isUniquelyReferenced_nonNull_native);
  uint64_t v8 = *v3;
  *uint64_t v3 = v9;
  swift_bridgeObjectRelease(v8);
}

void specialized Dictionary._Variant.setValue(_:forKey:)( _OWORD *a1, unint64_t a2, unint64_t a3)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v9 = *v3;
  *uint64_t v3 = 0x8000000000000000LL;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, isUniquelyReferenced_nonNull_native);
  uint64_t v8 = *v3;
  *uint64_t v3 = v9;
  swift_bridgeObjectRelease(v8);
}

void specialized Dictionary._Variant.setValue(_:forKey:)(uint64_t a1, uint64_t a2, void *a3)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  uint64_t v9 = *v3;
  *uint64_t v3 = 0x8000000000000000LL;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, a3, isUniquelyReferenced_nonNull_native);
  uint64_t v8 = *v3;
  *uint64_t v3 = v9;
  swift_bridgeObjectRelease(v8);
}

void specialized Dictionary._Variant.setValue(_:forKey:)(_OWORD *a1, void *a2)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v2);
  uint64_t v7 = *v2;
  uint64_t *v2 = 0x8000000000000000LL;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, isUniquelyReferenced_nonNull_native);
  uint64_t v6 = *v2;
  uint64_t *v2 = v7;
  swift_bridgeObjectRelease(v6);
}

void Dictionary._Variant.setValue(_:forKey:)(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (char *)a3[2];
  uint64_t v10 = (uint64_t *)a3[3];
  if ((v8 & 0xC000000000000001LL) == 0)
  {
    uint64_t v13 = a3[4];
    goto LABEL_8;
  }

  if (v8 < 0) {
    uint64_t v11 = (void *)v8;
  }
  else {
    uint64_t v11 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v12 = objc_msgSend(v11, sel_count);
  if (!__OFADD__(v12, 1LL))
  {
    uint64_t v13 = a3[4];
    uint64_t v8 = (uint64_t)_NativeDictionary.init(_:capacity:)(v11, (uint64_t)v12 + 1, v9, v10, v13);
    *uint64_t v4 = v8;
LABEL_8:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v8);
    uint64_t v17 = *v4;
    *uint64_t v4 = 0x8000000000000000LL;
    uint64_t v15 = type metadata accessor for _NativeDictionary(0LL, (uint64_t)v9, (uint64_t)v10, v13);
    _NativeDictionary.setValue(_:forKey:isUnique:)(a1, a2, isUniquelyReferenced_nonNull_native, v15);
    uint64_t v16 = *v4;
    *uint64_t v4 = v17;
    swift_bridgeObjectRelease(v16);
    return;
  }

  __break(1u);
}

uint64_t Dictionary.removeValue(forKey:)@<X0>(id *a1@<X0>, uint64_t *a2@<X1>, char *a3@<X8>)
{
  uint64_t v5 = type metadata accessor for Dictionary._Variant(0LL, a2[2], a2[3], a2[4]);
  return Dictionary._Variant.removeValue(forKey:)(a1, v5, a3);
}

void (*Dictionary.subscript.modify(void *a1, uint64_t a2, void *a3))(void *a1)
{
  uint64_t v5 = malloc(0x40uLL);
  *a1 = v5;
  uint64_t v6 = a3[2];
  v5[4] = v6;
  uint64_t v7 = *(void *)(v6 - 8);
  v5[5] = v7;
  uint64_t v8 = malloc(*(void *)(v7 + 64));
  v5[6] = v8;
  (*(void (**)(void))(v7 + 16))();
  uint64_t v9 = (void *)type metadata accessor for Dictionary._Variant(0LL, v6, a3[3], a3[4]);
  v5[7] = Dictionary._Variant.subscript.modify(v5, (uint64_t)v8, v9);
  return Dictionary.subscript.modify;
}

void Dictionary.subscript.modify(void *a1)
{
  Swift::String v1 = (void *)*a1;
  uint64_t v2 = *(void **)(*a1 + 48LL);
  uint64_t v3 = *(void *)(*a1 + 32LL);
  uint64_t v4 = *(void *)(*a1 + 40LL);
  (*(void (**)(void, void))(*a1 + 56LL))(*a1, 0LL);
  (*(void (**)(void *, uint64_t))(v4 + 8))(v2, v3);
  free(v2);
  free(v1);
}

void (*Dictionary._Variant.subscript.modify(void *a1, uint64_t a2, void *a3))(uint64_t *a1)
{
  uint64_t v7 = malloc(0xA0uLL);
  *a1 = v7;
  uint64_t v8 = (char *)a3[2];
  v7[13] = v8;
  uint64_t v9 = *((void *)v8 - 1);
  v7[14] = v9;
  size_t v10 = *(void *)(v9 + 64);
  uint64_t v11 = malloc(v10);
  v7[15] = v11;
  id v12 = malloc(v10);
  v7[16] = v12;
  uint64_t v13 = *v3;
  uint64_t v14 = (uint64_t *)a3[3];
  if ((*v3 & 0xC000000000000001LL) != 0)
  {
    if (v13 < 0) {
      uint64_t v15 = (void *)*v3;
    }
    else {
      uint64_t v15 = (void *)(v13 & 0xFFFFFFFFFFFFFF8LL);
    }
    unint64_t result = (void (*)(uint64_t *))objc_msgSend(v15, sel_count);
    if (__OFADD__(result, 1LL))
    {
      __break(1u);
    }

    else
    {
      uint64_t v17 = a3[4];
      uint64_t v18 = (unint64_t *)_NativeDictionary.init(_:capacity:)(v15, (uint64_t)result + 1, v8, v14, v17);
      v7[12] = v18;
      *uint64_t v3 = (uint64_t)v18;
      (*(void (**)(void *, uint64_t, char *))(v9 + 16))(v11, a2, v8);
      swift_retain(v18, v19, v20, v21);
      uint64_t v22 = (void *)type metadata accessor for _NativeDictionary(0LL, (uint64_t)v8, (uint64_t)v14, v17);
      v7[19] = _NativeDictionary.subscript.modify(v7, (uint64_t)v11, 1, v22);
      return Dictionary._Variant.subscript.modify;
    }
  }

  else
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v13);
    (*(void (**)(void *, uint64_t, char *))(v9 + 16))(v12, a2, v8);
    v7[17] = Dictionary._Variant.asNative.modify(v7 + 4);
    uint64_t v24 = (void *)type metadata accessor for _NativeDictionary(0LL, (uint64_t)v8, (uint64_t)v14, a3[4]);
    v7[18] = _NativeDictionary.subscript.modify(v7 + 8, (uint64_t)v12, isUniquelyReferenced_nonNull_native, v24);
    return Dictionary._Variant.subscript.modify;
  }

  return result;
}

void Dictionary._Variant.subscript.modify(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *a1 + 32;
  uint64_t v3 = *(void (**)(uint64_t, void))(*a1 + 136);
  uint64_t v4 = *(void *)(*a1 + 128);
  uint64_t v5 = *(void *)(*a1 + 104);
  uint64_t v6 = *(void *)(*a1 + 112);
  (*(void (**)(uint64_t, void))(*a1 + 144))(*a1 + 64, 0LL);
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v4, v5);
  v3(v2, 0LL);
  uint64_t v7 = *(void **)(v1 + 120);
  free(*(void **)(v1 + 128));
  free(v7);
  free((void *)v1);
}

void Dictionary._Variant.subscript.modify(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = *(void *)(*a1 + 112LL);
  uint64_t v2 = *(void *)(*a1 + 120LL);
  uint64_t v4 = *(void *)(*a1 + 104LL);
  (*(void (**)(void, void))(*a1 + 152LL))(*a1, 0LL);
  (*(void (**)(uint64_t, uint64_t))(v3 + 8))(v2, v4);
  swift_release(*(void *)(v1 + 96));
  uint64_t v5 = *(void **)(v1 + 120);
  free(*(void **)(v1 + 128));
  free(v5);
  free((void *)v1);
}

unint64_t _NativeDictionary.find(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return __RawDictionaryStorage.find<A>(_:)(a1, a3, a5);
}

_OWORD *specialized _NativeDictionary._insert(at:key:value:)( unint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, void *a5)
{
  a5[(a1 >> 6) + 8] |= 1LL << a1;
  uint64_t v6 = (void *)(a5[6] + 16 * a1);
  *uint64_t v6 = a2;
  v6[1] = a3;
  unint64_t result = outlined init with take of Any(a4, (_OWORD *)(a5[7] + 32 * a1));
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1LL);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

{
  void *v6;
  _OWORD *result;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  a5[(a1 >> 6) + 8] |= 1LL << a1;
  uint64_t v6 = (void *)(a5[6] + 16 * a1);
  *uint64_t v6 = a2;
  v6[1] = a3;
  unint64_t result = outlined init with take of Any(a4, (_OWORD *)(a5[7] + 32 * a1));
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1LL);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

_OWORD *specialized _NativeDictionary._insert(at:key:value:)( unint64_t a1, uint64_t a2, _OWORD *a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1LL << a1;
  uint64_t v5 = a4[6] + 40 * a1;
  __int128 v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v6;
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  unint64_t result = outlined init with take of Any(a3, (_OWORD *)(a4[7] + 32 * a1));
  uint64_t v8 = a4[2];
  BOOL v9 = __OFADD__(v8, 1LL);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a4[2] = v10;
  }
  return result;
}

{
  uint64_t v5;
  __int128 v6;
  _OWORD *result;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  a4[(a1 >> 6) + 8] |= 1LL << a1;
  uint64_t v5 = a4[6] + 40 * a1;
  __int128 v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v6;
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  unint64_t result = outlined init with take of Any(a3, (_OWORD *)(a4[7] + 32 * a1));
  uint64_t v8 = a4[2];
  BOOL v9 = __OFADD__(v8, 1LL);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a4[2] = v10;
  }
  return result;
}

unint64_t specialized _NativeDictionary._insert(at:key:value:)( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  a6[(result >> 6) + 8] |= 1LL << result;
  __int128 v6 = (void *)(a6[6] + 16 * result);
  *__int128 v6 = a2;
  v6[1] = a3;
  uint64_t v7 = (void *)(a6[7] + 16 * result);
  *uint64_t v7 = a4;
  v7[1] = a5;
  uint64_t v8 = a6[2];
  BOOL v9 = __OFADD__(v8, 1LL);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a6[2] = v10;
  }
  return result;
}

unint64_t specialized _NativeDictionary._insert(at:key:value:)( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  a5[(result >> 6) + 8] |= 1LL << result;
  uint64_t v5 = (void *)(a5[6] + 16 * result);
  *uint64_t v5 = a2;
  v5[1] = a3;
  uint64_t v6 = a5[7] + 40 * result;
  __int128 v7 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)uint64_t v6 = *(_OWORD *)a4;
  *(_OWORD *)(v6 + 16) = v7;
  *(void *)(v6 + 32) = *(void *)(a4 + 32);
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1LL);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

{
  uint64_t v5;
  __int128 v6;
  void *v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  a5[(result >> 6) + 8] |= 1LL << result;
  uint64_t v5 = a5[6] + 40 * result;
  uint64_t v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v6;
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  __int128 v7 = (void *)(a5[7] + 16 * result);
  *__int128 v7 = a3;
  v7[1] = a4;
  uint64_t v8 = a5[2];
  BOOL v9 = __OFADD__(v8, 1LL);
  uint64_t v10 = v8 + 1;
  if (v9) {
    __break(1u);
  }
  else {
    a5[2] = v10;
  }
  return result;
}

uint64_t _NativeDictionary._insert(at:key:value:)( unint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  a4[(a1 >> 6) + 8] |= 1LL << a1;
  (*(void (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 32LL))( a4[6] + *(void *)(*(void *)(a5 - 8) + 72LL) * a1,  a2,  a5);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a6 - 8) + 32LL))( a4[7] + *(void *)(*(void *)(a6 - 8) + 72LL) * a1,  a3,  a6);
  uint64_t v11 = a4[2];
  BOOL v12 = __OFADD__(v11, 1LL);
  uint64_t v13 = v11 + 1;
  if (v12) {
    __break(1u);
  }
  else {
    a4[2] = v13;
  }
  return result;
}

uint64_t Dictionary.subscript.getter@<X0>( id *a1@<X0>, void (*a2)(void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, char *a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a3;
  unint64_t v32 = a2;
  uint64_t v14 = type metadata accessor for Optional(0LL, (uint64_t)a6, a3, a4);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v31 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v31 - v19;
  if ((a4 & 0xC000000000000001LL) != 0)
  {
    uint64_t v21 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a5);
    if (a4 < 0) {
      uint64_t v22 = (void *)a4;
    }
    else {
      uint64_t v22 = (void *)(a4 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v23 = objc_msgSend(v22, sel_objectForKey_, v21, v31, v32);
    swift_unknownObjectRelease(v21);
    if (v23)
    {
      _forceBridgeFromObjectiveC<A>(_:_:)(v23, a6, v24, v20);
      swift_unknownObjectRelease(v23);
      uint64_t v25 = 0LL;
      uint64_t v26 = *((void *)a6 - 1);
      goto LABEL_11;
    }
  }

  else if (*(void *)(a4 + 16))
  {
    unint64_t v27 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a5, a7);
    if ((v28 & 1) != 0)
    {
      uint64_t v29 = *(void *)(a4 + 56);
      uint64_t v26 = *((void *)a6 - 1);
      (*(void (**)(char *, unint64_t, char *))(v26 + 16))(v20, v29 + *(void *)(v26 + 72) * v27, a6);
      uint64_t v25 = 0LL;
      goto LABEL_11;
    }
  }

  uint64_t v26 = *((void *)a6 - 1);
  uint64_t v25 = 1LL;
LABEL_11:
  (*(void (**)(char *, uint64_t, uint64_t, char *))(v26 + 56))(v20, v25, 1LL, a6);
  (*(void (**)(char *, char *, uint64_t))(v15 + 32))(v18, v20, v14);
  v32();
  return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v18, v14);
}

void (*Dictionary.subscript.modify( uint64_t *a1, uint64_t a2, void (*a3)(unint64_t), uint64_t a4, uint64_t a5))(void **a1)
{
  uint64_t v6 = v5;
  uint64_t v7 = a5;
  uint64_t v11 = *(char **)(a5 + 16);
  uint64_t v40 = *((void *)v11 - 1);
  uint64_t v12 = (uint64_t)malloc(*(void *)(v40 + 64));
  *a1 = v12;
  uint64_t v13 = *(uint64_t **)(v7 + 24);
  uint64_t v39 = malloc(*(void *)(*(v13 - 1) + 64));
  a1[1] = (uint64_t)v39;
  uint64_t v14 = *v6;
  uint64_t v42 = a3;
  uint64_t v43 = a2;
  uint64_t v41 = v12;
  if ((*v6 & 0xC000000000000001LL) == 0)
  {
    Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v14);
    uint64_t v28 = *v6;
    uint64_t v44 = *v6;
    *uint64_t v6 = 0x8000000000000000LL;
    uint64_t v7 = *(void *)(v7 + 32);
    unint64_t v29 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v11, v7);
    uint64_t v31 = *(void *)(v28 + 16);
    BOOL v32 = (v30 & 1) == 0;
    Swift::Int v33 = v31 + v32;
    if (!__OFADD__(v31, v32))
    {
      uint64_t v12 = v29;
      LOBYTE(a2) = v30;
      if (*(void *)(v28 + 24) < v33)
      {
        type metadata accessor for _NativeDictionary(0LL, (uint64_t)v11, (uint64_t)v13, v7);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v33, isUniquelyReferenced_nonNull_native);
        uint64_t v28 = v44;
        unint64_t v34 = __RawDictionaryStorage.find<A>(_:)(v43, (uint64_t)v11, v7);
        if ((a2 & 1) != (v35 & 1)) {
          goto LABEL_24;
        }
        uint64_t v12 = v34;
LABEL_17:
        uint64_t v36 = *v6;
        *uint64_t v6 = v28;
        swift_bridgeObjectRelease(v36);
        uint64_t v17 = (__objc2_class **)*v6;
        if ((a2 & 1) != 0) {
          goto LABEL_11;
        }
LABEL_18:
        unint64_t v37 = swift_bridgeObjectRetain((unint64_t)v17, v19, v20, v21);
        v42(v37);
        (*(void (**)(uint64_t, uint64_t, char *))(v40 + 16))(v41, v43, v11);
        _NativeDictionary._insert(at:key:value:)(v12, v41, (uint64_t)v39, v17, (uint64_t)v11, (uint64_t)v13);
        goto LABEL_19;
      }

      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_17;
      }
LABEL_23:
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v11, (uint64_t)v13, v7);
      _NativeDictionary.copy()();
      uint64_t v28 = v44;
      goto LABEL_17;
    }

void Dictionary.subscript.modify(void **a1)
{
  uint64_t v1 = *a1;
  free(a1[1]);
  free(v1);
}

unint64_t Dictionary._Variant.mutatingFind(_:)(uint64_t a1, void *a2)
{
  uint64_t v5 = v2;
  uint64_t v8 = *v2;
  BOOL v9 = (char *)a2[2];
  uint64_t v10 = (uint64_t *)a2[3];
  if ((*v2 & 0xC000000000000001LL) == 0)
  {
    Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v8);
    uint64_t v23 = *v2;
    uint64_t v34 = *v5;
    *uint64_t v5 = 0x8000000000000000LL;
    uint64_t v4 = a2[4];
    unint64_t v24 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
    uint64_t v26 = *(void *)(v23 + 16);
    BOOL v27 = (v25 & 1) == 0;
    Swift::Int v28 = v26 + v27;
    if (!__OFADD__(v26, v27))
    {
      char v29 = v25;
      if (*(void *)(v23 + 24) >= v28)
      {
        unint64_t v3 = v24;
        if (!isUniquelyReferenced_nonNull_native)
        {
LABEL_21:
          type metadata accessor for _NativeDictionary(0LL, (uint64_t)v9, (uint64_t)v10, v4);
          _NativeDictionary.copy()();
          uint64_t v23 = v34;
        }
      }

      else
      {
        type metadata accessor for _NativeDictionary(0LL, (uint64_t)v9, (uint64_t)v10, v4);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v28, isUniquelyReferenced_nonNull_native);
        uint64_t v23 = v34;
        unint64_t v30 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
        if ((v29 & 1) != (v31 & 1)) {
          goto LABEL_22;
        }
        unint64_t v3 = v30;
      }

      uint64_t v32 = *v5;
      *uint64_t v5 = v23;
      swift_bridgeObjectRelease(v32);
      return v3;
    }

uint64_t _NativeDictionary._values.getter(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t Dictionary.subscript.setter( Swift::Int a1, uint64_t a2, Swift::Int a3, unint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  uint64_t v7 = a5;
  id v12 = *(uint64_t **)(a5 + 24);
  uint64_t v13 = *(v12 - 1);
  MEMORY[0x1895F8858](a1);
  unint64_t v47 = (char *)&v47 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v48 = v15;
  uint64_t v16 = *v5;
  Swift::Int v18 = *(char **)(v17 + 16);
  BOOL v19 = (*v5 & 0xC000000000000001LL) == 0;
  Swift::Int v50 = a1;
  uint64_t v51 = v20;
  uint64_t v49 = v21;
  if (v19)
  {
    Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v16);
    uint64_t v35 = *v5;
    unint64_t v52 = (__objc2_class **)*v6;
    *uint64_t v6 = 0x8000000000000000LL;
    uint64_t v7 = *(void *)(v7 + 32);
    unint64_t v36 = __RawDictionaryStorage.find<A>(_:)(a2, (uint64_t)v18, v7);
    uint64_t v38 = *(void *)(v35 + 16);
    BOOL v39 = (v37 & 1) == 0;
    a3 = v38 + v39;
    if (!__OFADD__(v38, v39))
    {
      a4 = v36;
      LOBYTE(a2) = v37;
      if (*(void *)(v35 + 24) < a3)
      {
        type metadata accessor for _NativeDictionary(0LL, (uint64_t)v18, (uint64_t)v12, v7);
        _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(a3, isUniquelyReferenced_nonNull_native);
        uint64_t v35 = (uint64_t)v52;
        unint64_t v40 = __RawDictionaryStorage.find<A>(_:)(v51, (uint64_t)v18, v7);
        if ((a2 & 1) != (v41 & 1)) {
          goto LABEL_24;
        }
        a4 = v40;
        a3 = v50;
LABEL_17:
        uint64_t v42 = *v6;
        *uint64_t v6 = v35;
        swift_bridgeObjectRelease(v42);
        unint64_t v24 = (__objc2_class **)*v6;
        if ((a2 & 1) != 0) {
          goto LABEL_11;
        }
LABEL_18:
        unint64_t v43 = swift_bridgeObjectRetain((unint64_t)v24, v26, v27, v28);
        uint64_t v44 = (uint64_t)v47;
        v49(v43);
        _NativeDictionary._insert(at:key:value:)(a4, v51, v44, v24, (uint64_t)v18, (uint64_t)v12);
        goto LABEL_19;
      }

      a3 = v50;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_17;
      }
LABEL_23:
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v18, (uint64_t)v12, v7);
      _NativeDictionary.copy()();
      uint64_t v35 = (uint64_t)v52;
      goto LABEL_17;
    }

__objc2_class **Dictionary.mapValues<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, char *a5, uint64_t a6, uint64_t a7)
{
  if ((a3 & 0xC000000000000001LL) == 0) {
    return (__objc2_class **)_NativeDictionary.mapValues<A>(_:)(a1, a2, a3, (uint64_t)a4, (uint64_t)a5, a6);
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return __CocoaDictionary.mapValues<A, B, C>(_:)(a1, a2, (swift *)a3, a4, a5, a6, a7);
}

__objc2_class **Dictionary._Variant.mapValues<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, char *a5, uint64_t a6, uint64_t a7)
{
  if ((a3 & 0xC000000000000001LL) == 0) {
    return (__objc2_class **)_NativeDictionary.mapValues<A>(_:)(a1, a2, a3, (uint64_t)a4, (uint64_t)a5, a6);
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return __CocoaDictionary.mapValues<A, B, C>(_:)(a1, a2, (swift *)a3, a4, a5, a6, a7);
}

__objc2_class **Dictionary.compactMapValues<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v138 = a7;
  v155 = (char *)a4;
  v144 = a1;
  uint64_t v145 = a2;
  uint64_t v133 = type metadata accessor for Optional(0LL, a6, a3, a4);
  uint64_t v132 = *(void *)(v133 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v133);
  v143 = (char *)&v118 - v12;
  uint64_t v154 = a6;
  uint64_t v139 = *(void *)(a6 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  v141 = (char *)&v118 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  v131 = (char *)&v118 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a4, a5, "key value ", 0LL);
  uint64_t v149 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v140 = (uint64_t)&v118 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v118 - v19;
  uint64_t v122 = type metadata accessor for Optional(0LL, a5, v21, v22);
  uint64_t v23 = *(void *)(v122 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v122);
  uint64_t v26 = (char *)&v118 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v24);
  v146 = (uint64_t *)((char *)&v118 - v27);
  uint64_t v120 = type metadata accessor for Optional(0LL, a4, v28, v29);
  uint64_t v124 = *(void *)(v120 - 8);
  uint64_t v30 = MEMORY[0x1895F8858](v120);
  uint64_t v123 = (char *)&v118 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v119 = (uint64_t *)((char *)&v118 - v33);
  uint64_t v34 = (uint64_t *)a5;
  uint64_t v156 = *(void *)(a5 - 8);
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  v137 = (char *)&v118 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v148 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v35);
  v136 = (char *)&v118 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v40 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v38, v39);
  MEMORY[0x1895F8858](v40);
  v153 = (char *)&v118 - v44;
  v161 = &_swiftEmptyDictionarySingleton;
  if ((a3 & 0xC000000000000001LL) != 0)
  {
    uint64_t v45 = v26;
    if (a3 < 0) {
      uint64_t v46 = a3;
    }
    else {
      uint64_t v46 = a3 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v47 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v48 = (unint64_t)swift_allocObject(v47, 0xE8uLL, 7uLL);
    uint64_t v129 = 0LL;
    uint64_t v49 = 0LL;
    unint64_t v50 = 0LL;
    *(void *)(v48 + 208) = v46;
    *(void *)(v48 + 216) = 0LL;
    uint64_t v26 = v45;
    *(_OWORD *)(v48 + 16) = 0u;
    *(_OWORD *)(v48 + 32) = 0u;
    *(_OWORD *)(v48 + 48) = 0u;
    *(_OWORD *)(v48 + 64) = 0u;
    *(_OWORD *)(v48 + 80) = 0u;
    *(_OWORD *)(v48 + 96) = 0u;
    *(_OWORD *)(v48 + 112) = 0u;
    *(_OWORD *)(v48 + 128) = 0u;
    *(_OWORD *)(v48 + 144) = 0u;
    *(_OWORD *)(v48 + 160) = 0u;
    *(_OWORD *)(v48 + 176) = 0u;
    *(_OWORD *)(v48 + 192) = 0u;
    *(void *)(v48 + 224) = 0LL;
    unint64_t v51 = v48 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v52 = -1LL << *(_BYTE *)(a3 + 32);
    uint64_t v49 = ~v52;
    uint64_t v53 = *(void *)(a3 + 64);
    uint64_t v129 = a3 + 64;
    uint64_t v54 = -v52;
    if (v54 < 64) {
      uint64_t v55 = ~(-1LL << v54);
    }
    else {
      uint64_t v55 = -1LL;
    }
    unint64_t v50 = v55 & v53;
    unint64_t v51 = a3;
  }

  uint64_t v127 = (v51 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v134 = v51 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v126 = (v51 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v125 = v49;
  int64_t v128 = (unint64_t)(v49 + 64) >> 6;
  swift_bridgeObjectRetain(a3, v41, v42, v43);
  uint64_t v59 = 0LL;
  v130 = (swift *)&unk_189B8D230;
  v151 = v34;
  uint64_t v60 = v149;
  v121 = v26;
  unint64_t v142 = v51;
  uint64_t v147 = v23;
  v135 = v20;
  while (1)
  {
    uint64_t v61 = v146;
    v152 = v59;
    if ((v51 & 0x8000000000000000LL) == 0)
    {
      uint64_t v62 = v153;
      unint64_t v150 = v50;
      if (v50)
      {
        uint64_t v63 = TupleTypeMetadata2;
        uint64_t v157 = (v50 - 1) & v50;
        v158 = v59;
        unint64_t v64 = __clz(__rbit64(v50)) | ((void)v59 << 6);
      }

      else
      {
        int64_t v78 = (int64_t)v59 + 1;
        if (__OFADD__(v59, 1LL))
        {
          __break(1u);
LABEL_60:
          __break(1u);
LABEL_61:
          unint64_t v117 = 773LL;
LABEL_63:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v117,  0);
        }

        if (v78 >= v128) {
          goto LABEL_55;
        }
        unint64_t v79 = *(void *)(v129 + 8 * v78);
        if (!v79)
        {
          int64_t v80 = (int64_t)v59 + 2;
          unint64_t v79 = *(void *)(v129 + 8 * v80);
          if (!v79)
          {
            int64_t v80 = (int64_t)v59 + 3;
            unint64_t v79 = *(void *)(v129 + 8 * v80);
            if (!v79)
            {
              while (1)
              {
                int64_t v78 = v80 + 1;
                if (__OFADD__(v80, 1LL)) {
                  goto LABEL_60;
                }
                if (v78 >= v128) {
                  goto LABEL_55;
                }
                unint64_t v79 = *(void *)(v129 + 8 * v78);
                ++v80;
                if (v79) {
                  goto LABEL_36;
                }
              }
            }
          }

          int64_t v78 = v80;
        }

uint64_t Sequence.reduce<A>(into:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, const char *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v39 = a6;
  uint64_t v36 = a5;
  v33[0] = a2;
  v33[1] = a3;
  uint64_t v42 = a1;
  uint64_t v34 = a7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v41 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)v33 - v11;
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)v33 - v17;
  uint64_t v19 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)v33 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v22 = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v35 = *(void *)(v22 - 8);
  MEMORY[0x1895F8858](v22);
  uint64_t v24 = (char *)v33 - v23;
  (*(void (**)(char *, unint64_t, uint64_t))(v19 + 16))(v21, v40, a4);
  uint64_t v25 = (uint64_t)v39;
  (*((void (**)(uint64_t, const char *))v39 + 4))(a4, v39);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v25,  a4,  v22,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v27 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v39 = v24;
  unint64_t v40 = v22;
  v27(v22, AssociatedConformanceWitness);
  uint64_t v28 = v41;
  uint64_t v29 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v41 + 48);
  if (v29(v18, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_5:
    (*(void (**)(const char *, unint64_t))(v35 + 8))(v39, v40);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v36 - 8) + 32LL))(v34, v42);
  }

  else
  {
    uint64_t v37 = v29;
    uint64_t v38 = v27;
    uint64_t v30 = (void (*)(uint64_t, char *))v33[0];
    uint64_t v31 = *(void (**)(char *, char *, unint64_t))(v28 + 32);
    while (1)
    {
      v31(v12, v18, AssociatedTypeWitness);
      v30(v42, v12);
      if (v7) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v41 + 8))(v12, AssociatedTypeWitness);
      v38(v40, AssociatedConformanceWitness);
      if (v37(v18, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_5;
      }
    }

    (*(void (**)(char *, unint64_t))(v41 + 8))(v12, AssociatedTypeWitness);
    (*(void (**)(const char *, unint64_t))(v35 + 8))(v39, v40);
    return (*(uint64_t (**)(uint64_t))(*(void *)(v36 - 8) + 8LL))(v42);
  }

void Dictionary.updateValue(_:forKey:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = (void *)type metadata accessor for Dictionary._Variant(0LL, a3[2], a3[3], a3[4]);
  Dictionary._Variant.updateValue(_:forKey:)(a1, a2, v7, a4);
}

void Dictionary._Variant.updateValue(_:forKey:)( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  uint64_t v11 = (char *)a3[2];
  uint64_t v12 = (uint64_t *)a3[3];
  if ((v10 & 0xC000000000000001LL) != 0)
  {
    if (v10 < 0) {
      uint64_t v13 = (void *)v10;
    }
    else {
      uint64_t v13 = (void *)(v10 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v14 = objc_msgSend(v13, sel_count);
    if (__OFADD__(v14, 1LL))
    {
      __break(1u);
    }

    else
    {
      uint64_t v15 = a3[4];
      uint64_t v20 = _NativeDictionary.init(_:capacity:)(v13, (uint64_t)v14 + 1, v11, v12, v15);
      uint64_t v16 = type metadata accessor for _NativeDictionary(0LL, (uint64_t)v11, (uint64_t)v12, v15);
      _NativeDictionary.updateValue(_:forKey:isUnique:)(a1, a2, 1, v16, a4);
      *uint64_t v5 = (uint64_t)v20;
    }
  }

  else
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v10);
    uint64_t v21 = *v5;
    *uint64_t v5 = 0x8000000000000000LL;
    uint64_t v18 = type metadata accessor for _NativeDictionary(0LL, (uint64_t)v11, (uint64_t)v12, a3[4]);
    _NativeDictionary.updateValue(_:forKey:isUnique:)(a1, a2, isUniquelyReferenced_nonNull_native, v18, a4);
    uint64_t v19 = *v5;
    *uint64_t v5 = v21;
    swift_bridgeObjectRelease(v19);
  }

void Dictionary.merge<A>(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9 = type metadata accessor for Dictionary._Variant(0LL, a4[2], a4[3], a4[4]);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)(a1, a2, a3, v9, a5);
}

void Dictionary._Variant.merge<A>(_:uniquingKeysWith:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = v5;
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  id v14 = (void (*)(char *, uint64_t, swift *))((char *)&v33 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v12);
  uint64_t v19 = (void (*)(char *, uint64_t, swift *))((char *)&v33 - v18);
  uint64_t v20 = *v7;
  unint64_t v22 = *(char **)(v17 + 16);
  uint64_t v21 = *(uint64_t **)(v17 + 24);
  BOOL v23 = (*v7 & 0xC000000000000001LL) == 0;
  uint64_t v35 = v16;
  uint64_t v36 = v24;
  uint64_t v33 = v6;
  uint64_t v34 = v15;
  if (v23)
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v20);
    (*(void (**)(void, uint64_t, uint64_t))(v11 + 32))(v19, a1, a5);
    uint64_t v37 = (__objc2_class **)*v7;
    *uint64_t v7 = 0x8000000000000000LL;
    uint64_t v31 = type metadata accessor for _NativeDictionary(0LL, (uint64_t)v22, (uint64_t)v21, *(void *)(a4 + 32));
    specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)( v19,  isUniquelyReferenced_nonNull_native,  v34,  v35,  v31,  a5,  v36);
    (*(void (**)(void (*)(char *, uint64_t, swift *), uint64_t))(v11 + 8))(v19, a5);
    uint64_t v32 = *v7;
    *uint64_t v7 = (uint64_t)v37;
    swift_bridgeObjectRelease(v32);
  }

  else
  {
    if (v20 < 0) {
      uint64_t v25 = (void *)v20;
    }
    else {
      uint64_t v25 = (void *)(v20 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(v20, (uint64_t)v15, v16, (char *)v17);
    id v26 = objc_msgSend(v25, sel_count);
    uint64_t v27 = *(void *)(a4 + 32);
    uint64_t v37 = _NativeDictionary.init(_:capacity:)(v25, (uint64_t)v26, v22, v21, v27);
    (*(void (**)(void, uint64_t, uint64_t))(v11 + 32))(v14, a1, a5);
    uint64_t v28 = type metadata accessor for _NativeDictionary(0LL, (uint64_t)v22, (uint64_t)v21, v27);
    uint64_t v29 = v33;
    specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)(v14, 1, v34, v35, v28, a5, v36);
    (*(void (**)(void (*)(char *, uint64_t, swift *), uint64_t))(v11 + 8))(v14, a5);
    if (v29)
    {
      swift_release((uint64_t)v37);
    }

    else
    {
      swift_bridgeObjectRelease(*v7);
      *uint64_t v7 = (uint64_t)v37;
    }
  }

void Dictionary.merge(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = swift_allocObject((uint64_t)&unk_189B78230, 0x28uLL, 7uLL);
  uint64_t v9 = a4[2];
  uint64_t v10 = a4[3];
  v8[2] = v9;
  v8[3] = v10;
  uint64_t v11 = a4[4];
  v8[4] = v11;
  uint64_t v12 = swift_allocObject((uint64_t)&unk_189B78258, 0x38uLL, 7uLL);
  v12[2] = v9;
  uint64_t v12[3] = v10;
  v12[4] = v11;
  v12[5] = partial apply for closure #1 in Dictionary.merge(_:uniquingKeysWith:);
  v12[6] = v8;
  v19[0] = a1;
  v19[1] = partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B);
  v19[2] = v12;
  uint64_t v13 = type metadata accessor for Dictionary._Variant(0LL, v9, v10, v11);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, v9, v10, 0LL, 0LL);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A : B], a4, v15);
  uint64_t v17 = type metadata accessor for LazyMapSequence(0LL, (uint64_t)a4, (uint64_t)TupleTypeMetadata2, WitnessTable);
  swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v17, v18);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)((uint64_t)v19, a2, a3, v13, v17);
}

uint64_t thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)@<X0>( uint64_t a1@<X0>, uint64_t (*a2)(uint64_t, uint64_t, uint64_t, uint64_t)@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v10 = a1 + *((int *)swift_getTupleTypeMetadata2(0LL, a3, a4, "key value ", 0LL) + 12);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, a4, 0LL, 0LL);
  return a2(a5, a5 + *((int *)TupleTypeMetadata2 + 12), a1, v10);
}

unint64_t *LazySequenceProtocol.map<A>(_:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  (uint64_t)&associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  id v14 = (void *)(a6
                 + *(int *)(type metadata accessor for LazyMapSequence( 0LL,  AssociatedTypeWitness,  a4,  AssociatedConformanceWitness)
                          + 44));
  *id v14 = a1;
  v14[1] = a2;
  return swift_retain(a2, v15, v16, v17);
}

uint64_t Dictionary.merging<A>(_:uniquingKeysWith:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = type metadata accessor for Dictionary._Variant(0LL, a5, a6, a8);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)(a1, a2, a3, v13, a7);
  if (v8) {
    swift_bridgeObjectRelease(a4);
  }
  return a4;
}

void Dictionary.merging(_:uniquingKeysWith:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v24 = a4;
  id v14 = swift_allocObject((uint64_t)&unk_189B78280, 0x28uLL, 7uLL);
  v14[2] = a5;
  _OWORD v14[3] = a6;
  v14[4] = a7;
  uint64_t v15 = swift_allocObject((uint64_t)&unk_189B782A8, 0x38uLL, 7uLL);
  v15[2] = a5;
  v15[3] = a6;
  v15[4] = a7;
  v15[5] = partial apply for closure #1 in Dictionary.merge(_:uniquingKeysWith:);
  v15[6] = v14;
  v23[0] = a1;
  v23[1] = partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B);
  v23[2] = v15;
  uint64_t v16 = type metadata accessor for Dictionary._Variant(0LL, a5, a6, a7);
  uint64_t v17 = type metadata accessor for Dictionary((const char *)0xFF, a5, a6, a7);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, a5, a6, 0LL, 0LL);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A : B], v17, v19);
  uint64_t v21 = type metadata accessor for LazyMapSequence(0LL, v17, (uint64_t)TupleTypeMetadata2, WitnessTable);
  swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v21, v22);
  Dictionary._Variant.merge<A>(_:uniquingKeysWith:)((uint64_t)v23, a2, a3, v16, v21);
  if (v7) {
    swift_bridgeObjectRelease(v24);
  }
}

void Dictionary.remove(at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t *a6)
{
  char v10 = a5 & 1;
  uint64_t v11 = type metadata accessor for Dictionary._Variant(0LL, a6[2], a6[3], a6[4]);
  Dictionary._Variant.remove(at:)(a1, a2, a3, a4, v10, v11);
}

void Dictionary._Variant.remove(at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v7 = (unint64_t *)v6;
  uint64_t v55 = a1;
  uint64_t v56 = a2;
  uint64_t v12 = *(char **)(a6 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v17 = (char *)&v53 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = *v6;
  uint64_t v20 = *(uint64_t **)(v19 + 24);
  BOOL v21 = (*v6 & 0xC000000000000001LL) == 0;
  uint64_t v57 = v22;
  if (!v21)
  {
    if (v18 < 0) {
      BOOL v23 = (void *)v18;
    }
    else {
      BOOL v23 = (void *)(v18 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(v18, v13, v14, v15);
    uint64_t v24 = _NativeDictionary.init(_:capacity:)( v23,  (uint64_t)objc_msgSend(v23, sel_count),  v12,  v20,  *(void *)(a6 + 32));
    uint64_t v25 = a4;
    unint64_t v26 = *v7;
    *uint64_t v7 = (unint64_t)v24;
    swift_retain((unint64_t *)v24, v27, v28, v29);
    uint64_t v30 = v26;
    a4 = v25;
    swift_bridgeObjectRelease(v30);
    if ((a5 & 1) == 0) {
      goto LABEL_6;
    }
LABEL_15:
    uint64_t v54 = a4;
    if (a3 >= 0) {
      uint64_t v37 = a3 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v37 = a3;
    }
    uint64_t v38 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a3, v39, v40, v41);
    uint64_t v42 = swift_dynamicCastClass(v37, v38);
    uint64_t v31 = v57;
    if (v42)
    {
      if (swift_dynamicCastClass(v37, v38))
      {
        uint64_t v46 = *(void *)(v37 + 24);
        uint64_t v47 = v54;
        if (*(void *)(v46 + 16) <= v54) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        unint64_t v48 = *(void **)(v46 + 8 * v54 + 24);
        swift_unknownObjectRetain(v48, v43, v44, v45);
        outlined consume of [A : B].Index._Variant<A, B>(a3, v47, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v48, v12, v49, v17);
        swift_unknownObjectRelease(v48);
        a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v17, (uint64_t)v12, *(void *)(a6 + 32));
        LOBYTE(v48) = v50;
        (*(void (**)(char *, char *))(v31 + 8))(v17, v12);
LABEL_26:
        unint64_t v32 = 303LL;
LABEL_11:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v32,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if (!swift_isUniquelyReferenced_nonNull_native(v18))
  {
    uint64_t v58 = *v6;
    *uint64_t v6 = 0x8000000000000000LL;
    type metadata accessor for _NativeDictionary(0LL, (uint64_t)v12, (uint64_t)v20, *(void *)(a6 + 32));
    _NativeDictionary.copy()();
    uint64_t v36 = *v6;
    *uint64_t v6 = v58;
    swift_bridgeObjectRelease(v36);
  }

  uint64_t v24 = (__objc2_class **)*v6;
  swift_bridgeObjectRetain(*v7, v33, v34, v35);
  if ((a5 & 1) != 0) {
    goto LABEL_15;
  }
LABEL_6:
  uint64_t v31 = v57;
  if (a3 < 0
    || 1LL << *((_BYTE *)v24 + 32) <= a3
    || ((*(unint64_t *)((char *)v24 + (((unint64_t)a3 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> a3) & 1) == 0
    || *((_DWORD *)v24 + 9) != (_DWORD)a4)
  {
    unint64_t v32 = 281LL;
    goto LABEL_11;
  }

uint64_t specialized Dictionary._Variant.removeValue(forKey:)( unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = v4;
  unint64_t v6 = a2;
  uint64_t v8 = *v5;
  swift_bridgeObjectRetain(*v5, a2, a3, a4);
  Swift::Int v9 = specialized __RawDictionaryStorage.find<A>(_:)(a1, v6);
  LOBYTE(v6) = v10;
  swift_bridgeObjectRelease(v8);
  if ((v6 & 1) == 0) {
    return 0LL;
  }
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v5);
  uint64_t v12 = *v5;
  unint64_t v17 = *v5;
  *uint64_t v5 = 0x8000000000000000LL;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized _NativeDictionary.copy()();
    uint64_t v12 = v17;
  }

  swift_bridgeObjectRelease(*(void *)(*(void *)(v12 + 48) + 16 * v9 + 8));
  uint64_t v13 = *(void *)(*(void *)(v12 + 56) + 16 * v9);
  v14.offset = v9;
  specialized _NativeDictionary._delete(at:)(v14, v12);
  uint64_t v15 = *v5;
  *uint64_t v5 = v12;
  swift_bridgeObjectRelease(v15);
  return v13;
}

double specialized Dictionary._Variant.removeValue(forKey:)@<D0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6 = v5;
  unint64_t v7 = a2;
  uint64_t v10 = *v6;
  swift_bridgeObjectRetain(*v6, a2, a3, a4);
  Swift::Int v11 = specialized __RawDictionaryStorage.find<A>(_:)(a1, v7);
  LOBYTE(v7) = v12;
  swift_bridgeObjectRelease(v10);
  if ((v7 & 1) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v6);
    uint64_t v14 = *v6;
    unint64_t v19 = *v6;
    *unint64_t v6 = 0x8000000000000000LL;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeDictionary.copy()();
      uint64_t v14 = v19;
    }

    swift_bridgeObjectRelease(*(void *)(*(void *)(v14 + 48) + 16 * v11 + 8));
    uint64_t v15 = *(void *)(v14 + 56) + 40 * v11;
    __int128 v20 = *(_OWORD *)v15;
    __int128 v21 = *(_OWORD *)(v15 + 16);
    uint64_t v22 = *(void *)(v15 + 32);
    v16.offset = v11;
    specialized _NativeDictionary._delete(at:)(v16, v14);
    uint64_t v17 = *v6;
    *unint64_t v6 = v14;
    swift_bridgeObjectRelease(v17);
    double result = *(double *)&v20;
    *(_OWORD *)a5 = v20;
    *(_OWORD *)(a5 + 16) = v21;
    *(void *)(a5 + 32) = v22;
  }

  else
  {
    *(void *)(a5 + 32) = 0LL;
    double result = 0.0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
  }

  return result;
}

double specialized Dictionary._Variant.removeValue(forKey:)@<D0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, _OWORD *a5@<X8>)
{
  unint64_t v6 = v5;
  unint64_t v7 = a2;
  uint64_t v10 = *v6;
  swift_bridgeObjectRetain(*v6, a2, a3, a4);
  Swift::Int v11 = specialized __RawDictionaryStorage.find<A>(_:)(a1, v7);
  LOBYTE(v7) = v12;
  swift_bridgeObjectRelease(v10);
  if ((v7 & 1) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v6);
    uint64_t v14 = *v6;
    unint64_t v18 = *v6;
    *unint64_t v6 = 0x8000000000000000LL;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeDictionary.copy()();
      uint64_t v14 = v18;
    }

    swift_bridgeObjectRelease(*(void *)(*(void *)(v14 + 48) + 16 * v11 + 8));
    outlined init with take of Any((_OWORD *)(*(void *)(v14 + 56) + 32 * v11), v19);
    v15.offset = v11;
    specialized _NativeDictionary._delete(at:)(v15, v14);
    uint64_t v16 = *v6;
    *unint64_t v6 = v14;
    swift_bridgeObjectRelease(v16);
    outlined init with take of Any(v19, a5);
  }

  else
  {
    double result = 0.0;
    *a5 = 0u;
    a5[1] = 0u;
  }

  return result;
}

double specialized Dictionary._Variant.removeValue(forKey:)@<D0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, _OWORD *a5@<X8>)
{
  unint64_t v6 = v5;
  uint64_t v9 = *v6;
  swift_bridgeObjectRetain(*v6, a2, a3, a4);
  Swift::Int v10 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
  LOBYTE(a1) = v11;
  swift_bridgeObjectRelease(v9);
  if ((a1 & 1) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v6);
    uint64_t v13 = *v6;
    unint64_t v17 = *v6;
    *unint64_t v6 = 0x8000000000000000LL;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeDictionary.copy()();
      uint64_t v13 = v17;
    }

    outlined destroy of AnyHashable((uint64_t *)(*(void *)(v13 + 48) + 40 * v10));
    outlined init with take of Any((_OWORD *)(*(void *)(v13 + 56) + 32 * v10), v18);
    v14.offset = v10;
    specialized _NativeDictionary._delete(at:)(v14, v13);
    uint64_t v15 = *v6;
    *unint64_t v6 = v13;
    swift_bridgeObjectRelease(v15);
    outlined init with take of Any(v18, a5);
  }

  else
  {
    double result = 0.0;
    *a5 = 0u;
    a5[1] = 0u;
  }

  return result;
}

uint64_t specialized Dictionary._Variant.removeValue(forKey:)(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = *v5;
  swift_bridgeObjectRetain(*v5, a2, a3, a4);
  Swift::Int v8 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
  LOBYTE(a1) = v9;
  swift_bridgeObjectRelease(v7);
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v5);
  uint64_t v11 = *v5;
  unint64_t v16 = *v5;
  *uint64_t v5 = 0x8000000000000000LL;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized _NativeDictionary.copy()();
    uint64_t v11 = v16;
  }

  outlined destroy of AnyHashable((uint64_t *)(*(void *)(v11 + 48) + 40 * v8));
  uint64_t v12 = *(void *)(*(void *)(v11 + 56) + 16 * v8);
  v13.offset = v8;
  specialized _NativeDictionary._delete(at:)(v13, v11);
  uint64_t v14 = *v5;
  *uint64_t v5 = v11;
  swift_bridgeObjectRelease(v14);
  return v12;
}

uint64_t Dictionary._Variant.removeValue(forKey:)@<X0>(id *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = v3;
  Swift::Int v8 = *(uint64_t **)(a2 + 24);
  uint64_t v9 = *(v8 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v51 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  unint64_t v17 = (char *)&v51 - v16;
  uint64_t v18 = *v4;
  unint64_t v19 = *(uint64_t **)(v13 + 16);
  if ((*v4 & 0xC000000000000001LL) != 0)
  {
    uint64_t v52 = v9;
    uint64_t v53 = a3;
    BOOL v23 = _bridgeAnythingToObjectiveC<A>(_:)(a1, v19);
    uint64_t v24 = *v4;
    if ((*v4 & 0x8000000000000000LL) != 0LL) {
      uint64_t v25 = (void *)*v4;
    }
    else {
      uint64_t v25 = (void *)(*v4 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(*v4, v20, v21, v22);
    id v26 = objc_msgSend(v25, sel_objectForKey_, v23);
    swift_unknownObjectRelease(v23);
    if (v26)
    {
      swift_unknownObjectRelease(v26);
      id v27 = objc_msgSend(v25, sel_count);
      uint64_t v28 = *(void *)(a2 + 32);
      uint64_t v29 = (unint64_t *)_NativeDictionary.init(_:capacity:)(v25, (uint64_t)v27, (char *)v19, v8, v28);
      swift_retain(v29, v30, v31, v32);
      unint64_t v33 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)v19, v28);
      char v35 = v34;
      swift_release((uint64_t)v29);
      if ((v35 & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Bridging did not preserve equality",  34LL,  2,  "Swift/DictionaryVariant.swift",  29LL,  2,  0x195uLL,  0);
      }
      (*(void (**)(unint64_t, uint64_t *))(*(v19 - 1) + 8))( v29[6] + *(void *)(*(v19 - 1) + 72) * v33,  v19);
      uint64_t v36 = v52;
      uint64_t v37 = *(void (**)(char *, unint64_t, uint64_t *))(v52 + 32);
      v37(v12, v29[7] + *(void *)(v52 + 72) * v33, v8);
      _NativeDictionary._delete(at:)((Swift::_HashTable::Bucket)v33);
      uint64_t v38 = *v4;
      *uint64_t v4 = (unint64_t)v29;
      swift_bridgeObjectRelease(v38);
      uint64_t v39 = v53;
      v37(v53, (unint64_t)v12, v8);
      return (*(uint64_t (**)(char *, void, uint64_t, uint64_t *))(v36 + 56))(v39, 0LL, 1LL, v8);
    }

    else
    {
      swift_bridgeObjectRelease(v24);
      return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t *))(v52 + 56))(v53, 1LL, 1LL, v8);
    }
  }

  else
  {
    uint64_t v41 = *(void *)(a2 + 32);
    swift_bridgeObjectRetain(*v4, v13, v14, v15);
    unint64_t v42 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)v19, v41);
    char v44 = v43;
    swift_bridgeObjectRelease(v18);
    if ((v44 & 1) != 0)
    {
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
      unint64_t v46 = *v4;
      unint64_t v54 = *v4;
      *uint64_t v4 = 0x8000000000000000LL;
      if (!isUniquelyReferenced_nonNull_native)
      {
        type metadata accessor for _NativeDictionary(0LL, (uint64_t)v19, (uint64_t)v8, v41);
        _NativeDictionary.copy()();
        unint64_t v46 = v54;
      }

      (*(void (**)(unint64_t, uint64_t *))(*(v19 - 1) + 8))( *(void *)(v46 + 48) + *(void *)(*(v19 - 1) + 72) * v42,  v19);
      unint64_t v47 = *(void *)(v46 + 56) + *(void *)(v9 + 72) * v42;
      uint64_t v48 = v9;
      uint64_t v49 = *(void (**)(char *, unint64_t, uint64_t *))(v9 + 32);
      v49(v17, v47, v8);
      _NativeDictionary._delete(at:)((Swift::_HashTable::Bucket)v42);
      uint64_t v50 = *v4;
      *uint64_t v4 = v46;
      swift_bridgeObjectRelease(v50);
      v49(a3, (unint64_t)v17, v8);
      return (*(uint64_t (**)(char *, void, uint64_t, uint64_t *))(v48 + 56))(a3, 0LL, 1LL, v8);
    }

    else
    {
      return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t *))(v9 + 56))(a3, 1LL, 1LL, v8);
    }
  }

Swift::Void __swiftcall Dictionary.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
}

Swift::Void __swiftcall Dictionary._Variant.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  unint64_t v3 = v2;
  uint64_t v5 = *v2;
  if (!keepingCapacity)
  {
    swift_bridgeObjectRelease(v5);
    uint64_t *v2 = (uint64_t)&_swiftEmptyDictionarySingleton;
    return;
  }

  uint64_t v6 = v1;
  uint64_t v7 = *(void *)(v1 + 16);
  if ((v5 & 0xC000000000000001LL) == 0)
  {
    goto LABEL_9;
  }

  if (v5 >= 0) {
    v5 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((uint64_t)objc_msgSend((id)v5, sel_count) > 0)
  {
LABEL_9:
    uint64_t v8 = *v3;
    uint64_t v9 = *(void *)(v6 + 24);
    if ((*v3 & 0xC000000000000001LL) != 0)
    {
      if (v8 < 0) {
        uint64_t v10 = (void *)*v3;
      }
      else {
        uint64_t v10 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
      }
      id v11 = objc_msgSend(v10, sel_count);
      swift_bridgeObjectRelease(v8);
      if (v11)
      {
        type metadata accessor for _DictionaryStorage(0LL, v7, v9, *(void *)(v6 + 32));
        uint64_t v12 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)((uint64_t)v11);
      }

      else
      {
        uint64_t v12 = &_swiftEmptyDictionarySingleton;
      }

      *unint64_t v3 = (uint64_t)v12;
    }

    else
    {
      Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
      uint64_t v15 = *v3;
      *unint64_t v3 = 0x8000000000000000LL;
      type metadata accessor for _NativeDictionary(0LL, v7, v9, *(void *)(v6 + 32));
      _NativeDictionary.removeAll(isUnique:)(isUniquelyReferenced_nonNull_native);
      uint64_t v14 = *v3;
      *unint64_t v3 = v15;
      swift_bridgeObjectRelease(v14);
    }
  }

unint64_t Dictionary.values.getter()
{
  unint64_t v0 = EnumeratedSequence._base.modify();
  return swift_bridgeObjectRetain(v0, v1, v2, v3);
}

uint64_t (*Dictionary.values.modify(void *a1))(uint64_t result)
{
  *a1 = *v1;
  a1[1] = v1;
  void *v1 = 0x8000000000000000LL;
  return _ArrayBody.count.modify;
}

unint64_t Dictionary._Variant.init(dummy:)()
{
  return 0x8000000000000000LL;
}

uint64_t swap<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = (char *)&v11 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void (**)(char *, uint64_t))(v8 + 32);
  v9(v7, a1);
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(a1, a2, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v9)(a2, v7, a3);
}

void Dictionary.values.setter(uint64_t a1)
{
  uint64_t *v1 = a1;
}

void Dictionary.Keys._variant.setter(uint64_t a1)
{
  uint64_t *v1 = a1;
}

uint64_t (*Dictionary.Keys._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t Dictionary.Keys.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return _NativeDictionary.startIndex.getter(a1);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      uint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_andKeys_count_, 0, v8 + 3, v6);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t Dictionary.Keys.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return 1LL << *(_BYTE *)(a1 + 32);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      uint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_andKeys_count_, 0, v8 + 3, v6);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

Swift::Int Dictionary.Keys.index(after:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = a1;
  uint64_t v9 = a3 & 1;
  if ((a4 & 0xC000000000000001LL) == 0) {
    return _NativeDictionary.index(after:)(a1, a2, v9, a4, a5, a6, a7);
  }
  if (a4 < 0) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a4 & 0xFFFFFFFFFFFFFF8LL;
  }
  if (!(_DWORD)v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  if (a1 >= 0) {
    uint64_t v11 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v11 = a1;
  }
  outlined copy of [A : B].Index._Variant<A, B>(a1, a2, 1LL, (char *)a4);
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v11, v12)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v11 + 16) != v10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E7uLL,  0);
  }
  if (*(void *)(*(void *)(v11 + 24) + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E8uLL,  0);
  }
  return v8;
}

void Dictionary.Keys.subscript.getter( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X6>, char *a6@<X8>)
{
  uint64_t v10 = a1;
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v16 & 0xC000000000000001LL) == 0)
  {
    if ((v13 & 1) == 0)
    {
      if (v10 < 0
        || 1LL << *(_BYTE *)(a3 + 32) <= v10
        || ((*(void *)(a3 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> v10) & 1) == 0
        || *(_DWORD *)(a3 + 36) != (_DWORD)a2)
      {
        unint64_t v24 = 281LL;
        goto LABEL_13;
      }

void Dictionary._Variant.key(at:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X6>, char *a6@<X8>)
{
  uint64_t v10 = a1;
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v16 & 0xC000000000000001LL) == 0)
  {
    if ((v13 & 1) == 0)
    {
      if (v10 < 0
        || 1LL << *(_BYTE *)(a3 + 32) <= v10
        || ((*(void *)(a3 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> v10) & 1) == 0
        || *(_DWORD *)(a3 + 36) != (_DWORD)a2)
      {
        unint64_t v24 = 281LL;
        goto LABEL_13;
      }

id Dictionary.Keys.count.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 16);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

uint64_t Dictionary.Keys._customContainsEquatableElement(_:)( id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      return v9 & 1;
    }

LABEL_9:
    char v9 = 0;
    return v9 & 1;
  }

  unint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v8 = objc_msgSend(v7, sel_objectForKey_, v6);
  swift_unknownObjectRelease(v6);
  if (!v8) {
    goto LABEL_9;
  }
  swift_unknownObjectRelease(v8);
  char v9 = 1;
  return v9 & 1;
}

    char v9 = 0;
    return v9 & 1;
  }

  unint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v8 = objc_msgSend(v7, sel_objectForKey_, v6);
  swift_unknownObjectRelease(v6);
  if (!v8) {
    goto LABEL_9;
  }
  swift_unknownObjectRelease(v8);
  char v9 = 1;
  return v9 & 1;
}

    char v9 = 0;
    return v9 & 1;
  }

  unint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, v5);
  if (v4 < 0) {
    uint64_t v7 = (void *)v4;
  }
  else {
    uint64_t v7 = (void *)(v4 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v8 = objc_msgSend(v7, sel_objectForKey_, v6);
  swift_unknownObjectRelease(v6);
  if (!v8) {
    goto LABEL_9;
  }
  swift_unknownObjectRelease(v8);
  char v9 = 1;
  return v9 & 1;
}

  (*(void (**)(char *, unint64_t))(v32 + 8))(v37, v38);
  return v39;
}

    uint64_t v14 = 4LL;
LABEL_10:
    if (rawValue) {
      goto LABEL_11;
    }
LABEL_46:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  if (v12 != 2)
  {
    if (v12 != 3) {
      goto LABEL_9;
    }
    goto LABEL_7;
  }

  uint64_t v15 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(4LL, v6, v5);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v15, 8LL, (uint64_t)rawValue, (uint64_t)v11);
  if (!v6 || !rawValue) {
    goto LABEL_46;
  }
  uint64_t v16 = (void *)(v6 + 12);
  if ((char *)(v6 + 12) != rawValue + 16)
  {
    *((void *)rawValue + 2) = *v16;
  }

  if ((v7 & 0x400000) != 0)
  {
    uint64_t v17 = (void *)(v6 + 20);
    if ((char *)(v6 + 20) != rawValue + 24)
    {
      *((void *)rawValue + 3) = *v17;
    }

    uint64_t v14 = 32LL;
    if ((v7 & 0x80000) == 0) {
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v14 = 24LL;
    if ((v7 & 0x80000) == 0) {
      goto LABEL_11;
    }
  }

  uint64_t v18 = RawKeyPathComponent._computedArguments.getter(v7, v6);
  uint64_t v19 = RawKeyPathComponent._computedArgumentSize.getter(v7, v6);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v19, v14, (uint64_t)rawValue, (uint64_t)v11);
  uint64_t v20 = (uint64_t *)(RawKeyPathComponent._computedArgumentHeaderPointer.getter(v7, v6) + 8);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(*v20, v14 + 8, (uint64_t)rawValue, (uint64_t)v11);
  uint64_t v21 = v14 + 16;
  if ((v7 & 0x10) != 0)
  {
    uint64_t v23 = (uint64_t *)(RawKeyPathComponent._computedArguments.getter(v7, v6) - 8);
    specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(*v23, v14 + 16, (uint64_t)rawValue, (uint64_t)v11);
    unint64_t v24 = RawKeyPathComponent._computedArguments.getter(v7, v6);
    if (((v24 - 8) & 7) != 0) {
      goto LABEL_43;
    }
    uint64_t v21 = v14 + 24;
    id v22 = *(void *)(v24 - 8);
  }

  else
  {
    id v22 = 0LL;
  }

  uint64_t v25 = v19 - v22;
  if (__OFSUB__(v19, v22))
  {
    __break(1u);
LABEL_45:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  uint64_t v26 = (uint64_t *)(RawKeyPathComponent._computedArgumentHeaderPointer.getter(v7, v6) + 8);
  uint64_t v27 = (void (*)(uint64_t, char *, uint64_t))ComputedAccessorsPtr.nonmutatingSetter<A, B>()(*v26);
  v27(v18, &rawValue[v21], v25);
  if ((v7 & 0x10) == 0) {
    goto LABEL_38;
  }
  uint64_t v28 = (size_t *)(RawKeyPathComponent._computedArguments.getter(v7, v6) - 8);
  if ((v28 & 7) != 0) {
LABEL_43:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  if ((*v28 & 0x8000000000000000LL) != 0) {
    goto LABEL_45;
  }
  memcpy(&rawValue[v21 + v25], (const void *)(v18 + v25), *v28);
LABEL_38:
  uint64_t v14 = v21 + v19;
  if (__OFADD__(v21, v19))
  {
    __break(1u);
    goto LABEL_41;
  }

          int64_t v80 = (v34 - 1) & v34;
          uint64_t v81 = v30;
        }
      }

      uint64_t v39 = v37 + 1;
      if (v37 + 1 < v78)
      {
        uint64_t v38 = *(void *)(v77 + 8 * v39);
        if (v38)
        {
          ++v37;
          goto LABEL_19;
        }

        while (1)
        {
          char v37 = v39 + 1;
          if (__OFADD__(v39, 1LL)) {
            break;
          }
          if (v37 >= v78) {
            goto LABEL_54;
          }
          uint64_t v38 = *(void *)(v77 + 8 * v37);
          ++v39;
          if (v38) {
            goto LABEL_19;
          }
        }

        __break(1u);
        goto LABEL_56;
      }
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
  }

  char v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
  unint64_t result = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)&type metadata for Unicode.UTF16,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  if (result != v9) {
    goto LABEL_9;
  }
  uint64_t v11 = *a1;
  uint64_t v12 = (unsigned __int16)*a1;
  if (v12 <= 0x7F)
  {
    char v13 = (v11 + 1);
    goto LABEL_5;
  }

  uint64_t v14 = (*a1 & 0x3F) << 8;
  if (v12 < 0x800)
  {
    uint64_t v15 = v14 | (v12 >> 6);
LABEL_12:
    char v13 = v15 + 33217;
    goto LABEL_5;
  }

  if ((*a1 & 0xF800) != 0xD800)
  {
    char v13 = (((v14 | (v12 >> 6) & 0x3F) << 8) | ((unsigned __int16)v11 >> 12)) + 8487393;
    goto LABEL_5;
  }

      __asm { FCVT            H0, S0 }

      break;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      _H0 = v16;
      break;
  }

  *a2 = _H0;
}

  *a2 = v4;
  return result;
}

  uint64_t v5 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x635uLL,  0);
  }
  return result;
}

  uint64_t v7 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v7) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  return result;
}

  __break(1u);
  return result;
}

  uint64_t v5 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x117uLL,  0);
  }
  return result;
}

        v222 = v224;
        *(void *)v223 = 0x800000000LL;
        uint64_t v12 = *v11;
        if ((*v11 & 0x80) != 0)
        {
          if ((*v11 & 0x1F) - 17 >= 2)
          {
            if ((*v11 & 0x1F) != 0x10) {
              abort();
            }
            if ((v12 & 0x20000000) != 0)
            {
              ResilientImmediateMembersOffset = swift::getResilientImmediateMembersOffset( (uint64_t)v11,  (uint64_t)a2,  a3,  a4);
            }

            else
            {
              if ((v12 & 0x10000000) != 0)
              {
                unint64_t v77 = 0;
                int64_t v78 = v11 + 6;
              }

              else
              {
                unint64_t v77 = v11[7];
                int64_t v78 = v11 + 8;
              }

              ResilientImmediateMembersOffset = v77 - *v78;
            }
          }

          else
          {
            ResilientImmediateMembersOffset = 2;
          }

          if (!_buildDemanglingForGenericArgs( v11,  v5 + 8LL * ResilientImmediateMembersOffset,  (uint64_t)&v222,  a2))
          {
LABEL_266:
            Node = 0LL;
LABEL_267:
            if (v222 != v224) {
              free(v222);
            }
            return Node;
          }

          uint64_t v14 = (const char *)v222;
          char v13 = v223[0];
        }

        else
        {
          char v13 = 0LL;
          uint64_t v14 = v224;
        }

        Node = swift::_buildDemanglingForContext((uint64_t **)v11, v14, v13, a2);
        goto LABEL_267;
      }

  if ((swift::usesNativeSwiftReferenceCounting(v2) & 1) == 0)
  {
    a1 = v15;
    while ((*(_BYTE *)(v2 + 32) & 2) != 0)
    {
      uint64_t v2 = *(void *)(v2 + 8);
      uint64_t v14 = *(void *)v2;
      if (*(void *)v2 > 0x7FFuLL) {
        LODWORD(v14) = 0;
      }
      if ((_DWORD)v14)
      {
        if ((_DWORD)v14 == 773) {
          uint64_t v2 = *(void *)(v2 + 8);
        }
        else {
          uint64_t v2 = 0LL;
        }
      }
    }

    char v13 = (objc_class *)v2;
LABEL_42:
    object_setClass(a1, v13);
    a1 = v15;
    goto LABEL_43;
  }

  uint64_t v5 = (uint64_t)v15;
  unint64_t v6 = v15 + 1;
  uint64_t v7 = v15[1];
  id v8 = v7 - 0x200000000LL;
  if (v7 - 0x200000000LL >= 0)
  {
    while (1)
    {
      char v9 = __ldxr(v6);
      if (v9 != v7) {
        break;
      }
      if (__stlxr(v8, v6)) {
        goto LABEL_15;
      }
      uint64_t v10 = 1;
LABEL_16:
      if ((v10 & 1) != 0) {
        goto LABEL_20;
      }
      uint64_t v7 = v9;
      id v8 = v9 - 0x200000000LL;
      if (v9 - 0x200000000LL < 0)
      {
        if ((_DWORD)v9 != -1) {
          goto LABEL_19;
        }
        goto LABEL_20;
      }
    }

    __clrex();
LABEL_15:
    uint64_t v10 = 0;
    goto LABEL_16;
  }

  char v9 = v15[1];
  if ((_DWORD)v7 != -1)
  {
LABEL_19:
    swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)0>( v6,  v9,  1LL);
    uint64_t v5 = (uint64_t)v15;
  }

  uint64_t v11 = 0LL;
  return TrailingObjectsImpl + 4 * ((v3 >> 30) & 1) + 12LL * v4 + 4 * v6 + 4LL * ((v5 >> 19) & 1) + 4 * v11;
}

    char v13 = 1;
    if (v8 < a2) {
      goto LABEL_10;
    }
LABEL_31:
    switch(v13)
    {
      case 1u:
        *char v9 = 0;
        break;
      case 2u:
        *(_WORD *)char v9 = 0;
        break;
      case 3u:
        void v9[2] = 0;
        *(_WORD *)char v9 = 0;
        break;
      case 4u:
        *(_DWORD *)char v9 = 0;
        break;
      default:
        *(_DWORD *)char v9 = 0;
        bzero(v9 + 4, v13 - 4LL);
        break;
    }

    goto LABEL_37;
  }

  if (v8 < a2)
  {
    char v13 = 0;
    uint64_t v14 = ~v8 + a2;
    goto LABEL_13;
  }

    char v13 = 1;
    if (v8 < a2) {
      goto LABEL_10;
    }
LABEL_31:
    switch(v13)
    {
      case 1u:
        *char v9 = 0;
        break;
      case 2u:
        *(_WORD *)char v9 = 0;
        break;
      case 3u:
        void v9[2] = 0;
        *(_WORD *)char v9 = 0;
        break;
      case 4u:
        *(_DWORD *)char v9 = 0;
        break;
      default:
        *(_DWORD *)char v9 = 0;
        bzero(v9 + 4, v13 - 4LL);
        break;
    }

    goto LABEL_37;
  }

  if (v8 < a2)
  {
    char v13 = 0;
    uint64_t v14 = ~v8 + a2;
    goto LABEL_13;
  }

    char v13 = 1;
    if (v8 < a2) {
      goto LABEL_10;
    }
LABEL_31:
    switch(v13)
    {
      case 1u:
        *char v9 = 0;
        break;
      case 2u:
        *(_WORD *)char v9 = 0;
        break;
      case 3u:
        void v9[2] = 0;
        *(_WORD *)char v9 = 0;
        break;
      case 4u:
        *(_DWORD *)char v9 = 0;
        break;
      default:
        *(_DWORD *)char v9 = 0;
        bzero(v9 + 4, v13 - 4LL);
        break;
    }

    goto LABEL_37;
  }

  if (v8 < a2)
  {
    char v13 = 0;
    uint64_t v14 = ~v8 + a2;
    goto LABEL_13;
  }

    if (v17 == a6)
    {
      uint64_t v25 = v24;
      (*(void (**)(void *, void *))(*a6 + 24LL))(a6, v24);
    }

    else
    {
      uint64_t v25 = (void *)(*(uint64_t (**)(void *))(*v17 + 16LL))(v17);
    }

    if (v17 == a6)
    {
      uint64_t v25 = v24;
      (*(void (**)(void *, void *))(*a6 + 24LL))(a6, v24);
    }

    else
    {
      uint64_t v25 = (void *)(*(uint64_t (**)(void *))(*v17 + 16LL))(v17);
    }

  uint64_t v11 = 0LL;
LABEL_10:
  uint64_t v12 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::popFunctionParamLabels( this,  v11,  a3,  a4,  a5);
  uint64_t v17 = swift::Demangle::__runtime::Demangler::popContext(this, v13, v14, v15, v16);
  if (!v11) {
    return 0LL;
  }
  uint64_t v20 = v17;
  uint64_t v21 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v21 || v21 + 24 > *((void *)this + 2))
  {
    id v22 = 2LL * *((void *)this + 4);
    if (v22 <= 0x20) {
      id v22 = 32LL;
    }
    *((void *)this + 4) = v22;
    uint64_t v23 = v22 + 8;
    unint64_t v24 = malloc(v22 + 8);
    uint64_t v25 = (char *)v24 + v23;
    *unint64_t v24 = *((void *)this + 3);
    uint64_t v21 = ((unint64_t)v24 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = v25;
    *((void *)this + 3) = v24;
  }

  uint64_t v26 = 0LL;
  *((void *)this + 1) = v21 + 24;
  *(_WORD *)(v21 + 16) = 220;
  *(_BYTE *)(v21 + 18) = 0;
  if (v20 && v21)
  {
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v21, v20, this, v18, v19);
    if (v12) {
      swift::Demangle::__runtime::Node::addChild((unsigned int *)v21, v12, this, v27, v28);
    }
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v21, v11, this, v27, v28);
    if (v9) {
      swift::Demangle::__runtime::Node::addChild((unsigned int *)v21, v9, this, v18, v19);
    }
    uint64_t v26 = (swift::Demangle::__runtime::Node *)v21;
  }

  uint64_t v29 = setParentForOpaqueReturnTypeNodes(this, v26, v11, v18, v19);
  return swift::Demangle::__runtime::Demangler::demangleAccessor(this, v29, v30, v31, v32);
}

  uint64_t v10 = 0;
  if (v7 >= v8) {
    goto LABEL_13;
  }
LABEL_10:
  if (*(_BYTE *)(*((void *)a1 + 7) + v7) != 97)
  {
LABEL_13:
    uint64_t v11 = 0;
    if (v7 < v8) {
      goto LABEL_14;
    }
    return 0LL;
  }

  *((void *)a1 + 9) = ++v7;
  uint64_t v11 = 1;
  if (v7 >= v8) {
    return 0LL;
  }
LABEL_14:
  *((void *)a1 + 9) = v7 + 1;
  uint64_t v12 = *(char *)(*((void *)a1 + 7) + v7);
  char v13 = (*((void *)a1 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v13 || (uint64_t v14 = *((void *)a1 + 2), v13 + 24 > v14))
  {
    uint64_t v15 = 2LL * *((void *)a1 + 4);
    if (v15 <= 0x20) {
      uint64_t v15 = 32LL;
    }
    *((void *)a1 + 4) = v15;
    uint64_t v16 = v15 + 8;
    uint64_t v17 = malloc(v15 + 8);
    uint64_t v14 = (unint64_t)v17 + v16;
    *uint64_t v17 = *((void *)a1 + 3);
    char v13 = ((unint64_t)v17 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)a1 + 2) = v14;
    *((void *)a1 + 3) = v17;
  }

  uint64_t v18 = v13 + 24;
  *(_WORD *)(v13 + 16) = a2;
  *(_BYTE *)(v13 + 18) = 0;
  if (!v9)
  {
    if (!v10) {
      goto LABEL_28;
    }
LABEL_31:
    unint64_t v24 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    if (!v24 || v24 + 24 > *((void *)a1 + 2))
    {
      uint64_t v25 = 2LL * *((void *)a1 + 4);
      if (v25 <= 0x20) {
        uint64_t v25 = 32LL;
      }
      *((void *)a1 + 4) = v25;
      uint64_t v26 = v25 + 8;
      uint64_t v27 = malloc(v25 + 8);
      *uint64_t v27 = *((void *)a1 + 3);
      unint64_t v24 = ((unint64_t)v27 + 15) & 0xFFFFFFFFFFFFFFF8LL;
      *((void *)a1 + 2) = (char *)v27 + v26;
      *((void *)a1 + 3) = v27;
    }

    *((void *)a1 + 1) = v24 + 24;
    *(_WORD *)(v24 + 16) = 217;
    *(_BYTE *)(v24 + 18) = 0;
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v13, (swift::Demangle::__runtime::Node *)v24, a1, a4, a5);
    uint64_t v18 = *((void *)a1 + 1);
    uint64_t v23 = v12 - 48;
    if (!v11) {
      goto LABEL_43;
    }
    goto LABEL_37;
  }

  uint64_t v19 = (v13 + 31) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v19 || v19 + 24 > v14)
  {
    uint64_t v20 = 2LL * *((void *)a1 + 4);
    if (v20 <= 0x20) {
      uint64_t v20 = 32LL;
    }
    *((void *)a1 + 4) = v20;
    uint64_t v21 = v20 + 8;
    id v22 = malloc(v20 + 8);
    *id v22 = *((void *)a1 + 3);
    uint64_t v19 = ((unint64_t)v22 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)a1 + 2) = (char *)v22 + v21;
    *((void *)a1 + 3) = v22;
  }

  *((void *)a1 + 1) = v19 + 24;
  *(_WORD *)(v19 + 16) = 339;
  *(_BYTE *)(v19 + 18) = 0;
  swift::Demangle::__runtime::Node::addChild((unsigned int *)v13, (swift::Demangle::__runtime::Node *)v19, a1, a4, a5);
  uint64_t v18 = *((void *)a1 + 1);
  if (v10) {
    goto LABEL_31;
  }
LABEL_28:
  uint64_t v23 = v12 - 48;
  if (v11)
  {
LABEL_37:
    uint64_t v28 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    if (!v28 || v28 + 24 > *((void *)a1 + 2))
    {
      uint64_t v29 = 2LL * *((void *)a1 + 4);
      if (v29 <= 0x20) {
        uint64_t v29 = 32LL;
      }
      *((void *)a1 + 4) = v29;
      uint64_t v30 = v29 + 8;
      uint64_t v31 = malloc(v29 + 8);
      *uint64_t v31 = *((void *)a1 + 3);
      uint64_t v28 = ((unint64_t)v31 + 15) & 0xFFFFFFFFFFFFFFF8LL;
      *((void *)a1 + 2) = (char *)v31 + v30;
      *((void *)a1 + 3) = v31;
    }

    *((void *)a1 + 1) = v28 + 24;
    *(_WORD *)(v28 + 16) = 346;
    *(_BYTE *)(v28 + 18) = 0;
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v13, (swift::Demangle::__runtime::Node *)v28, a1, a4, a5);
    uint64_t v18 = *((void *)a1 + 1);
  }

            std::string::append(this, "]", 1uLL);
LABEL_10:
            continue;
          case 6:
          case 7:
          case 8:
            if ((_DWORD)v12 == 1) {
              goto LABEL_19;
            }
            if ((_DWORD)v12 != 5) {
              goto LABEL_17;
            }
            goto LABEL_41;
          case 9:
            std::string::append(this, v9, 1uLL);
            uint64_t v33 = *((unsigned __int8 *)a2 + 18);
            char v34 = v33 - 1;
            switch((_DWORD)v33)
            {
              case 1:
                goto LABEL_64;
              case 5:
                break;
              case 2:
                uint64_t v33 = 2LL;
LABEL_64:
                if (v33 <= v7)
                {
LABEL_131:
                  char v36 = 0LL;
                  goto LABEL_132;
                }

                break;
              default:
                goto LABEL_131;
            }

            uint64_t v35 = a2;
            if (v34 >= 2) {
              uint64_t v35 = *(swift::Demangle::__runtime::Node **)a2;
            }
            char v36 = (swift::Demangle::__runtime::Node *)*((void *)v35 + v7);
LABEL_132:
            std::string::append(this, v10, 3uLL);
            id v69 = *((unsigned __int8 *)a2 + 18);
            if (v69 == 2)
            {
              uint64_t v70 = *((unsigned __int8 *)a2 + 18);
            }

            else
            {
              if (v69 != 5) {
                goto LABEL_140;
              }
              uint64_t v70 = *((unsigned int *)a2 + 2);
            }

            char v71 = (v7 + 1);
            if (v70 > v71)
            {
              char v72 = v69 - 1;
              int v73 = a2;
              if (v72 >= 2) {
                int v73 = *(swift::Demangle::__runtime::Node **)a2;
              }
              uint64_t v74 = (swift::Demangle::__runtime::Node *)*((void *)v73 + v71);
LABEL_141:
              std::string::append(this, "<", 1uLL);
              uint64_t v75 = *((unsigned __int8 *)a2 + 18);
              uint64_t v76 = v75 - 1;
              if ((_DWORD)v75 != 1)
              {
                if ((_DWORD)v75 == 5)
                {
                  uint64_t v75 = *((unsigned int *)a2 + 2);
                }

                else
                {
                  if ((_DWORD)v75 != 2) {
                    goto LABEL_168;
                  }
                  uint64_t v75 = 2LL;
                }
              }

              unint64_t v84 = (v7 + 2);
              if (v75 > v84)
              {
                uint64_t v85 = a2;
                if (v76 >= 2) {
                  uint64_t v85 = *(swift::Demangle::__runtime::Node **)a2;
                }
                uint64_t v86 = (swift::Demangle::__runtime::Node *)*((void *)v85 + v84);
LABEL_169:
                std::string::append(this, ",", 1uLL);
                uint64_t v87 = *((unsigned __int8 *)a2 + 18);
                v88 = v87 - 1;
                if ((_DWORD)v87 != 1)
                {
                  if ((_DWORD)v87 == 5)
                  {
                    uint64_t v87 = *((unsigned int *)a2 + 2);
                  }

                  else
                  {
                    if ((_DWORD)v87 != 2) {
                      goto LABEL_178;
                    }
                    uint64_t v87 = 2LL;
                  }
                }

                v89 = (v7 + 3);
                if (v87 > v89)
                {
                  uint64_t v90 = a2;
                  if (v88 >= 2) {
                    uint64_t v90 = *(swift::Demangle::__runtime::Node **)a2;
                  }
                  uint64_t v91 = (swift::Demangle::__runtime::Node *)*((void *)v90 + v89);
                  goto LABEL_179;
                }

  if (*((_DWORD *)v4 + 2) <= 2u) {
    goto LABEL_12;
  }
  if (*(_DWORD *)a4) {
    return result;
  }
LABEL_13:
  unint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "fU", 2uLL, this[1593]);
  uint64_t v11 = *((unsigned __int8 *)v4 + 18);
  if (v11 == 2) {
  if (v11 == 5 && *((_DWORD *)v4 + 2) >= 2u)
  }
  {
    uint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  if (v8 == 5 && *((_DWORD *)v4 + 2) >= 2u)
  {
    uint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
    goto LABEL_12;
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_15:
  unint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "XP", 2uLL, this[1593]);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  if (*((_DWORD *)v4 + 2) <= 2u) {
    goto LABEL_12;
  }
  if (*(_DWORD *)a4) {
    return result;
  }
LABEL_13:
  unint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "fu", 2uLL, this[1593]);
  uint64_t v11 = *((unsigned __int8 *)v4 + 18);
  if (v11 == 2) {
  if (v11 == 5 && *((_DWORD *)v4 + 2) >= 2u)
  }
  {
    uint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

uint64_t Dictionary._Variant.contains(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      return v9 & 1;
    }

void *Dictionary.index(forKey:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v30 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if ((v31 & 1) != 0) {
        return (void *)v30;
      }
    }

    return 0LL;
  }

  unint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v8 = objc_msgSend(v7, sel_objectForKey_, v6);
  if (!v8)
  {
    swift_unknownObjectRelease(v6);
    return 0LL;
  }

  swift_unknownObjectRelease(v8);
  unint64_t v12 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v7, v9, v10, v11), sel_count);
  unint64_t v13 = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v12 - 0x1000000000000000LL) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_19;
  }

  if (__OFADD__(8 * v12, 24LL))
  {
LABEL_19:
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v14 = swift_bufferAllocate(v13, 8 * v12 + 24, 7uLL);
  v14[2] = v12;
  objc_msgSend(v7, sel_getObjects_andKeys_count_, 0, v14 + 3, v12);
  swift_bridgeObjectRelease(a2);
  if ((v14[2] & 0x8000000000000000LL) != 0) {
    goto LABEL_20;
  }
  swift_unknownObjectRetain(v14, v15, v16, v17);
  uint64_t v21 = 0LL;
  do
  {
    uint64_t v22 = v21 + 1;
    uint64_t v23 = (void *)v14[v21 + 3];
    swift_unknownObjectRetain(v23, v18, v19, v20);
    char isEqual = swift_stdlib_NSObject_isEqual(v6, v23);
    swift_unknownObjectRelease(v23);
    uint64_t v21 = v22;
  }

  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v14);
  uint64_t v25 = type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t v26 = swift_allocObject(v25, 0x20uLL, 7uLL);
  v26[2] = v7;
  v26[3] = v14;
  swift_unknownObjectRetain(v7, v27, v28, v29);
  swift_unknownObjectRelease(v6);
  return v26;
}

uint64_t Optional.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a2 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 32))(a3, a1, a2);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v5 + 56))(a3, 0LL, 1LL, a2);
}

void *Dictionary.Keys._customLastIndexOfEquatableElement(_:)( id *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v30 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if ((v31 & 1) != 0) {
        return (void *)v30;
      }
    }

    return 0LL;
  }

  unint64_t v6 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v7 = (void *)a2;
  }
  else {
    uint64_t v7 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v8 = objc_msgSend(v7, sel_objectForKey_, v6);
  if (!v8)
  {
    swift_unknownObjectRelease(v6);
    return 0LL;
  }

  swift_unknownObjectRelease(v8);
  unint64_t v12 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v7, v9, v10, v11), sel_count);
  unint64_t v13 = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v12 - 0x1000000000000000LL) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_19;
  }

  if (__OFADD__(8 * v12, 24LL))
  {
LABEL_19:
    __break(1u);
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v14 = swift_bufferAllocate(v13, 8 * v12 + 24, 7uLL);
  v14[2] = v12;
  objc_msgSend(v7, sel_getObjects_andKeys_count_, 0, v14 + 3, v12);
  swift_bridgeObjectRelease(a2);
  if ((v14[2] & 0x8000000000000000LL) != 0) {
    goto LABEL_20;
  }
  swift_unknownObjectRetain(v14, v15, v16, v17);
  uint64_t v21 = 0LL;
  do
  {
    uint64_t v22 = v21 + 1;
    uint64_t v23 = (void *)v14[v21 + 3];
    swift_unknownObjectRetain(v23, v18, v19, v20);
    char isEqual = swift_stdlib_NSObject_isEqual(v6, v23);
    swift_unknownObjectRelease(v23);
    uint64_t v21 = v22;
  }

  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v14);
  uint64_t v25 = type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t v26 = swift_allocObject(v25, 0x20uLL, 7uLL);
  v26[2] = v7;
  v26[3] = v14;
  swift_unknownObjectRetain(v7, v27, v28, v29);
  swift_unknownObjectRelease(v6);
  return v26;
}

uint64_t static Dictionary.Keys.== infix(_:_:)( int64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v94 = a5;
  uint64_t v8 = *((void *)a3 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (id *)((char *)&v81 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v95 = v10;
  MEMORY[0x1895F8858](v9);
  unint64_t v13 = (id *)((char *)&v81 - v12);
  uint64_t v16 = type metadata accessor for Optional(0LL, v14, v14, v15);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v27 = (char *)&v81 - v26;
  unint64_t v98 = a2 & 0xC000000000000001LL;
  unint64_t v28 = a1 & 0xC000000000000001LL;
  if ((a1 & 0xC000000000000001LL) == 0 && !v98 && a1 == a2) {
    return 1LL;
  }
  if (!v28)
  {
    uint64_t v85 = v11;
    uint64_t v86 = v25;
    uint64_t v82 = v24;
    uint64_t v83 = v23;
    uint64_t v84 = v19;
    id v33 = *(id *)(a1 + 16);
    if (v98) {
      goto LABEL_22;
    }
LABEL_15:
    if (v33 == *(id *)(a2 + 16)) {
      goto LABEL_26;
    }
    return 0LL;
  }

  if (v98)
  {
    uint64_t v30 = a1 & 0xFFFFFFFFFFFFFF8LL;
    if (a1 < 0) {
      uint64_t v31 = a1;
    }
    else {
      uint64_t v31 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v32 = a2 & 0xFFFFFFFFFFFFFF8LL;
    if (a2 < 0) {
      uint64_t v32 = a2;
    }
    if (v31 == v32) {
      return 1LL;
    }
  }

  else
  {
    uint64_t v30 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }

  uint64_t v85 = v11;
  uint64_t v86 = v25;
  uint64_t v82 = v24;
  uint64_t v83 = v23;
  uint64_t v84 = v19;
  if (a1 < 0) {
    char v34 = (void *)a1;
  }
  else {
    char v34 = (void *)v30;
  }
  id v33 = objc_msgSend(v34, sel_count);
  if (!v98) {
    goto LABEL_15;
  }
LABEL_22:
  if (a2 < 0) {
    uint64_t v35 = (void *)a2;
  }
  else {
    uint64_t v35 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  if (v33 != objc_msgSend(v35, sel_count)) {
    return 0LL;
  }
LABEL_26:
  if (v28)
  {
    if (a1 < 0) {
      uint64_t v36 = a1;
    }
    else {
      uint64_t v36 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v37 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v38 = (unint64_t)swift_allocObject(v37, 0xE8uLL, 7uLL);
    int64_t v92 = 0LL;
    uint64_t v39 = 0LL;
    unint64_t v40 = 0LL;
    *(void *)(v38 + 208) = v36;
    *(void *)(v38 + 216) = 0LL;
    *(_OWORD *)(v38 + 16) = 0u;
    *(_OWORD *)(v38 + 32) = 0u;
    *(_OWORD *)(v38 + 48) = 0u;
    *(_OWORD *)(v38 + 64) = 0u;
    *(_OWORD *)(v38 + 80) = 0u;
    *(_OWORD *)(v38 + 96) = 0u;
    *(_OWORD *)(v38 + 112) = 0u;
    *(_OWORD *)(v38 + 128) = 0u;
    *(_OWORD *)(v38 + 144) = 0u;
    *(_OWORD *)(v38 + 160) = 0u;
    *(_OWORD *)(v38 + 176) = 0u;
    *(_OWORD *)(v38 + 192) = 0u;
    *(void *)(v38 + 224) = 0LL;
    unint64_t v41 = v38 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v42 = -1LL << *(_BYTE *)(a1 + 32);
    uint64_t v39 = ~v42;
    uint64_t v43 = *(void *)(a1 + 64);
    int64_t v92 = a1 + 64;
    uint64_t v44 = -v42;
    if (v44 < 64) {
      uint64_t v45 = ~(-1LL << v44);
    }
    else {
      uint64_t v45 = -1LL;
    }
    unint64_t v40 = v45 & v43;
    unint64_t v41 = a1;
  }

  uint64_t v90 = v41 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v87 = (v41 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v88 = (v41 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v81 = v39;
  int64_t v91 = (unint64_t)(v39 + 64) >> 6;
  unint64_t v46 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  if (a2 < 0) {
    unint64_t v46 = (void *)a2;
  }
  id v93 = v46;
  swift_bridgeObjectRetain(a1, v20, v21, v22);
  int64_t v50 = 0LL;
  v89 = (swift *)&unk_189B8D230;
  unint64_t v96 = v41;
  while (1)
  {
    unint64_t v51 = v40;
    int64_t v97 = v50;
    if ((v41 & 0x8000000000000000LL) == 0)
    {
      if (v40)
      {
        unint64_t v52 = __clz(__rbit64(v40));
        v40 &= v40 - 1;
        unint64_t v53 = v52 | (v50 << 6);
      }

      else
      {
        int64_t v61 = v50 + 1;
        if (__OFADD__(v50, 1LL))
        {
          __break(1u);
LABEL_90:
          __break(1u);
LABEL_91:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x305uLL,  0);
        }

        if (v61 >= v91) {
          goto LABEL_85;
        }
        unint64_t v62 = *(void *)(v92 + 8 * v61);
        ++v50;
        if (!v62)
        {
          int64_t v50 = v61 + 1;
          if (v61 + 1 >= v91) {
            goto LABEL_85;
          }
          unint64_t v62 = *(void *)(v92 + 8 * v50);
          if (!v62)
          {
            int64_t v50 = v61 + 2;
            if (v61 + 2 >= v91) {
              goto LABEL_85;
            }
            unint64_t v62 = *(void *)(v92 + 8 * v50);
            if (!v62)
            {
              int64_t v63 = v61 + 3;
              if (v63 >= v91) {
                goto LABEL_85;
              }
              unint64_t v62 = *(void *)(v92 + 8 * v63);
              if (!v62)
              {
                while (1)
                {
                  int64_t v50 = v63 + 1;
                  if (__OFADD__(v63, 1LL)) {
                    goto LABEL_90;
                  }
                  if (v50 >= v91) {
                    goto LABEL_85;
                  }
                  unint64_t v62 = *(void *)(v92 + 8 * v50);
                  ++v63;
                  if (v62) {
                    goto LABEL_64;
                  }
                }
              }

              int64_t v50 = v63;
            }
          }
        }

BOOL === infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == a2;
  if (!a2) {
    BOOL v2 = a1 == 0;
  }
  if (a1) {
    return v2;
  }
  else {
    return a2 == 0;
  }
}

id Dictionary._Variant.asCocoa.getter(uint64_t a1)
{
  uint64_t v1 = (void *)specialized _ArrayBuffer._nonNative.getter(a1);
  return swift_unknownObjectRetain(v1, v2, v3, v4);
}

int64_t Dictionary.Keys.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001LL) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v4 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0LL;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0LL;
    unint64_t result = v5 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v9 = -1LL;
    uint64_t v10 = -1LL << *(_BYTE *)(result + 32);
    int64_t v6 = result + 64;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1LL << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 64);
  }

  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0LL;
  a2[4] = v8;
  return result;
}

uint64_t Dictionary.Keys.Iterator.next()@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v7 = *v5;
  if (*v5 < 0)
  {
    uint64_t v17 = *(char **)(result + 16);
    id v18 = __CocoaDictionary.Iterator.nextKey()(result, a2, a3, a4);
    if (v18)
    {
      uint64_t v20 = v18;
      _forceBridgeFromObjectiveC<A>(_:_:)(v18, v17, v19, a5);
      swift_unknownObjectRelease(v20);
      uint64_t v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v17 - 1) + 56LL);
      uint64_t v22 = a5;
      uint64_t v23 = 0LL;
    }

    else
    {
      uint64_t v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v17 - 1) + 56LL);
      uint64_t v22 = a5;
      uint64_t v23 = 1LL;
    }

    return v21(v22, v23, 1LL, v17);
  }

  else
  {
    uint64_t v8 = v5[1];
    uint64_t v9 = v5[2];
    int64_t v11 = v5[3];
    unint64_t v10 = v5[4];
    if (v10)
    {
      uint64_t v12 = (v10 - 1) & v10;
      unint64_t v13 = __clz(__rbit64(v10)) | (v11 << 6);
LABEL_4:
      uint64_t v14 = *(void *)(result + 16);
      uint64_t v15 = *(void *)(v14 - 8);
      (*(void (**)(char *, unint64_t, uint64_t))(v15 + 16))( a5,  *(void *)(v7 + 48) + *(void *)(v15 + 72) * v13,  v14);
      unint64_t result = (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(a5, 0LL, 1LL, v14);
      int64_t v16 = v11;
LABEL_23:
      *unint64_t v5 = v7;
      v5[1] = v8;
      v5[2] = v9;
      v5[3] = v16;
      v5[4] = v12;
      return result;
    }

    int64_t v24 = v11 + 1;
    if (!__OFADD__(v11, 1LL))
    {
      int64_t v25 = (unint64_t)(v9 + 64) >> 6;
      int64_t v16 = v5[3];
      if (v24 < v25)
      {
        unint64_t v26 = *(void *)(v8 + 8 * v24);
        if (v26)
        {
LABEL_10:
          uint64_t v12 = (v26 - 1) & v26;
          unint64_t v13 = __clz(__rbit64(v26)) + (v24 << 6);
          int64_t v11 = v24;
          goto LABEL_4;
        }

        int64_t v16 = v11 + 1;
        if (v11 + 2 < v25)
        {
          unint64_t v26 = *(void *)(v8 + 8 * (v11 + 2));
          if (v26)
          {
            int64_t v24 = v11 + 2;
            goto LABEL_10;
          }

          int64_t v24 = v11 + 3;
          int64_t v16 = v11 + 2;
          if (v11 + 3 < v25)
          {
            unint64_t v26 = *(void *)(v8 + 8 * v24);
            if (v26) {
              goto LABEL_10;
            }
            int64_t v16 = v25 - 1;
            int64_t v27 = v11 + 4;
            while (v25 != v27)
            {
              unint64_t v26 = *(void *)(v8 + 8 * v27++);
              if (v26)
              {
                int64_t v24 = v27 - 1;
                goto LABEL_10;
              }
            }
          }
        }
      }

      unint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(result + 16) - 8LL) + 56LL))( a5,  1LL,  1LL);
      uint64_t v12 = 0LL;
      goto LABEL_23;
    }

    __break(1u);
  }

  return result;
}

BOOL Sequence<>.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(a3 + 48))();
  if (v8 == 2)
  {
    MEMORY[0x1895F8858](v8);
    v11[2] = a2;
    v11[3] = a3;
    v11[4] = a4;
    uint64_t v11[5] = a1;
    return Sequence.contains(where:)( (uint64_t (*)(char *))partial apply for closure #1 in Sequence<>.contains(_:),  (uint64_t)v11,  a2,  (const char *)a3);
  }

  else
  {
    return v8 & 1;
  }

uint64_t (*Dictionary.Keys.subscript.read( char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8))()
{
  uint64_t v14 = *((void *)a6 - 1);
  *a1 = a6;
  a1[1] = (char *)v14;
  uint64_t v15 = (char *)malloc(*(void *)(v14 + 64));
  a1[2] = v15;
  Dictionary.Keys.subscript.getter(a2, a3, a5, a6, a8, v15);
  return _ArrayBuffer.subscript.read;
}

uint64_t (*Dictionary.Values._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t Dictionary.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0)
  {
    unint64_t v14 = *(void *)(a1 + 64);
    if (v14)
    {
      uint64_t v15 = 0LL;
      return __clz(__rbit64(v14)) + v15;
    }

    else
    {
      uint64_t v15 = 0LL;
      unint64_t v10 = (void *)(1LL << *(_BYTE *)(a1 + 32));
      unint64_t v16 = (((unint64_t)v10 + 63) >> 6) - 1;
      uint64_t v17 = (unint64_t *)(a1 + 72);
      while (v16)
      {
        unint64_t v18 = *v17++;
        unint64_t v14 = v18;
        --v16;
        v15 += 64LL;
        if (v18) {
          return __clz(__rbit64(v14)) + v15;
        }
      }
    }

    return (unint64_t)v10;
  }

  if (a1 < 0) {
    unint64_t v5 = (void *)a1;
  }
  else {
    unint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      uint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_andKeys_count_, 0, v8 + 3, v6);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaDictionary.Index.Storage();
      unint64_t v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

void Dictionary.formIndex(after:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 16);
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    Swift::Int v21 = _NativeDictionary.index(after:)(*(void *)a1, v9, v10, a2, a3, a6, a5);
    uint64_t v19 = v22;
    char v20 = v23 & 1;
    outlined consume of [A : B].Index._Variant<A, B>(v8, v9, v10);
    *(void *)a1 = v21;
    goto LABEL_20;
  }

  if ((v10 & 1) == 0)
  {
    unint64_t v24 = 1850LL;
    goto LABEL_26;
  }

  if (v8 >= 0) {
    uint64_t v11 = v8 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v11 = *(void *)a1;
  }
  uint64_t v12 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v8, v13, v14, v15);
  if (!swift_dynamicCastClass(v11, v12)) {
LABEL_23:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  outlined consume of [A : B].Index._Variant<A, B>(v8, v9, 1);
  if (v11) {
    swift_isUniquelyReferenced_nonNull_native(v11);
  }
  if (*(_BYTE *)(a1 + 16) != 1)
  {
    unint64_t v24 = 1858LL;
LABEL_26:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  v24,  0);
  }

  uint64_t v16 = *(void *)(a1 + 8);
  else {
    uint64_t v17 = *(void *)a1;
  }
  if (!swift_dynamicCastClass(v17, v12)) {
    goto LABEL_23;
  }
  uint64_t v18 = a2 & 0xFFFFFFFFFFFFFF8LL;
  if (a2 < 0) {
    uint64_t v18 = a2;
  }
  if (*(void *)(v17 + 16) != v18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E7uLL,  0);
  }
  if (v16 >= *(void *)(*(void *)(v17 + 24) + 16LL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E8uLL,  0);
  }
  uint64_t v19 = v16 + 1;
  char v20 = 1;
LABEL_20:
  *(void *)(a1 + 8) = v19;
  *(_BYTE *)(a1 + 16) = v20;
}

void Dictionary.Values.subscript.getter( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, char *a5@<X5>, uint64_t a6@<X6>, char *a7@<X8>)
{
  uint64_t v12 = a1;
  uint64_t v14 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v17 = (char *)&v40 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v18 & 0xC000000000000001LL) == 0)
  {
    if ((v15 & 1) != 0)
    {
      unint64_t v41 = a7;
      if (v12 >= 0) {
        uint64_t v27 = v12 & 0xFFFFFFFFFFFFFF8LL;
      }
      else {
        uint64_t v27 = v12;
      }
      uint64_t v28 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(v12, v29, v30, v31);
      if (!swift_dynamicCastClass(v27, v28)) {
        goto LABEL_31;
      }
      if (!swift_dynamicCastClass(v27, v28)) {
        goto LABEL_31;
      }
      uint64_t v35 = *(void *)(v27 + 24);
      if (*(void *)(v35 + 16) <= a2) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
      }
      uint64_t v36 = *(void **)(v35 + 8 * a2 + 24);
      swift_unknownObjectRetain(v36, v32, v33, v34);
      outlined consume of [A : B].Index._Variant<A, B>(v12, a2, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v36, a4, v37, v17);
      swift_unknownObjectRelease(v36);
      uint64_t v12 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v17, (uint64_t)a4, a6);
      char v39 = v38;
      (*(void (**)(char *, char *))(v14 + 8))(v17, a4);
      if ((v39 & 1) == 0)
      {
LABEL_34:
        unint64_t v26 = 303LL;
LABEL_18:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v26,  0);
      }

      a7 = v41;
    }

    else if (v12 < 0 {
           || 1LL << *(_BYTE *)(a3 + 32) <= v12
    }
           || ((*(void *)(a3 + (((unint64_t)v12 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> v12) & 1) == 0
           || *(_DWORD *)(a3 + 36) != (_DWORD)a2)
    {
      unint64_t v26 = 281LL;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, char *))(*((void *)a5 - 1) + 16LL))( a7,  *(void *)(a3 + 56) + *(void *)(*((void *)a5 - 1) + 72LL) * v12,  a5);
    return;
  }

  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v15 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  if (v12 >= 0) {
    v12 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  uint64_t v19 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v12, v19)) {
    goto LABEL_31;
  }
  if (*(void *)(v12 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x22CuLL,  0);
  }
  char v23 = *(void **)(*(void *)(v12 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v23, v20, v21, v22);
  if (!swift_dynamicCastClass(v12, v19)) {
LABEL_31:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  id v24 = objc_msgSend((id)a3, sel_objectForKey_, v23);
  swift_unknownObjectRelease(v23);
  if (!v24) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x22EuLL,  0);
  }
  _forceBridgeFromObjectiveC<A>(_:_:)(v24, a5, v25, a7);
  swift_unknownObjectRelease(v24);
}

void (*Dictionary.Values.subscript.modify( char **a1, uint64_t a2, uint64_t a3, char a4, void *a5))(void **a1)
{
  unint64_t v6 = (unint64_t *)v5;
  uint64_t v12 = (char *)a5[2];
  uint64_t v53 = *((void *)v12 - 1);
  uint64_t v16 = (char *)malloc(*(void *)(v53 + 64));
  *a1 = v16;
  uint64_t v17 = *v5;
  uint64_t v18 = (uint64_t *)a5[3];
  if ((*v5 & 0xC000000000000001LL) == 0)
  {
    if (!swift_isUniquelyReferenced_nonNull_native(v17))
    {
      uint64_t v54 = *v5;
      *unint64_t v5 = 0x8000000000000000LL;
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v12, (uint64_t)v18, a5[4]);
      _NativeDictionary.copy()();
      uint64_t v32 = *v5;
      *unint64_t v5 = v54;
      swift_bridgeObjectRelease(v32);
    }

    uint64_t v20 = (__objc2_class **)*v5;
    swift_bridgeObjectRetain(*v6, v29, v30, v31);
    if ((a4 & 1) == 0) {
      goto LABEL_6;
    }
LABEL_15:
    if (a2 >= 0) {
      uint64_t v33 = a2 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v33 = a2;
    }
    uint64_t v34 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a2, v35, v36, v37);
    if (swift_dynamicCastClass(v33, v34))
    {
      if (*((_DWORD *)v20 + 9) != specialized static Hasher._hash(seed:_:)(0LL, *(void *)(v33 + 16)))
      {
        swift_retain((unint64_t *)v20, v38, v39, v40);
        goto LABEL_28;
      }

      if (swift_dynamicCastClass(v33, v34))
      {
        uint64_t v44 = *(void *)(v33 + 24);
        if (*(void *)(v44 + 16) <= a3) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        uint64_t v45 = *(void **)(v44 + 8 * a3 + 24);
        swift_retain((unint64_t *)v20, v41, v42, v43);
        swift_unknownObjectRetain(v45, v46, v47, v48);
        outlined consume of [A : B].Index._Variant<A, B>(a2, a3, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v45, v12, v49, v16);
        swift_unknownObjectRelease(v45);
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v16, (uint64_t)v12, a5[4]);
        char v51 = v50;
        swift_release((uint64_t)v20);
        (*(void (**)(char *, char *))(v53 + 8))(v16, v12);
        if ((v51 & 1) != 0) {
          goto LABEL_23;
        }
LABEL_28:
        unint64_t v28 = 303LL;
LABEL_11:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v28,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if (v17 < 0) {
    uint64_t v19 = (void *)*v5;
  }
  else {
    uint64_t v19 = (void *)(v17 & 0xFFFFFFFFFFFFFF8LL);
  }
  swift_bridgeObjectRetain(v17, v13, v14, v15);
  uint64_t v20 = _NativeDictionary.init(_:capacity:)(v19, (uint64_t)objc_msgSend(v19, sel_count), v12, v18, a5[4]);
  uint64_t v21 = *v6;
  *unint64_t v6 = (unint64_t)v20;
  swift_retain((unint64_t *)v20, v22, v23, v24);
  swift_bridgeObjectRelease(v21);
  if ((a4 & 1) != 0) {
    goto LABEL_15;
  }
LABEL_6:
  if (a2 < 0 || 1LL << *((_BYTE *)v20 + 32) <= a2)
  {
    swift_retain((unint64_t *)v20, v25, v26, v27);
LABEL_10:
    unint64_t v28 = 281LL;
    goto LABEL_11;
  }

  if (((*(unint64_t *)((char *)v20 + (((unint64_t)a2 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> a2) & 1) == 0
    || *((_DWORD *)v20 + 9) != (_DWORD)a3)
  {
    goto LABEL_10;
  }

void Dictionary.Values.subscript.modify(void **a1)
{
}

void Dictionary._Variant.value(at:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, char *a5@<X5>, uint64_t a6@<X6>, char *a7@<X8>)
{
  uint64_t v12 = a1;
  uint64_t v14 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v17 = (char *)&v40 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v18 & 0xC000000000000001LL) == 0)
  {
    if ((v15 & 1) != 0)
    {
      uint64_t v41 = a7;
      if (v12 >= 0) {
        uint64_t v27 = v12 & 0xFFFFFFFFFFFFFF8LL;
      }
      else {
        uint64_t v27 = v12;
      }
      uint64_t v28 = type metadata accessor for __CocoaDictionary.Index.Storage();
      swift_bridgeObjectRetain(v12, v29, v30, v31);
      if (!swift_dynamicCastClass(v27, v28)) {
        goto LABEL_31;
      }
      if (!swift_dynamicCastClass(v27, v28)) {
        goto LABEL_31;
      }
      uint64_t v35 = *(void *)(v27 + 24);
      if (*(void *)(v35 + 16) <= a2) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
      }
      uint64_t v36 = *(void **)(v35 + 8 * a2 + 24);
      swift_unknownObjectRetain(v36, v32, v33, v34);
      outlined consume of [A : B].Index._Variant<A, B>(v12, a2, 1);
      _forceBridgeFromObjectiveC<A>(_:_:)(v36, a4, v37, v17);
      swift_unknownObjectRelease(v36);
      uint64_t v12 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v17, (uint64_t)a4, a6);
      char v39 = v38;
      (*(void (**)(char *, char *))(v14 + 8))(v17, a4);
      if ((v39 & 1) == 0)
      {
LABEL_34:
        unint64_t v26 = 303LL;
LABEL_18:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v26,  0);
      }

      a7 = v41;
    }

    else if (v12 < 0 {
           || 1LL << *(_BYTE *)(a3 + 32) <= v12
    }
           || ((*(void *)(a3 + (((unint64_t)v12 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> v12) & 1) == 0
           || *(_DWORD *)(a3 + 36) != (_DWORD)a2)
    {
      unint64_t v26 = 281LL;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, char *))(*((void *)a5 - 1) + 16LL))( a7,  *(void *)(a3 + 56) + *(void *)(*((void *)a5 - 1) + 72LL) * v12,  a5);
    return;
  }

  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((v15 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  if (v12 >= 0) {
    v12 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  uint64_t v19 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v12, v19)) {
    goto LABEL_31;
  }
  if (*(void *)(v12 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x22CuLL,  0);
  }
  uint64_t v23 = *(void **)(*(void *)(v12 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v23, v20, v21, v22);
  if (!swift_dynamicCastClass(v12, v19)) {
LABEL_31:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  id v24 = objc_msgSend((id)a3, sel_objectForKey_, v23);
  swift_unknownObjectRelease(v23);
  if (!v24) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x22EuLL,  0);
  }
  _forceBridgeFromObjectiveC<A>(_:_:)(v24, a5, v25, a7);
  swift_unknownObjectRelease(v24);
}

unint64_t *Dictionary._Variant.ensureUniqueNative()(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = (unint64_t *)v4;
  uint64_t v7 = *v4;
  uint64_t v8 = (char *)a1[2];
  uint64_t v9 = (uint64_t *)a1[3];
  if ((v7 & 0xC000000000000001LL) != 0)
  {
    if (v7 < 0) {
      uint64_t v10 = (void *)v7;
    }
    else {
      uint64_t v10 = (void *)(v7 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(v7, a2, a3, a4);
    uint64_t v11 = (unint64_t *)_NativeDictionary.init(_:capacity:)( v10,  (uint64_t)objc_msgSend(v10, sel_count),  v8,  v9,  a1[4]);
    uint64_t v12 = *v5;
    *unint64_t v5 = (unint64_t)v11;
    swift_retain(v11, v13, v14, v15);
    swift_bridgeObjectRelease(v12);
  }

  else
  {
    if (!swift_isUniquelyReferenced_nonNull_native(v7))
    {
      unint64_t v21 = *v5;
      *unint64_t v5 = 0x8000000000000000LL;
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v8, (uint64_t)v9, a1[4]);
      _NativeDictionary.copy()();
      uint64_t v19 = *v5;
      *unint64_t v5 = v21;
      swift_bridgeObjectRelease(v19);
    }

    uint64_t v11 = (unint64_t *)*v5;
    swift_bridgeObjectRetain(*v5, v16, v17, v18);
  }

  return v11;
}

uint64_t _NativeDictionary.validatedBucket(for:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a1;
  uint64_t v12 = *((void *)a5 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v15 & 1) != 0)
  {
    if (v11 >= 0) {
      uint64_t v17 = v11 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v17 = v11;
    }
    uint64_t v18 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v11, v19, v20, v21);
    if (swift_dynamicCastClass(v17, v18))
    {
      if (swift_dynamicCastClass(v17, v18))
      {
        uint64_t v25 = *(void *)(v17 + 24);
        if (*(void *)(v25 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        unint64_t v26 = *(void **)(v25 + 8 * a2 + 24);
        swift_unknownObjectRetain(v26, v22, v23, v24);
        outlined consume of [A : B].Index._Variant<A, B>(v11, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v26, a5, v27, v14);
        swift_unknownObjectRelease(v26);
        uint64_t v11 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, (uint64_t)a5, a7);
        char v29 = v28;
        (*(void (**)(char *, char *))(v12 + 8))(v14, a5);
        if ((v29 & 1) != 0) {
          return v11;
        }
LABEL_19:
        unint64_t v16 = 303LL;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v16,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if (v11 < 0
    || 1LL << *(_BYTE *)(a4 + 32) <= v11
    || ((*(void *)(a4 + (((unint64_t)v11 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> v11) & 1) == 0
    || *(_DWORD *)(a4 + 36) != (_DWORD)a2)
  {
    unint64_t v16 = 281LL;
    goto LABEL_7;
  }

  return v11;
}

void Dictionary.Values.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  unint64_t v6 = (unint64_t *)v5;
  int v57 = a4;
  uint64_t v56 = a1;
  uint64_t v10 = *(char **)(a5 + 16);
  uint64_t v11 = *((void *)v10 - 1);
  MEMORY[0x1895F8858](a1);
  unint64_t v16 = (char *)&v55 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *v5;
  uint64_t v19 = *(uint64_t **)(v18 + 24);
  if ((*v5 & 0xC000000000000001LL) != 0)
  {
    if (v17 < 0) {
      uint64_t v20 = (void *)*v5;
    }
    else {
      uint64_t v20 = (void *)(v17 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(v17, v12, v13, v14);
    unint64_t v21 = _NativeDictionary.init(_:capacity:)( v20,  (uint64_t)objc_msgSend(v20, sel_count),  v10,  v19,  *(void *)(a5 + 32));
    uint64_t v22 = *v6;
    *unint64_t v6 = (unint64_t)v21;
    swift_retain((unint64_t *)v21, v23, v24, v25);
    swift_bridgeObjectRelease(v22);
    if ((v57 & 1) != 0) {
      goto LABEL_6;
    }
LABEL_18:
    if (a2 < 0 || 1LL << *((_BYTE *)v21 + 32) <= a2)
    {
      swift_retain((unint64_t *)v21, v26, v27, v28);
    }

    else if (((*(unint64_t *)((char *)v21 + (((unint64_t)a2 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> a2) & 1) != 0)
    {
      unint64_t v46 = a2;
      if (*((_DWORD *)v21 + 9) == (_DWORD)a3) {
        goto LABEL_22;
      }
    }

    unint64_t v54 = 281LL;
    goto LABEL_27;
  }

  if (!swift_isUniquelyReferenced_nonNull_native(v17))
  {
    uint64_t v58 = *v5;
    *unint64_t v5 = 0x8000000000000000LL;
    type metadata accessor for _NativeDictionary(0LL, (uint64_t)v10, (uint64_t)v19, *(void *)(a5 + 32));
    _NativeDictionary.copy()();
    uint64_t v52 = *v5;
    *unint64_t v5 = v58;
    swift_bridgeObjectRelease(v52);
  }

  unint64_t v21 = (__objc2_class **)*v5;
  swift_bridgeObjectRetain(*v6, v49, v50, v51);
  if ((v57 & 1) == 0) {
    goto LABEL_18;
  }
LABEL_6:
  if (a2 >= 0) {
    uint64_t v29 = a2 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v29 = a2;
  }
  uint64_t v30 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(a2, v31, v32, v33);
  if (!swift_dynamicCastClass(v29, v30)) {
    goto LABEL_24;
  }
  if (*((_DWORD *)v21 + 9) != specialized static Hasher._hash(seed:_:)(0LL, *(void *)(v29 + 16)))
  {
    swift_retain((unint64_t *)v21, v34, v35, v36);
LABEL_29:
    unint64_t v54 = 303LL;
LABEL_27:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v54,  0);
  }

  if (!swift_dynamicCastClass(v29, v30)) {
LABEL_24:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  uint64_t v40 = *(void *)(v29 + 24);
  if (*(void *)(v40 + 16) <= a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
  }
  uint64_t v41 = *(void **)(v40 + 8 * a3 + 24);
  swift_retain((unint64_t *)v21, v37, v38, v39);
  swift_unknownObjectRetain(v41, v42, v43, v44);
  outlined consume of [A : B].Index._Variant<A, B>(a2, a3, 1);
  _forceBridgeFromObjectiveC<A>(_:_:)(v41, v10, v45, v16);
  swift_unknownObjectRelease(v41);
  unint64_t v46 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v16, (uint64_t)v10, *(void *)(a5 + 32));
  char v48 = v47;
  swift_release((uint64_t)v21);
  (*(void (**)(char *, char *))(v11 + 8))(v16, v10);
  if ((v48 & 1) == 0) {
    goto LABEL_29;
  }
LABEL_22:
  uint64_t v53 = v21[7];
  swift_release((uint64_t)v21);
  (*(void (**)(unint64_t, uint64_t, uint64_t *))(*(v19 - 1) + 40))( (unint64_t)v53 + *(void *)(*(v19 - 1) + 72) * v46,  v56,  v19);
  outlined consume of [A : B].Index._Variant<A, B>(a2, a3, v57 & 1);
}

BOOL Dictionary.isEmpty.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 >= 0) {
      a1 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    id v1 = objc_msgSend((id)a1, sel_count);
  }

  else
  {
    id v1 = *(id *)(a1 + 16);
  }

  return v1 == 0LL;
}

void Dictionary.Values.swapAt(_:_:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = v7;
  uint64_t v13 = a1;
  uint64_t v14 = *(uint64_t **)(a7 + 24);
  uint64_t v15 = MEMORY[0x1895F8858](a1);
  uint64_t v17 = &v92[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v99 = *(char **)(v18 + 16);
  uint64_t v100 = v18;
  uint64_t v98 = *((void *)v99 - 1);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = &v92[-v22];
  uint64_t v97 = v24;
  uint64_t v95 = v25;
  int v101 = v21;
  if ((v26 & 1) == 0)
  {
    if ((v21 & 1) == 0)
    {
      if ((_DWORD)a2 != (_DWORD)a5) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xD5uLL,  0);
      }
      if (v13 == a4) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }

LABEL_50:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

    uint64_t v29 = rawBits >> 16;
    if ((v21 & 0x2000000000000000LL) != 0)
    {
      uint64_t v59 = v22;
      uint64_t v60 = v21 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v31 = *((unsigned __int8 *)&v59 + v29);
    }

    else
    {
      if ((v22 & 0x1000000000000000LL) != 0) {
        uint64_t v30 = (unsigned __int8 *)((v21 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v30 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v22, v21);
      }
      uint64_t v31 = v30[v29];
    }

    uint64_t v32 = (char)v31;
    int64_t v33 = __clz(v31 ^ 0xFF) - 24;
    if (v32 >= 0) {
      LOBYTE(v33) = 1;
    }
    v6._rawBits = ((v29 + v33) << 16) | 5;
    *(Swift::String::Index *)(v0 + 16) = v6;
    if ((v19 & 1) == 0)
    {
LABEL_58:
      if ((v20 & 1) != 0)
      {
        uint64_t v3 = 0;
        uint64_t v4 = value | (unint64_t)(v19 << 32);
        goto LABEL_5;
      }

      goto LABEL_68;
    }

    v246 = v4;
    v244 = v252 & 0xFFFFFFFFFFFFLL;
    if (v3) {
      uint64_t v4 = HIBYTE(*((void *)&v252 + 1)) & 0xFLL;
    }
    else {
      uint64_t v4 = v252 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(*((uint64_t *)&v252 + 1), 2LL, v59, v60);
    v245 = v4;
    if ((v13 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v13, 5LL, v64, v65);
      v153._rawBits = 1LL;
      v154._rawBits = (v4 << 16) | 1;
      v155._rawBits = _StringGuts.validateScalarRange(_:)(v153, v154, v5, v13);
      if (v155._rawBits < 0x10000) {
        v155._rawBits |= 3;
      }
      uint64_t v4 = specialized Collection.count.getter(v155, v156, v5, v13);
      swift_bridgeObjectRelease(v13);
      if ((v46 & 0x1000000000000000LL) != 0)
      {
LABEL_156:
        uint64_t v157 = String.UTF8View._foreignCount()();
        uint64_t v66 = v157 + v4;
        if (!__OFADD__(v157, v4))
        {
LABEL_56:
          int v67 = v12 & ~v46;
          if ((v67 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v46 & 0xFFFFFFFFFFFFFFFLL))
          {
            int v68 = _StringGuts.nativeUnusedCapacity.getter(v12, v46);
            if ((v69 & 1) == 0)
            {
              if (v66 > 15) {
                goto LABEL_62;
              }
              if ((v46 & 0x2000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease_n(v13, 5LL);
                char v77 = v46;
                uint64_t v4 = v246;
                uint64_t v7 = v247;
              }

              else
              {
                if (v68 >= v4) {
                  goto LABEL_62;
                }
LABEL_73:
                swift_bridgeObjectRelease_n(v13, 5LL);
                uint64_t v7 = v247;
                if ((v46 & 0x2000000000000000LL) != 0)
                {
                  char v77 = v46;
                  uint64_t v4 = v246;
                }

                else
                {
                  uint64_t v4 = v246;
                  if ((v46 & 0x1000000000000000LL) != 0)
                  {
                    uint64_t v12 = _StringGuts._foreignConvertedToSmall()(v12, v46);
                    char v77 = v243;
                  }

                  else
                  {
                    if ((v12 & 0x1000000000000000LL) != 0)
                    {
                      v237 = (unsigned __int8 *)((v46 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    }

                    else
                    {
                      v237 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v12, v46);
                      uint64_t v2 = v74;
                    }

                    swift_bridgeObjectRetain(v46, v74, v75, v76);
                    closure #1 in _StringGuts._convertedToSmall()(v237, v2, &v252);
                    swift_bridgeObjectRelease(v46);
                    char v77 = *((void *)&v252 + 1);
                    uint64_t v12 = v252;
                  }
                }
              }

              v78._rawBits = (v245 << 16) | 1;
              v79._rawBits = 1LL;
              v80._rawBits = _StringGuts.validateScalarRange(_:)(v79, v78, v5, v13);
              if (v80._rawBits < 0x10000) {
                v80._rawBits |= 3;
              }
              uint64_t v82 = specialized String.init(_:)(v80, v81, v5, v13);
              uint64_t v84 = v83;
              swift_bridgeObjectRelease(v13);
              if ((v84 & 0x2000000000000000LL) == 0) {
                goto LABEL_241;
              }
              swift_bridgeObjectRelease(v84);
              goto LABEL_79;
            }

        if (and._value < 0x300 || !(_swift_stdlib_getNormData(and._value) >> 3))
        {
          unint64_t v5 = 0;
          v2[1] = v10;
          v2[2] = 0;
          return v5 & 1;
        }

        goto LABEL_59;
      case 4:
      case 5:
        uint64_t v11 = v7;
        if (v7 == 4) {
          goto LABEL_28;
        }
        goto LABEL_21;
      case 6:
        if (v7 != 7 && v7 != 4) {
          goto LABEL_40;
        }
        goto LABEL_28;
      case 9:
        goto LABEL_28;
      case 10:
        switch(v7)
        {
          case 5u:
          case 6u:
          case 7u:
          case 0xAu:
          case 0xBu:
            goto LABEL_28;
          default:
            goto LABEL_40;
        }

      case 11:
        switch(v7)
        {
          case 4u:
          case 5u:
          case 7u:
          case 0xBu:
            goto LABEL_28;
          default:
            goto LABEL_40;
        }

      default:
        uint64_t v11 = v7;
        if (v7 == 12)
        {
          if (v8 == 3)
          {
            unint64_t v5 = v2[1] ^ 1;
            *(_WORD *)(v2 + 1) = 0;
            return v5 & 1;
          }
        }

        else if (v7 == 8)
        {
          if (v8 == 8)
          {
            unint64_t v5 = v2[3];
            v2[3] = v5 ^ 1;
            *(_WORD *)(v2 + 1) = 0;
            return v5 & 1;
          }
        }

        else
        {
LABEL_21:
          if (v11 == 7)
          {
LABEL_28:
            unint64_t v5 = 0;
            *(_WORD *)(v2 + 1) = 0;
            return v5 & 1;
          }
        }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
  }

  uint64_t v17 = _StringGuts.nativeUnusedCapacity.getter(*v5, v5[1]);
  if ((v18 & 1) != 0)
  {
    uint64_t v65 = 258LL;
    goto LABEL_56;
  }

  if (v15 <= 15 && ((v12 & 0x2000000000000000LL) != 0 || v17 < v11)) {
    goto LABEL_19;
  }
LABEL_13:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v15, v11);
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(a3, a4, v9, v10);
  }

  else
  {
    if ((a4 & 0x2000000000000000LL) == 0)
    {
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        uint64_t v19 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v20 = a3 & 0xFFFFFFFFFFFFLL;
        if ((a3 & 0xFFFFFFFFFFFFLL) >= (uint64_t)v10)
        {
LABEL_17:
          int v21 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, (uint64_t)v19, v20);
          _StringGuts.appendInPlace(_:isASCII:)(v21, v22, a3 < 0);
          return;
        }
      }

      else
      {
        uint64_t v19 = _StringObject.sharedUTF8.getter(a3, a4);
        uint64_t v20 = v64;
      }

    uint64_t v20 = _StringObject.sharedUTF8.getter(a2, a3);
    goto LABEL_19;
  }

  uint64_t v4 = String.UnicodeScalarView._foreignIndex(before:)(v9)._rawBits;
  v43._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)v4)._rawBits;
  value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v43._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
LABEL_20:
  uint64_t v22 = value;
  rawBits = v4 >> 16;
  if (v4 >= 0x10000)
  {
    uint64_t v44 = (char *)&v44 + 6;
    while (1)
    {
      v24._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(rawBits << 16))._rawBits;
      if (!(v24._rawBits >> 14)) {
        break;
      }
      uint64_t v4 = v24._rawBits;
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        v29._rawBits = String.UnicodeScalarView._foreignIndex(before:)(v24)._rawBits;
        v30._rawBits = _StringGuts.validateScalarIndex(_:)(v29)._rawBits;
        uint64_t v35 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v30._rawBits & 0xFFFFFFFFFFFF0000LL));
        scalarLength = v35.scalarLength;
        uint64_t v31 = v35._0._value;
      }

      else
      {
        if ((a3 & 0x2000000000000000LL) != 0)
        {
          uint64_t v45 = a2;
          unint64_t v46 = a3 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v45 + (v24._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v36 = 0LL;
            do
              uint64_t v37 = v44[(v24._rawBits >> 16) + v36--] & 0xC0;
            while (v37 == 128);
            char v28 = 1 - v36;
          }

          else
          {
            char v28 = 1LL;
          }
        }

        else
        {
          uint64_t v25 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a2 & 0x1000000000000000LL) == 0)
          {
            uint64_t v25 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
            if (!v25) {
              goto LABEL_49;
            }
          }

          char v26 = 0LL;
          do
            BOOL v27 = v25[(v4 >> 16) - 1 + v26--] & 0xC0;
          while (v27 == 128);
          char v28 = -v26;
        }

        v29._rawBits = (v4 - (v28 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
        v39._rawBits = _StringGuts.validateScalarIndex(_:)(v29)._rawBits >> 16;
        if ((a3 & 0x2000000000000000LL) != 0)
        {
          uint64_t v45 = a2;
          unint64_t v46 = a3 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v40 = &v45;
        }

        else
        {
          uint64_t v40 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a2 & 0x1000000000000000LL) == 0) {
            uint64_t v40 = _StringObject.sharedUTF8.getter(a2, a3);
          }
        }

        uint64_t v31 = _decodeScalar(_:startingAt:)((uint64_t)v40, v38._rawBits, v39._rawBits);
      }

      id v41 = v31;
      swift_bridgeObjectRetain(a3, scalarLength, v33, v34);
      uint64_t v42 = specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(v41, v22, rawBits, (char *)a2, a3);
      swift_bridgeObjectRelease(a3);
      if ((v42 & 1) == 0)
      {
        rawBits = v29._rawBits >> 16;
        uint64_t v22 = v41;
        if (v29._rawBits >> 16) {
          continue;
        }
      }

      goto LABEL_21;
    }

  char *v55 = v54;
  return result;
}

  char *v55 = v54;
  return result;
}

  char *v55 = v54;
  return result;
}

  char *v55 = v54;
  return result;
}

  *uint64_t v54 = v55;
  return result;
}

    if (v18 == 12) {
      goto LABEL_76;
    }
    if (v20 != 4) {
      break;
    }
    if (v18 == 3 || v18 == 6)
    {
LABEL_64:
      LOBYTE(v31) = v20;
      if (v27) {
        uint64_t v22 = v14;
      }
      else {
        uint64_t v22 = *((void *)&v26 + 1);
      }
      uint64_t v29 = v22;
      uint64_t v30 = 0;
      goto LABEL_11;
    }

    if (v18 != 17) {
      goto LABEL_7;
    }
LABEL_11:
    char v28 = v5;
    if (v5 <= 0) {
      goto LABEL_76;
    }
  }

  if (v20 == 16)
  {
    switch(v18)
    {
      case 3u:
      case 6u:
      case 0x11u:
        goto LABEL_64;
      case 0x10u:
        goto LABEL_11;
      default:
        goto LABEL_7;
    }
  }

  if (v20 != 12)
  {
    if (v18 <= 0x11 && ((1 << v18) & 0x20048) != 0)
    {
      if (v20 > 0x11 || ((1 << v20) & 0x20048) == 0) {
        goto LABEL_64;
      }
      goto LABEL_11;
    }

    if (v20 > 0x11 || ((1 << v20) & 0x20048) == 0)
    {
LABEL_7:
      else {
        uint64_t v11 = v31;
      }
      specialized _StringGuts.decidePostFormatBackward(between:and:with:)(v18, v11, (uint64_t)&v25, v17);
      if ((v12 & 1) != 0) {
        goto LABEL_76;
      }
      goto LABEL_11;
    }

    goto LABEL_74;
  }

  uint64_t v19 = v23;
  if (v23)
  {
    os_unfair_lock_unlock(v23 + 2);
    uint64_t v20 = *(void **)&v19[4]._os_unfair_lock_opaque;
    *(void *)&v19[4]._os_unfair_lock_opaque = 0LL;
    if (v20) {
      operator delete(v20);
    }
    swift_slowDealloc(v19);
  }

  return (unint64_t *)v6;
}

  if (v41 == v40)
  {
    uint64_t v24 = 4LL;
  }

  else
  {
    if (!v41) {
      goto LABEL_55;
    }
    uint64_t v24 = 5LL;
    uint64_t v14 = v41;
  }

  (*(void (**)(void *))(*v14 + 8 * v24))(v14);
LABEL_55:
  if (v39 == v37)
  {
    uint64_t v25 = 4LL;
  }

  else
  {
    if (!v39) {
      goto LABEL_60;
    }
    uint64_t v25 = 5LL;
    uint64_t v13 = v39;
  }

  (*(void (**)(void *))(*v13 + 8 * v25))(v13);
LABEL_60:
  v46[0] = off_189B8E500;
  char v26 = v84;
  if (v84 == v83)
  {
    BOOL v27 = 4LL;
    char v26 = v83;
  }

  else
  {
    if (!v84) {
      goto LABEL_65;
    }
    BOOL v27 = 5LL;
  }

  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_65:
  v46[0] = off_189B8E4D8;
  unint64_t result = swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v47);
  if (v48) {
    *(_BYTE *)(v48 + 48) = 0;
  }
  return result;
}

        if (*(void *)v21 == 0x2E6E69746C697542LL && *(void *)(v21 + 3) == 0x746E492E6E69746CLL)
        {
LABEL_64:
          uint64_t v48 = 11LL;
          if (v20 < 0xB) {
            uint64_t v48 = v20;
          }
          uint64_t v49 = (const void *)(v21 + v48);
          BOOL v50 = v20 - v48;
LABEL_67:
          uint64_t v51 = v6;
          uint64_t v52 = 105;
LABEL_113:
          uint64_t v81 = swift::Demangle::__runtime::RemanglerBuffer::operator<<(v51, v52);
          swift::Demangle::__runtime::CharVector::append(v81, v49, v50, v81[2]);
          uint64_t v57 = v81;
          uint64_t v58 = 95;
          goto LABEL_114;
        }

        if (v20 >= 0xE
          && (*(void *)v21 == 0x2E6E69746C697542LL ? (uint64_t v44 = *(void *)(v21 + 6) == 0x4545454950462E6ELL) : (uint64_t v44 = 0),
              v44))
        {
          uint64_t v49 = (const void *)(v21 + 14);
          BOOL v50 = v20 - 14;
        }

        else
        {
LABEL_59:
          if (*(void *)v21 != 0x2E6E69746C697542LL || *(void *)(v21 + 3) != 0x6365562E6E69746CLL)
          {
LABEL_63:
            unint64_t v46 = 1553;
            char v47 = 9;
            goto LABEL_115;
          }

          uint64_t v53 = 11LL;
          if (v20 < 0xB) {
            uint64_t v53 = v20;
          }
          uint64_t v54 = (const void *)(v21 + v53);
          uint64_t v55 = v20 - v53;
          if (v20 >= 0xC)
          {
            char v71 = memchr(v54, 120, v20 - v53);
            if (v71) {
              uint64_t v56 = v71 - (_BYTE *)v54;
            }
            else {
              uint64_t v56 = -1LL;
            }
          }

          else
          {
            uint64_t v56 = -1LL;
          }

          uint64_t v72 = swift::Demangle::__runtime::RemanglerBuffer::operator<<(v6, 118);
          uint64_t v73 = v72;
          uint64_t v74 = v55 > v56;
          if (v55 < v56) {
            uint64_t v56 = v55;
          }
          uint64_t v75 = v74;
          if (v74) {
            uint64_t v76 = (uint64_t)v54 + v56 + 1;
          }
          else {
            uint64_t v76 = (uint64_t)v54 + v56;
          }
          swift::Demangle::__runtime::CharVector::append(v72, v54, v56, v72[2]);
          this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<(v73, 66);
          char v77 = v55 - v56 - v75;
          if (v77 == 10)
          {
            if (*(void *)v76 == 0x746E696F50776152LL && *(_WORD *)(v76 + 8) == 29285)
            {
              uint64_t v57 = v6;
              uint64_t v58 = 112;
LABEL_114:
              this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<(v57, v58);
              char v47 = 0;
              a2 = 0LL;
              unint64_t v46 = 0;
              goto LABEL_115;
            }
          }

          else if (v77 < 6)
          {
            if (v77 < 3)
            {
LABEL_109:
              unint64_t v46 = 1550;
              char v47 = 8;
              goto LABEL_115;
            }

            goto LABEL_105;
          }

          if (*(_DWORD *)v76 != 1162432582 || *(_WORD *)(v76 + 4) != 17733)
          {
LABEL_105:
            if (*(_WORD *)v76 != 28233 || *(_BYTE *)(v76 + 2) != 116) {
              goto LABEL_109;
            }
            uint64_t v49 = (const void *)(v76 + 3);
            BOOL v50 = v77 - 3;
            goto LABEL_67;
          }

          uint64_t v49 = (const void *)(v76 + 6);
          BOOL v50 = v77 - 6;
        }

        uint64_t v51 = v6;
        uint64_t v52 = 102;
        goto LABEL_113;
      }

      uint64_t v59 = *(_DWORD *)(v4 + 12736);
      uint64_t v60 = *(unsigned int *)(v4 + 12740);
      char v61 = *(char **)(v4 + 12728);
      char v62 = *(void **)(v4 + 12744);
      unint64_t v63 = (char *)v62[1];
      if (&v61[v60] == v63)
      {
        uint64_t v94 = (unint64_t)&v61[v60 + 1];
        int v64 = v62[2];
        if (v94 <= v64)
        {
          v62[1] = v94;
          LODWORD(v95) = 1;
          goto LABEL_157;
        }
      }

      else
      {
        int v64 = v62[2];
      }

      else {
        uint64_t v95 = (2 * v60);
      }
      unint64_t v96 = v95 + v60;
      if (!v63 || (unint64_t)&v63[v96] > v64)
      {
        uint64_t v97 = 2LL * v62[4];
        if (v97 <= v96 + 1) {
          uint64_t v97 = v96 + 1;
        }
        v62[4] = v97;
        uint64_t v98 = v97 + 8;
        this = (uint64_t)malloc(v97 + 8);
        uint64_t v99 = this + v98;
        *(void *)this = v62[3];
        unint64_t v63 = (char *)(this + 8);
        v62[2] = v99;
        v62[3] = this;
      }

      v62[1] = &v63[v96];
      if ((_DWORD)v60)
      {
        this = (uint64_t)memcpy(v63, *(const void **)(v4 + 12728), v60);
        LODWORD(v60) = *(_DWORD *)(v4 + 12740);
        uint64_t v59 = *(_DWORD *)(v4 + 12736);
      }

      *unint64_t v6 = v63;
      char v61 = v63;
LABEL_157:
      *(_DWORD *)(v4 + 12740) = v60 + v95;
LABEL_158:
      char v47 = 0;
      a2 = 0LL;
      unint64_t v46 = 0;
      *(_DWORD *)(v4 + 12736) = v59 + 1;
      v61[v59] = 98;
LABEL_115:
      *(_DWORD *)a3 = v47;
      *(void *)(a3 + 8) = a2;
      *(_DWORD *)(a3 + 16) = v46;
      return this;
    case 0x15uLL:
      this = memcmp(*(const void **)a2, "Builtin.UnknownObject", *((void *)a2 + 1));
      if ((_DWORD)this) {
        goto LABEL_50;
      }
      uint64_t v37 = *(_DWORD *)(v4 + 12736);
      uint64_t v38 = *(unsigned int *)(v4 + 12740);
      uint64_t v39 = *(char **)(v4 + 12728);
      uint64_t v40 = *(void **)(v4 + 12744);
      id v41 = (char *)v40[1];
      if (&v39[v38] == v41)
      {
        uint64_t v88 = (unint64_t)&v39[v38 + 1];
        uint64_t v42 = v40[2];
        if (v88 <= v42)
        {
          v40[1] = v88;
          LODWORD(v89) = 1;
          goto LABEL_143;
        }
      }

      else
      {
        uint64_t v42 = v40[2];
      }

      else {
        uint64_t v89 = (2 * v38);
      }
      uint64_t v90 = v89 + v38;
      if (!v41 || (unint64_t)&v41[v90] > v42)
      {
        int64_t v91 = 2LL * v40[4];
        if (v91 <= v90 + 1) {
          int64_t v91 = v90 + 1;
        }
        v40[4] = v91;
        int64_t v92 = v91 + 8;
        this = (uint64_t)malloc(v91 + 8);
        BOOL v93 = this + v92;
        *(void *)this = v40[3];
        id v41 = (char *)(this + 8);
        v40[2] = v93;
        v40[3] = this;
      }

      v40[1] = &v41[v90];
      if ((_DWORD)v38)
      {
        this = (uint64_t)memcpy(v41, *(const void **)(v4 + 12728), v38);
        LODWORD(v38) = *(_DWORD *)(v4 + 12740);
        uint64_t v37 = *(_DWORD *)(v4 + 12736);
      }

      *unint64_t v6 = v41;
      uint64_t v39 = v41;
LABEL_143:
      *(_DWORD *)(v4 + 12740) = v38 + v89;
LABEL_144:
      char v47 = 0;
      a2 = 0LL;
      unint64_t v46 = 0;
      *(_DWORD *)(v4 + 12736) = v37 + 1;
      v39[v37] = 79;
      goto LABEL_115;
    case 0x19uLL:
      this = memcmp(*(const void **)a2, "Builtin.UnsafeValueBuffer", *((void *)a2 + 1));
      if ((_DWORD)this) {
        goto LABEL_50;
      }
      uint64_t v65 = *(_DWORD *)(v4 + 12736);
      uint64_t v66 = *(unsigned int *)(v4 + 12740);
      int v67 = *(char **)(v4 + 12728);
      int v68 = *(void **)(v4 + 12744);
      uint64_t v69 = (char *)v68[1];
      if (&v67[v66] == v69)
      {
        uint64_t v100 = (unint64_t)&v67[v66 + 1];
        uint64_t v70 = v68[2];
        if (v100 <= v70)
        {
          v68[1] = v100;
          LODWORD(v101) = 1;
          goto LABEL_171;
        }
      }

      else
      {
        uint64_t v70 = v68[2];
      }

      else {
        int v101 = (2 * v66);
      }
      uint64_t v102 = v101 + v66;
      if (!v69 || (unint64_t)&v69[v102] > v70)
      {
        uint64_t v103 = 2LL * v68[4];
        if (v103 <= v102 + 1) {
          uint64_t v103 = v102 + 1;
        }
        v68[4] = v103;
        uint64_t v104 = v103 + 8;
        this = (uint64_t)malloc(v103 + 8);
        unint64_t v105 = this + v104;
        *(void *)this = v68[3];
        uint64_t v69 = (char *)(this + 8);
        v68[2] = v105;
        v68[3] = this;
      }

      v68[1] = &v69[v102];
      if ((_DWORD)v66)
      {
        this = (uint64_t)memcpy(v69, *(const void **)(v4 + 12728), v66);
        LODWORD(v66) = *(_DWORD *)(v4 + 12740);
        uint64_t v65 = *(_DWORD *)(v4 + 12736);
      }

      *unint64_t v6 = v69;
      int v67 = v69;
LABEL_171:
      *(_DWORD *)(v4 + 12740) = v66 + v101;
LABEL_172:
      char v47 = 0;
      a2 = 0LL;
      unint64_t v46 = 0;
      *(_DWORD *)(v4 + 12736) = v65 + 1;
      v67[v65] = 66;
      goto LABEL_115;
    default:
      if (v20 < 0xB) {
        goto LABEL_63;
      }
      goto LABEL_50;
  }

__objc2_class **_NativeDictionary.init(_:)(void *a1, char *a2, uint64_t *a3, uint64_t a4)
{
  return _NativeDictionary.init(_:capacity:)(a1, (uint64_t)objc_msgSend(a1, sel_count), a2, a3, a4);
}

BOOL specialized Dictionary._Variant.isUniquelyReferenced()()
{
  return swift_isUniquelyReferenced_nonNull_native(*v0);
}

Swift::Bool __swiftcall Dictionary._Variant.isUniquelyReferenced()()
{
  return swift_isUniquelyReferenced_nonNull_native(*v0);
}

uint64_t (*Dictionary._Variant.asNative.modify(void *a1))()
{
  *a1 = *v1;
  a1[1] = v1;
  void *v1 = 0x8000000000000000LL;
  return _SmallString.leadingRawBits.modify;
}

Swift::Void __swiftcall _NativeDictionary.swapValuesAt(_:_:isUnique:)( Swift::_HashTable::Bucket _, Swift::_HashTable::Bucket a2, Swift::Bool isUnique)
{
  uint64_t v7 = *(void *)(v3 + 24);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](_.offset);
  uint64_t v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 1) == 0) {
    _NativeDictionary.copy()();
  }
  uint64_t v12 = *v4;
  uint64_t v13 = *(void *)(v8 + 72);
  Swift::Int v14 = v13 * _.offset;
  uint64_t v15 = *(void (**)(char *, Swift::Int, uint64_t))(v8 + 32);
  v15(v10, *(void *)(v12 + 56) + v14, v7);
  Swift::Int v16 = v13 * a2.offset;
  UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(*(void *)(v12 + 56) + v16),  1LL,  (char *)(*(void *)(v12 + 56) + v14),  v7);
  v15((char *)(*(void *)(v12 + 56) + v16), (Swift::Int)v10, v7);
}

uint64_t (*MutableCollection<>.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v9 = malloc(0x58uLL);
  *a1 = v9;
  v9[1] = a4;
  void v9[2] = v4;
  *uint64_t v9 = a3;
  uint64_t v10 = *(const char **)(a4 + 8);
  uint64_t v12 = type metadata accessor for Slice(0LL, a3, (uint64_t)v10, v11);
  v9[3] = v12;
  uint64_t v13 = *(void *)(v12 - 8);
  v9[4] = v13;
  size_t v14 = *(void *)(v13 + 64);
  v9[5] = malloc(v14);
  uint64_t v15 = (char *)malloc(v14);
  v9[6] = v15;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v19 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v18);
  v9[7] = v19;
  uint64_t v20 = *(void *)(v19 - 8);
  v9[8] = v20;
  size_t v21 = *(void *)(v20 + 64);
  v9[9] = malloc(v21);
  v9[10] = malloc(v21);
  (*(void (**)(void))(v20 + 16))();
  MutableCollection<>.subscript.getter(a2, a3, a4, v15);
  return MutableCollection<>.subscript.modify;
}

uint64_t (*Dictionary.Values.subscript.read( char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6, char *a7, uint64_t a8))()
{
  uint64_t v15 = *((void *)a7 - 1);
  *a1 = a7;
  a1[1] = (char *)v15;
  Swift::Int v16 = (char *)malloc(*(void *)(v15 + 64));
  a1[2] = v16;
  Dictionary.Values.subscript.getter(a2, a3, a5, a6, a7, a8, v16);
  return _ArrayBuffer.subscript.read;
}

uint64_t MutableCollection<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  unint64_t v63 = a4;
  uint64_t v64 = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v56 = (char *)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v54 = (char *)&v51 - v11;
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v51 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v51 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  size_t v21 = (char *)&v51 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v51 - v22;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v60 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v57 = *(void *)(v60 - 8);
  uint64_t v26 = MEMORY[0x1895F8858](v60);
  uint64_t v53 = (char *)&v51 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = (char *)&v51 - v28;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(a2, v6);
  uint64_t v29 = *(void (**)(uint64_t, uint64_t))(v6 + 72);
  uint64_t v61 = a2;
  uint64_t v62 = v4;
  uint64_t v59 = v6;
  v29(a2, v6);
  uint64_t v30 = *(void (**)(char *, char *, unint64_t))(v12 + 16);
  v30(v18, v23, AssociatedTypeWitness);
  uint64_t v52 = v21;
  v30(v15, v21, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v18,  v15,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = v12;
  uint64_t v32 = *(void (**)(char *, unint64_t))(v12 + 8);
  v32(v15, AssociatedTypeWitness);
  v32(v18, AssociatedTypeWitness);
  int64_t v33 = TupleTypeMetadata2;
  uint64_t v34 = v54;
  uint64_t v35 = &v54[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v36 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
  v36(v54, v23, AssociatedTypeWitness);
  v36(v35, v52, AssociatedTypeWitness);
  uint64_t v37 = v56;
  uint64_t v38 = &v56[*((int *)v33 + 12)];
  v30(v56, v34, AssociatedTypeWitness);
  v30(v38, v35, AssociatedTypeWitness);
  uint64_t v39 = v53;
  v36(v53, v37, AssociatedTypeWitness);
  v32(v38, AssociatedTypeWitness);
  uint64_t v40 = &v37[*((int *)v33 + 12)];
  v36(v37, v34, AssociatedTypeWitness);
  v36(v40, v35, AssociatedTypeWitness);
  uint64_t v41 = v60;
  v36(&v39[*(int *)(v60 + 36)], v40, AssociatedTypeWitness);
  v32(v37, AssociatedTypeWitness);
  uint64_t v42 = v57;
  uint64_t v43 = v55;
  (*(void (**)(char *, char *, uint64_t))(v57 + 32))(v55, v39, v41);
  uint64_t v44 = v59;
  uint64_t v46 = v61;
  uint64_t v45 = v62;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v59 + 176))(v64, v43, v61, v59);
  (*(void (**)(char *, uint64_t))(v42 + 8))(v43, v41);
  uint64_t v48 = type metadata accessor for Slice(0LL, v46, v44, v47);
  uint64_t v49 = v63;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v46 - 8) + 16LL))(&v63[*(int *)(v48 + 40)], v45, v46);
  (*(void (**)(char *, uint64_t, uint64_t))(v42 + 16))(v39, v64, v41);
  v36(v49, v39, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, unint64_t))v36)( &v49[*(int *)(v48 + 36)],  &v39[*(int *)(v41 + 36)],  AssociatedTypeWitness);
}

int64_t Dictionary.Values.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001LL) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v4 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0LL;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0LL;
    unint64_t result = v5 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v9 = -1LL;
    uint64_t v10 = -1LL << *(_BYTE *)(result + 32);
    int64_t v6 = result + 64;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1LL << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 64);
  }

  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0LL;
  a2[4] = v8;
  return result;
}

uint64_t Dictionary.Keys.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = type metadata accessor for Dictionary.Keys(0LL, a2, a3, a4);
  swift_getWitnessTable(&protocol conformance descriptor for [A : B].Keys, v4, v5);
  return Collection._makeCollectionDescription(withTypeName:)((Swift::String_optional)0)._countAndFlagsBits;
}

uint64_t Dictionary.Keys.debugDescription.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  *(void *)&__int128 v235 = a1;
  unint64_t v228 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (uint64_t)&v225 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = type metadata accessor for Optional(0LL, v5, v6, v7);
  MEMORY[0x1895F8858](v8);
  v231 = (char *)&v225 - v9;
  __int128 v10 = (__int128)String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Dictionary.Keys", 0xFuLL, 1);
  unint64_t v11 = v10;
  uint64_t v12 = *((void *)&v10 + 1);
  unint64_t v240 = 0LL;
  unint64_t v241 = 0xE000000000000000LL;
  uint64_t v13 = specialized static String._createEmpty(withInitialCapacity:)(4LL);
  unint64_t v17 = v13;
  unint64_t v18 = v14;
  *(void *)&__int128 v239 = v13;
  *((void *)&v239 + 1) = v14;
  uint64_t v19 = HIBYTE(v14) & 0xF;
  int64_t v20 = v13 & 0xFFFFFFFFFFFFLL;
  if ((v14 & 0x2000000000000000LL) != 0) {
    uint64_t v21 = HIBYTE(v14) & 0xF;
  }
  else {
    uint64_t v21 = v13 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v233 = v4;
  if (!v21 && (v13 & ~v14 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v14);
    unint64_t v17 = 0LL;
    unint64_t v43 = 0xE000000000000000LL;
    *(void *)&__int128 v239 = 0LL;
LABEL_21:
    *((void *)&v239 + 1) = v43;
    goto LABEL_25;
  }

  if ((v14 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v14);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v47 = 0xA000000000000000LL;
    if (!(v18 & 0x80808080808080LL | v17 & 0x8080808080808080LL)) {
      unint64_t v47 = 0xE000000000000000LL;
    }
    unint64_t v43 = v47 & 0xFF00000000000000LL | (v19 << 56) | v18 & 0xFFFFFFFFFFFFFFLL;
    *(void *)&__int128 v239 = v17;
    goto LABEL_21;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v15, v16);
  if ((v18 & 0x1000000000000000LL) != 0)
  {
    int64_t v20 = String.UTF8View._foreignCount()();
    if ((v17 & ~v18 & 0x2000000000000000LL) == 0) {
      goto LABEL_23;
    }
  }

  else if ((v17 & ~v18 & 0x2000000000000000LL) == 0)
  {
    goto LABEL_23;
  }

  if (swift_isUniquelyReferenced_nonNull_native(v18 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v17, v18);
    if ((v23 & 1) != 0) {
      goto LABEL_218;
    }
    if (v20 <= 15 && (v22 & 0x8000000000000000LL) != 0) {
      goto LABEL_13;
    }
LABEL_24:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v20, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    int64_t v236 = 0LL;
    uint64_t v237 = 0LL;
    uint64_t v48 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v236, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v48, v49, 1);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v43 = *((void *)&v239 + 1);
    unint64_t v17 = v239;
    goto LABEL_25;
  }

LABEL_77:
  int64_t v52 = v235;
  uint64_t v108 = *((void *)&v239 + 1);
  uint64_t v109 = HIBYTE(*((void *)&v239 + 1)) & 0xFLL;
  if ((*((void *)&v239 + 1) & 0x2000000000000000LL) == 0) {
    uint64_t v109 = v239 & 0xFFFFFFFFFFFFLL;
  }
  if (v109 || ((unint64_t)v239 & ~*((void *)&v239 + 1) & 0x2000000000000000LL) != 0)
  {
    if ((*((void *)&v239 + 1) & 0x2000000000000000LL) == 0
      || (unint64_t v110 = specialized _SmallString.init(_:appending:)( v239,  *((unint64_t *)&v239 + 1),  0x5B28uLL,  0xE200000000000000LL),  (v65 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v64, v65, v66);
      _StringGuts.append(_:)(23336LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
      unint64_t v112 = *((void *)&v239 + 1);
      unint64_t v111 = v239;
    }

    else
    {
      unint64_t v111 = v110;
      unint64_t v112 = v64;
      swift_bridgeObjectRelease(v108);
      swift_bridgeObjectRelease(0xE200000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(*((uint64_t *)&v239 + 1));
    unint64_t v112 = 0xE200000000000000LL;
    unint64_t v111 = 23336LL;
  }

  unint64_t v17 = v241;
  unint64_t v116 = HIBYTE(v241) & 0xF;
  if ((v241 & 0x2000000000000000LL) == 0) {
    unint64_t v116 = v240 & 0xFFFFFFFFFFFFLL;
  }
  if (!v116 && (v240 & ~v241 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v241);
    unint64_t v240 = v111;
    unint64_t v241 = v112;
    goto LABEL_96;
  }

  if ((v241 & 0x2000000000000000LL) == 0)
  {
    if ((v112 & 0x2000000000000000LL) != 0)
    {
      uint64_t v117 = HIBYTE(v112) & 0xF;
      goto LABEL_94;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }

    v301(v324, a3);
    int64_t v229 = 0;
    Swift::String::Index v217 = v304;
    Swift::String::Index v218 = (unsigned __int16)v339 & 0x3FF;
    goto LABEL_98;
  }

  if (v212 > 64) {
    goto LABEL_67;
  }
  v256 = v336;
  v257 = v306;
  v258 = swift_getAssociatedConformanceWitness( (uint64_t)v336,  a3,  v306,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v259 = v335;
  (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v258 + 8))( &qword_18180BE68,  256LL,  v257,  v258);
  v260 = v338;
  (*((void (**)(char *, uint64_t, const char *))v256 + 3))(v259, a3, v256);
  v261 = v324;
  LOBYTE(v257) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v324,  v260,  a3);
  v301(v260, a3);
  (*(void (**)(char *, char *, uint64_t))(v303 + 32))(v308, v261, a3);
  if ((v257 & 1) != 0)
  {
    v301(v308, a3);
    Swift::String::Index v217 = v304;
    Swift::String::Index v218 = (unsigned __int16)v339 & 0x3FF;
    goto LABEL_97;
  }

  uint64_t v226 = v308;
  __int128 v227 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
LABEL_75:
  unint64_t v228 = v227;
  v301(v226, a3);
  Swift::String::Index v217 = v304;
  Swift::String::Index v218 = (unsigned __int16)v339 & 0x3FF;
  if (v228 < 0) {
    goto LABEL_97;
  }
LABEL_76:
  int64_t v229 = 0;
LABEL_98:
  *v337 = ((v218 | (v217 << 10)) + 15360) | v229;
  v262 = v305;
  v263 = *(uint64_t (**)(unint64_t *, unint64_t))(v305 + 64);
  v264 = (uint64_t)v334;
  if ((v263(v334, v305) & 1) != 0)
  {
    goto LABEL_103;
  }

  v265 = v263((unint64_t *)v264, v262);
  v266 = (*(uint64_t (**)(uint64_t, unint64_t))(v262 + 128))(v264, v262);
  if ((v265 & 1) != 0)
  {
    if (v266 > 64)
    {
LABEL_103:
      v340 = 0LL;
      v267 = v332;
      v268 = (uint64_t)v334;
      (*(void (**)(char **, ValueMetadata *, char *, unint64_t *))(v305 + 96))( &v340,  &type metadata for Int,  v314,  v334);
      v269 = v330;
      unint64_t v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v330,  v267,  v268);
      v270 = v267;
      v271 = v320;
      ((void (*)(char *, uint64_t))v320)(v270, v268);
      ((void (*)(char *, uint64_t))v271)(v269, v268);
      return v96 & 1;
    }

    v275 = v327;
    ((void (*)(uint64_t *, uint64_t))v322)(&qword_18180BE68, 256LL);
    v276 = v332;
    v277 = (uint64_t)v334;
    ((void (*)(char *, unint64_t *, char *))v321)(v275, v334, v329);
    v278 = v330;
    v279 = (*(uint64_t (**)(char *, char *, uint64_t))(AssociatedConformanceWitness + 32))(v330, v276, v277);
    ((void (*)(char *, uint64_t))v320)(v276, v277);
    v333(v312, v278, v277);
    unint64_t v96 = (v279 & 1) != 0 && ((uint64_t (*)(unint64_t *, unint64_t))v315)(v334, v305) == 0;
    ((void (*)(char *, unint64_t *))v320)(v312, v334);
  }

  else
  {
    if (v266 < 64)
    {
LABEL_106:
      v272 = v332;
      v273 = (uint64_t)v334;
      v333(v332, v330, v334);
      v274 = ((uint64_t (*)(uint64_t, unint64_t))v315)(v273, v305);
      ((void (*)(char *, uint64_t))v320)(v272, v273);
      unint64_t v96 = v274 == 0;
      return v96 & 1;
    }

    v340 = 0LL;
    v280 = v332;
    v281 = (uint64_t)v334;
    (*(void (**)(char **, ValueMetadata *, char *, unint64_t *))(v305 + 96))( &v340,  &type metadata for Int,  v314,  v334);
    v282 = v330;
    unint64_t v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v330,  v280,  v281);
    v283 = v282;
    v284 = v320;
    ((void (*)(char *, uint64_t))v320)(v283, v281);
    ((void (*)(char *, uint64_t))v284)(v280, v281);
  }

  return v96 & 1;
}

    unint64_t v107 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v151 + 56);
    goto LABEL_83;
  }

  uint64_t v144 = v39;
  if (v43 == 45)
  {
    unint64_t v149 = v31;
    uint64_t v44 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v40);
    uint64_t v48 = specialized UnsafeBufferPointer.init(rebasing:)(v44, v45, v46, v47);
    if (v49)
    {
      uint64_t v51 = (unsigned __int8 *)v48;
      unint64_t v142 = v49;
      int64_t v52 = a3 + 48;
      unint64_t v53 = a3 + 55;
      unint64_t v54 = a3 + 87;
      if (a3 <= 10) {
        unint64_t v54 = 97;
      }
      id v138 = v54;
      if (a3 <= 10) {
        unint64_t v53 = 65;
      }
      uint64_t v139 = v53;
      char v152 = a3;
      uint64_t v55 = v150;
      uint64_t v56 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v150 + 96);
      if (a3 > 10) {
        int64_t v52 = 58;
      }
      uint64_t v141 = v52;
      Swift::Int v57 = lazy protocol witness table accessor for type Int and conformance Int(v48, v49, v50);
      unint64_t v143 = v56;
      v56(&v152, &type metadata for Int, v57, a4, v55);
      int64_t v58 = swift_getAssociatedConformanceWitness( v13,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v59 = v144;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v58 + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  v58);
      int64_t v60 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, uint64_t))(v13 + 24))(v59, a4, v13);
      if (v51)
      {
        uint64_t v140 = v42;
        size_t v63 = v146;
        do
        {
          uint64_t v64 = *v51;
          if (v64 < 0x30 || v64 >= v141)
          {
            if (v64 < 0x41 || v64 >= v139)
            {
              if (v64 < 0x61 || v64 >= v138)
              {
                uint64_t v134 = v151;
                v135 = *(void (**)(char *, uint64_t))(v151 + 8);
                v135(v34, a4);
                unint64_t v136 = v42;
                goto LABEL_82;
              }

              uint64_t v144 = v51;
              uint64_t v65 = v64 - 87;
            }

            else
            {
              uint64_t v144 = v51;
              uint64_t v65 = v64 - 55;
            }

            LOBYTE(v152) = v65;
          }

          else
          {
            uint64_t v144 = v51;
            LOBYTE(v152) = v64 - 48;
          }

          uint64_t v66 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v60, v61, v62);
          unint64_t v67 = v149;
          v143(&v152, &type metadata for UInt8, v66, a4, v150);
          uint64_t v68 = v148;
          uint64_t v69 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v148 + 96))(v63, v42, a4, v148);
          uint64_t v70 = v151;
          unint64_t v71 = *(void (**)(char *, uint64_t))(v151 + 8);
          v71(v34, a4);
          unint64_t v72 = *(void (**)(char *, char *, uint64_t))(v70 + 32);
          v72(v34, v63, a4);
          unint64_t v73 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v68 + 88))(v63, v67, a4, v68);
          v71(v67, a4);
          v71(v34, a4);
          Swift::String::Index v74 = v147;
          v72(v147, v63, a4);
          int64_t v60 = ((uint64_t (*)(char *, char *, uint64_t))v72)(v34, v74, a4);
          if ((v69 & 1) != 0 || (v73 & 1) != 0)
          {
            v71(v34, a4);
            uint64_t v133 = v140;
            goto LABEL_76;
          }

          uint64_t v51 = v144 + 1;
          --v142;
          char v42 = v140;
        }

        while (v142);
      }

      Swift::String::Index v75 = v151;
      (*(void (**)(char *, uint64_t))(v151 + 8))(v42, a4);
      unint64_t v76 = v145;
      (*(void (**)(char *, char *, uint64_t))(v75 + 32))(v145, v34, a4);
LABEL_50:
      unint64_t v107 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v75 + 56);
LABEL_51:
      uint64_t v108 = v76;
      uint64_t v109 = 0LL;
      return v107((uint64_t)v108, v109, 1LL, a4);
    }

    goto LABEL_77;
  }

  unint64_t v142 = v40;
  unint64_t v143 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v35;
  unint64_t v110 = a3 + 48;
  unint64_t v111 = a3 + 55;
  unint64_t v112 = a3 + 87;
  if (a3 <= 10) {
    unint64_t v112 = 97;
  }
  id v138 = v112;
  if (a3 <= 10) {
    unint64_t v111 = 65;
  }
  uint64_t v139 = v111;
  char v152 = a3;
  uint64_t v113 = v150;
  uint64_t v114 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v150 + 96);
  if (a3 > 10) {
    unint64_t v110 = 58;
  }
  uint64_t v141 = v110;
  uint64_t v115 = lazy protocol witness table accessor for type Int and conformance Int(v35, v36, v40);
  v114(&v152, &type metadata for Int, v115, a4, v113);
  unint64_t v116 = swift_getAssociatedConformanceWitness( v13,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v117 = v144;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v116 + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  v116);
  uint64_t v118 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, uint64_t))(v13 + 24))(v117, a4, v13);
  uint64_t v140 = (char *)v114;
  while (1)
  {
    uint64_t v121 = *a1;
    uint64_t v144 = a1;
    LOBYTE(v152) = v121 - 48;
LABEL_69:
    unint64_t v123 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v118, v119, v120);
    uint64_t v124 = (char *)v143;
    v114(&v152, &type metadata for UInt8, v123, a4, v150);
    uint64_t v125 = v148;
    uint64_t v126 = v146;
    uint64_t v127 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v148 + 96))(v146, v149, a4, v148);
    uint64_t v128 = v151;
    unint64_t v129 = *(void (**)(char *, uint64_t))(v151 + 8);
    v129(v24, a4);
    uint64_t v130 = *(void (**)(char *, char *, uint64_t))(v128 + 32);
    v130(v24, v126, a4);
    v131 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v125 + 80))(v126, v124, a4, v125);
    v129(v124, a4);
    v129(v24, a4);
    size_t v132 = v147;
    v130(v147, v126, a4);
    uint64_t v118 = ((uint64_t (*)(char *, char *, uint64_t))v130)(v24, v132, a4);
    if ((v127 & 1) != 0 || (v131 & 1) != 0)
    {
      v129(v24, a4);
      v129(v149, a4);
      goto LABEL_77;
    }

    a1 = v144 + 1;
    --v142;
    uint64_t v114 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v140;
    if (!v142)
    {
      v129(v149, a4);
      unint64_t v76 = v145;
      v130(v145, v24, a4);
      unint64_t v107 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v151 + 56);
      goto LABEL_51;
    }
  }

  if (v121 >= 0x41 && v121 < v139)
  {
    uint64_t v144 = a1;
    uint64_t v122 = v121 - 55;
LABEL_68:
    LOBYTE(v152) = v122;
    goto LABEL_69;
  }

  if (v121 >= 0x61 && v121 < v138)
  {
    uint64_t v144 = a1;
    uint64_t v122 = v121 - 87;
    goto LABEL_68;
  }

  uint64_t v134 = v151;
  v135 = *(void (**)(char *, uint64_t))(v151 + 8);
  v135(v24, a4);
LABEL_81:
  unint64_t v136 = v149;
LABEL_82:
  v135(v136, a4);
  unint64_t v107 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v134 + 56);
LABEL_83:
  uint64_t v108 = v145;
  uint64_t v109 = 1LL;
  return v107((uint64_t)v108, v109, 1LL, a4);
}

          Swift::Int v57 = (v63 - 1) & v63;
          char v61 = __clz(__rbit64(v63)) + (v59 << 6);
        }

        outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v61, (uint64_t)&v93);
        specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v93, (uint64_t)v13);
      }
    }

    unint64_t v47 = v20;
    uint64_t v51 = v18;
    unint64_t v37 = v19;
    unint64_t v22 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v23);
    int64_t v20 = v47;
    unint64_t v18 = v51;
    uint64_t v19 = v37;
    goto LABEL_53;
  }

  if (v15 >= rawBits >> 14) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  to._rawBits = v9 >> 16;
  unint64_t v39 = 4LL;
  if (((v6 >> 60) & ((v7 & 0x800000000000000LL) == 0)) != 0) {
    unint64_t v39 = 8LL;
  }
  unint64_t v14 = v9 & 2 | v39;
  do
  {
    if (__OFSUB__(v8--, 1LL)) {
      goto LABEL_93;
    }
    if ((rawBits ^ v9) >= 0x4000)
    {
      unint64_t v40 = _StringGuts._opaqueCharacterStride(endingAt:in:)(rawBits >> 16, v9 >> 16, v2, v7, v6);
      rawBits -= v40 << 16;
      unint64_t v41 = v40 << 8;
      if (v40 > 63) {
        unint64_t v41 = 0LL;
      }
    }

    else
    {
      unint64_t v41 = 0LL;
    }

    char v42 = rawBits & 0xFFFFFFFFFFFF0000LL | v41;
    rawBits = v14 | v42 | 1;
  }

  while (v15 < v42 >> 14);
  return v8;
}

        uint64_t v25 = 1;
        goto LABEL_85;
      }
    }

    uint64_t v25 = 0;
    goto LABEL_85;
  }

  return a1;
}

  uint64_t v16 = *(_DWORD *)(v5 + 12736);
  unint64_t v17 = *(unsigned int *)(v5 + 12740);
  unint64_t v18 = *(char **)(v5 + 12728);
  if (v16 >= v17)
  {
    uint64_t v19 = *(void **)(v5 + 12744);
    int64_t v20 = (char *)v19[1];
    a4 = v62;
    if (&v18[v17] == v20)
    {
      int64_t v52 = (unint64_t)&v18[v17 + 1];
      uint64_t v51 = v19[2];
      if (v52 <= v51) {
        goto LABEL_108;
      }
    }

    else
    {
      uint64_t v51 = v19[2];
    }

    else {
      unint64_t v53 = (2 * v17);
    }
    unint64_t v54 = v53 + v17;
    if (!v20 || (unint64_t)&v20[v54] > v51)
    {
      uint64_t v55 = 2LL * v19[4];
      if (v55 <= v54 + 1) {
        uint64_t v55 = v54 + 1;
      }
      v19[4] = v55;
      uint64_t v56 = v55 + 8;
      this = (uint64_t *)malloc(v55 + 8);
      Swift::Int v57 = (char *)this + v56;
      *this = v19[3];
      int64_t v20 = (char *)(this + 1);
      _OWORD v19[2] = v57;
      void v19[3] = this;
    }

    v19[1] = &v20[v54];
    if ((_DWORD)v17)
    {
      this = (uint64_t *)memcpy(v20, *(const void **)(v5 + 12728), v17);
      LODWORD(v17) = *(_DWORD *)(v5 + 12740);
      uint64_t v16 = *(_DWORD *)(v5 + 12736);
    }

    a4 = v62;
LABEL_93:
    *(void *)(v5 + 12728) = v20;
    unint64_t v18 = v20;
LABEL_94:
    *(_DWORD *)(v5 + 12740) = v17 + v53;
  }

  else
  {
    a4 = v62;
  }

LABEL_93:
    uint64_t v117 = v111 & 0xFFFFFFFFFFFFLL;
    goto LABEL_94;
  }

  if ((v112 & 0x2000000000000000LL) == 0) {
    goto LABEL_93;
  }
  unint64_t v213 = specialized _SmallString.init(_:appending:)(v240, v241, v111, v112);
  if ((v114 & 1) == 0)
  {
    unint64_t v214 = v213;
    unint64_t v215 = v113;
    swift_bridgeObjectRelease(v17);
    swift_bridgeObjectRelease(v112);
    unint64_t v240 = v214;
    unint64_t v241 = v215;
    unint64_t v43 = v228;
    goto LABEL_95;
  }

  uint64_t v117 = HIBYTE(v112) & 0xF;
  unint64_t v43 = v228;
LABEL_94:
  swift_bridgeObjectRetain(v112, v113, v114, v115);
  unint64_t v17 = (unint64_t)&v240;
  _StringGuts.append(_:)(v111, v112, 0LL, v117);
  swift_bridgeObjectRelease_n(v112, 2LL);
LABEL_95:
  uint64_t v4 = v233;
LABEL_96:
  int64_t v58 = (int64_t)v231;
  if ((v52 & 0xC000000000000001LL) != 0)
  {
    if (v52 < 0) {
      uint64_t v121 = v52;
    }
    else {
      uint64_t v121 = v52 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v122 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v123 = (unint64_t)swift_allocObject(v122, 0xE8uLL, 7uLL);
    uint64_t v230 = 0LL;
    uint64_t v124 = 0LL;
    unint64_t v11 = 0LL;
    *(void *)(v123 + 208) = v121;
    *(void *)(v123 + 216) = 0LL;
    *(_OWORD *)(v123 + 16) = 0u;
    *(_OWORD *)(v123 + 32) = 0u;
    *(_OWORD *)(v123 + 48) = 0u;
    *(_OWORD *)(v123 + 64) = 0u;
    *(_OWORD *)(v123 + 80) = 0u;
    *(_OWORD *)(v123 + 96) = 0u;
    *(_OWORD *)(v123 + 112) = 0u;
    *(_OWORD *)(v123 + 128) = 0u;
    *(_OWORD *)(v123 + 144) = 0u;
    *(_OWORD *)(v123 + 160) = 0u;
    *(_OWORD *)(v123 + 176) = 0u;
    *(_OWORD *)(v123 + 192) = 0u;
    *(void *)(v123 + 224) = 0LL;
    unint64_t v53 = v123 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v125 = -1LL << *(_BYTE *)(v52 + 32);
    uint64_t v124 = ~v125;
    uint64_t v126 = *(void *)(v52 + 64);
    uint64_t v230 = v52 + 64;
    uint64_t v127 = -v125;
    if (v127 < 64) {
      uint64_t v128 = ~(-1LL << v127);
    }
    else {
      uint64_t v128 = -1LL;
    }
    unint64_t v11 = v128 & v126;
    unint64_t v53 = v52;
  }

  uint64_t v232 = v53 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v225 = v124;
  int64_t v229 = (unint64_t)(v124 + 64) >> 6;
  unint64_t v129 = swift_bridgeObjectRetain(v52, v118, v119, v120);
  unint64_t v234 = 0LL;
  uint64_t v12 = 1LL;
  __int128 v235 = xmmword_1817FFC60;
  __int128 v227 = xmmword_1817FFC70;
  while (1)
  {
    if ((v53 & 0x8000000000000000LL) != 0)
    {
      unint64_t v17 = v232;
      id v138 = __CocoaDictionary.Iterator.nextKey()(v129, v130, v55, v56);
      if (!v138) {
        goto LABEL_165;
      }
      uint64_t v140 = v138;
      _forceBridgeFromObjectiveC<A>(_:_:)(v138, (char *)v2, v139, (char *)v58);
      swift_unknownObjectRelease(v140);
    }

    else
    {
      if (v11)
      {
        unint64_t v136 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        uint64_t v137 = v136 | (v234 << 6);
      }

      else
      {
        uint64_t v141 = v234 + 1;
        uint64_t v51 = v230;
        if (__OFADD__(v234, 1LL)) {
          goto LABEL_205;
        }
        if (v141 >= v229) {
          goto LABEL_165;
        }
        unint64_t v142 = *(void *)(v230 + 8 * v141);
        if (!v142)
        {
          unint64_t v143 = v234 + 2;
          unint64_t v142 = *(void *)(v230 + 8 * v143);
          if (!v142)
          {
            while (1)
            {
              uint64_t v141 = v143 + 1;
              if (__OFADD__(v143, 1LL)) {
                break;
              }
              if (v141 >= v229) {
                goto LABEL_165;
              }
              unint64_t v142 = *(void *)(v230 + 8 * v141);
              ++v143;
              if (v142) {
                goto LABEL_123;
              }
            }

            __break(1u);
LABEL_205:
            __break(1u);
LABEL_206:
            swift_bridgeObjectRetain_n(v12, 5LL, v55, v56);
            v217._rawBits = 1LL;
            v218._rawBits = (v4 << 16) | 1;
            v219._rawBits = _StringGuts.validateScalarRange(_:)(v217, v218, v11, v12);
            if (v219._rawBits < 0x10000) {
              v219._rawBits |= 3;
            }
            Swift::Int v57 = specialized Collection.count.getter(v219, v220, v11, v12);
            swift_bridgeObjectRelease(v12);
            if ((v43 & 0x1000000000000000LL) != 0) {
              goto LABEL_209;
            }
LABEL_39:
            int64_t v58 = v51 + v57;
            if (!__OFADD__(v51, v57)) {
              goto LABEL_40;
            }
LABEL_211:
            __break(1u);
LABEL_212:
            Swift::Int v222 = String.UTF8View._foreignCount()();
            int64_t v188 = v222 + 2;
            if (!__OFADD__(v222, 2LL))
            {
LABEL_177:
              if ((v2 & ~v17 & 0x2000000000000000LL) == 0
                || !swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
              {
                if (v188 <= 15) {
                  goto LABEL_188;
                }
                goto LABEL_193;
              }

              int64_t v189 = _StringGuts.nativeUnusedCapacity.getter(v2, v17);
              if ((v190 & 1) == 0)
              {
                BOOL v192 = (v17 & 0x2000000000000000LL) == 0 && v189 > 1;
                if (v188 <= 15 && !v192)
                {
LABEL_188:
                  swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
                  swift_bridgeObjectRetain(v17, v193, v194, v195);
                  unint64_t v196 = _StringGuts._convertedToSmall()(v2, v17);
                  unint64_t v198 = v197;
                  swift_bridgeObjectRelease(v17);
                  v199._rawBits = 1LL;
                  v200._rawBits = 131073LL;
                  v201._rawBits = _StringGuts.validateScalarRange(_:)(v199, v200, 0x295DuLL, 0xE200000000000000LL);
                  if (v201._rawBits < 0x10000) {
                    v201._rawBits |= 3;
                  }
                  unint64_t v203 = specialized String.init(_:)(v201, v202, 0x295DuLL, 0xE200000000000000LL);
                  unint64_t v205 = v204;
                  swift_bridgeObjectRelease(0xE200000000000000LL);
                  unint64_t v206 = _StringGuts._convertedToSmall()(v203, v205);
                  unint64_t v208 = v207;
                  swift_bridgeObjectRelease(v205);
                  unint64_t v209 = specialized _SmallString.init(_:appending:)(v196, v198, v206, v208);
                  if ((v210 & 1) == 0)
                  {
                    uint64_t v2 = v209;
                    swift_bridgeObjectRelease(v17);
                    swift_bridgeObjectRelease(v226);
                    swift_bridgeObjectRelease(0xE200000000000000LL);
                    return v2;
                  }

          v411 = v729;
          v412 = v272;
          v413 = (uint64_t)v782;
          v414 = v727;
          v415 = swift_getAssociatedConformanceWitness( (uint64_t)v729,  (uint64_t)v782,  v727,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v416 = v728;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v415 + 8))( &qword_18180BE70,  512LL,  v414,  v415);
          v417 = v730;
          (*((void (**)(char *, uint64_t, const char *))v411 + 3))(v416, v413, v411);
          v418 = v745;
          v419 = v744;
          (*(void (**)(uint64_t, uint64_t))(v745 + 112))(v413, v745);
          v420 = v417;
          v421 = (void (*)(char **, uint64_t))v759;
          ((void (*)(char *, uint64_t))v759)(v420, v413);
          (*(void (**)(char *, unint64_t, unint64_t *))(v412 + 32))(v404, v781, v125);
          v422 = v718;
          v423 = v752;
          (*((void (**)(char *, unint64_t *, void, unint64_t *))v719 + 11))( v404,  v125,  v267,  v752);
          v424 = (void (**)(char *, char *, unint64_t *))(*(void *)(v720 + 8) + 24LL);
          goto LABEL_106;
        }

        if (v401 <= 64)
        {
          v450 = (void (**)(char *, unint64_t *, const char *))v757;
          v451 = v755;
          v452 = swift_getAssociatedConformanceWitness( (uint64_t)v757,  (uint64_t)v125,  v755,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v453 = v756;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v452 + 8))( &unk_18180BE68,  256LL,  v451,  v452);
          v450[3](v453, v125, (const char *)v450);
          LOBYTE(v450) = (*(uint64_t (**)(uint64_t, char *, unint64_t *))(*(void *)(*(void *)(v267 + 32) + 8LL)
                                                                                        + 16LL))( v282,  v404,  v125);
          v408 = *(void (**)(char *, unint64_t *))(v272 + 8);
          v408(v404, v125);
          v454 = v685;
          (*(void (**)(char *, uint64_t, unint64_t *))(v272 + 16))(v685, v282, v125);
          if ((v450 & 1) != 0)
          {
            v408(v454, v125);
            goto LABEL_105;
          }

          v409 = (*(uint64_t (**)(unint64_t *, uint64_t))(v267 + 120))(v125, v267);
          v410 = v454;
LABEL_92:
          v408(v410, v125);
          if ((v409 & 0x8000000000000000LL) == 0) {
            goto LABEL_93;
          }
LABEL_105:
          v455 = v729;
          v456 = v282;
          v413 = (uint64_t)v782;
          v457 = v727;
          v458 = swift_getAssociatedConformanceWitness( (uint64_t)v729,  (uint64_t)v782,  v727,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v459 = v728;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v458 + 8))( &qword_18180BE70,  512LL,  v457,  v458);
          v460 = v730;
          (*((void (**)(char *, uint64_t, const char *))v455 + 3))(v459, v413, v455);
          v418 = v745;
          v461 = v744;
          (*(void (**)(uint64_t, uint64_t))(v745 + 112))(v413, v745);
          v462 = v460;
          v421 = (void (*)(char **, uint64_t))v759;
          ((void (*)(char *, uint64_t))v759)(v462, v413);
          (*(void (**)(uint64_t, unint64_t *))(*(void *)(AssociatedConformanceWitness + 16) + 16LL))( v456,  v125);
          v408((char *)v456, v125);
          v419 = v461;
          v422 = v718;
          v423 = v752;
          (*((void (**)(char *, unint64_t *, void, unint64_t *))v719 + 11))( v404,  v125,  v267,  v752);
          v424 = (void (**)(char *, char *, unint64_t *))(*(void *)(v720 + 8) + 40LL);
LABEL_106:
          v463 = v717;
          (*v424)(v419, v422, v423);
          v464 = v741;
          v465 = *(void (**)(char *, unint64_t *))(v741 + 8);
          v465(v422, v423);
          v465(v419, v423);
          (*(void (**)(char *, char *, unint64_t *))(v464 + 32))(v751, v463, v423);
          v466 = v778;
          v467 = (*(uint64_t (**)(uint64_t, uint64_t))(v418 + 136))(v413, v418);
          v421(v466, v413);
          v468 = v771;
          v469 = v779;
          v777 = *(void *)(v771 + 136);
          v470 = ((uint64_t (*)(uint64_t, uint64_t))v777)(v779, v771);
          v471 = v763;
          v778 = *(char ***)(v468 + 120);
          ((void (*)(uint64_t, uint64_t))v778)(v469, v468);
          v472 = v753;
          v473 = (uint64_t)v743;
          v773 = *(void *)(v753 + 144);
          v474 = ((uint64_t (*)(unint64_t *, uint64_t))v773)(v743, v753);
          v774 = *(char ***)(v734 + 8);
          ((void (*)(char *, uint64_t))v774)(v471, v473);
          v776 = (char *)v467;
          v781 = v467 - v470 - v474;
          LOBYTE(v470) = (*(uint64_t (**)(uint64_t))(v764 + 392))(v469);
          v475 = v760;
          v476 = v738;
          v477 = swift_getAssociatedConformanceWitness( (uint64_t)v760,  v473,  v738,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v478 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v477 + 8);
          if ((v470 & 1) != 0)
          {
            v479 = v737;
            v478(&qword_18180BE70, 512LL, v476, v477);
            (*((void (**)(char *, uint64_t, const char *))v475 + 3))(v479, v473, v475);
            v480 = ((uint64_t (*)(uint64_t, uint64_t))v777)(v469, v468);
            v481 = v736;
            v482 = v468;
            v381 = v778;
            ((void (*)(uint64_t, uint64_t))v778)(v469, v482);
            v483 = ((uint64_t (*)(uint64_t, uint64_t))v773)(v473, v472);
            v484 = v746;
            v485 = v483;
            v486 = v774;
            v487 = ((uint64_t (*)(char *, uint64_t))v774)(v481, v473);
            v783 = v485 + v480;
            v488 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v472 + 256);
            v491 = lazy protocol witness table accessor for type Int and conformance Int(v487, v489, v490);
            v492 = v721;
            v488(v471, &v783, &type metadata for Int, v491, v473, v472);
            ((void (*)(char *, uint64_t))v486)(v471, v473);
            v388 = v486;
          }

          else
          {
            v493 = v737;
            v478((uint64_t *)&unk_18180BE68, 256LL, v476, v477);
            v492 = v721;
            (*((void (**)(char *, uint64_t, const char *))v475 + 3))(v493, v473, v475);
            v481 = v736;
            v484 = v746;
            v388 = v774;
            v381 = v778;
          }

          v494 = v735;
          v495 = v781;
          if ((v781 & 0x8000000000000000LL) != 0)
          {
            v448 = (uint64_t)v725;
            ((void (*)(uint64_t, uint64_t))v381)(v779, v771);
            (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v472 + 224))(v492, v448, v473, v472);
            ((void (*)(uint64_t, uint64_t))v388)(v448, v473);
            v505 = ((uint64_t (*)(char *, uint64_t))v388)(v492, v473);
            if (__OFSUB__(0LL, v781))
            {
              __break(1u);
              goto LABEL_153;
            }

            v783 = -(uint64_t)v781;
            v508 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v472 + 240);
            v509 = lazy protocol witness table accessor for type Int and conformance Int(v505, v506, v507);
            v510 = v763;
            v508(v481, &v783, &type metadata for Int, v509, v473, v472);
            ((void (*)(char *, uint64_t))v388)(v481, v473);
            v503 = v716;
            ((void (*)(char *, uint64_t, uint64_t, unint64_t *, void *))v494[11])( v510,  v473,  v472,  v484,  v494);
            v504 = v748;
          }

          else
          {
            ((void (*)(uint64_t, uint64_t))v381)(v779, v771);
            v496 = v763;
            (*(void (**)(char *, char *, uint64_t, uint64_t))(v472 + 224))(v492, v481, v473, v472);
            ((void (*)(char *, uint64_t))v388)(v481, v473);
            ((void (*)(char *, uint64_t))v388)(v492, v473);
            v497 = v749;
            v498 = ((uint64_t (*)(char *, uint64_t, uint64_t, unint64_t *, void *))v494[11])( v496,  v473,  v472,  v484,  v494);
            v783 = v495;
            v499 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, void *))v494[32];
            v502 = lazy protocol witness table accessor for type Int and conformance Int(v498, v500, v501);
            v503 = v716;
            v499(v497, &v783, &type metadata for Int, v502, v484, v494);
            v504 = v748;
            (*(void (**)(char *, unint64_t *))(v748 + 8))(v497, v484);
          }

          v511 = v740;
          (*(void (**)(char *, char *, unint64_t *))(v504 + 32))(v740, v503, v484);
          v512 = v764;
LABEL_125:
          v565 = v779;
          v773 = *(void *)(v512 + 168);
          v566 = ((uint64_t (*)(uint64_t, uint64_t))v773)(v779, v512) & 1;
          v567 = v744;
          (*(void (**)(char *, char *, unint64_t *))(v741 + 32))(v744, v751, v752);
          v568 = v749;
          (*(void (**)(char *, char *, unint64_t *))(v504 + 16))(v749, v511, v484);
          v569 = v747;
          v570 = v568;
          v571 = (uint64_t)v782;
          (*(void (**)(uint64_t, char *, char *, char **))(v745 + 56))(v566, v567, v570, v782);
          v572 = ((uint64_t (*)(uint64_t, uint64_t))v777)(v565, v771);
          if ((uint64_t)v776 < v572)
          {
            v573 = v760;
            v574 = v738;
            v575 = swift_getAssociatedConformanceWitness( (uint64_t)v760,  v473,  v738,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v576 = v737;
            v777 = *(void *)(v575 + 8);
            ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v777)( &qword_18180BE70,  512LL,  v574,  v575);
            v577 = v763;
            v578 = v473;
            v776 = (char *)*((void *)v573 + 3);
            v579 = ((uint64_t (*)(char *, uint64_t, const char *))v776)(v576, v473, v573);
            if (!__OFSUB__(0LL, v781))
            {
              v783 = -(uint64_t)v781;
              v583 = v574;
              v584 = v753;
              v585 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v753 + 256);
              v586 = lazy protocol witness table accessor for type Int and conformance Int(v579, v580, v581);
              v585(v577, &v783, &type metadata for Int, v586, v473, v584);
              v587 = v774;
              ((void (*)(char *, uint64_t))v774)(v577, v473);
              ((void (*)(uint64_t, uint64_t))v778)(v565, v771);
              ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v777)( &qword_18180BE70,  512LL,  v583,  v575);
              v588 = v725;
              ((void (*)(char *, uint64_t, const char *))v776)(v576, v473, v760);
              v589 = *(void (**)(char *, char *, uint64_t))(*(void *)(v707 + 8) + 40LL);
              v781 = v575;
              v590 = v736;
              v589(v739, v588, v473);
              ((void (*)(char *, uint64_t))v587)(v588, v473);
              v591 = v731;
              (*(void (**)(char *, char *, uint64_t, uint64_t))(v584 + 192))(v577, v590, v473, v584);
              ((void (*)(char *, uint64_t))v587)(v590, v473);
              ((void (*)(char *, uint64_t))v587)(v577, v473);
              ((void (*)(void *, uint64_t, unint64_t, unint64_t))v777)( &unk_18180BE80,  768LL,  v583,  v781);
              v592 = v739;
              ((void (*)(char *, uint64_t, const char *))v776)(v576, v473, v760);
              v593 = v592;
              v778 = *(char ***)(v584 + 152);
              ((void (*)(char *, char *, uint64_t, uint64_t))v778)(v592, v590, v473, v584);
              ((void (*)(char *, uint64_t))v587)(v590, v473);
              v594 = *(void *)(*(void *)(v584 + 32) + 8LL);
              LOBYTE(v592) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v594 + 16))( v591,  v577,  v473,  v594);
              ((void (*)(char *, uint64_t))v587)(v577, v473);
              if ((v592 & 1) != 0)
              {
                ((void (*)(char *, uint64_t))v587)(v731, v473);
                ((void (*)(char *, uint64_t))v587)(v593, v473);
                (*(void (**)(char *, unint64_t *))(v748 + 8))(v740, v746);
                (*(void (**)(char *, char *, char **))(v767 + 32))((char *)v754, v747, v782);
              }

              else
              {
                v596 = ((uint64_t (*)(uint64_t, uint64_t))v773)(v779, v764);
                v597 = 328LL;
                if ((v596 & 1) == 0) {
                  v597 = 320LL;
                }
                v598 = v698;
                (*(void (**)(char **))(v775 + v597))(v782);
                v599 = v737;
                ((void (*)(void *, uint64_t))v777)(&unk_18180BE80, 768LL);
                ((void (*)(char *, uint64_t, const char *))v776)(v599, v473, v760);
                ((void (*)(char *, char *, uint64_t, uint64_t))v778)(v593, v590, v473, v584);
                ((void (*)(char *, uint64_t))v587)(v590, v473);
                ((void (*)(char *, uint64_t))v587)(v593, v473);
                v600 = v731;
                LOBYTE(v599) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v594 + 40))( v731,  v577,  v473,  v594);
                ((void (*)(char *, uint64_t))v587)(v577, v473);
                ((void (*)(char *, uint64_t))v587)(v600, v473);
                if ((v599 & 1) != 0)
                {
                  v601 = (uint64_t)v782;
                  ((void (*)(char *, char **))v759)(v747, v782);
                  (*(void (**)(char *, unint64_t *))(v748 + 8))(v740, v746);
                  (*(void (**)(char *, char *, uint64_t))(v767 + 32))((char *)v754, v598, v601);
                }

                else
                {
                  v658 = v735;
                  v659 = (uint64_t (*)(unint64_t *, void *))v735[18];
                  v660 = v740;
                  v661 = v746;
                  v662 = v659(v746, v735);
                  v663 = v598;
                  v664 = *(void (**)(char *, unint64_t *))(v748 + 8);
                  v664(v660, v661);
                  v665 = v749;
                  v666 = (uint64_t)v782;
                  (*(void (**)(char **))(v745 + 120))(v782);
                  v667 = v659(v661, v658);
                  v664(v665, v661);
                  if (v667 >= v662)
                  {
                    ((void (*)(char *, uint64_t))v759)(v747, v666);
                    v668 = *(void (**)(char *, char *, uint64_t))(v767 + 32);
                    v669 = v677;
                    v668(v677, v663, v666);
                  }

                  else
                  {
                    ((void (*)(char *, uint64_t))v759)(v663, v666);
                    v668 = *(void (**)(char *, char *, uint64_t))(v767 + 32);
                    v669 = v677;
                    v668(v677, v747, v666);
                  }

                  v668((char *)v754, v669, v666);
                }
              }

              return 0LL;
            }

            __break(1u);
LABEL_149:
            v657 = v730;
            v582((char **)v578);
            (*(void (**)(char *, uint64_t))(v702 + 16))(v657, v578);
            (*(void (**)(char *, uint64_t))(v767 + 8))(v657, v578);
            return 1LL;
          }

          (*(void (**)(char *, unint64_t *))(v504 + 8))(v511, v484);
          (*(void (**)(char *, char *, uint64_t))(v767 + 32))((char *)v754, v569, v571);
          return 1LL;
        }
      }

      v783 = 0LL;
      v406 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v267 + 96);
      v407 = lazy protocol witness table accessor for type Int and conformance Int(v401, v402, v403);
      v406(&v783, &type metadata for Int, v407, v125, v267);
      LOBYTE(v406) = (*(uint64_t (**)(uint64_t, char *, unint64_t *))(*(void *)(*(void *)(v267 + 32)
                                                                                                + 8LL)
                                                                                    + 16LL))( v282,  v404,  v125);
      v408 = *(void (**)(char *, unint64_t *))(v272 + 8);
      v408(v404, v125);
      goto LABEL_93;
    }

    if (v165 < v164)
    {
      Swift::String::Index v167 = (uint64_t)v52;
      Swift::String::Index v168 = v773;
      Swift::String::Index v169 = v776;
      (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v773 + 96))( v766,  v167,  v161,  v125,  v773);
      unint64_t v170 = v781;
      unint64_t v171 = (*(uint64_t (**)(unint64_t, char *, unint64_t *))(*(void *)(*(void *)(v168 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v781,  v169,  v125);
      (*(void (**)(char *, unint64_t *))(v777 + 8))(v169, v125);
LABEL_19:
      unint64_t v180 = (uint64_t)v782;
      goto LABEL_21;
    }

    unint64_t v182 = (void (**)(char *, unint64_t *, const char *))v757;
    Swift::Int v183 = v755;
    uint64_t v184 = swift_getAssociatedConformanceWitness( (uint64_t)v757,  (uint64_t)v125,  v755,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v185 = v756;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v184 + 8))( &unk_18180BE68,  256LL,  v183,  v184);
    unint64_t v186 = v776;
    v182[3](v185, v125, (const char *)v182);
    unint64_t v187 = v773;
    int64_t v188 = v781;
    LOBYTE(v182) = (*(uint64_t (**)(unint64_t, char *, unint64_t *))(*(void *)(*(void *)(v773 + 32) + 8LL)
                                                                                           + 16LL))( v781,  v186,  v125);
    int64_t v189 = v777;
    char v190 = *(void (**)(char *, unint64_t *))(v777 + 8);
    v190(v186, v125);
    (*(void (**)(char *, uint64_t, unint64_t *))(v189 + 16))(v149, v188, v125);
    v191 = v772;
    BOOL v192 = v701;
    (*(void (**)(char *, char *, unint64_t *))(v772 + 32))(v701, v766, v52);
    if ((v182 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t *))(v191 + 8))(v192, v52);
      v190(v149, v125);
      unint64_t v170 = v781;
      unint64_t v180 = (uint64_t)v782;
      Swift::String::Index v167 = (uint64_t)v52;
      Swift::String::Index v168 = v187;
      Swift::String::Index v169 = v776;
      goto LABEL_22;
    }

    unint64_t v207 = v187;
    unint64_t v208 = v774;
    unint64_t v209 = v770;
    ((void (*)(char *, unint64_t *, uint64_t, unint64_t *, char **))v774[12])( v149,  v125,  v207,  v52,  v774);
    unint64_t v171 = (*(uint64_t (**)(char *, char *, unint64_t *))(*((void *)v208[4] + 1) + 16LL))( v209,  v192,  v52);
    char v210 = *(void (**)(char *, unint64_t *))(v191 + 8);
    v210(v209, v52);
    v210(v192, v52);
    unint64_t v170 = v781;
    unint64_t v180 = (uint64_t)v782;
    v211 = v52;
    Swift::String::Index v168 = v207;
    Swift::String::Index v166 = v208;
    Swift::String::Index v167 = (uint64_t)v211;
    Swift::String::Index v169 = v776;
  }

  else
  {
    v765 = *(char **)(v159 + 128);
    unint64_t v172 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v159);
    v761 = v161[16];
    unint64_t v173 = v172 < ((uint64_t (*)(unint64_t *, char **))v761)(v52, v161);
    unint64_t v170 = v154;
    Swift::String::Index v167 = (uint64_t)v52;
    if (v173)
    {
      Swift::String::Index v169 = v776;
      Swift::String::Index v168 = v159;
      (*(void (**)(char *, uint64_t, unint64_t *))(v777 + 16))(v776, v170, v125);
      unint64_t v174 = v770;
      ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v161[12])( v169,  v125,  v168,  v167,  v161);
      unint64_t v171 = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v161[4] + 1) + 16LL))(v174, v158, v167);
      unint64_t v175 = *(void (**)(char *, uint64_t))(v772 + 8);
      v175(v174, v167);
      v175(v158, v167);
    }

    else
    {
      Swift::String::Index v168 = v159;
      Swift::String::Index v169 = v776;
      (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v159 + 96))( v158,  v167,  v161,  v125,  v159);
      unint64_t v171 = (*(uint64_t (**)(uint64_t, char *, unint64_t *))(*(void *)(*(void *)(v159 + 32) + 8LL)
                                                                            + 16LL))( v170,  v169,  v125);
      (*(void (**)(char *, unint64_t *))(v777 + 8))(v169, v125);
    }

    Swift::String::Index v166 = v161;
    unint64_t v180 = (uint64_t)v782;
  }

          unint64_t v76 = _StringGuts.nativeUnusedCapacity.getter(v73, v9);
          uint64_t v45 = (v77 & 1) == 0 && v76 >= v71;
          if ((v73 & ~v9 & 0x2000000000000000LL) == 0
            || !swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
          {
            if ((v45 & 1) == 0) {
              goto LABEL_104;
            }
LABEL_110:
            _StringGuts.grow(_:)(v1);
            goto LABEL_111;
          }

          if ((v45 & 1) != 0)
          {
LABEL_111:
            swift_bridgeObjectRelease_n(v8, 4LL);
            if ((v8 & 0x1000000000000000LL) == 0)
            {
              id v1 = v185;
              if (v68)
              {
                swift_bridgeObjectRelease_n(v8, 2LL);
                *(void *)&v186[0] = v11;
                *((void *)&v186[0] + 1) = v8 & 0xFFFFFFFFFFFFFFLL;
                unint64_t v83 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v8) & 0xF,  (uint64_t)v186,  HIBYTE(v8) & 0xF);
                _StringGuts.appendInPlace(_:isASCII:)(v83, v84, (v8 & 0x4000000000000000LL) != 0);
                uint64_t v2 = v184;
                swift_bridgeObjectRelease(v8);
              }

              else
              {
                if ((v11 & 0x1000000000000000LL) != 0)
                {
                  swift_bridgeObjectRelease(v8);
                  unint64_t v101 = (id)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  id v102 = v183;
                  uint64_t v103 = v183;
                }

                else
                {
                  unint64_t v101 = _StringObject.sharedUTF8.getter(v11, v8);
                  uint64_t v103 = v176;
                  swift_bridgeObjectRelease(v8);
                  if (v103 < v183) {
                    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
                  }
                  id v1 = v185;
                  id v102 = v183;
                }

                uint64_t v104 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v102, (uint64_t)v101, v103);
                _StringGuts.appendInPlace(_:isASCII:)(v104, v105, v11 < 0);
                swift_bridgeObjectRelease_n(v8, 2LL);
                uint64_t v2 = v184;
              }

              goto LABEL_159;
            }

            swift_bridgeObjectRelease(v8);
            _StringGuts._foreignAppendInPlace(_:)(v11, v8, 0LL, v2);
            swift_bridgeObjectRelease_n(v8, 2LL);
            uint64_t v2 = v184;
LABEL_121:
            id v1 = v185;
            goto LABEL_159;
          }

            id v102 = _StringGuts.nativeCapacity.getter(v12, v46);
            if ((v103 & 1) != 0) {
              uint64_t v104 = 0LL;
            }
            else {
              uint64_t v104 = v102;
            }
            if (v104 + 0x4000000000000000LL < 0)
            {
              __break(1u);
              goto LABEL_250;
            }

            unint64_t v105 = 2 * v104;
            if (v105 > v66) {
              uint64_t v66 = v105;
            }
          }

          else
          {
            uint64_t v4 = v246;
            if (!v73) {
              goto LABEL_93;
            }
          }

          _StringGuts.grow(_:)(v66);
          goto LABEL_100;
        }

        goto LABEL_158;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(v13, 4LL, v64, v65);
      if ((v46 & 0x1000000000000000LL) != 0) {
        goto LABEL_156;
      }
    }

    uint64_t v21 = __OFADD__(v62, v4);
    uint64_t v66 = v62 + v4;
    if (!v21) {
      goto LABEL_56;
    }
LABEL_158:
    __break(1u);
LABEL_159:
    v158 = String.UTF8View._foreignCount()();
    unint64_t v22 = v158 + 6;
    if (__OFADD__(v158, 6LL)) {
      goto LABEL_161;
    }
LABEL_13:
    if ((v12 & ~v13 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      char v23 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
      if ((v24 & 1) != 0) {
        goto LABEL_255;
      }
      uint64_t v26 = (v13 & 0x2000000000000000LL) == 0 && v23 > 5;
      if (v22 > 15 || v26) {
        goto LABEL_29;
      }
LABEL_24:
      swift_bridgeObjectRelease_n(0xE600000000000000LL, 5LL);
      swift_bridgeObjectRetain(v13, v27, v28, v29);
      Swift::String::Index v30 = _StringGuts._convertedToSmall()(v12, v13);
      Swift::String::Index v32 = v31;
      swift_bridgeObjectRelease(v13);
      v33._rawBits = 1LL;
      v34._rawBits = 393217LL;
      v35._rawBits = _StringGuts.validateScalarRange(_:)(v33, v34, 0x2865676E6152uLL, 0xE600000000000000LL);
      if (v35._rawBits < 0x10000) {
        v35._rawBits |= 3;
      }
      unint64_t v37 = specialized String.init(_:)(v35, v36, 0x2865676E6152uLL, 0xE600000000000000LL);
      unint64_t v39 = v38;
      swift_bridgeObjectRelease(0xE600000000000000LL);
      unint64_t v40 = _StringGuts._convertedToSmall()(v37, v39);
      char v42 = v41;
      swift_bridgeObjectRelease(v39);
      unint64_t v43 = specialized _SmallString.init(_:appending:)(v30, v32, v40, v42);
      if ((v45 & 1) != 0) {
        goto LABEL_254;
      }
      uint64_t v12 = v43;
      uint64_t v46 = v44;
      swift_bridgeObjectRelease(v13);
      swift_bridgeObjectRelease(0xE600000000000000LL);
      v253 = v12;
      v254 = v46;
      uint64_t v3 = v251;
    }

    else
    {
      if (v22 <= 15) {
        goto LABEL_24;
      }
LABEL_29:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v22, 6LL);
      swift_bridgeObjectRelease_n(0xE600000000000000LL, 6LL);
      v252 = xmmword_1817FFDB0;
      unint64_t v47 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 6LL, (uint64_t)&v252, 6LL);
      _StringGuts.appendInPlace(_:isASCII:)(v47, v48, 1);
      swift_bridgeObjectRelease(0xE600000000000000LL);
      uint64_t v12 = v253;
      uint64_t v46 = v254;
    }
  }

  size_t v63 = v61 + v7;
  if ((unint64_t)(v61 + v7) > 0xF)
  {
    uint64_t v3 = 1LL;
    goto LABEL_50;
  }

  uint64_t v3 = v251;
  if (v7)
  {
    uint64_t v108 = 0;
    uint64_t v109 = 0LL;
    unint64_t v110 = v46;
    do
    {
      unint64_t v111 = v61 + v109;
      unint64_t v112 = v109 + 1;
      if (v109 >= 8) {
        uint64_t v113 = *((void *)&v252 + 1);
      }
      else {
        uint64_t v113 = v252;
      }
      uint64_t v114 = v113 >> (v108 & 0x38);
      uint64_t v115 = (8 * v61 + v108) & 0x38;
      unint64_t v116 = (-255LL << v115) - 1;
      uint64_t v117 = (unint64_t)v114 << v115;
      uint64_t v118 = v117 | v116 & v110;
      uint64_t v119 = v117 | v116 & v12;
      if (v111 < 8) {
        uint64_t v12 = v119;
      }
      else {
        unint64_t v110 = v118;
      }
      v108 += 8;
      uint64_t v109 = v112;
    }

    while (v7 != v112);
  }

  else
  {
    unint64_t v110 = v46;
  }

  swift_bridgeObjectRelease(v46);
  swift_bridgeObjectRelease(v13);
  uint64_t v125 = 0xA000000000000000LL;
  if (!(v12 & 0x8080808080808080LL | v110 & 0x80808080808080LL)) {
    uint64_t v125 = 0xE000000000000000LL;
  }
  v253 = v12;
  v254 = v125 & 0xFF00000000000000LL | (v63 << 56) | v110 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v7 = v247;
  while (1)
  {
LABEL_128:
    uint64_t v2 = v253;
    uint64_t v12 = v254;
    uint64_t v126 = HIBYTE(v254) & 0xF;
    uint64_t v127 = v253 & 0xFFFFFFFFFFFFLL;
    if ((v254 & 0x2000000000000000LL) != 0) {
      uint64_t v128 = HIBYTE(v254) & 0xF;
    }
    else {
      uint64_t v128 = v253 & 0xFFFFFFFFFFFFLL;
    }
    if (!v128 && (v253 & ~v254 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v254);
      uint64_t v2 = 0LL;
      v253 = 0LL;
      uint64_t v151 = 0xE000000000000000LL;
      goto LABEL_165;
    }

    if ((v254 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v254);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      char v152 = 0xA000000000000000LL;
      if (!(v12 & 0x80808080808080LL | v2 & 0x8080808080808080LL)) {
        char v152 = 0xE000000000000000LL;
      }
      uint64_t v151 = v152 & 0xFF00000000000000LL | (v126 << 56) | v12 & 0xFFFFFFFFFFFFFFLL;
      v253 = v2;
      goto LABEL_165;
    }

    swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v99, v100);
    if ((v12 & 0x1000000000000000LL) != 0)
    {
LABEL_162:
      uint64_t v127 = String.UTF8View._foreignCount()();
      if ((v2 & ~v12 & 0x2000000000000000LL) == 0) {
        goto LABEL_163;
      }
    }

    else if ((v2 & ~v12 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_163;
    }

    if (swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v129 = _StringGuts.nativeUnusedCapacity.getter(v2, v12);
      if ((v130 & 1) != 0) {
        goto LABEL_255;
      }
      if (v127 > 15 || (v129 & 0x8000000000000000LL) == 0)
      {
LABEL_164:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v127, 0LL);
        swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
        v252 = 0uLL;
        BOOL v159 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v252, 0LL);
        _StringGuts.appendInPlace(_:isASCII:)(v159, v160, 1);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        uint64_t v2 = v253;
        uint64_t v151 = v254;
        goto LABEL_165;
      }

      goto LABEL_140;
    }

  (*(void (**)(char *, uint64_t, uint64_t, swift *))(v8 + 56))(v35, 1LL, 1LL, a2);
  uint64_t v109 = v53;
LABEL_94:
  outlined consume of [A : B].Iterator._Variant<A, B>(v109);
  return v129;
}

            __break(1u);
            goto LABEL_94;
          }
        }

        else
        {
          if (v54)
          {
            uint64_t v113 = (v54 - 1) & v54;
            uint64_t v114 = v55;
            uint64_t v56 = __clz(__rbit64(v54)) | (v55 << 6);
LABEL_68:
            (*(void (**)(char *, unint64_t, char *))(v8 + 16))( v23,  *(void *)(v39 + 48) + *(void *)(v8 + 72) * v56,  v5);
            size_t v63 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
            goto LABEL_69;
          }

          uint64_t v64 = v55 + 1;
          if (!__OFADD__(v55, 1LL))
          {
            if (v64 < v109)
            {
              uint64_t v65 = *(void *)(v106 + 8 * v64);
              if (v65)
              {
LABEL_67:
                uint64_t v113 = (v65 - 1) & v65;
                uint64_t v114 = v64;
                uint64_t v56 = __clz(__rbit64(v65)) + (v64 << 6);
                goto LABEL_68;
              }

              uint64_t v66 = v55 + 2;
              if (v55 + 2 < v109)
              {
                uint64_t v65 = *(void *)(v106 + 8 * v66);
                if (v65)
                {
                  uint64_t v64 = v55 + 2;
                  goto LABEL_67;
                }

                while (1)
                {
                  uint64_t v64 = v66 + 1;
                  if (__OFADD__(v66, 1LL)) {
                    break;
                  }
                  if (v64 >= v109) {
                    goto LABEL_85;
                  }
                  uint64_t v65 = *(void *)(v106 + 8 * v64);
                  ++v66;
                  if (v65) {
                    goto LABEL_67;
                  }
                }

                __break(1u);
                goto LABEL_93;
              }
            }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56))(v105, 1LL, 1LL, a2);
  uint64_t v137 = v157;
LABEL_100:
  outlined consume of [A : B].Iterator._Variant<A, B>(v137);
  return (uint64_t)v162;
}

  if (v11) {
    uint64_t v48 = v24;
  }
  else {
    uint64_t v48 = 0;
  }
  size_t v49 = a5;
  uint64_t v50 = v34;
  if (v48)
  {
    std::string::append((std::string *)a1, v12, v11);
    if ((v31 & 0x80000000) == 0)
    {
      snprintf(__str, 0x20uLL, "%lld", v31);
      std::string::append((std::string *)a1, __str);
    }

    std::string::append((std::string *)a1, " of ", 4uLL);
    unint64_t v11 = 0LL;
    LODWORD(v31) = -1;
    uint64_t v12 = "";
  }

  else {
    uint64_t v51 = *(void *)(a1 + 8);
  }
  if (v37)
  {
    std::string::append((std::string *)a1, __sa, v37);
    uint64_t v46 = a3;
    unint64_t v47 = v87;
    goto LABEL_105;
  }

  uint64_t v56 = *((unsigned __int8 *)v17 + 18);
  Swift::Int v57 = v17;
  if (v56 == 5) {
    Swift::Int v57 = (uint64_t *)*v17;
  }
  int64_t v58 = (swift::Demangle::__runtime::Node *)v57[1];
  uint64_t v46 = a3;
  if (*((_WORD *)v58 + 8) != 176)
  {
    uint64_t v56 = *((unsigned __int8 *)v17 + 18);
  }

  unint64_t v59 = (swift::Demangle::__runtime::Node **)v17;
  unint64_t v47 = v87;
  if ((v56 - 1) >= 2)
  {
    if (v56 == 5)
    {
      int64_t v60 = (uint64_t *)*v17;
      unint64_t v59 = (swift::Demangle::__runtime::Node **)*v17;
      goto LABEL_191;
    }

    unint64_t v59 = 0LL;
  }

  if (v56 == 1)
  {
    Swift::String::Index v74 = (swift::Demangle::__runtime::Node **)(v17 + 1);
    goto LABEL_221;
  }

  if (v56 == 2)
  {
    Swift::String::Index v74 = (swift::Demangle::__runtime::Node **)(v17 + 2);
    goto LABEL_221;
  }

  if (v56 != 5)
  {
    Swift::String::Index v74 = 0LL;
    goto LABEL_221;
  }

  int64_t v60 = (uint64_t *)*v17;
LABEL_191:
  Swift::String::Index v74 = (swift::Demangle::__runtime::Node **)&v60[*((unsigned int *)v17 + 2)];
LABEL_221:
  if (v59 != v74)
  {
    while (*((_WORD *)*v59 + 8) != 176)
    {
      if (++v59 == v74)
      {
        unint64_t v59 = v74;
        break;
      }
    }
  }

  switch(v56)
  {
    case 5:
      unint64_t v83 = *v17 + 8LL * *((unsigned int *)v17 + 2);
      break;
    case 2:
      unint64_t v83 = (uint64_t)(v17 + 2);
      break;
    case 1:
      unint64_t v83 = (uint64_t)(v17 + 1);
      break;
    default:
      unint64_t v83 = 0LL;
      break;
  }

  if (v59 != (swift::Demangle::__runtime::Node **)v83 && *v59) {
LABEL_105:
  }
  int64_t v52 = *(unsigned __int8 *)(a1 + 23);
  if ((v52 & 0x80u) != 0LL) {
    int64_t v52 = *(void *)(a1 + 8);
  }
  if (v52 == v51)
  {
    unint64_t v34 = v50;
    a5 = v49;
    if (!v11) {
      goto LABEL_114;
    }
  }

  else
  {
    unint64_t v34 = v50;
    a5 = v49;
    if (!v11) {
      goto LABEL_114;
    }
    std::string::push_back((std::string *)a1, 46);
  }

            *((_DWORD *)v5 + 3184) = v88 + 1;
            v54[v88] = v90;
            unint64_t v38 = v133;
LABEL_94:
            uint64_t v55 = v126;
LABEL_95:
            uint64_t v51 = v55 + 1;
            if (v51 == v123) {
              goto LABEL_197;
            }
            continue;
          }

          break;
        }

        if (v88 >= v89)
        {
          unint64_t v93 = (char *)v87[1];
          if (&v54[v89] != v93)
          {
            unint64_t v94 = v87[2];
            goto LABEL_164;
          }

          unint64_t v100 = (unint64_t)&v54[v89 + 1];
          unint64_t v94 = v87[2];
          if (v100 <= v94)
          {
            v87[1] = v100;
            LODWORD(v101) = 1;
          }

          else
          {
LABEL_164:
            else {
              unint64_t v101 = (2 * v89);
            }
            id v102 = v101 + v89;
            if (!v93 || (unint64_t)&v93[v102] > v94)
            {
              uint64_t v103 = 2LL * v87[4];
              if (v103 <= v102 + 1) {
                uint64_t v103 = v102 + 1;
              }
              v87[4] = v103;
              uint64_t v121 = v103 + 8;
              uint64_t v104 = malloc(v103 + 8);
              *uint64_t v104 = v87[3];
              unint64_t v93 = (char *)(v104 + 1);
              v87[2] = (char *)v104 + v121;
              v87[3] = v104;
            }

            v87[1] = &v93[v102];
            if ((_DWORD)v89)
            {
              memcpy(v93, v5[1591], v89);
              LODWORD(v89) = *((_DWORD *)v5 + 3185);
              unint64_t v88 = *((_DWORD *)v5 + 3184);
            }

            *(void *)uint64_t v128 = v93;
            unint64_t v54 = v93;
          }

          *((_DWORD *)v5 + 3185) = v89 + v101;
        }

        *((_DWORD *)v5 + 3184) = v88 + 1;
        v54[v88] = v86 + 65;
        uint64_t v55 = v126;
        unint64_t v38 = v133;
        if (v52 != a3) {
          goto LABEL_95;
        }
        unint64_t v88 = *((_DWORD *)v5 + 3184);
        unint64_t v105 = *((unsigned int *)v5 + 3185);
        unint64_t v54 = (char *)v5[1591];
        if (v88 < v105)
        {
          char v90 = 48;
          int64_t v52 = a3;
          goto LABEL_93;
        }

        size_t v106 = v5[1593];
        unint64_t v91 = (char *)v106[1];
        if (&v54[v105] != v91)
        {
          unint64_t v107 = v106[2];
          goto LABEL_184;
        }

        uint64_t v108 = (unint64_t)&v54[v105 + 1];
        unint64_t v107 = v106[2];
        if (v108 <= v107)
        {
          v106[1] = v108;
          LODWORD(v109) = 1;
          unint64_t v91 = v54;
          int64_t v52 = a3;
        }

        else
        {
LABEL_184:
          else {
            uint64_t v109 = (2 * v105);
          }
          unint64_t v110 = v109 + v105;
          if (!v91 || (unint64_t)&v91[v110] > v107)
          {
            unint64_t v111 = 2LL * v106[4];
            if (v111 <= v110 + 1) {
              unint64_t v111 = v110 + 1;
            }
            v106[4] = v111;
            unint64_t v112 = v111 + 8;
            uint64_t v113 = malloc(v111 + 8);
            uint64_t *v113 = v106[3];
            unint64_t v91 = (char *)(v113 + 1);
            v106[2] = (char *)v113 + v112;
            v106[3] = v113;
          }

          v106[1] = &v91[v110];
          if ((_DWORD)v105)
          {
            memcpy(v91, v5[1591], v105);
            LODWORD(v105) = *((_DWORD *)v5 + 3185);
            unint64_t v88 = *((_DWORD *)v5 + 3184);
          }

          int64_t v52 = a3;
          *(void *)uint64_t v128 = v91;
        }

        unint64_t v53 = v105 + v109;
        char v90 = 48;
        goto LABEL_92;
      }
    }

    if (v3 >= v19) {
      char v23 = v19;
    }
    else {
      char v23 = v3;
    }
    uint64_t v24 = &v4[v23];
    uint64_t v25 = v3 - v23;
    if (v25 >= v18 - v19) {
      uint64_t v26 = v18 - v19;
    }
    else {
      uint64_t v26 = v25;
    }
    if (!(_DWORD)v131) {
      goto LABEL_55;
    }
    unint64_t v27 = 0LL;
    unint64_t v28 = v5[1591];
    unint64_t v29 = *((unsigned int *)v5 + 3184);
    Swift::String::Index v30 = (unint64_t *)(*v130 + 8LL);
    while (1)
    {
      Swift::String::Index v31 = *(v30 - 1);
      Swift::String::Index v32 = *v30;
      if (v29 < v31) {
        Swift::String::Index v31 = v29;
      }
      if (v29 - v31 < v32) {
        Swift::String::Index v32 = v29 - v31;
      }
      v30 += 2;
      if (v131 == ++v27) {
        goto LABEL_55;
      }
    }

    if ((v27 & 0x80000000) == 0)
    {
      uint64_t v4 = v129;
    }

    else
    {
LABEL_55:
      Swift::String::Index v33 = *((unsigned int *)v5 + 3192);
      uint64_t v4 = v129;
      unint64_t v34 = v131;
      unint64_t v35 = (unint64_t *)(*v130 + v122);
      while (1)
      {
        unint64_t v36 = *(v35 - 1);
        unint64_t v37 = *v35;
        if (a3 < v36) {
          unint64_t v36 = a3;
        }
        if (a3 - v36 < v37) {
          unint64_t v37 = a3 - v36;
        }
        if (v26 == v37 && (!v26 || !memcmp(v24, &v129[v36], v26))) {
          break;
        }
        v35 += 2;
        if (v33 == ++v34) {
          goto LABEL_67;
        }
      }

      if ((v34 & 0x80000000) != 0)
      {
LABEL_67:
        uint64_t v3 = a3;
        if (v18 - v19 < 2 || v33 > 0x19)
        {
LABEL_20:
          else {
            uint64_t v19 = v18;
          }
          goto LABEL_29;
        }

        __p.__r_.__value_.__r.__words[0] = v19;
        __p.__r_.__value_.__l.__size_ = v18 - v19;
        swift::Demangle::__runtime::Vector<swift::Mangle::__runtime::WordReplacement>::push_back( (uint64_t)v130,  (__n128 *)&__p,  *v5);
LABEL_19:
        uint64_t v3 = a3;
        goto LABEL_20;
      }

      LODWORD(v27) = v34;
    }

    __p.__r_.__value_.__r.__words[0] = v19;
    LODWORD(__p.__r_.__value_.__r.__words[1]) = v27;
    swift::Demangle::__runtime::Vector<swift::Mangle::__runtime::WordReplacement>::push_back( (uint64_t)v124,  (__n128 *)&__p,  *v5);
    goto LABEL_19;
  }

  memset(&__p, 0, sizeof(__p));
  swift::Punycode::__runtime::encodePunycodeUTF8(v4, a3, &__p, 1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size = __p.__r_.__value_.__s.__size_;
  }
  else {
    size = __p.__r_.__value_.__l.__size_;
  }
  swift::Demangle::__runtime::CharVector::append((char **)v5 + 1591, "00", 2uLL, v5[1593]);
  swift::Demangle::__runtime::CharVector::append( (unsigned int *)v5 + 3182,  size,  (swift::Demangle::__runtime::NodeFactory *)v5[1593]);
  __int128 v10 = p_p->__r_.__value_.__s.__data_[0];
  uint64_t v12 = *((_DWORD *)v5 + 3184);
  uint64_t v13 = *((unsigned int *)v5 + 3185);
  unint64_t v14 = v5[1591];
  if (v12 >= v13)
  {
    uint64_t v15 = v5[1593];
    uint64_t v16 = (char *)v15[1];
    if ((char *)v14 + v13 == v16)
    {
      uint64_t v114 = (unint64_t)v14 + v13 + 1;
      unint64_t v17 = v15[2];
      if (v114 <= v17)
      {
        v15[1] = v114;
        LODWORD(v115) = 1;
LABEL_212:
        *((_DWORD *)v5 + 3185) = v13 + v115;
        goto LABEL_213;
      }
    }

    else
    {
      unint64_t v17 = v15[2];
    }

    else {
      uint64_t v115 = (2 * v13);
    }
    unint64_t v116 = v115 + v13;
    if (!v16 || (unint64_t)&v16[v116] > v17)
    {
      uint64_t v117 = 2LL * v15[4];
      if (v117 <= v116 + 1) {
        uint64_t v117 = v116 + 1;
      }
      v15[4] = v117;
      uint64_t v134 = v115;
      uint64_t v115 = v117 + 8;
      uint64_t v118 = malloc(v117 + 8);
      *uint64_t v118 = v15[3];
      uint64_t v16 = (char *)(v118 + 1);
      uint64_t v119 = (char *)v118 + v115;
      LODWORD(v115) = v134;
      v15[2] = v119;
      v15[3] = v118;
    }

    v15[1] = &v16[v116];
    if ((_DWORD)v13)
    {
      memcpy(v16, v5[1591], v13);
      LODWORD(v13) = *((_DWORD *)v5 + 3185);
      uint64_t v12 = *((_DWORD *)v5 + 3184);
    }

    v5[1591] = v16;
    unint64_t v14 = v16;
    goto LABEL_212;
  }

LABEL_217:
                  unint64_t v224 = 266LL;
LABEL_219:
                  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v224,  0);
                }

            __break(1u);
            goto LABEL_218;
          }
        }

        __break(1u);
        goto LABEL_217;
      }
    }

            __break(1u);
            goto LABEL_218;
          }
        }

        __break(1u);
        goto LABEL_217;
      }
    }

  v374 = v556;
  v375 = v567;
  v376 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    v376 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v376 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    v375 = 0xE200000000000000LL;
  }

  else
  {
    v566 = 8236LL;
    v567 = 0xE200000000000000LL;
  }

  swift_bridgeObjectRelease(v375);
  v146(8LL, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v377 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v377, v374, v2);
  v378 = v561;
  v379 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v380 = (void *)swift_getDynamicType(v379, v378, 1);
  LODWORD(v378) = swift_isOptionalType(v380);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v378)
  {
    memcpy(v151, v374, v2);
    v381 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v381, 7uLL);
LABEL_224:
    v382 = (uint64_t)v561;
    v383 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v384 = (*(uint64_t (**)(uint64_t, uint64_t))(v383 + 8))(v382, v383);
    v386 = v385;
    specialized String.write<A>(to:)(&v566, v384, v385, v387);
    swift_bridgeObjectRelease(v386);
LABEL_225:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_228;
  }

  v388 = v547;
  memcpy(v547, v374, v2);
  if ((swift_dynamicCast((char *)&v560, v388, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v389 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v389);
  }

  else
  {
    v438 = v538;
    memcpy(v538, v374, v2);
    v439 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v438, v1, v439, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v440 = (uint64_t)v561;
      v441 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v441 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v440,  v441);
      goto LABEL_225;
    }

    v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v476 = v530;
    memcpy(v530, v374, v2);
    v477 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v476, v1, v477, 6uLL)
      || (v565 = 0LL,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  v478 = v520,  memcpy(v520, v374, v2),  v479 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v478, v1, v479, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_224;
    }

    v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v505 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v505, v374, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v506 = v560._object;
    v507 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v374,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v507);
    swift_release((uint64_t)v506);
  }

    __src = v38 + 1;
    __len = v37 - 1;
    if (!v16) {
      goto LABEL_3;
    }
    swift::Demangle::__runtime::Node::addChild(Node, (swift::Demangle::__runtime::Node *)v16, v185, v35, v36);
    uint64_t v181 = __p;
    if (__len < 4) {
      break;
    }
    uint64_t v161 = __src;
    if (*(_DWORD *)__src != 1398035551) {
      goto LABEL_239;
    }
    uint64_t v3 = 0LL;
    unint64_t v11 = (unsigned __int8 *)__src + 4;
    uint64_t v12 = __len - 4;
    __src = (char *)__src + 4;
    __len = v12;
    if (!v12) {
      goto LABEL_4;
    }
  }

  if (__len >= 2)
  {
    uint64_t v161 = __src;
LABEL_239:
    if (*v161 == 21599)
    {
      __src = v161 + 1;
      __len -= 2LL;
      goto LABEL_228;
    }
  }

LABEL_218:
              unint64_t v224 = 258LL;
              goto LABEL_219;
            }

            goto LABEL_214;
          }

          uint64_t v141 = v234 + 2;
        }

            unint64_t result = 0LL;
            __int128 v10 = 0;
            goto LABEL_261;
          }

          goto LABEL_266;
        }

        __int128 v10 = 1;
        uint64_t v69 = specialized Collection.subscript.getter(1LL, (uint64_t)v7, v8);
        unint64_t v73 = specialized UnsafeBufferPointer.init(rebasing:)(v69, v70, v71, v72);
        if (v74)
        {
          unint64_t v76 = (unsigned __int8 *)v73;
          Swift::String::Index v77 = a3 + 48;
          Swift::String::Index v78 = a3 + 55;
          unint64_t v79 = a3 + 87;
          if (a3 > 10)
          {
            Swift::String::Index v77 = 58;
          }

          else
          {
            unint64_t v79 = 97;
            Swift::String::Index v78 = 65;
          }

          if (v73)
          {
            unint64_t v80 = v74;
            char v23 = 0LL;
            unint64_t v81 = 0LL;
            unint64_t v82 = abs64(a3);
            unint64_t v83 = -(v75 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
            while (1)
            {
              unint64_t v84 = *v76;
              if (v84 < 0x30 || v84 >= v77)
              {
                if (v84 < 0x41 || v84 >= v78)
                {
                  unint64_t result = 0LL;
                  __int128 v10 = 1;
                  if (v84 < 0x61 || v84 >= v79) {
                    goto LABEL_261;
                  }
                  unint64_t v85 = -87;
                }

                else
                {
                  unint64_t v85 = -55;
                }
              }

              else
              {
                unint64_t v85 = -48;
              }

              char v87 = !((__PAIR128__(v81 ^ (unint64_t)(v81 >> 63), v23 ^ (v81 >> 63))
                     - __PAIR128__(v81 >> 63, v81 >> 63)) >> 64)
                 || v83 == 0;
              unint64_t v88 = v87 && (*((unint64_t *)&v86 + 1) * (unsigned __int128)v82) >> 64 == 0;
              uint64_t v89 = v88 && (v83 * (unsigned __int128)(unint64_t)v86) >> 64 == 0;
              char v90 = !v89;
              unint64_t v91 = (__PAIR128__(v83, v82) * v86) >> 64;
              unint64_t v92 = __CFADD__( ((unint64_t)v86 * (unsigned __int128)v82) >> 64,  v83 * v86 + *((void *)&v86 + 1) * v82)
                 || v90;
              unint64_t v93 = v86 * v82;
              if ((v81 ^ (a3 >> 63)) < 0)
              {
                if ((v92 & 1) != 0) {
                  goto LABEL_260;
                }
                unint64_t v39 = v93 == 0;
                unint64_t v93 = -(uint64_t)v93;
                unint64_t v91 = -(uint64_t)(v91 + !v39);
                LOBYTE(v94) = v93 != 0;
              }

              else
              {
                if ((v92 & 1) != 0) {
                  goto LABEL_260;
                }
                unint64_t v94 = v91 >> 63;
              }

              unint64_t result = 0LL;
              unint64_t v39 = __CFADD__(v93, (v84 + v85));
              unint64_t v81 = (__PAIR128__(v91, v93) + (v84 + v85)) >> 64;
              char v23 = v93 + (v84 + v85);
              unint64_t v95 = __OFADD__(v39, v91);
              __int128 v10 = 1;
              if ((v94 & 1) != 0 || v95) {
                goto LABEL_261;
              }
              ++v76;
              if (!--v80) {
                goto LABEL_217;
              }
            }
          }

          goto LABEL_218;
        }

              uint64_t v160 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(startingAta);
              uint64_t v161 = startingAta << 16;
              if (v160 > 63)
              {
LABEL_199:
                *uint64_t v3 = v161 | 5;
                if (_StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v161 | 5))) {
                  *uint64_t v3 = v161 | 7;
                }
                unint64_t v81 = __OFADD__(startingAta, v149);
                uint64_t v127 = startingAta + v149;
                if (v81)
                {
                  __break(1u);
LABEL_204:
                  __break(1u);
LABEL_205:
                  __break(1u);
LABEL_206:
                  __break(1u);
                  goto LABEL_207;
                }

                goto LABEL_140;
              }

LABEL_123:
        unint64_t v11 = (v142 - 1) & v142;
        uint64_t v137 = __clz(__rbit64(v142)) + (v141 << 6);
        unint64_t v234 = v141;
      }

      (*(void (**)(int64_t, uint64_t, uint64_t))(v43 + 16))( v58,  *(void *)(v53 + 48) + *(void *)(v43 + 72) * v137,  v2);
    }

    (*(void (**)(int64_t, void, uint64_t, uint64_t))(v43 + 56))(v58, 0LL, 1LL, v2);
    int64_t v52 = *(void *)(v43 + 32);
    ((void (*)(uint64_t, int64_t, uint64_t))v52)(v4, v58, v2);
    if ((v12 & 1) == 0) {
      break;
    }
LABEL_108:
    uint64_t v133 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v133, v238);
    *((_OWORD *)inited + 1) = v235;
    inited[7] = v2;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    ((void (*)(void *, uint64_t, uint64_t))v52)(boxed_opaque_existential_0Tm, v4, v2);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  (uint64_t *)&v240);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v12 = 0LL;
  }

  uint64_t v146 = v240;
  unint64_t v17 = v241;
  unint64_t v147 = HIBYTE(v241) & 0xF;
  if ((v241 & 0x2000000000000000LL) != 0) {
    unint64_t v148 = HIBYTE(v241) & 0xF;
  }
  else {
    unint64_t v148 = v240 & 0xFFFFFFFFFFFFLL;
  }
  if (!v148 && (v240 & ~v241 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v241);
    unint64_t v240 = 8236LL;
    unint64_t v241 = 0xE200000000000000LL;
    goto LABEL_107;
  }

  if ((v241 & 0x2000000000000000LL) != 0 && v147 <= 0xD)
  {
    unint64_t v149 = 8 * (HIBYTE(v241) & 7);
    uint64_t v150 = (-255LL << v149) - 1;
    uint64_t v151 = 44LL << v149;
    char v152 = v147 + 1;
    if (v147 >= 8)
    {
      uint64_t v153 = v151 | v150 & v241;
      uint64_t v4 = v233;
    }

    else
    {
      uint64_t v146 = v151 | v150 & v240;
      uint64_t v4 = v233;
      if (v147 != 7)
      {
        uint64_t v146 = (32LL << (8 * (v152 & 7u))) | ((-255LL << (8 * (v152 & 7u))) - 1) & v146;
        uint64_t v181 = v241;
        goto LABEL_159;
      }

      char v152 = 8;
      uint64_t v153 = v241;
    }

    uint64_t v181 = (32LL << (8 * (v152 & 7u))) | ((-255LL << (8 * (v152 & 7u))) - 1) & v153;
LABEL_159:
    swift_bridgeObjectRelease(v241);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v182 = 0xE000000000000000LL;
    if (v146 & 0x8080808080808080LL | v181 & 0x80808080808080LL) {
      unint64_t v182 = 0xA000000000000000LL;
    }
    unint64_t v240 = v146;
    unint64_t v241 = (v182 & 0xFF00000000000000LL | (v147 << 56) | v181 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
    int64_t v58 = (int64_t)v231;
    goto LABEL_108;
  }

  swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v144, v145);
  if ((v17 & 0x1000000000000000LL) == 0)
  {
    BOOL v154 = __OFADD__(v148, 2LL);
    int64_t v155 = v148 + 2;
    if (v154) {
      goto LABEL_164;
    }
LABEL_138:
    if ((v146 & ~v17 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v17 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v156 = _StringGuts.nativeUnusedCapacity.getter(v146, v17);
      if ((v157 & 1) != 0) {
        goto LABEL_218;
      }
      BOOL v159 = (v17 & 0x2000000000000000LL) == 0 && v156 > 1;
      if (v155 > 15 || v159) {
        goto LABEL_106;
      }
    }

    else if (v155 > 15)
    {
LABEL_106:
      unint64_t v17 = (unint64_t)&v240;
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v155, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
      __int128 v239 = v227;
      v131 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v239, 2LL);
      _StringGuts.appendInPlace(_:isASCII:)(v131, v132, 1);
      swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_107:
      uint64_t v4 = v233;
      goto LABEL_108;
    }

    swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
    swift_bridgeObjectRetain(v17, v160, v161, v162);
    unint64_t v163 = _StringGuts._convertedToSmall()(v146, v17);
    unint64_t v165 = v164;
    swift_bridgeObjectRelease(v17);
    v166._rawBits = 1LL;
    v167._rawBits = 131073LL;
    v168._rawBits = _StringGuts.validateScalarRange(_:)(v166, v167, 0x202CuLL, 0xE200000000000000LL);
    if (v168._rawBits < 0x10000) {
      v168._rawBits |= 3;
    }
    unint64_t v170 = specialized String.init(_:)(v168, v169, 0x202CuLL, 0xE200000000000000LL);
    unint64_t v172 = v171;
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v173 = _StringGuts._convertedToSmall()(v170, v172);
    unint64_t v175 = v174;
    swift_bridgeObjectRelease(v172);
    unint64_t v176 = specialized _SmallString.init(_:appending:)(v163, v165, v173, v175);
    if ((v178 & 1) != 0) {
      goto LABEL_217;
    }
    unint64_t v179 = v176;
    unint64_t v180 = v177;
    swift_bridgeObjectRelease(v17);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v240 = v179;
    unint64_t v241 = v180;
    unint64_t v43 = v228;
    int64_t v58 = (int64_t)v231;
    goto LABEL_107;
  }

  Swift::Int v183 = String.UTF8View._foreignCount()();
  int64_t v155 = v183 + 2;
  if (!__OFADD__(v183, 2LL)) {
    goto LABEL_138;
  }
LABEL_164:
  __break(1u);
LABEL_165:
  (*(void (**)(int64_t, uint64_t, uint64_t, uint64_t))(v43 + 56))(v58, 1LL, 1LL, v2);
  outlined consume of [A : B].Iterator._Variant<A, B>(v53);
  uint64_t v2 = v240;
  unint64_t v17 = v241;
  unint64_t v186 = HIBYTE(v241) & 0xF;
  if ((v241 & 0x2000000000000000LL) != 0) {
    unint64_t v187 = HIBYTE(v241) & 0xF;
  }
  else {
    unint64_t v187 = v240 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v12 = v226;
  if (!v187 && (v240 & ~v241 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v241);
    swift_bridgeObjectRelease(v12);
    return 10589LL;
  }

  if ((v241 & 0x2000000000000000LL) == 0 || v186 > 0xD)
  {
    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v184, v185);
    if ((v17 & 0x1000000000000000LL) != 0) {
      goto LABEL_212;
    }
    BOOL v154 = __OFADD__(v187, 2LL);
    int64_t v188 = v187 + 2;
    if (!v154) {
      goto LABEL_177;
    }
LABEL_214:
    __break(1u);
    goto LABEL_215;
  }

  if (v186 < 8)
  {
    uint64_t v2 = (93LL << (8 * (HIBYTE(v241) & 7u))) | ((-255LL << (8 * (HIBYTE(v241) & 7u))) - 1) & v240;
    if (v186 != 7) {
      uint64_t v2 = (41LL << (8 * ((v186 + 1) & 7))) | ((-255LL << (8 * ((v186 + 1) & 7))) - 1) & v2;
    }
  }

  swift_bridgeObjectRelease(v241);
  swift_bridgeObjectRelease(v12);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  return v2;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
  }

  unint64_t v85 = _StringGuts.nativeUnusedCapacity.getter(v82, v81);
  if ((v86 & 1) != 0)
  {
LABEL_129:
    uint64_t v139 = 258LL;
LABEL_130:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v139,  0);
  }

  if (v83 <= 15 && ((v81 & 0x2000000000000000LL) != 0 || v85 < v80)) {
    goto LABEL_83;
  }
LABEL_77:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v83, v80);
  swift_bridgeObjectRelease(v32);
  if ((v32 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(v79, v32, v31, v37);
    goto LABEL_106;
  }

  if ((v32 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v32);
    uint64_t v120 = HIBYTE(v32) & 0xF;
    unint64_t v142 = v79;
    unint64_t v143 = v32 & 0xFFFFFFFFFFFFFFLL;
    if (v120 >= v37)
    {
      uint64_t v121 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v31, v37, (uint64_t)&v142, v120);
      _StringGuts.appendInPlace(_:isASCII:)(v121, v122, (v32 & 0x4000000000000000LL) != 0);
      goto LABEL_109;
    }

    goto LABEL_127;
  }

  if ((v79 & 0x1000000000000000LL) == 0)
  {
    char v87 = _StringObject.sharedUTF8.getter(v79, v32);
    unint64_t v88 = v138;
    if (v138 >= v37) {
      goto LABEL_81;
    }
LABEL_127:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  char v87 = (id)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
  unint64_t v88 = v79 & 0xFFFFFFFFFFFFLL;
  if ((v79 & 0xFFFFFFFFFFFFLL) < v37) {
    goto LABEL_127;
  }
LABEL_81:
  uint64_t v89 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v31, v37, (uint64_t)v87, v88);
  _StringGuts.appendInPlace(_:isASCII:)(v89, v90, v79 < 0);
LABEL_106:
  swift_bridgeObjectRelease(v32);
LABEL_109:
  unint64_t v123 = v144;
  uint64_t v124 = v145;
  swift_bridgeObjectRelease(v3[1]);
  *uint64_t v3 = v123;
  v3[1] = v124;
}

    unint64_t v11 = (Swift::Int)swift_allocError( (uint64_t)&unk_189B86A70,  (uint64_t)&protocol witness table for UTF8ValidationError,  0LL,  0);
    swift_willThrow();
    swift_errorRelease((id)v11);
    Swift::String::Index v78 = specialized Collection.subscript.getter(v12, (uint64_t)v65, v64);
    unint64_t v83 = findInvalidRange #1 (_:) in validateUTF8(_:)(v78, v79, v80, v81);
    *(void *)&v338 = 0LL;
    *((void *)&v338 + 1) = 0xE000000000000000LL;
    if (__OFADD__(v64, 15LL)) {
      goto LABEL_272;
    }
    unint64_t v84 = v82;
    _StringGuts.reserveCapacity(_:)(v64 + 15);
    unint64_t v53 = 0LL;
    while (2)
    {
      unint64_t v85 = specialized Collection.subscript.getter(v83, (uint64_t)v65, v64);
      uint64_t v89 = v338 & 0xFFFFFFFFFFFFLL;
      if ((*((void *)&v338 + 1) & 0x2000000000000000LL) != 0) {
        uint64_t v89 = HIBYTE(*((void *)&v338 + 1)) & 0xFLL;
      }
      char v90 = __OFADD__(v89, v64);
      unint64_t v91 = v89 + v64;
      if (v90)
      {
        __break(1u);
LABEL_259:
        __break(1u);
        goto LABEL_260;
      }

      unint64_t v92 = v85;
      if (__OFADD__(v91, 3LL)) {
        goto LABEL_259;
      }
      unint64_t v93 = v86;
      unint64_t v94 = v87;
      unint64_t v95 = v88;
      _StringGuts.reserveCapacity(_:)(v91 + 3);
      unint64_t v96 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v92, v93, v94, v95);
      _StringGuts.appendInPlace(_:isASCII:)(v96, v97, 0);
      v341 = 3LL;
      v342 = 12435439LL;
      specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v342, &v341, &v338);
      uint64_t v98 = specialized Collection.subscript.getter(v84, (uint64_t)v65, v64);
      uint64_t v65 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v98, v99, v100, v101);
      uint64_t v64 = v102;
      uint64_t v103 = validateUTF8(_:)(v65, v102);
      if ((v62 & 1) != 0)
      {
        unint64_t v83 = v103;
        unint64_t v84 = v104;
        if (!v64) {
          goto LABEL_138;
        }
        continue;
      }

      break;
    }

    _StringGuts.appendInPlace(_:isASCII:)((char *)v65, v64, 0);
LABEL_138:
    uint64_t v3 = *((void *)&v338 + 1);
    uint64_t v4 = v338;
    a1 = v337;
LABEL_169:
    unint64_t v214 = v339;
    uint64_t v12 = v340;
    unint64_t v215 = HIBYTE(v340) & 0xF;
    if ((v340 & 0x2000000000000000LL) != 0) {
      v216 = HIBYTE(v340) & 0xF;
    }
    else {
      v216 = v339 & 0xFFFFFFFFFFFFLL;
    }
    if (!v216 && (v339 & ~v340 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v340);
      v339 = v4;
      v340 = v3;
      goto LABEL_220;
    }

    a1 = v3 & 0x2000000000000000LL;
    a2 = HIBYTE(v3) & 0xF;
    if ((v340 & 0x2000000000000000LL) == 0 || !a1) {
      goto LABEL_178;
    }
    Swift::String::Index v217 = v215 + a2;
    if (v215 + a2 <= 0xF)
    {
      a1 = v337;
      if (a2)
      {
        v250 = 0;
        v251 = 0LL;
        v252 = v340;
        do
        {
          v253 = v215 + v251;
          v254 = v251 + 1;
          if (v251 >= 8) {
            v255 = v3;
          }
          else {
            v255 = v4;
          }
          v256 = v255 >> (v250 & 0x38);
          v257 = (8 * v215 + v250) & 0x38;
          v258 = (-255LL << v257) - 1;
          v259 = (unint64_t)v256 << v257;
          v260 = v259 | v258 & v252;
          v261 = v259 | v258 & v214;
          if (v253 < 8) {
            unint64_t v214 = v261;
          }
          else {
            v252 = v260;
          }
          v250 += 8;
          v251 = v254;
        }

        while (a2 != v254);
      }

      else
      {
        v252 = v340;
      }

      swift_bridgeObjectRelease(v340);
      swift_bridgeObjectRelease(v3);
      v267 = 0xA000000000000000LL;
      if (!(v214 & 0x8080808080808080LL | v252 & 0x80808080808080LL)) {
        v267 = 0xE000000000000000LL;
      }
      v339 = v214;
      v340 = v267 & 0xFF00000000000000LL | (v217 << 56) | v252 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_220;
    }

    a1 = 1LL;
LABEL_178:
    v334 = v4 & 0xFFFFFFFFFFFFLL;
    if (a1) {
      Swift::String::Index v218 = HIBYTE(v3) & 0xF;
    }
    else {
      Swift::String::Index v218 = v4 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v3, 2LL, v62, v63);
    if ((v3 & 0x1000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain_n(v3, 4LL, v219, v220);
      unint64_t v11 = v218;
      if ((v12 & 0x1000000000000000LL) == 0) {
        goto LABEL_183;
      }
LABEL_266:
      v321 = String.UTF8View._foreignCount()();
      Swift::Int v221 = v321 + v11;
      if (!__OFADD__(v321, v11)) {
        goto LABEL_184;
      }
LABEL_268:
      __break(1u);
LABEL_269:
      v322 = String.UTF8View._foreignCount()();
      v278 = v322 + 1;
      if (!__OFADD__(v322, 1LL)) {
        goto LABEL_238;
      }
LABEL_271:
      __break(1u);
LABEL_272:
      __break(1u);
LABEL_273:
      uint64_t v24 = _StringGuts._foreignConvertedToSmall()(v11, v12);
      uint64_t v25 = v323;
LABEL_17:
      v26._rawBits = 1LL;
      v27._rawBits = 1LL;
      v28._rawBits = _StringGuts.validateScalarRange(_:)(v26, v27, 0LL, 0xE000000000000000LL);
      if (v28._rawBits < 0x10000) {
        v28._rawBits |= 3;
      }
      Swift::String::Index v30 = specialized String.init(_:)(v28, v29, 0LL, 0xE000000000000000LL);
      Swift::String::Index v32 = v31;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      if ((v32 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v32);
      }

      else if ((v32 & 0x1000000000000000LL) != 0)
      {
        Swift::String::Index v30 = _StringGuts._foreignConvertedToSmall()(v30, v32);
        v329 = v328;
        swift_bridgeObjectRelease(v32);
        Swift::String::Index v32 = v329;
      }

      else
      {
        if ((v30 & 0x1000000000000000LL) != 0)
        {
          v324 = (unsigned __int8 *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v325 = v30 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v324 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v30, v32);
        }

        closure #1 in _StringGuts._convertedToSmall()(v324, v325, &v338);
        swift_bridgeObjectRelease(v32);
        Swift::String::Index v32 = *((void *)&v338 + 1);
        Swift::String::Index v30 = v338;
      }

      Swift::String::Index v33 = HIBYTE(v25) & 0xF;
      unint64_t v34 = HIBYTE(v32) & 0xF;
      unint64_t v35 = v34 + v33;
      if ((unint64_t)(v34 + v33) <= 0xF)
      {
        if (v34)
        {
          unint64_t v36 = 0;
          unint64_t v37 = 0LL;
          do
          {
            unint64_t v38 = v33 + v37;
            unint64_t v39 = v37 + 1;
            if (v37 >= 8) {
              unint64_t v40 = v32;
            }
            else {
              unint64_t v40 = v30;
            }
            unint64_t v41 = v40 >> (v36 & 0x38);
            char v42 = (8 * v33 + v36) & 0x38;
            unint64_t v43 = (-255LL << v42) - 1;
            uint64_t v44 = (unint64_t)v41 << v42;
            uint64_t v45 = v44 | v43 & v25;
            uint64_t v46 = v44 | v43 & v24;
            if (v38 < 8) {
              uint64_t v24 = v46;
            }
            else {
              uint64_t v25 = v45;
            }
            v36 += 8;
            unint64_t v37 = v39;
          }

          while (v34 != v39);
        }

        swift_bridgeObjectRelease(v12);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        unint64_t v47 = 0xA000000000000000LL;
        if (!(v24 & 0x8080808080808080LL | v25 & 0x80808080808080LL)) {
          unint64_t v47 = 0xE000000000000000LL;
        }
        uint64_t v48 = v47 & 0xFF00000000000000LL | (v35 << 56) | v25 & 0xFFFFFFFFFFFFFFLL;
        v339 = v24;
        continue;
      }

    *((_DWORD *)this + 3184) = v51 + 1;
    v53[v51] = 95;
    unint64_t v47 = 1;
    uint64_t v48 = v69;
LABEL_124:
    if (*(_DWORD *)a4) {
      return;
    }
    if (*((_WORD *)v50 + 8) == 216 && *((_BYTE *)v5 + 18) == 4) {
      swift::Demangle::__runtime::CharVector::append( v71,  *(void *)v5,  *((swift::Demangle::__runtime::NodeFactory **)this + 1593));
    }
    uint64_t v44 = (swift::Demangle::__runtime::Node *)((char *)v44 + 8);
  }

  while (v44 != v49);
  if ((v47 & 1) == 0) {
LABEL_130:
  }
    swift::Demangle::__runtime::CharVector::append((char **)v71, "_n", 2uLL, *((void **)this + 1593));
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
}

uint64_t Dictionary.Values.description.getter(int64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v116 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = type metadata accessor for Optional(0LL, v8, v8, v9);
  MEMORY[0x1895F8858](v10);
  uint64_t v12 = (char *)&v116 - v11;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v128 = 91LL;
  unint64_t v129 = 0xE100000000000000LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v16 = a1;
    }
    else {
      uint64_t v16 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v17 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v18 = (unint64_t)swift_allocObject(v17, 0xE8uLL, 7uLL);
    uint64_t v120 = 0LL;
    uint64_t v19 = 0LL;
    unint64_t v20 = 0LL;
    *(void *)(v18 + 208) = v16;
    *(void *)(v18 + 216) = 0LL;
    *(_OWORD *)(v18 + 16) = 0u;
    *(_OWORD *)(v18 + 32) = 0u;
    *(_OWORD *)(v18 + 48) = 0u;
    *(_OWORD *)(v18 + 64) = 0u;
    *(_OWORD *)(v18 + 80) = 0u;
    *(_OWORD *)(v18 + 96) = 0u;
    *(_OWORD *)(v18 + 112) = 0u;
    *(_OWORD *)(v18 + 128) = 0u;
    *(_OWORD *)(v18 + 144) = 0u;
    *(_OWORD *)(v18 + 160) = 0u;
    *(_OWORD *)(v18 + 176) = 0u;
    *(_OWORD *)(v18 + 192) = 0u;
    *(void *)(v18 + 224) = 0LL;
    unint64_t v21 = v18 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v22 = -1LL << *(_BYTE *)(a1 + 32);
    uint64_t v19 = ~v22;
    uint64_t v23 = *(void *)(a1 + 64);
    uint64_t v120 = a1 + 64;
    uint64_t v24 = -v22;
    if (v24 < 64) {
      uint64_t v25 = ~(-1LL << v24);
    }
    else {
      uint64_t v25 = -1LL;
    }
    unint64_t v20 = v25 & v23;
    unint64_t v21 = a1;
  }

  uint64_t v122 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v116 = v19;
  int64_t v119 = (unint64_t)(v19 + 64) >> 6;
  unint64_t v26 = swift_bridgeObjectRetain(a1, v13, v14, v15);
  int64_t v123 = 0LL;
  unint64_t v30 = 1LL;
  __int128 v125 = xmmword_1817FFC60;
  __int128 v118 = xmmword_1817FFC70;
  unint64_t v121 = v21;
  uint64_t v117 = v7;
  while ((v21 & 0x8000000000000000LL) != 0)
  {
    id v38 = __CocoaDictionary.Iterator.next()(v26, v27, v28, v29);
    if (!v38) {
      goto LABEL_70;
    }
    unint64_t v40 = v39;
    swift_unknownObjectRelease(v38);
    _forceBridgeFromObjectiveC<A>(_:_:)(v40, (char *)v3, v41, v12);
    swift_unknownObjectRelease(v40);
LABEL_30:
    (*(void (**)(char *, void, uint64_t, uint64_t))(v5 + 56))(v12, 0LL, 1LL, v3);
    uint64_t v46 = *(void (**)(char *, char *, uint64_t))(v5 + 32);
    v46(v7, v12, v3);
    if ((v30 & 1) != 0) {
      goto LABEL_13;
    }
    unint64_t v124 = v20;
    uint64_t v50 = v128;
    uint64_t v49 = v129;
    unint64_t v51 = HIBYTE(v129) & 0xF;
    if ((v129 & 0x2000000000000000LL) != 0) {
      unint64_t v52 = HIBYTE(v129) & 0xF;
    }
    else {
      unint64_t v52 = v128 & 0xFFFFFFFFFFFFLL;
    }
    if (!v52 && (v128 & ~v129 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v129);
      uint64_t v128 = 8236LL;
      unint64_t v129 = 0xE200000000000000LL;
      goto LABEL_12;
    }

    if ((v129 & 0x2000000000000000LL) == 0 || v51 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v47, v48);
      if ((v49 & 0x1000000000000000LL) == 0)
      {
        BOOL v58 = __OFADD__(v52, 2LL);
        int64_t v59 = v52 + 2;
        if (v58) {
          goto LABEL_69;
        }
LABEL_43:
        if ((v50 & ~v49 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v49 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v60 = _StringGuts.nativeUnusedCapacity.getter(v50, v49);
          if ((v61 & 1) != 0) {
            goto LABEL_115;
          }
          BOOL v63 = (v49 & 0x2000000000000000LL) == 0 && v60 > 1;
          if (v59 > 15 || v63) {
            goto LABEL_11;
          }
        }

        else if (v59 > 15)
        {
LABEL_11:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v59, 2LL);
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
          __int128 v126 = v118;
          Swift::String::Index v31 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v126, 2LL);
          _StringGuts.appendInPlace(_:isASCII:)(v31, v32, 1);
          swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_12:
          unint64_t v20 = v124;
          goto LABEL_13;
        }

        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        swift_bridgeObjectRetain(v49, v64, v65, v66);
        unint64_t v67 = _StringGuts._convertedToSmall()(v50, v49);
        unint64_t v69 = v68;
        swift_bridgeObjectRelease(v49);
        v70._rawBits = 131073LL;
        v71._rawBits = 1LL;
        v72._rawBits = _StringGuts.validateScalarRange(_:)(v71, v70, 0x202CuLL, 0xE200000000000000LL);
        if (v72._rawBits < 0x10000) {
          v72._rawBits |= 3;
        }
        unint64_t v74 = specialized String.init(_:)(v72, v73, 0x202CuLL, 0xE200000000000000LL);
        unint64_t v76 = v75;
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v77 = _StringGuts._convertedToSmall()(v74, v76);
        unint64_t v79 = v78;
        swift_bridgeObjectRelease(v76);
        unint64_t v80 = specialized _SmallString.init(_:appending:)(v67, v69, v77, v79);
        if ((v82 & 1) != 0) {
          goto LABEL_114;
        }
        uint64_t v83 = v80;
        unint64_t v84 = v81;
        swift_bridgeObjectRelease(v49);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        uint64_t v128 = v83;
        unint64_t v129 = v84;
        uint64_t v7 = v117;
        unint64_t v21 = v121;
        goto LABEL_12;
      }

      Swift::Int v87 = String.UTF8View._foreignCount()();
      int64_t v59 = v87 + 2;
      if (!__OFADD__(v87, 2LL)) {
        goto LABEL_43;
      }
LABEL_69:
      __break(1u);
LABEL_70:
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v5 + 56))(v12, 1LL, 1LL, v3);
      outlined consume of [A : B].Iterator._Variant<A, B>(v21);
      uint64_t v43 = v128;
      uint64_t v3 = v129;
      unint64_t v30 = HIBYTE(v129) & 0xF;
      uint64_t v12 = (char *)(v128 & 0xFFFFFFFFFFFFLL);
      if ((v129 & 0x2000000000000000LL) != 0) {
        unint64_t v90 = HIBYTE(v129) & 0xF;
      }
      else {
        unint64_t v90 = v128 & 0xFFFFFFFFFFFFLL;
      }
      if (!v90 && (v128 & ~v129 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v129);
        return 93LL;
      }

      if ((v129 & 0x2000000000000000LL) != 0 && v30 != 15)
      {
        if (v30 < 8) {
          uint64_t v43 = (93LL << (8 * (HIBYTE(v129) & 7u))) | ((-255LL << (8 * (HIBYTE(v129) & 7u))) - 1) & v128;
        }
        swift_bridgeObjectRelease(v129);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        return v43;
      }

      swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v88, v89);
      if ((v3 & 0x1000000000000000LL) != 0) {
        goto LABEL_103;
      }
      BOOL v58 = __OFADD__(v90, 1LL);
      uint64_t v91 = v90 + 1;
      if (!v58) {
        goto LABEL_82;
      }
LABEL_105:
      __break(1u);
      goto LABEL_106;
    }

    unint64_t v53 = 8 * (HIBYTE(v129) & 7);
    uint64_t v54 = (-255LL << v53) - 1;
    uint64_t v55 = 44LL << v53;
    char v56 = v51 + 1;
    if (v51 >= 8)
    {
      uint64_t v57 = v55 | v54 & v129;
      unint64_t v20 = v124;
    }

    else
    {
      uint64_t v50 = v55 | v54 & v128;
      unint64_t v20 = v124;
      if (v51 != 7)
      {
        uint64_t v50 = (32LL << (8 * (v56 & 7u))) | ((-255LL << (8 * (v56 & 7u))) - 1) & v50;
        uint64_t v85 = v129;
        goto LABEL_64;
      }

      char v56 = 8;
      uint64_t v57 = v129;
    }

    uint64_t v85 = (32LL << (8 * (v56 & 7u))) | ((-255LL << (8 * (v56 & 7u))) - 1) & v57;
LABEL_64:
    swift_bridgeObjectRelease(v129);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v86 = 0xE000000000000000LL;
    if (v50 & 0x8080808080808080LL | v85 & 0x80808080808080LL) {
      unint64_t v86 = 0xA000000000000000LL;
    }
    uint64_t v128 = v50;
    unint64_t v129 = (v86 & 0xFF00000000000000LL | (v51 << 56) | v85 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
    unint64_t v21 = v121;
LABEL_13:
    uint64_t v33 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v33, v127);
    *((_OWORD *)inited + 1) = v125;
    inited[7] = v3;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v46(boxed_opaque_existential_0Tm, v7, v3);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v128);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    unint64_t v30 = 0LL;
  }

  if (v20)
  {
    unint64_t v36 = __clz(__rbit64(v20));
    v20 &= v20 - 1;
    unint64_t v37 = v36 | (v123 << 6);
LABEL_29:
    (*(void (**)(char *, unint64_t, uint64_t))(v5 + 16))( v12,  *(void *)(v21 + 56) + *(void *)(v5 + 72) * v37,  v3);
    goto LABEL_30;
  }

  int64_t v42 = v123 + 1;
  uint64_t v43 = v120;
  if (__OFADD__(v123, 1LL)) {
    goto LABEL_102;
  }
  if (v42 >= v119) {
    goto LABEL_70;
  }
  unint64_t v44 = *(void *)(v120 + 8 * v42);
  if (v44)
  {
LABEL_28:
    unint64_t v20 = (v44 - 1) & v44;
    unint64_t v37 = __clz(__rbit64(v44)) + (v42 << 6);
    int64_t v123 = v42;
    goto LABEL_29;
  }

  int64_t v45 = v123 + 2;
  if (v123 + 2 >= v119) {
    goto LABEL_70;
  }
  unint64_t v44 = *(void *)(v120 + 8 * v45);
  if (v44)
  {
    int64_t v42 = v123 + 2;
    goto LABEL_28;
  }

  while (1)
  {
    int64_t v42 = v45 + 1;
    if (__OFADD__(v45, 1LL)) {
      break;
    }
    if (v42 >= v119) {
      goto LABEL_70;
    }
    unint64_t v44 = *(void *)(v120 + 8 * v42);
    ++v45;
    if (v44) {
      goto LABEL_28;
    }
  }

  __break(1u);
LABEL_102:
  __break(1u);
LABEL_103:
  Swift::Int v107 = String.UTF8View._foreignCount()();
  uint64_t v91 = v107 + 1;
  if (__OFADD__(v107, 1LL)) {
    goto LABEL_105;
  }
LABEL_82:
  if ((v43 & ~v3 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v3 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v92 = _StringGuts.nativeUnusedCapacity.getter(v43, v3);
    if ((v93 & 1) != 0)
    {
LABEL_115:
      unint64_t v112 = 258LL;
    }

    else
    {
      if (v91 > 15) {
        goto LABEL_88;
      }
      if ((v3 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        goto LABEL_91;
      }

      if (v92 > 0) {
        goto LABEL_88;
      }
LABEL_90:
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
      if ((v3 & 0x2000000000000000LL) != 0)
      {
LABEL_91:
        uint64_t v12 = (char *)v3;
      }

      else if ((v3 & 0x1000000000000000LL) != 0)
      {
        uint64_t v43 = _StringGuts._foreignConvertedToSmall()(v43, v3);
        uint64_t v12 = v115;
      }

      else
      {
        if ((v43 & 0x1000000000000000LL) != 0)
        {
          unint64_t v111 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          unint64_t v111 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v43, v3);
          uint64_t v12 = (char *)v96;
        }

        swift_bridgeObjectRetain(v3, v96, v97, v98);
        closure #1 in _StringGuts._convertedToSmall()(v111, (uint64_t)v12, &v126);
        swift_bridgeObjectRelease(v3);
        uint64_t v12 = (char *)*((void *)&v126 + 1);
        uint64_t v43 = v126;
      }

      v99._rawBits = 1LL;
      v100._rawBits = 65537LL;
      v101._rawBits = _StringGuts.validateScalarRange(_:)(v99, v100, 0x5DuLL, 0xE100000000000000LL);
      if (v101._rawBits < 0x10000) {
        v101._rawBits |= 3;
      }
      unint64_t v30 = specialized String.init(_:)(v101, v102, 0x5DuLL, 0xE100000000000000LL);
      uint64_t v91 = v103;
      swift_bridgeObjectRelease(0xE100000000000000LL);
      if ((v91 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v91);
        goto LABEL_96;
      }

LABEL_106:
      uint64_t v108 = v43;
      if ((v91 & 0x1000000000000000LL) != 0)
      {
        unint64_t v30 = _StringGuts._foreignConvertedToSmall()(v30, v91);
        uint64_t v114 = v113;
        swift_bridgeObjectRelease(v91);
        uint64_t v91 = v114;
        uint64_t v43 = v108;
      }

      else
      {
        if ((v30 & 0x1000000000000000LL) != 0)
        {
          uint64_t v109 = (unsigned __int8 *)((v91 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v110 = v30 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v109 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v30, v91);
        }

        closure #1 in _StringGuts._convertedToSmall()(v109, v110, &v126);
        swift_bridgeObjectRelease(v91);
        uint64_t v91 = *((void *)&v126 + 1);
        unint64_t v30 = v126;
      }

  v231 = v280;
  v250 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
  ((void (*)(char *, uint64_t))v286)(v231, v77);
  if (__OFADD__(v250, 1074LL))
  {
    __break(1u);
    goto LABEL_110;
  }

  Swift::String::Index v71 = v287;
  Swift::String::Index v70 = v251;
  if (v250 + 1074 < v282)
  {
LABEL_108:
    v70((char *)v71, a2);
    return 0LL;
  }

        unint64_t v77 = _StringGuts.nativeCapacity.getter(v43, v7);
        if ((v78 & 1) != 0) {
          unint64_t v79 = 0LL;
        }
        else {
          unint64_t v79 = v77;
        }
        if (v79 + 0x4000000000000000LL >= 0)
        {
          unint64_t v80 = 2 * v79;
          if (v80 > v71) {
            Swift::String::Index v71 = v80;
          }
          goto LABEL_112;
        }

        __break(1u);
LABEL_212:
        unint64_t v164 = v7;
        if ((v43 & 0x1000000000000000LL) != 0)
        {
          uint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, v43);
          unint64_t v174 = v173;
          swift_bridgeObjectRelease(v43);
          uint64_t v43 = v174;
          uint64_t v7 = v164;
        }

        else
        {
          if ((v9 & 0x1000000000000000LL) != 0)
          {
            unint64_t v165 = (unsigned __int8 *)((v43 & 0xFFFFFFFFFFFFFFFLL) + 32);
            Swift::String::Index v166 = v9 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            unint64_t v165 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v43);
          }

          closure #1 in _StringGuts._convertedToSmall()(v165, v166, v176);
          swift_bridgeObjectRelease(v43);
          uint64_t v43 = *((void *)&v176[0] + 1);
          uint64_t v9 = *(void *)&v176[0];
        }

      Swift::Int v107 = v42;
      if ((v90 & 0x1000000000000000LL) != 0)
      {
        unint64_t v30 = _StringGuts._foreignConvertedToSmall()(v30, v90);
        uint64_t v113 = v112;
        swift_bridgeObjectRelease(v90);
        unint64_t v90 = v113;
        int64_t v42 = v107;
      }

      else
      {
        if ((v30 & 0x1000000000000000LL) != 0)
        {
          uint64_t v108 = (unsigned __int8 *)((v90 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v109 = v30 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v108 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v30, v90);
        }

        closure #1 in _StringGuts._convertedToSmall()(v108, v109, &v126);
        swift_bridgeObjectRelease(v90);
        unint64_t v90 = *((void *)&v126 + 1);
        unint64_t v30 = v126;
      }

        __break(1u);
        goto LABEL_107;
      }

    _StringGuts._foreignGrow(_:)(v21);
    if ((a2 & 0x1000000000000000LL) == 0) {
      goto LABEL_80;
    }
    goto LABEL_107;
  }

  uint64_t v10 = v23;
  if ((rawBits & 0x2000000000000000LL) == 0)
  {
    if ((rawBits & 0x1000000000000000LL) != 0)
    {
      uint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, v23);
      rawBits = v8._rawBits;
    }

    else
    {
      char v93 = v103;
      if ((v9 & 0x1000000000000000LL) != 0)
      {
        unint64_t v94 = (unsigned __int8 *)((rawBits & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        unint64_t v94 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v23);
        char v93 = v8._rawBits;
      }

      swift_bridgeObjectRetain(v10, v8._rawBits, a3, a4);
      closure #1 in _StringGuts._convertedToSmall()(v94, v93, &__src);
      swift_bridgeObjectRelease(v10);
      uint64_t v9 = __src;
      rawBits = v109;
    }
  }

  swift_bridgeObjectRetain(a2, v8._rawBits, a3, a4);
  if (v106)
  {
    swift_bridgeObjectRelease(a2);
  }

  else if ((a2 & 0x1000000000000000LL) != 0)
  {
    a1 = _StringGuts._foreignConvertedToSmall()(a1, a2);
    Swift::String::Index v99 = v98;
    swift_bridgeObjectRelease(a2);
    a2 = v99;
  }

  else
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      closure #1 in _StringGuts._convertedToSmall()((unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32), v102, &__src);
    }

    else
    {
      Swift::String::Index v100 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      closure #1 in _StringGuts._convertedToSmall()(v100, v101, &__src);
    }

    swift_bridgeObjectRelease(a2);
    a1 = __src;
    a2 = v109;
  }

  unint64_t v30 = HIBYTE(rawBits) & 0xF;
  Swift::String::Index v31 = HIBYTE(a2) & 0xF;
  unint64_t v20 = v31 + v30;
  if ((unint64_t)(v31 + v30) > 0xF)
  {
    uint64_t v97 = 266LL;
    goto LABEL_126;
  }

  if (v31)
  {
    size_t v32 = 0;
    uint64_t v33 = 0LL;
    do
    {
      unint64_t v34 = v30 + v33;
      unint64_t v35 = v33 + 1;
      if (v33 >= 8) {
        unint64_t v36 = a2;
      }
      else {
        unint64_t v36 = a1;
      }
      unint64_t v37 = v36 >> (v32 & 0x38);
      id v38 = (8 * v30 + v32) & 0x38;
      unint64_t v39 = (-255LL << v38) - 1;
      unint64_t v40 = (unint64_t)v37 << v38;
      uint64_t v41 = v40 | v39 & rawBits;
      int64_t v42 = v40 | v39 & v9;
      if (v34 < 8) {
        uint64_t v9 = v42;
      }
      else {
        rawBits = v41;
      }
      v32 += 8;
      uint64_t v33 = v35;
    }

    while (v31 != v35);
  }

LABEL_114:
      unint64_t v112 = 266LL;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v112,  0);
  }

  if (v91 <= 15) {
    goto LABEL_90;
  }
LABEL_88:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v91, 1LL);
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
  __int128 v126 = xmmword_1817FFC80;
  unint64_t v94 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v126, 1LL);
  _StringGuts.appendInPlace(_:isASCII:)(v94, v95, 1);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v128;
}

      v540(v526, v551);
      ((void (*)(char *, unint64_t *))v541)(v522, v535);
      (*(void (**)(char *, unint64_t))(v553 + 8))(v552, v554);
      v380 = v568;
      v381 = v530(v568, v303);
      (*(void (**)(char *, uint64_t, uint64_t))(v565 + 16))(v501, v569, v380);
      if ((v381 & 1) != 0)
      {
        if ((((uint64_t (*)(void))v530)() & 1) != 0)
        {
          if (v537(v568, v566) < 64) {
            goto LABEL_163;
          }
LABEL_120:
          v573 = 0LL;
          v386 = v566;
          v387 = v558;
          v388 = v568;
          (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v566 + 96))( &v573,  &type metadata for Int,  v545,  v568,  v566);
          v389 = v501;
          LOBYTE(v386) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v386 + 32) + 8LL)
                                                                            + 16LL))( v501,  v387,  v388);
          v390 = v387;
          v391 = v550;
          v550(v390, v388);
          v391(v389, v388);
          if ((v386 & 1) != 0) {
            goto LABEL_174;
          }
LABEL_167:
          (*(void (**)(void *))(v538 + 112))(v567);
          goto LABEL_58;
        }

        v382 = v568;
        v383 = v566;
        v384 = v530(v568, v566);
        v385 = v537(v382, v383);
        if ((v384 & 1) != 0)
        {
          if (v385 <= 64)
          {
            v476 = (void (**)(char *, uint64_t, const char *))v544;
            v477 = v568;
            v478 = v542;
            v479 = swift_getAssociatedConformanceWitness( (uint64_t)v544,  v568,  v542,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v480 = v543;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v479 + 8))( &unk_18180BE68,  256LL,  v478,  v479);
            v481 = v558;
            v476[3](v480, v477, (const char *)v476);
            v482 = v501;
            LOBYTE(v476) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v566 + 32) + 8LL)
                                                                              + 16LL))( v501,  v481,  v477);
            v550(v481, v477);
            (*(void (**)(char *, char *, uint64_t))(v565 + 32))(v485, v482, v477);
            if ((v476 & 1) == 0)
            {
              v471 = *(uint64_t (**)(uint64_t))(v566 + 120);
              v472 = (unint64_t **)&v517;
LABEL_164:
              v473 = (char *)*(v472 - 32);
              v474 = v568;
              v475 = v471(v568);
              v550(v473, v474);
              if (v475 < 0) {
                goto LABEL_174;
              }
              goto LABEL_167;
            }

            v550(v485, v568);
LABEL_174:
            v483 = v495;
            v484 = (uint64_t)v567;
            (*(void (**)(void *))(v538 + 112))(v567);
            (*(void (**)(char *, uint64_t))(v494 + 16))(v483, v484);
            v534(v483, v484);
            goto LABEL_58;
          }

          goto LABEL_120;
        }

        if (v385 < 64)
        {
LABEL_163:
          v471 = *(uint64_t (**)(uint64_t))(v566 + 120);
          v472 = &v533;
          goto LABEL_164;
        }
      }

      v550(v501, v568);
      goto LABEL_167;
    }

    (*(void (**)(char *, char *, unint64_t *))(v529 + 32))(v488, v513, v533);
    if ((uint64_t)v528 > 0)
    {
      v573 = (uint64_t)v528;
      v374 = v536;
      v375 = v521;
      v376 = v533;
      (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v536 + 96))( &v573,  &type metadata for Int,  v545,  v533,  v536);
      v377 = v488;
      LOBYTE(v374) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v374 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v488,  v375,  v376);
      v378 = v375;
      v379 = v514;
      ((void (*)(char *, unint64_t *))v514)(v378, v376);
      ((void (*)(char *, unint64_t *))v379)(v377, v376);
      v303 = v566;
      if ((v374 & 1) == 0) {
        goto LABEL_132;
      }
      goto LABEL_114;
    }

    v410 = v488;
    v411 = v533;
    v412 = (char **)&v546;
LABEL_131:
    ((void (*)(char *, unint64_t *))*(v412 - 32))(v410, v411);
    v303 = v566;
    goto LABEL_132;
  }

      unint64_t v111 = 266LL;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v111,  0);
  }

  if (v90 <= 15) {
    goto LABEL_90;
  }
LABEL_88:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v90, 1LL);
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
  __int128 v126 = xmmword_1817FFC80;
  char v93 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v126, 1LL);
  _StringGuts.appendInPlace(_:isASCII:)(v93, v94, 1);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v127;
}

      uint64_t v127 = v81 - 8;
      uint64_t v128 = 8LL;
      if (v81 < 8) {
        uint64_t v128 = v81;
      }
      if ((v128 & 0x8000000000000000LL) == 0)
      {
        if (v128 >= 8)
        {
          if (v128 >= 0x10)
          {
            unint64_t v129 = v128 & 0xFFFFFFFFFFFFFFF0LL;
            BOOL v154 = vmovl_high_u8(*TypeName);
            int64_t v155 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v154.i8);
            int64_t v156 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            char v157 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v156.i8);
            v158 = (int8x16_t)vmovl_high_u16(v154);
            BOOL v159 = (int8x8_t)vextq_s8(v158, v158, 8uLL).u64[0];
            uint64_t v160 = (int8x16_t)vmovl_high_u16(v156);
            uint64_t v161 = (int8x8_t)vextq_s8(v160, v160, 8uLL).u64[0];
            *(int8x8_t *)v160.i8 = vorr_s8(*(int8x8_t *)v160.i8, *(int8x8_t *)v158.i8);
            v162.i64[0] = v160.u32[0];
            v162.i64[1] = v160.u32[1];
            unint64_t v163 = (int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1817FFCE0);
            *(int8x8_t *)v158.i8 = vorr_s8(*(int8x8_t *)v157.i8, *(int8x8_t *)v155.i8);
            v162.i64[0] = v158.u32[0];
            v162.i64[1] = v158.u32[1];
            unint64_t v164 = vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1817FFCD0), v163);
            *(int8x8_t *)v158.i8 = vorr_s8(v161, v159);
            v162.i64[0] = v158.u32[0];
            v162.i64[1] = v158.u32[1];
            unint64_t v165 = (int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1817FFCC0);
            *(int8x8_t *)v155.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v157, v157, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v155, v155, 8uLL));
            v162.i64[0] = v155.u32[0];
            v162.i64[1] = v155.u32[1];
            Swift::String::Index v166 = vorrq_s8(v164, vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1817FFCB0), v165));
            uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v166.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v166, v166, 8uLL));
            if (v128 == (v128 & 0xFFFFFFFFFFFFFFF0LL)) {
              goto LABEL_135;
            }
            uint64_t v130 = 8 * v129;
            if ((v128 & 8) == 0) {
              goto LABEL_133;
            }
          }

          else
          {
            uint64_t countAndFlagsBits = 0LL;
            uint64_t v130 = 0LL;
            unint64_t v129 = 0LL;
          }

          v131 = v129;
          size_t v132 = vdupq_n_s64(v130);
          unint64_t v129 = v128 & 0xFFFFFFFFFFFFFFF8LL;
          uint64_t v130 = 8 * (v128 & 0xFFFFFFFFFFFFFFF8LL);
          uint64_t v133 = 0uLL;
          uint64_t v134 = (int8x16_t)(unint64_t)countAndFlagsBits;
          v135 = vaddq_s64(v132, (int64x2_t)xmmword_1817FFCC0);
          unint64_t v136 = vaddq_s64(v132, (int64x2_t)xmmword_1817FFCE0);
          uint64_t v137 = vaddq_s64(v132, (int64x2_t)xmmword_1817FFCB0);
          id v138 = vaddq_s64(v132, (int64x2_t)xmmword_1817FFCD0);
          uint64_t v139 = (uint8x8_t *)&TypeName->i8[v131];
          uint64_t v140 = (int8x16_t)vdupq_n_s64(0x38uLL);
          uint64_t v141 = v131 - (v128 & 0xFFFFFFFFFFFFFFF8LL);
          unint64_t v142 = vdupq_n_s64(0x40uLL);
          unint64_t v143 = 0uLL;
          uint64_t v144 = 0uLL;
          do
          {
            uint64_t v145 = *v139++;
            uint64_t v146 = vmovl_u8(v145);
            unint64_t v147 = vmovl_high_u16(v146);
            v148.i64[0] = v147.u32[2];
            v148.i64[1] = v147.u32[3];
            unint64_t v149 = v148;
            v148.i64[0] = v147.u32[0];
            v148.i64[1] = v147.u32[1];
            uint64_t v150 = v148;
            uint64_t v151 = vmovl_u16(*(uint16x4_t *)v146.i8);
            v148.i64[0] = v151.u32[2];
            v148.i64[1] = v151.u32[3];
            char v152 = v148;
            v148.i64[0] = v151.u32[0];
            v148.i64[1] = v151.u32[1];
            uint64_t v144 = vorrq_s8((int8x16_t)vshlq_u64(v149, (uint64x2_t)vandq_s8((int8x16_t)v135, v140)), v144);
            unint64_t v143 = vorrq_s8((int8x16_t)vshlq_u64(v150, (uint64x2_t)vandq_s8((int8x16_t)v136, v140)), v143);
            uint64_t v133 = vorrq_s8((int8x16_t)vshlq_u64(v152, (uint64x2_t)vandq_s8((int8x16_t)v137, v140)), v133);
            uint64_t v134 = vorrq_s8((int8x16_t)vshlq_u64(v148, (uint64x2_t)vandq_s8((int8x16_t)v138, v140)), v134);
            unint64_t v136 = vaddq_s64(v136, v142);
            uint64_t v137 = vaddq_s64(v137, v142);
            id v138 = vaddq_s64(v138, v142);
            v135 = vaddq_s64(v135, v142);
            v141 += 8LL;
          }

          while (v141);
          uint64_t v153 = vorrq_s8(vorrq_s8(v134, v143), vorrq_s8(v133, v144));
          uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v153.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v153, v153, 8uLL));
          if (v128 == v129)
          {
LABEL_135:
            if (v81 < 9)
            {
              unint64_t v171 = 0LL;
LABEL_154:
              __int128 v235 = 0xA000000000000000LL;
              if (((*(void *)&v171 | countAndFlagsBits) & 0x8080808080808080LL) == 0) {
                __int128 v235 = 0xE000000000000000LL;
              }
              unint64_t object = v235 | (v81 << 56) | *(void *)&v171;
              goto LABEL_157;
            }

            if (v127 < 8)
            {
              unint64_t v170 = 0LL;
              unint64_t v171 = 0LL;
              unint64_t v172 = 0LL;
LABEL_152:
              uint64_t v232 = v81 - v170 - 8;
              uint64_t v233 = &TypeName->u8[v170 + 8];
              do
              {
                unint64_t v234 = *v233++;
                *(void *)&v171 |= (unint64_t)v234 << (v172 & 0x38);
                v172 += 8LL;
                --v232;
              }

              while (v232);
              goto LABEL_154;
            }

            if (v127 >= 0x10)
            {
              unint64_t v196 = (uint8x16_t *)&TypeName->u64[1];
              unint64_t v170 = v127 & 0xFFFFFFFFFFFFFFF0LL;
              unint64_t v197 = (int64x2_t)xmmword_1817FFD60;
              unint64_t v198 = (int64x2_t)xmmword_1817FFD70;
              Swift::String::Index v199 = (int64x2_t)xmmword_1817FFD80;
              Swift::String::Index v200 = (int64x2_t)xmmword_1817FFD90;
              Swift::String::Index v201 = (int64x2_t)xmmword_1817FFCC0;
              Swift::String::Index v202 = (int64x2_t)xmmword_1817FFCE0;
              unint64_t v203 = (int8x16_t)vdupq_n_s64(0x38uLL);
              unint64_t v204 = vdupq_n_s64(0x80uLL);
              unint64_t v205 = (int64x2_t)xmmword_1817FFCB0;
              unint64_t v172 = 8 * (v127 & 0xFFFFFFFFFFFFFFF0LL);
              unint64_t v206 = 0uLL;
              unint64_t v207 = 0uLL;
              unint64_t v208 = (int64x2_t)xmmword_1817FFCD0;
              unint64_t v209 = v127 & 0xFFFFFFFFFFFFFFF0LL;
              char v210 = 0uLL;
              v211 = 0uLL;
              size_t v212 = 0uLL;
              unint64_t v213 = 0uLL;
              unint64_t v214 = 0uLL;
              unint64_t v215 = 0uLL;
              do
              {
                v216 = *v196++;
                Swift::String::Index v217 = vmovl_u8(*(uint8x8_t *)v216.i8);
                Swift::String::Index v218 = vmovl_high_u16(v217);
                v219.i64[0] = v218.u32[2];
                v219.i64[1] = v218.u32[3];
                Swift::String::Index v220 = v219;
                Swift::Int v221 = vmovl_high_u8(v216);
                Swift::Int v222 = vmovl_u16(*(uint16x4_t *)v221.i8);
                v219.i64[0] = v222.u32[2];
                v219.i64[1] = v222.u32[3];
                uint64_t v223 = v219;
                v219.i64[0] = v222.u32[0];
                v219.i64[1] = v222.u32[1];
                unint64_t v224 = v219;
                v219.i64[0] = v218.u32[0];
                v219.i64[1] = v218.u32[1];
                uint64_t v225 = v219;
                uint64_t v226 = vmovl_u16(*(uint16x4_t *)v217.i8);
                v219.i64[0] = v226.u32[2];
                v219.i64[1] = v226.u32[3];
                __int128 v227 = v219;
                unint64_t v228 = vmovl_high_u16(v221);
                v219.i64[0] = v228.u32[0];
                v219.i64[1] = v228.u32[1];
                int64_t v229 = v219;
                v219.i64[0] = v226.u32[0];
                v219.i64[1] = v226.u32[1];
                uint64_t v230 = v219;
                v219.i64[0] = v228.u32[2];
                v219.i64[1] = v228.u32[3];
                v211 = vorrq_s8((int8x16_t)vshlq_u64(v220, (uint64x2_t)vandq_s8((int8x16_t)v201, v203)), v211);
                unint64_t v213 = vorrq_s8((int8x16_t)vshlq_u64(v223, (uint64x2_t)vandq_s8((int8x16_t)v199, v203)), v213);
                size_t v212 = vorrq_s8((int8x16_t)vshlq_u64(v224, (uint64x2_t)vandq_s8((int8x16_t)v200, v203)), v212);
                char v210 = vorrq_s8((int8x16_t)vshlq_u64(v225, (uint64x2_t)vandq_s8((int8x16_t)v202, v203)), v210);
                unint64_t v207 = vorrq_s8((int8x16_t)vshlq_u64(v227, (uint64x2_t)vandq_s8((int8x16_t)v205, v203)), v207);
                unint64_t v214 = vorrq_s8((int8x16_t)vshlq_u64(v229, (uint64x2_t)vandq_s8((int8x16_t)v198, v203)), v214);
                unint64_t v206 = vorrq_s8((int8x16_t)vshlq_u64(v230, (uint64x2_t)vandq_s8((int8x16_t)v208, v203)), v206);
                unint64_t v215 = vorrq_s8((int8x16_t)vshlq_u64(v219, (uint64x2_t)vandq_s8((int8x16_t)v197, v203)), v215);
                Swift::String::Index v202 = vaddq_s64(v202, v204);
                unint64_t v205 = vaddq_s64(v205, v204);
                unint64_t v208 = vaddq_s64(v208, v204);
                Swift::String::Index v201 = vaddq_s64(v201, v204);
                Swift::String::Index v200 = vaddq_s64(v200, v204);
                Swift::String::Index v199 = vaddq_s64(v199, v204);
                unint64_t v198 = vaddq_s64(v198, v204);
                unint64_t v197 = vaddq_s64(v197, v204);
                v209 -= 16LL;
              }

              while (v209);
              v231 = vorrq_s8( vorrq_s8(vorrq_s8(v206, v212), vorrq_s8(v210, v214)),  vorrq_s8(vorrq_s8(v207, v213), vorrq_s8(v211, v215)));
              unint64_t v171 = vorr_s8(*(int8x8_t *)v231.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v231, v231, 8uLL));
              if (v127 == v170) {
                goto LABEL_154;
              }
              if ((v127 & 8) == 0) {
                goto LABEL_152;
              }
            }

            else
            {
              unint64_t v171 = 0LL;
              unint64_t v172 = 0LL;
              unint64_t v170 = 0LL;
            }

            unint64_t v173 = v170;
            unint64_t v170 = v127 & 0xFFFFFFFFFFFFFFF8LL;
            unint64_t v174 = vdupq_n_s64(v172);
            unint64_t v172 = 8 * (v127 & 0xFFFFFFFFFFFFFFF8LL);
            unint64_t v175 = (int8x16_t)(unint64_t)v171;
            unint64_t v176 = 0uLL;
            unint64_t v177 = vaddq_s64(v174, (int64x2_t)xmmword_1817FFCC0);
            char v178 = vaddq_s64(v174, (int64x2_t)xmmword_1817FFCE0);
            unint64_t v179 = vaddq_s64(v174, (int64x2_t)xmmword_1817FFCB0);
            unint64_t v180 = vaddq_s64(v174, (int64x2_t)xmmword_1817FFCD0);
            uint64_t v181 = (uint8x8_t *)((char *)&TypeName->u64[1] + v173);
            unint64_t v182 = (int8x16_t)vdupq_n_s64(0x38uLL);
            Swift::Int v183 = v173 - (v127 & 0xFFFFFFFFFFFFFFF8LL);
            uint64_t v184 = vdupq_n_s64(0x40uLL);
            v185 = 0uLL;
            unint64_t v186 = 0uLL;
            do
            {
              unint64_t v187 = *v181++;
              int64_t v188 = vmovl_u8(v187);
              int64_t v189 = vmovl_high_u16(v188);
              v190.i64[0] = v189.u32[2];
              v190.i64[1] = v189.u32[3];
              v191 = v190;
              v190.i64[0] = v189.u32[0];
              v190.i64[1] = v189.u32[1];
              BOOL v192 = v190;
              uint64_t v193 = vmovl_u16(*(uint16x4_t *)v188.i8);
              v190.i64[0] = v193.u32[2];
              v190.i64[1] = v193.u32[3];
              uint64_t v194 = v190;
              v190.i64[0] = v193.u32[0];
              v190.i64[1] = v193.u32[1];
              unint64_t v186 = vorrq_s8((int8x16_t)vshlq_u64(v191, (uint64x2_t)vandq_s8((int8x16_t)v177, v182)), v186);
              v185 = vorrq_s8((int8x16_t)vshlq_u64(v192, (uint64x2_t)vandq_s8((int8x16_t)v178, v182)), v185);
              unint64_t v176 = vorrq_s8((int8x16_t)vshlq_u64(v194, (uint64x2_t)vandq_s8((int8x16_t)v179, v182)), v176);
              unint64_t v175 = vorrq_s8((int8x16_t)vshlq_u64(v190, (uint64x2_t)vandq_s8((int8x16_t)v180, v182)), v175);
              char v178 = vaddq_s64(v178, v184);
              unint64_t v179 = vaddq_s64(v179, v184);
              unint64_t v180 = vaddq_s64(v180, v184);
              unint64_t v177 = vaddq_s64(v177, v184);
              v183 += 8LL;
            }

            while (v183);
            v195 = vorrq_s8(vorrq_s8(v175, v185), vorrq_s8(v176, v186));
            unint64_t v171 = vorr_s8(*(int8x8_t *)v195.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v195, v195, 8uLL));
            if (v127 == v170) {
              goto LABEL_154;
            }
            goto LABEL_152;
          }
        }

        else
        {
          unint64_t v129 = 0LL;
          uint64_t countAndFlagsBits = 0LL;
          uint64_t v130 = 0LL;
        }

      unint64_t v165 = v444._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      goto LABEL_129;
    }

    uint64_t v194 = specialized _SmallString.init(_:appending:)( v450,  v451,  v444._countAndFlagsBits,  (unint64_t)v444._object);
    if ((v196 & 1) != 0)
    {
      unint64_t v165 = HIBYTE(object) & 0xF;
      uint64_t v150 = v443;
      BOOL v159 = v145;
      goto LABEL_129;
    }

    unint64_t v197 = v194;
    unint64_t v198 = v195;
    swift_bridgeObjectRelease(object);
    swift_bridgeObjectRelease(v163);
    v450 = v197;
    v451 = v198;
  }

  else
  {
    Swift::String::Index v166 = v420;
    memcpy(v420, v87, v2);
    Swift::String::Index v167 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v166, v1, v167, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      Swift::String::Index v168 = (uint64_t)v445;
      Swift::String::Index v169 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v169 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v168,  v169);
    }

    else
    {
      v449 = 0LL;
      v447 = 0u;
      v448 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
      unint64_t v173 = v412;
      memcpy(v412, v87, v2);
      unint64_t v174 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
      if (swift_dynamicCast((char *)&v447, v173, v1, v174, 6uLL))
      {
        outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
        unint64_t v175 = (uint64_t)v445;
        unint64_t v176 = v446;
        __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
        char v178 = (*(uint64_t (**)(uint64_t, uint64_t))(v176 + 8))(v175, v176);
        unint64_t v179 = v177;
        unint64_t v180 = HIBYTE(v451) & 0xF;
        if ((v451 & 0x2000000000000000LL) == 0) {
          unint64_t v180 = v450 & 0xFFFFFFFFFFFFLL;
        }
        if (v180 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
        {
          _StringGuts.append(_:)(v178, v177);
          swift_bridgeObjectRelease(v179);
        }

        else
        {
          swift_bridgeObjectRelease(v451);
          v450 = v178;
          v451 = v179;
        }

        uint64_t v150 = v443;
        BOOL v159 = v145;
        __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
        goto LABEL_130;
      }

      v449 = 0LL;
      v447 = 0u;
      v448 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?);
      unint64_t v186 = v404;
      memcpy(v404, v87, v2);
      unint64_t v187 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
      if (!swift_dynamicCast((char *)&v447, v186, v1, v187, 6uLL))
      {
        v449 = 0LL;
        v447 = 0u;
        v448 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((void *)&v448 + 1) = v1;
        Swift::String::Index v200 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
        memcpy(v200, v87, v2);
        Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
        Swift::String::Index v201 = v444._object;
        Swift::String::Index v202 = v446;
        ((void (*)(char *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v87,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
        swift_release(v202);
        swift_release((uint64_t)v201);
        goto LABEL_100;
      }

      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      int64_t v188 = (uint64_t)v445;
      int64_t v189 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      char v190 = (*(uint64_t (**)(uint64_t, uint64_t))(v189 + 8))(v188, v189);
      BOOL v192 = v191;
      specialized String.write<A>(to:)(&v450, v190, v191, v193);
      swift_bridgeObjectRelease(v192);
    }

    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  }

  unint64_t v206 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000LL) == 0) {
    unint64_t v206 = v407 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v207 = v383;
  if (v206 || (v407 & ~v408 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236LL;
    v408 = 0xE200000000000000LL;
  }

  v145(4LL, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  unint64_t v208 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v208, v207, v3);
  unint64_t v209 = v402;
  char v210 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  v211 = (void *)swift_getDynamicType(v210, v209, 1);
  LODWORD(v209) = swift_isOptionalType(v211);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v209)
  {
    memcpy(v101, v207, v3);
    size_t v212 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v212, 7uLL);
LABEL_121:
    unint64_t v213 = (uint64_t)v402;
    unint64_t v214 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    unint64_t v215 = (*(uint64_t (**)(uint64_t, uint64_t))(v214 + 8))(v213, v214);
    Swift::String::Index v217 = v216;
    specialized String.write<A>(to:)(&v407, v215, v216, v218);
    swift_bridgeObjectRelease(v217);
LABEL_122:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_125;
  }

  Swift::String::Index v219 = v375;
  memcpy(v375, v207, v3);
  if ((swift_dynamicCast((char *)&v401, v219, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    Swift::String::Index v220 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v220);
  }

  else
  {
    v298 = v369;
    memcpy(v369, v207, v3);
    v299 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v298, v2, v299, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v300 = (uint64_t)v402;
      v301 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v301 + 8))( &v407,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v300,  v301);
      goto LABEL_122;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v322 = v363;
    memcpy(v363, v207, v3);
    v323 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v322, v2, v323, 6uLL)
      || (v406 = 0LL,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomStringConvertible?),  v324 = v357,  memcpy(v357, v207, v3),  v325 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v404, v324, v2, v325, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_121;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v405 + 1) = v2;
    v345 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v345, v207, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v346 = v401._object;
    v347 = v207;
    v348 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v347,  &v401,  &v407,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v348);
    swift_release((uint64_t)v346);
  }

  if (!a5) {
    goto LABEL_207;
  }
  unint64_t v53 = *((unsigned __int8 *)v17 + 18);
  uint64_t v54 = (swift::Demangle::__runtime::Node **)v17;
  if ((v53 - 1) >= 2)
  {
    if (v53 == 5)
    {
      uint64_t v55 = (uint64_t *)*v17;
      uint64_t v54 = (swift::Demangle::__runtime::Node **)*v17;
      goto LABEL_130;
    }

    uint64_t v54 = 0LL;
  }

  switch(v53)
  {
    case 1:
      char v61 = (swift::Demangle::__runtime::Node **)(v17 + 1);
      if (v54 != (swift::Demangle::__runtime::Node **)(v17 + 1)) {
        goto LABEL_137;
      }
      break;
    case 2:
      char v61 = (swift::Demangle::__runtime::Node **)(v17 + 2);
      if (v54 != (swift::Demangle::__runtime::Node **)(v17 + 2)) {
        goto LABEL_137;
      }
      break;
    case 5:
      uint64_t v55 = (uint64_t *)*v17;
LABEL_130:
      char v61 = (swift::Demangle::__runtime::Node **)&v55[*((unsigned int *)v17 + 2)];
      if (v54 != v61) {
        goto LABEL_137;
      }
      break;
    default:
      char v61 = 0LL;
      if (v54)
      {
LABEL_137:
        while (*((_WORD *)*v54 + 8) != 232)
        {
          if (++v54 == v61)
          {
            uint64_t v54 = v61;
            goto LABEL_140;
          }
        }
      }

      break;
  }

uint64_t Dictionary.Values.debugDescription.getter(int64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  int64_t v4 = a1;
  unint64_t v219 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)v217 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for Optional(0LL, v7, v7, v8);
  MEMORY[0x1895F8858](v9);
  Swift::Int v222 = (char *)v217 - v10;
  unint64_t v231 = 0LL;
  unint64_t v232 = 0xE000000000000000LL;
  uint64_t v11 = specialized static String._createEmpty(withInitialCapacity:)(4LL);
  unint64_t v15 = v11;
  unint64_t v16 = v12;
  *(void *)&__int128 v230 = v11;
  *((void *)&v230 + 1) = v12;
  unint64_t v17 = HIBYTE(v12) & 0xF;
  int64_t v18 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v12 & 0x2000000000000000LL) != 0) {
    uint64_t v19 = HIBYTE(v12) & 0xF;
  }
  else {
    uint64_t v19 = v11 & 0xFFFFFFFFFFFFLL;
  }
  if (!v19 && (v11 & ~v12 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v12);
    unint64_t v15 = 0LL;
    unint64_t v41 = 0xE000000000000000LL;
    *(void *)&__int128 v230 = 0LL;
LABEL_21:
    *((void *)&v230 + 1) = v41;
    goto LABEL_25;
  }

  if ((v12 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v12);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v45 = 0xA000000000000000LL;
    if (!(v16 & 0x80808080808080LL | v15 & 0x8080808080808080LL)) {
      unint64_t v45 = 0xE000000000000000LL;
    }
    unint64_t v41 = v45 & 0xFF00000000000000LL | (v17 << 56) | v16 & 0xFFFFFFFFFFFFFFLL;
    *(void *)&__int128 v230 = v15;
    goto LABEL_21;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v13, v14);
  if ((v16 & 0x1000000000000000LL) != 0)
  {
    int64_t v18 = String.UTF8View._foreignCount()();
    if ((v15 & ~v16 & 0x2000000000000000LL) == 0) {
      goto LABEL_23;
    }
  }

  else if ((v15 & ~v16 & 0x2000000000000000LL) == 0)
  {
    goto LABEL_23;
  }

  if (swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v15, v16);
    if ((v21 & 1) != 0) {
      goto LABEL_211;
    }
    if (v18 <= 15 && (v20 & 0x8000000000000000LL) != 0) {
      goto LABEL_13;
    }
LABEL_24:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v18, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    unint64_t v227 = 0LL;
    uint64_t v228 = 0LL;
    uint64_t v46 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v227, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v46, v47, 1);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v41 = *((void *)&v230 + 1);
    unint64_t v15 = v230;
    goto LABEL_25;
  }

LABEL_210:
                unint64_t v216 = 266LL;
LABEL_212:
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v216,  0);
              }

          unint64_t v177 = 266LL;
LABEL_212:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v177,  0);
        }

        unint64_t v87 = 0;
        uint64_t v3 = v9;
LABEL_137:
        id v1 = v185;
        swift_bridgeObjectRelease_n(v8, 5LL);
        uint64_t v109 = v187;
        if (v87)
        {
          if ((v3 & 0x1000000000000000LL) != 0)
          {
            uint64_t v109 = _StringGuts._foreignConvertedToSmall()(v187, v9);
            uint64_t v3 = v178;
          }

          else
          {
            if ((v187 & 0x1000000000000000LL) != 0)
            {
              unint64_t v169 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
              unint64_t v170 = v187 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              unint64_t v169 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v187, v9);
              unint64_t v170 = v106;
            }

            swift_bridgeObjectRetain(v9, v106, v107, v108);
            closure #1 in _StringGuts._convertedToSmall()(v169, v170, v186);
            swift_bridgeObjectRelease(v9);
            uint64_t v3 = *((void *)&v186[0] + 1);
            uint64_t v109 = *(void *)&v186[0];
          }
        }

        v110._rawBits = (v2 << 16) | 1;
        v111._rawBits = 1LL;
        v112._rawBits = _StringGuts.validateScalarRange(_:)(v111, v110, v11, v8);
        if (v112._rawBits < 0x10000) {
          v112._rawBits |= 3;
        }
        uint64_t v114 = specialized String.init(_:)(v112, v113, v11, v8);
        uint64_t v116 = v115;
        swift_bridgeObjectRelease(v8);
        if ((v116 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v116);
          uint64_t v2 = v184;
        }

        else
        {
          uint64_t v2 = v184;
          if ((v116 & 0x1000000000000000LL) != 0)
          {
            uint64_t v114 = _StringGuts._foreignConvertedToSmall()(v114, v116);
            Swift::Int v180 = v179;
            swift_bridgeObjectRelease(v116);
            uint64_t v116 = v180;
          }

          else
          {
            if ((v114 & 0x1000000000000000LL) != 0)
            {
              unint64_t v171 = (unsigned __int8 *)((v116 & 0xFFFFFFFFFFFFFFFLL) + 32);
              unint64_t v172 = v114 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              unint64_t v171 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v114, v116);
            }

            closure #1 in _StringGuts._convertedToSmall()(v171, v172, v186);
            swift_bridgeObjectRelease(v116);
            uint64_t v116 = *((void *)&v186[0] + 1);
            uint64_t v114 = *(void *)&v186[0];
          }
        }

        uint64_t v117 = HIBYTE(v3) & 0xF;
        uint64_t v118 = HIBYTE(v116) & 0xF;
        unint64_t v119 = v118 + v117;
        if ((unint64_t)(v118 + v117) <= 0xF)
        {
          if (v118)
          {
            uint64_t v120 = 0;
            unint64_t v121 = 0LL;
            do
            {
              uint64_t v122 = v117 + v121;
              uint64_t v123 = v121 + 1;
              if (v121 >= 8) {
                uint64_t v124 = v116;
              }
              else {
                uint64_t v124 = v114;
              }
              uint64_t v125 = v124 >> (v120 & 0x38);
              unint64_t v126 = (8 * v117 + v120) & 0x38;
              uint64_t v127 = (-255LL << v126) - 1;
              uint64_t v128 = (unint64_t)v125 << v126;
              size_t v129 = v128 | v127 & v3;
              uint64_t v130 = v128 | v127 & v109;
              if (v122 < 8) {
                uint64_t v109 = v130;
              }
              else {
                uint64_t v3 = v129;
              }
              v120 += 8;
              unint64_t v121 = v123;
            }

            while (v118 != v123);
          }

          swift_bridgeObjectRelease(v9);
          swift_bridgeObjectRelease(v8);
          v131 = 0xA000000000000000LL;
          if (!(v109 & 0x8080808080808080LL | v3 & 0x80808080808080LL)) {
            v131 = 0xE000000000000000LL;
          }
          char v187 = v109;
          int64_t v188 = v131 & 0xFF00000000000000LL | (v119 << 56) | v3 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_159;
        }

        goto LABEL_210;
      }

  v312 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    v312 = v450 & 0xFFFFFFFFFFFFLL;
  }
  v313 = v442;
  if (v312 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236LL;
    v451 = 0xE200000000000000LL;
  }

  v159(7LL, v199, v203);
  v445 = (uint64_t *)v1;
  v314 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v314, v313, v2);
  v315 = v445;
  v316 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v317 = (void *)swift_getDynamicType(v316, v315, 1);
  LODWORD(v315) = swift_isOptionalType(v317);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v315)
  {
    memcpy(v150, v313, v2);
    v318 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v318, 7uLL);
LABEL_217:
    v319 = (uint64_t)v445;
    v320 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v321 = (*(uint64_t (**)(uint64_t, uint64_t))(v320 + 8))(v319, v320);
    v323 = v322;
    specialized String.write<A>(to:)(&v450, v321, v322, v324);
    swift_bridgeObjectRelease(v323);
LABEL_218:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_221;
  }

  v325 = v434;
  memcpy(v434, v313, v2);
  if ((swift_dynamicCast((char *)&v444, v325, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v326 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v326);
  }

  else
  {
    v349 = v427;
    memcpy(v427, v313, v2);
    v350 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v349, v1, v350, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v351 = (uint64_t)v445;
      v352 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v352 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v351,  v352);
      goto LABEL_218;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v373 = v419;
    memcpy(v419, v313, v2);
    v374 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v373, v1, v374, 6uLL)
      || (v449 = 0LL,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?),  v375 = v411,  memcpy(v411, v313, v2),  v376 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v447, v375, v1, v376, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_217;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v448 + 1) = v1;
    v400 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v400, v313, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v401 = v444._object;
    v402 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v313,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v402);
    swift_release((uint64_t)v401);
  }

                LOBYTE(v24) = 9;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 7u:
              if (v11 < 0xA)
              {
                uint64_t v24 = 10;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                unint64_t v25 = 10;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_213;
                }
                goto LABEL_226;
              }

              unint64_t v25 = 10;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int64_t v18 = 10;
                  goto LABEL_9;
                }

LABEL_192:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v185, 2LL);
              swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
              __int128 v230 = xmmword_1817FFD00;
              unint64_t v208 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v230, 2LL);
              _StringGuts.appendInPlace(_:isASCII:)(v208, v209, 1);
              swift_bridgeObjectRelease(0x80000001818B6150LL | 0x8000000000000000LL);
              swift_bridgeObjectRelease(0xE200000000000000LL);
              return v231;
            }

    unint64_t v241 = v159 & 0xFFFFFFFFFFFF0000LL;
    unint64_t v240 = 1LL;
LABEL_193:
    v241 |= v240 << 8;
  }

  v247 = v241 | 5;
  if ((v159 & 2) != 0 && (v47 < v131 || _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v241 | 5)))) {
    v247 = v241 | 7;
  }
  *uint64_t v43 = v247;
LABEL_199:
  if (v32) {
LABEL_200:
  }
    v43[1] = (v35 << 16) | 5;
}

LABEL_211:
            unint64_t v216 = 258LL;
            goto LABEL_212;
          }

          int64_t v139 = v225 + 2;
        }

      unint64_t v177 = 258LL;
      goto LABEL_212;
    }

          getContextDescriptor(v105, (uint64_t)&v175);
          if (!v175 || (swift::equalContexts((const char *)v175, (const char *)CanonicalTypeMetadata) & 1) == 0)
          {
            uint64_t v107 = 1;
            goto LABEL_215;
          }

          CanonicalTypeMetadata = (uint64_t (***)())v105;
LABEL_225:
          uint64_t WitnessTable = swift::TargetProtocolConformanceDescriptor<swift::InProcess>::getWitnessTable( v78,  (uint64_t)CanonicalTypeMetadata,  a3,  a4);
          ConformanceState::cacheResult((uint64_t)&Conformances, (uint64_t)v173, (uint64_t)v172);
          return WitnessTable;
        }
      }

      else
      {
        if (v81) {
          goto LABEL_178;
        }
        char v82 = *v80;
        if (!(_DWORD)v82) {
          goto LABEL_178;
        }
        CanonicalTypeMetadata = (uint64_t (***)())((char *)v80 + v82);
      }

      unint64_t v84 = 1;
      goto LABEL_205;
    }

    char v175 = (void *)1;
    unint64_t v176 = (__swift::__runtime::llvm *)-4096LL;
    v177[1] = -4096LL;
    v177[3] = -4096LL;
    v177[5] = -4096LL;
    size_t v85 = (uint64_t)v172;
    unint64_t v86 = (uint64_t)v173;
    if (swift::runtime::trace::LogsToken != -1) {
      dispatch_once_f(&swift::runtime::trace::LogsToken, 0LL, (dispatch_function_t)swift::runtime::trace::setupLogs);
    }
    if (swift::runtime::trace::TracingEnabled)
    {
      spidb = os_signpost_id_generate((os_log_t)swift::runtime::trace::ScanLog);
      if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
      {
        TypeName = swift_getTypeName(v86, 1LL);
        uint64_t v91 = v90;
        unint64_t v92 = v85 ? (char *)(*(int *)(v85 + 8) + v85 + 8) : "<null>";
        if (spidb - 1 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v151 = (os_log_s *)swift::runtime::trace::ScanLog;
          if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
          {
            *(_DWORD *)buf = 68158722;
            *(_DWORD *)&buf[4] = v91;
            *(_WORD *)&buf[8] = 2080;
            *(void *)&buf[10] = TypeName;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v86;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v92;
            *(_WORD *)&buf[38] = 2048;
            unint64_t v179 = (void **)v85;
            _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v151,  OS_SIGNPOST_INTERVAL_BEGIN,  spidb,  "section_scan",  "protocol conformance scan for %.*s(%p): %s(%p)",  buf,  0x30u);
          }
        }
      }
    }

    else
    {
LABEL_187:
      spidb = 0LL;
    }

    do
      unint64_t v93 = __ldaxr(&qword_18C486E88);
    while (__stxr(v93 + 1, &qword_18C486E88));
    if (qword_18C486E90)
    {
      char v94 = atomic_load((unint64_t *)qword_18C486E90);
      uint64_t v95 = (int **)(qword_18C486E90 + 8);
      if (byte_18C486EA8)
      {
        if (v94)
        {
          unint64_t v96 = &v95[2 * v94];
          do
          {
            *(void *)buf = &v172;
            *(void *)&buf[8] = &v173;
            *(void *)&buf[16] = &v171;
            *(void *)&buf[24] = &v169;
            *(void *)&buf[32] = &Conformances;
            unint64_t v179 = &v175;
            if (byte_18C486EA8)
            {
              unint64_t v97 = (uint64_t)*(v96 - 2);
              unint64_t v98 = (uint64_t)*(v96 - 1);
              if (v98 != v97)
              {
                unint64_t v99 = v98 - 4;
                do
                {
                  Swift::String::Index v100 = *(int *)(v98 - 4);
                  v98 -= 4LL;
                  v99 -= 4LL;
                }

                while (v98 != v97);
              }
            }

            else
            {
              size_t v101 = *(v96 - 2);
              uint64_t v102 = *(v96 - 1);
              if (v101 != v102)
              {
                uint64_t v103 = *(v96 - 2);
                do
                {
                  unint64_t v104 = *v103++;
                }

                while (v103 != v102);
              }
            }

            v96 -= 2;
          }

          while (v96 != v95);
        }
      }

      else if (v94)
      {
        unint64_t v113 = &v95[2 * v94];
        do
        {
          *(void *)buf = &v172;
          *(void *)&buf[8] = &v173;
          *(void *)&buf[16] = &v171;
          *(void *)&buf[24] = &v169;
          *(void *)&buf[32] = &Conformances;
          unint64_t v179 = &v175;
          if (byte_18C486EA8)
          {
            uint64_t v114 = *v95;
            uint64_t v115 = v95[1];
            if (v115 != *v95)
            {
              uint64_t v116 = v115 - 1;
              do
              {
                uint64_t v117 = *--v115;
              }

              while (v115 != v114);
            }
          }

          else
          {
            uint64_t v118 = *v95;
            unint64_t v119 = v95[1];
            if (*v95 != v119)
            {
              uint64_t v120 = *v95;
              do
              {
                unint64_t v121 = *v120++;
              }

              while (v120 != v119);
            }
          }

          v95 += 2;
        }

        while (v95 != v113);
      }
    }

    uint64_t v122 = (uint64_t)v173;
    if (!v173)
    {
      uint64_t v128 = 0LL;
      unint64_t v126 = 0LL;
      uint64_t v124 = 0LL;
      uint64_t v123 = 0LL;
LABEL_255:
      if (v128) {
        unint64_t v145 = v124 == 255;
      }
      else {
        unint64_t v145 = 0;
      }
      unint64_t v146 = v145;
      if (*v169) {
        unint64_t v147 = 1;
      }
      else {
        unint64_t v147 = v146;
      }
      *unint64_t v169 = v147;
      if (spidb - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v148 = (os_log_s *)swift::runtime::trace::ScanLog;
        if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
        {
          *(_DWORD *)buf = 134217984;
          *(void *)&buf[4] = v126;
          _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v148,  OS_SIGNPOST_INTERVAL_END,  spidb,  "section_scan",  "result=%p",  buf,  0xCu);
        }
      }

      uint64_t WitnessTable = v160;
      if (v126 != 0 || v160 == 0) {
        uint64_t WitnessTable = v126;
      }
      do
        uint64_t v149 = __ldxr(&qword_18C486E88);
      while (__stlxr(v149 - 1, &qword_18C486E88));
      return WitnessTable;
    }

    uint64_t v123 = 0LL;
    uint64_t v124 = 0LL;
    uint64_t v125 = 0;
    unint64_t v126 = 0LL;
    uint64_t v127 = v171;
    uint64_t v128 = (uint64_t)v173;
    while ((v175 & 1) == 0)
    {
      uint64_t v137 = v177[0];
      if (LODWORD(v177[0]))
      {
        uint64_t v138 = v176;
        goto LABEL_246;
      }

          unint64_t v144 = 320;
        }

        return (int8x16_t *)swift::Demangle::__runtime::Demangler::demangleAutoDiffFunctionOrSimpleThunk( this,  v144,  a3,  a4,  a5);
      }

    case 'K':
    case 'k':
      if (v11 == 75) {
        unint64_t v16 = 131;
      }
      else {
        unint64_t v16 = 132;
      }
      if (v9 < v6 && *(_BYTE *)(v10 + v9) == 113)
      {
        *((void *)this + 9) = v5 + 2;
        unint64_t v17 = 1;
      }

      else
      {
        unint64_t v17 = 0;
      }

      unint64_t v34 = *((_DWORD *)this + 24);
      if (!v34) {
        return 0LL;
      }
      unint64_t v35 = v34 - 1;
      Node = *(void *)(*((void *)this + 11) + 8LL * (v34 - 1));
      *((_DWORD *)this + 24) = v34 - 1;
      if (!Node) {
        return (int8x16_t *)Node;
      }
      if (*(_WORD *)(Node + 16) != 232) {
        return 0LL;
      }
      BOOL v192 = v17;
      unint64_t v36 = 0LL;
      unint64_t v37 = 0LL;
      unint64_t v38 = 0LL;
      break;
    case 'L':
      uint64_t v62 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::popProtocol(this, a2, a3, a4, a5);
      this = v7;
      unint64_t v65 = 266;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::createWithChild(this, v65, v62, a4, a5);
    case 'M':
      uint64_t v62 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::popAssocTypeName( this,  a2,  a3,  a4,  a5);
      this = v7;
      unint64_t v65 = 7;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::createWithChild(this, v65, v62, a4, a5);
    case 'N':
      Swift::String::Index v66 = (char *)swift::Demangle::__runtime::Demangler::popProtocol(this, a2, a3, a4, a5);
      unint64_t v71 = swift::Demangle::__runtime::Demangler::popAssocTypePath(v7, v67, v68, v69, v70);
      unint64_t v72 = *((_DWORD *)v7 + 24);
      if (v72
        && (unint64_t v73 = v72 - 1,
            unint64_t v74 = *(swift::Demangle::__runtime::Node **)(*((void *)v7 + 11) + 8LL * v73),
            *((_WORD *)v74 + 8) == 232))
      {
        *((_DWORD *)v7 + 24) = v73;
      }

      else
      {
        unint64_t v74 = 0LL;
      }

      unint64_t v140 = v7;
      int64_t v141 = 268;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::createWithChildren( v140,  v141,  v74,  (swift::Demangle::__runtime::Node *)v71,  v66);
    case 'O':
      char v58 = 160;
      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    case 'P':
      unint64_t v75 = 87;
      goto LABEL_151;
    case 'Q':
    case 'Y':
      int64_t v18 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
      if (v11 == 81) {
        uint64_t v19 = 328;
      }
      else {
        uint64_t v19 = 329;
      }
      if (!v18) {
        return 0LL;
      }
      unint64_t v20 = (swift::Demangle::__runtime::Node *)v18;
      Node = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!Node || Node + 24 > *((void *)v7 + 2))
      {
        char v21 = 2LL * *((void *)v7 + 4);
        if (v21 <= 0x20) {
          char v21 = 32LL;
        }
        *((void *)v7 + 4) = v21;
        uint64_t v22 = v21 + 8;
        uint64_t v23 = malloc(v21 + 8);
        uint64_t v24 = (char *)v23 + v22;
        *uint64_t v23 = *((void *)v7 + 3);
        Node = ((unint64_t)v23 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v24;
        *((void *)v7 + 3) = v23;
      }

      *((void *)v7 + 1) = Node + 24;
      *(_WORD *)(Node + 16) = v19;
      *(_BYTE *)(Node + 18) = 0;
      goto LABEL_234;
    case 'R':
    case 'r':
    case 'y':
      if (v11 == 82)
      {
        uint64_t v13 = 0;
        unint64_t v12 = 201;
      }

      else if (v11 == 121)
      {
        unint64_t v12 = 202;
        uint64_t v13 = 1;
      }

      else
      {
        uint64_t v13 = 0;
        unint64_t v12 = 200;
      }

      Node = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!Node || Node + 24 > *((void *)this + 2))
      {
        size_t v129 = 2LL * *((void *)this + 4);
        if (v129 <= 0x20) {
          size_t v129 = 32LL;
        }
        *((void *)this + 4) = v129;
        uint64_t v130 = v129 + 8;
        v131 = malloc(v129 + 8);
        size_t v132 = (char *)v131 + v130;
        char *v131 = *((void *)v7 + 3);
        Node = ((unint64_t)v131 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v132;
        *((void *)v7 + 3) = v131;
      }

      *((void *)v7 + 1) = Node + 24;
      *(_WORD *)(Node + 16) = v12;
      *(_BYTE *)(Node + 18) = 0;
      unint64_t v133 = *((_DWORD *)v7 + 24);
      if (!v133) {
        return (int8x16_t *)Node;
      }
      unint64_t v134 = *(swift::Demangle::__runtime::Node **)(*((void *)v7 + 11) + 8LL * (v133 - 1));
      if (*((_WORD *)v134 + 8) == 43)
      {
        *((_DWORD *)v7 + 24) = v133 - 1;
        swift::Demangle::__runtime::Node::addChild((unsigned int *)Node, v134, v7, a4, a5);
        unint64_t v133 = *((_DWORD *)v7 + 24);
      }

      if (!v13) {
        goto LABEL_192;
      }
      if (!v133) {
        return (int8x16_t *)Node;
      }
      id v135 = *(swift::Demangle::__runtime::Node **)(*((void *)v7 + 11) + 8LL * (v133 - 1));
      if (*((_WORD *)v135 + 8) == 232)
      {
        *((_DWORD *)v7 + 24) = v133 - 1;
        swift::Demangle::__runtime::Node::addChild((unsigned int *)Node, v135, v7, a4, a5);
        unint64_t v133 = *((_DWORD *)v7 + 24);
LABEL_192:
        if (!v133) {
          return (int8x16_t *)Node;
        }
      }

      unint64_t v136 = *(swift::Demangle::__runtime::Node **)(*((void *)v7 + 11) + 8LL * (v133 - 1));
      if (*((_WORD *)v136 + 8) == 232)
      {
        *((_DWORD *)v7 + 24) = v133 - 1;
        swift::Demangle::__runtime::Node::addChild((unsigned int *)Node, v136, v7, a4, a5);
        unint64_t v133 = *((_DWORD *)v7 + 24);
        if (!v133) {
          return (int8x16_t *)Node;
        }
      }

      uint64_t v137 = v133 - 1;
      uint64_t v138 = *(swift::Demangle::__runtime::Node **)(*((void *)v7 + 11) + 8LL * v137);
      if (*((_WORD *)v138 + 8) != 232) {
        return (int8x16_t *)Node;
      }
      *((_DWORD *)v7 + 24) = v137;
      int64_t v139 = (unsigned int *)Node;
      goto LABEL_235;
    case 'S':
      uint64_t v76 = *((_DWORD *)this + 24);
      if (v76
        && ((char v77 = v76 - 1,
             unint64_t v78 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * (v76 - 1)),
             uint64_t v79 = *((unsigned __int16 *)v78 + 8),
             v79 == 232)
         || swift::Demangle::__runtime::isContext(v79)))
      {
        *((_DWORD *)v7 + 24) = v77;
      }

      else
      {
        unint64_t v78 = 0LL;
      }

      this = v7;
      unint64_t v65 = 194;
      goto LABEL_223;
    case 'U':
      uint64_t v80 = *((_DWORD *)this + 24);
      if (!v80) {
        return 0LL;
      }
      uint64_t v81 = *((void *)this + 11);
      unint64_t v20 = *(swift::Demangle::__runtime::Node **)(v81 + 8LL * (v80 - 1));
      if (*((_WORD *)v20 + 8) != 232) {
        return 0LL;
      }
      *((_DWORD *)this + 24) = v80 - 1;
      if (v80 == 1) {
        return 0LL;
      }
      char v82 = v80 - 2;
      char v83 = *(swift::Demangle::__runtime::Node **)(v81 + 8LL * v82);
      *((_DWORD *)this + 24) = v82;
      if (!v83) {
        return 0LL;
      }
      Node = swift::Demangle::__runtime::NodeFactory::createNode(this, 203);
      swift::Demangle::__runtime::Node::addChild((unsigned int *)Node, v83, v7, v84, v85);
      goto LABEL_234;
    case 'V':
      unint64_t v86 = *((_DWORD *)this + 24);
      if (v86)
      {
        unint64_t v87 = v86 - 1;
        char v88 = *((void *)this + 11);
        uint64_t v89 = *(unsigned __int16 **)(v88 + 8LL * (v86 - 1));
        uint64_t v90 = v89[8];
        if (v90 == 232 || swift::Demangle::__runtime::isContext(v90))
        {
          *((_DWORD *)v7 + 24) = v87;
          if (v86 == 1) {
            goto LABEL_287;
          }
        }

        else
        {
          uint64_t v89 = 0LL;
          unint64_t v87 = v86;
        }

        unint64_t v183 = v87 - 1;
        unint64_t v184 = *(void *)(v88 + 8LL * v183);
        int64_t v185 = *(unsigned __int16 *)(v184 + 16);
        if (v185 == 232 || swift::Demangle::__runtime::isContext(v185))
        {
          *((_DWORD *)v7 + 24) = v183;
          goto LABEL_288;
        }
      }

      else
      {
        uint64_t v89 = 0LL;
      }

uint64_t (*Dictionary.Keys.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

id __CocoaDictionary.Iterator.nextKey()(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void *)(v4 + 216);
  if (v5 < 0) {
    return 0LL;
  }
  if (v5 != *(void *)(v4 + 224)) {
    goto LABEL_5;
  }
  id result = objc_msgSend(*(id *)(v4 + 208), sel_countByEnumeratingWithState_objects_count_, v4 + 16, v4 + 80, 16);
  *(void *)(v4 + 224) = result;
  if (result)
  {
    uint64_t v5 = 0LL;
    *(void *)(v4 + 216) = 0LL;
LABEL_5:
    uint64_t v7 = *(void *)(v4 + 24);
    if (!v7) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x305uLL,  0);
    }
    if ((unint64_t)(v5 - 0x1000000000000000LL) >> 61 == 7)
    {
      uint64_t v8 = (void **)(v7 + 8 * v5);
      if ((v8 & 7) == 0)
      {
        uint64_t v9 = *v8;
        *(void *)(v4 + 216) = v5 + 1;
        return swift_unknownObjectRetain(v9, a2, a3, a4);
      }
    }

    else
    {
      __break(1u);
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
  }

  *(void *)(v4 + 216) = -1LL;
  return result;
}

uint64_t _NativeDictionary.Iterator.nextKey()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (v4)
  {
    v2[4] = (v4 - 1) & v4;
    unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
    uint64_t v6 = *(void *)(*v2 + 48LL);
    uint64_t v7 = *(void *)(result + 16);
    uint64_t v8 = *(void *)(v7 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v8 + 16))(a2, v6 + *(void *)(v8 + 72) * v5, v7);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v10 = a2;
    uint64_t v11 = 0LL;
    uint64_t v12 = v7;
    return v9(v10, v11, 1LL, v12);
  }

  uint64_t v13 = v2[3];
  int64_t v14 = v13 + 1;
  if (!__OFADD__(v13, 1LL))
  {
    int64_t v15 = (unint64_t)(v2[2] + 64LL) >> 6;
    if (v14 < v15)
    {
      v2[3] = v14;
      uint64_t v16 = v2[1];
      unint64_t v17 = *(void *)(v16 + 8 * v14);
      v2[4] = v17;
      if (v17)
      {
LABEL_7:
        v2[4] = (v17 - 1) & v17;
        unint64_t v5 = __clz(__rbit64(v17)) + (v14 << 6);
        goto LABEL_3;
      }

      int64_t v14 = v13 + 2;
      if (v13 + 2 < v15)
      {
        v2[3] = v14;
        unint64_t v17 = *(void *)(v16 + 8 * v14);
        v2[4] = v17;
        if (v17) {
          goto LABEL_7;
        }
        uint64_t v18 = v13 + 3;
        while (v15 != v18)
        {
          v2[3] = v18;
          unint64_t v17 = *(void *)(v16 + 8 * v18);
          v2[4] = v17;
          ++v18;
          if (v17)
          {
            int64_t v14 = v18 - 1;
            goto LABEL_7;
          }
        }
      }
    }

    uint64_t v12 = *(void *)(result + 16);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56LL);
    uint64_t v10 = a2;
    uint64_t v11 = 1LL;
    return v9(v10, v11, 1LL, v12);
  }

  __break(1u);
  return result;
}

double Dictionary.Iterator._asNative.setter(__n128 *a1, uint64_t a2)
{
  *(void *)&double result = Dictionary.Iterator._asNative.setter( a1,  a2,  (void (*)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t))outlined consume of [A : B].Iterator._Variant<A, B>).n128_u64[0];
  return result;
}

unint64_t *Dictionary.Keys.Iterator._base.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  uint64_t v5 = v1[2];
  uint64_t v6 = (char *)v1[3];
  uint64_t v7 = v1[4];
  double result = outlined copy of [A : B].Iterator._Variant<A, B>(v3, v4, v5, v6);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = (uint64_t)v6;
  a1[4] = v7;
  return result;
}

__n128 Dictionary.Keys.Iterator._base.setter(__n128 *a1)
{
  __n128 v4 = a1[1];
  __n128 v5 = *a1;
  unint64_t v2 = a1[2].n128_u64[0];
  outlined consume of [A : B].Iterator._Variant<A, B>(v1->n128_u64[0]);
  __n128 result = v4;
  __n128 *v1 = v5;
  v1[1] = v4;
  v1[2].n128_u64[0] = v2;
  return result;
}

uint64_t (*Dictionary.Values.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

__n128 Dictionary.Keys.Iterator.init(_:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __n128 result = *(__n128 *)a1;
  __int128 v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = v2;
  return result;
}

uint64_t Dictionary.Values.Iterator.next()@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v7 = *v5;
  if (*v5 < 0)
  {
    unint64_t v17 = *(char **)(result + 24);
    id v18 = __CocoaDictionary.Iterator.next()(result, a2, a3, a4);
    if (v18)
    {
      unint64_t v20 = v19;
      swift_unknownObjectRelease(v18);
      _forceBridgeFromObjectiveC<A>(_:_:)(v20, v17, v21, a5);
      swift_unknownObjectRelease(v20);
      uint64_t v22 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v17 - 1) + 56LL);
      uint64_t v23 = a5;
      uint64_t v24 = 0LL;
    }

    else
    {
      uint64_t v22 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v17 - 1) + 56LL);
      uint64_t v23 = a5;
      uint64_t v24 = 1LL;
    }

    return v22(v23, v24, 1LL, v17);
  }

  else
  {
    uint64_t v8 = v5[1];
    uint64_t v9 = v5[2];
    int64_t v11 = v5[3];
    unint64_t v10 = v5[4];
    if (v10)
    {
      uint64_t v12 = (v10 - 1) & v10;
      unint64_t v13 = __clz(__rbit64(v10)) | (v11 << 6);
LABEL_4:
      uint64_t v14 = *(void *)(result + 24);
      uint64_t v15 = *(void *)(v14 - 8);
      (*(void (**)(char *, unint64_t, uint64_t))(v15 + 16))( a5,  *(void *)(v7 + 56) + *(void *)(v15 + 72) * v13,  v14);
      __n128 result = (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(a5, 0LL, 1LL, v14);
      int64_t v16 = v11;
LABEL_20:
      *__n128 v5 = v7;
      v5[1] = v8;
      v5[2] = v9;
      v5[3] = v16;
      v5[4] = v12;
      return result;
    }

    int64_t v25 = v11 + 1;
    if (!__OFADD__(v11, 1LL))
    {
      int64_t v26 = (unint64_t)(v9 + 64) >> 6;
      int64_t v16 = v5[3];
      if (v25 < v26)
      {
        unint64_t v27 = *(void *)(v8 + 8 * v25);
        if (v27)
        {
LABEL_10:
          uint64_t v12 = (v27 - 1) & v27;
          unint64_t v13 = __clz(__rbit64(v27)) + (v25 << 6);
          int64_t v11 = v25;
          goto LABEL_4;
        }

        int64_t v16 = v11 + 1;
        if (v11 + 2 < v26)
        {
          unint64_t v27 = *(void *)(v8 + 8 * (v11 + 2));
          int64_t v25 = v11 + 2;
          if (v27) {
            goto LABEL_10;
          }
          int64_t v16 = v26 - 1;
          int64_t v28 = v11 + 3;
          while (v26 != v28)
          {
            unint64_t v27 = *(void *)(v8 + 8 * v28++);
            if (v27)
            {
              int64_t v25 = v28 - 1;
              goto LABEL_10;
            }
          }
        }
      }

      __n128 result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(result + 24) - 8LL) + 56LL))( a5,  1LL,  1LL);
      uint64_t v12 = 0LL;
      goto LABEL_20;
    }

    __break(1u);
  }

  return result;
}

id __CocoaDictionary.Iterator.next()(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  id v5 = __CocoaDictionary.Iterator.nextKey()(a1, a2, a3, a4);
  if (v5 && !objc_msgSend(*(id *)(v4 + 208), sel_objectForKey_, v5)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x310uLL,  0);
  }
  return v5;
}

uint64_t _NativeDictionary.Iterator.nextValue()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (v4)
  {
    v2[4] = (v4 - 1) & v4;
    unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
    uint64_t v6 = *(void *)(*v2 + 56LL);
    uint64_t v7 = *(void *)(result + 24);
    uint64_t v8 = *(void *)(v7 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v8 + 16))(a2, v6 + *(void *)(v8 + 72) * v5, v7);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v10 = a2;
    uint64_t v11 = 0LL;
    uint64_t v12 = v7;
    return v9(v10, v11, 1LL, v12);
  }

  uint64_t v13 = v2[3];
  int64_t v14 = v13 + 1;
  if (!__OFADD__(v13, 1LL))
  {
    int64_t v15 = (unint64_t)(v2[2] + 64LL) >> 6;
    if (v14 < v15)
    {
      v2[3] = v14;
      uint64_t v16 = v2[1];
      unint64_t v17 = *(void *)(v16 + 8 * v14);
      v2[4] = v17;
      if (v17)
      {
LABEL_11:
        v2[4] = (v17 - 1) & v17;
        unint64_t v5 = __clz(__rbit64(v17)) + (v14 << 6);
        goto LABEL_3;
      }

      uint64_t v18 = v13 + 2;
      while (v15 != v18)
      {
        v2[3] = v18;
        unint64_t v17 = *(void *)(v16 + 8 * v18);
        v2[4] = v17;
        ++v18;
        if (v17)
        {
          int64_t v14 = v18 - 1;
          goto LABEL_11;
        }
      }
    }

    uint64_t v12 = *(void *)(result + 24);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56LL);
    uint64_t v10 = a2;
    uint64_t v11 = 1LL;
    return v9(v10, v11, 1LL, v12);
  }

  __break(1u);
  return result;
}

uint64_t specialized static Dictionary<>.== infix(_:_:)( unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0LL;
  }
  unint64_t v29 = a1 + 64;
  uint64_t v6 = 1LL << *(_BYTE *)(a1 + 32);
  uint64_t v7 = -1LL;
  if (v6 < 64) {
    uint64_t v7 = ~(-1LL << v6);
  }
  unint64_t v8 = v7 & *(void *)(a1 + 64);
  int64_t v30 = (unint64_t)(v6 + 63) >> 6;
  uint64_t result = swift_bridgeObjectRetain(a1, a2, a3, a4);
  int64_t v31 = 0LL;
  if (!v8) {
    goto LABEL_8;
  }
LABEL_6:
  unint64_t v10 = __clz(__rbit64(v8));
  v8 &= v8 - 1;
  unint64_t v11 = v10 | (v31 << 6);
LABEL_7:
  uint64_t v12 = 40 * v11;
  outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v11, (uint64_t)&v42);
  outlined init with copy of AnyHashable(*(void *)(v5 + 56) + v12, (uint64_t)&v44[1]);
  while (1)
  {
    outlined init with take of (key: AnyHashable, value: AnyHashable)?( (uint64_t)&v42,  (uint64_t)&v45,  &demangling cache variable for type metadata for (key: AnyHashable, value: AnyHashable)?);
    if (!*((void *)&v46 + 1))
    {
      swift_bridgeObjectRelease(v5);
      return 1LL;
    }

    __int128 v42 = v45;
    __int128 v43 = v46;
    v44[0] = v47;
    __int128 v39 = v48;
    __int128 v40 = v49;
    uint64_t v41 = v50;
    unint64_t v17 = specialized __RawDictionaryStorage.find<A>(_:)(&v42);
    char v19 = v18;
    outlined destroy of AnyHashable((uint64_t *)&v42);
    if ((v19 & 1) == 0)
    {
      swift_bridgeObjectRelease(v5);
      outlined destroy of AnyHashable((uint64_t *)&v39);
      return 0LL;
    }

    uint64_t v20 = v5;
    uint64_t v21 = v4;
    outlined init with copy of AnyHashable(*(void *)(v4 + 56) + 40 * v17, (uint64_t)v36);
    uint64_t v22 = v37;
    uint64_t v23 = v38;
    __swift_project_boxed_opaque_existential_0Tm(v36, v37);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v23 + 8))(v33, v22, v23);
    uint64_t v24 = v34;
    uint64_t v25 = v35;
    __swift_project_boxed_opaque_existential_0Tm(v33, v34);
    uint64_t v26 = *((void *)&v40 + 1);
    uint64_t v27 = v41;
    __swift_project_boxed_opaque_existential_0Tm(&v39, *((uint64_t *)&v40 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v27 + 8))(v32, v26, v27);
    char v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v25 + 16))(v32, v24, v25);
    __swift_destroy_boxed_opaque_existential_1Tm(v32);
    if (v28 == 2)
    {
      __swift_destroy_boxed_opaque_existential_1Tm(v33);
      outlined destroy of AnyHashable(v36);
      outlined destroy of AnyHashable((uint64_t *)&v39);
      uint64_t v5 = v20;
LABEL_34:
      swift_bridgeObjectRelease(v5);
      return 0LL;
    }

    __swift_destroy_boxed_opaque_existential_1Tm(v33);
    outlined destroy of AnyHashable(v36);
    uint64_t result = (uint64_t)outlined destroy of AnyHashable((uint64_t *)&v39);
    uint64_t v5 = v20;
    if ((v28 & 1) == 0) {
      goto LABEL_34;
    }
    uint64_t v4 = v21;
    if (v8) {
      goto LABEL_6;
    }
LABEL_8:
    int64_t v13 = v31 + 1;
    if (__OFADD__(v31, 1LL))
    {
      __break(1u);
      goto LABEL_37;
    }

    if (v13 < v30)
    {
      unint64_t v14 = *(void *)(v29 + 8 * v13);
      if (v14) {
        goto LABEL_11;
      }
      int64_t v15 = v31 + 2;
      ++v31;
      if (v13 + 1 < v30)
      {
        unint64_t v14 = *(void *)(v29 + 8 * v15);
        if (v14)
        {
          ++v13;
LABEL_11:
          unint64_t v8 = (v14 - 1) & v14;
          unint64_t v11 = __clz(__rbit64(v14)) + (v13 << 6);
          int64_t v31 = v13;
          goto LABEL_7;
        }

        int64_t v16 = v13 + 2;
        int64_t v31 = v13 + 1;
        if (v13 + 2 < v30) {
          break;
        }
      }
    }

unint64_t specialized static Dictionary<>.== infix(_:_:)(unint64_t result, uint64_t a2)
{
  if (result == a2) {
    return 1LL;
  }
  unint64_t v3 = result;
  if (*(void *)(result + 16) != *(void *)(a2 + 16)) {
    return 0LL;
  }
  int64_t v4 = 0LL;
  unint64_t v5 = result + 64;
  uint64_t v6 = 1LL << *(_BYTE *)(result + 32);
  uint64_t v7 = -1LL;
  if (v6 < 64) {
    uint64_t v7 = ~(-1LL << v6);
  }
  unint64_t v8 = v7 & *(void *)(result + 64);
  int64_t v9 = (unint64_t)(v6 + 63) >> 6;
  while (1)
  {
    if (v8)
    {
      unint64_t v10 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v11 = v10 | (v4 << 6);
      goto LABEL_22;
    }

    int64_t v12 = v4 + 1;
    if (__OFADD__(v4, 1LL))
    {
      __break(1u);
      goto LABEL_27;
    }

    if (v12 >= v9) {
      return 1LL;
    }
    unint64_t v13 = *(void *)(v5 + 8 * v12);
    ++v4;
    if (!v13)
    {
      int64_t v4 = v12 + 1;
      if (v12 + 1 >= v9) {
        return 1LL;
      }
      unint64_t v13 = *(void *)(v5 + 8 * v4);
      if (!v13)
      {
        int64_t v4 = v12 + 2;
        if (v12 + 2 >= v9) {
          return 1LL;
        }
        unint64_t v13 = *(void *)(v5 + 8 * v4);
        if (!v13) {
          break;
        }
      }
    }

uint64_t static Dictionary<>.== infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v81 = a5;
  uint64_t v82 = a6;
  uint64_t v10 = *((void *)a4 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  unint64_t v13 = (char *)&v65 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v65 - v15;
  uint64_t v18 = *(void *)(v17 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v20 = (char *)&v65 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, v21, (uint64_t)a4, "key value ", 0LL);
  uint64_t v25 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v23, v24);
  uint64_t v26 = MEMORY[0x1895F8858](v25);
  uint64_t result = MEMORY[0x1895F8858](v26);
  unint64_t v32 = a2 & 0xC000000000000001LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      unint64_t v33 = (void *)a1;
    }
    else {
      unint64_t v33 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    if (v32)
    {
      if (a2 < 0) {
        uint64_t v34 = (void *)a2;
      }
      else {
        uint64_t v34 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
      }
      return swift_stdlib_NSObject_isEqual(v33, v34);
    }

    uint64_t v35 = a2;
    return _NativeDictionary<>.isEqual(to:)(v33, v35, a3, a4, v28, v82);
  }

  uint64_t v76 = v31;
  char v77 = TupleTypeMetadata2;
  unint64_t v75 = v20;
  if (v32)
  {
    if (a2 < 0) {
      unint64_t v33 = (void *)a2;
    }
    else {
      unint64_t v33 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v35 = a1;
    return _NativeDictionary<>.isEqual(to:)(v33, v35, a3, a4, v28, v82);
  }

  if (a1 == a2) {
    return 1;
  }
  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0;
  }
  Swift::String::Index v69 = v13;
  unint64_t v70 = (char *)&v65 - v29;
  uint64_t v80 = v18;
  uint64_t v72 = result;
  uint64_t v73 = v10;
  int64_t v36 = 0LL;
  uint64_t v68 = a1;
  uint64_t v39 = *(void *)(a1 + 64);
  uint64_t v38 = a1 + 64;
  uint64_t v37 = v39;
  uint64_t v40 = 1LL << *(_BYTE *)(v38 - 32);
  uint64_t v41 = -1LL;
  if (v40 < 64) {
    uint64_t v41 = ~(-1LL << v40);
  }
  unint64_t v42 = v41 & v37;
  uint64_t v66 = v38;
  int64_t v67 = (unint64_t)(v40 + 63) >> 6;
  int64_t v65 = v67 - 1;
  uint64_t v71 = v30;
  while (1)
  {
    if (v42)
    {
      uint64_t v78 = (v42 - 1) & v42;
      int64_t v79 = v36;
      unint64_t v43 = __clz(__rbit64(v42)) | (v36 << 6);
      uint64_t v44 = v73;
      uint64_t v45 = v68;
      uint64_t v46 = v80;
      uint64_t v48 = v76;
      uint64_t v47 = v77;
      goto LABEL_24;
    }

    int64_t v50 = v36 + 1;
    uint64_t v44 = v73;
    uint64_t v46 = v80;
    uint64_t v48 = v76;
    uint64_t v47 = v77;
    if (__OFADD__(v36, 1LL))
    {
      __break(1u);
      goto LABEL_54;
    }

    if (v50 < v67) {
      break;
    }
    int64_t v79 = v36;
LABEL_30:
    uint64_t v78 = 0LL;
LABEL_31:
    uint64_t v49 = 1LL;
LABEL_32:
    uint64_t v52 = (uint64_t)v75;
    uint64_t v53 = *(v47 - 1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(v53 + 56))(v48, v49, 1LL, v47);
    Swift::Int v54 = v70;
    (*(void (**)(char *, uint64_t, uint64_t))(v71 + 32))(v70, v48, v72);
    int v55 = (*(uint64_t (**)(char *, uint64_t, unint64_t *))(v53 + 48))(v54, 1LL, v47);
    BOOL v74 = v55 == 1;
    if (v55 == 1) {
      return v74;
    }
    int64_t v56 = &v54[*((int *)v47 + 12)];
    uint64_t v57 = v80;
    (*(void (**)(uint64_t, char *, uint64_t *))(v80 + 32))(v52, v54, a3);
    (*(void (**)(char *, char *, char *))(v44 + 32))(v16, v56, a4);
    unint64_t v58 = __RawDictionaryStorage.find<A>(_:)(v52, (uint64_t)a3, v81);
    char v60 = v59;
    (*(void (**)(uint64_t, uint64_t *))(v57 + 8))(v52, a3);
    if ((v60 & 1) == 0)
    {
      (*(void (**)(char *, char *))(v44 + 8))(v16, a4);
      return 0;
    }

    uint64_t v61 = v69;
    (*(void (**)(char *, unint64_t, char *))(v44 + 16))( v69,  *(void *)(a2 + 56) + *(void *)(v44 + 72) * v58,  a4);
    char v62 = (*(uint64_t (**)(char *, char *, char *))(v82 + 8))(v61, v16, a4);
    unint64_t v63 = *(void (**)(char *, char *))(v44 + 8);
    v63(v61, a4);
    uint64_t result = ((uint64_t (*)(char *, char *))v63)(v16, a4);
    unint64_t v42 = v78;
    int64_t v36 = v79;
    if ((v62 & 1) == 0) {
      return v74;
    }
  }

  unint64_t v51 = *(void *)(v66 + 8 * v50);
  uint64_t v45 = v68;
  if (v51) {
    goto LABEL_28;
  }
  if (v36 + 2 >= v67)
  {
    uint64_t v78 = 0LL;
    int64_t v79 = v36 + 1;
    goto LABEL_31;
  }

  unint64_t v51 = *(void *)(v66 + 8 * (v36 + 2));
  if (v51)
  {
    int64_t v50 = v36 + 2;
    goto LABEL_28;
  }

  uint64_t v64 = v36 + 3;
  if (v36 + 3 >= v67)
  {
    int64_t v79 = v36 + 2;
    goto LABEL_30;
  }

  unint64_t v51 = *(void *)(v66 + 8 * v64);
  if (v51)
  {
    int64_t v50 = v36 + 3;
LABEL_28:
    uint64_t v78 = (v51 - 1) & v51;
    int64_t v79 = v50;
    unint64_t v43 = __clz(__rbit64(v51)) + (v50 << 6);
LABEL_24:
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(v46 + 16))( v48,  *(void *)(v45 + 48) + *(void *)(v46 + 72) * v43,  a3);
    (*(void (**)(uint64_t, unint64_t, char *))(v44 + 16))( v48 + *((int *)v47 + 12),  *(void *)(v45 + 56) + *(void *)(v44 + 72) * v43,  a4);
    uint64_t v49 = 0LL;
    goto LABEL_32;
  }

  while (1)
  {
    int64_t v50 = v64 + 1;
    if (__OFADD__(v64, 1LL)) {
      break;
    }
    if (v50 >= v67)
    {
      uint64_t v49 = 1LL;
      uint64_t v78 = 0LL;
      int64_t v79 = v65;
      goto LABEL_32;
    }

    unint64_t v51 = *(void *)(v66 + 8 * v50);
    ++v64;
    if (v51) {
      goto LABEL_28;
    }
  }

uint64_t _NativeDictionary<>.isEqual(to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v67 = a6;
  uint64_t v69 = a5;
  uint64_t v8 = a1;
  uint64_t v9 = *(void *)(a4 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v66 = (char *)&v58 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v58 - v13;
  uint64_t v75 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v68 = (char *)&v58 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v76 = v17;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, v17, a4, "key value ", 0LL);
  uint64_t v21 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v19, v20);
  uint64_t v71 = *(void *)(v21 - 8);
  uint64_t v72 = v21;
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  uint64_t v24 = (char *)&v58 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v58 - v26;
  if (a2 == v8) {
    return 1;
  }
  if (*(void *)(a2 + 16) != *(void *)(v8 + 16)) {
    return 0;
  }
  uint64_t v64 = v14;
  uint64_t v65 = v9;
  int64_t v70 = 0LL;
  uint64_t v61 = a2;
  char v62 = TupleTypeMetadata2;
  uint64_t v30 = *(void *)(a2 + 64);
  uint64_t v29 = a2 + 64;
  uint64_t v28 = v30;
  uint64_t v31 = 1LL << *(_BYTE *)(v29 - 32);
  uint64_t v32 = -1LL;
  if (v31 < 64) {
    uint64_t v32 = ~(-1LL << v31);
  }
  unint64_t v33 = v32 & v28;
  uint64_t v59 = v29;
  int64_t v60 = (unint64_t)(v31 + 63) >> 6;
  int64_t v58 = v60 - 1;
  unint64_t v63 = v24;
  while (1)
  {
    if (v33)
    {
      unint64_t v34 = __clz(__rbit64(v33));
      uint64_t v35 = (v33 - 1) & v33;
      unint64_t v36 = v34 | (v70 << 6);
      uint64_t v37 = v61;
      uint64_t v38 = v65;
      goto LABEL_8;
    }

    int64_t v55 = v70 + 1;
    uint64_t v38 = v65;
    if (__OFADD__(v70, 1LL))
    {
      __break(1u);
      goto LABEL_32;
    }

    if (v55 >= v60)
    {
      uint64_t v35 = 0LL;
      uint64_t v39 = 1LL;
      goto LABEL_9;
    }

    unint64_t v56 = *(void *)(v59 + 8 * v55);
    if (v56) {
      goto LABEL_16;
    }
    int64_t v57 = v70 + 2;
    if (v70 + 2 < v60) {
      break;
    }
    uint64_t v35 = 0LL;
    uint64_t v39 = 1LL;
    ++v70;
LABEL_9:
    uint64_t v40 = *(TupleTypeMetadata2 - 1);
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v40 + 56))(v24, v39, 1LL, TupleTypeMetadata2);
    (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v27, v24, v72);
    int v41 = (*(uint64_t (**)(char *, uint64_t, unint64_t *))(v40 + 48))(v27, 1LL, TupleTypeMetadata2);
    BOOL v73 = v41 == 1;
    if (v41 == 1) {
      return v73;
    }
    unint64_t v74 = v35;
    unint64_t v42 = &v27[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v43 = v75;
    uint64_t v44 = v76;
    uint64_t v45 = (uint64_t)v68;
    uint64_t v46 = v27;
    (*(void (**)(char *, char *, uint64_t))(v75 + 32))(v68, v27, v76);
    uint64_t v47 = v64;
    (*(void (**)(char *, char *, uint64_t))(v38 + 32))(v64, v42, a4);
    unint64_t v48 = __RawDictionaryStorage.find<A>(_:)(v45, v44, v69);
    uint64_t v49 = v8;
    char v51 = v50;
    (*(void (**)(uint64_t, uint64_t))(v43 + 8))(v45, v44);
    if ((v51 & 1) == 0)
    {
      (*(void (**)(char *, uint64_t))(v38 + 8))(v47, a4);
      return 0;
    }

    uint64_t v52 = v66;
    (*(void (**)(char *, unint64_t, uint64_t))(v38 + 16))( v66,  *(void *)(v49 + 56) + *(void *)(v38 + 72) * v48,  a4);
    char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(v67 + 8))(v52, v47, a4);
    Swift::Int v54 = *(void (**)(char *, uint64_t))(v38 + 8);
    v54(v52, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v47, a4);
    uint64_t v8 = v49;
    TupleTypeMetadata2 = v62;
    uint64_t v24 = v63;
    uint64_t v27 = v46;
    unint64_t v33 = v74;
    if ((v53 & 1) == 0) {
      return v73;
    }
  }

  unint64_t v56 = *(void *)(v59 + 8 * v57);
  if (v56)
  {
    int64_t v55 = v70 + 2;
LABEL_16:
    uint64_t v37 = v61;
    uint64_t v35 = (v56 - 1) & v56;
    unint64_t v36 = __clz(__rbit64(v56)) + (v55 << 6);
    int64_t v70 = v55;
LABEL_8:
    (*(void (**)(char *, unint64_t, uint64_t))(v75 + 16))( v24,  *(void *)(v37 + 48) + *(void *)(v75 + 72) * v36,  v76);
    (*(void (**)(char *, unint64_t, uint64_t))(v38 + 16))( &v24[*((int *)TupleTypeMetadata2 + 12)],  *(void *)(v37 + 56) + *(void *)(v38 + 72) * v36,  a4);
    uint64_t v39 = 0LL;
    goto LABEL_9;
  }

  while (1)
  {
    int64_t v55 = v57 + 1;
    if (__OFADD__(v57, 1LL)) {
      break;
    }
    if (v55 >= v60)
    {
      uint64_t v35 = 0LL;
      uint64_t v39 = 1LL;
      int64_t v70 = v58;
      goto LABEL_9;
    }

    unint64_t v56 = *(void *)(v59 + 8 * v55);
    ++v57;
    if (v56) {
      goto LABEL_16;
    }
  }

uint64_t _NativeDictionary<>.isEqual(to:)( void *a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v63 = a6;
  uint64_t v10 = type metadata accessor for Optional(0LL, (uint64_t)a4, (uint64_t)a3, (uint64_t)a4);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  unint64_t v56 = (char *)&v53 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  int64_t v55 = (uint64_t *)((char *)&v53 - v15);
  uint64_t v67 = *((void *)a4 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  char v62 = (char *)&v53 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v66 = (char *)&v53 - v19;
  uint64_t v20 = *(a3 - 1);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  int64_t v57 = (id *)((char *)&v53 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v64 = v22;
  MEMORY[0x1895F8858](v21);
  uint64_t v24 = (id *)((char *)&v53 - v23);
  id v25 = *(id *)(a2 + 16);
  id v65 = a1;
  if (v25 == objc_msgSend(a1, sel_count))
  {
    uint64_t v53 = v10;
    uint64_t v54 = v11;
    int64_t v26 = 0LL;
    uint64_t v27 = *(void *)(a2 + 64);
    uint64_t v58 = a2 + 64;
    uint64_t v28 = 1LL << *(_BYTE *)(a2 + 32);
    uint64_t v29 = -1LL;
    if (v28 < 64) {
      uint64_t v29 = ~(-1LL << v28);
    }
    unint64_t v30 = v29 & v27;
    int64_t v59 = (unint64_t)(v28 + 63) >> 6;
    int64_t v60 = (swift *)&unk_189B8D230;
    uint64_t v61 = a2;
    while (1)
    {
      if (v30)
      {
        unint64_t v31 = __clz(__rbit64(v30));
        v30 &= v30 - 1;
        unint64_t v32 = v31 | (v26 << 6);
      }

      else
      {
        int64_t v33 = v26 + 1;
        if (__OFADD__(v26, 1LL))
        {
          __break(1u);
LABEL_32:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
        }

        if (v33 >= v59) {
          return 1LL;
        }
        unint64_t v34 = *(void *)(v58 + 8 * v33);
        ++v26;
        if (!v34)
        {
          while (1)
          {
            int64_t v26 = v33 + 1;
            if (__OFADD__(v33, 1LL)) {
              break;
            }
            if (v26 >= v59) {
              return 1LL;
            }
            unint64_t v34 = *(void *)(v58 + 8 * v26);
            ++v33;
            if (v34) {
              goto LABEL_13;
            }
          }

          __break(1u);
LABEL_30:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }

void specialized Dictionary<>.hash(into:)(__int128 *a1, unint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v29 = a2 + 64;
  uint64_t v6 = 1LL << *(_BYTE *)(a2 + 32);
  uint64_t v7 = -1LL;
  if (v6 < 64) {
    uint64_t v7 = ~(-1LL << v6);
  }
  unint64_t v8 = v7 & *(void *)(a2 + 64);
  int64_t v30 = (unint64_t)(v6 + 63) >> 6;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  Swift::UInt v9 = 0LL;
  int64_t v10 = 0LL;
  if (!v8) {
    goto LABEL_6;
  }
LABEL_4:
  unint64_t v11 = __clz(__rbit64(v8));
  v8 &= v8 - 1;
  unint64_t v12 = v11 | (v10 << 6);
LABEL_5:
  uint64_t v13 = 40 * v12;
  outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v12, (uint64_t)&v39);
  outlined init with copy of AnyHashable(*(void *)(a2 + 56) + v13, (uint64_t)&v41 + 8);
  while (1)
  {
    outlined init with take of (key: AnyHashable, value: AnyHashable)?( (uint64_t)&v39,  (uint64_t)&v44,  &demangling cache variable for type metadata for (key: AnyHashable, value: AnyHashable)?);
    if (!*((void *)&v45 + 1))
    {
      swift_release(a2);
      Hasher._combine(_:)(v9);
      return;
    }

    v37[0] = v44;
    v37[1] = v45;
    uint64_t v38 = v46;
    __int128 v34 = v47;
    __int128 v35 = v48;
    uint64_t v36 = v49;
    uint64_t v18 = *((void *)a1 + 8);
    __int128 v19 = a1[1];
    __int128 v39 = *a1;
    __int128 v40 = v19;
    __int128 v20 = a1[3];
    __int128 v41 = a1[2];
    __int128 v42 = v20;
    *(void *)&__int128 v43 = v18;
    uint64_t v21 = *((void *)&v45 + 1);
    uint64_t v22 = v46;
    __swift_project_boxed_opaque_existential_0Tm(v37, *((uint64_t *)&v45 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v22 + 8))(v31, v21, v22);
    uint64_t v23 = v32;
    uint64_t v24 = v33;
    __swift_project_boxed_opaque_existential_0Tm(v31, v32);
    (*(void (**)(__int128 *, uint64_t, uint64_t))(v24 + 32))(&v39, v23, v24);
    __swift_destroy_boxed_opaque_existential_1Tm(v31);
    outlined destroy of AnyHashable((uint64_t *)v37);
    uint64_t v25 = *((void *)&v35 + 1);
    uint64_t v26 = v36;
    __swift_project_boxed_opaque_existential_0Tm(&v34, *((uint64_t *)&v35 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v26 + 8))(v31, v25, v26);
    uint64_t v27 = v32;
    uint64_t v28 = v33;
    __swift_project_boxed_opaque_existential_0Tm(v31, v32);
    (*(void (**)(__int128 *, uint64_t, uint64_t))(v28 + 32))(&v39, v27, v28);
    __swift_destroy_boxed_opaque_existential_1Tm(v31);
    outlined destroy of AnyHashable((uint64_t *)&v34);
    v9 ^= Hasher._finalize()();
    if (v8) {
      goto LABEL_4;
    }
LABEL_6:
    int64_t v14 = v10 + 1;
    if (__OFADD__(v10, 1LL))
    {
      __break(1u);
      goto LABEL_27;
    }

    if (v14 < v30)
    {
      unint64_t v15 = *(void *)(v29 + 8 * v14);
      if (v15) {
        goto LABEL_9;
      }
      int64_t v16 = v10 + 2;
      ++v10;
      if (v14 + 1 < v30)
      {
        unint64_t v15 = *(void *)(v29 + 8 * v16);
        if (v15)
        {
          ++v14;
LABEL_9:
          unint64_t v8 = (v15 - 1) & v15;
          unint64_t v12 = __clz(__rbit64(v15)) + (v14 << 6);
          int64_t v10 = v14;
          goto LABEL_5;
        }

        int64_t v17 = v14 + 2;
        int64_t v10 = v14 + 1;
        if (v14 + 2 < v30) {
          break;
        }
      }
    }

void Dictionary<>.hash(into:)( uint64_t a1, int64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v114 = a6;
  uint64_t v113 = a5;
  uint64_t v116 = a1;
  uint64_t v9 = type metadata accessor for Optional(0LL, a4, (uint64_t)a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v98 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  unint64_t v15 = (char *)&v98 - v14;
  uint64_t v103 = type metadata accessor for Optional(0LL, (uint64_t)a3, v16, v17);
  uint64_t v102 = *(void *)(v103 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v103);
  unint64_t v99 = (char *)&v98 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v104 = (uint64_t *)((char *)&v98 - v21);
  uint64_t v124 = *(void *)(a4 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v122 = (char *)&v98 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v126 = *(a3 - 1);
  MEMORY[0x1895F8858](v22);
  unint64_t v121 = (char *)&v98 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v125 = a3;
  uint64_t v25 = (char *)a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, (uint64_t)a3, a4, "key value ", 0LL);
  uint64_t v29 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v27, v28);
  uint64_t v118 = *(void *)(v29 - 8);
  uint64_t v119 = v29;
  uint64_t v30 = MEMORY[0x1895F8858](v29);
  uint64_t v120 = (char *)&v98 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v30);
  Swift::String::Index v100 = (uint64_t *)v15;
  uint64_t v117 = (char *)&v98 - v35;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v36 = a2;
    }
    else {
      uint64_t v36 = a2 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v37 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v38 = (unint64_t)swift_allocObject(v37, 0xE8uLL, 7uLL);
    int64_t v108 = 0LL;
    uint64_t v39 = 0LL;
    unint64_t v40 = 0LL;
    *(void *)(v38 + 208) = v36;
    *(void *)(v38 + 216) = 0LL;
    *(_OWORD *)(v38 + 16) = 0u;
    *(_OWORD *)(v38 + 32) = 0u;
    *(_OWORD *)(v38 + 48) = 0u;
    *(_OWORD *)(v38 + 64) = 0u;
    *(_OWORD *)(v38 + 80) = 0u;
    *(_OWORD *)(v38 + 96) = 0u;
    *(_OWORD *)(v38 + 112) = 0u;
    *(_OWORD *)(v38 + 128) = 0u;
    *(_OWORD *)(v38 + 144) = 0u;
    *(_OWORD *)(v38 + 160) = 0u;
    *(_OWORD *)(v38 + 176) = 0u;
    *(_OWORD *)(v38 + 192) = 0u;
    *(void *)(v38 + 224) = 0LL;
    unint64_t v41 = v38 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v42 = -1LL << *(_BYTE *)(a2 + 32);
    uint64_t v39 = ~v42;
    uint64_t v43 = *(void *)(a2 + 64);
    int64_t v108 = a2 + 64;
    uint64_t v44 = -v42;
    if (v44 < 64) {
      uint64_t v45 = ~(-1LL << v44);
    }
    else {
      uint64_t v45 = -1LL;
    }
    unint64_t v40 = v45 & v43;
    unint64_t v41 = a2;
  }

  uint64_t v109 = v41 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v106 = v39;
  int64_t v110 = (unint64_t)(v39 + 64) >> 6;
  int64_t v105 = v110 - 1;
  uint64_t v46 = swift_bridgeObjectRetain(a2, v32, v33, v34);
  Swift::UInt v50 = 0LL;
  int64_t v51 = 0LL;
  uint64_t v107 = (swift *)&unk_189B8D230;
  uint64_t v123 = v25;
  size_t v101 = v13;
  unint64_t v115 = v41;
  uint64_t v112 = v10;
  uint64_t v111 = v9;
  while (1)
  {
    Swift::UInt v129 = v50;
    int64_t v127 = v51;
    if ((v41 & 0x8000000000000000LL) != 0)
    {
      uint64_t v66 = (swift *)__CocoaDictionary.Iterator.next()(v46, v47, v48, v49);
      uint64_t v68 = v126;
      id v65 = v117;
      if (v66)
      {
        uint64_t v69 = v66;
        int64_t v70 = v67;
        uint64_t v71 = (const char *)v125;
        if (_swift_isClassOrObjCExistentialType((uint64_t)v125, v125))
        {
          *(void *)&v130[0] = v69;
          char v62 = v120;
          swift_dynamicCast(v120, (uint64_t *)v130, v107, v71, 7uLL);
        }

        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t, const char *))(v68 + 56))(v104, 1LL, 1LL, v71);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v69, (uint64_t)v71, v104);
          swift_unknownObjectRelease(v69);
          uint64_t v91 = v99;
          (*(void (**)(char *, uint64_t *, uint64_t))(v102 + 16))(v99, v104, v103);
          (*(void (**)(uint64_t *, uint64_t))(v102 + 8))(v104, v103);
          unint64_t v92 = *(void (**)(char *, char *, const char *))(v68 + 32);
          char v62 = v120;
          v92(v120, v91, v71);
        }

        uint64_t v72 = &v62[*((int *)TupleTypeMetadata2 + 12)];
        uint64_t v73 = (uint64_t)v25;
        if (_swift_isClassOrObjCExistentialType((uint64_t)v25, (uint64_t *)v25))
        {
          *(void *)&v130[0] = v70;
          swift_dynamicCast(v72, (uint64_t *)v130, (swift *)&unk_189B8D230, v25, 7uLL);
        }

        else
        {
          unint64_t v93 = v100;
          (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v124 + 56))(v100, 1LL, 1LL, v73);
          char v94 = v70;
          uint64_t v95 = v93;
          unint64_t v96 = v94;
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v94, v73, v95);
          swift_unknownObjectRelease(v96);
          unint64_t v97 = v101;
          (*(void (**)(char *, uint64_t *, uint64_t))(v10 + 16))(v101, v95, v9);
          (*(void (**)(uint64_t *, uint64_t))(v10 + 8))(v95, v9);
          (*(void (**)(char *, char *, uint64_t))(v124 + 32))(v72, v97, v73);
        }

        uint64_t v63 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v63 + 56))( v62,  0LL,  1LL,  TupleTypeMetadata2);
      }

      else
      {
        uint64_t v63 = *(TupleTypeMetadata2 - 1);
        char v62 = v120;
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v63 + 56))( v120,  1LL,  1LL,  TupleTypeMetadata2);
      }

      int64_t v64 = v127;
      uint64_t v128 = v40;
    }

    else
    {
      if (v40)
      {
        uint64_t v128 = (v40 - 1) & v40;
        unint64_t v52 = __clz(__rbit64(v40)) | (v51 << 6);
        int64_t v53 = v51;
        uint64_t v54 = v124;
        goto LABEL_14;
      }

      int64_t v53 = v51 + 1;
      if (__OFADD__(v51, 1LL))
      {
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }

      int64_t v64 = v51;
      char v62 = v120;
      if (v53 < v110)
      {
        unint64_t v74 = *(void *)(v108 + 8 * v53);
        uint64_t v54 = v124;
        if (v74) {
          goto LABEL_24;
        }
        int64_t v75 = v51 + 2;
        int64_t v64 = v51 + 1;
        if (v51 + 2 < v110)
        {
          unint64_t v74 = *(void *)(v108 + 8 * v75);
          uint64_t v54 = v124;
          if (v74)
          {
            int64_t v53 = v51 + 2;
LABEL_24:
            uint64_t v128 = (v74 - 1) & v74;
            unint64_t v52 = __clz(__rbit64(v74)) + (v53 << 6);
LABEL_14:
            uint64_t v55 = v126;
            (*(void (**)(char *, unint64_t, uint64_t *))(v126 + 16))( v121,  *(void *)(v41 + 48) + *(void *)(v126 + 72) * v52,  v125);
            unint64_t v56 = *(void *)(v41 + 56) + *(void *)(v54 + 72) * v52;
            int64_t v57 = *(void (**)(char *, unint64_t, char *))(v54 + 16);
            uint64_t v58 = v122;
            uint64_t v59 = v54;
            int64_t v60 = v123;
            v57(v122, v56, v123);
            uint64_t v61 = &v120[*((int *)TupleTypeMetadata2 + 12)];
            char v62 = v120;
            (*(void (**)(void))(v55 + 32))();
            (*(void (**)(char *, char *, char *))(v59 + 32))(v61, v58, v60);
            uint64_t v63 = *(TupleTypeMetadata2 - 1);
            (*(void (**)(char *, void, uint64_t, unint64_t *))(v63 + 56))( v62,  0LL,  1LL,  TupleTypeMetadata2);
            int64_t v64 = v53;
            uint64_t v9 = v111;
            uint64_t v10 = v112;
            id v65 = v117;
            goto LABEL_36;
          }

          while (1)
          {
            int64_t v53 = v75 + 1;
            if (__OFADD__(v75, 1LL)) {
              goto LABEL_44;
            }
            if (v53 >= v110) {
              break;
            }
            unint64_t v74 = *(void *)(v108 + 8 * v53);
            ++v75;
            if (v74) {
              goto LABEL_24;
            }
          }

          int64_t v64 = v105;
        }
      }

      uint64_t v63 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v63 + 56))( v120,  1LL,  1LL,  TupleTypeMetadata2);
      uint64_t v128 = 0LL;
      uint64_t v9 = v111;
      uint64_t v10 = v112;
      id v65 = v117;
    }

void *static Int.^= infix(_:_:)(void *result, uint64_t a2)
{
  *result ^= a2;
  return result;
}

Swift::Int Dictionary<>.hashValue.getter(int64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  Dictionary<>.hash(into:)((uint64_t)v6, a1, a2, a3, a4, a5);
  return Hasher._finalize()();
}

uint64_t Dictionary<>._toCustomAnyHashable()@<X0>( int64_t a1@<X0>, const char *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int64_t *a6@<X8>)
{
  uint64_t v12 = specialized _dictionaryUpCast<A, B, C, D>(_:)(a1, a2, a3);
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a4;
  _OWORD v14[3] = a5;
  uint64_t result = type metadata accessor for _DictionaryAnyHashableBox(0LL, (uint64_t)v14);
  a6[3] = result;
  a6[4] = (int64_t)&protocol witness table for _DictionaryAnyHashableBox<A, B>;
  *a6 = a1;
  a6[1] = (int64_t)v12;
  return result;
}

void specialized _dictionaryUpCast<A, B, C, D>(_:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    unint64_t v5 = (unint64_t *)specialized static _DictionaryStorage.allocate(capacity:)(v4);
  }
  else {
    unint64_t v5 = (unint64_t *)&_swiftEmptyDictionarySingleton;
  }
  unint64_t v39 = a1 + 64;
  uint64_t v6 = -1LL;
  uint64_t v7 = -1LL << *(_BYTE *)(a1 + 32);
  if (-v7 < 64) {
    uint64_t v6 = ~(-1LL << -(char)v7);
  }
  unint64_t v8 = v6 & *(void *)(a1 + 64);
  int64_t v36 = (unint64_t)(63 - v7) >> 6;
  swift_retain(v5, a2, a3, a4);
  swift_bridgeObjectRetain(a1, v9, v10, v11);
  int64_t v15 = 0LL;
  uint64_t v37 = v5;
  if (!v8) {
    goto LABEL_8;
  }
LABEL_7:
  uint64_t v40 = (v8 - 1) & v8;
  int64_t v41 = v15;
  for (unint64_t i = __clz(__rbit64(v8)) | (v15 << 6); ; unint64_t i = __clz(__rbit64(v18)) + (v19 << 6))
  {
    uint64_t v21 = 40 * i;
    outlined init with copy of AnyHashable(*(void *)(a1 + 48) + 40 * i, (uint64_t)&v47);
    outlined init with copy of AnyHashable(*(void *)(a1 + 56) + v21, (uint64_t)&v42);
    __int128 v22 = v47;
    uint64_t v23 = v48;
    uint64_t v24 = v49;
    uint64_t v25 = v50;
    uint64_t v26 = v42;
    uint64_t v27 = v43;
    uint64_t v29 = v44;
    uint64_t v28 = v45;
    uint64_t v30 = v46;
    __int128 v34 = swift_retain((unint64_t *)a1, v31, v32, v33);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v34);
    unint64_t v5 = v37;
    if (!v24) {
      goto LABEL_24;
    }
    __int128 v47 = v22;
    uint64_t v48 = v23;
    uint64_t v49 = v24;
    uint64_t v50 = v25;
    uint64_t v42 = v26;
    uint64_t v43 = v27;
    uint64_t v44 = v29;
    uint64_t v45 = v28;
    uint64_t v46 = v30;
    specialized _NativeDictionary._unsafeInsertNew(key:value:)(&v47, (uint64_t)&v42, v37);
    unint64_t v8 = v40;
    int64_t v15 = v41;
    if (v40) {
      goto LABEL_7;
    }
LABEL_8:
    int64_t v17 = v15 + 1;
    if (__OFADD__(v15, 1LL))
    {
      __break(1u);
      goto LABEL_26;
    }

    if (v17 >= v36) {
      goto LABEL_23;
    }
    unint64_t v18 = *(void *)(v39 + 8 * v17);
    int64_t v19 = v15 + 1;
    if (!v18)
    {
      int64_t v19 = v15 + 2;
      if (v15 + 2 >= v36) {
        goto LABEL_23;
      }
      unint64_t v18 = *(void *)(v39 + 8 * v19);
      if (!v18) {
        break;
      }
    }

LABEL_19:
    uint64_t v40 = (v18 - 1) & v18;
    int64_t v41 = v19;
  }

  uint64_t v20 = v15 + 3;
  if (v15 + 3 >= v36)
  {
LABEL_23:
    uint64_t v35 = swift_retain((unint64_t *)a1, v12, v13, v14);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v35);
LABEL_24:
    swift_release(a1);
    swift_release((uint64_t)v5);
    return;
  }

  unint64_t v18 = *(void *)(v39 + 8 * v20);
  if (v18)
  {
    int64_t v19 = v15 + 3;
    goto LABEL_19;
  }

  while (1)
  {
    int64_t v19 = v20 + 1;
    if (__OFADD__(v20, 1LL)) {
      break;
    }
    if (v19 >= v36) {
      goto LABEL_23;
    }
    unint64_t v18 = *(void *)(v39 + 8 * v19);
    ++v20;
    if (v18) {
      goto LABEL_19;
    }
  }

  swift_release((uint64_t)v7);
  uint64_t v21 = 1LL << v7[2].i8[0];
  if (v21 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v21 + 63) >> 6, v7 + 4);
  }
  else {
    v10->i64[0] = -1LL << v21;
  }
  v7[1].i64[0] = 0LL;
  ++v7[2].i32[1];
}

    v306 = (char *)v76;
    int64_t v108 = (*(uint64_t (**)(uint64_t))(v333 + 136))(v334);
    uint64_t v109 = v321;
    int64_t v110 = v321(v45, v89);
    v330 = (char *)v106;
    if ((v110 & 1) != 0)
    {
      uint64_t v111 = v320(v45, v89);
      if (v111 < 64)
      {
        ((void (**)(char *, char *, unint64_t *))v79)[2](v95, v78, v45);
        uint64_t v114 = (*(uint64_t (**)(unint64_t *, uint64_t))(v89 + 120))(v45, v89);
        v106(v95, v45);
        unint64_t v115 = v114 < v108;
LABEL_27:
        uint64_t v126 = v95;
        int64_t v127 = v89;
        goto LABEL_49;
      }

      v344 = v108;
      uint64_t v123 = v78;
      uint64_t v124 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v89 + 96);
      uint64_t v125 = lazy protocol witness table accessor for type Int and conformance Int(v111, v112, v113);
      v124(&v344, &type metadata for Int, v125, v45, v89);
      uint64_t v122 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32) + 8LL)
                                                                           + 16LL))( v123,  v95,  v45);
LABEL_26:
      unint64_t v115 = v122;
      v106(v95, v45);
      goto LABEL_27;
    }

    uint64_t v116 = v109(v45, v89);
    uint64_t v117 = v320(v45, v89);
    if ((v116 & 1) != 0)
    {
      if (v117 > 64)
      {
        v344 = v108;
        uint64_t v120 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v89 + 96);
        unint64_t v121 = lazy protocol witness table accessor for type Int and conformance Int(v117, v118, v119);
        v120(&v344, &type metadata for Int, v121, v45, v89);
        uint64_t v122 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32) + 8LL)
                                                                             + 16LL))( v342,  v95,  v45);
        goto LABEL_26;
      }

      unint64_t v144 = (uint64_t)v287;
      unint64_t v145 = v305;
      unint64_t v146 = swift_getAssociatedConformanceWitness( (uint64_t)v287,  (uint64_t)v45,  v305,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v147 = v303;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v146 + 8))( &unk_18180BE68,  256LL,  v145,  v146);
      (*(void (**)(char *, unint64_t *, uint64_t))(v144 + 24))(v147, v45, v144);
      uint64_t v148 = v342;
      LOBYTE(v145) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v342,  v95,  v45);
      v106(v95, v45);
      uint64_t v149 = (void (*)(char *, char *, unint64_t *))v79[2];
      char v150 = v294;
      v149(v294, v148, v45);
      unint64_t v115 = (v145 & 1) != 0 || (*(uint64_t (**)(unint64_t *, uint64_t))(v89 + 120))(v45, v89) < v108;
      v106(v150, v45);
      uint64_t v126 = v95;
      int64_t v127 = v335;
    }

    else
    {
      if (v117 < 64)
      {
        ((void (**)(char *, char *, unint64_t *))v79)[2](v95, v342, v45);
        uint64_t v128 = (*(uint64_t (**)(unint64_t *, uint64_t))(v89 + 120))(v45, v89);
        v106(v95, v45);
        unint64_t v115 = v128 < v108;
      }

      else
      {
        uint64_t v151 = (uint64_t (*)(char *, char *, unint64_t *))v79[2];
        int64_t v152 = v293;
        int64_t v153 = v151(v293, v342, v45);
        if (v108 < 1)
        {
          v106(v152, v45);
          unint64_t v115 = 0;
        }

        else
        {
          v344 = v108;
          BOOL v156 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v89 + 96);
          uint64_t v157 = lazy protocol witness table accessor for type Int and conformance Int(v153, v154, v155);
          v156(&v344, &type metadata for Int, v157, v45, v89);
          unint64_t v115 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32) + 8LL)
                                                                               + 16LL))( v152,  v95,  v45);
          v106(v95, v45);
          v106(v152, v45);
        }
      }

      uint64_t v126 = v95;
      int64_t v127 = v89;
    }

    uint64_t v14 = 43LL;
    goto LABEL_45;
  }

  if (v3 < v29 >> 14 || v3 >= v35)
  {
    uint64_t v14 = 267LL;
LABEL_45:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v14,  0);
  }

    uint64_t v11 = (v21 - 1) & v21;
    int64_t v19 = __clz(__rbit64(v21)) + (v17 << 6);
LABEL_20:
    uint64_t v23 = 16 * v19;
    uint64_t v24 = (unint64_t *)(v4[3].i64[0] + v23);
    uint64_t v26 = *v24;
    uint64_t v25 = v24[1];
    uint64_t v27 = (uint64_t *)(v4[3].i64[1] + v23);
    uint64_t v29 = *v27;
    uint64_t v28 = v27[1];
    if ((a2 & 1) == 0)
    {
      swift_bridgeObjectRetain(v24[1], v14, v15, v16);
      swift_bridgeObjectRetain(v28, v30, v31, v32);
    }

    uint64_t result = specialized _NativeDictionary._unsafeInsertNew(key:value:)(v26, v25, v29, v28, v35);
  }

    uint64_t v11 = (v21 - 1) & v21;
    int64_t v19 = __clz(__rbit64(v21)) + (v17 << 6);
LABEL_20:
    uint64_t v23 = (unint64_t *)(v4[3].i64[0] + 16 * v19);
    uint64_t v25 = *v23;
    uint64_t v24 = v23[1];
    uint64_t v26 = *(void *)(v4[3].i64[1] + 8 * v19);
    if ((a2 & 1) == 0) {
      swift_bridgeObjectRetain(v23[1], v14, v15, v16);
    }
    uint64_t result = specialized _NativeDictionary._unsafeInsertNew(key:value:)(v25, v24, v26, v28);
  }

    unint64_t v56 = (v31 - 1) & v31;
    int64_t v57 = v29;
  }

  swift_release(v7);
  uint64_t v21 = 1LL << *(_BYTE *)(v7 + 32);
  if (v21 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)( 0LL,  (unint64_t)(v21 + 63) >> 6,  (int64x2_t *)(v7 + 56));
  }
  else {
    const char *v10 = -1LL << v21;
  }
  *(void *)(v7 + 16) = 0LL;
  ++*(_DWORD *)(v7 + 36);
}

  void *v2 = v7;
  return result;
}

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }

      Swift::String::Index v165 = v222;
      ContiguousArray.subscript.getter(v224, v101, v93, v222);
      Swift::String::Index v166 = v213;
      unint64_t v167 = v93;
      ((void (*)(char *, uint64_t, uint64_t))v92)(v213, v165, v7);
      v95(v165, v93);
      unint64_t v168 = v216;
      ((void (*)(char *, char *, uint64_t))v92)(v216, v229, v7);
      unint64_t v169 = v214;
      ((void (*)(char *, char *, uint64_t))v92)(v214, v166, v7);
      unint64_t v170 = v215;
      ((void (*)(char *, char *, uint64_t))v92)(v215, v168, v7);
      unint64_t v171 = v92;
      v100(v170, v7);
      v100(v169, v7);
      unint64_t v172 = TupleTypeMetadata2;
      unint64_t v173 = &v102[*((int *)TupleTypeMetadata2 + 12)];
      unint64_t v174 = *(void (**)(char *, char *, uint64_t))(v195 + 32);
      v174(v102, v166, v7);
      v174(v173, v168, v7);
      char v175 = v230;
      unint64_t v176 = &v230[*((int *)v172 + 12)];
      ((void (*)(char *, char *, uint64_t))v171)(v230, v102, v7);
      ((void (*)(char *, char *, uint64_t))v171)(v176, v173, v7);
      unint64_t v177 = v102;
      uint64_t v178 = v196;
      v174(v196, v175, v7);
      v100(v176, v7);
      unint64_t v179 = &v175[*((int *)v172 + 12)];
      v174(v175, v177, v7);
      v174(v179, v173, v7);
      v174(&v178[*(int *)(v167 + 36)], v179, v7);
      v100(v175, v7);
      Swift::Int v180 = *(void (**)(char *, char *, uint64_t))(v234 + 32);
      uint64_t v181 = v204;
      v180(v204, v178, v167);
      unint64_t v133 = v226;
      v180(v226, v181, v167);
      Swift::String::Index v164 = v167;
    }

    else
    {
      if ((v97 & 1) == 0)
      {
        int64_t v188 = type metadata accessor for ContiguousArray(0LL, v93, v98, v99);
        uint64_t v191 = type metadata accessor for EmptyCollection(0LL, v93, v189, v190);
        uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v191, v192);
        unint64_t v183 = v224;
        unint64_t v184 = v232;
        int64_t v186 = v188;
        char v187 = v191;
        goto LABEL_16;
      }

      int64_t v141 = v228;
      ((void (*)(char *, char *, uint64_t))v92)(v228, v193, v7);
      uint64_t v142 = *v96;
      unint64_t v143 = v221;
      unint64_t v144 = v95;
      unint64_t v145 = v93;
      ContiguousArray.subscript.getter(v194, v142, v93, v221);
      unint64_t v146 = v143 + *(int *)(v93 + 36);
      unint64_t v147 = v212;
      ((void (*)(char *, uint64_t, uint64_t))v92)(v212, v146, v7);
      v144(v143, v145);
      uint64_t v148 = v210;
      uint64_t v149 = v141;
      char v150 = v147;
      ((void (*)(char *, char *, uint64_t))v92)(v210, v149, v7);
      uint64_t v151 = v211;
      ((void (*)(char *, char *, uint64_t))v92)(v211, v147, v7);
      v100(v151, v7);
      v100(v148, v7);
      int64_t v152 = TupleTypeMetadata2;
      int64_t v153 = v233;
      char v154 = &v233[*((int *)TupleTypeMetadata2 + 12)];
      int64_t v155 = *(void (**)(char *, char *, uint64_t))(v195 + 32);
      v155(v233, v228, v7);
      v155(v154, v150, v7);
      BOOL v156 = v230;
      uint64_t v157 = &v230[*((int *)v152 + 12)];
      ((void (*)(char *, char *, uint64_t))v92)(v230, v153, v7);
      ((void (*)(char *, char *, uint64_t))v92)(v157, v154, v7);
      uint64_t v158 = v196;
      v155(v196, v156, v7);
      v100(v157, v7);
      BOOL v159 = &v156[*((int *)v152 + 12)];
      v155(v156, v153, v7);
      v155(v159, v154, v7);
      v155(&v158[*(int *)(v145 + 36)], v159, v7);
      v100(v156, v7);
      unint64_t v160 = *(void (**)(char *, char *, uint64_t))(v234 + 32);
      unint64_t v161 = v203;
      v160(v203, v158, v145);
      unint64_t v133 = v226;
      v160(v226, v161, v145);
      Swift::String::Index v164 = v145;
    }

    uint64_t v138 = type metadata accessor for ContiguousArray(0LL, v164, v162, v163);
    int64_t v139 = &protocol conformance descriptor for CollectionOfOne<A>;
    unint64_t v140 = v227;
    goto LABEL_14;
  }

  __int128 v34 = (v12 - 1) & v12;
  uint64_t v35 = v13;
  for (unint64_t i = __clz(__rbit64(v12)) + (v13 << 6); ; unint64_t i = __clz(__rbit64(v7)) | (v3 << 6))
  {
    outlined init with copy of AnyHashable(*(void *)(result + 48) + 40 * i, (uint64_t)&v46);
    uint64_t v43 = v46;
    uint64_t v44 = v47;
    int64_t v15 = v48;
    uint64_t v45 = v48;
    uint64_t v16 = *(void *)(a2 + 40);
    int64_t v17 = *((void *)&v47 + 1);
    __swift_project_boxed_opaque_existential_0Tm(&v43, *((uint64_t *)&v47 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v15 + 8))(v40, v17, v15);
    unint64_t v18 = v41;
    int64_t v19 = v42;
    __swift_project_boxed_opaque_existential_0Tm(v40, v41);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v19 + 40))(v16, v18, v19);
    __swift_destroy_boxed_opaque_existential_1Tm(v40);
    uint64_t v21 = -1LL << *(_BYTE *)(a2 + 32);
    __int128 v22 = v20 & ~v21;
    if (((*(void *)(v9 + ((v22 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v22) & 1) == 0) {
      break;
    }
    uint64_t v23 = ~v21;
    while (1)
    {
      outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v22, (uint64_t)v40);
      uint64_t v24 = v41;
      uint64_t v25 = v42;
      __swift_project_boxed_opaque_existential_0Tm(v40, v41);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v25 + 8))(v37, v24, v25);
      uint64_t v26 = v38;
      uint64_t v27 = v39;
      __swift_project_boxed_opaque_existential_0Tm(v37, v38);
      uint64_t v28 = *((void *)&v44 + 1);
      uint64_t v29 = v45;
      __swift_project_boxed_opaque_existential_0Tm(&v43, *((uint64_t *)&v44 + 1));
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v29 + 8))(v36, v28, v29);
      uint64_t v30 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v27 + 16))(v36, v26, v27);
      __swift_destroy_boxed_opaque_existential_1Tm(v36);
      if (v30 != 2) {
        break;
      }
      __swift_destroy_boxed_opaque_existential_1Tm(v37);
      outlined destroy of AnyHashable(v40);
LABEL_23:
      __int128 v22 = (v22 + 1) & v23;
      if (((*(void *)(v9 + ((v22 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v22) & 1) == 0) {
        goto LABEL_29;
      }
    }

    __swift_destroy_boxed_opaque_existential_1Tm(v37);
    outlined destroy of AnyHashable(v40);
    if ((v30 & 1) == 0) {
      goto LABEL_23;
    }
    outlined destroy of AnyHashable((uint64_t *)&v43);
    uint64_t v4 = v32;
    uint64_t result = v33;
    unint64_t v8 = v31;
    uint64_t v7 = v34;
    unint64_t v3 = v35;
    if (!v34) {
      goto LABEL_8;
    }
LABEL_7:
    __int128 v34 = (v7 - 1) & v7;
    uint64_t v35 = v3;
  }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }

  if (offsetBy < 0)
  {
    unint64_t v39 = 0LL;
    uint64_t v40 = v9 >> 14;
    int64_t v41 = v9 >> 16;
    uint64_t v42 = 4LL;
    if (((v6 >> 60) & ((v7 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v42 = 8LL;
    }
    uint64_t v43 = v9 & 2 | v42;
    do
    {
      if (v40 >= v11._rawBits >> 14)
      {
        __int128 v47 = 321LL;
LABEL_77:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/Substring.swift",  21LL,  2,  v47,  0);
      }

      --v39;
      uint64_t v44 = _StringGuts._opaqueCharacterStride(endingAt:in:)(v11._rawBits >> 16, v41, v2, v7, v6);
      uint64_t v45 = v44 << 8;
      if (v44 > 63) {
        uint64_t v45 = 0LL;
      }
      v11._rawBits = v43 | v45 | (v11._rawBits - (v44 << 16)) & 0xFFFFFFFFFFFF0000LL | 1;
    }

    while (v39 > offsetBy);
  }

  else if (offsetBy)
  {
    uint64_t v16 = v8 >> 14;
    int64_t v17 = v8 >> 16;
    unint64_t v18 = HIBYTE(v6) & 0xF;
    int64_t v19 = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v20 = 4LL;
    if (((v6 >> 60) & ((v7 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v20 = 8LL;
    }
    uint64_t v21 = v9 & 2 | v20;
    while (1)
    {
      if (v16 <= v11._rawBits >> 14)
      {
        __int128 v47 = 316LL;
        goto LABEL_77;
      }

      __int128 v22 = (v11._rawBits >> 8) & 0x3F;
      uint64_t v23 = v11._rawBits >> 16;
      if (!v22) {
        break;
      }
LABEL_40:
      uint64_t v27 = v22 + v23;
      if (v17 < v22 + v23) {
        uint64_t v27 = v17;
      }
      uint64_t v28 = v27 << 16;
      uint64_t v29 = v27 & 0xFFFFFFFFFFFFLL;
      if ((v27 & 0xFFFFFFFFFFFFLL) != v17)
      {
        if ((v6 & 0x1000000000000000LL) != 0) {
          goto LABEL_62;
        }
        if ((v6 & 0x2000000000000000LL) != 0)
        {
          int64_t v53 = v7;
          uint64_t v54 = v19;
          if (v29 + 1 != v18)
          {
            uint64_t v33 = *(unsigned __int16 *)((char *)&v53 + v29);
LABEL_53:
            if (v33 == 2573 || (v33 & 0x8080) != 0)
            {
LABEL_62:
              uint64_t v49 = v18;
              uint64_t v35 = v29;
              int64_t v36 = v19;
              uint64_t v30 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v35);
              int64_t v19 = v36;
              unint64_t v18 = v49;
              if (v30 > 63) {
                goto LABEL_60;
              }
              goto LABEL_59;
            }
          }
        }

        else
        {
          uint64_t v31 = (char *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v32 = v7 & 0xFFFFFFFFFFFFLL;
          if ((v7 & 0x1000000000000000LL) == 0)
          {
            uint64_t v48 = v19;
            int64_t v51 = v18;
            uint64_t v31 = (char *)_StringObject.sharedUTF8.getter(v7, v6);
            int64_t v19 = v48;
            unint64_t v18 = v51;
          }

          if (v29 + 1 != v32)
          {
            if (!v31) {
LABEL_80:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            uint64_t v33 = *(unsigned __int16 *)&v31[v29];
            goto LABEL_53;
          }
        }

        uint64_t v30 = 1LL;
        goto LABEL_59;
      }

      uint64_t v30 = 0LL;
LABEL_59:
      v28 |= v30 << 8;
LABEL_60:
      v11._rawBits = v21 | v28 | 1;
      if (!--offsetBy) {
        return v11;
      }
    }

    if (v23 == v17)
    {
      __int128 v22 = 0LL;
      goto LABEL_40;
    }

    if ((v6 & 0x1000000000000000LL) == 0)
    {
      if ((v6 & 0x2000000000000000LL) == 0)
      {
        uint64_t v24 = (char *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v25 = v7 & 0xFFFFFFFFFFFFLL;
        if ((v7 & 0x1000000000000000LL) == 0)
        {
          unint64_t v52 = v18;
          unint64_t v38 = v19;
          uint64_t v24 = (char *)_StringObject.sharedUTF8.getter(v7, v6);
          int64_t v19 = v38;
          unint64_t v18 = v52;
        }

        if (v23 + 1 == v25)
        {
LABEL_39:
          __int128 v22 = 1LL;
          goto LABEL_40;
        }

        if (!v24) {
          goto LABEL_80;
        }
        uint64_t v26 = *(unsigned __int16 *)&v24[v23];
        if (v26 == 2573) {
          goto LABEL_64;
        }
        goto LABEL_38;
      }

      int64_t v53 = v7;
      uint64_t v54 = v19;
      if (v23 + 1 == v18) {
        goto LABEL_39;
      }
      uint64_t v26 = *(unsigned __int16 *)((char *)&v53 + v23);
      if (v26 != 2573)
      {
LABEL_38:
        if ((v26 & 0x80808080) == 0) {
          goto LABEL_39;
        }
      }
    }

  uint64_t v20 = v7._rawBits >> 16;
  uint64_t v21 = v6._rawBits >> 16;
  if ((v9 & ~v11 & 0x2000000000000000LL) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL);
    uint64_t v9 = v19[2]._rawBits;
    uint64_t v11 = v19[3]._rawBits;
    if (isUniquelyReferenced_nonNull_native)
    {
      v6._rawBits = a4;
      swift_bridgeObjectRetain(a4, v23, v24, v25);
      v7._rawBits = a3;
      uint64_t v26 = specialized Collection.count.getter( a3,  a4,  (void (*)(unint64_t *__return_ptr, uint64_t *))closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL);
      uint64_t v27 = v20 + v26;
      if (__OFADD__(v20, v26))
      {
        __break(1u);
      }

      else
      {
        uint64_t v28 = v9 & 0xFFFFFFFFFFFFLL;
        if ((v11 & 0x2000000000000000LL) != 0) {
          uint64_t v28 = HIBYTE(v11) & 0xF;
        }
        uint64_t v29 = v28 - v21;
        int64_t v15 = v27 + v29;
        if (!__OFADD__(v27, v29))
        {
          uint64_t v30 = v26;
          startingAt = v20 + v26;
          uint64_t v11 = v20;
          if (v15 >= 16)
          {
            uint64_t v31 = _StringGuts.uniqueNativeCapacity.getter();
            if ((v32 & 1) != 0 || v31 < v15)
            {
              uint64_t v33 = _StringGuts.uniqueNativeCapacity.getter();
              if ((v34 & 1) != 0)
              {
                uint64_t v128 = v19[3]._rawBits;
                if ((v128 & 0x1000000000000000LL) != 0)
                {
                  uint64_t v35 = String.UTF8View._foreignCount()();
                }

                else if ((v128 & 0x2000000000000000LL) != 0)
                {
                  uint64_t v35 = HIBYTE(v128) & 0xF;
                }

                else
                {
                  uint64_t v35 = v19[2]._rawBits & 0xFFFFFFFFFFFFLL;
                }
              }

              else
              {
                uint64_t v35 = 2 * v33;
              }

              if (v35 > v15) {
                int64_t v15 = v35;
              }
              Swift::UInt v129 = v19[3]._rawBits;
              if ((v129 & 0x1000000000000000LL) != 0)
              {
                _StringGuts._foreignGrow(_:)(v15);
              }

              else
              {
                uint64_t v130 = *(void *)v8;
                if ((v129 & 0x2000000000000000LL) != 0)
                {
                  unint64_t v133 = (v129 >> 62) & 1;
                  unint64_t v182 = v130;
                  unint64_t v183 = v129 & 0xFFFFFFFFFFFFFFLL;
                  uint64_t v131 = (char *)&v182;
                  size_t v132 = HIBYTE(v129) & 0xF;
                }

                else
                {
                  if ((v130 & 0x1000000000000000LL) != 0)
                  {
                    uint64_t v131 = (char *)((v129 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    size_t v132 = v130 & 0xFFFFFFFFFFFFLL;
                  }

                  else
                  {
                    uint64_t v131 = (char *)_StringObject.sharedUTF8.getter(v130, v129);
                  }

                  unint64_t v133 = v130 >> 63;
                }

                unint64_t v134 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v131,  v132,  v15,  v133);
                id v135 = *(void *)(v134 + 24);
                swift_bridgeObjectRelease(*(void *)(v179 + 24));
                *(void *)(v179 + 16) = v135;
                *(void *)(v179 + 24) = v134;
                int64_t v19 = (Swift::String::Index *)v179;
              }
            }
          }

          int64_t v15 = v19[3]._rawBits;
          specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( v20,  v21,  a3,  a4,  (uint64_t)closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL,  v30);
          swift_bridgeObjectRelease(a4);
          uint64_t v12 = *(void *)(v15 + 24);
          v19[2]._rawBits = v12;
          goto LABEL_115;
        }
      }

      __break(1u);
      goto LABEL_183;
    }
  }

  unint64_t v8 = 0xE000000000000000LL;
  unint64_t v182 = 0LL;
  unint64_t v183 = 0xE000000000000000LL;
  int64_t v36 = _StringGuts.nativeCapacity.getter(v9, v11);
  uint64_t v9 = 0LL;
  if ((v37 & 1) == 0)
  {
    unint64_t v38 = v36;
    if (v36 >= 16)
    {
      unint64_t v39 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v40 & 1) != 0 || v39 < v38)
      {
        uint64_t v42 = 2 * _StringGuts.uniqueNativeCapacity.getter();
        if (v42 <= v38) {
          uint64_t v42 = v38;
        }
        if ((v41 & 1) != 0) {
          uint64_t v43 = v38;
        }
        else {
          uint64_t v43 = v42;
        }
        Swift::Int v180 = 0LL;
        uint64_t v181 = 0LL;
        unint64_t v8 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v180,  0LL,  v43,  1);
        uint64_t v9 = *(void *)(v8 + 24);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        unint64_t v182 = v9;
        unint64_t v183 = v8;
      }

      else
      {
        uint64_t v9 = 0LL;
        unint64_t v8 = 0xE000000000000000LL;
      }
    }
  }

  v44._rawBits = v7._rawBits;
  startingAt = v19[2]._rawBits;
  unint64_t v173 = v7._rawBits >> 16;
  unint64_t v174 = v19[3]._rawBits;
  uint64_t v11 = specialized Collection.subscript.getter(v44, startingAt, v174);
  int64_t v15 = v47;
  v7._rawBits = v46;
  uint64_t v12 = v47 >> 16;
  unint64_t v171 = v11 >> 16;
  unint64_t v172 = v6._rawBits >> 16;
  unint64_t v179 = v45;
  if ((v46 & 0x1000000000000000LL) == 0)
  {
    uint64_t v13 = v12 - (v11 >> 16);
    swift_bridgeObjectRetain_n(v46, 2LL, v45, (char *)v46);
    if ((v8 & 0x1000000000000000LL) != 0) {
      goto LABEL_149;
    }
LABEL_44:
    if ((v8 & 0x2000000000000000LL) != 0)
    {
      int64_t v51 = HIBYTE(v8) & 0xF;
      uint64_t v50 = v51 + v13;
      if (__OFADD__(v51, v13)) {
        goto LABEL_151;
      }
    }

    else
    {
      uint64_t v50 = (v9 & 0xFFFFFFFFFFFFLL) + v13;
      if (__OFADD__(v9 & 0xFFFFFFFFFFFFLL, v13)) {
        goto LABEL_151;
      }
    }

    __break(1u);
    goto LABEL_20;
  }

  uint64_t v67 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 120);
  uint64_t v68 = v67(v5, v7);
  uint64_t v69 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
  v69(v30, v5);
  *(_DWORD *)v3 &= ~(v68 << v3[4]);
  int64_t v70 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 16);
  uint64_t v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
  ((void (*)(uint64_t (*)(uint64_t, uint64_t), uint64_t (*)(uint64_t, uint64_t), uint64_t))v70)( (uint64_t (*)(uint64_t, uint64_t))v121,  v113,  v5);
  if ((v36(v5, v7) & 1) == 0) {
    goto LABEL_22;
  }
  uint64_t v113 = v67;
  uint64_t v116 = v3;
  uint64_t v72 = v111;
  ((void (*)(_BYTE *, uint64_t (*)(uint64_t, uint64_t), uint64_t))v70)(v111, v71, v5);
  uint64_t v73 = AssociatedTypeWitness;
  unint64_t v74 = v119;
  int64_t v75 = swift_getAssociatedConformanceWitness( (uint64_t)v119,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v76 = v117;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v75 + 8))( &unk_18180BE68,  256LL,  v73,  v75);
  uint64_t v77 = v122;
  (*((void (**)(_BYTE *, uint64_t, const char *))v74 + 3))(v76, v5, v74);
  LOBYTE(v73) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 32LL))( v72,  v77,  v5);
  v69(v77, v5);
  if ((v73 & 1) == 0) {
LABEL_40:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  v69(v72, v5);
  unint64_t v3 = v116;
  int64_t v36 = v120;
  uint64_t v67 = v113;
  uint64_t v44 = v114;
LABEL_22:
  if (v44(v5, v7) >= 32)
  {
    uint64_t v113 = v70;
    ((void (*)(_BYTE *, uint64_t (*)(uint64_t, uint64_t), uint64_t))v70)(v115, v71, v5);
    uint64_t v126 = -1;
    uint64_t v78 = v36(v5, v7);
    uint64_t v79 = v44(v5, v7);
    if ((v78 & 1) != 0)
    {
      uint64_t v116 = v3;
      if (v79 >= 33)
      {
        uint64_t v82 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
        uint64_t v83 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v79, v80, v81);
        unint64_t v84 = v122;
        v82(&v126, &type metadata for UInt32, v83, v5, v7);
        size_t v85 = v115;
        unint64_t v86 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 16LL))( v84,  v115,  v5);
        v69(v84, v5);
        uint64_t v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        unint64_t v3 = v116;
        if ((v86 & 1) != 0) {
          goto LABEL_34;
        }
        goto LABEL_36;
      }

      unint64_t v92 = AssociatedTypeWitness;
      unint64_t v93 = v119;
      char v94 = swift_getAssociatedConformanceWitness( (uint64_t)v119,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v95 = v117;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v94 + 8))( &unk_18180BE68,  256LL,  v92,  v94);
      unint64_t v96 = v122;
      (*((void (**)(_BYTE *, uint64_t, const char *))v93 + 3))(v95, v5, v93);
      unint64_t v97 = v115;
      LOBYTE(v92) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 40LL))( v115,  v96,  v5);
      v69(v96, v5);
      uint64_t v98 = v126;
      unint64_t v99 = v110;
      ((void (*)(_BYTE *, _BYTE *, uint64_t))v113)(v110, v97, v5);
      if ((v92 & 1) != 0)
      {
        Swift::String::Index v100 = v67(v5, v7);
        v69(v99, v5);
        size_t v101 = v98 >= v100;
        uint64_t v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        size_t v85 = v115;
        unint64_t v3 = v116;
        if (!v101) {
LABEL_34:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
      }

      else
      {
        v69(v99, v5);
        uint64_t v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        size_t v85 = v115;
        unint64_t v3 = v116;
      }
    }

    else
    {
      uint64_t v87 = v3;
      if (v79 <= 32)
      {
        uint64_t v102 = v122;
        size_t v85 = v115;
        ((void (*)(_BYTE *, _BYTE *, uint64_t))v113)(v122, v115, v5);
        uint64_t v103 = v67(v5, v7);
        v69(v102, v5);
        uint64_t v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        unint64_t v3 = v87;
        if (v126 < v103) {
          goto LABEL_34;
        }
      }

      else
      {
        __int128 v88 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
        __int128 v89 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v79, v80, v81);
        uint64_t v90 = v122;
        v88(&v126, &type metadata for UInt32, v89, v5, v7);
        size_t v85 = v115;
        uint64_t v91 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 16LL))( v90,  v115,  v5);
        v69(v90, v5);
        uint64_t v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        unint64_t v3 = v87;
        if ((v91 & 1) != 0) {
          goto LABEL_34;
        }
      }
    }

  uint64_t v103 = *(_BYTE **)(v7 + 120);
  char v62 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
  uint64_t v63 = (void (*)(_BYTE *, uint64_t))*((void *)v10 + 1);
  v63(v28, v5);
  *v4 &= ~(v62 << *((_BYTE *)v4 + 4));
  int64_t v64 = v34(v5, v7);
  id v65 = v108;
  if ((v64 & 1) == 0) {
    goto LABEL_22;
  }
  unint64_t v97 = v10;
  uint64_t v66 = v99;
  (*((void (**)(_BYTE *, _BYTE *, uint64_t))v10 + 2))(v99, v108, v5);
  uint64_t v67 = AssociatedTypeWitness;
  uint64_t v68 = v106;
  uint64_t v69 = swift_getAssociatedConformanceWitness( (uint64_t)v106,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v70 = v104;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v69 + 8))( &unk_18180BE68,  256LL,  v67,  v69);
  (*((void (**)(_BYTE *, uint64_t, const char *))v68 + 3))(v70, v5, v68);
  LOBYTE(v67) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 32LL))( v66,  v23,  v5);
  v63(v23, v5);
  if ((v67 & 1) == 0) {
LABEL_38:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  v63(v66, v5);
  uint64_t v10 = v97;
  __int128 v34 = v102;
LABEL_22:
  uint64_t v71 = v107;
  if (v107(v5, v7) >= 32)
  {
    uint64_t v72 = (_BYTE *)*((void *)v10 + 2);
    uint64_t v73 = v98;
    unint64_t v99 = v72;
    ((void (*)(_BYTE *, _BYTE *, uint64_t))v72)(v98, v65, v5);
    uint64_t v112 = -1;
    unint64_t v74 = v34(v5, v7);
    int64_t v75 = v71(v5, v7);
    if ((v74 & 1) != 0)
    {
      if (v75 < 33)
      {
        uint64_t v78 = AssociatedTypeWitness;
        uint64_t v79 = v106;
        uint64_t v80 = swift_getAssociatedConformanceWitness( (uint64_t)v106,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v81 = v104;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v80 + 8))( &unk_18180BE68,  256LL,  v78,  v80);
        (*((void (**)(_BYTE *, uint64_t, const char *))v79 + 3))(v81, v5, v79);
        LOBYTE(v78) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL)
                                                                           + 40LL))( v73,  v23,  v5);
        v63(v23, v5);
        uint64_t v82 = v112;
        uint64_t v83 = v96;
        ((void (*)(_BYTE *, _BYTE *, uint64_t))v99)(v96, v73, v5);
        if ((v78 & 1) != 0)
        {
          unint64_t v84 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
          v63(v83, v5);
          size_t v85 = v82 >= v84;
          goto LABEL_31;
        }

        v63(v83, v5);
        id v65 = v108;
LABEL_34:
        v63(v73, v5);
        goto LABEL_35;
      }
    }

    else if (v75 <= 32)
    {
      ((void (*)(_BYTE *, _BYTE *, uint64_t))v99)(v23, v73, v5);
      __int128 v89 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
      v63(v23, v5);
      size_t v85 = v112 >= v89;
LABEL_31:
      id v65 = v108;
      if (!v85) {
        goto LABEL_32;
      }
      goto LABEL_34;
    }

    unint64_t v86 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    uint64_t v87 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v75, v76, v77);
    v86(&v112, &type metadata for UInt32, v87, v5, v7);
    __int128 v88 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 16LL))( v23,  v73,  v5);
    v63(v23, v5);
    id v65 = v108;
    if ((v88 & 1) == 0) {
      goto LABEL_34;
    }
LABEL_32:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }

  uint64_t v55 = v127(a3, a4);
  unint64_t v56 = v126(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64) {
      goto LABEL_21;
    }
LABEL_24:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v62(v29, a3);
    if (v63 > 128) {
      goto LABEL_25;
    }
    goto LABEL_26;
  }

  if (v56 <= 63) {
    goto LABEL_24;
  }
LABEL_21:
  Swift::UInt v129 = 128LL;
  uint64_t v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  int64_t v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v129, &type metadata for Int, v60, a3, a4);
  uint64_t v61 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
  char v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v62(v29, a3);
  if ((v61 & 1) != 0) {
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v123 = v30;
  int64_t v64 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  id v65 = v125;
  v64(v125, a2, a3);
  uint64_t v66 = v127(a3, a4);
  v64(v25, (uint64_t)v65, a3);
  if ((v66 & 1) != 0)
  {
    uint64_t v67 = v126(a3, a4);
    v62(v25, a3);
    if (v67 <= 64) {
      goto LABEL_47;
    }
    uint64_t v68 = v117;
    v64(v117, (uint64_t)v125, a3);
    Swift::UInt v129 = 0x8000000000000000LL;
    uint64_t v69 = v127;
    if ((v127(a3, a4) & 1) != 0)
    {
      int64_t v70 = v126(a3, a4);
      if (v70 < 64)
      {
        uint64_t v73 = v29;
        goto LABEL_41;
      }

      uint64_t v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
      v82(&v129, &type metadata for Int, v83, a3, a4);
      uint64_t v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  v29,  a3);
      goto LABEL_36;
    }

    int64_t v75 = v69(a3, a4);
    uint64_t v76 = v126(a3, a4);
    if ((v75 & 1) != 0)
    {
      if (v76 <= 64)
      {
        uint64_t v87 = AssociatedTypeWitness;
        unint64_t v86 = (void (**)(char *, uint64_t, const char *))v120;
        __int128 v88 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        __int128 v89 = v118;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v88 + 8))( &unk_18180BE68,  256LL,  v87,  v88);
        v86[3](v89, a3, (const char *)v86);
        uint64_t v90 = v117;
        LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v29,  a3);
        v62(v29, a3);
        uint64_t v91 = v116;
        v64(v116, (uint64_t)v90, a3);
        if ((v86 & 1) != 0)
        {
          v62(v91, a3);
          goto LABEL_70;
        }

        unint64_t v92 = v129;
        unint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v62(v91, a3);
        uint64_t v68 = v117;
        if (v93 < v92) {
          goto LABEL_70;
        }
LABEL_45:
        unint64_t v74 = v68;
        goto LABEL_46;
      }

      uint64_t v79 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v80 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
      v79(&v129, &type metadata for Int, v80, a3, a4);
      uint64_t v68 = v117;
      uint64_t v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v29,  a3);
LABEL_36:
      unint64_t v84 = v81;
      v62(v29, a3);
      if ((v84 & 1) != 0) {
        goto LABEL_70;
      }
      goto LABEL_45;
    }

    if (v76 < 64)
    {
      uint64_t v73 = v29;
      uint64_t v68 = v117;
LABEL_41:
      v64(v73, (uint64_t)v68, a3);
      size_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      if (v85 < v129) {
LABEL_70:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      goto LABEL_45;
    }

    unint64_t v74 = v117;
  }

  else
  {
    unint64_t v74 = v25;
  }

  int64_t v53 = v119(a3, a4);
  uint64_t v54 = v117(a3, a4);
  if ((v53 & 1) != 0)
  {
    if (v54 > 64) {
      goto LABEL_21;
    }
  }

  else if (v54 >= 64)
  {
LABEL_21:
    unint64_t v121 = 128LL;
    int64_t v57 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v58 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v57(&v121, &type metadata for Int, v58, a3, a4);
    uint64_t v59 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    int64_t v60 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    uint64_t result = v60(v29, a3);
    if ((v59 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    int64_t v70 = v118[1];
    goto LABEL_30;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
  uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int64_t v60 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  uint64_t result = v60(v29, a3);
  if (v69 > 128) {
    goto LABEL_29;
  }
LABEL_22:
  uint64_t v61 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v61(v27, a2, a3);
  char v62 = v119(a3, a4);
  v61(v24, (uint64_t)v27, a3);
  if ((v62 & 1) == 0) {
    goto LABEL_44;
  }
  uint64_t v63 = v117(a3, a4);
  v60(v24, a3);
  if (v63 <= 64) {
    goto LABEL_46;
  }
  uint64_t v24 = v112;
  v61(v112, (uint64_t)v27, a3);
  unint64_t v121 = 0x8000000000000000LL;
  int64_t v64 = v119;
  if ((v119(a3, a4) & 1) != 0)
  {
    id v65 = v117(a3, a4);
    if (v65 < 64)
    {
      uint64_t v68 = v29;
      goto LABEL_40;
    }

    uint64_t v78 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v79 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
    v78(&v121, &type metadata for Int, v79, a3, a4);
    uint64_t v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v24,  v29,  a3);
    goto LABEL_35;
  }

  uint64_t v71 = v64(a3, a4);
  uint64_t v72 = v117(a3, a4);
  if ((v71 & 1) != 0)
  {
    if (v72 > 64)
    {
      int64_t v75 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v76 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
      v75(&v121, &type metadata for Int, v76, a3, a4);
      uint64_t v24 = v112;
      uint64_t v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
LABEL_35:
      uint64_t v80 = v77;
      v60(v29, a3);
      if ((v80 & 1) != 0) {
        goto LABEL_68;
      }
      goto LABEL_44;
    }

    uint64_t v83 = AssociatedTypeWitness;
    uint64_t v82 = (void (**)(char *, uint64_t, const char *))v115;
    unint64_t v84 = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    size_t v85 = v113;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v84 + 8))( &unk_18180BE68,  256LL,  v83,  v84);
    v82[3](v85, a3, (const char *)v82);
    unint64_t v86 = v112;
    LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
    v60(v29, a3);
    uint64_t v87 = v111;
    v61(v111, (uint64_t)v86, a3);
    if ((v82 & 1) != 0)
    {
      v60(v87, a3);
      goto LABEL_68;
    }

    __int128 v88 = v121;
    __int128 v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v60(v87, a3);
    uint64_t v90 = v89 < v88;
    uint64_t v24 = v112;
    if (v90) {
      goto LABEL_68;
    }
LABEL_44:
    uint64_t v107 = v24;
    goto LABEL_45;
  }

  if (v72 < 64)
  {
    uint64_t v68 = v29;
    uint64_t v24 = v112;
LABEL_40:
    v61(v68, (uint64_t)v24, a3);
    uint64_t v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v60(v29, a3);
    if (v81 < v121) {
LABEL_68:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
    goto LABEL_44;
  }

  uint64_t v107 = v112;
LABEL_45:
  v60(v107, a3);
LABEL_46:
  uint64_t v91 = v117;
  unint64_t v92 = v117(a3, a4);
  unint64_t v93 = v116;
  v61(v116, (uint64_t)v27, a3);
  if (v92 >= 65)
  {
    v60(v93, a3);
    goto LABEL_48;
  }

  size_t v101 = v91(a3, a4);
  v60(v93, a3);
  if (v101 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_48:
    v61(v17, (uint64_t)v27, a3);
    unint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
    char v94 = v119(a3, a4);
    uint64_t v95 = v117(a3, a4);
    if ((v94 & 1) != 0)
    {
      if (v95 > 64)
      {
        uint64_t v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v99 = lazy protocol witness table accessor for type Int and conformance Int(v95, v96, v97);
        Swift::String::Index v100 = &v121;
        goto LABEL_57;
      }
    }

    else if (v95 >= 64)
    {
      uint64_t v120 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v99 = lazy protocol witness table accessor for type Int and conformance Int(v95, v96, v97);
      Swift::String::Index v100 = &v120;
LABEL_57:
      v98(v100, &type metadata for Int, v99, a3, a4);
      uint64_t v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v17,  a3);
      v60(v29, a3);
      if ((v102 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_58;
    }

    v61(v29, (uint64_t)v17, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v60(v29, a3);
LABEL_58:
    v60(v17, a3);
  }

  uint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v60(v27, a3);
  unint64_t v104 = *v118;
  int64_t v70 = v118[1];
  if ((v103 & 0x8000000000000000LL) == 0)
  {
    if (v103 < 0x80)
    {
      int64_t v51 = ((2 * v70) << ~(_BYTE)v103) | (v104 >> v103);
      int64_t v105 = v70 >> v103;
      if ((v103 & 0x40) != 0) {
        int64_t v51 = v70 >> v103;
      }
      unint64_t v52 = v70 >> 63;
      if ((v103 & 0x40) == 0) {
        unint64_t v52 = v105;
      }
      goto LABEL_65;
    }

  uint64_t v54 = (char)v118 >> 7;
LABEL_51:
  *uint64_t v119 = v54;
  return result;
}

  uint64_t v54 = (__int16)v118 >> 15;
LABEL_51:
  *uint64_t v119 = v54;
  return result;
}

  uint64_t v12 = v6 * v5 + v7 * v4;
  uint64_t v13 = v6 * v4;
  uint64_t v14 = v12 + ((v6 * (unsigned __int128)(unint64_t)v4) >> 64);
  int64_t v15 = -v14;
  if (v13) {
    int64_t v15 = ~v14;
  }
  uint64_t v16 = (__PAIR128__(v15, -v13 - 1) + __PAIR128__((uint64_t)((unint64_t)(v13 == 0) << 63) >> 63, 1LL)) >> 64;
  int64_t v17 = -v13;
  if (v9) {
    uint64_t v14 = v16;
  }
  else {
    int64_t v17 = v13;
  }
  *a3 = v17;
  a3[1] = v14;
  return result;
}

      uint64_t v16 = (v14 >> (8 * a5)) + 1;
      if (!a5)
      {
LABEL_30:
        switch(v12)
        {
          case 0u:
            return;
          case 1u:
            *uint64_t v11 = v16;
            break;
          case 2u:
            *(_WORD *)uint64_t v11 = v16;
            break;
          case 3u:
            *(_WORD *)uint64_t v11 = v16;
            v11[2] = BYTE2(v16);
            break;
          case 4u:
            *(_DWORD *)uint64_t v11 = v16;
            break;
          default:
            *(_DWORD *)uint64_t v11 = v16;
            bzero(v11 + 4, v12 - 4LL);
            break;
        }

        return;
      }

      v14 &= ~(-1 << (8 * a5));
LABEL_21:
      switch(a5)
      {
        case 1uLL:
          *a1 = v14;
          break;
        case 2uLL:
          *(_WORD *)a1 = v14;
          break;
        case 3uLL:
          *(_WORD *)a1 = v14;
          a1[2] = BYTE2(v14);
          break;
        case 4uLL:
          *(_DWORD *)a1 = v14;
          break;
        default:
          *(_DWORD *)a1 = v14;
          bzero(a1 + 4, a5 - 4);
          break;
      }

      goto LABEL_30;
    }

    uint64_t v13 = ((a3 - a6 + ~(-1 << (8 * a5))) >> (8 * a5)) + 1;
    if (v13 >= 2)
    {
      if (v13 >= 0x10000) {
        int64_t v15 = 4;
      }
      else {
        int64_t v15 = 2;
      }
      if (v13 >= 0x100) {
        uint64_t v12 = v15;
      }
      else {
        uint64_t v12 = 1;
      }
      goto LABEL_17;
    }

    if (a2 > a6)
    {
      uint64_t v12 = 0;
      uint64_t v14 = ~(_DWORD)a6 + a2;
      goto LABEL_19;
    }
  }

  if (v23 >= 0x100)
  {
    uint64_t v24 = 4LL;
    if (v23 < 0x10000) {
      uint64_t v24 = 2LL;
    }
  }

  else
  {
    uint64_t v24 = 1LL;
  }

  v12[0] = off_189B8E500;
  uint64_t v9 = v50;
  if (v50 == v49)
  {
    uint64_t v10 = 4LL;
    uint64_t v9 = v49;
  }

  else
  {
    if (!v50) {
      goto LABEL_24;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void *))(*v9 + 8 * v10))(v9);
LABEL_24:
  v12[0] = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v13);
  if (v14) {
    *(_BYTE *)(v14 + 48) = 0;
  }
  return v6;
}

  v98[0] = off_189B8D850;
  v98[1] = &v56;
  unint64_t v99 = v98;
  int64_t v19 = (unsigned int *)swift::Demangle::__runtime::Demangler::demangleType((uint64_t)&v56, (uint64_t)a2, a3, v98);
  uint64_t v26 = v99;
  if (v99 == v98)
  {
    uint64_t v27 = 4LL;
    uint64_t v26 = v98;
  }

  else
  {
    if (!v99) {
      goto LABEL_24;
    }
    uint64_t v27 = 5LL;
  }

  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_24:
  if (!v19)
  {
    *(_BYTE *)(a7 + 16) = 0;
    *(void *)a7 = "unknown error";
    *(void *)(a7 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
    *(_WORD *)(a7 + 24) = 1;
    goto LABEL_59;
  }

  uint64_t v28 = (void *)a5[3];
  if (v28) {
    goto LABEL_26;
  }
LABEL_45:
  uint64_t v55 = 0LL;
  uint64_t v29 = (void *)a6[3];
  if (!v29) {
    goto LABEL_31;
  }
LABEL_46:
  if (v29 == a6)
  {
    int64_t v53 = v52;
    (*(void (**)(void *, void *))(*a6 + 24LL))(a6, v52);
  }

  else
  {
    int64_t v53 = (void *)(*(uint64_t (**)(void *))(*v29 + 16LL))(v29);
  }

  int64_t v17 = *((void *)this + 9);
  if (v17 >= *((void *)this + 8))
  {
    unint64_t v18 = 0;
  }

  else
  {
    *((void *)this + 9) = v17 + 1;
    unint64_t v18 = *(unsigned __int8 *)(*((void *)this + 7) + v17);
  }

  HIDWORD(v19) = v18;
  LODWORD(v19) = (v18 << 24) - 1677721600;
  uint64_t v20 = (v19 >> 25);
  uint64_t v21 = v20 > 7;
  __int128 v22 = (1 << v20) & 0xC3;
  if (v21 || v22 == 0) {
    return 0LL;
  }
  uint64_t v24 = (char)v18;
  uint64_t v25 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v25 || v25 + 24 > *((void *)this + 2))
  {
    uint64_t v26 = 2LL * *((void *)this + 4);
    if (v26 <= 0x20) {
      uint64_t v26 = 32LL;
    }
    *((void *)this + 4) = v26;
    uint64_t v27 = v26 + 8;
    uint64_t v28 = malloc(v26 + 8);
    *uint64_t v28 = *((void *)this + 3);
    uint64_t v25 = ((unint64_t)v28 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = (char *)v28 + v27;
    *((void *)this + 3) = v28;
  }

  *((void *)this + 1) = v25 + 24;
  *(_WORD *)(v25 + 16) = 321;
  *(_BYTE *)(v25 + 18) = 4;
  *(void *)uint64_t v25 = v24;
  if (v6) {
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v25,  this,  a4,  a5);
  }
  return v6;
}

  if (v2 == 5)
  {
  }

  else
  {
    uint64_t v6 = a1 + 1;
    if (v2 != 1) {
      uint64_t v6 = 0LL;
    }
    if (v2 == 2) {
      uint64_t v7 = a1 + 2;
    }
    else {
      uint64_t v7 = v6;
    }
    if (v3 != v7) {
      return *v3;
    }
  }

  return 0LL;
}

    int64_t v15 = 0;
    uint64_t v16 = a5 + 1;
    int64_t v17 = "";
    while (1)
    {
      uint64_t v20 = *v12;
      uint64_t v21 = *(unsigned __int16 *)(*v12 + 16);
      if (v21 == 216 || v21 == 339) {
        goto LABEL_24;
      }
      if (v21 == 217)
      {
        if (v17) {
          __int128 v22 = strlen(v17);
        }
        else {
          __int128 v22 = 0LL;
        }
        std::string::append(v7, v17, v22);
        int64_t v17 = ", ";
        goto LABEL_24;
      }

      uint64_t v23 = *(unsigned __int8 *)(v20 + 18);
LABEL_23:
      ++v15;
LABEL_24:
      if (++v12 == v14) {
        return std::string::append(v7, "> of ", 5uLL);
      }
    }

    if (v17) {
      uint64_t v24 = strlen(v17);
    }
    else {
      uint64_t v24 = 0LL;
    }
    std::string::append(v7, v17, v24);
    std::string::append(v7, a6, a7);
    uint64_t v25 = *(unsigned __int16 *)(v20 + 16);
    uint64_t v26 = v7;
    if (v25 == 79)
    {
      unint64_t v18 = "Return = ";
      int64_t v19 = 9LL;
    }

    else
    {
      if (v25 != 78)
      {
        goto LABEL_22;
      }

      std::string::append(v7, "Arg[", 4uLL);
      snprintf(__str, 0x20uLL, "%lld", v15);
      std::string::append(v7, __str);
      uint64_t v26 = v7;
      unint64_t v18 = "] = ";
      int64_t v19 = 4LL;
    }

    std::string::append(v26, v18, v19);
LABEL_22:
    int64_t v17 = ", ";
    goto LABEL_23;
  }

  if (!result[4].__r_.__value_.__s.__data_[0])
  {
    uint64_t result = std::string::append(result, "specialized ", 0xCuLL);
    v7[4].__r_.__value_.__s.__data_[0] = 1;
  }

  return result;
}

  if (v9 == 5)
  {
  }

  else
  {
    uint64_t v13 = (swift::Demangle::__runtime::Node *)((char *)a2 + 8);
    if (v9 != 1) {
      uint64_t v13 = 0LL;
    }
    if (v9 == 2) {
      uint64_t v14 = (swift::Demangle::__runtime::Node *)((char *)a2 + 16);
    }
    else {
      uint64_t v14 = v13;
    }
    if (v10 != v14)
    {
LABEL_26:
      int64_t v15 = *(swift::Demangle::__runtime::Node **)v10;
      if (a4 | *(void *)v10) {
        goto LABEL_27;
      }
LABEL_33:
      return;
    }
  }

  int64_t v15 = 0LL;
  if (!a4) {
    goto LABEL_33;
  }
LABEL_27:
  if (!a4)
  {
    if (*((_WORD *)a3 + 8) != 44) {
      goto LABEL_85;
    }
    int64_t v19 = *((unsigned __int8 *)a3 + 18);
    uint64_t v20 = (swift::Demangle::__runtime::Node **)a3;
    if ((v19 - 1) >= 2)
    {
      if (v19 != 5 || !*((_DWORD *)a3 + 2))
      {
        uint64_t v21 = 0LL;
        goto LABEL_57;
      }

      uint64_t v20 = *(swift::Demangle::__runtime::Node ***)a3;
    }

    uint64_t v21 = *v20;
LABEL_57:
    goto LABEL_58;
  }

  std::string::append((std::string *)this, "<", 1uLL);
  uint64_t v16 = *(unsigned __int8 *)(a4 + 18);
  int64_t v17 = (swift::Demangle::__runtime::Node *)a4;
  if ((v16 - 1) >= 2)
  {
    if (v16 == 5)
    {
      unint64_t v18 = *(swift::Demangle::__runtime::Node **)a4;
      int64_t v17 = *(swift::Demangle::__runtime::Node **)a4;
      goto LABEL_45;
    }

    int64_t v17 = 0LL;
  }

  switch(v16)
  {
    case 1:
      __int128 v22 = (char *)(a4 + 8);
      if (v17 == (swift::Demangle::__runtime::Node *)(a4 + 8)) {
        goto LABEL_54;
      }
      goto LABEL_52;
    case 2:
      __int128 v22 = (char *)(a4 + 16);
      if (v17 == (swift::Demangle::__runtime::Node *)(a4 + 16)) {
        goto LABEL_54;
      }
      goto LABEL_52;
    case 5:
      unint64_t v18 = *(swift::Demangle::__runtime::Node **)a4;
LABEL_45:
      __int128 v22 = (char *)v18 + 8 * *(unsigned int *)(a4 + 8);
      if (v17 == (swift::Demangle::__runtime::Node *)v22) {
        goto LABEL_54;
      }
      goto LABEL_52;
  }

  __int128 v22 = 0LL;
  if (!v17) {
    goto LABEL_54;
  }
LABEL_52:
  uint64_t v24 = *(swift::Demangle::__runtime::Node **)v17;
  uint64_t v23 = (swift::Demangle::__runtime::Node **)((char *)v17 + 8);
  while (v23 != (swift::Demangle::__runtime::Node **)v22)
  {
    std::string::append((std::string *)this, ", ", 2uLL);
    uint64_t v25 = *v23++;
  }

  uint64_t v12 = *((_DWORD *)this + 3184);
  uint64_t v13 = *((unsigned int *)this + 3185);
  uint64_t v14 = (char *)this[1591];
  if (v12 >= v13)
  {
    int64_t v15 = this[1593];
    uint64_t v16 = (char *)v15[1];
    if (&v14[v13] == v16)
    {
      unint64_t v18 = (unint64_t)&v14[v13 + 1];
      int64_t v17 = v15[2];
      if (v18 <= v17)
      {
        v15[1] = v18;
        LODWORD(v19) = 1;
LABEL_34:
        *((_DWORD *)this + 3185) = v13 + v19;
        goto LABEL_35;
      }
    }

    else
    {
      int64_t v17 = v15[2];
    }

    else {
      int64_t v19 = (2 * v13);
    }
    uint64_t v20 = v19 + v13;
    if (!v16 || (unint64_t)&v16[v20] > v17)
    {
      uint64_t v21 = 2LL * v15[4];
      if (v21 <= v20 + 1) {
        uint64_t v21 = v20 + 1;
      }
      v15[4] = v21;
      __int128 v22 = v21 + 8;
      uint64_t v23 = malloc(v21 + 8);
      uint64_t v24 = (char *)v23 + v22;
      *uint64_t v23 = v15[3];
      uint64_t v16 = (char *)(v23 + 1);
      v15[2] = v24;
      v15[3] = v23;
    }

    v15[1] = &v16[v20];
    if ((_DWORD)v13)
    {
      memcpy(v16, this[1591], v13);
      LODWORD(v13) = *((_DWORD *)this + 3185);
      uint64_t v12 = *((_DWORD *)this + 3184);
    }

    this[1591] = v16;
    uint64_t v14 = v16;
    goto LABEL_34;
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = swift::Demangle::__runtime::CharVector::append(this + 1591, "fMa", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = swift::Demangle::__runtime::CharVector::append(this + 1591, "fMb", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = swift::Demangle::__runtime::CharVector::append(this + 1591, "fMc", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "fMe", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "fMm", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "fMr", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "fMp", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_20:
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "fMq", 3uLL, this[1593]);
  if (*((_BYTE *)a2 + 18) == 5 && *((_DWORD *)a2 + 2) >= 4u) {
  *(_DWORD *)a4 = 0;
  }
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

unint64_t *specialized _dictionaryUpCast<A, B, C, D>(_:)( int64_t a1, const char *a2, uint64_t *a3)
{
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a2, (uint64_t)a3, "key value ", 0LL);
  uint64_t v7 = *(TupleTypeMetadata2 - 1);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v145 = (char *)&v120 - v8;
  uint64_t v127 = type metadata accessor for Optional(0LL, (uint64_t)a3, v9, v10);
  uint64_t v11 = *(void *)(v127 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v127);
  uint64_t v14 = (char *)&v120 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (uint64_t *)((char *)&v120 - v15);
  uint64_t v123 = type metadata accessor for Optional(0LL, (uint64_t)a2, v17, v18);
  uint64_t v122 = *(void *)(v123 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v123);
  uint64_t v21 = (char *)&v120 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v134 = (uint64_t *)((char *)&v120 - v23);
  unint64_t v146 = a3;
  uint64_t v137 = *(a3 - 1);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v136 = (uint64_t *)((char *)&v120 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  unint64_t v147 = (char *)a2;
  uint64_t v26 = *((void *)a2 - 1);
  MEMORY[0x1895F8858](v24);
  int64_t v141 = (uint64_t *)((char *)&v120 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v149 = TupleTypeMetadata2;
  uint64_t v30 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v28, v29);
  MEMORY[0x1895F8858](v30);
  unint64_t v144 = (char *)&v120 - v34;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v35 = (void *)a1;
    }
    else {
      uint64_t v35 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v36 = objc_msgSend(v35, sel_count);
    if (v36) {
      goto LABEL_6;
    }
LABEL_8:
    uint64_t v142 = (unint64_t *)&_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }

  id v36 = *(id *)(a1 + 16);
  if (!v36) {
    goto LABEL_8;
  }
LABEL_6:
  uint64_t v142 = (unint64_t *)specialized static _DictionaryStorage.allocate(capacity:)((uint64_t)v36);
LABEL_9:
  uint64_t v126 = v11;
  uint64_t v125 = v14;
  uint64_t v124 = v16;
  unint64_t v121 = v21;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v37 = a1;
    }
    else {
      uint64_t v37 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v38 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v39 = (unint64_t)swift_allocObject(v38, 0xE8uLL, 7uLL);
    int64_t v132 = 0LL;
    uint64_t v40 = 0LL;
    unint64_t v41 = 0LL;
    *(void *)(v39 + 208) = v37;
    *(void *)(v39 + 216) = 0LL;
    *(_OWORD *)(v39 + 16) = 0u;
    *(_OWORD *)(v39 + 32) = 0u;
    *(_OWORD *)(v39 + 48) = 0u;
    *(_OWORD *)(v39 + 64) = 0u;
    *(_OWORD *)(v39 + 80) = 0u;
    *(_OWORD *)(v39 + 96) = 0u;
    *(_OWORD *)(v39 + 112) = 0u;
    *(_OWORD *)(v39 + 128) = 0u;
    *(_OWORD *)(v39 + 144) = 0u;
    *(_OWORD *)(v39 + 160) = 0u;
    *(_OWORD *)(v39 + 176) = 0u;
    *(_OWORD *)(v39 + 192) = 0u;
    *(void *)(v39 + 224) = 0LL;
    unint64_t v148 = v39 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v42 = -1LL << *(_BYTE *)(a1 + 32);
    uint64_t v40 = ~v42;
    uint64_t v43 = *(void *)(a1 + 64);
    int64_t v132 = a1 + 64;
    uint64_t v44 = -v42;
    if (v44 < 64) {
      uint64_t v45 = ~(-1LL << v44);
    }
    else {
      uint64_t v45 = -1LL;
    }
    unint64_t v41 = v45 & v43;
    unint64_t v148 = a1;
  }

  uint64_t v130 = (v148 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v135 = v148 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v129 = (v148 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v128 = v40;
  int64_t v131 = (unint64_t)(v40 + 64) >> 6;
  unint64_t v140 = &v155;
  int64_t v139 = &v158;
  swift_retain(v142, v31, v32, v33);
  swift_bridgeObjectRetain(a1, v46, v47, v48);
  int64_t v138 = 0LL;
  unint64_t v133 = (swift *)&unk_189B8D230;
  uint64_t v52 = v137;
  int64_t v53 = v136;
  uint64_t v143 = v26;
  uint64_t v54 = v145;
  while (1)
  {
    if ((v148 & 0x8000000000000000LL) == 0)
    {
      size_t v85 = v141;
      if (v41)
      {
        uint64_t v55 = v54;
        uint64_t v56 = v7;
        unint64_t v145 = (char *)((v41 - 1) & v41);
        unint64_t v57 = __clz(__rbit64(v41)) | (v138 << 6);
      }

      else
      {
        int64_t v86 = v138 + 1;
        uint64_t v87 = v144;
        if (__OFADD__(v138, 1LL))
        {
          __break(1u);
LABEL_59:
          unint64_t v119 = 773LL;
LABEL_61:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v119,  0);
        }

        if (v86 >= v131) {
          goto LABEL_54;
        }
        unint64_t v88 = *(void *)(v132 + 8 * v86);
        if (!v88)
        {
          int64_t v89 = v138 + 2;
          if (v138 + 2 >= v131) {
            goto LABEL_54;
          }
          unint64_t v88 = *(void *)(v132 + 8 * v89);
          if (!v88)
          {
            while (1)
            {
              int64_t v86 = v89 + 1;
              if (__OFADD__(v89, 1LL)) {
                break;
              }
              if (v86 >= v131) {
                goto LABEL_54;
              }
              unint64_t v88 = *(void *)(v132 + 8 * v86);
              ++v89;
              if (v88) {
                goto LABEL_33;
              }
            }

            __break(1u);
LABEL_56:
            __break(1u);
LABEL_57:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
          }

          int64_t v86 = v138 + 2;
        }

unint64_t specialized _dictionaryUpCast<A, B, C, D>(_:)( unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    unint64_t v5 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v4);
  }
  else {
    unint64_t v5 = &_swiftEmptyDictionarySingleton;
  }
  unint64_t v48 = a1 + 64;
  uint64_t v6 = -1LL;
  uint64_t v7 = -1LL << *(_BYTE *)(a1 + 32);
  uint64_t v46 = v5;
  if (-v7 < 64) {
    uint64_t v6 = ~(-1LL << -(char)v7);
  }
  unint64_t v8 = v6 & *(void *)(a1 + 64);
  uint64_t v44 = v5 + 8;
  int64_t v45 = (unint64_t)(63 - v7) >> 6;
  unint64_t result = swift_bridgeObjectRetain(a1, a2, a3, a4);
  for (int64_t i = 0LL; ; int64_t i = v50)
  {
    if (v8)
    {
      uint64_t v49 = (v8 - 1) & v8;
      int64_t v50 = i;
      unint64_t v17 = __clz(__rbit64(v8)) | (i << 6);
    }

    else
    {
      int64_t v18 = i + 1;
      if (__OFADD__(i, 1LL)) {
        goto LABEL_34;
      }
      if (v18 >= v45)
      {
LABEL_30:
        uint64_t v43 = swift_retain((unint64_t *)a1, v10, v11, v12);
        outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v43);
LABEL_31:
        swift_release(a1);
        return (unint64_t)v46;
      }

      unint64_t v19 = *(void *)(v48 + 8 * v18);
      int64_t v20 = i + 1;
      if (!v19)
      {
        int64_t v20 = i + 2;
        if (i + 2 >= v45) {
          goto LABEL_30;
        }
        unint64_t v19 = *(void *)(v48 + 8 * v20);
        if (!v19)
        {
          int64_t v20 = i + 3;
          if (i + 3 >= v45) {
            goto LABEL_30;
          }
          unint64_t v19 = *(void *)(v48 + 8 * v20);
          if (!v19)
          {
            uint64_t v21 = i + 4;
            if (i + 4 >= v45) {
              goto LABEL_30;
            }
            unint64_t v19 = *(void *)(v48 + 8 * v21);
            if (!v19)
            {
              while (1)
              {
                int64_t v20 = v21 + 1;
                if (__OFADD__(v21, 1LL)) {
                  goto LABEL_35;
                }
                if (v20 >= v45) {
                  goto LABEL_30;
                }
                unint64_t v19 = *(void *)(v48 + 8 * v20);
                ++v21;
                if (v19) {
                  goto LABEL_24;
                }
              }
            }

            int64_t v20 = i + 4;
          }
        }
      }

{
  uint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  unint64_t i;
  int64_t v18;
  unint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t *v34;
  int64_t v35;
  unint64_t *v36;
  unint64_t v38;
  uint64_t v39;
  int64_t v40;
  _OWORD v41[2];
  uint64_t v42;
  uint64_t v43[2];
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  _OWORD v47[2];
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  _OWORD v51[3];
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    unint64_t v5 = (unint64_t *)specialized static _DictionaryStorage.allocate(capacity:)(v4);
  }
  else {
    unint64_t v5 = (unint64_t *)&_swiftEmptyDictionarySingleton;
  }
  char v38 = a1 + 64;
  uint64_t v6 = -1LL;
  uint64_t v7 = -1LL << *(_BYTE *)(a1 + 32);
  if (-v7 < 64) {
    uint64_t v6 = ~(-1LL << -(char)v7);
  }
  unint64_t v8 = v6 & *(void *)(a1 + 64);
  unint64_t v35 = (unint64_t)(63 - v7) >> 6;
  swift_retain(v5, a2, a3, a4);
  unint64_t result = swift_bridgeObjectRetain(a1, v9, v10, v11);
  uint64_t v16 = 0LL;
  unint64_t v36 = v5;
  if (!v8) {
    goto LABEL_8;
  }
LABEL_7:
  unint64_t v39 = (v8 - 1) & v8;
  uint64_t v40 = v16;
  for (int64_t i = __clz(__rbit64(v8)) | (v16 << 6); ; int64_t i = __clz(__rbit64(v19)) + (v20 << 6))
  {
    uint64_t v22 = (uint64_t *)(*(void *)(a1 + 48) + 16 * i);
    unint64_t v24 = *v22;
    unint64_t v23 = v22[1];
    outlined init with copy of AnyHashable(*(void *)(a1 + 56) + 40 * i, (uint64_t)&v48);
    __int128 v25 = v48;
    __int128 v26 = v49;
    uint64_t v27 = v50;
    swift_retain((unint64_t *)a1, v28, v29, v30);
    swift_bridgeObjectRetain(v23, v31, v32, v33);
    outlined consume of [A : B].Iterator._Variant<A, B>(a1);
    unint64_t v5 = v36;
    if (!v23) {
      goto LABEL_26;
    }
    v43[0] = v24;
    v43[1] = v23;
    swift_dynamicCast( (char *)&v44,  v43,  (swift *)&type metadata for String,  (const char *)&type metadata for AnyHashable,  7uLL);
    v41[0] = v25;
    v41[1] = v26;
    uint64_t v42 = v27;
    swift_dynamicCast((char *)v47, (uint64_t *)v41, (swift *)&type metadata for AnyHashable, byte_189B8D218, 7uLL);
    unint64_t v48 = v44;
    uint64_t v49 = v45;
    int64_t v50 = v46;
    outlined init with take of Any(v47, v51);
    uint64_t v44 = v48;
    int64_t v45 = v49;
    uint64_t v46 = v50;
    outlined init with take of Any(v51, v41);
    outlined init with take of Any(v41, &v48);
    unint64_t result = (unint64_t)specialized _NativeDictionary._unsafeInsertNew(key:value:)(&v44, &v48, v36);
    unint64_t v8 = v39;
    uint64_t v16 = v40;
    if (v39) {
      goto LABEL_7;
    }
LABEL_8:
    int64_t v18 = v16 + 1;
    if (__OFADD__(v16, 1LL))
    {
      __break(1u);
      goto LABEL_28;
    }

    if (v18 >= v35) {
      goto LABEL_25;
    }
    unint64_t v19 = *(void *)(v38 + 8 * v18);
    int64_t v20 = v16 + 1;
    if (!v19)
    {
      int64_t v20 = v16 + 2;
      if (v16 + 2 >= v35) {
        goto LABEL_25;
      }
      unint64_t v19 = *(void *)(v38 + 8 * v20);
      if (!v19)
      {
        int64_t v20 = v16 + 3;
        if (v16 + 3 >= v35) {
          goto LABEL_25;
        }
        unint64_t v19 = *(void *)(v38 + 8 * v20);
        if (!v19) {
          break;
        }
      }
    }

unint64_t *_dictionaryUpCast<A, B, C, D>(_:)( int64_t a1, uint64_t *a2, uint64_t *a3, ValueMetadata *a4, const char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v263 = a7;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a4, (uint64_t)a5, "key value ", 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  v259 = (char *)&v231 - v12;
  v258 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a4, (uint64_t)a5, 0LL, 0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v258);
  v257 = (char *)&v231 - v14;
  uint64_t v269 = *((void *)a5 - 1);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  v252 = (char *)&v231 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  v251 = (char *)&v231 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  v246 = (char *)&v231 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  v245 = (char *)&v231 - v22;
  Description = a4[-1].Description;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  v250 = (char *)&v231 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  v249 = (swift *)((char *)&v231 - v26);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  v244 = (char *)&v231 - v28;
  MEMORY[0x1895F8858](v27);
  v243 = (swift *)((char *)&v231 - v29);
  uint64_t v30 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a2, (uint64_t)a3, "key value ", 0LL);
  uint64_t v272 = *(v30 - 1);
  uint64_t v31 = MEMORY[0x1895F8858](v30);
  v248 = (char *)&v231 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v31);
  v242 = (char *)&v231 - v33;
  uint64_t v233 = type metadata accessor for Optional(0LL, (uint64_t)a3, v34, v35);
  uint64_t v36 = *(void *)(v233 - 8);
  uint64_t v37 = MEMORY[0x1895F8858](v233);
  unint64_t v39 = (char *)&v231 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v40 = MEMORY[0x1895F8858](v37);
  __int128 v239 = (char *)&v231 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  uint64_t v237 = (char *)&v231 - v43;
  MEMORY[0x1895F8858](v42);
  int64_t v236 = (char *)&v231 - v44;
  uint64_t v232 = type metadata accessor for Optional(0LL, (uint64_t)a2, v45, v46);
  uint64_t v234 = *(void *)(v232 - 8);
  uint64_t v47 = MEMORY[0x1895F8858](v232);
  v254 = (char *)&v231 - ((v48 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  unint64_t v241 = (char *)&v231 - v50;
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  unint64_t v53 = (char *)&v231 - v52;
  uint64_t v54 = MEMORY[0x1895F8858](v51);
  v238 = (char *)&v231 - v55;
  uint64_t v261 = *(a3 - 1);
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  v270 = a2;
  v271 = (char *)&v231 - ((v57 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v58 = *(a2 - 1);
  int64_t v59 = a1;
  uint64_t v265 = v58;
  MEMORY[0x1895F8858](v56);
  v266 = (uint64_t *)((char *)&v231 - ((v60 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v61 = v30;
  uint64_t v64 = type metadata accessor for Optional(0LL, (uint64_t)v30, v62, v63);
  uint64_t v65 = MEMORY[0x1895F8858](v64);
  v253 = (char *)&v231 - ((v66 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v65);
  v247 = (char *)&v231 - v70;
  unint64_t v71 = a1 & 0xC000000000000001LL;
  if (v71)
  {
    if (v59 < 0) {
      uint64_t v72 = (void *)v59;
    }
    else {
      uint64_t v72 = (void *)(v59 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v73 = objc_msgSend(v72, sel_count);
  }

  else
  {
    id v73 = *(id *)(v59 + 16);
  }

  uint64_t v240 = v36;
  if (v73)
  {
    type metadata accessor for _DictionaryStorage(0LL, (uint64_t)a4, (uint64_t)a5, v263);
    v264 = (unint64_t *)static _DictionaryStorage.allocate(capacity:)((uint64_t)v73);
  }

  else
  {
    v264 = (unint64_t *)&_swiftEmptyDictionarySingleton;
  }

  v267 = a3;
  v262 = v61;
  v256 = a5;
  if (a4 == &type metadata for String)
  {
    v250 = v53;
    if (v71)
    {
      if (v59 < 0) {
        uint64_t v79 = v59;
      }
      else {
        uint64_t v79 = v59 & 0xFFFFFFFFFFFFFF8LL;
      }
      uint64_t v80 = type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v81 = (unint64_t)swift_allocObject(v80, 0xE8uLL, 7uLL);
      v248 = 0LL;
      uint64_t v82 = 0LL;
      unint64_t v83 = 0LL;
      *(void *)(v81 + 208) = v79;
      *(void *)(v81 + 216) = 0LL;
      *(_OWORD *)(v81 + 16) = 0u;
      *(_OWORD *)(v81 + 32) = 0u;
      *(_OWORD *)(v81 + 48) = 0u;
      *(_OWORD *)(v81 + 64) = 0u;
      *(_OWORD *)(v81 + 80) = 0u;
      *(_OWORD *)(v81 + 96) = 0u;
      *(_OWORD *)(v81 + 112) = 0u;
      *(_OWORD *)(v81 + 128) = 0u;
      *(_OWORD *)(v81 + 144) = 0u;
      *(_OWORD *)(v81 + 160) = 0u;
      *(_OWORD *)(v81 + 176) = 0u;
      *(_OWORD *)(v81 + 192) = 0u;
      *(void *)(v81 + 224) = 0LL;
      unint64_t v84 = v81 | 0x8000000000000000LL;
    }

    else
    {
      uint64_t v150 = -1LL << *(_BYTE *)(v59 + 32);
      uint64_t v82 = ~v150;
      uint64_t v151 = *(void *)(v59 + 64);
      v248 = (char *)(v59 + 64);
      uint64_t v152 = -v150;
      if (v152 < 64) {
        uint64_t v153 = ~(-1LL << v152);
      }
      else {
        uint64_t v153 = -1LL;
      }
      unint64_t v83 = v153 & v151;
      unint64_t v84 = v59;
    }

    uint64_t v154 = v264;
    char v155 = v271;
    unint64_t v156 = v59;
    uint64_t v157 = v266;
    char v158 = v61;
    __int128 v239 = (char *)((v84 & 0x7FFFFFFFFFFFFFFFLL) + 16);
    v251 = (char *)(v84 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v235 = (v84 & 0x7FFFFFFFFFFFFFFFLL) + 80;
    unint64_t v231 = (char *)v82;
    unint64_t v241 = (char *)((unint64_t)(v82 + 64) >> 6);
    v252 = (char *)(v264 + 8);
    swift_bridgeObjectRetain(v156, v67, v68, v69);
    v253 = 0LL;
    v249 = (swift *)&unk_189B8D230;
    uint64_t v162 = v272;
    v254 = (char *)v84;
    while (1)
    {
      if ((v84 & 0x8000000000000000LL) != 0)
      {
        Swift::String::Index v166 = v251;
        uint64_t v167 = *((void *)v251 + 27);
        if (v167 < 0) {
          goto LABEL_110;
        }
        unint64_t v255 = v83;
        unint64_t v168 = (void *)*((void *)v251 + 26);
        unint64_t v169 = v270;
        unint64_t v170 = v250;
        unint64_t v171 = (uint64_t *)v238;
        if (v167 == *((void *)v251 + 28))
        {
          id v172 = objc_msgSend(*((id *)v251 + 26), sel_countByEnumeratingWithState_objects_count_, v239, v235, 16);
          v166[28] = v172;
          if (!v172)
          {
            v166[27] = -1LL;
            goto LABEL_110;
          }

          uint64_t v167 = 0LL;
          v166[27] = 0LL;
        }

        uint64_t v173 = v166[3];
        if (!v173) {
          goto LABEL_121;
        }
        unint64_t v174 = (void **)(v173 + 8 * v167);
        if ((v174 & 7) != 0) {
LABEL_112:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
        char v175 = *v174;
        v166[27] = v167 + 1;
        swift_unknownObjectRetain(v175, v159, v160, v161);
        unint64_t v176 = (swift *)objc_msgSend(v168, sel_objectForKey_, v175);
        if (!v176)
        {
LABEL_122:
          unint64_t v230 = 784LL;
          goto LABEL_123;
        }

        unint64_t v177 = v176;
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v169, v169);
        uint64_t v179 = v265;
        if (isClassOrObjCExistentialType)
        {
          v273 = (swift *)v175;
          Swift::Int v180 = v247;
          swift_dynamicCast(v247, (uint64_t *)&v273, v249, (const char *)v169, 7uLL);
        }

        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v265 + 56))(v171, 1LL, 1LL, v169);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v175, (uint64_t)v169, v171);
          swift_unknownObjectRelease(v175);
          uint64_t v222 = v234;
          uint64_t v223 = v179;
          uint64_t v224 = v232;
          (*(void (**)(char *, uint64_t *, uint64_t))(v234 + 16))(v170, v171, v232);
          (*(void (**)(uint64_t *, uint64_t))(v222 + 8))(v171, v224);
          Swift::Int v180 = v247;
          (*(void (**)(char *, char *, uint64_t *))(v223 + 32))(v247, v170, v169);
        }

        uint64_t v181 = &v180[*((int *)v158 + 12)];
        unint64_t v182 = (const char *)v267;
        BOOL v183 = _swift_isClassOrObjCExistentialType((uint64_t)v267, v267);
        unint64_t v184 = v237;
        int64_t v185 = (uint64_t *)v236;
        if (v183)
        {
          v273 = v177;
          swift_dynamicCast(v181, (uint64_t *)&v273, (swift *)&unk_189B8D230, v182, 7uLL);
        }

        else
        {
          uint64_t v225 = v261;
          (*(void (**)(char *, uint64_t, uint64_t, const char *))(v261 + 56))(v236, 1LL, 1LL, v182);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v177, (uint64_t)v182, v185);
          swift_unknownObjectRelease(v177);
          uint64_t v226 = v240;
          uint64_t v227 = v233;
          (*(void (**)(char *, uint64_t *, uint64_t))(v240 + 16))(v184, v185, v233);
          if ((*(unsigned int (**)(char *, uint64_t, const char *))(v225 + 48))(v184, 1LL, v182) == 1) {
LABEL_124:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
          (*(void (**)(uint64_t *, uint64_t))(v226 + 8))(v185, v227);
          (*(void (**)(char *, char *, const char *))(v225 + 32))(v181, v184, v182);
        }

        uint64_t v162 = v272;
        int64_t v186 = v247;
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v272 + 56))(v247, 0LL, 1LL, v158);
        uint64_t v157 = v266;
        char v187 = (swift *)v267;
        uint64_t v188 = v261;
        BOOL v189 = (swift *)v270;
        uint64_t v190 = v265;
      }

      else
      {
        if (v83)
        {
          unint64_t v163 = __clz(__rbit64(v83));
          uint64_t v164 = (v83 - 1) & v83;
          unint64_t v165 = v163 | ((void)v253 << 6);
        }

        else
        {
          uint64_t v191 = v253 + 1;
          if (__OFADD__(v253, 1LL)) {
            goto LABEL_119;
          }
          unint64_t v192 = *(void *)&v248[8 * (void)v191];
          unint64_t v193 = v253 + 1;
          if (!v192)
          {
            unint64_t v193 = v253 + 2;
            unint64_t v192 = *(void *)&v248[8 * (void)v193];
            if (!v192)
            {
              unint64_t v194 = v253 + 3;
              unint64_t v192 = *(void *)&v248[8 * (void)v194];
              if (!v192)
              {
                while (1)
                {
                  unint64_t v193 = v194 + 1;
                  if (__OFADD__(v194, 1LL)) {
                    goto LABEL_120;
                  }
                  unint64_t v192 = *(void *)&v248[8 * (void)v193];
                  ++v194;
                  if (v192) {
                    goto LABEL_95;
                  }
                }

LABEL_95:
          uint64_t v164 = (v192 - 1) & v192;
          unint64_t v165 = __clz(__rbit64(v192)) + ((void)v193 << 6);
          v253 = v193;
        }

        unint64_t v255 = v164;
        uint64_t v190 = v265;
        BOOL v189 = (swift *)v270;
        (*(void (**)(uint64_t *, unint64_t, uint64_t *))(v265 + 16))( v157,  *(void *)(v84 + 48) + *(void *)(v265 + 72) * v165,  v270);
        uint64_t v195 = *(void *)(v84 + 56);
        uint64_t v188 = v261;
        Swift::String::Index v196 = v155;
        Swift::String::Index v197 = v155;
        char v187 = (swift *)v267;
        (*(void (**)(char *, unint64_t, uint64_t *))(v261 + 16))( v196,  v195 + *(void *)(v261 + 72) * v165,  v267);
        int64_t v186 = v247;
        Swift::String::Index v198 = &v247[*((int *)v158 + 12)];
        (*(void (**)(char *, uint64_t *, swift *))(v190 + 32))(v247, v157, v189);
        (*(void (**)(char *, char *, swift *))(v188 + 32))(v198, v197, v187);
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v162 + 56))(v186, 0LL, 1LL, v158);
      }

      Swift::String::Index v199 = v242;
      (*(void (**)(char *, char *, unint64_t *))(v162 + 32))(v242, v186, v158);
      unint64_t v200 = &v199[*((int *)v158 + 12)];
      unint64_t v201 = v259;
      unint64_t v202 = &v259[*((int *)TupleTypeMetadata2 + 12)];
      (*(void (**)(uint64_t *, char *, swift *))(v190 + 32))(v157, v199, v189);
      swift_dynamicCast(v201, v157, v189, (const char *)&type metadata for String, 7uLL);
      unint64_t v203 = (uint64_t *)v271;
      (*(void (**)(char *, char *, swift *))(v188 + 32))(v271, v200, v187);
      unint64_t v204 = v203;
      unint64_t v205 = v256;
      swift_dynamicCast(v202, v204, v187, v256, 7uLL);
      unint64_t v206 = v257;
      char v207 = &v257[*((int *)v258 + 12)];
      unint64_t v208 = Description;
      size_t v209 = (void (*)(char *, char *, ValueMetadata *))Description[4];
      v209(v257, v201, &type metadata for String);
      uint64_t v210 = v269;
      Swift::String::Index v211 = *(void (**)(char *, char *, const char *))(v269 + 32);
      v211(v207, v202, v205);
      Swift::String::Index v212 = v243;
      v209((char *)v243, v206, &type metadata for String);
      Swift::String::Index v213 = v245;
      v211(v245, v207, v205);
      uint64_t v214 = (uint64_t)v244;
      v209(v244, (char *)v212, &type metadata for String);
      Swift::Int v215 = v246;
      v211(v246, v213, v205);
      uint64_t v154 = v264;
      unint64_t v216 = __RawDictionaryStorage.find<A>(_:)(v214, (uint64_t)&type metadata for String, v263);
      unint64_t v217 = v216;
      if ((v218 & 1) != 0)
      {
        ((void (*)(unint64_t, uint64_t, ValueMetadata *))v208[5])( v154[6] + v208[9] * v216,  v214,  &type metadata for String);
        (*(void (**)(unint64_t, char *, const char *))(v210 + 40))( v154[7] + *(void *)(v210 + 72) * v217,  v215,  v205);
      }

      else
      {
        if (v154[2] >= v154[3]) {
          goto LABEL_114;
        }
        *(void *)&v252[(v216 >> 3) & 0x1FFFFFFFFFFFFFF8LL] |= 1LL << v216;
        v209((char *)(v154[6] + Description[9] * v216), (char *)v214, &type metadata for String);
        v211((char *)(v154[7] + *(void *)(v269 + 72) * v217), v215, v205);
        unint64_t v219 = v154[2];
        BOOL v220 = __OFADD__(v219, 1LL);
        unint64_t v221 = v219 + 1;
        if (v220)
        {
          __break(1u);
LABEL_116:
          __break(1u);
LABEL_117:
          __break(1u);
          goto LABEL_118;
        }

        v154[2] = v221;
      }

      char v158 = v262;
      char v155 = v271;
      uint64_t v162 = v272;
      uint64_t v157 = v266;
      unint64_t v84 = (unint64_t)v254;
      unint64_t v83 = v255;
    }
  }

  unint64_t v231 = v39;
  if (v71)
  {
    if (v59 < 0) {
      uint64_t v74 = v59;
    }
    else {
      uint64_t v74 = v59 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v75 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v76 = (unint64_t)swift_allocObject(v75, 0xE8uLL, 7uLL);
    v242 = 0LL;
    uint64_t v77 = 0LL;
    unint64_t v255 = 0LL;
    *(void *)(v76 + 208) = v74;
    *(void *)(v76 + 216) = 0LL;
    *(_OWORD *)(v76 + 16) = 0u;
    *(_OWORD *)(v76 + 32) = 0u;
    *(_OWORD *)(v76 + 48) = 0u;
    *(_OWORD *)(v76 + 64) = 0u;
    *(_OWORD *)(v76 + 80) = 0u;
    *(_OWORD *)(v76 + 96) = 0u;
    *(_OWORD *)(v76 + 112) = 0u;
    *(_OWORD *)(v76 + 128) = 0u;
    *(_OWORD *)(v76 + 144) = 0u;
    *(_OWORD *)(v76 + 160) = 0u;
    *(_OWORD *)(v76 + 176) = 0u;
    *(_OWORD *)(v76 + 192) = 0u;
    *(void *)(v76 + 224) = 0LL;
    unint64_t v78 = v59;
    int64_t v59 = v76 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v85 = -1LL << *(_BYTE *)(v59 + 32);
    uint64_t v77 = ~v85;
    uint64_t v86 = *(void *)(v59 + 64);
    v242 = (char *)(v59 + 64);
    uint64_t v87 = -v85;
    if (v87 < 64) {
      uint64_t v88 = ~(-1LL << v87);
    }
    else {
      uint64_t v88 = -1LL;
    }
    unint64_t v255 = v88 & v86;
    unint64_t v78 = v59;
  }

  int64_t v89 = v254;
  uint64_t v237 = (char *)((v59 & 0x7FFFFFFFFFFFFFFFLL) + 16);
  v244 = (char *)(v59 & 0x7FFFFFFFFFFFFFFFLL);
  int64_t v236 = (char *)((v59 & 0x7FFFFFFFFFFFFFFFLL) + 80);
  uint64_t v235 = v77;
  v238 = (char *)((unint64_t)(v77 + 64) >> 6);
  swift_bridgeObjectRetain(v78, v67, v68, v69);
  swift_retain(v264, v90, v91, v92);
  v245 = 0LL;
  v243 = (swift *)&unk_189B8D230;
  v247 = (char *)a4;
  v246 = (char *)v59;
  while ((v59 & 0x8000000000000000LL) == 0)
  {
    uint64_t v120 = (swift *)v267;
    uint64_t v121 = v261;
    uint64_t v122 = v262;
    uint64_t v123 = v272;
    uint64_t v124 = v253;
    if (v255)
    {
      unint64_t v96 = __clz(__rbit64(v255));
      v255 &= v255 - 1;
      unint64_t v97 = v96 | ((void)v245 << 6);
    }

    else
    {
      uint64_t v125 = v245 + 1;
      if (__OFADD__(v245, 1LL)) {
        goto LABEL_116;
      }
      unint64_t v126 = *(void *)&v242[8 * (void)v125];
      uint64_t v127 = v245 + 1;
      if (!v126)
      {
        uint64_t v127 = v245 + 2;
        unint64_t v126 = *(void *)&v242[8 * (void)v127];
        if (!v126)
        {
          uint64_t v128 = v245 + 3;
          unint64_t v126 = *(void *)&v242[8 * (void)v128];
          if (!v126)
          {
            while (1)
            {
              uint64_t v127 = v128 + 1;
              if (__OFADD__(v128, 1LL)) {
                break;
              }
              unint64_t v126 = *(void *)&v242[8 * (void)v127];
              ++v128;
              if (v126) {
                goto LABEL_55;
              }
            }

    v20.partialValue.low = 0LL;
    return v20.partialValue.low;
  }

  uint64_t v26 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, a2);
  uint64_t v30 = specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
  if (!v31)
  {
    v20.partialValue.low = 0LL;
    return v20.partialValue.low;
  }

  uint64_t v32 = (unsigned __int8 *)v30;
  if (low <= 10) {
    uint64_t v33 = 97;
  }
  else {
    uint64_t v33 = low + 87;
  }
  if (low <= 10) {
    uint64_t v34 = 65;
  }
  else {
    uint64_t v34 = low + 55;
  }
  if (low <= 10) {
    uint64_t v35 = low + 48;
  }
  else {
    uint64_t v35 = 58;
  }
  if (!v30) {
    goto LABEL_95;
  }
  uint64_t v36 = v31;
  do
  {
    uint64_t v47 = *v32;
    if (v47 < 0x30 || v47 >= v35)
    {
      if (v47 < 0x41 || v47 >= v34)
      {
        v20.partialValue.low = 0LL;
        if (v47 < 0x61 || v47 >= v33) {
          return v20.partialValue.low;
        }
        uint64_t v48 = -87;
      }

      else
      {
        uint64_t v48 = -55;
      }
    }

    else
    {
      uint64_t v48 = -48;
    }

    uint64_t v49 = v47 + v48;
    v50.low = low;
    v50.high = low >> 63;
    uint64_t v20 = _Int128.multipliedReportingOverflow(by:)(v50);
    uint64_t v51 = *(_DWORD *)&v20.overflow;
    *(void *)&v20.overflow = v20.partialValue.low + v49;
    uint64_t v52 = __CFADD__(v20.partialValue.low, v49);
    if (v20.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
    {
      if (((v52 | v51) & 1) != 0) {
        goto LABEL_97;
      }
    }

    else if (v52)
    {
      if ((v51 & 1) != 0)
      {
LABEL_97:
        v20.partialValue.low = 0LL;
        return v20.partialValue.low;
      }
    }

    else if ((v51 & 1) != 0)
    {
      goto LABEL_97;
    }

    ++v32;
    --v36;
  }

  while (v36);
LABEL_98:
  v20.partialValue.low = *(void *)&v20.overflow;
  return v20.partialValue.low;
}

        uint64_t v74 = _StringGuts.nativeUnusedCapacity.getter(v43, v7);
        id v1 = (v75 & 1) == 0 && v74 >= v70;
        if ((v43 & ~v7 & 0x2000000000000000LL) == 0
          || !swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
        {
          if ((v1 & 1) == 0) {
            goto LABEL_106;
          }
LABEL_112:
          _StringGuts.grow(_:)(v71);
          goto LABEL_113;
        }

        if ((v1 & 1) != 0)
        {
LABEL_113:
          swift_bridgeObjectRelease_n(object, 4LL);
          if ((object & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(object);
            _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, object, 0LL, v175);
            swift_bridgeObjectRelease_n(object, 2LL);
            a1 = 0LL;
          }

          else if (v66)
          {
            swift_bridgeObjectRelease_n(object, 2LL);
            *(void *)&v176[0] = countAndFlagsBits;
            *((void *)&v176[0] + 1) = object & 0xFFFFFFFFFFFFFFLL;
            unint64_t v81 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(object) & 0xF,  (uint64_t)v176,  HIBYTE(object) & 0xF);
            _StringGuts.appendInPlace(_:isASCII:)(v81, v82, (object & 0x4000000000000000LL) != 0);
            a1 = 0LL;
            swift_bridgeObjectRelease(object);
          }

          else
          {
            if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(object);
              unint64_t v99 = (id)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
              Swift::String::Index v100 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              unint64_t v99 = _StringObject.sharedUTF8.getter(countAndFlagsBits, object);
              Swift::String::Index v100 = v168;
              swift_bridgeObjectRelease(object);
              if (v100 < (uint64_t)a1) {
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
              }
            }

            unint64_t v101 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  countAndFlagsBits & 0xFFFFFFFFFFFFLL,  (uint64_t)v99,  v100);
            _StringGuts.appendInPlace(_:isASCII:)(v101, v102, countAndFlagsBits < 0);
            a1 = 0LL;
            swift_bridgeObjectRelease_n(object, 2LL);
          }

          goto LABEL_160;
        }

                  __break(1u);
                  goto LABEL_96;
                }

                uint64_t v35 = v48;
              }
            }
          }

    uint64_t v49 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    uint64_t v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    uint64_t v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    uint64_t v44 = v54;
    unint64_t v8 = v62;
    if (v46) {
      continue;
    }
    break;
  }

  uint64_t v2 = v75;
  swift_release(v74);
  return v2;
}

    uint64_t v52 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
    swift_willThrow();
    swift_errorRelease(v52);
    unint64_t v53 = specialized Collection.subscript.getter(v66, (uint64_t)&v11[v47], v58 - v47);
    uint64_t v45 = findInvalidRange #1 (_:) in validateUTF8(_:)(v53, v54, v55, v56);
    uint64_t v47 = v57;
    uint64_t v11 = v65;
    if (v49) {
      continue;
    }
    break;
  }

  unint64_t v5 = v78;
  swift_release(v77);
  return v5;
}

    uint64_t v49 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    uint64_t v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    uint64_t v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    uint64_t v44 = v54;
    unint64_t v8 = v62;
    if (v46) {
      continue;
    }
    break;
  }

  uint64_t v2 = v75;
  swift_release(v74);
  return v2;
}

    uint64_t v54 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
    swift_willThrow();
    swift_errorRelease(v54);
    uint64_t v55 = specialized Collection.subscript.getter(v68, (uint64_t)&v13[v49], v60 - v49);
    uint64_t v47 = findInvalidRange #1 (_:) in validateUTF8(_:)(v55, v56, v57, v58);
    uint64_t v49 = v59;
    uint64_t v13 = v67;
    if (v51) {
      continue;
    }
    break;
  }

  uint64_t v6 = v81;
  swift_release(v80);
  return v6;
}

    uint64_t v49 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    uint64_t v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    uint64_t v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    uint64_t v44 = v54;
    unint64_t v8 = v62;
    if (v46) {
      continue;
    }
    break;
  }

  uint64_t v2 = v75;
  swift_release(v74);
  return v2;
}

            ++v37;
          }

          uint64_t v36 = v168 + 16;
          if (v168 + 16 == spida) {
            goto LABEL_129;
          }
        }
      }
    }

    do
LABEL_129:
      uint64_t v54 = __ldxr(&qword_18C486ED0);
    while (__stlxr(v54 - 1, &qword_18C486ED0));
    unint64_t v174 = &v175;
    uint64_t v9 = v161;
    if (v161)
    {
      uint64_t v55 = v175;
      uint64_t v56 = (char *)v175;
      if ((_DWORD)v176)
      {
        uint64_t v57 = 8LL * v176;
        uint64_t v56 = (char *)v175;
        while (*(void *)v56 != v161)
        {
          v56 += 8;
          v57 -= 8LL;
          if (!v57)
          {
            uint64_t v56 = (char *)v175 + 8 * v176;
            break;
          }
        }
      }

      if (v176 == (v56 - (_BYTE *)v175) >> 3)
      {
        uint64_t v58 = swift_getTypeName(v31, 1LL);
        uint64_t v60 = v59;
        uint64_t v61 = *(int *)(v32 + 8) + v32 + 8;
        validateDyldResults(ConformanceState &,swift::TargetMetadata<swift::InProcess> const*,swift::TargetProtocolDescriptor<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*,swift::TargetProtocolConformanceDescriptor<swift::InProcess> const*,BOOL)::$_0::operator()( (unint64_t ***)&v174,  (std::string *)buf);
        if (buf[23] >= 0) {
          uint64_t v64 = buf;
        }
        else {
          uint64_t v64 = *(_BYTE **)buf;
        }
        swift::fatalError( 0LL,  "Checking conformance of %.*s %p to %s %p - dyld cached conformance descriptor %p not found in conformance records: (%s)\n",  v62,  v63,  v60,  v58,  v31,  v61,  v32,  v161,  v64);
      }
    }

    else
    {
      if ((_DWORD)v176)
      {
        uint64_t v152 = swift_getTypeName(v31, 1LL);
        uint64_t v154 = v153;
        char v155 = *(int *)(v32 + 8) + v32 + 8;
        validateDyldResults(ConformanceState &,swift::TargetMetadata<swift::InProcess> const*,swift::TargetProtocolDescriptor<swift::InProcess> const*,swift::TargetWitnessTable<swift::InProcess> const*,swift::TargetProtocolConformanceDescriptor<swift::InProcess> const*,BOOL)::$_0::operator()( (unint64_t ***)&v174,  (std::string *)buf);
        if (buf[23] >= 0) {
          char v158 = buf;
        }
        else {
          char v158 = *(_BYTE **)buf;
        }
        swift::fatalError( 0LL,  "Checking conformance of %.*s %p to %s %p - dyld found no conformance descriptor, but matching descriptors exist: (%s)\n",  v156,  v157,  v154,  v152,  v31,  v155,  v32,  v158);
      }

      uint64_t v55 = v175;
    }

    if (v55 != v177) {
      free(v55);
    }
    uint64_t WitnessTable = v159;
    unint64_t v5 = &unk_18C486000;
  }

  if (byte_18C486EA8) {
    uint64_t v65 = 1;
  }
  else {
    uint64_t v65 = WitnessTable == 0;
  }
  if (v65)
  {
    uint64_t v4 = v173;
    spid = (__swift::__runtime::llvm *)v172;
    uint64_t v167 = v171 != 0;
    if (v5[478] != -1LL) {
      dispatch_once_f( &qword_18C486EF0,  &Conformances,  (dispatch_function_t)swift::Lazy<ConformanceState>::defaultInitCallback);
    }
    goto LABEL_153;
  }

  return WitnessTable;
}

    uint64_t v35 = 0LL;
    goto LABEL_100;
  }

  uint64_t v35 = 0LL;
  uint64_t v36 = v5;
  if ((v32 & 1) == 0) {
LABEL_101:
  }
    uint64_t v36 = *(swift::Demangle::__runtime::Node **)v5;
LABEL_102:
  uint64_t v38 = *(unsigned __int16 *)(*((void *)v36 + v19) + 16LL);
  if (v38 == 66) {
    unint64_t v39 = v12 + 1;
  }
  else {
    unint64_t v39 = v12;
  }
  uint64_t v40 = v5;
  if ((v32 & 1) == 0) {
    uint64_t v40 = *(swift::Demangle::__runtime::Node **)v5;
  }
  uint64_t v41 = *(unsigned __int16 *)(*((void *)v40 + v39) + 16LL);
  if (v41 == 271) {
    unint64_t v39 = (v39 + 1);
  }
  else {
    unint64_t v39 = v39;
  }
  uint64_t v42 = v5;
  if ((v32 & 1) == 0) {
    uint64_t v42 = *(swift::Demangle::__runtime::Node **)v5;
  }
  uint64_t v43 = *(unsigned __int16 *)(*((void *)v42 + v39) + 16LL);
  switch((v28 >> 1) | (v28 << 7))
  {
    case 0:
      uint64_t v44 = "@differentiable ";
      uint64_t v45 = this;
      uint64_t v46 = 16LL;
      goto LABEL_118;
    case 1:
      uint64_t v44 = "@differentiable(_forward) ";
      uint64_t v45 = this;
      uint64_t v46 = 26LL;
      goto LABEL_118;
    case 4:
      uint64_t v44 = "@differentiable(_linear) ";
      goto LABEL_117;
    case 7:
      uint64_t v44 = "@differentiable(reverse) ";
LABEL_117:
      uint64_t v45 = this;
      uint64_t v46 = 25LL;
LABEL_118:
      std::string::append(v45, v44, v46);
      break;
    default:
      break;
  }

  if (v38 == 66) {
    std::string::append(this, "@Sendable ", 0xAuLL);
  }
  uint64_t v47 = *((unsigned __int8 *)v5 + 18);
  uint64_t v48 = v47 - 1;
  if ((_DWORD)v47 != 1)
  {
    if ((_DWORD)v47 == 5)
    {
      uint64_t v47 = *((unsigned int *)v5 + 2);
    }

    else
    {
      if ((_DWORD)v47 != 2)
      {
LABEL_130:
        uint64_t v50 = 0LL;
        goto LABEL_131;
      }

      uint64_t v47 = 2LL;
    }
  }

  if (v47 <= v55) {
    goto LABEL_130;
  }
  uint64_t v49 = v5;
  if (v48 >= 2) {
    uint64_t v49 = *(swift::Demangle::__runtime::Node **)v5;
  }
  uint64_t v50 = (swift::Demangle::__runtime::Node *)*((void *)v49 + v55);
LABEL_131:
  if (!this[1].__r_.__value_.__s.__data_[15]) {
    return;
  }
  if (v41 == 271) {
    std::string::append(this, " async", 6uLL);
  }
  if (v35) {
  std::string::append(this, " -> ", 4uLL);
  }
  if (v43 == 130) {
    std::string::append(this, "sending ", 8uLL);
  }
  uint64_t v51 = *((unsigned __int8 *)v5 + 18);
  uint64_t v52 = v51 - 1;
  if ((_DWORD)v51 != 1)
  {
    if ((_DWORD)v51 == 5)
    {
      uint64_t v51 = *((unsigned int *)v5 + 2);
    }

    else
    {
      if ((_DWORD)v51 != 2) {
        goto LABEL_147;
      }
      uint64_t v51 = 2LL;
    }
  }

  unint64_t v53 = (v13 - 1);
  if (v51 > v53)
  {
    if (v52 >= 2) {
      unint64_t v5 = *(swift::Demangle::__runtime::Node **)v5;
    }
    uint64_t v54 = (swift::Demangle::__runtime::Node *)*((void *)v5 + v53);
    goto LABEL_148;
  }

  char *v63 = v16 + 1;
  v18[v16] = 108;
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

LABEL_118:
            __break(1u);
LABEL_119:
            __break(1u);
LABEL_120:
            __break(1u);
LABEL_121:
            unint64_t v230 = 773LL;
LABEL_123:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v230,  0);
          }

          uint64_t v127 = v245 + 3;
        }
      }

  if ((v96 & ~v106 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v106 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v174 >= 16)
    {
      v366 = (Swift::UInt64 *)v108;
      char v175 = v390;
      unint64_t v96 = v391;
      goto LABEL_127;
    }

    uint64_t v88 = v391;
    if ((v391 & 0x2000000000000000LL) == 0)
    {
      unint64_t v96 = v391;
      goto LABEL_150;
    }

    BOOL v189 = 0;
    unint64_t v96 = v391;
LABEL_169:
    swift_bridgeObjectRelease_n(v81, 5LL);
    unint64_t v106 = v390;
    uint64_t v62 = (uint64_t)v386;
    int64_t v59 = v387;
    int64_t v89 = (unint64_t)v378;
    if (!v189)
    {
LABEL_170:
      v206._rawBits = (v367 << 16) | 1;
      v207._rawBits = 1LL;
      v208._rawBits = _StringGuts.validateScalarRange(_:)(v207, v206, v79, v81);
      if (v208._rawBits < 0x10000) {
        v208._rawBits |= 3;
      }
      uint64_t v210 = specialized String.init(_:)(v208, v209, v79, v81);
      Swift::String::Index v212 = v211;
      swift_bridgeObjectRelease(v81);
      if ((v212 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v212);
      }

      else
      {
        v355 = v96;
        if ((v212 & 0x1000000000000000LL) != 0)
        {
          uint64_t v210 = _StringGuts._foreignConvertedToSmall()(v210, v212);
          v362 = v361;
          swift_bridgeObjectRelease(v212);
          Swift::String::Index v212 = v362;
        }

        else
        {
          if ((v210 & 0x1000000000000000LL) != 0)
          {
            v356 = (unsigned __int8 *)((v212 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v357 = v210 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            v356 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v210, v212);
          }

          closure #1 in _StringGuts._convertedToSmall()(v356, v357, &v388);
          swift_bridgeObjectRelease(v212);
          uint64_t v210 = v388;
          Swift::String::Index v212 = v389;
        }

        unint64_t v96 = v355;
        uint64_t v62 = (uint64_t)v386;
        int64_t v59 = v387;
        int64_t v89 = (unint64_t)v378;
      }

      Swift::String::Index v213 = HIBYTE(v88) & 0xF;
      uint64_t v214 = HIBYTE(v212) & 0xF;
      Swift::Int v215 = v214 + v213;
      if ((unint64_t)(v214 + v213) <= 0xF)
      {
        if (v214)
        {
          unint64_t v216 = 0LL;
          unint64_t v217 = 0LL;
          char v218 = 8 * v214;
          do
          {
            unint64_t v219 = v213 + v217;
            uint64_t v141 = v217++ >= 8;
            if (v141) {
              BOOL v220 = v212;
            }
            else {
              BOOL v220 = v210;
            }
            unint64_t v221 = (8 * v213 + v216) & 0x38;
            uint64_t v222 = (-255LL << v221) - 1;
            uint64_t v223 = (unint64_t)(v220 >> (v216 & 0x38)) << v221;
            uint64_t v224 = v223 | v222 & v88;
            uint64_t v225 = v223 | v222 & v106;
            if (v219 < 8) {
              unint64_t v106 = v225;
            }
            else {
              uint64_t v88 = v224;
            }
            v216 += 8LL;
          }

          while (v218 != v216);
        }

        swift_bridgeObjectRelease(v96);
        swift_bridgeObjectRelease(v81);
        uint64_t v226 = 0xA000000000000000LL;
        if (!(v106 & 0x8080808080808080LL | v88 & 0x80808080808080LL)) {
          uint64_t v226 = 0xE000000000000000LL;
        }
        v390 = v106;
        v391 = v226 & 0xFF00000000000000LL | (v215 << 56) | v88 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_191;
      }

        std::string::append(&v118, ")");
        if ((char)v118.__r_.__value_.__s.__size_ < 0)
        {
          size = v118.__r_.__value_.__l.__size_;
          uint64_t v12 = malloc(v118.__r_.__value_.__l.__size_ + 1);
          uint64_t v52 = (std::string *)v118.__r_.__value_.__r.__words[0];
        }

        else
        {
          size = v118.__r_.__value_.__s.__size_;
          uint64_t v12 = malloc(v118.__r_.__value_.__s.__size_ + 1LL);
          uint64_t v52 = &v118;
        }

        memcpy(v12, v52, size);
        *((_BYTE *)v12 + size) = 0;
        os_unfair_lock_lock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
        *(void *)&uint64_t v74 = v15;
        *((void *)&v74 + 1) = a2;
        *(void *)&uint64_t v75 = v12;
        *((void *)&v75 + 1) = size;
        unint64_t v53 = dword_18C5757A8;
        if (dword_18C5757A8)
        {
          uint64_t v54 = MangledToPrettyFunctionNameCache;
          uint64_t v55 = __swift::__runtime::llvm::hash_value(v15, a2);
          uint64_t v56 = 0LL;
          uint64_t v57 = v53 - 1;
          uint64_t v58 = (v53 - 1) & v55;
          for (k = 1; ; ++k)
          {
            uint64_t v60 = v54 + 32LL * v58;
            uint64_t v61 = *(const void **)v60;
            if (*(void *)v60 == -2LL)
            {
              if (v15 == (void *)-2LL) {
                goto LABEL_141;
              }
            }

            else if (v61 == (const void *)-1LL)
            {
              if (v15 == (void *)-1LL) {
                goto LABEL_141;
              }
            }

            else if (*(void *)(v60 + 8) == a2)
            {
              if (!a2) {
                goto LABEL_141;
              }
              id v73 = v54;
              uint64_t v62 = v56;
              uint64_t v63 = memcmp(v15, *(const void **)v60, a2);
              uint64_t v56 = v62;
              uint64_t v54 = v73;
              if (!v63) {
                goto LABEL_141;
              }
            }

            if (v56) {
              uint64_t v64 = 0;
            }
            else {
              uint64_t v64 = v61 == (const void *)-2LL;
            }
            if (v64) {
              uint64_t v56 = (void *)v60;
            }
            uint64_t v65 = v58 + k;
            uint64_t v58 = v65 & v57;
          }

          if (v56) {
            uint64_t v66 = v56;
          }
          else {
            uint64_t v66 = (void *)v60;
          }
        }

        else
        {
          uint64_t v66 = 0LL;
        }

        uint64_t v67 = __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::InsertIntoBucketImpl<__swift::__runtime::llvm::StringRef>( (uint64_t)&MangledToPrettyFunctionNameCache,  (uint64_t)&v74,  (uint64_t)&v74,  v66);
        *uint64_t v67 = v74;
        v67[1] = v75;
LABEL_141:
        os_unfair_lock_unlock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
LABEL_69:
        v78[0] = off_189B8E500;
        uint64_t v37 = v116;
        if (v116 == v115)
        {
          uint64_t v38 = 4LL;
          uint64_t v37 = v115;
        }

        else
        {
          if (!v116)
          {
LABEL_74:
            v78[0] = off_189B8E4D8;
            swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v79);
            if (v80) {
              *(_BYTE *)(v80 + 48) = 0;
            }
            return v12;
          }

          uint64_t v38 = 5LL;
        }

        (*(void (**)(void))(*v37 + 8 * v38))();
        goto LABEL_74;
      }

      uint64_t v18 = 5LL;
    }

    (*(void (**)(void))(*v17 + 8 * v18))();
    goto LABEL_28;
  }

  uint64_t v13 = a2;
  uint64_t v14 = (unsigned __int8 *)a1;
  while (*v14 - 32 < 0xFFFFFFE1)
  {
    ++v14;
    if (!--v13) {
      goto LABEL_22;
    }
  }

  return 0LL;
}

          while (v12 != v28)
          {
            uint64_t v51 = *v12++;
          }

          goto LABEL_120;
        }

        uint64_t v14 = *((unsigned __int8 *)a2 + 18);
        for (i = a2; ; uint64_t v14 = *((unsigned __int8 *)i + 18))
        {
          if (v14 != 1)
          {
            if (v14 != 5)
            {
              if (v14 != 2) {
              goto LABEL_30;
              }
            }

            uint64_t v16 = *((_DWORD *)i + 2);
            if (v16 != 1) {
              break;
            }
          }

          if (*((_WORD *)i + 8) != 232)
          {
            if (v14 != 5) {
            uint64_t v16 = *((_DWORD *)i + 2);
            }
            break;
          }

          int64_t i = *(swift::Demangle::__runtime::Node **)i;
        }

        if (v16 != 2) {
        uint64_t v14 = 5;
        }
LABEL_30:
        uint64_t v17 = *((unsigned __int16 *)i + 8);
        if ((v17 & 0xFFFE) == 0xE)
        {
          uint64_t v18 = i;
          if (v14 != 2)
          {
            if (!*((_DWORD *)i + 2))
            {
              uint64_t v19 = 0LL;
LABEL_36:
              uint64_t v20 = *((unsigned __int8 *)v19 + 18);
              if ((v20 - 1) >= 2)
              {
                if (v20 != 5 || !*((_DWORD *)v19 + 2))
                {
                  uint64_t v21 = 0LL;
LABEL_42:
                  if (v14 != 2)
                  {
                    if (*((_DWORD *)i + 2) < 2u)
                    {
                      uint64_t v22 = 0LL;
LABEL_47:
                      uint64_t v23 = *((unsigned __int8 *)v21 + 18);
                      if (v17 == 14)
                      {
                        uint64_t v24 = v21;
                        if (v23 != 2)
                        {
                          if (v23 != 5 || *((_DWORD *)v21 + 2) < 2u)
                          {
                            uint64_t v25 = 0LL;
                            goto LABEL_65;
                          }

                          uint64_t v24 = (uint64_t *)*v21;
                        }

                        uint64_t v25 = v24[1];
LABEL_65:
                        if (*(_WORD *)(v25 + 16) != 101) {
                          goto LABEL_68;
                        }
                        if (*(void *)(v25 + 8) != 8LL) {
                          goto LABEL_68;
                        }
                        if (**(void **)v25 != 0x6C616E6F6974704FLL) {
                          goto LABEL_68;
                        }
                        uint64_t v54 = *(unsigned __int8 *)(v22 + 18);
                        if (v54 != 1 && (v54 != 5 || *(_DWORD *)(v22 + 8) != 1)) {
                          goto LABEL_68;
                        }
                        uint64_t v55 = (int ***)v21;
                        if ((v23 - 1) >= 2)
                        {
                          if (v23 != 5 || !*((_DWORD *)v21 + 2))
                          {
                            uint64_t v56 = 0LL;
LABEL_152:
                            if (*((_WORD *)v56 + 8) == 153 && v56[1] == (int *)5)
                            {
                              uint64_t v62 = *v56;
                              uint64_t v63 = *v62;
                              uint64_t v64 = *((unsigned __int8 *)v62 + 4);
                              if (v63 == 1718187859 && v64 == 116)
                              {
                                uint64_t v66 = "?";
                                goto LABEL_181;
                              }
                            }

LABEL_55:
      unint64_t v255 = (v126 - 1) & v126;
      unint64_t v97 = __clz(__rbit64(v126)) + ((void)v127 << 6);
      v245 = v127;
    }

    uint64_t v98 = v265;
    unint64_t v99 = v266;
    Swift::String::Index v100 = v270;
    (*(void (**)(uint64_t *, unint64_t, uint64_t *))(v265 + 16))( v266,  *(void *)(v59 + 48) + *(void *)(v265 + 72) * v97,  v270);
    unint64_t v101 = *(void *)(v59 + 56) + *(void *)(v121 + 72) * v97;
    uint64_t v102 = (uint64_t *)v271;
    (*(void (**)(char *, unint64_t, swift *))(v121 + 16))(v271, v101, v120);
    uint64_t v103 = &v124[*((int *)v122 + 12)];
    (*(void (**)(char *, uint64_t *, uint64_t *))(v98 + 32))(v124, v99, v100);
    (*(void (**)(char *, uint64_t *, swift *))(v121 + 32))(v103, v102, v120);
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v123 + 56))(v124, 0LL, 1LL, v122);
LABEL_28:
    unint64_t v104 = v124;
    BOOL v105 = v248;
    (*(void (**)(char *, char *, unint64_t *))(v123 + 32))(v248, v104, v122);
    unint64_t v106 = &v105[*((int *)v122 + 12)];
    uint64_t v107 = v259;
    int64_t v108 = &v259[*((int *)TupleTypeMetadata2 + 12)];
    (*(void (**)(uint64_t *, char *, uint64_t *))(v98 + 32))(v99, v105, v100);
    uint64_t v109 = (swift *)v100;
    int64_t v110 = v247;
    swift_dynamicCast(v107, v99, v109, v247, 7uLL);
    (*(void (**)(uint64_t *, char *, swift *))(v121 + 32))(v102, v106, v120);
    uint64_t v111 = v256;
    swift_dynamicCast(v108, v102, v120, v256, 7uLL);
    uint64_t v112 = v257;
    uint64_t v113 = &v257[*((int *)v258 + 12)];
    uint64_t v114 = (void (*)(char *, char *, char *))Description[4];
    v114(v257, v107, v110);
    unint64_t v115 = *(void (**)(char *, char *, const char *))(v269 + 32);
    v115(v113, v108, v111);
    uint64_t v116 = v249;
    v114((char *)v249, v112, v110);
    uint64_t v117 = v251;
    v115(v251, v113, v111);
    uint64_t v118 = (uint64_t)v250;
    v114(v250, (char *)v116, v110);
    uint64_t v119 = (uint64_t)v252;
    v115(v252, v117, v111);
    _NativeDictionary._unsafeInsertNew(key:value:)(v118, v119, v264, (unint64_t)v110, (uint64_t)v111, v263);
    int64_t v89 = v254;
    int64_t v59 = (int64_t)v246;
  }

  uint64_t v129 = v244;
  uint64_t v130 = *((void *)v244 + 27);
  uint64_t v120 = (swift *)v267;
  uint64_t v122 = v262;
  uint64_t v123 = v272;
  int64_t v131 = (uint64_t *)v241;
  uint64_t v124 = v253;
  if (v130 < 0) {
    goto LABEL_108;
  }
  int64_t v132 = (void *)*((void *)v244 + 26);
  if (v130 != *((void *)v244 + 28))
  {
LABEL_43:
    uint64_t v134 = *((void *)v129 + 3);
    if (!v134) {
      goto LABEL_121;
    }
    if ((unint64_t)(v130 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_114:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  0x1FFuLL,  0);
    }

    uint64_t v135 = (void **)(v134 + 8 * v130);
    unint64_t v136 = *v135;
    *((void *)v129 + 27) = v130 + 1;
    swift_unknownObjectRetain(v136, v93, v94, v95);
    uint64_t v137 = (swift *)objc_msgSend(v132, sel_objectForKey_, v136);
    if (!v137) {
      goto LABEL_122;
    }
    int64_t v138 = v137;
    int64_t v139 = (const char *)v270;
    BOOL v140 = _swift_isClassOrObjCExistentialType((uint64_t)v270, v270);
    uint64_t v141 = v240;
    if (v140)
    {
      v273 = (swift *)v136;
      swift_dynamicCast(v124, (uint64_t *)&v273, v243, v139, 7uLL);
    }

    else
    {
      uint64_t v145 = v265;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, const char *))(v265 + 56))(v131, 1LL, 1LL, v139);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v136, (uint64_t)v139, v131);
      swift_unknownObjectRelease(v136);
      uint64_t v146 = v232;
      (*(void (**)(char *, uint64_t *, uint64_t))(v234 + 16))(v89, v131, v232);
      (*(void (**)(uint64_t *, uint64_t))(v234 + 8))(v131, v146);
      (*(void (**)(char *, char *, const char *))(v145 + 32))(v124, v89, v139);
    }

    uint64_t v142 = &v124[*((int *)v122 + 12)];
    BOOL v143 = _swift_isClassOrObjCExistentialType((uint64_t)v120, (uint64_t *)v120);
    unint64_t v144 = (uint64_t *)v239;
    if (v143)
    {
      v273 = v138;
      swift_dynamicCast(v142, (uint64_t *)&v273, (swift *)&unk_189B8D230, (const char *)v120, 7uLL);
    }

    else
    {
      uint64_t v147 = v261;
      (*(void (**)(char *, uint64_t, uint64_t, swift *))(v261 + 56))(v239, 1LL, 1LL, v120);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v138, (uint64_t)v120, v144);
      swift_unknownObjectRelease(v138);
      unint64_t v148 = v231;
      uint64_t v149 = v233;
      (*(void (**)(char *, uint64_t *, uint64_t))(v141 + 16))(v231, v144, v233);
      (*(void (**)(uint64_t *, uint64_t))(v141 + 8))(v144, v149);
      (*(void (**)(char *, char *, swift *))(v147 + 32))(v142, v148, v120);
    }

    uint64_t v123 = v272;
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v272 + 56))(v124, 0LL, 1LL, v122);
    uint64_t v121 = v261;
    Swift::String::Index v100 = v270;
    uint64_t v102 = (uint64_t *)v271;
    uint64_t v98 = v265;
    unint64_t v99 = v266;
    goto LABEL_28;
  }

  id v133 = objc_msgSend(*((id *)v244 + 26), sel_countByEnumeratingWithState_objects_count_, v237, v236, 16);
  uint64_t v129 = v244;
  *((void *)v244 + 28) = v133;
  if (v133)
  {
    uint64_t v130 = 0LL;
    *((void *)v129 + 27) = 0LL;
    goto LABEL_43;
  }

  *((void *)v129 + 27) = -1LL;
LABEL_108:
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v123 + 56))(v124, 1LL, 1LL, v122);
  uint64_t v154 = v264;
  swift_release((uint64_t)v264);
  uint64_t v228 = v59;
LABEL_111:
  outlined consume of [A : B].Iterator._Variant<A, B>(v228);
  return v154;
}

                    uint64_t v49 = (v77 - 1) & v77;
                    uint64_t v75 = __clz(__rbit64(v77)) + (v78 << 6);
                    unint64_t v126 = v78;
                  }

                  (*(void (**)(char *, unint64_t, uint64_t *))(v8 + 16))( v32,  *(void *)(v50 + 48) + *(void *)(v8 + 72) * v75,  a2);
LABEL_57:
                  uint64_t v72 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
                }
              }

              goto LABEL_111;
            }

            goto LABEL_103;
          }

          __break(1u);
LABEL_105:
          __break(1u);
          goto LABEL_106;
        }

        uint64_t v68 = objc_msgSend( *(id *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0xD0),  sel_countByEnumeratingWithState_objects_count_,  v122,  v121,  16);
        *(void *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0xE0) = v68;
        if (v68)
        {
          uint64_t v67 = 0LL;
          *(void *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = 0LL;
          goto LABEL_35;
        }

        *(void *)((v50 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = -1LL;
      }

  if (v14 >= v15 && v14 < v13._rawBits >> 14)
  {
LABEL_86:
    v13._rawBits = 0LL;
    uint64_t v54 = 1;
  }

  else
  {
LABEL_87:
    uint64_t v54 = 0;
  }

  uint64_t v55 = v13._rawBits;
  result.value._rawBits = v55;
  result.is_nil = v54;
  return result;
}

  unint64_t result = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v18);
  uint64_t v21 = v17 & 0xFFFFFFFFFFFF0000LL;
  if (result <= 63) {
    goto LABEL_26;
  }
LABEL_27:
  uint64_t v29 = v21 | 5;
  if ((v17 & 2) != 0)
  {
    if (v18 < v16
      || (unint64_t result = _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v21 | 5)), (result & 1) != 0))
    {
      uint64_t v29 = v21 | 7;
    }
  }

  *a3 = v29;
LABEL_32:
  if (v19) {
LABEL_33:
  }
    *a4 = (a2 << 16) | 5;
  return result;
}

  uint64_t v21 = v25;
  if (v25)
  {
    os_unfair_lock_unlock(v25 + 2);
    uint64_t v22 = *(void **)&v21[4]._os_unfair_lock_opaque;
    *(void *)&v21[4]._os_unfair_lock_opaque = 0LL;
    if (v22) {
      operator delete(v22);
    }
    swift_slowDealloc(v21);
  }

  return v8;
}

  uint64_t v19 = v23;
  if (v23)
  {
    os_unfair_lock_unlock(v23 + 2);
    uint64_t v20 = *(void **)&v19[4]._os_unfair_lock_opaque;
    *(void *)&v19[4]._os_unfair_lock_opaque = 0LL;
    if (v20) {
      operator delete(v20);
    }
    swift_slowDealloc(v19);
  }

  return v6;
}

        abort();
      }

      if (v18 > 1u) {
        goto LABEL_37;
      }
    }

    else if (v9)
    {
      if (v9 != 1) {
        goto LABEL_55;
      }
      if (v18 == 3) {
        goto LABEL_37;
      }
    }

    if ((v5 & 0x100) != 0) {
      goto LABEL_37;
    }
    if (v10 < v18)
    {
      uint64_t v32 = *(void *)(a2 + 8);
    }

    swift::blockOnMetadataDependency(a1[1], v5, v17, v4);
  }

  uint64_t v19 = checkTransitiveCompleteness((uint64_t *)v8, a2, a3, a4);
  if (v19)
  {
    uint64_t v17 = v19;
    uint64_t v18 = 3;
    goto LABEL_22;
  }

  uint64_t v20 = *(void *)v8;
  if (*(void *)v8 > 0x7FFuLL) {
    LODWORD(v20) = 0;
  }
  if ((v20 - 512) < 5
    || !(_DWORD)v20 && (uint64_t v30 = (unsigned int **)(v8 + 64), (*(_BYTE *)(v8 + 32) & 2) != 0))
  {
    uint64_t v21 = *v30;
  }

  else
  {
    uint64_t v21 = 0LL;
  }

  uint64_t v26 = (int *)swift::TargetTypeContextDescriptor<swift::InProcess>::getSingletonMetadataInitialization(v21);
  uint64_t v27 = *v26;
  if ((_DWORD)v27) {
    uint64_t v28 = (unint64_t *)((char *)v26 + v27);
  }
  else {
    uint64_t v28 = 0LL;
  }
  atomic_store(v8, v28);
  *(_BYTE *)(a2 + 17) = 4;
  uint64_t v29 = *(void *)(v32 + 16);
  *(void *)(v32 + 16) = 0LL;
  return a1[1];
}

  uint64_t v18 = v22;
  if (v22)
  {
    os_unfair_lock_unlock(v22 + 2);
    uint64_t v19 = *(void **)&v18[4]._os_unfair_lock_opaque;
    *(void *)&v18[4]._os_unfair_lock_opaque = 0LL;
    if (v19) {
      operator delete(v19);
    }
    swift_slowDealloc(v18);
  }

  return v6;
}

  uint64_t v25 = v39;
  if (v39 == v38)
  {
    uint64_t v26 = 4LL;
    uint64_t v25 = v38;
LABEL_59:
    (*(void (**)(void))(*v25 + 8 * v26))();
  }

  else if (v39)
  {
    uint64_t v26 = 5LL;
    goto LABEL_59;
  }

  uint64_t v27 = v37;
  if (v37 == v36)
  {
    uint64_t v28 = 4LL;
    uint64_t v27 = v36;
LABEL_64:
    (*(void (**)(void))(*v27 + 8 * v28))();
  }

  else if (v37)
  {
    uint64_t v28 = 5LL;
    goto LABEL_64;
  }

  if (v47 != v49) {
    free(v47);
  }
LABEL_67:
  v50[0] = off_189B8E500;
  uint64_t v29 = v88;
  if (v88 == v87)
  {
    uint64_t v30 = 4LL;
    uint64_t v29 = v87;
LABEL_71:
    (*(void (**)(void))(*v29 + 8 * v30))();
  }

  else if (v88)
  {
    uint64_t v30 = 5LL;
    goto LABEL_71;
  }

  v50[0] = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v51);
  if (v52) {
    *(_BYTE *)(v52 + 48) = 0;
  }
  return a6;
}

    *location = obj;
    return;
  }

  if ((*(_BYTE *)((*obj & 0xFFFFFFFF8LL) + 0x20) & 2) == 0)
  {
    uint64_t v6 = 0;
    if (*location) {
      uint64_t v7 = ((unint64_t)*location & 0x8000000000000001LL) == 1;
    }
    else {
      uint64_t v7 = 1;
    }
    unint64_t v8 = v7;
    if ((v8 & 1) != 0) {
      goto LABEL_57;
    }
    goto LABEL_53;
  }

  if (*location) {
    uint64_t v24 = ((unint64_t)*location & 0x8000000000000001LL) == 1;
  }
  else {
    uint64_t v24 = 1;
  }
  unint64_t v8 = v24;
  if (v8 != 1 || (*(_DWORD *)((*obj & 0xFFFFFFFF8LL) + 0x28) & 2) == 0)
  {
    uint64_t v6 = (*(_DWORD *)((*obj & 0xFFFFFFFF8LL) + 0x28) >> 1) & 1;
    if ((v8 & 1) != 0)
    {
LABEL_57:
      if (v8)
      {
        uint64_t v26 = (unint64_t)*location;
        *location = 0LL;
        uint64_t v27 = (unsigned __int128 *)(v26 & 0x7FFFFFFFFFFFFFFELL);
        if ((v26 & 0x7FFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v28 = v27 + 1;
          do
            uint64_t v29 = __ldxp(v28);
          while (__stxp(v29, v28));
          uint64_t v30 = (DWORD2(v29) - 1);
          do
          {
            while (1)
            {
              uint64_t v33 = __ldxp(v28);
              uint64_t v32 = *((void *)&v33 + 1);
              uint64_t v31 = v33;
              uint64_t v34 = (void)v33 != (void)v29;
              if (*((void *)&v33 + 1) != *((void *)&v29 + 1)) {
                ++v34;
              }
              if (!v34) {
                break;
              }
              if (!__stxp(v33, v28)) {
                goto LABEL_68;
              }
            }
          }

          while (__stxp(__PAIR128__(v30, v29), v28));
LABEL_68:
          if ((void)v33 != (void)v29 || *((void *)&v33 + 1) != *((void *)&v29 + 1))
          {
            do
            {
              uint64_t v38 = (v32 - 1);
              do
              {
                while (1)
                {
                  unint64_t v39 = __ldxp(v28);
                  uint64_t v40 = (void)v39 != v31;
                  if (*((void *)&v39 + 1) != v32) {
                    ++v40;
                  }
                  if (!v40) {
                    break;
                  }
                  if (!__stxp(v39, v28)) {
                    goto LABEL_74;
                  }
                }
              }

              while (__stxp(__PAIR128__(v38, v31), v28));
LABEL_74:
              uint64_t v36 = *((void *)&v39 + 1) ^ v32;
              uint64_t v37 = v39 ^ v31;
              uint64_t v32 = *((void *)&v39 + 1);
              uint64_t v31 = v39;
            }

            while (v37 | v36);
            LODWORD(v30) = v38;
          }

          if (!(_DWORD)v30) {
            swift_slowDealloc(v27);
          }
        }
      }

      else
      {
        objc_destroyWeak(location);
      }

      if (v6)
      {
        uint64_t v57 = swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::formWeakReference( obj + 1,  (uint64_t)obj,  a3,  a4);
        uint64_t v58 = (void *)(v57 | 1);
        if (!v57) {
          uint64_t v58 = 0LL;
        }
        *location = v58;
      }

      else
      {
        objc_initWeak(location, obj);
      }

      return;
    }

    uint64_t v24 = v20 - 1;
    while (1)
    {
      uint64_t v25 = *((unsigned __int8 *)v16 + 18);
      uint64_t v26 = v25 - 1;
      if ((_DWORD)v25 != 1)
      {
        if ((_DWORD)v25 == 5)
        {
          uint64_t v25 = *((unsigned int *)v16 + 2);
        }

        else
        {
          if ((_DWORD)v25 != 2) {
            goto LABEL_56;
          }
          uint64_t v25 = 2LL;
        }
      }

      if (v25 > v24)
      {
        uint64_t v27 = v16;
        if (v26 >= 2) {
          uint64_t v27 = *(swift::Demangle::__runtime::Node **)v16;
        }
        if (*(_DWORD *)a4) {
          return result;
        }
        goto LABEL_57;
      }

unint64_t _DictionaryAnyHashableBox._base.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unint64_t *a5@<X8>)
{
  a5[3] = type metadata accessor for Dictionary(0LL, a2, a3, a4);
  *a5 = a1;
  return swift_bridgeObjectRetain(a1, v7, v8, v9);
}

void _DictionaryAnyHashableBox._canonicalBox.getter( unint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, unint64_t *a4@<X8>)
{
  a4[3] = (unint64_t)&unk_189B8A140;
  a4[4] = (unint64_t)&protocol witness table for _DictionaryAnyHashableBox<A, B>;
  *a4 = a1;
  a4[1] = v9;
}

uint64_t _DictionaryAnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  uint64_t v7 = v11[0];
  uint64_t v8 = v11[1];
  char v9 = specialized static Dictionary<>.== infix(_:_:)(a3, v11[0], v5, v6);
  swift_bridgeObjectRelease(v8);
  swift_bridgeObjectRelease(v7);
  return v9 & 1;
}

Swift::Int _DictionaryAnyHashableBox._hashValue.getter( uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  *(void *)&__int128 v5 = 0LL;
  *((void *)&v5 + 1) = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  uint64_t v6 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v7 = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  uint64_t v8 = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  specialized Dictionary<>.hash(into:)(&v5, a2, a3, a4);
  return Hasher._finalize()();
}

void _DictionaryAnyHashableBox._hash(into:)(__int128 *a1, uint64_t a2, unint64_t a3, char *a4)
{
}

Swift::Int __swiftcall _DictionaryAnyHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  *(void *)&__int128 v4 = 0LL;
  *((void *)&v4 + 1) = _swift_stdlib_Hashing_parameters ^ _seed ^ 0x736F6D6570736575LL;
  uint64_t v5 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v6 = _swift_stdlib_Hashing_parameters ^ _seed ^ 0x6C7967656E657261LL;
  uint64_t v7 = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  specialized Dictionary<>.hash(into:)(&v4, v1, v1, v2);
  return Hasher._finalize()();
}

uint64_t _DictionaryAnyHashableBox._unbox<A>()@<X0>( unint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, const char *a4@<X4>, uint64_t a5@<X5>, char *a6@<X8>)
{
  unint64_t v15 = a1;
  __int128 v9 = (swift *)type metadata accessor for Dictionary(0LL, a2, a3, a5);
  swift_bridgeObjectRetain(a1, v10, v11, v12);
  int v13 = swift_dynamicCast(a6, (uint64_t *)&v15, v9, a4, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a4 - 1) + 56LL))( a6,  v13 ^ 1u,  1LL,  a4);
}

uint64_t _DictionaryAnyHashableBox._downCastConditional<A>(into:)( char *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t v28 = a1;
  uint64_t v12 = type metadata accessor for Optional(0LL, (uint64_t)a6, a3, a4);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v28 - v15;
  uint64_t v17 = *((void *)a6 - 1);
  MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v28 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v29 = a2;
  uint64_t v20 = (swift *)type metadata accessor for Dictionary(0LL, a4, a5, a7);
  swift_bridgeObjectRetain(a2, v21, v22, v23);
  uint64_t v24 = swift_dynamicCast(v16, (uint64_t *)&v29, v20, a6, 6uLL);
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v17 + 56);
  if ((_DWORD)v24)
  {
    v25(v16, 0LL, 1LL, a6);
    uint64_t v26 = *(void (**)(char *, char *, const char *))(v17 + 32);
    v26(v19, v16, a6);
    v26(v28, v19, a6);
  }

  else
  {
    v25(v16, 1LL, 1LL, a6);
    (*(void (**)(char *, uint64_t))(v13 + 8))(v16, v12);
  }

  return v24;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _DictionaryAnyHashableBox<A, B>( uint64_t a1@<X2>, char *a2@<X3>, unint64_t *a3@<X8>)
{
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _DictionaryAnyHashableBox<A, B>( uint64_t a1, uint64_t a2)
{
  return _DictionaryAnyHashableBox._isEqual(to:)(a1, a2, *(void *)(v2 + 8));
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _DictionaryAnyHashableBox<A, B>( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return _DictionaryAnyHashableBox._hashValue.getter(a1, *(void *)(v4 + 8), a3, a4);
}

void protocol witness for _AnyHashableBox._hash(into:) in conformance _DictionaryAnyHashableBox<A, B>( __int128 *a1, uint64_t a2, uint64_t a3, char *a4)
{
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _DictionaryAnyHashableBox<A, B>( Swift::Int _seed)
{
  return _DictionaryAnyHashableBox._rawHashValue(_seed:)(_seed);
}

unint64_t protocol witness for _AnyHashableBox._base.getter in conformance _DictionaryAnyHashableBox<A, B>@<X0>( uint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  return _DictionaryAnyHashableBox._base.getter(*v2, a1[2], a1[3], a1[4], a2);
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _DictionaryAnyHashableBox<A, B>@<X0>( const char *a1@<X0>, uint64_t *a2@<X2>, char *a3@<X8>)
{
  return _DictionaryAnyHashableBox._unbox<A>()(*v3, a2[2], a2[3], a1, a2[4], a3);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _DictionaryAnyHashableBox<A, B>( char *a1, const char *a2, uint64_t *a3)
{
  return _DictionaryAnyHashableBox._downCastConditional<A>(into:)(a1, *v3, (uint64_t)a3, a3[2], a3[3], a2, a3[4]);
}

uint64_t Dictionary.description.getter(uint64_t a1, char *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  v243 = a2;
  uint64_t v4 = a1;
  uint64_t v237 = *(void *)(a3 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  v242 = (char *)v225 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v236 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v5);
  v238 = (char *)v225 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, v9, v10, "key value ", 0LL);
  uint64_t v233 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v12, v13);
  uint64_t v232 = *(void *)(v233 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v233);
  uint64_t v16 = (char *)v225 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v21 = (char *)v225 - v20;
  if ((v4 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(v4 + 16))
    {
      uint64_t v247 = 91LL;
      unint64_t v248 = 0xE100000000000000LL;
      uint64_t v28 = -1LL << *(_BYTE *)(v4 + 32);
      uint64_t v25 = ~v28;
      uint64_t v29 = *(void *)(v4 + 64);
      uint64_t v228 = v4 + 64;
      uint64_t v30 = -v28;
      if (v30 < 64) {
        uint64_t v31 = ~(-1LL << v30);
      }
      else {
        uint64_t v31 = -1LL;
      }
      uint64_t v26 = v31 & v29;
      unint64_t v27 = v4;
      goto LABEL_12;
    }

    return 6109787LL;
  }

  if (v4 < 0) {
    uint64_t v22 = (void *)v4;
  }
  else {
    uint64_t v22 = (void *)(v4 & 0xFFFFFFFFFFFFFF8LL);
  }
  if (!objc_msgSend(v22, sel_count)) {
    return 6109787LL;
  }
  uint64_t v247 = 91LL;
  unint64_t v248 = 0xE100000000000000LL;
  uint64_t v23 = type metadata accessor for __CocoaDictionary.Iterator();
  unint64_t v24 = (unint64_t)swift_allocObject(v23, 0xE8uLL, 7uLL);
  uint64_t v228 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  *(void *)(v24 + 208) = v22;
  *(void *)(v24 + 216) = 0LL;
  *(_OWORD *)(v24 + 16) = 0u;
  *(_OWORD *)(v24 + 32) = 0u;
  *(_OWORD *)(v24 + 48) = 0u;
  *(_OWORD *)(v24 + 64) = 0u;
  *(_OWORD *)(v24 + 80) = 0u;
  *(_OWORD *)(v24 + 96) = 0u;
  *(_OWORD *)(v24 + 112) = 0u;
  *(_OWORD *)(v24 + 128) = 0u;
  *(_OWORD *)(v24 + 144) = 0u;
  *(_OWORD *)(v24 + 160) = 0u;
  *(_OWORD *)(v24 + 176) = 0u;
  *(_OWORD *)(v24 + 192) = 0u;
  *(void *)(v24 + 224) = 0LL;
  unint64_t v27 = v24 | 0x8000000000000000LL;
LABEL_12:
  unint64_t v234 = v27;
  uint64_t v229 = v27 & 0x7FFFFFFFFFFFFFFFLL;
  v225[1] = v25;
  int64_t v230 = (unint64_t)(v25 + 64) >> 6;
  v225[0] = v230 - 1;
  unint64_t v32 = swift_bridgeObjectRetain(v4, v17, v18, v19);
  uint64_t v36 = 0LL;
  char v37 = 1;
  __int128 v241 = xmmword_1817FFC60;
  __int128 v227 = xmmword_1817FFD10;
  __int128 v226 = xmmword_1817FFC70;
  uint64_t v235 = (char *)v3;
  unint64_t v231 = v16;
  while (1)
  {
    uint64_t v40 = v36;
    if ((v234 & 0x8000000000000000LL) != 0)
    {
      id v44 = __CocoaDictionary.Iterator.next()(v32, v33, v34, v35);
      if (v44)
      {
        uint64_t v47 = v44;
        uint64_t v48 = v45;
        _forceBridgeFromObjectiveC<A>(_:_:)(v44, v243, v46, v16);
        swift_unknownObjectRelease(v47);
        unint64_t v3 = (unint64_t)v235;
        _forceBridgeFromObjectiveC<A>(_:_:)(v48, v235, v49, &v16[*((int *)TupleTypeMetadata2 + 12)]);
        swift_unknownObjectRelease(v48);
        uint64_t v43 = 0LL;
        uint64_t v240 = v26;
      }

      else
      {
        uint64_t v43 = 1LL;
        uint64_t v240 = v26;
        unint64_t v3 = (unint64_t)v235;
      }
    }

    else
    {
      if (v26)
      {
        uint64_t v240 = (v26 - 1) & v26;
        unint64_t v41 = __clz(__rbit64(v26)) | (v36 << 6);
        goto LABEL_20;
      }

      ++v36;
      if (__OFADD__(v40, 1LL)) {
        goto LABEL_252;
      }
      if (v36 >= v230)
      {
        uint64_t v240 = 0LL;
        uint64_t v43 = 1LL;
        uint64_t v36 = v40;
      }

      else
      {
        unint64_t v50 = *(void *)(v228 + 8 * v36);
        if (v50) {
          goto LABEL_26;
        }
        uint64_t v153 = v40 + 2;
        if (v40 + 2 >= v230)
        {
          uint64_t v240 = 0LL;
          uint64_t v43 = 1LL;
        }

        else
        {
          unint64_t v50 = *(void *)(v228 + 8 * v153);
          if (v50)
          {
            ++v36;
LABEL_26:
            uint64_t v240 = (v50 - 1) & v50;
            unint64_t v41 = __clz(__rbit64(v50)) + (v36 << 6);
LABEL_20:
            uint64_t v42 = v234;
            (*(void (**)(char *, unint64_t, char *))(v236 + 16))( v16,  *(void *)(v234 + 48) + *(void *)(v236 + 72) * v41,  v243);
            (*(void (**)(char *, unint64_t, unint64_t))(v237 + 16))( &v16[*((int *)TupleTypeMetadata2 + 12)],  *(void *)(v42 + 56) + *(void *)(v237 + 72) * v41,  v3);
            uint64_t v43 = 0LL;
            goto LABEL_29;
          }

          while (1)
          {
            uint64_t v36 = v153 + 1;
            if (__OFADD__(v153, 1LL)) {
              goto LABEL_254;
            }
            if (v36 >= v230) {
              break;
            }
            unint64_t v50 = *(void *)(v228 + 8 * v36);
            ++v153;
            if (v50) {
              goto LABEL_26;
            }
          }

          uint64_t v240 = 0LL;
          uint64_t v43 = 1LL;
          uint64_t v36 = v225[0];
        }
      }
    }

LABEL_51:
      v73._rawBits = 1LL;
      v74._rawBits = 131073LL;
      v75._rawBits = _StringGuts.validateScalarRange(_:)(v73, v74, 0x202CuLL, 0xE200000000000000LL);
      if (v75._rawBits < 0x10000) {
        v75._rawBits |= 3;
      }
      unint64_t v77 = specialized String.init(_:)(v75, v76, 0x202CuLL, 0xE200000000000000LL);
      unint64_t v79 = v78;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      if ((v79 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v79);
      }

      else if ((v79 & 0x1000000000000000LL) != 0)
      {
        unint64_t v77 = _StringGuts._foreignConvertedToSmall()(v77, v79);
        unint64_t v166 = v165;
        swift_bridgeObjectRelease(v79);
        unint64_t v79 = v166;
      }

      else
      {
        if ((v77 & 0x1000000000000000LL) != 0)
        {
          uint64_t v159 = (unsigned __int8 *)((v79 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v160 = v77 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v159 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v77, v79);
        }

        closure #1 in _StringGuts._convertedToSmall()(v159, v160, &v246);
        swift_bridgeObjectRelease(v79);
        unint64_t v79 = *((void *)&v246 + 1);
        unint64_t v77 = v246;
      }

      uint64_t v80 = HIBYTE(v72) & 0xF;
      uint64_t v81 = HIBYTE(v79) & 0xF;
      uint64_t v82 = v81 + v80;
      if (v81)
      {
        char v83 = 0;
        unint64_t v84 = 0LL;
        do
        {
          unint64_t v85 = v80 + v84;
          unint64_t v86 = v84 + 1;
          if (v84 >= 8) {
            unint64_t v87 = v79;
          }
          else {
            unint64_t v87 = v77;
          }
          unint64_t v88 = v87 >> (v83 & 0x38);
          char v89 = (8 * v80 + v83) & 0x38;
          uint64_t v90 = (-255LL << v89) - 1;
          unint64_t v91 = (unint64_t)v88 << v89;
          unint64_t v92 = v91 | v90 & v72;
          unint64_t v93 = v91 | v90 & v57;
          if (v85 < 8) {
            uint64_t v57 = v93;
          }
          else {
            unint64_t v72 = v92;
          }
          v83 += 8;
          unint64_t v84 = v86;
        }

        while (v81 != v86);
      }

      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v94 = 0xE000000000000000LL;
      if (v57 & 0x8080808080808080LL | v72 & 0x80808080808080LL) {
        unint64_t v94 = 0xA000000000000000LL;
      }
      unint64_t v95 = v94 & 0xFF00000000000000LL | (v82 << 56) | v72 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_77;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v66, 2LL);
    swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
    __int128 v246 = v226;
    unint64_t v96 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v246, 2LL);
    _StringGuts.appendInPlace(_:isASCII:)(v96, v97, 1);
    swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_79:
    uint64_t v26 = (uint64_t)v243;
    uint64_t v54 = v238;
LABEL_80:
    uint64_t v100 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v100, &v245);
    *((_OWORD *)inited + 1) = v241;
    inited[7] = v26;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v53(boxed_opaque_existential_0Tm, v54, (char *)v26);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v247);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v105 = v247;
    unint64_t v3 = v248;
    unint64_t v106 = HIBYTE(v248) & 0xF;
    uint64_t v4 = v247 & 0xFFFFFFFFFFFFLL;
    if ((v248 & 0x2000000000000000LL) != 0) {
      unint64_t v107 = HIBYTE(v248) & 0xF;
    }
    else {
      unint64_t v107 = v247 & 0xFFFFFFFFFFFFLL;
    }
    if (!v107 && (v247 & ~v248 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v248);
      uint64_t v247 = 8250LL;
      unint64_t v38 = 0xE200000000000000LL;
      goto LABEL_14;
    }

    if ((v248 & 0x2000000000000000LL) == 0 || v106 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v103, v104);
      if ((v3 & 0x1000000000000000LL) != 0)
      {
        Swift::Int v154 = String.UTF8View._foreignCount()();
        Swift::Int v113 = v154 + 2;
        if (__OFADD__(v154, 2LL))
        {
LABEL_251:
          __break(1u);
LABEL_252:
          __break(1u);
LABEL_253:
          __break(1u);
LABEL_254:
          __break(1u);
LABEL_255:
          __break(1u);
LABEL_256:
          Swift::Int v217 = String.UTF8View._foreignCount()();
          uint64_t v179 = v217 + 1;
          if (!__OFADD__(v217, 1LL)) {
            goto LABEL_202;
          }
LABEL_258:
          __break(1u);
LABEL_259:
          if ((v179 & 0x1000000000000000LL) != 0)
          {
            unint64_t v3 = _StringGuts._foreignConvertedToSmall()(v3, v179);
            uint64_t v223 = v222;
            swift_bridgeObjectRelease(v179);
            uint64_t v179 = v223;
          }

          else
          {
            if ((v3 & 0x1000000000000000LL) != 0)
            {
              char v218 = (unsigned __int8 *)((v179 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v219 = v3 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              char v218 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v179);
            }

            closure #1 in _StringGuts._convertedToSmall()(v218, v219, &v246);
            swift_bridgeObjectRelease(v179);
            uint64_t v179 = *((void *)&v246 + 1);
            unint64_t v3 = v246;
          }

          goto LABEL_225;
        }
      }

      else
      {
        BOOL v65 = __OFADD__(v107, 2LL);
        Swift::Int v113 = v107 + 2;
        if (v65) {
          goto LABEL_251;
        }
      }

      uint64_t v26 = v105 & ~v3;
      if ((v26 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v3 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v114 = _StringGuts.nativeUnusedCapacity.getter(v105, v3);
        if ((v115 & 1) != 0) {
          goto LABEL_269;
        }
        if (v113 > 15) {
          goto LABEL_118;
        }
        if ((v3 & 0x2000000000000000LL) == 0)
        {
          if (v114 <= 1) {
            goto LABEL_98;
          }
LABEL_118:
          int64_t v142 = _StringGuts.nativeUnusedCapacity.getter(v105, v3);
          uint64_t v4 = (v143 & 1) == 0 && v142 > 1;
          if ((v26 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v3 & 0xFFFFFFFFFFFFFFFLL))
          {
            if ((v4 & 1) != 0)
            {
LABEL_138:
              swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
              __int128 v246 = v227;
              uint64_t v150 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v246, 2LL);
              _StringGuts.appendInPlace(_:isASCII:)(v150, v151, 1);
              swift_bridgeObjectRelease(0xE200000000000000LL);
              goto LABEL_15;
            }

        v294 = 15LL;
        uint64_t v172 = v77((unint64_t *)v78, v68);
        uint64_t v173 = v259(v78, v68);
        if ((v172 & 1) != 0)
        {
          int64_t v66 = v257;
          if (v173 > 64)
          {
            unint64_t v176 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
            unint64_t v177 = lazy protocol witness table accessor for type Int and conformance Int(v173, v174, v175);
            v176(&v294, &type metadata for Int, v177, v78, v68);
            unint64_t v178 = v290;
            uint64_t v179 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v83,  v290,  v78);
            uint64_t v180 = (void (*)(char *, uint64_t))v291;
            ((void (*)(char *, uint64_t))v291)(v83, v78);
            int64_t v181 = v178;
            goto LABEL_61;
          }
        }

        else
        {
          int64_t v66 = v257;
          if (v173 > 63)
          {
            v293 = 15LL;
            char v184 = *(uint64_t (**)(char *, char *, uint64_t))(v84 + 32);
            int64_t v185 = v266;
            BOOL v186 = v184(v266, v290, v78);
            uint64_t v187 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
            Swift::String::Index v190 = lazy protocol witness table accessor for type Int and conformance Int(v186, v188, v189);
            v187(&v293, &type metadata for Int, v190, v78, v68);
            uint64_t v179 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v83,  v185,  v78);
            uint64_t v180 = (void (*)(char *, uint64_t))v291;
            ((void (*)(char *, uint64_t))v291)(v83, v78);
            int64_t v181 = v185;
LABEL_61:
            v180(v181, v78);
            if ((v179 & 1) == 0)
            {
LABEL_62:
              unint64_t v72 = v292;
              Swift::String::Index v191 = (*(uint64_t (**)(swift *, uint64_t))(v63 + 136))(a2, v63);
              unint64_t v71 = v256;
              if (v191 >= 11) {
                goto LABEL_108;
              }
              goto LABEL_16;
            }

          unint64_t v27 = ((uint64_t (*)(uint64_t, uint64_t))v61)(a3, v96);
          a2 = v241;
          uint64_t v14 = v234;
          goto LABEL_56;
        }

        uint64_t v109 = v242;
      }

      else
      {
        uint64_t v109 = v242;
        if (v100 > 63)
        {
          unint64_t v108 = *(void (**)(void))(v242 + 16);
          uint64_t v110 = v225;
          char v111 = ((uint64_t (*)(char *, void (*)(void), void (*)(char *, uint64_t)))v108)( v225,  v250,  v8);
          if (v98 < 0)
          {
            v59(v110, v8);
            goto LABEL_51;
          }

          v252[0] = v98;
          int64_t v114 = v96;
          char v115 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
          uint64_t v116 = lazy protocol witness table accessor for type Int and conformance Int(v111, v112, v113);
          uint64_t v117 = v244;
          v115(v252, &type metadata for Int, v116, v8, v6);
          unint64_t v96 = v114;
          uint64_t v118 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                                 + 16LL))( v117,  v110,  v8);
          unint64_t v119 = v117;
          uint64_t v61 = (uint64_t (*)(uint64_t))v249;
          v59(v119, v8);
          v59(v110, v8);
          if ((v118 & 1) != 0) {
            goto LABEL_51;
          }
          goto LABEL_34;
        }
      }

      unint64_t v108 = *(void (**)(void))(v109 + 16);
      Swift::String::Index v120 = v244;
      ((void (*)(char *, void (*)(void), void (*)(char *, uint64_t)))v108)(v244, v250, v8);
      Swift::String::Index v121 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
      Swift::String::Index v122 = v120;
      uint64_t v61 = (uint64_t (*)(uint64_t))v249;
      v59(v122, v8);
      if (v98 < v121) {
        goto LABEL_51;
      }
LABEL_34:
      Swift::String::Index v123 = v231;
      v108();
      unint64_t v124 = v235(v8, v6);
      unint64_t v125 = v229;
      v250 = v108;
      ((void (*)(char *, char *, void (*)(char *, uint64_t)))v108)(v229, v123, v8);
      if ((v124 & 1) != 0)
      {
        unint64_t v126 = v233(v8, v6);
        uint64_t v127 = v59;
        v59(v125, v8);
        uint64_t v128 = v230;
        uint64_t v129 = v232;
        if (v126 < 65) {
          goto LABEL_41;
        }
        char v130 = v224;
        ((void (*)(char *, char *, void (*)(char *, uint64_t)))v250)(v224, v123, v8);
        v252[0] = 0x8000000000000000LL;
        unint64_t v131 = v235;
        if ((v235(v8, v6) & 1) != 0)
        {
          unint64_t v132 = v233(v8, v6);
          if (v132 < 64)
          {
            unint64_t v135 = v244;
            ((void (*)(char *, char *, void (*)(char *, uint64_t)))v250)(v244, v130, v8);
            char v136 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
            v127(v135, v8);
            uint64_t v137 = v136 < v252[0];
            uint64_t v129 = v232;
            unint64_t v138 = v130;
LABEL_77:
            unint64_t v59 = v127;
            if (!v137) {
              goto LABEL_40;
            }
LABEL_89:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
          }

          Swift::String::Index v192 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
          Swift::String::Index v193 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
          uint64_t v194 = v244;
          v192(v252, &type metadata for Int, v193, v8, v6);
          unint64_t v96 = v248;
          uint64_t v195 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                                 + 16LL))( v130,  v194,  v8);
          v127(v194, v8);
          uint64_t v129 = v232;
          unint64_t v138 = v130;
          unint64_t v59 = v127;
          if ((v195 & 1) != 0) {
            goto LABEL_89;
          }
        }

        else
        {
          int64_t v183 = v131(v8, v6);
          char v184 = v233(v8, v6);
          if ((v183 & 1) != 0)
          {
            if (v184 <= 64)
            {
              unint64_t v199 = v228;
              unint64_t v200 = AssociatedTypeWitness;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v228,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              unint64_t v202 = v226;
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                          + 8))( &unk_18180BE68,  256LL,  v200,  AssociatedConformanceWitness);
              unint64_t v203 = v244;
              (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v199 + 3))( v202,  v8,  v199);
              char v204 = v224;
              LOBYTE(v200) = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v224,  v203,  v8);
              v127(v203, v8);
              uint64_t v205 = v223;
              ((void (*)(char *, char *, void (*)(char *, uint64_t)))v250)(v223, v204, v8);
              if ((v200 & 1) != 0)
              {
                v127(v205, v8);
                goto LABEL_89;
              }

              unint64_t v206 = v252[0];
              unint64_t v207 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
              v127(v205, v8);
              uint64_t v137 = v207 < v206;
              unint64_t v96 = v248;
              uint64_t v129 = v232;
              unint64_t v138 = v224;
              goto LABEL_77;
            }

            uint64_t v187 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
            uint64_t v188 = lazy protocol witness table accessor for type Int and conformance Int(v184, v185, v186);
            BOOL v189 = v244;
            v187(v252, &type metadata for Int, v188, v8, v6);
            unint64_t v96 = v248;
            Swift::String::Index v190 = v224;
            Swift::String::Index v191 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v224,  v189,  v8);
            v127(v189, v8);
            unint64_t v138 = v190;
            unint64_t v59 = v127;
            uint64_t v129 = v232;
            if ((v191 & 1) != 0) {
              goto LABEL_89;
            }
          }

          else if (v184 < 64)
          {
            uint64_t v196 = v244;
            uint64_t v197 = v224;
            ((void (*)(char *, char *, void (*)(char *, uint64_t)))v250)(v244, v224, v8);
            char v198 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
            v127(v196, v8);
            unint64_t v138 = v197;
            unint64_t v59 = v127;
            uint64_t v129 = v232;
            if (v198 < v252[0]) {
              goto LABEL_89;
            }
          }

          else
          {
            uint64_t v129 = v232;
            unint64_t v138 = v224;
            unint64_t v59 = v127;
          }
        }
      }

      else
      {
        unint64_t v138 = v125;
        uint64_t v128 = v230;
        uint64_t v129 = v232;
      }

    if (v16 >= v29) {
      uint64_t v18 = v29;
    }
    else {
      uint64_t v18 = v16;
    }
    if (v18 >= v15) {
      goto LABEL_31;
    }
LABEL_55:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if ((v4 & 0x1000000000000000LL) != 0)
  {
    unint64_t v27 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v28 = v4 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    unint64_t v27 = (char *)_StringObject.sharedUTF8.getter(v4, v5);
    uint64_t v16 = v3 >> 16;
  }

  uint64_t v29 = v15 + 1;
  if (v15 + 1 == v28) {
    goto LABEL_51;
  }
  if (!v27) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  uint64_t v30 = *(unsigned __int16 *)&v27[v15];
LABEL_49:
  if (v30 != 2573 && (v30 & 0x80808080) == 0) {
    goto LABEL_51;
  }
LABEL_60:
  uint64_t v35 = v16;
  uint64_t v36 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v15);
  uint64_t v16 = v35;
  uint64_t v14 = v36;
LABEL_26:
  uint64_t v17 = v14 + v15;
  if (v16 >= v17) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = v16;
  }
  if ((v5 & 0x1000000000000000LL) != 0)
  {
    uint64_t v31 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v15, v18);
    unint64_t object = v31._object;
    uint64_t countAndFlagsBits = v31._countAndFlagsBits;
    goto LABEL_39;
  }

  if (v18 < v15) {
    goto LABEL_55;
  }
LABEL_31:
  if ((v5 & 0x2000000000000000LL) != 0)
  {
    unint64_t v38 = v4;
    unint64_t v39 = v5 & 0xFFFFFFFFFFFFFFLL;
    if ((uint64_t)(HIBYTE(v5) & 0xF) >= v18)
    {
      uint64_t v22 = v18 - v15;
      if (v22 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      uint64_t v21 = (uint8x16_t *)((char *)&v38 + v15);
      goto LABEL_38;
    }

    goto LABEL_58;
  }

  if ((v4 & 0x1000000000000000LL) == 0)
  {
    unint64_t v32 = v4;
    uint64_t v33 = v18;
    uint64_t v19 = _StringObject.sharedUTF8.getter(v32, v5);
    uint64_t v20 = v34;
    uint64_t v18 = v33;
    if (v20 >= v33) {
      goto LABEL_34;
    }
LABEL_58:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  uint64_t v19 = (id)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v20 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0xFFFFFFFFFFFFLL) < v18) {
    goto LABEL_58;
  }
LABEL_34:
  uint64_t v21 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v15, v18, (uint64_t)v19, v20);
LABEL_38:
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v21, v22);
LABEL_39:
  uint64_t v25 = (uint64_t)object;
  v37[0] = countAndFlagsBits;
  v37[1] = object;
  v6(&v38, v37);
  swift_bridgeObjectRelease(v25);
  return v38;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  if ((a6 & 0x1000000000000000LL) != 0)
  {
    uint64_t v18 = (id)((a7 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v19 = a6 & 0xFFFFFFFFFFFFLL;
    if (a8 < 0) {
      goto LABEL_57;
    }
  }

  else
  {
    uint64_t v18 = _StringObject.sharedUTF8.getter(a6, a7);
    uint64_t v19 = v59;
    if (a8 < 0) {
      goto LABEL_57;
    }
  }

  if (v19 < a9)
  {
LABEL_50:
    unint64_t v58 = 1861LL;
    goto LABEL_58;
  }

  uint64_t v20 = (const void *)specialized UnsafeBufferPointer.init(rebasing:)(a8, a9, (uint64_t)v18, v19);
  uint64_t v22 = v21;
  if ((a2 & 0x2000000000000000LL) != 0)
  {
    char v68 = v15;
    uint64_t v69 = a2 & 0xFFFFFFFFFFFFFFLL;
    if (a3 < 0) {
      goto LABEL_57;
    }
    uint64_t v49 = v15;
    unint64_t v50 = v17;
    uint64_t v51 = v11;
    uint64_t v52 = a4 - a3;
    if (a4 - a3 >= 0)
    {
      if (v52 >= v21) {
        unint64_t v53 = v21;
      }
      else {
        unint64_t v53 = a4 - a3;
      }
      uint64_t v54 = _swift_stdlib_memcmp(v20, (char *)&v68 + a3, v53);
      uint64_t v55 = v54;
      if (!v54) {
        uint64_t v55 = v22 - v52;
      }
      uint64_t v12 = a4;
      uint64_t v11 = v51;
      uint64_t v17 = v50;
      uint64_t v15 = v49;
      if (!v55) {
        return v17 == 0;
      }
      return _StringGutsSlice._slowCompare(with:expecting:)(v15, a2, a3, v12, v17, v11, a7, a8, v16);
    }

    goto LABEL_51;
  }

  if ((v15 & 0x1000000000000000LL) != 0)
  {
    uint64_t v23 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    unint64_t v24 = v15 & 0xFFFFFFFFFFFFLL;
    uint64_t v25 = a4;
    if ((a3 & 0x8000000000000000LL) == 0) {
      goto LABEL_10;
    }
LABEL_57:
    unint64_t v58 = 1860LL;
LABEL_58:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v58,  0);
  }

  unint64_t v60 = v20;
  uint64_t v23 = _StringObject.sharedUTF8.getter(v15, a2);
  uint64_t v20 = v60;
  unint64_t v24 = v61;
  uint64_t v25 = a4;
  if (a3 < 0) {
    goto LABEL_57;
  }
LABEL_10:
  if (v24 < v25) {
    goto LABEL_50;
  }
  uint64_t v26 = v20;
  uint64_t v28 = (const void *)specialized UnsafeBufferPointer.init(rebasing:)(a3, v25, (uint64_t)v23, v24);
  uint64_t v64 = v15;
  uint64_t v29 = v17;
  uint64_t v30 = v11;
  uint64_t v31 = v27;
  if (v27 >= v22) {
    unint64_t v32 = v22;
  }
  else {
    unint64_t v32 = v27;
  }
  uint64_t v33 = v26;
  uint64_t v16 = a9;
  uint64_t v34 = _swift_stdlib_memcmp(v33, v28, v32);
  uint64_t v35 = v34;
  uint64_t v36 = v22 - v31;
  uint64_t v11 = v30;
  uint64_t v17 = v29;
  uint64_t v15 = v64;
  if (!v34) {
    uint64_t v35 = v36;
  }
  uint64_t v12 = a4;
  if (!v35) {
    return v17 == 0;
  }
  return _StringGutsSlice._slowCompare(with:expecting:)(v15, a2, a3, v12, v17, v11, a7, a8, v16);
}

  v13._rawBits = 0LL;
  unint64_t v32 = 1;
LABEL_56:
  result.value = v13;
  result.is_nil = v32;
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  LODWORD(v20) = 0;
LABEL_52:
  uint64_t v82 = off_189B8E500;
  uint64_t v31 = v123;
  if (v123 == v122)
  {
    unint64_t v32 = 4LL;
    uint64_t v31 = v122;
LABEL_56:
    (*(void (**)(void))(*v31 + 8 * v32))();
  }

  else if (v123)
  {
    unint64_t v32 = 5LL;
    goto LABEL_56;
  }

  uint64_t v82 = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(v85);
  if (v87) {
    *(_BYTE *)(v87 + 48) = 0;
  }
  if (!(_DWORD)v20) {
    return 0LL;
  }
LABEL_60:
  unint64_t v77 = v79;
  unint64_t v78 = 0x400000000LL;
  Swift::String::Index v74 = v76;
  Swift::String::Index v75 = 0x400000000LL;
  if (v14 >= 5)
  {
    __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v77, v79, v14, 8LL);
    uint64_t v33 = v78;
    goto LABEL_63;
  }

  uint64_t v33 = 0;
  uint64_t v34 = 0;
  if (v14)
  {
LABEL_63:
    memcpy((char *)v77 + 8 * v33, (const void *)(a2 + 16), 8 * v14);
    uint64_t v34 = v78;
  }

  uint64_t v35 = (v34 + v14);
  LODWORD(v78) = v35;
  if (v35 >= HIDWORD(v78))
  {
    __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v77, v79, v35 + 1, 8LL);
    LODWORD(v35) = v78;
  }

  *((void *)v77 + v35) = v15;
  LODWORD(v78) = v78 + 1;
  LODWORD(v82) = 2;
  char v83 = v12;
  unint64_t v84 = v77;
  unint64_t v85 = &v87;
  unint64_t v86 = 0x800000000LL;
  *(void *)&unint64_t v106 = 0LL;
  uint64_t v36 = *v12;
  if ((v36 & 0x800) != 0)
  {
    unint64_t v38 = 0LL;
    char v37 = &swift::ImplicitGenericParamDescriptors;
  }

  else
  {
    char v37 = (void *)((((unint64_t)&v12[2 * ((v36 >> 8) & 1) + 4] + 3) & 0xFFFFFFFFFFFFFFFCLL)
                 + 4 * ((v36 >> 9) & 1)
                 + 4LL * ((v36 >> 10) & 1));
    unint64_t v38 = *((unsigned __int16 *)v12 + 4);
  }

  unint64_t v39 = (unsigned __int16 *)(v12 + 4);
  if ((*v12 & 0x1100) == 0x100) {
    uint64_t v40 = *v39;
  }
  else {
    uint64_t v40 = 0LL;
  }
  unint64_t v41 = (((unint64_t)&v39[4 * ((v36 >> 8) & 1) + 1] + 1) & 0xFFFFFFFFFFFFFFFCLL)
  uint64_t v42 = *((void *)v12 + 1);
  v70[0] = off_189B8B1A0;
  v70[1] = &v82;
  unint64_t v71 = v70;
  v68[0] = off_189B8B1E8;
  v68[1] = &v82;
  uint64_t v69 = v68;
  v66[0] = off_189B8B230;
  int64_t v67 = v66;
  swift::_checkGenericRequirements( (uint64_t)v37,  (const char *)(unsigned __int16)v42,  (v41 + v40 + v38 + 3) & 0xFFFFFFFFFFFFFFFCLL,  WORD1(v42),  (uint64_t)&v74,  v70,  (uint64_t)v68,  v66,  (uint64_t)v72);
  uint64_t v43 = v67;
  if (v67 == v66)
  {
    id v44 = 4LL;
    uint64_t v43 = v66;
LABEL_76:
    (*(void (**)(void))(*v43 + 8 * v44))();
  }

  else if (v67)
  {
    id v44 = 5LL;
    goto LABEL_76;
  }

  uint64_t v45 = v69;
  if (v69 == v68)
  {
    uint64_t v46 = 4LL;
    uint64_t v45 = v68;
LABEL_81:
    (*(void (**)(void))(*v45 + 8 * v46))();
  }

  else if (v69)
  {
    uint64_t v46 = 5LL;
    goto LABEL_81;
  }

  uint64_t v47 = v71;
  if (v71 == v70)
  {
    uint64_t v48 = 4LL;
    uint64_t v47 = v70;
LABEL_86:
    (*(void (**)(void))(*v47 + 8 * v48))();
  }

  else if (v71)
  {
    uint64_t v48 = 5LL;
    goto LABEL_86;
  }

  uint64_t v49 = v73;
  if (v73) {
    ((void (*)(void, uint64_t, void))v72[1])(v72[0], 3LL, 0LL);
  }
  if (v85 != &v87) {
    free(v85);
  }
  if (v49)
  {
    unint64_t v50 = 0LL;
  }

  else
  {
    switch(*(_BYTE *)v12)
    {
      case 0:
        a1[3] = a4;
        BoxForExistentialIn = swift::TargetMetadata<swift::InProcess>::allocateBoxForExistentialIn(a4, a1);
        uint64_t v51 = a1 + 4;
        a1 = BoxForExistentialIn;
        uint64_t v52 = v75;
        if ((_DWORD)v75) {
          goto LABEL_100;
        }
        goto LABEL_107;
      case 1:
      case 2:
        uint64_t v51 = a1 + 1;
        uint64_t v52 = v75;
        if (!(_DWORD)v75) {
          goto LABEL_107;
        }
        goto LABEL_100;
      case 3:
        abort();
      default:
        a1 = 0LL;
        uint64_t v51 = 0LL;
        uint64_t v52 = v75;
        if (!(_DWORD)v75) {
          goto LABEL_107;
        }
LABEL_100:
        uint64_t v54 = 0LL;
        uint64_t v55 = (char *)v74;
        uint64_t v54 = v52 & 0xFFFFFFFC;
        uint64_t v56 = (__int128 *)((char *)v74 + 16);
        uint64_t v57 = v51 + 2;
        unint64_t v58 = v54;
        do
        {
          unint64_t v59 = *v56;
          *(v57 - 1) = *(v56 - 1);
          id *v57 = v59;
          v56 += 2;
          v57 += 2;
          v58 -= 4LL;
        }

        while (v58);
        if (v54 != v52)
        {
LABEL_105:
          unint64_t v60 = &v51[v54];
          uint64_t v61 = &v55[8 * v54];
          uint64_t v62 = v52 - v54;
          do
          {
            char v63 = *(void *)v61;
            v61 += 8;
            *v60++ = v63;
            --v62;
          }

          while (v62);
        }

  *(_OWORD *)a5 = *(_OWORD *)&p_p->__r_.__value_.__l.__data_;
  *(void *)(a5 + 16) = p_p->__r_.__value_.__l.__cap_;
LABEL_56:
  *(_DWORD *)(a5 + 24) = 1;
  if (v18 != -1) {
    ((void (*)(std::string *, std::string *))off_189B8B2E0[v18])(&v28, &__p);
  }
}

          swift_getTypeByMangledName(&v256, 255LL, SymbolicMangledNameStringRef, v21, v22, v273, v271);
          uint64_t v30 = v272;
          if (v272 == v271)
          {
            uint64_t v30 = v271;
            uint64_t v31 = 4LL;
          }

          else
          {
            if (!v272) {
              goto LABEL_56;
            }
            uint64_t v31 = 5LL;
          }

          (*(void (**)(void))(*v30 + 8 * v31))();
LABEL_56:
          unint64_t v32 = v274;
          if (v274 == v273)
          {
            unint64_t v32 = v273;
            uint64_t v33 = 4LL;
          }

          else
          {
            if (!v274) {
              goto LABEL_61;
            }
            uint64_t v33 = 5LL;
          }

          (*(void (**)(void))(*v32 + 8 * v33))();
LABEL_61:
          if ((_WORD)v259)
          {
            if ((unsigned __int16)v259 == 1)
            {
              uint64_t v34 = v256;
              uint64_t v35 = (uint64_t (*)(void *, uint64_t, void))v257;
              *(void *)(a9 + 8) = v257;
              uint64_t v36 = (_DWORD *)v35(v34, 2LL, 0LL);
LABEL_64:
              *(void *)a9 = v36;
              *(_BYTE *)(a9 + 16) = 1;
              goto LABEL_350;
            }

            char v37 = 0LL;
          }

          else
          {
            char v37 = (uint64_t *)v256;
          }

          unint64_t v38 = *(_DWORD *)v13 & 0x1F;
          switch(v38)
          {
            case 0:
              v268 = 0LL;
              uint64_t v40 = (int *)(v13 + 8);
              unint64_t v39 = *(int *)(v13 + 8);
              if ((v39 & 2) != 0)
              {
                unint64_t v108 = (unint64_t)v40 + (v39 & 0xFFFFFFFFFFFFFFFCLL);
                if ((v39 & 1) != 0) {
                  unint64_t v108 = *(void *)v108;
                }
                unint64_t v41 = (const char *)(v108 | 1);
              }

              else if ((v39 & 0xFFFFFFFD) != 0)
              {
                unint64_t v41 = (char *)v40 + (v39 & 0xFFFFFFFFFFFFFFFCLL);
                if ((v39 & 1) != 0) {
                  unint64_t v41 = *(const char **)v41;
                }
              }

              else
              {
                unint64_t v41 = 0LL;
              }

              char v136 = swift::_conformsToProtocol(0LL, (uint64_t)v37, v41, (uint64_t *)&v268);
              uint64_t v137 = *v40;
              if ((v136 & 1) != 0)
              {
                uint64_t v12 = a5;
                if ((v137 & 2) == 0)
                {
                  if ((v137 & 0xFFFFFFFD) == 0) {
                    goto LABEL_249;
                  }
                  unint64_t v138 = (void *)((char *)v40 + (v137 & 0xFFFFFFFFFFFFFFFCLL));
                  if ((v137 & 1) != 0) {
                    unint64_t v138 = (void *)*v138;
                  }
                  if ((v138 & 1) == 0)
                  {
LABEL_249:
                    unint64_t v139 = (uint64_t)v268;
                    unint64_t v140 = *(unsigned int *)(a5 + 8);
                    if (v140 >= *(unsigned int *)(a5 + 12))
                    {
                      __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a5, v235, v140 + 1, 8LL);
                      unint64_t v140 = *(unsigned int *)(a5 + 8);
                    }

                    *(void *)(*(void *)a5 + 8 * v140) = v139;
                    ++*(_DWORD *)(a5 + 8);
                  }
                }

    uint64_t v22 = 0LL;
LABEL_56:
    uint64_t v19 = v12 + 1;
    LODWORD(v11) = *((unsigned __int8 *)v5 + 18);
    ++v12;
  }

  if ((v11 - 1) >= 2)
  {
    unint64_t v24 = 0;
    uint64_t v25 = *(swift::Demangle::__runtime::Node **)v5;
  }

  else
  {
    unint64_t v24 = 1;
    uint64_t v25 = v5;
  }

  if (*(_WORD *)(*((void *)v25 + v19) + 16LL) != 68)
  {
    uint64_t v28 = -100;
    uint64_t v29 = v5;
    if ((v24 & 1) != 0) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }

  uint64_t v26 = v5;
  if ((v24 & 1) == 0) {
    uint64_t v26 = *(swift::Demangle::__runtime::Node **)v5;
  }
  unint64_t v27 = **((_BYTE **)v26 + v19);
  uint64_t v19 = v12 + 1;
  uint64_t v28 = v27 - 100;
  ++v12;
  uint64_t v29 = v5;
  if ((v24 & 1) == 0) {
LABEL_66:
  }
    uint64_t v29 = *(swift::Demangle::__runtime::Node **)v5;
LABEL_67:
  if (*(_WORD *)(*((void *)v29 + v19) + 16LL) == 349)
  {
    if ((_DWORD)v11 == 1)
    {
      if (!v19) {
        goto LABEL_76;
      }
    }

    else
    {
      if ((_DWORD)v11 != 5)
      {
        if ((_DWORD)v11 != 2 || v19 >= 2) {
          goto LABEL_74;
        }
LABEL_76:
        uint64_t v31 = v5;
        if ((v24 & 1) == 0) {
          uint64_t v31 = *(swift::Demangle::__runtime::Node **)v5;
        }
        uint64_t v30 = (swift::Demangle::__runtime::Node *)*((void *)v31 + v19);
        goto LABEL_79;
      }
    }

  std::string::push_back((std::string *)this, 62);
LABEL_52:
  if (!v9) {
    return;
  }
  std::string::append((std::string *)this, " for <", 6uLL);
  uint64_t v20 = *((unsigned __int8 *)v9 + 18);
  if ((v20 - 1) >= 2)
  {
    if (v20 != 5 || !*((_DWORD *)v9 + 2)) {
      goto LABEL_73;
    }
    uint64_t v9 = (swift::Demangle::__runtime::Node **)*v9;
  }

  uint64_t v21 = *v9;
  if (*v9)
  {
    uint64_t v22 = *((unsigned __int8 *)v21 + 18);
    uint64_t v23 = (swift::Demangle::__runtime::Node **)*v9;
    if ((v22 - 1) >= 2)
    {
      if (v22 == 5)
      {
        unint64_t v24 = *(swift::Demangle::__runtime::Node ***)v21;
        uint64_t v23 = *(swift::Demangle::__runtime::Node ***)v21;
LABEL_66:
        uint64_t v25 = &v24[*((unsigned int *)v21 + 2)];
        goto LABEL_70;
      }

      uint64_t v23 = 0LL;
    }

    switch(v22)
    {
      case 1:
        uint64_t v25 = (swift::Demangle::__runtime::Node **)((char *)v21 + 8);
        break;
      case 2:
        uint64_t v25 = (swift::Demangle::__runtime::Node **)((char *)v21 + 16);
        break;
      case 5:
        unint64_t v24 = *(swift::Demangle::__runtime::Node ***)v21;
        goto LABEL_66;
      default:
        uint64_t v25 = 0LL;
        break;
    }

LABEL_131:
            uint64_t v146 = _StringGuts.nativeCapacity.getter(v105, v3);
            if ((v147 & 1) != 0) {
              uint64_t v148 = 0LL;
            }
            else {
              uint64_t v148 = v146;
            }
            if (v148 + 0x4000000000000000LL < 0) {
              goto LABEL_255;
            }
            uint64_t v149 = 2 * v148;
            if (v149 > v113) {
              Swift::Int v113 = v149;
            }
          }

          else if ((v4 & 1) == 0)
          {
            goto LABEL_131;
          }

          _StringGuts.grow(_:)(v113);
          goto LABEL_138;
        }

        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
LABEL_99:
        unint64_t v119 = v3;
      }

      else
      {
        if (v113 > 15) {
          goto LABEL_118;
        }
LABEL_98:
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        if ((v3 & 0x2000000000000000LL) != 0) {
          goto LABEL_99;
        }
        if ((v3 & 0x1000000000000000LL) != 0)
        {
          uint64_t v105 = _StringGuts._foreignConvertedToSmall()(v105, v3);
          unint64_t v119 = v164;
        }

        else
        {
          if ((v105 & 0x1000000000000000LL) != 0)
          {
            char v158 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            char v158 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v105, v3);
            uint64_t v4 = v116;
          }

          swift_bridgeObjectRetain(v3, v116, v117, v118);
          closure #1 in _StringGuts._convertedToSmall()(v158, v4, &v246);
          swift_bridgeObjectRelease(v3);
          unint64_t v119 = *((void *)&v246 + 1);
          uint64_t v105 = v246;
        }
      }

      v120._rawBits = 1LL;
      v121._rawBits = 131073LL;
      v122._rawBits = _StringGuts.validateScalarRange(_:)(v120, v121, 0x203AuLL, 0xE200000000000000LL);
      if (v122._rawBits < 0x10000) {
        v122._rawBits |= 3;
      }
      unint64_t v124 = specialized String.init(_:)(v122, v123, 0x203AuLL, 0xE200000000000000LL);
      unint64_t v126 = v125;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      if ((v126 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v126);
      }

      else if ((v126 & 0x1000000000000000LL) != 0)
      {
        unint64_t v124 = _StringGuts._foreignConvertedToSmall()(v124, v126);
        unint64_t v163 = v162;
        swift_bridgeObjectRelease(v126);
        unint64_t v126 = v163;
      }

      else
      {
        if ((v124 & 0x1000000000000000LL) != 0)
        {
          unint64_t v156 = (unsigned __int8 *)((v126 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v157 = v124 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          unint64_t v156 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v124, v126);
        }

        closure #1 in _StringGuts._convertedToSmall()(v156, v157, &v246);
        swift_bridgeObjectRelease(v126);
        unint64_t v126 = *((void *)&v246 + 1);
        unint64_t v124 = v246;
      }

      uint64_t v127 = HIBYTE(v119) & 0xF;
      uint64_t v128 = HIBYTE(v126) & 0xF;
      uint64_t v129 = v128 + v127;
      if (v128)
      {
        char v130 = 0;
        unint64_t v131 = 0LL;
        do
        {
          unint64_t v132 = v127 + v131;
          unint64_t v133 = v131 + 1;
          if (v131 >= 8) {
            unint64_t v134 = v126;
          }
          else {
            unint64_t v134 = v124;
          }
          unint64_t v135 = v134 >> (v130 & 0x38);
          char v136 = (8 * v127 + v130) & 0x38;
          uint64_t v137 = (-255LL << v136) - 1;
          unint64_t v138 = (unint64_t)v135 << v136;
          unint64_t v139 = v138 | v137 & v119;
          unint64_t v140 = v138 | v137 & v105;
          if (v132 < 8) {
            uint64_t v105 = v140;
          }
          else {
            unint64_t v119 = v139;
          }
          v130 += 8;
          unint64_t v131 = v133;
        }

        while (v128 != v133);
      }

      swift_bridgeObjectRelease(v3);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v141 = 0xE000000000000000LL;
      if (v105 & 0x8080808080808080LL | v119 & 0x80808080808080LL) {
        unint64_t v141 = 0xA000000000000000LL;
      }
      unint64_t v38 = v141 & 0xFF00000000000000LL | (v129 << 56) | v119 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v247 = v105;
LABEL_14:
      unint64_t v248 = v38;
LABEL_15:
      uint64_t v16 = v231;
      goto LABEL_16;
    }

    unint64_t v108 = 8 * (HIBYTE(v248) & 7);
    uint64_t v109 = (-255LL << v108) - 1;
    uint64_t v110 = 58LL << v108;
    char v111 = v106 + 1;
    if (v106 >= 8)
    {
      uint64_t v112 = v110 | v109 & v248;
      uint64_t v16 = v231;
    }

    else
    {
      uint64_t v105 = v110 | v109 & v247;
      uint64_t v16 = v231;
      if (v106 != 7)
      {
        uint64_t v105 = (32LL << (8 * (v111 & 7u))) | ((-255LL << (8 * (v111 & 7u))) - 1) & v105;
        uint64_t v145 = v248;
        goto LABEL_140;
      }

      char v111 = 8;
      uint64_t v112 = v248;
    }

    uint64_t v145 = (32LL << (8 * (v111 & 7u))) | ((-255LL << (8 * (v111 & 7u))) - 1) & v112;
LABEL_140:
    swift_bridgeObjectRelease(v248);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v152 = 0xE000000000000000LL;
    if (v105 & 0x8080808080808080LL | v145 & 0x80808080808080LL) {
      unint64_t v152 = 0xA000000000000000LL;
    }
    uint64_t v247 = v105;
    unint64_t v248 = (v152 & 0xFF00000000000000LL | (v106 << 56) | v145 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
LABEL_16:
    uint64_t v4 = (uint64_t)swift_initStackObject(v100, v244);
    *(_OWORD *)(v4 + 16) = v241;
    unint64_t v3 = (unint64_t)v235;
    *(void *)(v4 + 56) = v235;
    unint64_t v39 = (char *)__swift_allocate_boxed_opaque_existential_0Tm((void *)(v4 + 32));
    v239(v39, v242, v3);
    specialized _debugPrint<A>(_:separator:terminator:to:)( v4,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v247);
    swift_bridgeObjectRelease(v4);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    char v37 = 0;
    uint64_t v26 = v240;
  }

  outlined consume of [A : B].Iterator._Variant<A, B>(v234);
  uint64_t v26 = v247;
  uint64_t v4 = v248;
  unint64_t v3 = HIBYTE(v248) & 0xF;
  uint64_t v36 = v247 & 0xFFFFFFFFFFFFLL;
  if ((v248 & 0x2000000000000000LL) != 0) {
    unint64_t v170 = HIBYTE(v248) & 0xF;
  }
  else {
    unint64_t v170 = v247 & 0xFFFFFFFFFFFFLL;
  }
  if (!v170 && (v247 & ~v248 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v248);
    unint64_t v248 = 0xE100000000000000LL;
    return 93LL;
  }

  if ((v248 & 0x2000000000000000LL) == 0 || v3 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v168, v169);
    if ((v4 & 0x1000000000000000LL) != 0) {
      goto LABEL_256;
    }
    BOOL v65 = __OFADD__(v170, 1LL);
    uint64_t v179 = v170 + 1;
    if (v65) {
      goto LABEL_258;
    }
LABEL_202:
    uint64_t v180 = v26 & ~v4;
    if ((v180 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v181 = _StringGuts.nativeUnusedCapacity.getter(v26, v4);
      if ((v182 & 1) != 0)
      {
LABEL_269:
        unint64_t v221 = 258LL;
LABEL_270:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v221,  0);
      }

      if (v179 > 15) {
        goto LABEL_208;
      }
      if ((v4 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        goto LABEL_220;
      }

      if (v181 > 0)
      {
LABEL_208:
        int64_t v183 = _StringGuts.nativeUnusedCapacity.getter(v26, v4);
        BOOL v186 = (v184 & 1) == 0 && v183 > 0;
        if ((v180 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v186) {
            goto LABEL_247;
          }
        }

        else if (v186)
        {
LABEL_246:
          _StringGuts.grow(_:)(v179);
LABEL_247:
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          __int128 v246 = xmmword_1817FFC80;
          uint64_t v214 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v246, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v214, v215, 1);
          swift_bridgeObjectRelease(0xE100000000000000LL);
          return v247;
        }

        uint64_t v210 = _StringGuts.nativeCapacity.getter(v26, v4);
        if ((v211 & 1) != 0) {
          uint64_t v212 = 0LL;
        }
        else {
          uint64_t v212 = v210;
        }
        if (v212 + 0x4000000000000000LL >= 0)
        {
          uint64_t v213 = 2 * v212;
          if (v213 > v179) {
            uint64_t v179 = v213;
          }
          goto LABEL_246;
        }

        __break(1u);
        goto LABEL_268;
      }
    }

    else if (v179 > 15)
    {
      goto LABEL_208;
    }

    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    if ((v4 & 0x2000000000000000LL) == 0)
    {
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        uint64_t v26 = _StringGuts._foreignConvertedToSmall()(v26, v4);
        uint64_t v36 = v224;
      }

      else
      {
        if ((v26 & 0x1000000000000000LL) != 0)
        {
          BOOL v220 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          BOOL v220 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v26, v4);
          uint64_t v36 = v187;
        }

        swift_bridgeObjectRetain(v4, v187, v188, v189);
        closure #1 in _StringGuts._convertedToSmall()(v220, v36, &v246);
        swift_bridgeObjectRelease(v4);
        uint64_t v36 = *((void *)&v246 + 1);
        uint64_t v26 = v246;
      }

      goto LABEL_221;
    }

LABEL_220:
    uint64_t v36 = v4;
LABEL_221:
    v190._rawBits = 65537LL;
    v191._rawBits = 1LL;
    v192._rawBits = _StringGuts.validateScalarRange(_:)(v191, v190, 0x5DuLL, 0xE100000000000000LL);
    if (v192._rawBits < 0x10000) {
      v192._rawBits |= 3;
    }
    unint64_t v3 = specialized String.init(_:)(v192, v193, 0x5DuLL, 0xE100000000000000LL);
    uint64_t v179 = v194;
    swift_bridgeObjectRelease(0xE100000000000000LL);
    if ((v179 & 0x2000000000000000LL) == 0) {
      goto LABEL_259;
    }
    swift_bridgeObjectRelease(v179);
LABEL_225:
    uint64_t v195 = HIBYTE(v36) & 0xF;
    uint64_t v196 = HIBYTE(v179) & 0xF;
    uint64_t v197 = v196 + v195;
    if ((unint64_t)(v196 + v195) <= 0xF)
    {
      if (v196)
      {
        char v198 = 0;
        unint64_t v199 = 0LL;
        do
        {
          unint64_t v200 = v195 + v199;
          unint64_t v201 = v199 + 1;
          if (v199 >= 8) {
            unint64_t v202 = v179;
          }
          else {
            unint64_t v202 = v3;
          }
          unint64_t v203 = v202 >> (v198 & 0x38);
          char v204 = (8 * v195 + v198) & 0x38;
          uint64_t v205 = (-255LL << v204) - 1;
          unint64_t v206 = (unint64_t)v203 << v204;
          unint64_t v207 = v206 | v205 & v36;
          unint64_t v208 = v206 | v205 & v26;
          if (v200 < 8) {
            uint64_t v26 = v208;
          }
          else {
            uint64_t v36 = v207;
          }
          v198 += 8;
          unint64_t v199 = v201;
        }

        while (v196 != v201);
      }

      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      unint64_t v209 = 0xA000000000000000LL;
      if (!(v26 & 0x8080808080808080LL | v36 & 0x80808080808080LL)) {
        unint64_t v209 = 0xE000000000000000LL;
      }
      unint64_t v178 = v209 & 0xFF00000000000000LL | (v197 << 56) | v36 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_238;
    }

LABEL_268:
    unint64_t v221 = 266LL;
    goto LABEL_270;
  }

  unint64_t v171 = 8 * (HIBYTE(v248) & 7);
  uint64_t v172 = (-255LL << v171) - 1;
  uint64_t v173 = 93LL << v171;
  uint64_t v174 = v173 | v172 & v248;
  uint64_t v175 = v173 | v172 & v247;
  if (v3 >= 8) {
    unint64_t v176 = v174;
  }
  else {
    unint64_t v176 = v248;
  }
  if (v3 < 8) {
    uint64_t v26 = v175;
  }
  swift_bridgeObjectRelease(v248);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  unint64_t v177 = 0xA000000000000000LL;
  if (!(v26 & 0x8080808080808080LL | v176 & 0x80808080808080LL)) {
    unint64_t v177 = 0xE000000000000000LL;
  }
  unint64_t v178 = (v177 & 0xFF00000000000000LL | (v3 << 56) | v176 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL;
LABEL_238:
  unint64_t v248 = v178;
  return v26;
}

                        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
                      }

uint64_t Dictionary.debugDescription.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for Dictionary(0LL, a2, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A : B], v6, v7);
  return specialized Collection._makeKeyValuePairDescription<A, B>(withTypeName:)(v6, a2, a3, WitnessTable);
}

uint64_t static _MergeError.== infix(_:_:)()
{
  return 1LL;
}

void _MergeError.hash(into:)()
{
}

void protocol witness for Hashable.hash(into:) in conformance _MergeError()
{
}

uint64_t protocol witness for Error._domain.getter in conformance _MergeError(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError( a1,  a2,  &demangling cache variable for type metadata for _MergeError.Type);
}

uint64_t Error._domain.getter(uint64_t *a1)
{
  v5[0] = 0LL;
  v5[1] = 0xE000000000000000LL;
  unint64_t DynamicType = swift_getDynamicType(v1, a1, 0);
  MetatypeMetadata = (swift *)swift_getMetatypeMetadata((uint64_t)a1);
  _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)&DynamicType,  (uint64_t)v5,  MetatypeMetadata,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  return v5[0];
}

uint64_t protocol witness for Error._code.getter in conformance _MergeError(void *a1)
{
  return _swift_stdlib_getDefaultErrorCode((uint64_t)a1, a1);
}

uint64_t Error._code.getter(void *a1)
{
  return _swift_stdlib_getDefaultErrorCode(v1, a1);
}

uint64_t protocol witness for Error._userInfo.getter in conformance _MergeError(uint64_t a1, uint64_t a2)
{
  return _swift_stdlib_getErrorDefaultUserInfo(a1, a1, a2);
}

uint64_t Error._userInfo.getter(uint64_t a1, uint64_t a2)
{
  return _swift_stdlib_getErrorDefaultUserInfo(v2, a1, a2);
}

unint64_t Dictionary.Index._variant.getter(unint64_t a1, uint64_t a2, char a3, char *a4)
{
  return a1;
}

uint64_t Dictionary.Index._variant.setter(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  return Dictionary.Index._variant.setter( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))outlined consume of [A : B].Index._Variant<A, B>);
}

uint64_t (*Dictionary.Index._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

  ;
}

  ;
}

  ;
}

uint64_t Dictionary.Index._guaranteedNative.getter()
{
  return 0LL;
}

Swift::Bool __swiftcall Dictionary.Index._isUniquelyReferenced()()
{
  if ((*(_BYTE *)(v0 + 16) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  uint64_t v2 = *(void *)v0;
  uint64_t v1 = *(void *)(v0 + 8);
  else {
    uint64_t v3 = *(void *)v0;
  }
  uint64_t v4 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v2, v5, v6, v7);
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  Swift::Bool v8 = 1;
  outlined consume of [A : B].Index._Variant<A, B>(v2, v1, 1);
  if (v3) {
    return swift_isUniquelyReferenced_nonNull_native(v3);
  }
  return v8;
}

unint64_t Dictionary.Index._asCocoa.getter(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a3 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x73AuLL,  0);
  }
  return swift_bridgeObjectRetain(a1, a2, a3, a4);
}

uint64_t __CocoaDictionary.Index.handleBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return __CocoaDictionary.Index.handleBitPattern.getter( a1,  a2,  type metadata accessor for __CocoaDictionary.Index.Storage);
}

BOOL Dictionary.Index._isNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  return (a3 & 1) == 0;
}

void Dictionary.Index._asNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x72DuLL,  0);
  }
}

uint64_t (*Dictionary.Index._asCocoa.modify(void *a1))(void)
{
  a1[2] = v1;
  if (*(_BYTE *)(v1 + 16) != 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x742uLL,  0);
  }
  uint64_t v2 = *(void *)(v1 + 8);
  *a1 = *(void *)v1;
  a1[1] = v2;
  *(_BYTE *)(v1 + 16) = 0;
  *(void *)uint64_t v1 = 0LL;
  *(void *)(v1 + 8) = 0LL;
  return Dictionary.Index._asCocoa.modify;
}

void Dictionary.Index._asCocoa.setter(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(v2 + 16) != 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x742uLL,  0);
  }
  outlined consume of [A : B].Index._Variant<A, B>(*(void *)v2, *(void *)(v2 + 8), 1);
  *(void *)uint64_t v2 = a1;
  *(void *)(v2 + 8) = a2;
  *(_BYTE *)(v2 + 16) = 1;
}

BOOL static Dictionary.Index.== infix(_:_:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v7 = a4;
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0)
    {
      if ((_DWORD)a2 != (_DWORD)a5) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xD5uLL,  0);
      }
      return a1 == a4;
    }

BOOL static _HashTable.Index.== infix(_:_:)(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a2 != a4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xD5uLL,  0);
  }
  return a1 == a3;
}

BOOL static Dictionary.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v7 = a4;
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0)
    {
      if ((_DWORD)a2 != (_DWORD)a5) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xE2uLL,  0);
      }
      return a1 < a4;
    }

BOOL static _HashTable.Index.< infix(_:_:)(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a2 != a4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xE2uLL,  0);
  }
  return a1 < a3;
}

void Dictionary.Index.hash(into:)(uint64_t a1, Swift::UInt a2, Swift::UInt a3, char a4)
{
  if ((a4 & 1) != 0) {
    a2 = a3;
  }
  Hasher._combine(_:)(a4 & 1);
  Hasher._combine(_:)(a2);
}

Swift::Int Dictionary.Index.hashValue.getter(Swift::UInt a1, Swift::UInt a2, char a3)
{
  if ((a3 & 1) != 0) {
    a1 = a2;
  }
  Hasher._combine(_:)(a3 & 1);
  Hasher._combine(_:)(a1);
  return Hasher._finalize()();
}

uint64_t Dictionary.Iterator._variant.getter@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for Dictionary.Iterator._Variant(0LL, a1[2], a1[3], a1[4]);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, v2, v4);
}

__n128 Dictionary.Iterator._variant.setter(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = type metadata accessor for Dictionary.Iterator._Variant(0LL, a2[2], a2[3], a2[4]);
  (*(void (**)(_OWORD *, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(v9, a1, v4);
  __n128 v7 = (__n128)v9[1];
  __n128 v8 = (__n128)v9[0];
  unint64_t v5 = v10;
  outlined consume of [A : B].Iterator._Variant<A, B>(v2->n128_u64[0]);
  __n128 result = v7;
  __n128 *v2 = v8;
  v2[1] = v7;
  v2[2].n128_u64[0] = v5;
  return result;
}

uint64_t (*Dictionary.Iterator._variant.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

double Dictionary.Iterator.init(_variant:)@<D0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = type metadata accessor for Dictionary.Iterator._Variant(0LL, a2, a3, a4);
  (*(void (**)(_OWORD *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(v11, a1, v7);
  uint64_t v8 = v12;
  double result = *(double *)v11;
  __int128 v10 = v11[1];
  *(_OWORD *)a5 = v11[0];
  *(_OWORD *)(a5 + 16) = v10;
  *(void *)(a5 + 32) = v8;
  return result;
}

__n128 Dictionary.Iterator.init(_native:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __n128 result = *(__n128 *)a1;
  __int128 v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = v2;
  return result;
}

double Dictionary.Iterator.init(_cocoa:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = a1 | 0x8000000000000000LL;
  double result = 0.0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  return result;
}

uint64_t Dictionary.Iterator._guaranteedNative.getter()
{
  return 0LL;
}

BOOL Dictionary.Iterator._isNative.getter(uint64_t *a1)
{
  uint64_t v2 = type metadata accessor for Dictionary.Iterator._Variant(0LL, a1[2], a1[3], a1[4]);
  uint64_t v3 = *(void (**)(_BYTE *, uint64_t, uint64_t))(*(void *)(v2 - 8) + 32LL);
  v3(v5, v1, v2);
  v3(v6, (uint64_t)v5, v2);
  return v6[0] >= 0LL;
}

void (*Dictionary.Iterator._asNative.modify( void *a1))(unint64_t ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v3 = malloc(0x30uLL);
  *a1 = v3;
  uint64_t v4 = *((void *)v1 + 4);
  __int128 v5 = *v1;
  __int128 v6 = v1[1];
  *uint64_t v3 = *v1;
  v3[1] = v6;
  *((void *)v3 + 4) = v4;
  *((void *)v3 + 5) = v1;
  swift_retain((unint64_t *)v5, v7, v8, v9);
  return Dictionary.Iterator._asNative.modify;
}

void Dictionary.Iterator._asNative.modify(unint64_t ***a1, uint64_t a2, uint64_t a3, char *a4)
{
}

unint64_t *Dictionary.Iterator._asCocoa.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain((unint64_t *)(*v4 & 0x7FFFFFFFFFFFFFFFLL), a2, a3, a4);
}

uint64_t _NativeDictionary.Iterator.next()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = result;
  unint64_t v5 = v2[4];
  if (v5)
  {
    v2[4] = (v5 - 1) & v5;
    unint64_t v6 = __clz(__rbit64(v5)) | (v2[3] << 6);
LABEL_3:
    uint64_t v7 = *v2;
    uint64_t v8 = *(void *)(*v2 + 48LL);
    uint64_t v9 = *(void *)(result + 16);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)(v9 - 8) + 16LL))( a2,  v8 + *(void *)(*(void *)(v9 - 8) + 72LL) * v6,  v9);
    uint64_t v10 = *(void *)(v7 + 56);
    uint64_t v11 = *(void *)(v3 + 24);
    uint64_t v12 = *(void *)(v11 - 8);
    uint64_t v13 = v10 + *(void *)(v12 + 72) * v6;
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v11, "key value ", 0LL);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a2 + *((int *)TupleTypeMetadata2 + 12), v13, v11);
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 56);
    uint64_t v16 = a2;
    uint64_t v17 = 0LL;
    uint64_t v18 = TupleTypeMetadata2;
    return v15(v16, v17, 1LL, v18);
  }

  uint64_t v19 = v2[3];
  int64_t v20 = v19 + 1;
  if (!__OFADD__(v19, 1LL))
  {
    int64_t v21 = (unint64_t)(v2[2] + 64LL) >> 6;
    if (v20 < v21)
    {
      v2[3] = v20;
      uint64_t v22 = v2[1];
      unint64_t v23 = *(void *)(v22 + 8 * v20);
      v2[4] = v23;
      if (v23)
      {
LABEL_11:
        v2[4] = (v23 - 1) & v23;
        unint64_t v6 = __clz(__rbit64(v23)) + (v20 << 6);
        goto LABEL_3;
      }

      uint64_t v24 = v19 + 2;
      while (v21 != v24)
      {
        v2[3] = v24;
        unint64_t v23 = *(void *)(v22 + 8 * v24);
        v2[4] = v23;
        ++v24;
        if (v23)
        {
          int64_t v20 = v24 - 1;
          goto LABEL_11;
        }
      }
    }

    uint64_t v18 = swift_getTupleTypeMetadata2(0LL, *(void *)(result + 16), *(void *)(result + 24), "key value ", 0LL);
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(*(v18 - 1) + 56);
    uint64_t v16 = a2;
    uint64_t v17 = 1LL;
    return v15(v16, v17, 1LL, v18);
  }

  __break(1u);
  return result;
}

uint64_t Dictionary.Iterator.customMirror.getter@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v5 = *(_OWORD *)(v2 + 16);
  v8[0] = *(_OWORD *)v2;
  v8[1] = v5;
  uint64_t v9 = *(void *)(v2 + 32);
  uint64_t v6 = type metadata accessor for Dictionary.Iterator._Variant(0LL, a1[2], a1[3], a1[4]);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v6 - 8) + 32LL))(v10, v2, v6);
  outlined retain of [A : B].Iterator._Variant( v10,  (void (*)(void, void, void, void, void))outlined copy of [A : B].Iterator._Variant<A, B>);
  return specialized Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)( (uint64_t)v8,  8,  0LL,  0LL,  (swift *)a1,  a2);
}

uint64_t specialized Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, int a2@<W1>, unint64_t a3@<X2>, uint64_t a4@<X3>, swift *a5@<X4>, uint64_t a6@<X8>)
{
  HIDWORD(v29) = a2;
  uint64_t v11 = *((void *)a5 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (uint64_t *)((char *)&v30[-1] - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  v30[0] = v15;
  v30[1] = v16;
  uint64_t v18 = static Mirror._superclassIterator<A>(_:_:)(v12, (uint64_t)v30, v17);
  uint64_t v20 = v19;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v21 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<EmptyCollection<(label: String?, value: Any)>>);
  uint64_t v22 = swift_allocObject(v21, 0x30uLL, 7uLL);
  uint64_t v23 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v24 = swift_allocObject(v23, 0x18uLL, 7uLL);
  v24[2] = 0LL;
  uint64_t v25 = swift_allocObject(v23, 0x18uLL, 7uLL);
  v25[2] = 0LL;
  v22[2] = v24;
  v22[3] = &protocol witness table for _IndexBox<A>;
  v22[4] = v25;
  v22[5] = &protocol witness table for _IndexBox<A>;
  (*(void (**)(uint64_t *, uint64_t, swift *))(v11 + 32))(v14, a1, a5);
  uint64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v30, v14, a5, v26, 6uLL);
  char v28 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v30);
  }
  *(void *)a6 = a5;
  *(void *)(a6 + 8) = v22;
  *(_BYTE *)(a6 + 16) = BYTE4(v29);
  *(void *)(a6 + 24) = v18;
  *(void *)(a6 + 32) = v20;
  *(_BYTE *)(a6 + 40) = v28;
  return result;
}

uint64_t Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 *a3@<X2>, unint64_t *a4@<X3>, swift *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, swift **a8@<X8>)
{
  id v44 = a5;
  uint64_t v45 = a1;
  uint64_t v51 = a8;
  uint64_t v49 = *((void *)a5 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v46 = (uint64_t *)((char *)&v43 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  v16,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v43 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v20 = (char *)&v43 - v19;
  int v50 = *a3;
  unint64_t v21 = *a4;
  uint64_t v22 = a4[1];
  v52[0] = v21;
  v52[1] = v22;
  uint64_t v23 = static Mirror._superclassIterator<A>(_:_:)(a1, (uint64_t)v52, a5);
  uint64_t v47 = v24;
  uint64_t v48 = v23;
  outlined consume of Mirror.AncestorRepresentation(v21, v22);
  uint64_t v26 = type metadata accessor for _CollectionBox(0LL, a6, a7, v25);
  unint64_t v27 = (char *)swift_allocObject(v26, *(unsigned int *)(v26 + 48), *(unsigned __int16 *)(v26 + 52));
  uint64_t v28 = *(void *)(a6 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v28 + 16))(&v27[*(void *)(*(void *)v27 + 360LL)], a2, a6);
  (*(void (**)(uint64_t, uint64_t))(a7 + 64))(a6, a7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  a6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v31 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v30);
  unint64_t v32 = (char *)swift_allocObject(v31, *(unsigned int *)(v31 + 48), *(unsigned __int16 *)(v31 + 52));
  uint64_t v33 = *(void (**)(char *, char *, unint64_t))(v43 + 32);
  v33(&v32[*(void *)(*(void *)v32 + 96LL)], v20, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(a7 + 72))(a6, a7);
  (*(void (**)(uint64_t, uint64_t))(v28 + 8))(a2, a6);
  uint64_t v34 = (char *)swift_allocObject(v31, *(unsigned int *)(v31 + 48), *(unsigned __int16 *)(v31 + 52));
  v33(&v34[*(void *)(*(void *)v34 + 96LL)], v20, AssociatedTypeWitness);
  uint64_t v36 = v44;
  uint64_t v35 = v45;
  *((void *)v27 + 2) = v32;
  *((void *)v27 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v27 + 4) = v34;
  *((void *)v27 + 5) = &protocol witness table for _IndexBox<A>;
  char v37 = v46;
  (*(void (**)(uint64_t *, uint64_t, swift *))(v49 + 32))(v46, v35, v36);
  unint64_t v38 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v52, v37, v36, v38, 6uLL);
  char v40 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v52);
  }
  unint64_t v41 = v51;
  *uint64_t v51 = v36;
  v41[1] = (swift *)v27;
  *((_BYTE *)v41 + 16) = v50;
  uint64_t v42 = v47;
  v41[3] = (swift *)v48;
  v41[4] = v42;
  *((_BYTE *)v41 + 40) = v40;
  return result;
}

uint64_t Dictionary.customMirror.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, swift **a5@<X8>)
{
  uint64_t v15 = a1;
  uint64_t v16 = a1;
  unsigned __int8 v14 = 6;
  v13[0] = 0LL;
  v13[1] = 0LL;
  uint64_t v7 = (swift *)type metadata accessor for Dictionary(0LL, a2, a3, a4);
  swift_bridgeObjectRetain_n(a1, 2LL, v8, v9);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A : B], v7, v10);
  return Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( (uint64_t)&v16,  (uint64_t)&v15,  &v14,  v13,  v7,  (uint64_t)v7,  WitnessTable,  a5);
}

uint64_t Dictionary.popFirst()@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v6 = a1[2];
  if ((*v2 & 0xC000000000000001LL) != 0)
  {
    if (v5 < 0) {
      uint64_t v7 = (void *)*v2;
    }
    else {
      uint64_t v7 = (void *)(v5 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v8 = objc_msgSend(v7, sel_count);
  }

  else
  {
    id v8 = *(id *)(v5 + 16);
  }

  uint64_t v9 = a1[3];
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v6, v9, "key value ", 0LL);
  uint64_t v11 = TupleTypeMetadata2;
  if (v8)
  {
    uint64_t v12 = a2 + *((int *)TupleTypeMetadata2 + 12);
    uint64_t v13 = a1[4];
    uint64_t v14 = Dictionary.startIndex.getter(v5);
    uint64_t v16 = v15;
    char v18 = v17 & 1;
    uint64_t v19 = type metadata accessor for Dictionary._Variant(0LL, v6, v9, v13);
    Dictionary._Variant.remove(at:)(a2, v12, v14, v16, v18, v19);
    outlined consume of [A : B].Index._Variant<A, B>(v14, v16, v18);
    uint64_t v20 = 0LL;
  }

  else
  {
    uint64_t v20 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(*(v11 - 1) + 56))(a2, v20, 1LL, v11);
}

id Dictionary.capacity.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 24);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

id Dictionary._Variant.capacity.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 24);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

Swift::Void __swiftcall Dictionary.reserveCapacity(_:)(Swift::Int a1)
{
}

Swift::Void __swiftcall Dictionary._Variant.reserveCapacity(_:)(Swift::Int a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v6 = *v2;
  id v8 = *(char **)(v1 + 16);
  uint64_t v7 = *(uint64_t **)(v1 + 24);
  if ((v6 & 0xC000000000000001LL) != 0)
  {
    if (v6 < 0) {
      uint64_t v9 = (void *)v6;
    }
    else {
      uint64_t v9 = (void *)(v6 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v10 = objc_msgSend(v9, sel_count);
    else {
      Swift::Int v11 = (Swift::Int)v10;
    }
    *uint64_t v3 = (uint64_t)_NativeDictionary.init(_:capacity:)(v9, v11, v8, v7, *(void *)(v4 + 32));
  }

  else
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v6);
    BOOL v13 = isUniquelyReferenced_nonNull_native;
    uint64_t v16 = *v3;
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    if (*(void *)(v14 + 24) >= a1)
    {
      if (!isUniquelyReferenced_nonNull_native)
      {
        type metadata accessor for _NativeDictionary(0LL, (uint64_t)v8, (uint64_t)v7, *(void *)(v4 + 32));
        _NativeDictionary.copy()();
      }
    }

    else
    {
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v8, (uint64_t)v7, *(void *)(v4 + 32));
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(a1, v13);
    }

    uint64_t v15 = *v3;
    *uint64_t v3 = v16;
    swift_bridgeObjectRelease(v15);
  }

__objc2_class **_NativeDictionary.bridged()(__objc2_class **a1, uint64_t *a2, void *a3, uint64_t a4)
{
  if (one-time initialization token for _bridgeInitializedSuccessfully != -1) {
    swift_once( &one-time initialization token for _bridgeInitializedSuccessfully,  (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully,  a3);
  }
  if (!_bridgeInitializedSuccessfully) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0x82uLL,  0);
  }
  _orphanedFoundationSubclassesReparented = 1;
  if (a1 == &_swiftEmptyDictionarySingleton)
  {
    a1 = &_swiftEmptyDictionarySingleton;
    swift_release((uint64_t)&_swiftEmptyDictionarySingleton);
  }

  else if (a1[2])
  {
    if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2)
      && _swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      uint64_t v8 = type metadata accessor for _DictionaryStorage(0LL, (uint64_t)a2, (uint64_t)a3, a4);
      if (!swift_dynamicCastClass((uint64_t)a1, v8)) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
      }
    }

    else
    {
      uint64_t v9 = type metadata accessor for _SwiftDeferredNSDictionary(0LL, (uint64_t)a2, (uint64_t)a3, a4);
      id v10 = swift_allocObject(v9, 0x28uLL, 7uLL);
      v10[2] = 0LL;
      v10[3] = 0LL;
      v10[4] = a1;
      return (__objc2_class **)v10;
    }
  }

  else
  {
    swift_release((uint64_t)a1);
    return &_swiftEmptyDictionarySingleton;
  }

  return a1;
}

__objc2_class **static __RawDictionaryStorage.empty.getter()
{
  return &_swiftEmptyDictionarySingleton;
}

uint64_t _NativeDictionary.count.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void @objc _SwiftDictionaryNSEnumerator.init()()
{
}

uint64_t _NativeDictionary.hashTable.getter(uint64_t a1)
{
  return a1 + 64;
}

unint64_t _HashTable.startBucket.getter(unint64_t *a1, unint64_t a2)
{
  unint64_t result = a2 + 1;
  if (a2 <= 0xFFFFFFFFFFFFFFBFLL)
  {
    unint64_t v4 = *a1;
    if (*a1)
    {
      uint64_t v5 = 0LL;
      return __clz(__rbit64(v4)) + v5;
    }

    unint64_t v6 = a2 + 64;
    if (a2 + 64 >= 0x80)
    {
      unint64_t v4 = a1[1];
      if (v4)
      {
        uint64_t v5 = 64LL;
        return __clz(__rbit64(v4)) + v5;
      }

      uint64_t v7 = v6 >> 6;
      if (v6 >> 6 <= 2) {
        uint64_t v7 = 2LL;
      }
      uint64_t v8 = v7 - 2;
      uint64_t v9 = a1 + 2;
      uint64_t v5 = 64LL;
      while (v8)
      {
        unint64_t v10 = *v9++;
        unint64_t v4 = v10;
        --v8;
        v5 += 64LL;
        if (v10) {
          return __clz(__rbit64(v4)) + v5;
        }
      }
    }
  }

  return result;
}

uint64_t _HashTable.endBucket.getter(uint64_t a1, uint64_t a2)
{
  return a2 + 1;
}

void *_SwiftDictionaryNSEnumerator.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = v4;
  v5[3] = 0LL;
  uint64_t v7 = *(unint64_t **)(a1 + 32);
  void v5[2] = v7;
  uint64_t v8 = swift_retain(v7, a2, a3, a4);
  uint64_t v9 = _SwiftDeferredNSDictionary.bridgeKeys()((uint64_t)v8);
  swift_release(a1);
  uint64_t v10 = v5[3];
  v5[3] = v9;
  swift_release(v10);
  uint64_t v11 = v5[2];
  uint64_t v12 = -1LL << *(_BYTE *)(v11 + 32);
  v5[4] = _HashTable.startBucket.getter((unint64_t *)(v11 + 64), ~v12);
  v5[5] = -v12;
  return v5;
}

void *_SwiftDeferredNSDictionary.bridgeKeys()(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(*v1 + 96);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = *(void *)(v3 + 64);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  MEMORY[0x1895F8858](v5);
  uint64_t v7 = (id *)((char *)&v51 - v6);
  uint64_t v8 = (void *)atomic_load(v1 + 2);
  if (v8)
  {
    unint64_t v9 = type metadata accessor for __BridgingHashBuffer(0LL);
    id v13 = swift_unknownObjectRetain(v8, v10, v11, v12);
    return v8;
  }

  uint64_t v52 = (id *)((char *)&v51 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v56 = v1 + 2;
  uint64_t v14 = v1[4];
  uint64_t v15 = -1LL << *(_BYTE *)(v14 + 32);
  uint64_t v58 = ~v15;
  unint64_t v16 = type metadata accessor for __BridgingHashBuffer(0LL);
  char v17 = swift_allocObject(v16, 40 - 8 * v15, 7uLL);
  v17[2] = v14;
  v17[3] = v14 + 64;
  uint64_t v57 = v14 + 64;
  uint64_t v17[4] = v58;
  swift_retain((unint64_t *)v14, v18, v19, v20);
  unint64_t v53 = v16;
  if (-v15 < 64) {
    uint64_t v23 = ~(-1LL << -(char)v15);
  }
  else {
    uint64_t v23 = -1LL;
  }
  unint64_t v24 = *(void *)(v14 + 64) & v23;
  int64_t v25 = (unint64_t)(63 - v15) >> 6;
  uint64_t v54 = v17;
  uint64_t v55 = v14;
  uint64_t v58 = (uint64_t)(v17 + 5);
  swift_retain_n(v14, 2LL, v21, v22);
  int64_t v26 = 0LL;
  while (1)
  {
    if (v24)
    {
      unint64_t v27 = __clz(__rbit64(v24));
      v24 &= v24 - 1;
      unint64_t v28 = v27 | (v26 << 6);
      goto LABEL_23;
    }

    if (__OFADD__(v26++, 1LL)) {
      goto LABEL_37;
    }
    if (v26 >= v25) {
      break;
    }
    unint64_t v30 = *(void *)(v57 + 8 * v26);
    if (!v30)
    {
      int64_t v31 = v26 + 1;
      if (v26 + 1 >= v25) {
        break;
      }
      unint64_t v30 = *(void *)(v57 + 8 * v31);
      if (!v30)
      {
        while (1)
        {
          int64_t v26 = v31 + 1;
          if (__OFADD__(v31, 1LL)) {
            break;
          }
          if (v26 >= v25) {
            goto LABEL_27;
          }
          unint64_t v30 = *(void *)(v57 + 8 * v26);
          ++v31;
          if (v30) {
            goto LABEL_22;
          }
        }

        __break(1u);
LABEL_37:
        __break(1u);
LABEL_38:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
      }

      ++v26;
    }

Swift::Bool __swiftcall _HashTable.isOccupied(_:)(Swift::_HashTable::Bucket a1)
{
  Swift::Int offset = a1.offset;
  LOBYTE(a1.offset) = 0;
  if ((offset & 0x8000000000000000LL) == 0 && v2 + 1 > offset) {
    a1.Swift::Int offset = (*(void *)(v1 + (((unint64_t)offset >> 3) & 0xFFFFFFFFFFFFF8LL)) >> offset) & 1LL;
  }
  return a1.offset;
}

uint64_t _NativeDictionary.uncheckedKey(at:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  *(void *)(a2 + 48) + *(void *)(*(void *)(a3 - 8) + 72LL) * a1);
}

char *_SwiftDictionaryNSEnumerator.nextObject()()
{
  uint64_t offset = v0[4].offset;
  if (offset == v0[5].offset) {
    return 0LL;
  }
  v0[4].uint64_t offset = _HashTable.occupiedBucket(after:)(v0[4]).offset;
  return _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
}

BOOL static _HashTable.Bucket.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.occupiedBucket(after:)(Swift::_HashTable::Bucket after)
{
  unint64_t v3 = (unint64_t)after.offset >> 6;
  unint64_t v5 = v3 + 1;
  result.uint64_t offset = v2 + 1;
  unint64_t v6 = (unint64_t)(v2 + 64) >> 6;
  if (v3 + 1 < v6)
  {
    unint64_t v7 = *(void *)(v1 + 8 * v5);
    if (v7)
    {
      return (Swift::_HashTable::Bucket)(__clz(__rbit64(v7)) + (v5 << 6));
    }

    else
    {
      unint64_t v8 = v3 + 2;
      while (v6 != v8)
      {
        unint64_t v7 = *(void *)(v1 + 8 * v8++);
        if (v7)
        {
          unint64_t v5 = v8 - 1;
          return (Swift::_HashTable::Bucket)(__clz(__rbit64(v7)) + (v5 << 6));
        }
      }
    }
  }

  return result;
}

id @objc _SwiftDictionaryNSEnumerator.nextObject()(unint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return @objc _SwiftDictionaryNSEnumerator.nextObject()( a1,  a2,  (uint64_t (*)(unint64_t *))_SwiftDictionaryNSEnumerator.nextObject(),  a4);
}

uint64_t @objc _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, char *))specialized _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:));
}

uint64_t @objc _SwiftDictionaryNSEnumerator.init(coder:)(uint64_t a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDictionaryNSEnumerator.init(coder:)( a1,  a2,  a3,  (char *)specialized _SwiftDictionaryNSEnumerator.init(coder:));
}

void @objc _SwiftDeferredNSDictionary.init(objects:forKeys:count:)()
{
}

  ;
}

id _stdlib_atomicLoadARCRef(object:)(unint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  id result = (id)atomic_load(a1);
  if (result) {
    return swift_unknownObjectRetain(result, a2, a3, a4);
  }
  return result;
}

uint64_t _stdlib_atomicInitializeARCRef(object:desired:)( unint64_t *a1, void *a2, uint64_t a3, char *a4)
{
  while (!__ldaxr(a1))
  {
  }

  uint64_t v7 = 0LL;
  __clrex();
  swift_unknownObjectRelease(a2);
  return v7;
}

  ;
}

Swift::_HashTable::Bucket_optional __swiftcall _HashTable.Iterator.next()()
{
  unint64_t v1 = v0[3];
  if (!v1)
  {
    uint64_t v4 = v0[2];
    int64_t v5 = v4 + 1;
    if (__OFADD__(v4, 1LL))
    {
      __break(1u);
      goto LABEL_13;
    }

    int64_t v6 = (unint64_t)(v0[1] + 64) >> 6;
    if (v5 < v6)
    {
      v0[2] = v5;
      uint64_t v7 = *v0;
      unint64_t v8 = *(void *)(*v0 + 8 * v5);
      v0[3] = v8;
      if (v8)
      {
LABEL_10:
        Swift::Bool v2 = 0;
        v0[3] = (v8 - 1) & v8;
        Swift::Int v3 = __clz(__rbit64(v8)) + (v5 << 6);
        goto LABEL_13;
      }

      uint64_t v9 = v4 + 2;
      while (v6 != v9)
      {
        v0[2] = v9;
        unint64_t v8 = *(void *)(v7 + 8 * v9);
        v0[3] = v8;
        ++v9;
        if (v8)
        {
          int64_t v5 = v9 - 1;
          goto LABEL_10;
        }
      }
    }

    Swift::Int v3 = 0LL;
    Swift::Bool v2 = 1;
    goto LABEL_13;
  }

  Swift::Bool v2 = 0;
  v0[3] = (v1 - 1) & v1;
  Swift::Int v3 = __clz(__rbit64(v1)) | (v0[2] << 6);
LABEL_13:
  result.value.uint64_t offset = v3;
  result.is_nil = v2;
  return result;
}

void *_SwiftDeferredNSDictionary.bridgeValues()(uint64_t a1)
{
  Swift::Bool v2 = *(uint64_t **)(*v1 + 104);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = *(void *)(v3 + 64);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  MEMORY[0x1895F8858](v5);
  uint64_t v7 = (id *)((char *)&v51 - v6);
  unint64_t v8 = (void *)atomic_load(v1 + 3);
  if (v8)
  {
    unint64_t v9 = type metadata accessor for __BridgingHashBuffer(0LL);
    id v13 = swift_unknownObjectRetain(v8, v10, v11, v12);
    return v8;
  }

  uint64_t v52 = (id *)((char *)&v51 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v56 = v1 + 3;
  uint64_t v14 = v1[4];
  uint64_t v15 = -1LL << *(_BYTE *)(v14 + 32);
  uint64_t v58 = ~v15;
  unint64_t v16 = type metadata accessor for __BridgingHashBuffer(0LL);
  char v17 = swift_allocObject(v16, 40 - 8 * v15, 7uLL);
  v17[2] = v14;
  v17[3] = v14 + 64;
  uint64_t v57 = v14 + 64;
  uint64_t v17[4] = v58;
  swift_retain((unint64_t *)v14, v18, v19, v20);
  unint64_t v53 = v16;
  if (-v15 < 64) {
    uint64_t v23 = ~(-1LL << -(char)v15);
  }
  else {
    uint64_t v23 = -1LL;
  }
  unint64_t v24 = *(void *)(v14 + 64) & v23;
  int64_t v25 = (unint64_t)(63 - v15) >> 6;
  uint64_t v54 = v17;
  uint64_t v55 = v14;
  uint64_t v58 = (uint64_t)(v17 + 5);
  swift_retain_n(v14, 2LL, v21, v22);
  int64_t v26 = 0LL;
  while (1)
  {
    if (v24)
    {
      unint64_t v27 = __clz(__rbit64(v24));
      v24 &= v24 - 1;
      unint64_t v28 = v27 | (v26 << 6);
      goto LABEL_23;
    }

    if (__OFADD__(v26++, 1LL)) {
      goto LABEL_37;
    }
    if (v26 >= v25) {
      break;
    }
    unint64_t v30 = *(void *)(v57 + 8 * v26);
    if (!v30)
    {
      int64_t v31 = v26 + 1;
      if (v26 + 1 >= v25) {
        break;
      }
      unint64_t v30 = *(void *)(v57 + 8 * v31);
      if (!v30)
      {
        while (1)
        {
          int64_t v26 = v31 + 1;
          if (__OFADD__(v31, 1LL)) {
            break;
          }
          if (v26 >= v25) {
            goto LABEL_27;
          }
          unint64_t v30 = *(void *)(v57 + 8 * v26);
          ++v31;
          if (v30) {
            goto LABEL_22;
          }
        }

        __break(1u);
LABEL_37:
        __break(1u);
LABEL_38:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
      }

      ++v26;
    }

uint64_t _NativeDictionary.uncheckedValue(at:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  *(void *)(a2 + 56) + *(void *)(*(void *)(a3 - 8) + 72LL) * a1,  a3);
}

char *_SwiftDeferredNSDictionary.object(forKey:)(void *a1)
{
  uint64_t v37 = a1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(uint64_t **)(*v1 + 104);
  uint64_t v4 = *(v3 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (id *)((char *)&v36 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v7 = *(char **)(v2 + 96);
  uint64_t v10 = type metadata accessor for Optional(0LL, (uint64_t)v7, v8, v9);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v36 - v13;
  uint64_t v15 = *((void *)v7 - 1);
  MEMORY[0x1895F8858](v12);
  char v17 = (char *)&v36 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  _conditionallyBridgeFromObjectiveC<A>(_:_:)(v37, v7, v18, v14);
  if ((*(unsigned int (**)(char *, uint64_t, char *))(v15 + 48))(v14, 1LL, v7) == 1)
  {
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    return 0LL;
  }

  uint64_t v19 = v6;
  (*(void (**)(char *, char *, char *))(v15 + 32))(v17, v14, v7);
  uint64_t v20 = *(unint64_t **)(v36 + 32);
  uint64_t v21 = *(void *)(v2 + 112);
  swift_retain(v20, v22, v23, v24);
  unint64_t v25 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v17, (uint64_t)v7, v21);
  char v27 = v26;
  swift_release((uint64_t)v20);
  uint64_t v28 = (*(uint64_t (**)(char *, char *))(v15 + 8))(v17, v7);
  if ((v27 & 1) == 0) {
    return 0LL;
  }
  uint64_t v29 = _SwiftDeferredNSDictionary.bridgeValues()(v28);
  if (v29)
  {
    uint64_t v33 = (uint64_t)v29;
    uint64_t v34 = (char *)v29[v25 + 5];
    swift_unknownObjectRetain(v34, v30, v31, v32);
    swift_release(v33);
  }

  else
  {
    (*(void (**)(id *, unint64_t, uint64_t *))(v4 + 16))( v19,  *(void *)(*(void *)(v36 + 32) + 56LL) + *(void *)(v4 + 72) * v25,  v3);
    uint64_t v34 = _bridgeAnythingToObjectiveC<A>(_:)(v19, v3);
    (*(void (**)(id *, uint64_t *))(v4 + 8))(v19, v3);
  }

  return v34;
}

id @objc _SwiftDeferredNSDictionary.object(forKey:)(unint64_t *a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDeferredNSDictionary.object(forKey:)( a1,  a2,  a3,  (char *)_SwiftDeferredNSDictionary.object(forKey:));
}

void *_SwiftDeferredNSDictionary.keyEnumerator()()
{
  unint64_t v1 = *v0;
  uint64_t v2 = *(uint64_t **)(*v0 + 96);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
  {
    unint64_t v3 = v0[4];
    uint64_t v4 = type metadata accessor for _SwiftDictionaryNSEnumerator( 0LL,  (uint64_t)v2,  *(void *)(v1 + 104),  *(void *)(v1 + 112));
    uint64_t v5 = swift_allocObject(v4, 0x30uLL, 7uLL);
    void v5[2] = v3;
    v5[3] = 0LL;
    uint64_t v6 = -1LL << *(_BYTE *)(v3 + 32);
    v5[4] = _HashTable.startBucket.getter((unint64_t *)(v3 + 64), ~v6);
    v5[5] = -v6;
    swift_retain((unint64_t *)v3, v7, v8, v9);
  }

  else
  {
    uint64_t v10 = type metadata accessor for _SwiftDictionaryNSEnumerator( 0LL,  (uint64_t)v2,  *(void *)(v1 + 104),  *(void *)(v1 + 112));
    uint64_t v5 = swift_allocObject(v10, 0x30uLL, 7uLL);
    uint64_t v14 = swift_retain(v0, v11, v12, v13);
    _SwiftDictionaryNSEnumerator.init(_:)((uint64_t)v14, v15, v16, v17);
  }

  return v5;
}

id @objc _SwiftDeferredNSDictionary.keyEnumerator()(unint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return @objc _SwiftDictionaryNSEnumerator.nextObject()( a1,  a2,  (uint64_t (*)(unint64_t *))_SwiftDeferredNSDictionary.keyEnumerator(),  a4);
}

void _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)(uint64_t a1, uint64_t a2, id *a3)
{
  uint64_t v137 = a1;
  unint64_t v138 = (void *)a2;
  uint64_t v5 = *(uint64_t **)(*(void *)v3 + 104LL);
  uint64_t v133 = *(v5 - 1);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (id *)((char *)&v123 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v9 = MEMORY[0x1895F8858](v6);
  uint64_t v11 = (id *)((char *)&v123 - v10);
  uint64_t v129 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v9);
  unint64_t v131 = (id *)((char *)&v123 - v14);
  uint64_t v16 = *(void *)(v15 + 96);
  uint64_t v134 = *(void *)(v16 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v13);
  uint64_t v19 = (id *)((char *)&v123 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (id *)((char *)&v123 - v21);
  uint64_t v130 = v23;
  uint64_t v24 = MEMORY[0x1895F8858](v20);
  char v26 = (id *)((char *)&v123 - v25);
  if (v27 < 0) {
    goto LABEL_99;
  }
  if (!a3) {
    return;
  }
  uint64_t v28 = (uint64_t)_SwiftDeferredNSDictionary.bridgeKeys()(v24);
  unint64_t v139 = (char *)_SwiftDeferredNSDictionary.bridgeValues()(v28);
  unint64_t v140 = a3;
  if (!v138)
  {
    swift_release(v28);
    if (!v137)
    {
      swift_release((uint64_t)v139);
      return;
    }

    unint64_t v124 = v11;
    uint64_t v75 = *(void *)(v135 + 32);
    uint64_t v76 = 1LL << *(_BYTE *)(v75 + 32);
    uint64_t v77 = v75 + 64;
    uint64_t v78 = -1LL;
    if (v76 < 64) {
      uint64_t v78 = ~(-1LL << v76);
    }
    uint64_t v28 = v78 & *(void *)(v75 + 64);
    int64_t v79 = (unint64_t)(v76 + 63) >> 6;
    uint64_t v80 = v139 + 40;
    unint64_t v138 = *(void **)(v135 + 32);
    swift_retain_n(v75, 2LL, v73, v74);
    uint64_t v19 = 0LL;
    uint64_t v16 = 0LL;
    while (1)
    {
      if (v28)
      {
        unint64_t v84 = __clz(__rbit64(v28));
        v28 &= v28 - 1;
        unint64_t v85 = v84 | (v16 << 6);
        if (v139) {
          goto LABEL_42;
        }
      }

      else
      {
        BOOL v47 = __OFADD__(v16++, 1LL);
        if (v47)
        {
          __break(1u);
LABEL_101:
          __break(1u);
          return;
        }

        if (v16 >= v79) {
          goto LABEL_87;
        }
        unint64_t v87 = *(void *)(v77 + 8 * v16);
        if (!v87)
        {
          uint64_t v88 = v16 + 1;
          if (v16 + 1 >= v79) {
            goto LABEL_87;
          }
          unint64_t v87 = *(void *)(v77 + 8 * v88);
          if (!v87)
          {
            while (1)
            {
              uint64_t v16 = v88 + 1;
              if (__OFADD__(v88, 1LL)) {
                goto LABEL_96;
              }
              if (v16 >= v79) {
                break;
              }
              unint64_t v87 = *(void *)(v77 + 8 * v16);
              ++v88;
              if (v87) {
                goto LABEL_53;
              }
            }

LABEL_53:
        uint64_t v28 = (v87 - 1) & v87;
        unint64_t v85 = __clz(__rbit64(v87)) + (v16 << 6);
        if (v139)
        {
LABEL_42:
          unint64_t v86 = *(void **)&v80[8 * v85];
          swift_unknownObjectRetain(v86, v81, v82, v83);
          if (v19 == (id *)0x1000000000000000LL) {
            goto LABEL_60;
          }
          goto LABEL_57;
        }
      }

      (*(void (**)(id *, unint64_t, uint64_t *))(v133 + 16))( v8,  *(void *)(*(void *)(v135 + 32) + 56LL) + *(void *)(v133 + 72) * v85,  v5);
      if (_swift_isClassOrObjCExistentialType((uint64_t)v5, v5))
      {
        if (v129 != 8) {
LABEL_92:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        unint64_t v86 = *v8;
        swift_unknownObjectRetain(*v8, v89, v90, v91);
        (*(void (**)(id *, uint64_t *))(v133 + 8))(v8, v5);
        if (v19 == (id *)0x1000000000000000LL)
        {
LABEL_60:
          __break(1u);
LABEL_61:
          swift_release((uint64_t)v139);
          uint64_t v97 = *(void *)(v135 + 32);
          uint64_t v98 = 1LL << *(_BYTE *)(v97 + 32);
          uint64_t v99 = v97 + 64;
          uint64_t v100 = -1LL;
          if (v98 < 64) {
            uint64_t v100 = ~(-1LL << v98);
          }
          unint64_t v101 = v100 & *(void *)(v97 + 64);
          int64_t v102 = (unint64_t)(v98 + 63) >> 6;
          uint64_t v103 = v28;
          uint64_t v104 = v28 + 40;
          unint64_t v139 = *(char **)(v135 + 32);
          swift_retain_n(v97, 2LL, v95, v96);
          uint64_t v108 = 0LL;
          int64_t v109 = 0LL;
          while (2)
          {
            if (v101)
            {
              unint64_t v110 = __clz(__rbit64(v101));
              v101 &= v101 - 1;
              unint64_t v111 = v110 | (v109 << 6);
              if (v103) {
                goto LABEL_66;
              }
LABEL_77:
              (*(void (**)(id *, unint64_t, uint64_t))(v134 + 16))( v19,  *(void *)(*(void *)(v135 + 32) + 48LL) + *(void *)(v134 + 72) * v111,  v16);
              if (_swift_isClassOrObjCExistentialType(v16, (uint64_t *)v16))
              {
                if (v130 != 8) {
                  goto LABEL_92;
                }
                uint64_t v112 = *v19;
                swift_unknownObjectRetain(*v19, v115, v116, v117);
                (*(void (**)(id *, uint64_t))(v134 + 8))(v19, v16);
              }

              else
              {
                uint64_t v118 = v125;
                (*(void (**)(id *, id *, uint64_t))(v134 + 32))(v125, v19, v16);
                uint64_t v112 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v118, (uint64_t *)v16, v119, v120);
              }
            }

            else
            {
              BOOL v47 = __OFADD__(v109++, 1LL);
              if (v47) {
                goto LABEL_101;
              }
              if (v109 >= v102) {
                goto LABEL_88;
              }
              unint64_t v113 = *(void *)(v99 + 8 * v109);
              if (!v113)
              {
                int64_t v114 = v109 + 1;
                if (v109 + 1 >= v102) {
                  goto LABEL_88;
                }
                unint64_t v113 = *(void *)(v99 + 8 * v114);
                if (!v113)
                {
                  while (1)
                  {
                    int64_t v109 = v114 + 1;
                    if (__OFADD__(v114, 1LL)) {
                      goto LABEL_97;
                    }
                    if (v109 >= v102) {
                      break;
                    }
                    unint64_t v113 = *(void *)(v99 + 8 * v109);
                    ++v114;
                    if (v113) {
                      goto LABEL_76;
                    }
                  }

      uint64_t v29 = __OFADD__(v30, v52);
      unint64_t v53 = v30 + v52;
      if (!v29) {
        goto LABEL_54;
      }
LABEL_230:
      __break(1u);
      goto LABEL_231;
    }

    goto LABEL_99;
  }

  unint64_t v231 = 0LL;
  uint64_t v229 = 0u;
  int64_t v230 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v229,  &demangling cache variable for type metadata for CustomStringConvertible?);
  uint64_t v232 = a1;
  int64_t v64 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v229, &v232, (swift *)v2, v64, 6uLL))
  {
    outlined init with take of MirrorPath(&v229, (uint64_t)v226);
    BOOL v65 = (uint64_t)v227;
    int64_t v66 = v228;
    __swift_project_boxed_opaque_existential_0Tm(v226, (uint64_t)v227);
    int64_t v67 = (*(uint64_t (**)(uint64_t, uint64_t))(v66 + 8))(v65, v66);
    uint64_t v13 = v67;
    uint64_t v14 = v68;
    uint64_t v15 = v233;
    uint64_t v19 = v234;
    uint64_t v71 = HIBYTE(v234) & 0xF;
    if ((v234 & 0x2000000000000000LL) != 0) {
      unint64_t v53 = HIBYTE(v234) & 0xF;
    }
    else {
      unint64_t v53 = v233 & 0xFFFFFFFFFFFFLL;
    }
    if (v53 || (v233 & ~v234 & 0x2000000000000000LL) != 0)
    {
      uint64_t v31 = v68 & 0x2000000000000000LL;
      uint64_t v16 = HIBYTE(v68) & 0xF;
      if ((v234 & 0x2000000000000000LL) != 0 && v31)
      {
        unint64_t v72 = v71 + v16;
        if (v71 + v16 <= 0xF)
        {
          if (v16)
          {
            char v182 = 0LL;
            int64_t v183 = 0LL;
            char v184 = 8 * v16;
            int64_t v185 = v234;
            do
            {
              BOOL v186 = v71 + v183;
              unint64_t v94 = v183++ >= 8;
              if (v94) {
                uint64_t v187 = v68;
              }
              else {
                uint64_t v187 = v67;
              }
              uint64_t v188 = (8 * v71 + v182) & 0x38;
              BOOL v189 = (-255LL << v188) - 1;
              Swift::String::Index v190 = (unint64_t)(v187 >> (v182 & 0x38)) << v188;
              Swift::String::Index v191 = v190 | v189 & v185;
              Swift::String::Index v192 = v190 | v189 & v15;
              if (v186 < 8) {
                uint64_t v15 = v192;
              }
              else {
                int64_t v185 = v191;
              }
              v182 += 8LL;
            }

            while (v184 != v182);
          }

          else
          {
            int64_t v185 = v234;
          }

          swift_bridgeObjectRelease(v234);
          swift_bridgeObjectRelease(v14);
          Swift::String::Index v193 = 0xA000000000000000LL;
          if (!(v15 & 0x8080808080808080LL | v185 & 0x80808080808080LL)) {
            Swift::String::Index v193 = 0xE000000000000000LL;
          }
          unint64_t v161 = v193 & 0xFF00000000000000LL | (v72 << 56) | v185 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_175;
        }

        uint64_t v31 = 1LL;
      }

      uint64_t v22 = v67 & 0xFFFFFFFFFFFFLL;
      if (v31) {
        uint64_t v20 = HIBYTE(v68) & 0xF;
      }
      else {
        uint64_t v20 = v67 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v68, 2LL, v69, v70);
      if ((v14 & 0x1000000000000000LL) == 0)
      {
        swift_bridgeObjectRetain_n(v14, 4LL, v50, v51);
        uint64_t v76 = v20;
        if ((v19 & 0x1000000000000000LL) != 0) {
          goto LABEL_234;
        }
        goto LABEL_90;
      }

                        __break(1u);
                        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
                      }

          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Distance is not representable in Int",  36LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x64AuLL,  0);
        }

        if (v9 == -1) {
LABEL_54:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x6BuLL,  0);
LABEL_44:
        uint64_t v22 = 1LL;
        goto LABEL_46;
      }
    }

    else if (v7 < 0)
    {
      uint64_t v11 = v6 == 0;
      uint64_t v6 = -(uint64_t)v6;
      uint64_t v5 = 0LL;
      if (v11) {
        uint64_t v7 = -v7;
      }
      else {
        uint64_t v7 = ~v7;
      }
      uint64_t v8 = 1;
      goto LABEL_38;
    }
  }

  else if (v5 < 0)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0;
    goto LABEL_10;
  }

  uint64_t v10 = v4 - v6;
  uint64_t v12 = v4 < v6;
  uint64_t v13 = v5 - v7;
  uint64_t v14 = __OFSUB__(v5, v7);
  if (v12)
  {
    if (v13 == 0x8000000000000000LL) {
      LOBYTE(v14) = 1;
    }
    if (v14) {
LABEL_19:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x252uLL,  0);
    --v13;
  }

  else if (v14)
  {
    goto LABEL_19;
  }

  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t v17 = v10 < v16;
  if (v13 != v15) {
    uint64_t v17 = v13 < v15;
  }
  if (v17) {
    goto LABEL_53;
  }
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t v20 = v19 < v10;
  if (v18 != v13) {
    uint64_t v20 = v18 < v13;
  }
  if (v20) {
    goto LABEL_53;
  }
LABEL_51:
  *a2 = v10;
}

    *(_DWORD *)(a4 + 24) = 0;
    return;
  }

  uint64_t v9 = *(_DWORD *)(a2 + 20);
  uint64_t v10 = v9 != 0;
  uint64_t v11 = *(InProcessReaderWriter **)a1;
  if (v9) {
    uint64_t v12 = "true";
  }
  else {
    uint64_t v12 = "false";
  }
  InProcessReaderWriter::log( v11,  "GenericMetadataBuilder.h",  534,  "installCommonValueWitnesses",  "type isPOD, hasExtraInhabitants=%s layout.size=%zu flags.getAlignmentMask=%zu",  v12,  *(void *)a2,  *(_DWORD *)(a2 + 16));
  uint64_t v13 = (v10 << 48) | (*(void *)a2 << 16) | v7;
  if (v13 <= 524294)
  {
    switch(v13)
    {
      case 65536LL:
        InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  589,  "installCommonValueWitnesses",  "case sizeWithAlignmentMask(1, 0, 0)");
        uint64_t v14 = (void **)(a1 + 136);
        uint64_t v15 = *(_DWORD *)(a1 + 160);
        if (!v15) {
          goto LABEL_52;
        }
        break;
      case 131073LL:
        uint64_t v14 = (void **)(a1 + 168);
        uint64_t v15 = *(_DWORD *)(a1 + 192);
        if (!v15)
        {
          InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  600,  "installCommonValueWitnesses",  "case sizeWithAlignmentMask(2, 1, 0)");
          goto LABEL_52;
        }

        break;
      case 262147LL:
        uint64_t v14 = (void **)(a1 + 200);
        uint64_t v15 = *(_DWORD *)(a1 + 224);
        if (!v15)
        {
          InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  609,  "installCommonValueWitnesses",  "case sizeWithAlignmentMask(4, 3, 0)");
          goto LABEL_52;
        }

        break;
      default:
        goto LABEL_41;
    }

    uint64_t v34 = v20 + (v20 >> 2);
    unint64_t v35 = v20;
    if (v34 <= v20 + 1) {
      uint64_t v34 = v20 + 1;
    }
    int64_t v36 = malloc_good_size(8 * v34 + 8);
    uint64_t v37 = malloc(v36);
    if (!v37) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    uint64_t v33 = (unint64_t)v37;
    void *v37 = (v36 + 0x7FFFFFFF8LL) >> 3;
    uint64_t v20 = v35;
    if (v30)
    {
      memcpy(v37 + 2, __src, 8 * v35);
      uint64_t v38 = malloc(0x10uLL);
      *uint64_t v38 = qword_18C486B78;
      v38[1] = v30;
      qword_18C486B78 = (uint64_t)v38;
    }

    atomic_store(v33, &qword_18C486B60);
    goto LABEL_59;
  }

  return result;
}

    uint64_t v34 = v20 + (v20 >> 2);
    unint64_t v35 = v20;
    if (v34 <= v20 + 1) {
      uint64_t v34 = v20 + 1;
    }
    int64_t v36 = malloc_good_size(8 * v34 + 8);
    uint64_t v37 = malloc(v36);
    if (!v37) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    uint64_t v33 = (unint64_t)v37;
    void *v37 = (v36 + 0x7FFFFFFF8LL) >> 3;
    uint64_t v20 = v35;
    if (v30)
    {
      memcpy(v37 + 2, __src, 8 * v35);
      uint64_t v38 = malloc(0x10uLL);
      *uint64_t v38 = qword_18C486BA8;
      v38[1] = v30;
      qword_18C486BA8 = (uint64_t)v38;
    }

    atomic_store(v33, &qword_18C486B90);
    goto LABEL_59;
  }

  return result;
}

    if ((v6 & 1) == 0)
    {
      objc_storeWeak(location, obj);
      return;
    }

    goto LABEL_57;
  }

  int64_t v41 = swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::formWeakReference( obj + 1,  (uint64_t)obj,  a3,  a4);
  uint64_t v42 = (void *)(v41 | 1);
  if (!v41) {
    uint64_t v42 = 0LL;
  }
  uint64_t v43 = (unint64_t)*location;
  *location = v42;
  unint64_t v44 = (unsigned __int128 *)(v43 & 0x7FFFFFFFFFFFFFFELL);
  if ((v43 & 0x7FFFFFFFFFFFFFFELL) == 0) {
    return;
  }
  uint64_t v45 = v44 + 1;
  do
    unint64_t v46 = __ldxp(v45);
  while (__stxp(v46, v45));
  do
  {
    while (1)
    {
      int64_t v49 = __ldxp(v45);
      unint64_t v48 = *((void *)&v49 + 1);
      BOOL v47 = v49;
      int v50 = (void)v49 != (void)v46;
      if (*((void *)&v49 + 1) != *((void *)&v46 + 1)) {
        ++v50;
      }
      if (!v50) {
        break;
      }
      if (!__stxp(v49, v45)) {
        goto LABEL_94;
      }
    }
  }

  while (__stxp(__PAIR128__((DWORD2(v46) - 1), v46), v45));
LABEL_94:
  if ((void)v49 == (void)v46 && *((void *)&v49 + 1) == *((void *)&v46 + 1))
  {
    if (DWORD2(v46) != 1) {
      return;
    }
LABEL_114:
    swift_slowDealloc(v44);
    return;
  }

  do
  {
    uint64_t v54 = (v48 - 1);
    do
    {
      while (1)
      {
        uint64_t v55 = __ldxp(v45);
        uint64_t v56 = (void)v55 != v47;
        if (*((void *)&v55 + 1) != v48) {
          ++v56;
        }
        if (!v56) {
          break;
        }
        if (!__stxp(v55, v45)) {
          goto LABEL_101;
        }
      }
    }

    while (__stxp(__PAIR128__(v54, v47), v45));
LABEL_101:
    uint64_t v52 = *((void *)&v55 + 1) ^ v48;
    unint64_t v53 = v55 ^ v47;
    unint64_t v48 = *((void *)&v55 + 1);
    BOOL v47 = v55;
  }

  while (v53 | v52);
  if (!(_DWORD)v54) {
    goto LABEL_114;
  }
}

        memset(&v72, 0, 17);
        {
          uint64_t v30 = *((void *)this + 1585);
          if (v30 > 0xF)
          {
            uint64_t v12 = *((_DWORD *)this + 3178) + 16;
            uint64_t v73 = v72;
            Swift::String::Index v74 = v12;
            std::__hash_table<std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,std::__unordered_map_hasher<swift::Demangle::__runtime::SubstitutionEntry,std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,swift::Demangle::__runtime::SubstitutionEntry::Hasher,std::equal_to<swift::Demangle::__runtime::SubstitutionEntry>,true>,std::__unordered_map_equal<swift::Demangle::__runtime::SubstitutionEntry,std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,std::equal_to<swift::Demangle::__runtime::SubstitutionEntry>,swift::Demangle::__runtime::SubstitutionEntry::Hasher,true>,std::allocator<std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>>>::__emplace_unique_key_args<swift::Demangle::__runtime::SubstitutionEntry,std::pair<swift::Demangle::__runtime::SubstitutionEntry const,unsigned int>>( (uint64_t)v70,  (uint64_t)&v73,  &v73);
          }

          else
          {
            *((void *)this + 1585) = v30 + 1;
            uint64_t v31 = (char *)this + 24 * v30 + 12296;
            *(_OWORD *)uint64_t v31 = *(_OWORD *)&v72.__r_.__value_.__l.__data_;
            v31[16] = v72.__r_.__value_.__s.__data_[16];
          }
        }

        *(_DWORD *)a4 = 0;
        *(void *)(a4 + 8) = 0LL;
        *(_DWORD *)(a4 + 16) = 0;
        goto LABEL_17;
      case 4:
        NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)*((void *)*v13 + 2);
        uint64_t v19 = *((void *)NodeWithAllocatedText + 1);
        if (v19)
        {
          uint64_t v20 = *(const std::string::value_type **)NodeWithAllocatedText;
          uint64_t v21 = **(unsigned __int8 **)NodeWithAllocatedText;
          if (v21 == 95 || (v21 - 48) <= 9)
          {
            uint64_t v23 = a4;
            v73.__r_.__value_.__s.__size_ = 1;
            LOWORD(v73.__r_.__value_.__l.__data_) = 95;
            std::string::append(&v73, v20, v19);
            uint64_t v24 = *(void **)this;
            if ((v73.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v25 = &v73;
            }
            else {
              uint64_t v25 = (std::string *)v73.__r_.__value_.__r.__words[0];
            }
            if ((v73.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              size = v73.__r_.__value_.__s.__size_;
            }
            else {
              size = v73.__r_.__value_.__l.__size_;
            }
            if (size)
            {
              uint64_t v27 = (char *)v24[1];
              if (!v27 || (unint64_t)&v27[size] > v24[2])
              {
                uint64_t v28 = 2LL * v24[4];
                if (v28 <= size + 1) {
                  uint64_t v28 = size + 1;
                }
                v24[4] = v28;
                uint64_t v68 = v28 + 8;
                uint64_t v29 = malloc(v28 + 8);
                *uint64_t v29 = v24[3];
                uint64_t v27 = (char *)(v29 + 1);
                v24[2] = (char *)v29 + v68;
                uint64_t v24[3] = v29;
              }

              v24[1] = &v27[size];
              memmove(v27, v25, size);
            }

            else
            {
              uint64_t v27 = 0LL;
            }

            a4 = v23;
            uint64_t v5 = a2;
            NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v24,  101,  (uint64_t)v27,  size);
          }
        }

        goto LABEL_53;
      case 5:
      case 9:
        uint64_t v17 = *(void *)v9;
        if (v14 == 2) {
          goto LABEL_33;
        }
        if (v14 == 5 && *((_DWORD *)v13 + 2) >= 2u)
        {
          uint64_t v17 = (uint64_t)*v13;
LABEL_33:
          uint64_t v18 = *(void *)(v17 + 8);
        }

        else
        {
          uint64_t v18 = 0LL;
        }

        memset(&v72, 0, 17);
        {
          uint64_t v32 = *((void *)this + 1585);
          if (v32 > 0xF)
          {
            uint64_t v34 = *((_DWORD *)this + 3178) + 16;
            uint64_t v73 = v72;
            Swift::String::Index v74 = v34;
            std::__hash_table<std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,std::__unordered_map_hasher<swift::Demangle::__runtime::SubstitutionEntry,std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,swift::Demangle::__runtime::SubstitutionEntry::Hasher,std::equal_to<swift::Demangle::__runtime::SubstitutionEntry>,true>,std::__unordered_map_equal<swift::Demangle::__runtime::SubstitutionEntry,std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>,std::equal_to<swift::Demangle::__runtime::SubstitutionEntry>,swift::Demangle::__runtime::SubstitutionEntry::Hasher,true>,std::allocator<std::__hash_value_type<swift::Demangle::__runtime::SubstitutionEntry,unsigned int>>>::__emplace_unique_key_args<swift::Demangle::__runtime::SubstitutionEntry,std::pair<swift::Demangle::__runtime::SubstitutionEntry const,unsigned int>>( (uint64_t)v70,  (uint64_t)&v73,  &v73);
          }

          else
          {
            *((void *)this + 1585) = v32 + 1;
            uint64_t v33 = (char *)this + 24 * v32 + 12296;
            *(_OWORD *)uint64_t v33 = *(_OWORD *)&v72.__r_.__value_.__l.__data_;
            v33[16] = v72.__r_.__value_.__s.__data_[16];
          }
        }

        *(_DWORD *)a4 = 0;
        *(void *)(a4 + 8) = 0LL;
        *(_DWORD *)(a4 + 16) = 0;
        unint64_t v35 = *((unsigned __int8 *)v13 + 18);
        switch(v35)
        {
          case 1:
            goto LABEL_65;
          case 2:
            goto LABEL_17;
          case 5:
            unint64_t v35 = *((_DWORD *)v13 + 2);
            if (v35 == 2) {
              goto LABEL_17;
            }
LABEL_65:
            int64_t v36 = 2;
            break;
          default:
            unint64_t v35 = 0;
            int64_t v36 = 2;
            break;
        }

        break;
      default:
        goto LABEL_17;
    }

    while (1)
    {
      uint64_t v37 = v36;
      uint64_t v38 = *((unsigned __int8 *)v13 + 18);
      unint64_t v39 = v38 - 1;
      if ((_DWORD)v38 == 1) {
        goto LABEL_71;
      }
      if ((_DWORD)v38 != 5) {
        break;
      }
      if (*((unsigned int *)v13 + 2) > v37)
      {
LABEL_72:
        char v40 = v13;
        if (v39 >= 2) {
          char v40 = (_DWORD **)*v13;
        }
        int64_t v41 = (swift::Demangle::__runtime::Node *)v40[v37];
        goto LABEL_77;
      }

LABEL_57:
      *(void *)(v137 + 8LL * (void)v19) = v86;
      swift_unknownObjectRelease(v86);
      uint64_t v19 = (id *)((char *)v19 + 1);
      if (v19 == v140)
      {
        swift_release((uint64_t)v139);
        uint64_t v122 = (uint64_t)v138;
        goto LABEL_90;
      }
    }
  }

  unint64_t v125 = v22;
  if (!v137) {
    goto LABEL_61;
  }
  unint64_t v124 = v11;
  uint64_t v31 = *(void *)(v135 + 32);
  uint64_t v32 = 1LL << *(_BYTE *)(v31 + 32);
  uint64_t v33 = v31 + 64;
  uint64_t v34 = -1LL;
  if (v32 < 64) {
    uint64_t v34 = ~(-1LL << v32);
  }
  unint64_t v35 = v34 & *(void *)(v31 + 64);
  int64_t v36 = (unint64_t)(v32 + 63) >> 6;
  uint64_t v132 = v28;
  uint64_t v127 = v139 + 40;
  uint64_t v128 = v28 + 40;
  uint64_t v126 = v31;
  swift_retain_n(v31, 2LL, v29, v30);
  char v40 = 0LL;
  int64_t v41 = 0LL;
  do
  {
    if (v35)
    {
      unint64_t v44 = __clz(__rbit64(v35));
      uint64_t v45 = (v35 - 1) & v35;
      unint64_t v46 = v44 | (v41 << 6);
    }

    else
    {
      BOOL v47 = __OFADD__(v41++, 1LL);
      if (v47) {
        goto LABEL_98;
      }
      if (v41 >= v36)
      {
LABEL_84:
        swift_release_n(v126, 2LL);
        swift_release(v132);
        uint64_t v121 = (uint64_t)v139;
        goto LABEL_89;
      }

      unint64_t v48 = *(void *)(v33 + 8 * v41);
      if (!v48)
      {
        int64_t v49 = v41 + 1;
        if (v41 + 1 >= v36) {
          goto LABEL_84;
        }
        unint64_t v48 = *(void *)(v33 + 8 * v49);
        if (!v48)
        {
          while (1)
          {
            int64_t v41 = v49 + 1;
            if (__OFADD__(v49, 1LL)) {
              break;
            }
            if (v41 >= v36) {
              goto LABEL_84;
            }
            unint64_t v48 = *(void *)(v33 + 8 * v41);
            ++v49;
            if (v48) {
              goto LABEL_22;
            }
          }

            v253((char *)v289, a2);
            goto LABEL_3;
          }
        }

        (*(void (**)(char *, char *, uint64_t))(v84 + 32))(v83, v287, v78);
        uint64_t v180 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
        ((void (*)(char *, uint64_t))v288)(v83, v78);
        if (v291 >= v180) {
          goto LABEL_63;
        }
        goto LABEL_57;
      }
    }

    else
    {
      int64_t v64 = v286;
      BOOL v65 = *(void (**)(char *, const char *, swift *))(v286 + 16);
      v65(v59, v289, a2);
      int64_t v66 = v60;
    }

    uint64_t v68 = v288;
    uint64_t v69 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 376))(a2, v66);
    goto LABEL_9;
  }

  (*(void (**)(const char *, swift *))(v42 + 8))(a1, a2);
LABEL_3:
  uint64_t v61 = 0LL;
  uint64_t v62 = 1;
LABEL_30:
  LOBYTE(v291) = v62;
  return v61 | ((unint64_t)v62 << 32);
}

    uint64_t v56 = v64 & 0xFFFFFFFFFFFFLL;
    goto LABEL_58;
  }

  if ((v1 & 0x2000000000000000LL) == 0)
  {
    if ((v0 & 0x1000000000000000LL) != 0)
    {
      uint64_t v7 = (int8x16_t *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v8 = v0 & 0xFFFFFFFFFFFFLL;
      if ((v0 & 0xFFFFFFFFFFFFuLL) <= 0xF)
      {
LABEL_8:
        uint64_t v80 = xmmword_1817FFDF0;
        if (v8)
        {
          uint64_t v9 = v8 & ~(v8 >> 63);
          uint64_t v10 = v8 - 1;
          if (v9 < v8 - 1) {
            uint64_t v10 = v8 & ~(v8 >> 63);
          }
          if (v10 > 0xF)
          {
            uint64_t v22 = v10 + 1;
            uint64_t v23 = v22 & 0xF;
            if ((v22 & 0xF) == 0) {
              uint64_t v23 = 16LL;
            }
            uint64_t v11 = v22 - v23;
            uint64_t v24 = (int8x16_t *)&v80;
            v25.i64[0] = -1LL;
            v25.i64[1] = -1LL;
            v26.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
            v26.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
            uint64_t v27 = (uint64x2_t)vdupq_n_s64(0x3FFE000000000uLL);
            v28.i64[0] = 0x2020202020202020LL;
            v28.i64[1] = 0x2020202020202020LL;
            uint64_t v29 = v11;
            uint64_t v30 = v7;
            do
            {
              uint64_t v31 = *v30++;
              uint64_t v32 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v31, v25), 1uLL), v26);
              uint64_t v33 = vmovl_u8(*(uint8x8_t *)v32.i8);
              uint64_t v34 = vmovl_u16(*(uint16x4_t *)v33.i8);
              v35.i64[0] = v34.u32[0];
              v35.i64[1] = v34.u32[1];
              int64_t v36 = v35;
              uint64_t v37 = vmovl_high_u16(v33);
              uint64_t v38 = vmovl_high_u8(v32);
              v35.i64[0] = v37.u32[0];
              v35.i64[1] = v37.u32[1];
              unint64_t v39 = v35;
              char v40 = vmovl_u16(*(uint16x4_t *)v38.i8);
              v35.i64[0] = v40.u32[0];
              v35.i64[1] = v40.u32[1];
              int64_t v41 = v35;
              uint64_t v42 = (int8x16_t)vmovl_high_u16(v38);
              v35.i64[0] = v42.u32[0];
              v35.i64[1] = v42.u32[1];
              v82.val[3] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, (uint32x4_t)v42));
              v82.val[1] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, v40));
              v82.val[2] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v35));
              v82.val[0] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v41));
              v83.val[3] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, v37));
              v83.val[1] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, v34));
              v83.val[2] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v39));
              v83.val[0] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v36));
              v42.i64[0] = vqtbl4q_s8(v83, (int8x16_t)xmmword_1817FFE00).u64[0];
              v42.i64[1] = vqtbl4q_s8(v82, (int8x16_t)xmmword_1817FFE00).u64[0];
              *v24++ = vaddq_s8(vandq_s8(v42, v28), v31);
              v29 -= 16LL;
            }

            while (v29);
          }

          else
          {
            uint64_t v11 = 0LL;
          }

          do
          {
            if (v9 == v11) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
            }
            ++v11;
          }

          while (v8 != v11);
          if (v8 > 0)
          {
            uint64_t v43 = 8;
            if (v8 <= 8) {
              unint64_t v44 = 8;
            }
            else {
              unint64_t v44 = v8;
            }
            uint64_t v45 = 56 * v44;
            if (v8 < 8) {
              uint64_t v43 = v8;
            }
            unint64_t v46 = 0xFFFFFFFFFFFFFFFFLL >> (v45 & 0x38);
            uint64_t v17 = v80 & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v43) & 0x38));
            BOOL v47 = *((void *)&v80 + 1) & v46;
            uint64_t v19 = ((*((void *)&v80 + 1) & v46 | v17) & 0x8080808080808080LL) == 0;
            unint64_t v48 = 0xA000000000000000LL;
            if (v19) {
              unint64_t v48 = 0xE000000000000000LL;
            }
            uint64_t v21 = v48 | (v8 << 56) | v47;
            if ((v21 & 0x4000000000000000LL) == 0)
            {
              *(void *)&uint64_t v80 = v17;
              *((void *)&v80 + 1) = v47 & 0xFFFFFFFFFFFFFFLL;
              closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)( (uint8x16_t *)&v80,  HIBYTE(v21) & 0xF,  v79.i64);
              uint64_t v21 = v79.u64[1];
              uint64_t v17 = v79.i64[0];
            }

            goto LABEL_46;
          }
        }

    uint64_t v56 = v64 & 0xFFFFFFFFFFFFLL;
    goto LABEL_58;
  }

  if ((v1 & 0x2000000000000000LL) == 0)
  {
    if ((v0 & 0x1000000000000000LL) != 0)
    {
      uint64_t v7 = (int8x16_t *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v8 = v0 & 0xFFFFFFFFFFFFLL;
      if ((v0 & 0xFFFFFFFFFFFFuLL) <= 0xF)
      {
LABEL_8:
        uint64_t v80 = xmmword_1817FFDF0;
        if (v8)
        {
          uint64_t v9 = v8 & ~(v8 >> 63);
          uint64_t v10 = v8 - 1;
          if (v9 < v8 - 1) {
            uint64_t v10 = v8 & ~(v8 >> 63);
          }
          if (v10 > 0xF)
          {
            uint64_t v22 = v10 + 1;
            uint64_t v23 = v22 & 0xF;
            if ((v22 & 0xF) == 0) {
              uint64_t v23 = 16LL;
            }
            uint64_t v11 = v22 - v23;
            uint64_t v24 = (int8x16_t *)&v80;
            v25.i64[0] = -1LL;
            v25.i64[1] = -1LL;
            v26.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
            v26.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
            uint64_t v27 = (uint64x2_t)vdupq_n_s64(0x1FFF000000000000uLL);
            v28.i64[0] = 0x2020202020202020LL;
            v28.i64[1] = 0x2020202020202020LL;
            uint64_t v29 = v11;
            uint64_t v30 = v7;
            do
            {
              uint64_t v31 = *v30++;
              uint64_t v32 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v31, v25), 1uLL), v26);
              uint64_t v33 = vmovl_u8(*(uint8x8_t *)v32.i8);
              uint64_t v34 = vmovl_u16(*(uint16x4_t *)v33.i8);
              v35.i64[0] = v34.u32[0];
              v35.i64[1] = v34.u32[1];
              int64_t v36 = v35;
              uint64_t v37 = vmovl_high_u16(v33);
              uint64_t v38 = vmovl_high_u8(v32);
              v35.i64[0] = v37.u32[0];
              v35.i64[1] = v37.u32[1];
              unint64_t v39 = v35;
              char v40 = vmovl_u16(*(uint16x4_t *)v38.i8);
              v35.i64[0] = v40.u32[0];
              v35.i64[1] = v40.u32[1];
              int64_t v41 = v35;
              uint64_t v42 = (int8x16_t)vmovl_high_u16(v38);
              v35.i64[0] = v42.u32[0];
              v35.i64[1] = v42.u32[1];
              v82.val[3] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, (uint32x4_t)v42));
              v82.val[1] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, v40));
              v82.val[2] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v35));
              v82.val[0] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v41));
              v83.val[3] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, v37));
              v83.val[1] = (int8x16_t)vshlq_u64(v27, vsubw_high_u32((uint64x2_t)0LL, v34));
              v83.val[2] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v39));
              v83.val[0] = (int8x16_t)vshlq_u64(v27, (uint64x2_t)vnegq_s64(v36));
              v42.i64[0] = vqtbl4q_s8(v83, (int8x16_t)xmmword_1817FFE00).u64[0];
              v42.i64[1] = vqtbl4q_s8(v82, (int8x16_t)xmmword_1817FFE00).u64[0];
              *v24++ = vsubq_s8(v31, vandq_s8(vshlq_n_s8(v42, 5uLL), v28));
              v29 -= 16LL;
            }

            while (v29);
          }

          else
          {
            uint64_t v11 = 0LL;
          }

          do
          {
            if (v9 == v11) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
            }
            *((_BYTE *)&v80 + v11) = v7->i8[v11]
                                   - 32 * ((0x1FFF000000000000uLL >> ((v7->u8[v11] - 1) >> 1)) & 1);
            ++v11;
          }

          while (v8 != v11);
          if (v8 > 0)
          {
            uint64_t v43 = 8;
            if (v8 <= 8) {
              unint64_t v44 = 8;
            }
            else {
              unint64_t v44 = v8;
            }
            uint64_t v45 = 56 * v44;
            if (v8 < 8) {
              uint64_t v43 = v8;
            }
            unint64_t v46 = 0xFFFFFFFFFFFFFFFFLL >> (v45 & 0x38);
            uint64_t v17 = v80 & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v43) & 0x38));
            BOOL v47 = *((void *)&v80 + 1) & v46;
            uint64_t v19 = ((*((void *)&v80 + 1) & v46 | v17) & 0x8080808080808080LL) == 0;
            unint64_t v48 = 0xA000000000000000LL;
            if (v19) {
              unint64_t v48 = 0xE000000000000000LL;
            }
            uint64_t v21 = v48 | (v8 << 56) | v47;
            if ((v21 & 0x4000000000000000LL) == 0)
            {
              *(void *)&uint64_t v80 = v17;
              *((void *)&v80 + 1) = v47 & 0xFFFFFFFFFFFFFFLL;
              closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)( (uint8x16_t *)&v80,  HIBYTE(v21) & 0xF,  v79.i64);
              uint64_t v21 = v79.u64[1];
              uint64_t v17 = v79.i64[0];
            }

            goto LABEL_46;
          }
        }

          uint64_t v20 = 0;
          unint64_t v48 = v34;
LABEL_58:
          unint64_t v46 = 0;
          goto LABEL_59;
        }

        if (v17 >= 0x300 && (v17 & 0x600000000LL) != 0)
        {
          uint64_t v38 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v34, v17);
          if ((v38 & 0x100000000LL) == 0) {
            goto LABEL_51;
          }
          Composition = _swift_stdlib_getComposition(v34, v17);
          if ((_DWORD)Composition != -1) {
            break;
          }
        }

                uint64_t v4 = 0LL;
                goto LABEL_59;
              }

  *(_OWORD *)a3 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  *(void *)(a3 + 16) = v21->__r_.__value_.__l.__cap_;
LABEL_63:
  *(_DWORD *)(a3 + 24) = 1;
  if (v20 != -1) {
    ((void (*)(std::string *, std::string *))off_189B8B2E0[v20])(&v35, &__dst);
  }
LABEL_21:
  if (v32 != -1) {
    ((void (*)(std::string *, _BYTE *))off_189B8B2E0[v32])(&__dst, v29);
  }
  if (v34 != -1) {
    ((void (*)(_BYTE *, void **))off_189B8B2D0[v34])(v29, &v33);
  }
}

    uint64_t v9 = 2LL;
    goto LABEL_58;
  }

  if (v2 != 153) {
    return 0LL;
  }
  uint64_t v3 = *(unsigned __int16 **)a2;
  uint64_t v4 = *((void *)a2 + 1);
  if (v4 == 3)
  {
    char v26 = *v3;
    uint64_t v27 = *((unsigned __int8 *)v3 + 2);
    if (v26 != 24415 || v27 != 67) {
      return 0LL;
    }
    uint64_t v8 = "So";
    goto LABEL_57;
  }

  if (v4 == 15)
  {
    uint64_t v29 = *(void *)v3;
    uint64_t v30 = *(void *)((char *)v3 + 7);
    if (v29 != 0x746E79535F435F5FLL || v30 != 0x64657A6973656874LL) {
      return 0LL;
    }
    uint64_t v8 = "SC";
    goto LABEL_57;
  }

  if (v4 != 5) {
    return 0LL;
  }
  uint64_t v5 = *(_DWORD *)v3;
  uint64_t v6 = *((unsigned __int8 *)v3 + 4);
  if (v5 != 1718187859 || v6 != 116) {
    return 0LL;
  }
  uint64_t v8 = "s";
  uint64_t v9 = 1LL;
LABEL_58:
  swift::Demangle::__runtime::CharVector::append(this + 1591, v8, v9, this[1593]);
  return 1LL;
}

LABEL_94:
          __break(1u);
LABEL_95:
          __break(1u);
LABEL_96:
          __break(1u);
LABEL_97:
          __break(1u);
LABEL_98:
          __break(1u);
LABEL_99:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid count",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x13AuLL,  0);
        }

        ++v41;
      }

              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
            }

    *(void *)(v38 + 8 + 8 * v80) = v44;
    atomic_store(v79, (unsigned int *)&dword_18C486C6C);
    __asm { BR              X11 }
  }

  uint64_t v4 = (uint64_t (***)())&type metadata for Swift.AnyObject;
  if (a1) {
    uint64_t v4 = &type metadata for Any;
  }
  return v4 + 1;
}

uint64_t @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)( a1,  a2,  a3,  a4,  a5,  (void (*)(uint64_t, char *, uint64_t))_SwiftDeferredNSDictionary.getObjects(_:andKeys:count:));
}

uint64_t _convertInOutToPointerArgument<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

void @objc _SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:using:)( unint64_t *a1, int a2, int a3, void *aBlock)
{
  uint64_t v5 = _Block_copy(aBlock);
  swift_retain(a1, v6, v7, v8);
  specialized _SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:using:)((uint64_t)v5);
  swift_release((uint64_t)a1);
  _Block_release(v5);
}

uint64_t @objc _SwiftDeferredNSDictionary.count.getter()
{
  return _SwiftDeferredNSDictionary.count.getter();
}

uint64_t _SwiftDeferredNSDictionary.count.getter()
{
  return *(void *)(*(void *)(v0 + 32) + 16LL);
}

uint64_t _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(uint64_t **)(*v3 + 96LL);
  uint64_t v63 = *(v6 - 1);
  uint64_t v64 = a3;
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (id *)((char *)&v49 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v61 = v8;
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v15 = (id *)((char *)&v49 - v14);
  uint64_t v62 = v3;
  uint64_t v16 = v3[4];
  uint64_t v17 = v16 + 64;
  uint64_t v18 = -1LL << *(_BYTE *)(v16 + 32);
  uint64_t v19 = *(void *)v10;
  __int128 v20 = *(_OWORD *)(v10 + 32);
  __int128 v57 = *(_OWORD *)(v10 + 48);
  __int128 v58 = v20;
  if (v19)
  {
    uint64_t v22 = *(void *)(v5 + 8);
    uint64_t v21 = *(Swift::UInt **)(v5 + 16);
    unint64_t v23 = *(void *)(v5 + 24);
    if (a2) {
      goto LABEL_3;
    }
  }

  else
  {
    unint64_t v45 = _HashTable.startBucket.getter((unint64_t *)(v16 + 64), ~v18);
    if ((v45 & 0x8000000000000000LL) != 0) {
      goto LABEL_40;
    }
    unint64_t v23 = v45;
    uint64_t v21 = &_fastEnumerationStorageMutationsTarget;
    uint64_t v19 = 1LL;
    uint64_t v22 = a2;
    if (a2)
    {
LABEL_3:
      if ((v23 & 0x8000000000000000LL) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      int64_t v24 = -v18;
      if (v23 + v18)
      {
        if ((uint64_t)v23 >= v24)
        {
          swift_retain((unint64_t *)v16, v11, v12, v13);
        }

        else if (((*(void *)(v17 + ((v23 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v23) & 1) != 0)
        {
          goto LABEL_7;
        }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid fast enumeration state",  30LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x195uLL,  0);
      }

LABEL_40:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
  }

  return 0LL;
}

      uint64_t v127 = v59;
      v59(v138, v8);
LABEL_41:
      unint64_t v139 = v233;
      unint64_t v140 = v233(v8, v6);
      ((void (*)(char *, char *, void (*)(char *, uint64_t)))v250)(v129, v123, v8);
      if (v140 < 65)
      {
        int64_t v142 = v139(v8, v6);
        v127(v129, v8);
        unint64_t v141 = v235;
        a2 = v241;
        if (v142 != 64 || (v235(v8, v6) & 1) != 0) {
          goto LABEL_55;
        }
      }

      else
      {
        v127(v129, v8);
        unint64_t v141 = v235;
        a2 = v241;
      }

      ((void (*)(char *, char *, void (*)(char *, uint64_t)))v250)(v128, v123, v8);
      v252[0] = 0x7FFFFFFFFFFFFFFFLL;
      char v143 = v141(v8, v6);
      unint64_t v144 = v233(v8, v6);
      if ((v143 & 1) != 0)
      {
        if (v144 > 64)
        {
          char v147 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
          uint64_t v148 = lazy protocol witness table accessor for type Int and conformance Int(v144, v145, v146);
          uint64_t v149 = v252;
          goto LABEL_53;
        }
      }

      else if (v144 > 63)
      {
        v251 = 0x7FFFFFFFFFFFFFFFLL;
        char v147 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
        uint64_t v148 = lazy protocol witness table accessor for type Int and conformance Int(v144, v145, v146);
        uint64_t v149 = &v251;
LABEL_53:
        size_t v151 = v128;
        unint64_t v152 = v244;
        v147(v149, &type metadata for Int, v148, v8, v6);
        uint64_t v153 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                               + 16LL))( v152,  v151,  v8);
        Swift::Int v154 = v152;
        uint64_t v128 = v151;
        unint64_t v96 = v248;
        v127(v154, v8);
        if ((v153 & 1) != 0) {
          goto LABEL_87;
        }
        goto LABEL_54;
      }

      uint64_t v150 = v244;
      ((void (*)(char *, char *, void (*)(char *, uint64_t)))v250)(v244, v128, v8);
      (*(void (**)(void *, uint64_t))(v6 + 120))(v8, v6);
      v127(v150, v8);
LABEL_54:
      v127(v128, v8);
LABEL_55:
      uint64_t v27 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
      v127(v123, v8);
      uint64_t v14 = v234;
      uint64_t v61 = (uint64_t (*)(uint64_t))v249;
      goto LABEL_56;
    }

    if (v64 <= 64)
    {
      uint64_t v77 = v228;
      uint64_t v78 = AssociatedTypeWitness;
      int64_t v79 = swift_getAssociatedConformanceWitness( (uint64_t)v228,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v80 = v226;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v79 + 8))( &unk_18180BE68,  256LL,  v78,  v79);
      uint64_t v81 = v244;
      (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v77 + 3))(v80, v8, v77);
      uint64_t v82 = v250;
      LOBYTE(v78) = (*(uint64_t (**)(void (*)(void), char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v250,  v81,  v8);
      char v83 = v242;
      unint64_t v84 = v81;
      unint64_t v85 = *(void (**)(char *, void *))(v242 + 8);
      v85(v84, v8);
      (*(void (**)(char *, void (*)(void), void (*)(char *, uint64_t)))(v83 + 16))(v30, v82, v8);
      uint64_t v14 = v234;
      if ((v78 & 1) != 0)
      {
        v85(v30, v8);
        unint64_t v60 = v248;
        uint64_t v61 = (uint64_t (*)(uint64_t))v249;
      }

      else
      {
        uint64_t v233 = v63;
        uint64_t v95 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
        v85(v30, v8);
        unint64_t v60 = v248;
        uint64_t v61 = (uint64_t (*)(uint64_t))v249;
        uint64_t v59 = v85;
        if (v95 >= v49) {
          goto LABEL_24;
        }
      }

      goto LABEL_21;
    }

    uint64_t v233 = v63;
    v252[0] = v49;
    int64_t v67 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
    uint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
    uint64_t v69 = v244;
    v67(v252, &type metadata for Int, v68, v8, v6);
    uint64_t v70 = (*(uint64_t (**)(void (*)(void), char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                                  + 16LL))( v250,  v69,  v8);
    uint64_t v59 = *(void (**)(char *, void *))(v242 + 8);
    v59(v69, v8);
    unint64_t v60 = v248;
    uint64_t v14 = v234;
LABEL_10:
    uint64_t v61 = (uint64_t (*)(uint64_t))v249;
    if ((v70 & 1) != 0) {
      goto LABEL_21;
    }
    goto LABEL_24;
  }

  uint64_t v52 = v250;
  uint64_t v233 = *(uint64_t (**)(void *, uint64_t))(v6 + 128);
  uint64_t v53 = v233(v8, v6);
  if (v53 >= 64)
  {
    v252[0] = v49;
    uint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    uint64_t v73 = v244;
    v71(v252, &type metadata for Int, v72, v8, v6);
    uint64_t v70 = (*(uint64_t (**)(void (*)(void), char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                                  + 16LL))( v52,  v73,  v8);
    uint64_t v59 = *(void (**)(char *, void *))(v242 + 8);
    v59(v73, v8);
    unint64_t v60 = v248;
    goto LABEL_10;
  }

  uint64_t v56 = v242;
  __int128 v57 = v244;
  (*(void (**)(char *, void (*)(void), void (*)(char *, uint64_t)))(v242 + 16))(v244, v52, v8);
  __int128 v58 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
  uint64_t v59 = *(void (**)(char *, void *))(v56 + 8);
  v59(v57, v8);
  unint64_t v60 = v248;
  uint64_t v61 = (uint64_t (*)(uint64_t))v249;
  if (v58 >= v49) {
    goto LABEL_24;
  }
LABEL_21:
  unint64_t v96 = v60;
  uint64_t v97 = v61(a3);
  uint64_t v27 = -v97;
  if (__OFSUB__(0LL, v97))
  {
    __break(1u);
LABEL_86:
    __break(1u);
LABEL_87:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }

  a2 = v241;
LABEL_56:
  Swift::Int v155 = v14;
  unint64_t v156 = *(void (**)(void))(v14 + 32);
  ((void (*)(char *, uint64_t, uint64_t))v156)(a2, v247, a3);
  uint64_t v6 = v240;
  uint64_t v157 = (*(uint64_t (**)(uint64_t, uint64_t))(v240 + 64))(a3, v240);
  v250 = v156;
  if ((v157 & 1) != 0)
  {
    char v158 = ((uint64_t (*)(uint64_t, uint64_t))v61)(a3, v96);
    if (!__OFSUB__(v158, 1LL))
    {
      v252[0] = v158 - 1;
      unint64_t v161 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
      unint64_t v162 = lazy protocol witness table accessor for type Int and conformance Int(v158, v159, v160);
      unint64_t v163 = (char *)v61;
      unint64_t v164 = v243;
      v161(v252, &type metadata for Int, v162, a3, v6);
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v96 + 200))(a2, v164, a3, v96);
      unint64_t v165 = v164;
      uint64_t v30 = v163;
      unint64_t v166 = v239;
      (*(void (**)(char *, uint64_t))(v155 + 8))(v165, a3);
      unint64_t v167 = v238;
      uint64_t v168 = swift_getAssociatedConformanceWitness( (uint64_t)v166,  a3,  v238,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v169 = v237;
      goto LABEL_60;
    }

    goto LABEL_86;
  }

  unint64_t v170 = v238;
  unint64_t v166 = v239;
  uint64_t v168 = swift_getAssociatedConformanceWitness( (uint64_t)v239,  a3,  v238,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v169 = v237;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v168 + 8))( &unk_18180BE68,  256LL,  v170,  v168);
  (*((void (**)(char *, uint64_t, const char *))v166 + 3))(v169, a3, v166);
  unint64_t v167 = v170;
  uint64_t v30 = v249;
LABEL_60:
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v168 + 8))( &unk_18180BE68,  256LL,  v167,  v168);
  (*((void (**)(char *, uint64_t, const char *))v166 + 3))(v169, a3, v166);
  uint64_t v8 = *(void (**)(char *, uint64_t))(v155 + 8);
  if ((v27 & 0x8000000000000000LL) == 0)
  {
    v8(v245, a3);
    unint64_t v171 = v248;
    uint64_t v172 = ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v248);
    uint64_t v173 = v247;
    if (v27 >= v172)
    {
      v8(a2, a3);
      char v218 = v236;
      uint64_t v219 = v250;
      ((void (*)(char *, char *, uint64_t))v250)(v236, v246, a3);
      return ((uint64_t (*)(uint64_t, char *, uint64_t))v219)(v173, v218, a3);
    }

    else
    {
      uint64_t v174 = ((uint64_t (*)(char *, uint64_t))v8)(v246, a3);
      v252[0] = v27;
      uint64_t v175 = v171;
      unint64_t v176 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
      uint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v174, v177, v178);
      uint64_t v180 = v243;
      v176(v252, &type metadata for Int, v179, a3, v6);
      int64_t v181 = v236;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v175 + 216))(a2, v180, a3, v175);
      v8(v180, a3);
      v8(a2, a3);
      return ((uint64_t (*)(uint64_t, char *, uint64_t))v250)(v173, v181, a3);
    }
  }

    int64_t v79 = v54;
    unint64_t v23 = v50;
    unint64_t v48 = __OFADD__(v34, v55);
    v34 += v55;
    uint64_t v31 = v74;
    uint64_t v33 = v75;
    if (v48)
    {
      __break(1u);
      goto LABEL_71;
    }
  }

  if (EnumCaseMultiPayload == 1)
  {
    (*(void (**)(char *, unint64_t))(v76 + 8))(v84, v18);
    BOOL v65 = specialized Collection.prefix(upTo:)(v34, (uint64_t)v25, v23);
    specialized Slice.deinitialize<A>()(v65, v66, v67);
    swift_slowDealloc(v25);
    return 0LL;
  }

  (*(void (**)(char *, unint64_t))(v76 + 8))(v84, v18);
  if ((v79 & 1) != 0) {
    uint64_t v64 = v34 | 0xC000000000000000LL;
  }
  else {
    uint64_t v64 = v34;
  }
  uint64_t v69 = type metadata accessor for __SharedStringStorage();
  uint64_t v70 = swift_allocObject(v69, 0x31uLL, 7uLL);
  v70[2] = 0LL;
  v70[3] = v25;
  *((_BYTE *)v70 + 48) = 0;
  v70[4] = v64;
  v70[5] = 0LL;
  return v64;
}

        if (v2[2] == 1 && *v2 == 1 && _swift_stdlib_isLinkingConsonant(and._value))
        {
          uint64_t v5 = 0;
          *(_WORD *)uint64_t v2 = 0;
          v2[2] = 0;
          return v5 & 1;
        }

      if ((v40 & ~v39 & 0x2000000000000000LL) != 0
        && (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v39 & 0xFFFFFFFFFFFFFFFLL),
            unint64_t v40 = *v130,
            unint64_t v39 = v130[1],
            isUniquelyReferenced_nonNull_native))
      {
        uint64_t v52 = _StringGuts.nativeUnusedCapacity.getter(*v130, v130[1]);
        if ((v53 & 1) != 0)
        {
          uint64_t v122 = 258LL;
LABEL_115:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v122,  0);
        }

        if (v50 <= 15 && ((v39 & 0x2000000000000000LL) != 0 || v52 < v48))
        {
LABEL_60:
          int64_t v67 = _StringGuts._convertedToSmall()(v40, v39);
          uint64_t v69 = v68;
          v70._rawBits = (v47 << 16) | 1;
          v71._rawBits = 3LL;
          unint64_t v72 = specialized String.init(_:)(v71, v70, v35, v33);
          Swift::String::Index v74 = v73;
          swift_bridgeObjectRelease(v33);
          uint64_t v75 = _StringGuts._convertedToSmall()(v72, v74);
          uint64_t v77 = v76;
          swift_bridgeObjectRelease(v74);
          uint64_t v78 = HIBYTE(v69) & 0xF;
          int64_t v79 = HIBYTE(v77) & 0xF;
          uint64_t v80 = v79 + v78;
          if ((unint64_t)(v79 + v78) > 0xF)
          {
            uint64_t v122 = 266LL;
            goto LABEL_115;
          }

          uint64_t v34 = (unint64_t *)v130;
          if (v79)
          {
            uint64_t v81 = 0;
            uint64_t v82 = 0LL;
            do
            {
              char v83 = v78 + v82;
              unint64_t v84 = v82 + 1;
              if (v82 >= 8) {
                unint64_t v85 = v77;
              }
              else {
                unint64_t v85 = v75;
              }
              unint64_t v86 = v85 >> (v81 & 0x38);
              unint64_t v87 = (8 * v78 + v81) & 0x38;
              uint64_t v88 = (-255LL << v87) - 1;
              uint64_t v89 = (unint64_t)v86 << v87;
              uint64_t v90 = v89 | v88 & v69;
              unint64_t v91 = v89 | v88 & v67;
              if (v83 < 8) {
                int64_t v67 = v91;
              }
              else {
                uint64_t v69 = v90;
              }
              v81 += 8;
              uint64_t v82 = v84;
            }

            while (v79 != v84);
          }

          swift_bridgeObjectRelease(v39);
          swift_bridgeObjectRelease(v33);
          unint64_t v92 = 0xA000000000000000LL;
          if (!(v67 & 0x8080808080808080LL | v69 & 0x80808080808080LL)) {
            unint64_t v92 = 0xE000000000000000LL;
          }
          uint64_t v38 = v92 & 0xFF00000000000000LL | (v80 << 56) | v69 & 0xFFFFFFFFFFFFFFLL;
          *uint64_t v34 = v67;
          goto LABEL_22;
        }
      }

      else if (v50 <= 15)
      {
        goto LABEL_60;
      }

      uint64_t v54 = v48;
      uint64_t v34 = (unint64_t *)v130;
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v50, v54);
      if ((v33 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignAppendInPlace(_:)(v35, v33, 0LL, v47);
        swift_bridgeObjectRelease_n(v33, 2LL);
        goto LABEL_23;
      }

      swift_bridgeObjectRelease(v33);
      if (!v43)
      {
        if ((v35 & 0x1000000000000000LL) != 0)
        {
          uint64_t v55 = (char *)((v33 & 0xFFFFFFFFFFFFFFFLL) + 32);
          goto LABEL_50;
        }

        Swift::String::Index v120 = (char *)_StringObject.sharedUTF8.getter(v35, v33);
        if (v121 < v125) {
          goto LABEL_111;
        }
        uint64_t v55 = v120;
        if (v125)
        {
          uint64_t v34 = (unint64_t *)v130;
          uint64_t v56 = v125;
          if (!v120) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
          }
        }

        else
        {
          uint64_t v34 = (unint64_t *)v130;
LABEL_50:
          uint64_t v56 = v125;
        }

        __int128 v57 = v34[1];
        __int128 v58 = v57 & 0xFFFFFFFFFFFFFFFLL;
        uint64_t v59 = (v57 & 0xFFFFFFFFFFFFFFFLL) + 32;
        unint64_t v60 = (char *)(v59 + (*(void *)(v57 + 24) & 0xFFFFFFFFFFFFLL));
        if (&v60[v56] > v55 && v60 < &v55[v56]) {
          goto LABEL_112;
        }
        memcpy(v60, v55, v56);
        uint64_t v61 = *(void *)(v58 + 24);
        uint64_t v62 = (v61 & 0xFFFFFFFFFFFFLL) + v56;
        if (((v61 & v35 & 0x8000000000000000LL) != 0LL) != v49) {
          v62 |= 0xC000000000000000LL;
        }
        uint64_t v63 = v62 | 0x3000000000000000LL;
        *(void *)(v58 + 24) = v62 | 0x3000000000000000LL;
        *(_BYTE *)(v59 + (v62 & 0xFFFFFFFFFFFFLL)) = 0;
        uint64_t v64 = *(void *)(v58 + 16);
        if (v64 < 0)
        {
          BOOL v65 = (uint64_t *)((v59 + (v64 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
          int64_t v66 = *v65;
          *BOOL v65 = 0LL;
          swift_release(v66);
          uint64_t v63 = *(void *)(v58 + 24);
        }

        *uint64_t v34 = v63;
        swift_bridgeObjectRelease(v33);
        goto LABEL_23;
      }

      __src = v35;
      uint64_t v132 = v33 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v104 = v34[1];
      uint64_t v105 = v104 & 0xFFFFFFFFFFFFFFFLL;
      uint64_t v106 = (v104 & 0xFFFFFFFFFFFFFFFLL) + 32;
      unint64_t v107 = (char *)(v106 + (*(void *)(v104 + 24) & 0xFFFFFFFFFFFFLL));
      if (&__src < (unint64_t *)&v107[v44] && v107 < (char *)&__src + v44) {
LABEL_112:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
      memcpy(v107, &__src, HIBYTE(v33) & 0xF);
      uint64_t v108 = *(void *)(v105 + 24);
      int64_t v109 = (v108 & 0xFFFFFFFFFFFFLL) + v44;
      unint64_t v110 = v108 > -1 || (v33 & 0x4000000000000000LL) == 0;
      unint64_t v111 = v109 | 0xC000000000000000LL;
      if (v110) {
        unint64_t v111 = v109;
      }
      *(void *)(v105 + 24) = v111 | 0x3000000000000000LL;
      *(_BYTE *)(v106 + (v111 & 0xFFFFFFFFFFFFLL)) = 0;
      uint64_t v112 = *(void *)(v105 + 16);
      if (v112 < 0)
      {
        unint64_t v113 = (uint64_t *)((v106 + (v112 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
        int64_t v114 = *v113;
        char *v113 = 0LL;
        swift_bridgeObjectRelease(v33);
        swift_release(v114);
      }

      else
      {
        swift_bridgeObjectRelease(v33);
      }

      *uint64_t v34 = *(void *)(v105 + 24);
LABEL_23:
      ((void (*)(unint64_t *__return_ptr, unint64_t, unint64_t))v126)( &__src,  AssociatedTypeWitness,  v127);
      unint64_t v35 = __src;
      uint64_t v33 = v132;
      if (!v132) {
        goto LABEL_107;
      }
    }
  }

  unint64_t v23 = __src;
  int64_t v24 = v132;
  uint64_t v25 = v130;
  char v26 = v130[1];
  uint64_t v27 = HIBYTE(v26) & 0xF;
  if ((v26 & 0x2000000000000000LL) == 0) {
    uint64_t v27 = *v130 & 0xFFFFFFFFFFFFLL;
  }
  if (v27 || (*v130 & ~v26 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(__src, v132);
LABEL_15:
    swift_bridgeObjectRelease(v24);
    return;
  }

  swift_bridgeObjectRelease(v26);
  *uint64_t v25 = v23;
  v25[1] = v24;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  unint64_t v39 = v93;
  unint64_t v40 = v35(a4, a6);
  if (v40 < 64)
  {
    uint64_t v43 = v94;
    v34(v94, (uint64_t)v39, a4);
    unint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    v37(v43, a4);
    unint64_t v45 = v101;
    if (v44 < v104) {
      goto LABEL_40;
    }
    goto LABEL_23;
  }

  uint64_t v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  __int128 v57 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
  __int128 v58 = v94;
  v56(&v104, &type metadata for Int, v57, a4, a6);
  uint64_t v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v93,  v58,  a4);
  uint64_t v55 = v58;
  unint64_t v39 = v93;
LABEL_13:
  v37(v55, a4);
  unint64_t v45 = v101;
  if ((v54 & 1) != 0) {
    goto LABEL_40;
  }
LABEL_23:
  v37(v39, a4);
LABEL_24:
  unint64_t v72 = v35(a4, a6);
  v34(v23, (uint64_t)v33, a4);
  if (v72 >= 65)
  {
    v37(v23, a4);
    goto LABEL_26;
  }

  uint64_t v80 = v35(a4, a6);
  v37(v23, a4);
  if (v80 == 64 && (v102(a4, a6) & 1) == 0)
  {
LABEL_26:
    v34(v45, (uint64_t)v33, a4);
    uint64_t v104 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v73 = v102(a4, a6);
    Swift::String::Index v74 = v35(a4, a6);
    if ((v73 & 1) != 0)
    {
      if (v74 > 64)
      {
        uint64_t v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        uint64_t v78 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
        int64_t v79 = &v104;
        goto LABEL_35;
      }
    }

    else if (v74 > 63)
    {
      uint64_t v103 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      uint64_t v78 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      int64_t v79 = &v103;
LABEL_35:
      uint64_t v82 = v94;
      v77(v79, &type metadata for Int, v78, a4, a6);
      char v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v82,  v45,  a4);
      v37(v82, a4);
      if ((v83 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_36;
    }

    uint64_t v81 = v94;
    v34(v94, (uint64_t)v45, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    v37(v81, a4);
LABEL_36:
    v37(v45, a4);
  }

  unint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
  v37(v33, a4);
  unint64_t v85 = v100;
  unint64_t v86 = v95;
  (*((void (**)(uint64_t, uint64_t, uint64_t))v99 + 17))(v100, v84, v98);
  uint64_t v88 = v96;
  unint64_t v87 = v97;
  (*(void (**)(uint64_t, unint64_t))(v96 + 8))(v85, v97);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v88 + 32))(v85, v86, v87);
}

  uint64_t v46 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
  uint64_t v49 = (v47 & 1) == 0 && v46 >= 0;
  if ((v13 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if ((v49 & 1) != 0) {
      goto LABEL_58;
    }
  }

  else if ((v49 & 1) != 0)
  {
LABEL_57:
    _StringGuts.grow(_:)(v12);
LABEL_58:
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    v314 = 0uLL;
    uint64_t v54 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v314, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v54, v55, 1);
    unint64_t v44 = 0xE000000000000000LL;
    goto LABEL_59;
  }

  uint64_t v50 = _StringGuts.nativeCapacity.getter(countAndFlagsBits, object);
  if ((v51 & 1) != 0) {
    uint64_t v52 = 0LL;
  }
  else {
    uint64_t v52 = v50;
  }
  if (v52 + 0x4000000000000000LL >= 0)
  {
    uint64_t v53 = 2 * v52;
    if (v53 > v12) {
      uint64_t v12 = v53;
    }
    goto LABEL_57;
  }

  __break(1u);
LABEL_279:
  uint64_t v116 = _StringObject.sharedUTF8.getter(v49, countAndFlagsBits);
  uint64_t v117 = v308;
  swift_bridgeObjectRelease(countAndFlagsBits);
  if (v117 < v1) {
    goto LABEL_282;
  }
LABEL_109:
  a1 = v313;
  uint64_t v118 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v1, (uint64_t)v116, v117);
  _StringGuts.appendInPlace(_:isASCII:)(v118, v119, v49 < 0);
  swift_bridgeObjectRelease_n(countAndFlagsBits, 2LL);
  while (1)
  {
    uint64_t countAndFlagsBits = v315._countAndFlagsBits;
    unint64_t object = (unint64_t)v315._object;
    Swift::String::Index v120 = ((unint64_t)v315._object >> 56) & 0xF;
    else {
      uint64_t v121 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v121 && (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000LL) == 0)
    {
      v315._uint64_t countAndFlagsBits = 46LL;
      v315._unint64_t object = (void *)0xE100000000000000LL;
      unint64_t v136 = object;
      goto LABEL_138;
    }

    if (((uint64_t)v315._object & 0x2000000000000000LL) == 0 || v120 == 15)
    {
      swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v101, v102);
      if ((object & 0x1000000000000000LL) == 0)
      {
        uint64_t v129 = __OFADD__(v121, 1LL);
        uint64_t v130 = v121 + 1;
        if (v129) {
          goto LABEL_267;
        }
LABEL_125:
        if ((countAndFlagsBits & ~object & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
        {
          unint64_t v131 = (unint64_t)v315._object;
          uint64_t v132 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
          if ((v133 & 1) != 0) {
            goto LABEL_284;
          }
          if (v130 > 15 || (v131 & 0x2000000000000000LL) == 0 && v132 > 0) {
            goto LABEL_131;
          }
        }

        else if (v130 > 15)
        {
LABEL_131:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v130, 1LL);
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          v314 = xmmword_1817FFFB0;
          uint64_t v134 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v314, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v134, v135, 1);
          unint64_t v136 = 0xE100000000000000LL;
LABEL_138:
          swift_bridgeObjectRelease(v136);
          goto LABEL_139;
        }

        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        uint64_t v137 = v315._countAndFlagsBits;
        unint64_t v138 = v315._object;
        swift_bridgeObjectRetain((unint64_t)v315._object, v139, v140, v141);
        int64_t v142 = _StringGuts._convertedToSmall()(v137, (unint64_t)v138);
        unint64_t v144 = v143;
        swift_bridgeObjectRelease((uint64_t)v138);
        v145._rawBits = 1LL;
        v146._rawBits = 65537LL;
        v147._rawBits = _StringGuts.validateScalarRange(_:)(v145, v146, 0x2EuLL, 0xE100000000000000LL);
        if (v147._rawBits < 0x10000) {
          v147._rawBits |= 3;
        }
        uint64_t v149 = specialized String.init(_:)(v147, v148, 0x2EuLL, 0xE100000000000000LL);
        size_t v151 = v150;
        swift_bridgeObjectRelease(0xE100000000000000LL);
        unint64_t v152 = _StringGuts._convertedToSmall()(v149, v151);
        Swift::Int v154 = v153;
        swift_bridgeObjectRelease(v151);
        Swift::Int v155 = specialized _SmallString.init(_:appending:)(v142, v144, v152, v154);
        if ((v157 & 1) != 0) {
          goto LABEL_283;
        }
        char v158 = v155;
        uint64_t v159 = v156;
        swift_bridgeObjectRelease(0xE100000000000000LL);
        unint64_t v136 = (uint64_t)v315._object;
        v315._uint64_t countAndFlagsBits = v158;
        v315._unint64_t object = v159;
        goto LABEL_138;
      }

      v302 = String.UTF8View._foreignCount()();
      uint64_t v130 = v302 + 1;
      if (!__OFADD__(v302, 1LL)) {
        goto LABEL_125;
      }
LABEL_267:
      __break(1u);
LABEL_268:
      v303 = String.UTF8View._foreignCount()();
      uint64_t v233 = v303 + 1;
      if (__OFADD__(v303, 1LL)) {
        goto LABEL_270;
      }
LABEL_204:
      if ((countAndFlagsBits & ~object & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
      {
        unint64_t v234 = (unint64_t)v315._object;
        uint64_t v235 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
        if ((v236 & 1) == 0)
        {
          if (v233 > 15 || (v234 & 0x2000000000000000LL) == 0 && v235 > 0) {
            goto LABEL_210;
          }
          goto LABEL_212;
        }

    if (v16 <= 15) {
      goto LABEL_13;
    }
    goto LABEL_41;
  }

  swift_bridgeObjectRelease(v8);
  unint64_t v48 = 0xE000000000000000LL;
  v339 = 0LL;
LABEL_38:
  while (2)
  {
    v340 = v48;
LABEL_60:
    TypeName = (uint8x16_t *)swift_getTypeName(a1, 0);
    if (v61 < 0)
    {
      LODWORD(v333) = 0;
      v332 = 1343LL;
      LOBYTE(v331) = 2;
      v315 = "UnsafeBufferPointer with negative count";
      v316 = 39LL;
      goto LABEL_262;
    }

    uint64_t v64 = v61;
    v335 = v4;
    v336 = a2;
    v337 = a1;
    if (!v61)
    {
      uint64_t v4 = 0LL;
      uint64_t v3 = 0xE000000000000000LL;
LABEL_168:
      uint64_t v53 = 0LL;
      goto LABEL_169;
    }

    BOOL v65 = (uint64_t *)TypeName;
    int64_t v66 = TypeName;
    if ((v61 & 0xFFFFFFFFFFFFFFF0LL) != 0)
    {
      if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080LL) != 0) {
        goto LABEL_82;
      }
      int64_t v66 = TypeName + 1;
      while (v66 < (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFF0LL])
      {
        int64_t v67 = v66->i64[0];
        uint64_t v68 = v66->i64[1];
        ++v66;
        if (((v68 | v67) & 0x8080808080808080LL) != 0) {
          goto LABEL_82;
        }
      }
    }

    if (v66 < (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFF8LL])
    {
      if ((v66->i64[0] & 0x8080808080808080LL) != 0) {
        goto LABEL_82;
      }
      int64_t v66 = (uint8x16_t *)((char *)v66 + 8);
    }

    if (v66 < (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFFCLL])
    {
      if ((v66->i32[0] & 0x80808080) != 0) {
        goto LABEL_82;
      }
      int64_t v66 = (uint8x16_t *)((char *)v66 + 4);
    }

    if (v66 >= (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFFELL])
    {
LABEL_78:
      if (v66 >= (uint8x16_t *)&TypeName->i8[v61] || (v66->i8[0] & 0x80000000) == 0)
      {
        if (v61 > 15)
        {
          uint64_t v69 = 1;
LABEL_122:
          uint64_t v3 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( TypeName->i8,  v61,  v61,  v69 & 1);
          uint64_t v53 = 0LL;
          uint64_t v4 = *(void *)(v3 + 24);
          goto LABEL_169;
        }

  v41(v54, a3);
LABEL_41:
  char v83 = v113;
  unint64_t v84 = v114;
  unint64_t v85 = v114(a3, a4);
  unint64_t v86 = v110;
  v47(v110, v83, a3);
  if (v85 >= 65)
  {
    v41(v86, a3);
    goto LABEL_43;
  }

  unint64_t v94 = v84(a3, a4);
  v41(v86, a3);
  if (v94 == 64 && (v27(a3, a4) & 1) == 0)
  {
LABEL_43:
    v47(v112, v113, a3);
    uint64_t v117 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v87 = v27(a3, a4);
    uint64_t v88 = v114(a3, a4);
    if ((v87 & 1) != 0)
    {
      if (v88 > 64)
      {
        unint64_t v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
        uint64_t v93 = &v117;
        goto LABEL_52;
      }
    }

    else if (v88 >= 64)
    {
      uint64_t v116 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
      uint64_t v93 = &v116;
LABEL_52:
      v91(v93, &type metadata for Int, v92, a3, a4);
      uint64_t v95 = v112;
      unint64_t v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v26,  v112,  a3);
      v41(v26, a3);
      if ((v96 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_53;
    }

    uint64_t v95 = v112;
    v47(v26, v112, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v41(v26, a3);
LABEL_53:
    v41(v95, a3);
  }

  uint64_t v97 = v113;
  uint64_t v98 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v41(v97, a3);
  uint64_t v99 = *v115;
  uint64_t v100 = v115[1];
  if ((v98 & 0x8000000000000000LL) != 0)
  {
    if (v98 > 0xFFFFFFFFFFFFFF80LL)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      Swift::_HashTable::Bucket_optional result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v117, v100, v99, v103);
      goto LABEL_57;
    }
  }

  else if (v98 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    Swift::_HashTable::Bucket_optional result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v117, v100, v99, v101);
LABEL_57:
    uint64_t v62 = v117;
    goto LABEL_58;
  }

  v41(v54, a3);
LABEL_41:
  char v83 = v113;
  unint64_t v84 = v114;
  unint64_t v85 = v114(a3, a4);
  unint64_t v86 = v110;
  v47(v110, v83, a3);
  if (v85 >= 65)
  {
    v41(v86, a3);
    goto LABEL_43;
  }

  unint64_t v94 = v84(a3, a4);
  v41(v86, a3);
  if (v94 == 64 && (v27(a3, a4) & 1) == 0)
  {
LABEL_43:
    v47(v112, v113, a3);
    uint64_t v117 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v87 = v27(a3, a4);
    uint64_t v88 = v114(a3, a4);
    if ((v87 & 1) != 0)
    {
      if (v88 > 64)
      {
        unint64_t v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
        uint64_t v93 = &v117;
        goto LABEL_52;
      }
    }

    else if (v88 >= 64)
    {
      uint64_t v116 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
      uint64_t v93 = &v116;
LABEL_52:
      v91(v93, &type metadata for Int, v92, a3, a4);
      uint64_t v95 = v112;
      unint64_t v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v26,  v112,  a3);
      v41(v26, a3);
      if ((v96 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_53;
    }

    uint64_t v95 = v112;
    v47(v26, v112, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v41(v26, a3);
LABEL_53:
    v41(v95, a3);
  }

  uint64_t v97 = v113;
  uint64_t v98 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v41(v97, a3);
  uint64_t v99 = *v115;
  uint64_t v100 = v115[1];
  if ((v98 & 0x8000000000000000LL) != 0)
  {
    if (v98 > 0xFFFFFFFFFFFFFF80LL)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      Swift::_HashTable::Bucket_optional result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v117, v100, v99, v103);
      goto LABEL_57;
    }
  }

  else if (v98 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    Swift::_HashTable::Bucket_optional result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v117, v100, v99, v101);
LABEL_57:
    uint64_t v62 = v117;
    goto LABEL_58;
  }

      __break(1u);
      goto LABEL_41;
    }

      if ((_UNKNOWN *)a1 == &unk_189B8CD38)
      {
        unint64_t v40 = "Builtin.Int1";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CD48)
      {
        unint64_t v40 = "Builtin.Int7";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CD58)
      {
        unint64_t v40 = "Builtin.Int8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CD68)
      {
        unint64_t v40 = "Builtin.Int16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CD78)
      {
        unint64_t v40 = "Builtin.Int32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CD88)
      {
        unint64_t v40 = "Builtin.Int63";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CD98)
      {
        unint64_t v40 = "Builtin.Int64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CDA8)
      {
        unint64_t v40 = "Builtin.Int128";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CDB8)
      {
        unint64_t v40 = "Builtin.Int256";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CDC8)
      {
        unint64_t v40 = "Builtin.Int512";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CDD8)
      {
        unint64_t v40 = "Builtin.Word";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CDE8)
      {
        unint64_t v40 = "Builtin.FPIEEE16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CDF8)
      {
        unint64_t v40 = "Builtin.FPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CE08)
      {
        unint64_t v40 = "Builtin.FPIEEE64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CE18)
      {
        unint64_t v40 = "Builtin.FPIEEE80";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CE28)
      {
        unint64_t v40 = "Builtin.FPIEEE128";
      }

      else if ((uint64_t *)a1 == &qword_189B8CE38)
      {
        unint64_t v40 = "Builtin.NativeObject";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CE48)
      {
        unint64_t v40 = "Builtin.BridgeObject";
      }

      else if ((char *)a1 == &byte_189B8CE58)
      {
        unint64_t v40 = "Builtin.RawPointer";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CE68)
      {
        unint64_t v40 = "Builtin.UnsafeValueBuffer";
      }

      else if ((_UNKNOWN **)a1 == &off_189B8CE78)
      {
        unint64_t v40 = "Builtin.UnknownObject";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CE88)
      {
        unint64_t v40 = "Builtin.RawUnsafeContinuation";
      }

      else if ((char *)a1 == &byte_189B8CE98)
      {
        unint64_t v40 = "Builtin.DefaultActorStorage";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CEA8)
      {
        unint64_t v40 = "Builtin.NonDefaultDistributedActorStorage";
      }

      else if ((uint64_t *)a1 == &qword_189B8CEB8)
      {
        unint64_t v40 = "Builtin.Executor";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CEC8)
      {
        unint64_t v40 = "Builtin.Job";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CED8)
      {
        unint64_t v40 = "Builtin.Vec2xInt8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CEE8)
      {
        unint64_t v40 = "Builtin.Vec3xInt8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CEF8)
      {
        unint64_t v40 = "Builtin.Vec4xInt8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF08)
      {
        unint64_t v40 = "Builtin.Vec8xInt8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF18)
      {
        unint64_t v40 = "Builtin.Vec16xInt8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF28)
      {
        unint64_t v40 = "Builtin.Vec32xInt8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF38)
      {
        unint64_t v40 = "Builtin.Vec64xInt8";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF48)
      {
        unint64_t v40 = "Builtin.Vec2xInt16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF58)
      {
        unint64_t v40 = "Builtin.Vec3xInt16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF68)
      {
        unint64_t v40 = "Builtin.Vec4xInt16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF78)
      {
        unint64_t v40 = "Builtin.Vec8xInt16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF88)
      {
        unint64_t v40 = "Builtin.Vec16xInt16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CF98)
      {
        unint64_t v40 = "Builtin.Vec32xInt16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CFA8)
      {
        unint64_t v40 = "Builtin.Vec64xInt16";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CFB8)
      {
        unint64_t v40 = "Builtin.Vec2xInt32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CFC8)
      {
        unint64_t v40 = "Builtin.Vec3xInt32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CFD8)
      {
        unint64_t v40 = "Builtin.Vec4xInt32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CFE8)
      {
        unint64_t v40 = "Builtin.Vec8xInt32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8CFF8)
      {
        unint64_t v40 = "Builtin.Vec16xInt32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D008)
      {
        unint64_t v40 = "Builtin.Vec32xInt32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D018)
      {
        unint64_t v40 = "Builtin.Vec64xInt32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D028)
      {
        unint64_t v40 = "Builtin.Vec2xInt64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D038)
      {
        unint64_t v40 = "Builtin.Vec3xInt64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D048)
      {
        unint64_t v40 = "Builtin.Vec4xInt64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D058)
      {
        unint64_t v40 = "Builtin.Vec8xInt64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D068)
      {
        unint64_t v40 = "Builtin.Vec16xInt64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D078)
      {
        unint64_t v40 = "Builtin.Vec32xInt64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D088)
      {
        unint64_t v40 = "Builtin.Vec64xInt64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D098)
      {
        unint64_t v40 = "Builtin.Vec2xFPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D0A8)
      {
        unint64_t v40 = "Builtin.Vec3xFPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D0B8)
      {
        unint64_t v40 = "Builtin.Vec4xFPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D0C8)
      {
        unint64_t v40 = "Builtin.Vec8xFPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D0D8)
      {
        unint64_t v40 = "Builtin.Vec16xFPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D0E8)
      {
        unint64_t v40 = "Builtin.Vec32xFPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D0F8)
      {
        unint64_t v40 = "Builtin.Vec64xFPIEEE32";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D108)
      {
        unint64_t v40 = "Builtin.Vec2xFPIEEE64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D118)
      {
        unint64_t v40 = "Builtin.Vec3xFPIEEE64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D128)
      {
        unint64_t v40 = "Builtin.Vec4xFPIEEE64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D138)
      {
        unint64_t v40 = "Builtin.Vec8xFPIEEE64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D148)
      {
        unint64_t v40 = "Builtin.Vec16xFPIEEE64";
      }

      else if ((_UNKNOWN *)a1 == &unk_189B8D158)
      {
        unint64_t v40 = "Builtin.Vec32xFPIEEE64";
      }

      else
      {
        if ((_UNKNOWN *)a1 != &unk_189B8D168) {
          goto LABEL_349;
        }
        unint64_t v40 = "Builtin.Vec64xFPIEEE64";
      }

      Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 20, v40);
      if (!Node) {
LABEL_349:
      }
        Node = 0LL;
      break;
  }

  return Node;
}

  uint64_t v30 = 0LL;
  uint64_t v31 = *(void *)(v8 + 16);
  *(void *)(v8 + 16) = 0LL;
  if (v20 | v31)
  {
    uint64_t v30 = (unint64_t)operator new(0x20uLL);
    *(void *)uint64_t v30 = v20;
    *(void *)(v30 + 8) = v3;
    *(void *)(v30 + 16) = v31;
  }

  uint64_t v32 = *(os_unfair_lock_s **)a2;
  os_unfair_lock_lock(*(os_unfair_lock_t *)a2);
  atomic_store(v30 | v29, (unint64_t *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a2 + 8) + 8LL));
  uint64_t v33 = *(void **)(a2 + 8);
  if (*v33 == 1LL)
  {
    uint64_t v34 = (void *)v33[2];
    void v33[2] = 0LL;
    if (v34) {
      operator delete(v34);
    }
    swift_slowDealloc(v33);
  }

  else
  {
    --*v33;
  }

  os_unfair_lock_unlock(v32);
  *(_BYTE *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0LL;
  return *(void *)(a1 + 8);
}

  operator delete(*(void **)(v34 - 160));
  if (((char)v66.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_26:
    goto LABEL_42;
  }

    uint64_t v34 = (uint64_t *)(a1 + 8);
LABEL_41:
    uint64_t v32 = *v34;
    goto LABEL_42;
  }

  if ((_DWORD)v33 == 515 || (_DWORD)v33 == 516) {
    goto LABEL_40;
  }
LABEL_42:
  uint64_t v56 = v32;
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a1, v27, v28, v29);
  __int128 v58 = v60;
  uint64_t v59 = 0x800000000LL;
  v60[32] = 0LL;
  v49[0] = off_189B8E310;
  v49[1] = &v55;
  uint64_t v50 = v49;
  v47[0] = off_189B8E358;
  v47[1] = &v55;
  unint64_t v48 = v47;
  swift_getTypeByMangledName(0LL, v30, v31, (uint64_t)GenericArgs, v49, v47, (uint64_t)&v51);
  unint64_t v35 = v48;
  if (v48 == v47)
  {
    uint64_t v36 = 4LL;
    unint64_t v35 = v47;
  }

  else
  {
    if (!v48) {
      goto LABEL_47;
    }
    uint64_t v36 = 5LL;
  }

  (*(void (**)(void))(*v35 + 8 * v36))();
LABEL_47:
  uint64_t v37 = v50;
  if (v50 == v49)
  {
    uint64_t v38 = 4LL;
    uint64_t v37 = v49;
    goto LABEL_51;
  }

  if (v50)
  {
    uint64_t v38 = 5LL;
LABEL_51:
    (*(void (**)(void))(*v37 + 8 * v38))();
  }

  unint64_t v39 = v54;
  if (v54)
  {
    if (v54 == 1)
    {
      unint64_t v40 = v52(v51, 0LL, 0LL);
      v52(v51, 1LL, v40);
      unint64_t v44 = 0;
      unint64_t v39 = v54;
      unint64_t v45 = &unk_189B8D178;
    }

    else
    {
      unint64_t v45 = 0LL;
      unint64_t v44 = 0;
    }
  }

  else
  {
    unint64_t v45 = v51;
    unint64_t v44 = v53;
  }

  uint64_t v46 = *(_BYTE *)v16;
  *(void *)a3 = v18;
  *(void *)(a3 + 8) = v19;
  *(void *)(a3 + 16) = v45;
  *(_BYTE *)(a3 + 24) = v46 & 1;
  *(_BYTE *)(a3 + 25) = (v46 & 2) != 0;
  *(_BYTE *)(a3 + 26) = v44;
  if (v39 == 1) {
    v52(v51, 3LL, 0LL);
  }
  if (v58 != v60) {
    free(v58);
  }
}

    switch(v10)
    {
      case 0:
        uint64_t v31 = swift::Demangle::__runtime::Demangler::popProtocol(this, a2, a3, a4, a5);
        uint64_t v32 = 0LL;
        if (!v14) {
          return v32;
        }
        uint64_t v8 = (swift::Demangle::__runtime::Node *)v31;
        if (!v31) {
          return v32;
        }
        goto LABEL_47;
      case 1:
        uint64_t v33 = *((_DWORD *)this + 24);
        if (!v33) {
          goto LABEL_122;
        }
        uint64_t v34 = v33 - 1;
        uint64_t v8 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v34);
        if (*((_WORD *)v8 + 8) != 232) {
          goto LABEL_122;
        }
        *((_DWORD *)this + 24) = v34;
        if (!v14) {
          goto LABEL_122;
        }
LABEL_47:
        uint64_t v32 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v32 || v32 + 24 > *((void *)this + 2))
        {
          unint64_t v35 = 2LL * *((void *)this + 4);
          if (v35 <= 0x20) {
            unint64_t v35 = 32LL;
          }
          *((void *)this + 4) = v35;
          uint64_t v36 = v35 + 8;
          uint64_t v37 = malloc(v35 + 8);
          uint64_t v38 = (char *)v37 + v36;
          void *v37 = *((void *)this + 3);
          uint64_t v32 = ((unint64_t)v37 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v38;
          *((void *)this + 3) = v37;
        }

        *((void *)this + 1) = v32 + 24;
        unint64_t v39 = 36;
        goto LABEL_89;
      case 2:
        unint64_t v40 = *((_DWORD *)this + 24);
        if (!v40) {
          goto LABEL_122;
        }
        unint64_t v41 = v40 - 1;
        uint64_t v8 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v41);
        if (*((_WORD *)v8 + 8) != 232) {
          goto LABEL_122;
        }
        *((_DWORD *)this + 24) = v41;
        if (!v14) {
          goto LABEL_122;
        }
        uint64_t v32 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v32 || v32 + 24 > *((void *)this + 2))
        {
          uint64_t v42 = 2LL * *((void *)this + 4);
          if (v42 <= 0x20) {
            uint64_t v42 = 32LL;
          }
          *((void *)this + 4) = v42;
          uint64_t v43 = v42 + 8;
          unint64_t v44 = malloc(v42 + 8);
          unint64_t v45 = (char *)v44 + v43;
          char *v44 = *((void *)this + 3);
          uint64_t v32 = ((unint64_t)v44 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v45;
          *((void *)this + 3) = v44;
        }

        *((void *)this + 1) = v32 + 24;
        unint64_t v39 = 39;
        goto LABEL_89;
      case 3:
        uint64_t v46 = *((_DWORD *)this + 24);
        if (!v46) {
          goto LABEL_122;
        }
        __int128 v47 = v46 - 1;
        uint64_t v8 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v47);
        if (*((_WORD *)v8 + 8) != 232) {
          goto LABEL_122;
        }
        *((_DWORD *)this + 24) = v47;
        if (!v14) {
          goto LABEL_122;
        }
        uint64_t v32 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v32 || v32 + 24 > *((void *)this + 2))
        {
          unint64_t v48 = 2LL * *((void *)this + 4);
          if (v48 <= 0x20) {
            unint64_t v48 = 32LL;
          }
          *((void *)this + 4) = v48;
          uint64_t v49 = v48 + 8;
          uint64_t v50 = malloc(v48 + 8);
          unint64_t v51 = (char *)v50 + v49;
          *uint64_t v50 = *((void *)this + 3);
          uint64_t v32 = ((unint64_t)v50 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v51;
          *((void *)this + 3) = v50;
        }

        *((void *)this + 1) = v32 + 24;
        unint64_t v39 = 40;
        goto LABEL_89;
      case 4:
        uint64_t v52 = *((void *)this + 9);
        if (v52 >= *((void *)this + 8)) {
          goto LABEL_122;
        }
        uint64_t v32 = 0LL;
        *((void *)this + 9) = v52 + 1;
        uint64_t v53 = "U";
        uint64_t v54 = 0LL;
        switch(*(_BYTE *)(*((void *)this + 7) + v52))
        {
          case 'B':
            uint64_t v32 = 0LL;
            uint64_t v54 = 0LL;
            uint64_t v53 = "B";
            goto LABEL_106;
          case 'C':
            uint64_t v32 = 0LL;
            uint64_t v54 = 0LL;
            uint64_t v53 = "C";
            goto LABEL_106;
          case 'D':
            uint64_t v32 = 0LL;
            uint64_t v54 = 0LL;
            uint64_t v53 = "D";
            goto LABEL_106;
          case 'E':
            uint64_t v32 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
            if (!v32) {
              return v32;
            }
            uint64_t v54 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
            uint64_t v53 = "E";
            goto LABEL_106;
          case 'M':
            uint64_t v32 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
            if (!v32) {
              return v32;
            }
            uint64_t v54 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
            uint64_t v53 = "M";
            goto LABEL_106;
          case 'N':
            uint64_t v32 = 0LL;
            uint64_t v54 = 0LL;
            uint64_t v53 = "N";
            goto LABEL_106;
          case 'R':
            uint64_t v32 = 0LL;
            uint64_t v54 = 0LL;
            uint64_t v53 = "R";
            goto LABEL_106;
          case 'S':
            BOOL v65 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
            uint64_t v54 = 0LL;
            if (!v65) {
              return 0LL;
            }
            uint64_t v32 = v65;
            uint64_t v53 = "S";
            goto LABEL_106;
          case 'T':
            uint64_t v32 = 0LL;
            uint64_t v54 = 0LL;
            uint64_t v53 = "T";
            goto LABEL_106;
          case 'U':
            goto LABEL_106;
          case 'e':
            int64_t v66 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
            uint64_t v54 = 0LL;
            if (!v66) {
              return 0LL;
            }
            uint64_t v32 = v66;
            uint64_t v53 = "e";
            goto LABEL_106;
          case 'm':
            int64_t v67 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
            uint64_t v54 = 0LL;
            if (!v67) {
              return 0LL;
            }
            uint64_t v32 = v67;
            uint64_t v53 = "m";
LABEL_106:
            uint64_t v68 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
            if (!v68 || v68 + 24 > *((void *)this + 2))
            {
              uint64_t v69 = 2LL * *((void *)this + 4);
              if (v69 <= 0x20) {
                uint64_t v69 = 32LL;
              }
              *((void *)this + 4) = v69;
              uint64_t v70 = v69 + 8;
              uint64_t v71 = malloc(v69 + 8);
              unint64_t v72 = (char *)v71 + v70;
              *uint64_t v71 = *((void *)this + 3);
              uint64_t v68 = ((unint64_t)v71 + 15) & 0xFFFFFFFFFFFFFFF8LL;
              *((void *)this + 2) = v72;
              *((void *)this + 3) = v71;
            }

            *((void *)this + 1) = v68 + 24;
            *(_WORD *)(v68 + 16) = 101;
            *(_BYTE *)(v68 + 18) = 3;
            *(void *)uint64_t v68 = v53;
            *(void *)(v68 + 8) = 1LL;
            if (!v14) {
              goto LABEL_122;
            }
            uint64_t v73 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
            if (!v73 || v73 + 24 > *((void *)this + 2))
            {
              Swift::String::Index v74 = 2LL * *((void *)this + 4);
              if (v74 <= 0x20) {
                Swift::String::Index v74 = 32LL;
              }
              *((void *)this + 4) = v74;
              uint64_t v75 = v74 + 8;
              uint64_t v76 = malloc(v74 + 8);
              uint64_t v77 = (char *)v76 + v75;
              *uint64_t v76 = *((void *)this + 3);
              uint64_t v73 = ((unint64_t)v76 + 15) & 0xFFFFFFFFFFFFFFF8LL;
              *((void *)this + 2) = v77;
              *((void *)this + 3) = v76;
            }

            *((void *)this + 1) = v73 + 24;
            *(_WORD *)(v73 + 16) = 41;
            *(_BYTE *)(v73 + 18) = 0;
            swift::Demangle::__runtime::Node::addChild( (unsigned int *)v73,  (swift::Demangle::__runtime::Node *)v14,  this,  a4,  a5);
            swift::Demangle::__runtime::Node::addChild( (unsigned int *)v73,  (swift::Demangle::__runtime::Node *)v68,  this,  v78,  v79);
            if (v32) {
              swift::Demangle::__runtime::Node::addChild( (unsigned int *)v73,  (swift::Demangle::__runtime::Node *)v32,  this,  v80,  v81);
            }
            if (v54) {
              swift::Demangle::__runtime::Node::addChild((unsigned int *)v73, v54, this, v80, v81);
            }
            uint64_t v32 = v73;
            break;
          default:
            return v32;
        }

        return v32;
      case 5:
        if (!v14) {
          goto LABEL_122;
        }
        uint64_t v32 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v32 || v32 + 24 > *((void *)this + 2))
        {
          uint64_t v55 = 2LL * *((void *)this + 4);
          if (v55 <= 0x20) {
            uint64_t v55 = 32LL;
          }
          *((void *)this + 4) = v55;
          uint64_t v56 = v55 + 8;
          __int128 v57 = malloc(v55 + 8);
          __int128 v58 = (char *)v57 + v56;
          id *v57 = *((void *)this + 3);
          uint64_t v32 = ((unint64_t)v57 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v58;
          *((void *)this + 3) = v57;
        }

        *((void *)this + 1) = v32 + 24;
        *(_WORD *)(v32 + 16) = 42;
        *(_BYTE *)(v32 + 18) = 0;
        uint64_t v59 = (unsigned int *)v32;
        unint64_t v60 = (swift::Demangle::__runtime::Node *)v14;
        goto LABEL_90;
      case 6:
        uint64_t v32 = 0LL;
        if (!v8 || !v14) {
          return v32;
        }
        uint64_t v32 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v32 || v32 + 24 > *((void *)this + 2))
        {
          uint64_t v61 = 2LL * *((void *)this + 4);
          if (v61 <= 0x20) {
            uint64_t v61 = 32LL;
          }
          *((void *)this + 4) = v61;
          uint64_t v62 = v61 + 8;
          uint64_t v63 = malloc(v61 + 8);
          uint64_t v64 = (char *)v63 + v62;
          uint64_t *v63 = *((void *)this + 3);
          uint64_t v32 = ((unint64_t)v63 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v64;
          *((void *)this + 3) = v63;
        }

        *((void *)this + 1) = v32 + 24;
        unint64_t v39 = 354;
LABEL_89:
        *(_WORD *)(v32 + 16) = v39;
        *(_BYTE *)(v32 + 18) = 0;
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v32,  (swift::Demangle::__runtime::Node *)v14,  this,  a4,  a5);
        uint64_t v59 = (unsigned int *)v32;
        unint64_t v60 = v8;
LABEL_90:
        swift::Demangle::__runtime::Node::addChild(v59, v60, this, a4, a5);
        break;
      default:
        goto LABEL_122;
    }
  }

  else
  {
    uint64_t v7 = v6 + 1;
    *((void *)this + 9) = v6 + 1;
    uint64_t v8 = 0LL;
    uint64_t v9 = 1;
    uint64_t v10 = 5;
    switch(*(_BYTE *)(*((void *)this + 7) + v6))
    {
      case 'B':
        goto LABEL_20;
      case 'C':
        goto LABEL_25;
      case 'I':
        uint64_t v11 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
        if (!v11) {
          goto LABEL_122;
        }
        uint64_t v8 = (swift::Demangle::__runtime::Node *)v11;
        uint64_t v9 = 6;
LABEL_20:
        uint64_t v19 = *((_DWORD *)this + 24);
        if (v19 && (v20 = v19 - 1, uint64_t v14 = *(void *)(*((void *)this + 11) + 8LL * v20), *(_WORD *)(v14 + 16) == 232)) {
          *((_DWORD *)this + 24) = v20;
        }
        else {
          uint64_t v14 = 0LL;
        }
        goto LABEL_39;
      case 'L':
        uint64_t v8 = 0LL;
        uint64_t v9 = 4;
        goto LABEL_20;
      case 'M':
        uint64_t v9 = 4;
        goto LABEL_25;
      case 'P':
        uint64_t v9 = 0;
        goto LABEL_25;
      case 'Q':
        uint64_t v8 = 0LL;
        uint64_t v9 = 0;
        goto LABEL_20;
      case 'S':
        uint64_t v8 = 0LL;
        uint64_t v9 = 2;
        goto LABEL_20;
      case 'T':
        uint64_t v9 = 2;
LABEL_25:
        uint64_t v21 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleGenericParamIndex( this,  a2,  a3,  a4,  a5);
        uint64_t v25 = swift::Demangle::__runtime::Demangler::demangleAssociatedTypeCompound(this, v21, v22, v23, v24);
        goto LABEL_36;
      case 'b':
        uint64_t v8 = 0LL;
        uint64_t v10 = 1;
        goto LABEL_7;
      case 'c':
        goto LABEL_35;
      case 'h':
        uint64_t v8 = 0LL;
        uint64_t v10 = 3;
        goto LABEL_7;
      case 'i':
        char v26 = swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
        if (v26)
        {
          uint64_t v8 = (swift::Demangle::__runtime::Node *)v26;
          uint64_t v10 = 6;
          goto LABEL_7;
        }

    uint64_t v28 = v11;
    if ((v25 & 1) == 0) {
      uint64_t v28 = (uint64_t *)*v11;
    }
    uint64_t v29 = (swift::Demangle::__runtime::Node *)v28[v18];
LABEL_45:
    uint64_t v30 = *((unsigned __int8 *)v29 + 18);
    uint64_t v31 = (unint64_t *)v29;
    if (v30 != 1)
    {
      if (v30 != 5 || *((_DWORD *)v29 + 2) != 1)
      {
LABEL_68:
        uint64_t v12 = 3604;
        uint64_t v13 = 1;
        uint64_t v5 = v29;
        goto LABEL_14;
      }

      uint64_t v31 = *(unint64_t **)v29;
    }

    if (*(_WORD *)(*v31 + 16) != 232) {
      goto LABEL_68;
    }
    uint64_t v32 = (unint64_t *)v29;
    if (v30 == 5 && *((_DWORD *)v29 + 2))
    {
      uint64_t v32 = *(unint64_t **)v29;
LABEL_54:
      __int128 v20 = *v32;
      goto LABEL_56;
    }

    __int128 v20 = 0LL;
LABEL_56:
    if (*((_WORD *)v29 + 8) != 213) {
      goto LABEL_27;
    }
    Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(*v6, 123);
    uint64_t v36 = (swift::Demangle::__runtime::Node *)Node;
    uint64_t v37 = *(unsigned __int8 *)(v20 + 18);
    if ((v37 - 1) >= 2)
    {
      if (v37 != 5 || !*(_DWORD *)(v20 + 8))
      {
        uint64_t v21 = 0LL;
        goto LABEL_26;
      }

      __int128 v20 = *(void *)v20;
    }

    uint64_t v21 = *(swift::Demangle::__runtime::Node **)v20;
LABEL_26:
    swift::Demangle::__runtime::Node::addChild(Node, v21, (swift::Demangle::__runtime::NodeFactory *)*v6, v34, v35);
    __int128 v20 = swift::Demangle::__runtime::NodeFactory::createNode(*v6, 232);
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v20,  v36,  (swift::Demangle::__runtime::NodeFactory *)*v6,  v22,  v23);
LABEL_27:
    this = (void **)swift::Demangle::__runtime::Node::addChild( (unsigned int *)v16,  (swift::Demangle::__runtime::Node *)v20,  (swift::Demangle::__runtime::NodeFactory *)*v6,  v14,  v15);
    if (v19 == ++v18) {
      goto LABEL_60;
    }
  }

  if ((_DWORD)v24 == 1) {
    goto LABEL_77;
  }
  if ((_DWORD)v24 != 5)
  {
    if ((_DWORD)v24 == 2)
    {
      int64_t v24 = 2LL;
      goto LABEL_77;
    }

    goto LABEL_81;
  }

  int64_t v24 = *((unsigned int *)v11 + 2);
LABEL_77:
  if (v24 <= v18)
  {
LABEL_81:
    uint64_t v5 = 0LL;
  }

  else
  {
    if ((v25 & 1) == 0) {
      uint64_t v11 = (uint64_t *)*v11;
    }
    uint64_t v5 = (swift::Demangle::__runtime::Node *)v11[v18];
  }

  uint64_t v12 = 3600;
LABEL_13:
  uint64_t v13 = 1;
LABEL_14:
  *(_DWORD *)a4 = v13;
  *(void *)(a4 + 8) = v5;
  *(_DWORD *)(a4 + 16) = v12;
  return this;
}

  return NodeWithAllocatedText;
}

  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v25 == v27) {
      goto LABEL_42;
    }
  }

  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v25 == v27) {
      goto LABEL_42;
    }
  }

uint64_t @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, char *, uint64_t))_SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:));
}

void _SwiftDeferredNSDictionary.__allocating_init(coder:)()
{
}

uint64_t @objc _SwiftDeferredNSDictionary.init(coder:)(uint64_t a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDictionaryNSEnumerator.init(coder:)( a1,  a2,  a3,  (char *)_SwiftDeferredNSDictionary.__allocating_init(coder:));
}

uint64_t @objc _SwiftDictionaryNSEnumerator.init(coder:)(uint64_t a1, uint64_t a2, void *a3, char *a4)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 96LL);
  uint64_t v5 = *(void *)(*(void *)a1 + 104LL);
  uint64_t v6 = *(void *)(*(void *)a1 + 112LL);
  swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a4)(v4, v5, v6);
}

uint64_t _SwiftDeferredNSDictionary.__ivar_destroyer()
{
  return swift_release(*(void *)(v0 + 32));
}

uint64_t __SwiftNativeNSDictionary.deinit()
{
  return v0;
}

void _SwiftDeferredNSDictionary.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void **)(v4 + 16);
  swift_retain((unint64_t *)v4, a2, a3, a4);
  swift_unknownObjectRelease(v5);
  swift_unknownObjectRelease(*(id *)(v4 + 24));
  uint64_t v6 = *(void *)(v4 + 32);
  swift_release(v4);
  swift_release(v6);
  swift_deallocClassInstance(v4);
}

unint64_t __CocoaDictionary.startIndex.getter(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(a1, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v5 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v5, 24LL))
    {
      uint64_t v7 = swift_bufferAllocate(result, 8 * v5 + 24, 7uLL);
      v7[2] = v5;
      objc_msgSend(a1, sel_getObjects_andKeys_count_, 0, v7 + 3, v5);
      swift_unknownObjectRelease(a1);
      uint64_t v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v9 = swift_allocObject(v8, 0x20uLL, 7uLL);
      _OWORD v9[2] = a1;
      v9[3] = v7;
      swift_unknownObjectRetain(a1, v10, v11, v12);
      return (unint64_t)v9;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t __CocoaDictionary.endIndex.getter(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(a1, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v5 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v5, 24LL))
    {
      uint64_t v7 = swift_bufferAllocate(result, 8 * v5 + 24, 7uLL);
      v7[2] = v5;
      objc_msgSend(a1, sel_getObjects_andKeys_count_, 0, v7 + 3, v5);
      swift_unknownObjectRelease(a1);
      uint64_t v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
      uint64_t v9 = swift_allocObject(v8, 0x20uLL, 7uLL);
      _OWORD v9[2] = a1;
      v9[3] = v7;
      swift_unknownObjectRetain(a1, v10, v11, v12);
      return (unint64_t)v9;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t __CocoaDictionary.index(after:)(int64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v7 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v6, v7)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v6 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E7uLL,  0);
  }
  if (*(void *)(*(void *)(v6 + 24) + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E8uLL,  0);
  }
  return swift_bridgeObjectRetain(a1, v8, v9, v10);
}

uint64_t __CocoaDictionary.formIndex(after:isUnique:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  if (*a1 < 0) {
    uint64_t v6 = *a1;
  }
  else {
    uint64_t v6 = *a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v7 = type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t result = swift_dynamicCastClass(v6, v7);
  if (!result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v6 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E7uLL,  0);
  }
  if (v5 >= *(void *)(*(void *)(v6 + 24) + 16LL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E8uLL,  0);
  }
  a1[1] = v5 + 1;
  return result;
}

void *__CocoaDictionary.index(forKey:)(void *a1, id a2)
{
  id v4 = objc_msgSend(a2, sel_objectForKey_, a1);
  if (!v4) {
    return 0LL;
  }
  swift_unknownObjectRelease(v4);
  unint64_t v8 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(a2, v5, v6, v7), sel_count);
  unint64_t v9 = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v8 - 0x1000000000000000LL) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_11;
  }

  if (__OFADD__(8 * v8, 24LL))
  {
LABEL_11:
    __break(1u);
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v10 = swift_bufferAllocate(v9, 8 * v8 + 24, 7uLL);
  v10[2] = v8;
  objc_msgSend(a2, sel_getObjects_andKeys_count_, 0, v10 + 3, v8);
  swift_unknownObjectRelease(a2);
  if ((v10[2] & 0x8000000000000000LL) != 0) {
    goto LABEL_12;
  }
  swift_unknownObjectRetain(v10, v11, v12, v13);
  uint64_t v17 = 0LL;
  do
  {
    uint64_t v18 = v17 + 1;
    uint64_t v19 = (void *)v10[v17 + 3];
    swift_unknownObjectRetain(v19, v14, v15, v16);
    char isEqual = swift_stdlib_NSObject_isEqual(a1, v19);
    swift_unknownObjectRelease(v19);
    uint64_t v17 = v18;
  }

  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v10);
  uint64_t v21 = type metadata accessor for __CocoaDictionary.Index.Storage();
  uint64_t v22 = swift_allocObject(v21, 0x20uLL, 7uLL);
  v22[2] = a2;
  v22[3] = v10;
  swift_unknownObjectRetain(a2, v23, v24, v25);
  return v22;
}

id __CocoaDictionary.lookup(_:)(uint64_t a1, id a2)
{
  return objc_msgSend(a2, sel_objectForKey_, a1);
}

BOOL __CocoaDictionary.contains(_:)(uint64_t a1, void *a2)
{
  return __CocoaDictionary.contains(_:)(a1, a2, (SEL *)&selRef_objectForKey_);
}

void *__CocoaDictionary.lookup(_:)(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1 < 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v6 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v5, v6)) {
    goto LABEL_10;
  }
  if (*(void **)(v5 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x21CuLL,  0);
  }
  uint64_t v10 = *(void **)(*(void *)(v5 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v10, v7, v8, v9);
  if (!swift_dynamicCastClass(v5, v6)) {
LABEL_10:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (!objc_msgSend(a3, sel_objectForKey_, v10)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x21EuLL,  0);
  }
  return v10;
}

id __CocoaDictionary.key(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (void *)specialized __CocoaDictionary.key(at:)(a1, a2, a3);
  return swift_unknownObjectRetain(v3, v4, v5, v6);
}

id __CocoaDictionary.Index.key.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)specialized __CocoaDictionary.Index.key.getter(a1, a2);
  return swift_unknownObjectRetain(v2, v3, v4, v5);
}

id __CocoaDictionary.value(at:)(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1 < 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v6 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v5, v6)) {
    goto LABEL_10;
  }
  if (*(void **)(v5 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x22CuLL,  0);
  }
  uint64_t v10 = *(void **)(*(void *)(v5 + 24) + 8 * a2 + 24);
  swift_unknownObjectRetain(v10, v7, v8, v9);
  if (!swift_dynamicCastClass(v5, v6)) {
LABEL_10:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  id v11 = objc_msgSend(a3, sel_objectForKey_, v10);
  swift_unknownObjectRelease(v10);
  if (!v11) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x22EuLL,  0);
  }
  return v11;
}

__objc2_class **__CocoaDictionary.mapValues<A, B, C>(_:)( void (*a1)(char *), uint64_t a2, swift *a3, uint64_t *a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8 = v7;
  uint64_t v88 = a7;
  unint64_t v85 = a1;
  uint64_t v86 = a2;
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v72 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v77 = type metadata accessor for Optional(0LL, v17, v15, v16);
  uint64_t v18 = *(void *)(v77 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v77);
  uint64_t v21 = (char *)&v72 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (uint64_t *)((char *)&v72 - v23);
  uint64_t v87 = *((void *)a5 - 1);
  MEMORY[0x1895F8858](v22);
  unint64_t v84 = (char *)&v72 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v28 = type metadata accessor for Optional(0LL, (uint64_t)a4, v26, v27);
  uint64_t v74 = *(void *)(v28 - 8);
  uint64_t v75 = v28;
  uint64_t v29 = MEMORY[0x1895F8858](v28);
  unint64_t v72 = (char *)&v72 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v78 = (uint64_t *)((char *)&v72 - v32);
  uint64_t v89 = *(a4 - 1);
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v91 = (uint64_t)&v72 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v33);
  uint64_t v90 = (char *)&v72 - v35;
  uint64_t v82 = a3;
  id v36 = -[swift count](a3, sel_count);
  uint64_t v76 = v18;
  uint64_t v73 = v21;
  if (v36)
  {
    uint64_t v37 = (uint64_t)v36;
    type metadata accessor for _DictionaryStorage(0LL, (uint64_t)a4, a6, v88);
    uint64_t v38 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(v37);
  }

  else
  {
    uint64_t v38 = &_swiftEmptyDictionarySingleton;
  }

  uint64_t v95 = v38;
  uint64_t v39 = type metadata accessor for __CocoaDictionary.Iterator();
  unint64_t v40 = swift_allocObject(v39, 0xE8uLL, 7uLL);
  *((_OWORD *)v40 + 1) = 0u;
  uint64_t v80 = v40 + 2;
  *((_OWORD *)v40 + 5) = 0u;
  int64_t v79 = v40 + 10;
  v40[27] = 0LL;
  uint64_t v93 = v40 + 27;
  *((_OWORD *)v40 + 2) = 0u;
  *((_OWORD *)v40 + 3) = 0u;
  *((_OWORD *)v40 + 4) = 0u;
  *((_OWORD *)v40 + 6) = 0u;
  *((_OWORD *)v40 + 7) = 0u;
  *((_OWORD *)v40 + 8) = 0u;
  *((_OWORD *)v40 + 9) = 0u;
  *((_OWORD *)v40 + 10) = 0u;
  *((_OWORD *)v40 + 11) = 0u;
  *((_OWORD *)v40 + 12) = 0u;
  v40[28] = 0LL;
  unint64_t v41 = v82;
  v40[26] = v82;
  swift_unknownObjectRetain(v41, v42, v43, v44);
  uint64_t v48 = 0LL;
  uint64_t v82 = (swift *)&unk_189B8D230;
  char v83 = v40;
  unint64_t v92 = a4;
  while (1)
  {
    uint64_t v49 = (void *)v40[26];
    if (v48 != v40[28]) {
      goto LABEL_9;
    }
    id v50 = objc_msgSend((id)v40[26], sel_countByEnumeratingWithState_objects_count_, v80, v79, 16);
    v40[28] = v50;
    if (!v50) {
      break;
    }
    uint64_t v48 = 0LL;
    uint64_t *v93 = 0LL;
LABEL_9:
    uint64_t v51 = v40[3];
    if (!v51)
    {
      unint64_t v71 = 773LL;
      goto LABEL_32;
    }

    if ((unint64_t)(v48 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_29:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    uint64_t v52 = (void **)(v51 + 8 * v48);
    uint64_t v81 = v38;
    uint64_t v53 = v24;
    uint64_t v54 = a5;
    uint64_t v55 = v14;
    uint64_t v56 = *v52;
    uint64_t *v93 = v48 + 1;
    swift_unknownObjectRetain(v56, v45, v46, v47);
    __int128 v57 = (swift *)objc_msgSend(v49, sel_objectForKey_, v56);
    if (!v57)
    {
      unint64_t v71 = 784LL;
LABEL_32:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v71,  0);
    }

    __int128 v58 = v57;
    if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4))
    {
      uint64_t v59 = (const char *)a4;
      uint64_t v60 = v8;
      v94[0] = (uint64_t)v56;
      swift_dynamicCast(v90, v94, v82, v59, 7uLL);
    }

    else
    {
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v89 + 56))(v78, 1LL, 1LL, a4);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v56, (uint64_t)a4, v78);
      swift_unknownObjectRelease(v56);
      int64_t v67 = v72;
      (*(void (**)(char *, uint64_t *, uint64_t))(v74 + 16))(v72, v78, v75);
      uint64_t v60 = v8;
      (*(void (**)(uint64_t *, uint64_t))(v74 + 8))(v78, v75);
      (*(void (**)(char *, char *, uint64_t *))(v89 + 32))(v90, v67, v92);
    }

    if (_swift_isClassOrObjCExistentialType((uint64_t)v54, (uint64_t *)v54))
    {
      v94[0] = (uint64_t)v58;
      uint64_t v61 = v84;
      swift_dynamicCast(v84, v94, (swift *)&unk_189B8D230, v54, 7uLL);
      uint64_t v62 = v87;
    }

    else
    {
      uint64_t v68 = v87;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v87 + 56))(v53, 1LL, 1LL, v54);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v58, (uint64_t)v54, v53);
      swift_unknownObjectRelease(v58);
      uint64_t v69 = v73;
      (*(void (**)(char *, uint64_t *, uint64_t))(v76 + 16))(v73, v53, v77);
      if ((*(unsigned int (**)(char *, uint64_t, char *))(v68 + 48))(v69, 1LL, v54) == 1) {
LABEL_33:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      uint64_t v14 = v55;
      (*(void (**)(uint64_t *, uint64_t))(v76 + 8))(v53, v77);
      uint64_t v62 = v87;
      uint64_t v61 = v84;
      (*(void (**)(char *, char *, char *))(v87 + 32))(v84, v69, v54);
    }

    (*(void (**)(uint64_t, char *, uint64_t *))(v89 + 32))(v91, v90, v92);
    v85(v61);
    uint64_t v8 = v60;
    if (v60)
    {
      (*(void (**)(uint64_t, uint64_t *))(v89 + 8))(v91, v92);
      swift_release((uint64_t)v83);
      (*(void (**)(char *, char *))(v62 + 8))(v61, v54);
      swift_release((uint64_t)v95);
      return v81;
    }

    uint64_t v63 = *(void (**)(char *, char *))(v62 + 8);
    a5 = v54;
    v63(v61, v54);
    uint64_t v38 = v95;
    uint64_t v64 = v95[2];
    a4 = v92;
    uint64_t v65 = v88;
    if (v95[3] <= v64)
    {
      Swift::Int v66 = (Swift::Int)&v64->isa + 1;
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)v92, a6, v88);
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v66, 1);
      uint64_t v38 = v95;
    }

    _NativeDictionary._unsafeInsertNew(key:value:)(v91, (uint64_t)v14, v38, (unint64_t)a4, a6, v65);
    uint64_t v48 = *v93;
    uint64_t v24 = v53;
    unint64_t v40 = v83;
    if (*v93 < 0) {
      goto LABEL_26;
    }
  }

  uint64_t *v93 = -1LL;
LABEL_26:
  swift_release((uint64_t)v40);
  return v38;
}

double __CocoaDictionary.makeIterator()(uint64_t a1)
{
  return __CocoaDictionary.makeIterator()(a1, type metadata accessor for __CocoaDictionary.Iterator);
}

id __CocoaDictionary.Index.dictionary.getter(uint64_t a1)
{
  if (a1 < 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v2 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v1, v2)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  return swift_unknownObjectRetain(*(id *)(v1 + 16), v3, v4, v5);
}

uint64_t __CocoaDictionary.Index.age.getter(uint64_t a1, uint64_t a2)
{
  return __CocoaDictionary.Index.age.getter(a1, a2, type metadata accessor for __CocoaDictionary.Index.Storage);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance __CocoaDictionary.Index( uint64_t *a1, uint64_t *a2)
{
  return specialized static __CocoaDictionary.Index.== infix(_:_:)(*a1, a1[1], *a2, a2[1]);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance __CocoaDictionary.Index( uint64_t *a1, uint64_t *a2)
{
  return specialized static __CocoaDictionary.Index.< infix(_:_:)(*a1, a1[1], *a2, a2[1]);
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))specialized static __CocoaDictionary.Index.< infix(_:_:));
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))specialized static __CocoaDictionary.Index.< infix(_:_:));
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance __CocoaDictionary.Index( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.> infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))specialized static __CocoaDictionary.Index.< infix(_:_:));
}

double protocol witness for Sequence.makeIterator() in conformance __CocoaDictionary@<D0>(void *a1@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance __CocoaDictionary( type metadata accessor for __CocoaDictionary.Iterator,  a1);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance __CocoaDictionary()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized _copySequenceToContiguousArray<A>(_:)(*v0);
  swift_unknownObjectRelease(v1);
  return v2;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance __CocoaDictionary( void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

id protocol witness for IteratorProtocol.next() in conformance __CocoaDictionary.Iterator@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, void *a5@<X8>)
{
  id result = __CocoaDictionary.Iterator.next()(a1, a2, a3, a4);
  *a5 = result;
  a5[1] = v7;
  return result;
}

int64_t Dictionary._bridgeToObjectiveCImpl()( int64_t result, uint64_t *a2, void *a3, uint64_t a4)
{
  if ((result & 0xC000000000000001LL) == 0) {
    return (int64_t)_NativeDictionary.bridged()((__objc2_class **)result, a2, a3, a4);
  }
  if (result >= 0) {
    return result & 0xFFFFFFFFFFFFFF8LL;
  }
  return result;
}

__objc2_class **static Dictionary._bridgeFromObjectiveCAdoptingNativeStorageOf(_:)( __objc2_class **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for _SwiftDeferredNSDictionary(0LL, a2, a3, a4);
  id v12 = swift_unknownObjectRetain(a1, v9, v10, v11);
  uint64_t v13 = swift_dynamicCastClass((uint64_t)v12, v8);
  if (v13)
  {
    uint64_t v14 = v13;
    swift_unknownObjectRelease(a1);
    uint64_t v15 = *(unint64_t **)(v14 + 32);
    swift_retain(v15, v16, v17, v18);
    swift_unknownObjectRelease(a1);
  }

  else
  {
    uint64_t v19 = type metadata accessor for _DictionaryStorage(0LL, a2, a3, a4);
    uint64_t v15 = (unint64_t *)swift_dynamicCastClass((uint64_t)a1, v19);
    swift_unknownObjectRelease(a1);
    if (!v15)
    {
      swift_unknownObjectRelease(a1);
      if (a1 == &_swiftEmptyDictionarySingleton) {
        return &_swiftEmptyDictionarySingleton;
      }
      else {
        return 0LL;
      }
    }
  }

  return (__objc2_class **)v15;
}

uint64_t (*_DictionaryBuilder._target.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _DictionaryBuilder._requestedCount.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

__objc2_class **_DictionaryBuilder.init(count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptyDictionarySingleton;
  }
  type metadata accessor for _DictionaryStorage(0LL, a2, a3, a4);
  return (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a1);
}

uint64_t _DictionaryBuilder.add(key:value:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v12 = *(void *)(v11 + 16);
  MEMORY[0x1895F8858](v8);
  uint64_t v15 = (char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = (void *)*v3;
  if (*(void *)(*v3 + 16LL) >= v3[1]) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't add more members than promised",  36LL,  2,  "Swift/DictionaryBuilder.swift",  29LL,  2,  0x21uLL,  0);
  }
  (*(void (**)(char *))(v13 + 16))(v15);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, a2, v6);
  return _NativeDictionary._unsafeInsertNew(key:value:)((uint64_t)v15, (uint64_t)v10, v16, v12, v6, *(void *)(a3 + 32));
}

__n128 specialized _NativeDictionary._unsafeInsertNew(key:value:)(__int128 *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[5];
  uint64_t v7 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 4);
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v19, v7, v8);
  uint64_t v9 = v20;
  uint64_t v10 = v21;
  __swift_project_boxed_opaque_existential_0Tm(v19, v20);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v6, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v19);
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v11);
  if ((v13 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  a3[(v12 >> 6) + 8] |= 1LL << v12;
  uint64_t v14 = a3[6] + 40 * v12;
  __int128 v15 = *a1;
  __int128 v16 = a1[1];
  *(void *)(v14 + 32) = *((void *)a1 + 4);
  *(_OWORD *)uint64_t v14 = v15;
  *(_OWORD *)(v14 + 16) = v16;
  uint64_t v17 = a3[7] + 40 * v12;
  __n128 result = *(__n128 *)(a2 + 16);
  *(_OWORD *)uint64_t v17 = *(_OWORD *)a2;
  *(__n128 *)(v17 + 16) = result;
  *(void *)(v17 + 32) = *(void *)(a2 + 32);
  ++a3[2];
  return result;
}

_OWORD *specialized _NativeDictionary._unsafeInsertNew(key:value:)( unint64_t a1, unint64_t a2, _OWORD *a3, void *a4)
{
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ a4[5];
  v14[0] = 0LL;
  v14[1] = v8 ^ 0x736F6D6570736575LL;
  v14[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  _OWORD v14[3] = v8 ^ 0x6C7967656E657261LL;
  void v14[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  String.hash(into:)(v14, a1, a2);
  Swift::Int v9 = Hasher._finalize()();
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v9);
  if ((v11 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a4[(v10 >> 6) + 8] |= 1LL << v10;
  unint64_t v12 = (unint64_t *)(a4[6] + 16 * v10);
  *unint64_t v12 = a1;
  v12[1] = a2;
  __n128 result = outlined init with take of Any(a3, (_OWORD *)(a4[7] + 32 * v10));
  ++a4[2];
  return result;
}

_OWORD *specialized _NativeDictionary._unsafeInsertNew(key:value:)(__int128 *a1, _OWORD *a2, void *a3)
{
  uint64_t v6 = a3[5];
  uint64_t v7 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 4);
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v18, v7, v8);
  uint64_t v9 = v19;
  uint64_t v10 = v20;
  __swift_project_boxed_opaque_existential_0Tm(v18, v19);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v6, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v18);
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v11);
  if ((v13 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  a3[(v12 >> 6) + 8] |= 1LL << v12;
  uint64_t v14 = a3[6] + 40 * v12;
  __int128 v15 = *a1;
  __int128 v16 = a1[1];
  *(void *)(v14 + 32) = *((void *)a1 + 4);
  *(_OWORD *)uint64_t v14 = v15;
  *(_OWORD *)(v14 + 16) = v16;
  __n128 result = outlined init with take of Any(a2, (_OWORD *)(a3[7] + 32 * v12));
  ++a3[2];
  return result;
}

__n128 specialized _NativeDictionary._unsafeInsertNew(key:value:)( uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = a4[5];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a1, v9);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v10 + 8))(v20, v9, v10);
  uint64_t v11 = v21;
  uint64_t v12 = v22;
  __swift_project_boxed_opaque_existential_0Tm(v20, v21);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 40))(v8, v11, v12);
  __swift_destroy_boxed_opaque_existential_1Tm(v20);
  unint64_t v14 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)((void *)a1, v13);
  if ((v15 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }
  a4[(v14 >> 6) + 8] |= 1LL << v14;
  uint64_t v16 = a4[6] + 40 * v14;
  __n128 result = *(__n128 *)a1;
  __int128 v18 = *(_OWORD *)(a1 + 16);
  *(void *)(v16 + 32) = *(void *)(a1 + 32);
  *(__n128 *)uint64_t v16 = result;
  *(_OWORD *)(v16 + 16) = v18;
  uint64_t v19 = (void *)(a4[7] + 16 * v14);
  *uint64_t v19 = a2;
  v19[1] = a3;
  ++a4[2];
  return result;
}

__n128 specialized _NativeDictionary._unsafeInsertNew(key:value:)( unint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ a4[5];
  v16[0] = 0LL;
  v16[1] = v8 ^ 0x736F6D6570736575LL;
  v16[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v16[3] = v8 ^ 0x6C7967656E657261LL;
  v16[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  String.hash(into:)(v16, a1, a2);
  Swift::Int v9 = Hasher._finalize()();
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v9);
  if ((v11 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a4[(v10 >> 6) + 8] |= 1LL << v10;
  uint64_t v12 = (unint64_t *)(a4[6] + 16 * v10);
  *uint64_t v12 = a1;
  v12[1] = a2;
  uint64_t v13 = a4[7] + 40 * v10;
  __n128 result = *(__n128 *)a3;
  __int128 v15 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)uint64_t v13 = *(_OWORD *)a3;
  *(_OWORD *)(v13 + 16) = v15;
  *(void *)(v13 + 32) = *(void *)(a3 + 32);
  ++a4[2];
  return result;
}

unint64_t specialized _NativeDictionary._unsafeInsertNew(key:value:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v10 = _swift_stdlib_Hashing_parameters ^ a5[5];
  v16[0] = 0LL;
  v16[1] = v10 ^ 0x736F6D6570736575LL;
  v16[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v16[3] = v10 ^ 0x6C7967656E657261LL;
  v16[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  String.hash(into:)(v16, a1, a2);
  Swift::Int v11 = Hasher._finalize()();
  unint64_t result = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v11);
  if ((v13 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a5[(result >> 6) + 8] |= 1LL << result;
  unint64_t v14 = (unint64_t *)(a5[6] + 16 * result);
  *unint64_t v14 = a1;
  v14[1] = a2;
  __int128 v15 = (void *)(a5[7] + 16 * result);
  *__int128 v15 = a3;
  v15[1] = a4;
  ++a5[2];
  return result;
}

unint64_t specialized _NativeDictionary._unsafeInsertNew(key:value:)( unint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ a4[5];
  v13[0] = 0LL;
  v13[1] = v8 ^ 0x736F6D6570736575LL;
  unint64_t v13[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v13[3] = v8 ^ 0x6C7967656E657261LL;
  v13[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  String.hash(into:)(v13, a1, a2);
  Swift::Int v9 = Hasher._finalize()();
  unint64_t result = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v9);
  if ((v11 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }
  a4[(result >> 6) + 8] |= 1LL << result;
  uint64_t v12 = (unint64_t *)(a4[6] + 16 * result);
  *uint64_t v12 = a1;
  v12[1] = a2;
  *(void *)(a4[7] + 8 * result) = a3;
  ++a4[2];
  return result;
}

uint64_t _NativeDictionary._unsafeInsertNew(key:value:)( uint64_t a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(a6 + 32))(a3[5], a4, a6);
  unint64_t v12 = __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v11, a4);
  if ((v13 & 1) != 0) {
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(a4);
  }
  unint64_t v14 = v12;
  a3[(v12 >> 6) + 8] |= 1LL << v12;
  (*(void (**)(unint64_t, uint64_t, unint64_t))(*(void *)(a4 - 8) + 32LL))( a3[6] + *(void *)(*(void *)(a4 - 8) + 72LL) * v12,  a1,  a4);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 32LL))( a3[7] + *(void *)(*(void *)(a5 - 8) + 72LL) * v14,  a2,  a5);
  ++a3[2];
  return result;
}

uint64_t _DictionaryBuilder.take()(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 16) != a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "The number of members added does not match the promised count",  61LL,  2,  "Swift/DictionaryBuilder.swift",  29LL,  2,  0x28uLL,  0);
  }
  return result;
}

uint64_t _NativeDictionary._keys.getter(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

Swift::Bool __swiftcall _HashTable._isOccupied(_:)(Swift::_HashTable::Bucket a1)
{
  return (*(void *)(v1 + (((unint64_t)a1.offset >> 3) & 0xFFFFFFFFFFFFF8LL)) >> SLOBYTE(a1.offset)) & 1LL;
}

Swift::Void __swiftcall _NativeDictionary.uncheckedDestroy(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v4 = v3;
  uint64_t v5 = v1;
  swift_arrayDestroy(*(void *)(v1 + 48) + *(void *)(*(void *)(v2 - 8) + 72LL) * at.offset, 1LL, v2);
  swift_arrayDestroy(*(void *)(v5 + 56) + *(void *)(*(void *)(v4 - 8) + 72LL) * at.offset, 1LL, v4);
}

Swift::Void __swiftcall _HashTable.insert(_:)(Swift::_HashTable::Bucket a1)
{
  *(void *)(v1 + (((unint64_t)a1.offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << SLOBYTE(a1.offset);
}

uint64_t _NativeDictionary.hashValue(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(a5 + 32))(*(void *)(a2 + 40), a3, a5);
}

Swift::_HashTable::Bucket __swiftcall _HashTable.insertNew(hashValue:)(Swift::Int hashValue)
{
  uint64_t v3 = v1;
  result.uint64_t offset = _HashTable.nextHole(atOrAfter:)((Swift::_HashTable::Bucket)(v2 & hashValue)).offset;
  *(void *)(v3 + (((unint64_t)result.offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << SLOBYTE(result.offset);
  return result;
}

Swift::Void __swiftcall _NativeDictionary.moveEntry(from:to:)( Swift::_HashTable::Bucket from, Swift::_HashTable::Bucket to)
{
  uint64_t v5 = v4;
  uint64_t v6 = v2;
  UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(*(void *)(v2 + 48) + *(void *)(*(void *)(v3 - 8) + 72LL) * from.offset),  1LL,  (char *)(*(void *)(v2 + 48) + *(void *)(*(void *)(v3 - 8) + 72LL) * to.offset),  v3);
  UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(*(void *)(v6 + 56) + *(void *)(*(void *)(v5 - 8) + 72LL) * from.offset),  1LL,  (char *)(*(void *)(v6 + 56) + *(void *)(*(void *)(v5 - 8) + 72LL) * to.offset),  v5);
}

Swift::Void __swiftcall _NativeDictionary.swapEntry(_:with:)( Swift::_HashTable::Bucket _, Swift::_HashTable::Bucket with)
{
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v7 = v2;
  Swift::Int offset = _.offset;
  uint64_t v9 = *(void *)(v4 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](_.offset);
  unint64_t v12 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  __int128 v15 = (char *)&v30 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *(void *)(v16 + 48);
  uint64_t v19 = *(void *)(v18 + 72);
  uint64_t v20 = (char *)(v17 + v19 * v13);
  uint64_t v22 = (char *)(v17 + v19 * v21);
  uint64_t v23 = *(void (**)(char *, char *, uint64_t))(v18 + 32);
  v23(v15, v20, v24);
  v23(v20, v22, v6);
  v23(v22, v15, v6);
  uint64_t v25 = *(void *)(v7 + 56);
  uint64_t v26 = *(void *)(v9 + 72);
  uint64_t v27 = (char *)(v25 + v26 * offset);
  uint64_t v28 = (char *)(v25 + v26 * with.offset);
  uint64_t v29 = *(void (**)(char *, Swift::Int, uint64_t))(v9 + 32);
  v29(v12, (Swift::Int)v27, v5);
  v29(v27, (Swift::Int)v28, v5);
  v29(v28, (Swift::Int)v12, v5);
}

void _swift_dictionaryDownCastIndirect( unint64_t *a1, uint64_t *a2, uint64_t *a3, char *a4, ValueMetadata *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = *a1;
  unint64_t v16 = swift_bridgeObjectRetain(*a1, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v17 = _dictionaryDownCast<A, B, C, D>(_:)(v16, a3, a4, a5, a6, a7, a8);
  swift_bridgeObjectRelease(v15);
  *a2 = v17;
}

uint64_t _dictionaryDownCast<A, B, C, D>(_:)( int64_t a1, uint64_t *a2, void *a3, ValueMetadata *a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v258 = a7;
  uint64_t v266 = a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a4, (uint64_t)a5, "key value ", 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v255 = (char *)&v227 - v12;
  v254 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a4, (uint64_t)a5, 0LL, 0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v254);
  v253 = (char *)&v227 - v14;
  v259 = a5;
  uint64_t v15 = *(a5 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v247 = (char *)&v227 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  __int128 v246 = (char *)&v227 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  __int128 v241 = (ValueMetadata *)((char *)&v227 - v21);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v240 = (char *)&v227 - v23;
  Description = a4[-1].Description;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v245 = (char *)&v227 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  v244 = (char *)&v227 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v31 = (uint64_t *)((char *)&v227 - v30);
  MEMORY[0x1895F8858](v29);
  __int128 v239 = (char *)&v227 - v32;
  uint64_t v33 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a2, (uint64_t)a3, "key value ", 0LL);
  uint64_t v34 = *(v33 - 1);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  v243 = (char *)&v227 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v35);
  v238 = (char *)&v227 - v37;
  uint64_t v230 = type metadata accessor for Optional(0LL, (uint64_t)a3, v38, v39);
  uint64_t v229 = *(void *)(v230 - 8);
  uint64_t v40 = MEMORY[0x1895F8858](v230);
  uint64_t v236 = (char *)&v227 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v250 = (uint64_t *)((char *)&v227 - v43);
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  uint64_t v233 = (char *)&v227 - v45;
  MEMORY[0x1895F8858](v44);
  uint64_t v235 = (uint64_t *)((char *)&v227 - v46);
  uint64_t v228 = type metadata accessor for Optional(0LL, (uint64_t)a2, v47, v48);
  uint64_t v227 = *(void *)(v228 - 8);
  uint64_t v49 = MEMORY[0x1895F8858](v228);
  uint64_t v237 = (char *)&v227 - ((v50 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  v249 = (uint64_t *)((char *)&v227 - v52);
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  uint64_t v232 = (char *)&v227 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  unint64_t v234 = (char *)&v227 - v56;
  uint64_t v268 = *(a3 - 1);
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  v262 = (char *)&v227 - ((v58 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v261 = *(a2 - 1);
  MEMORY[0x1895F8858](v57);
  v252 = (char *)&v227 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v60 = v33;
  uint64_t v63 = type metadata accessor for Optional(0LL, (uint64_t)v33, v61, v62);
  uint64_t v64 = MEMORY[0x1895F8858](v63);
  unint64_t v248 = (char *)&v227 - ((v65 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v64);
  v242 = (char *)&v227 - v66;
  v267 = a2;
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2)
    && _swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    && _swift_isClassOrObjCExistentialType((uint64_t)a4, &a4->Kind)
    && _swift_isClassOrObjCExistentialType((uint64_t)v259, v259))
  {
    if ((a1 & 0xC000000000000001LL) != 0)
    {
      unint64_t v70 = a1 & 0xFFFFFFFFFFFFFF8LL;
      if (a1 < 0) {
        unint64_t v70 = a1;
      }
      unint64_t v71 = (unint64_t *)(~(v70 >> 1) & 0x4000000000000000LL | v70);
      swift_bridgeObjectRetain(a1, v67, v68, v69);
    }

    else
    {
      uint64_t v224 = (__objc2_class **)swift_bridgeObjectRetain(a1, v67, v68, v69);
      uint64_t v225 = _NativeDictionary.bridged()(v224, v267, a3, v266);
      return ~((unint64_t)v225 >> 1) & 0x4000000000000000LL | (unint64_t)v225;
    }

    return (uint64_t)v71;
  }

  uint64_t v266 = v34;
  unint64_t v72 = a1 & 0xC000000000000001LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v73 = (void *)a1;
    }
    else {
      uint64_t v73 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v74 = objc_msgSend(v73, sel_count);
    if (v74) {
      goto LABEL_14;
    }
LABEL_16:
    v260 = &_swiftEmptyDictionarySingleton;
    goto LABEL_17;
  }

  id v74 = *(id *)(a1 + 16);
  if (!v74) {
    goto LABEL_16;
  }
LABEL_14:
  type metadata accessor for _DictionaryStorage(0LL, (uint64_t)a4, (uint64_t)v259, v258);
  v260 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)((uint64_t)v74);
LABEL_17:
  unint64_t v75 = a1;
  uint64_t v263 = a3;
  v264 = Description;
  uint64_t v265 = v15;
  v257 = v60;
  if (a4 == &type metadata for String)
  {
    uint64_t v81 = v268;
    unint64_t v71 = (unint64_t *)v260;
    if (v72)
    {
      if (a1 < 0) {
        uint64_t v82 = a1;
      }
      else {
        uint64_t v82 = a1 & 0xFFFFFFFFFFFFFF8LL;
      }
      uint64_t v83 = type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v84 = (unint64_t)swift_allocObject(v83, 0xE8uLL, 7uLL);
      v244 = 0LL;
      uint64_t v85 = 0LL;
      unint64_t v86 = 0LL;
      *(void *)(v84 + 208) = v82;
      *(void *)(v84 + 216) = 0LL;
      unint64_t v75 = a1;
      *(_OWORD *)(v84 + 16) = 0u;
      *(_OWORD *)(v84 + 32) = 0u;
      *(_OWORD *)(v84 + 48) = 0u;
      *(_OWORD *)(v84 + 64) = 0u;
      *(_OWORD *)(v84 + 80) = 0u;
      *(_OWORD *)(v84 + 96) = 0u;
      *(_OWORD *)(v84 + 112) = 0u;
      *(_OWORD *)(v84 + 128) = 0u;
      *(_OWORD *)(v84 + 144) = 0u;
      *(_OWORD *)(v84 + 160) = 0u;
      *(_OWORD *)(v84 + 176) = 0u;
      *(_OWORD *)(v84 + 192) = 0u;
      *(void *)(v84 + 224) = 0LL;
      unint64_t v87 = v84 | 0x8000000000000000LL;
    }

    else
    {
      uint64_t v152 = -1LL << *(_BYTE *)(a1 + 32);
      uint64_t v85 = ~v152;
      uint64_t v153 = *(void *)(a1 + 64);
      v244 = (char *)(a1 + 64);
      uint64_t v154 = -v152;
      if (v154 < 64) {
        uint64_t v155 = ~(-1LL << v154);
      }
      else {
        uint64_t v155 = -1LL;
      }
      unint64_t v86 = v155 & v153;
      unint64_t v87 = a1;
    }

    unint64_t v156 = v262;
    uint64_t v237 = (char *)((v87 & 0x7FFFFFFFFFFFFFFFLL) + 16);
    __int128 v246 = (char *)(v87 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v236 = (char *)((v87 & 0x7FFFFFFFFFFFFFFFLL) + 80);
    uint64_t v231 = v85;
    v243 = (char *)((unint64_t)(v85 + 64) >> 6);
    uint64_t v247 = (char *)(v71 + 8);
    swift_bridgeObjectRetain(v75, v67, v68, v69);
    unint64_t v248 = 0LL;
    uint64_t v245 = (char *)&unk_189B8D230;
    uint64_t v160 = v266;
    v249 = (uint64_t *)v87;
    v250 = v31;
    while (1)
    {
      if ((v87 & 0x8000000000000000LL) != 0)
      {
        unint64_t v251 = v86;
        unint64_t v162 = v246;
        uint64_t v163 = *((void *)v246 + 27);
        unint64_t v164 = v242;
        if (v163 < 0) {
          goto LABEL_118;
        }
        unint64_t v165 = (void *)*((void *)v246 + 26);
        if (v163 == *((void *)v246 + 28))
        {
          id v166 = objc_msgSend(*((id *)v246 + 26), sel_countByEnumeratingWithState_objects_count_, v237, v236, 16);
          v162[28] = v166;
          if (!v166)
          {
            v162[27] = -1LL;
LABEL_118:
            (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v160 + 56))(v164, 1LL, 1LL, v60);
            uint64_t v222 = v87;
            goto LABEL_119;
          }

          uint64_t v163 = 0LL;
          v162[27] = 0LL;
        }

        uint64_t v167 = v162[3];
        if (!v167) {
          goto LABEL_131;
        }
        uint64_t v168 = v235;
        unint64_t v169 = (uint64_t *)v234;
        unint64_t v170 = (void **)(v167 + 8 * v163);
        if ((v170 & 7) != 0) {
LABEL_122:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
        unint64_t v171 = *v170;
        v162[27] = v163 + 1;
        swift_unknownObjectRetain(v171, v157, v158, v159);
        uint64_t v172 = (swift *)objc_msgSend(v165, sel_objectForKey_, v171);
        if (!v172)
        {
LABEL_132:
          unint64_t v226 = 784LL;
          goto LABEL_133;
        }

        uint64_t v173 = v172;
        uint64_t v174 = v267;
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v267, v267);
        uint64_t v176 = v261;
        unint64_t v177 = v232;
        if (isClassOrObjCExistentialType)
        {
          uint64_t v269 = (swift *)v171;
          swift_dynamicCast(v164, &v269, v245, v174, 7LL);
        }

        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v261 + 56))(v169, 1LL, 1LL, v174);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v171, (uint64_t)v174, v169);
          swift_unknownObjectRelease(v171);
          uint64_t v217 = v227;
          uint64_t v218 = v228;
          (*(void (**)(char *, uint64_t *, uint64_t))(v227 + 16))(v177, v169, v228);
          (*(void (**)(uint64_t *, uint64_t))(v217 + 8))(v169, v218);
          (*(void (**)(char *, char *, uint64_t *))(v176 + 32))(v164, v177, v174);
        }

        unint64_t v178 = &v164[*((int *)v60 + 12)];
        uint64_t v179 = v263;
        BOOL v180 = _swift_isClassOrObjCExistentialType((uint64_t)v263, v263);
        int64_t v181 = v233;
        if (v180)
        {
          uint64_t v269 = v173;
          swift_dynamicCast(v178, &v269, &unk_189B8D230, v179, 7LL);
        }

        else
        {
          uint64_t v219 = v268;
          (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v268 + 56))(v168, 1LL, 1LL, v179);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v173, (uint64_t)v179, v168);
          swift_unknownObjectRelease(v173);
          uint64_t v220 = v229;
          uint64_t v221 = v230;
          (*(void (**)(char *, uint64_t *, uint64_t))(v229 + 16))(v181, v168, v230);
          if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v219 + 48))(v181, 1LL, v179) == 1) {
LABEL_134:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
          (*(void (**)(uint64_t *, uint64_t))(v220 + 8))(v168, v221);
          (*(void (**)(char *, char *, uint64_t *))(v219 + 32))(v178, v181, v179);
        }

        uint64_t v160 = v266;
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v266 + 56))(v164, 0LL, 1LL, v60);
        char v182 = v262;
        int64_t v183 = v263;
        char v184 = v267;
        uint64_t v185 = v261;
        BOOL v186 = v252;
      }

      else
      {
        if (v86)
        {
          unint64_t v251 = (v86 - 1) & v86;
          unint64_t v161 = __clz(__rbit64(v86)) | ((void)v248 << 6);
        }

        else
        {
          uint64_t v187 = v248 + 1;
          if (__OFADD__(v248, 1LL)) {
            goto LABEL_129;
          }
          unint64_t v188 = *(void *)&v244[8 * (void)v187];
          BOOL v189 = v248 + 1;
          if (!v188)
          {
            BOOL v189 = v248 + 2;
            unint64_t v188 = *(void *)&v244[8 * (void)v189];
            if (!v188)
            {
              Swift::String::Index v190 = v248 + 3;
              unint64_t v188 = *(void *)&v244[8 * (void)v190];
              if (!v188)
              {
                while (1)
                {
                  BOOL v189 = v190 + 1;
                  if (__OFADD__(v190, 1LL)) {
                    goto LABEL_130;
                  }
                  unint64_t v188 = *(void *)&v244[8 * (void)v189];
                  ++v190;
                  if (v188) {
                    goto LABEL_103;
                  }
                }

LABEL_113:
                (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v160 + 56))(v242, 1LL, 1LL, v60);
                uint64_t v222 = v87;
                goto LABEL_119;
              }

              BOOL v189 = v248 + 3;
            }
          }

            ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
          }
        }

        uint64_t v13 = (v13 + 1) & v93;
        uint64_t v29 = v13 >> 6;
        uint64_t v30 = 1LL << v13;
        uint64_t v35 = v94;
      }

      while ((v92[v13 >> 6] & (1LL << v13)) != 0);
    }

    if ((v115 & 1) != 0) {
      goto LABEL_113;
    }
    goto LABEL_102;
  }

  if (v27 < v26)
  {
    unint64_t v70 = specialized static _HashTable.scale(forCapacity:)(v26);
    LOBYTE(v123) = 1;
    uint64_t v35 = specialized static _SetStorage.allocate(scale:age:seed:)(v70, 0x100000000LL, 0LL, 1);
    if (!*(void *)(v23 + 16)) {
      goto LABEL_92;
    }
    id v74 = 1LL << *(_BYTE *)(v23 + 32);
    unint64_t v75 = v23 + 56;
    uint64_t v76 = -1LL;
    if (v74 < 64) {
      uint64_t v76 = ~(-1LL << v74);
    }
    uint64_t v77 = v76 & *(void *)(v23 + 56);
    unint64_t v78 = (unint64_t)(v74 + 63) >> 6;
    swift_retain((unint64_t *)v23, v71, v72, v73);
    uint64_t v79 = 0LL;
    while (1)
    {
      if (v77)
      {
        unint64_t v80 = __clz(__rbit64(v77));
        v77 &= v77 - 1;
        uint64_t v81 = v80 | (v79 << 6);
      }

      else
      {
        uint64_t v82 = v79 + 1;
        if (__OFADD__(v79, 1LL)) {
          goto LABEL_107;
        }
        if (v82 >= v78) {
          goto LABEL_91;
        }
        uint64_t v83 = *(void *)(v75 + 8 * v82);
        ++v79;
        if (!v83)
        {
          uint64_t v79 = v82 + 1;
          if (v82 + 1 >= v78) {
            goto LABEL_91;
          }
          uint64_t v83 = *(void *)(v75 + 8 * v79);
          if (!v83)
          {
            uint64_t v79 = v82 + 2;
            if (v82 + 2 >= v78) {
              goto LABEL_91;
            }
            uint64_t v83 = *(void *)(v75 + 8 * v79);
            if (!v83)
            {
              unint64_t v84 = v82 + 3;
              if (v84 >= v78) {
                goto LABEL_91;
              }
              uint64_t v83 = *(void *)(v75 + 8 * v84);
              if (!v83)
              {
                while (1)
                {
                  uint64_t v79 = v84 + 1;
                  if (__OFADD__(v84, 1LL)) {
                    goto LABEL_112;
                  }
                  if (v79 >= v78) {
                    break;
                  }
                  uint64_t v83 = *(void *)(v75 + 8 * v79);
                  ++v84;
                  if (v83) {
                    goto LABEL_86;
                  }
                }

    if ((v8 & ~v11 & 0x2000000000000000LL) == 0
      || !swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      break;
    }

    unint64_t v201 = v7 & 0xFFFFFFFFFFFFLL;
    uint64_t v91 = v203;
    uint64_t v8 = v204;
    unint64_t v92 = _StringGuts.nativeUnusedCapacity.getter(v203, v204);
    if ((v93 & 1) != 0) {
      goto LABEL_255;
    }
    if (v14 <= 15)
    {
      if ((v8 & 0x2000000000000000LL) != 0)
      {
        uint64_t v105 = 0;
        uint64_t v11 = v8;
        goto LABEL_165;
      }

      uint64_t v11 = v8;
    }

            unint64_t v113 = 266LL;
LABEL_115:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v113,  0);
          }
        }

        else if (v61 <= 15)
        {
          goto LABEL_92;
        }

        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v61, 1LL);
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
        unint64_t v114 = xmmword_1817FFC80;
        unint64_t v84 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v114, 1LL);
        _StringGuts.appendInPlace(_:isASCII:)(v84, v85, 1);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        return v115;
      }
    }

    else
    {
      uint64_t v27 = __OFADD__(v59, 1LL);
      uint64_t v61 = v59 + 1;
      if (!v27) {
        goto LABEL_81;
      }
    }

    __break(1u);
LABEL_107:
    unint64_t v111 = String.UTF8View._foreignCount()();
    uint64_t v4 = v111 + 1;
    if (__OFADD__(v111, 1LL))
    {
      while (1)
      {
        __break(1u);
LABEL_110:
        uint64_t v112 = String.UTF8View._foreignCount()();
        uint64_t v27 = __OFADD__(v112, 1LL);
        uint64_t v55 = v112 + 1;
        if (v27) {
          goto LABEL_112;
        }
LABEL_65:
        if (v55 <= 15)
        {
          unint64_t v87 = v116;
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
          uint64_t v88 = v115;
          swift_bridgeObjectRetain(v87, v89, v90, v91);
          unint64_t v92 = _StringGuts._convertedToSmall()(v88, v87);
          uint64_t v94 = v93;
          swift_bridgeObjectRelease(v87);
          v95._rawBits = 1LL;
          v96._rawBits = 65537LL;
          v97._rawBits = _StringGuts.validateScalarRange(_:)(v95, v96, 0x49uLL, 0xE100000000000000LL);
          if (v97._rawBits < 0x10000) {
            v97._rawBits |= 3;
          }
          uint64_t v99 = specialized String.init(_:)(v97, v98, 0x49uLL, 0xE100000000000000LL);
          unint64_t v101 = v100;
          swift_bridgeObjectRelease(0xE100000000000000LL);
          int64_t v102 = _StringGuts._convertedToSmall()(v99, v101);
          uint64_t v104 = v103;
          swift_bridgeObjectRelease(v101);
          uint64_t v105 = specialized _SmallString.init(_:appending:)(v92, v94, v102, v104);
          if ((v107 & 1) != 0) {
            goto LABEL_113;
          }
          uint64_t v108 = v105;
          int64_t v109 = v106;
          swift_bridgeObjectRelease(0xE100000000000000LL);
          uint64_t v9 = v116;
          uint64_t v115 = v108;
          uint64_t v116 = v109;
        }

        else
        {
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v55, 1LL);
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          unint64_t v114 = xmmword_1817FFF80;
          uint64_t v56 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v114, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v56, v57, 1);
          uint64_t v9 = 0xE100000000000000LL;
        }

    v81[0] = v57;
    uint64_t v82 = 0LL;
LABEL_142:
    unint64_t v78 = (os_unfair_lock_s *)&SingletonMetadata;
    goto LABEL_143;
  }

  if (v25 == 2)
  {
    checkMetadataDependency(swift::MetadataDependency)::CheckDependencyResult::forForeignMetadata( v88,  (uint64_t)v23,  (uint64_t)v81);
    goto LABEL_144;
  }

  if (v25) {
LABEL_159:
  }
    abort();
LABEL_2:
  LOBYTE(v13) = 4;
LABEL_3:
  v81[0] = v13;
LABEL_4:
  uint64_t v14 = (char *)__p;
  if (v86 - (_BYTE *)__p != 32) {
    goto LABEL_152;
  }
  uint64_t v15 = *((void *)v86 - 1);
  if (v15 <= 62)
  {
    if (v15)
    {
      if (v15 != 1) {
        goto LABEL_159;
      }
    }

    else if (v81[0] > 3u)
    {
      goto LABEL_153;
    }

LABEL_128:
            __break(1u);
LABEL_129:
            __break(1u);
LABEL_130:
            __break(1u);
LABEL_131:
            unint64_t v226 = 773LL;
LABEL_133:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v226,  0);
          }

          uint64_t v130 = v240 + 3;
        }
      }

    unint64_t v156 = 266LL;
    goto LABEL_130;
  }

  _StringGuts.nativeUnusedCapacity.getter(v32, v33);
  if ((v36 & 1) != 0) {
    goto LABEL_129;
  }
  if (v35 <= 15) {
    goto LABEL_27;
  }
LABEL_19:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v35, v29);
  swift_bridgeObjectRelease(v28);
  if ((v28 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(v27, v28, v157, v160);
    swift_bridgeObjectRelease(v28);
    uint64_t v32 = __src;
    uint64_t v27 = v164;
    goto LABEL_46;
  }

  uint64_t v26 = v27;
  if ((v28 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v28);
    uint64_t v76 = HIBYTE(v28) & 0xF;
    unint64_t v161 = v27;
    unint64_t v162 = v28 & 0xFFFFFFFFFFFFFFLL;
    if (v76 < v160) {
      goto LABEL_121;
    }
    uint64_t v77 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v157, v160, (uint64_t)&v161, v76);
    uint64_t v79 = v78;
    uint64_t v27 = v164;
    unint64_t v80 = v164 & 0xFFFFFFFFFFFFFFFLL;
    specialized UnsafeMutablePointer.initialize(from:count:)( v77,  v78,  (char *)((v164 & 0xFFFFFFFFFFFFFFFLL) + (*(void *)((v164 & 0xFFFFFFFFFFFFFFFLL) + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
    uint64_t v81 = *(void *)(v80 + 24);
    if (!__OFADD__(v81 & 0xFFFFFFFFFFFFLL, v79))
    {
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( (v81 & 0xFFFFFFFFFFFFLL) + v79,  ((unint64_t)v28 >> 62) & (v81 < 0));
      uint64_t v32 = *(void *)(v80 + 24);
      __src = v32;
      goto LABEL_46;
    }

    goto LABEL_119;
  }

  if ((v27 & 0x1000000000000000LL) == 0) {
    goto LABEL_117;
  }
  uint64_t v37 = (id)((v28 & 0xFFFFFFFFFFFFFFFLL) + 32);
  for (int64_t i = v27 & 0xFFFFFFFFFFFFLL; ; int64_t i = v154)
  {
    if (i < v160) {
      goto LABEL_121;
    }
    uint64_t v39 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v157, v160, (uint64_t)v37, i);
    uint64_t v41 = v40;
    uint64_t v27 = v164;
    uint64_t v42 = v164 & 0xFFFFFFFFFFFFFFFLL;
    specialized UnsafeMutablePointer.initialize(from:count:)( v39,  v40,  (char *)((v164 & 0xFFFFFFFFFFFFFFFLL) + (*(void *)((v164 & 0xFFFFFFFFFFFFFFFLL) + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
    uint64_t v43 = *(void *)(v42 + 24);
    if (__OFADD__(v43 & 0xFFFFFFFFFFFFLL, v41))
    {
      __break(1u);
LABEL_119:
      __break(1u);
      goto LABEL_120;
    }

    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( (v43 & 0xFFFFFFFFFFFFLL) + v41,  (v43 & v26 & 0x8000000000000000LL) != 0LL);
    uint64_t v32 = *(void *)(v42 + 24);
    __src = v32;
    swift_bridgeObjectRelease(v28);
LABEL_46:
    if ((v27 & 0x2000000000000000LL) != 0) {
      uint64_t v82 = HIBYTE(v27) & 0xF;
    }
    else {
      uint64_t v82 = v32 & 0xFFFFFFFFFFFFLL;
    }
    if (&full type metadata for EmptyCollection<Character> == &full type metadata for String)
    {
      __break(1u);
LABEL_126:
      __break(1u);
LABEL_127:
      __break(1u);
      goto LABEL_128;
    }

    if (&full type metadata for EmptyCollection<Character> == &full type metadata for Substring) {
      goto LABEL_126;
    }
    uint64_t v160 = v82;
    if (&full type metadata for EmptyCollection<Character> == &full type metadata for [Character]) {
      goto LABEL_127;
    }
    swift_bridgeObjectRetain_n(v27, 3LL, v44, v45);
    v83._rawBits = v159;
    uint64_t v33 = specialized Collection.subscript.getter(v83, v7, v6);
    uint64_t v35 = v84;
    uint64_t v6 = v30;
    uint64_t v26 = v31;
    uint64_t v29 = v33 >> 16;
    uint64_t v7 = v84 >> 16;
    if ((v31 & 0x1000000000000000LL) != 0)
    {
LABEL_113:
      swift_bridgeObjectRetain_n(v26, 3LL, v30, (char *)v31);
      v150._rawBits = v33 & 0xFFFFFFFFFFFF0000LL | 1;
      v151._rawBits = v35 & 0xFFFFFFFFFFFF0000LL | 1;
      v152._rawBits = _StringGuts.validateScalarRange(_:)(v150, v151, v6, v26);
      if (v152._rawBits < 0x10000) {
        v152._rawBits |= 3;
      }
      uint64_t v85 = specialized Collection.count.getter(v152, v153, v6, v26);
      swift_bridgeObjectRelease(v27);
      unint64_t v86 = v26;
    }

    else
    {
      uint64_t v85 = v7 - v29;
      swift_bridgeObjectRetain_n(v31, 2LL, v30, (char *)v31);
      unint64_t v86 = v27;
    }

    swift_bridgeObjectRelease(v27);
    swift_bridgeObjectRelease(v86);
    unint64_t v87 = v160;
    if ((v27 & 0x1000000000000000LL) != 0) {
      unint64_t v87 = String.UTF8View._foreignCount()();
    }
    swift_bridgeObjectRelease(v27);
    uint64_t v88 = __OFADD__(v87, v85);
    uint64_t v28 = v87 + v85;
    if (!v88) {
      break;
    }
    __break(1u);
LABEL_117:
    uint64_t v37 = _StringObject.sharedUTF8.getter(v26, v28);
  }

  if ((v32 & ~v27 & 0x2000000000000000LL) == 0
    || (v89 = swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL), v32 = __src, uint64_t v27 = v164, !v89))
  {
    if (v28 > 15) {
      goto LABEL_63;
    }
LABEL_69:
    swift_bridgeObjectRelease(v26);
    swift_bridgeObjectRetain(v27, v96, v97, v98);
    uint64_t v99 = _StringGuts._convertedToSmall()(v32, v27);
    unint64_t v101 = v100;
    swift_bridgeObjectRelease(v27);
    v102._rawBits = v33 & 0xFFFFFFFFFFFF0000LL | 1;
    v103._rawBits = v35 & 0xFFFFFFFFFFFF0000LL | 1;
    v104._rawBits = _StringGuts.validateScalarRange(_:)(v102, v103, v6, v26);
    if (v104._rawBits < 0x10000) {
      v104._rawBits |= 3;
    }
    uint64_t v106 = specialized String.init(_:)(v104, v105, v6, v26);
    uint64_t v108 = v107;
    swift_bridgeObjectRelease(v26);
    int64_t v109 = _StringGuts._convertedToSmall()(v106, v108);
    unint64_t v111 = v110;
    swift_bridgeObjectRelease(v108);
    uint64_t v112 = HIBYTE(v101) & 0xF;
    unint64_t v113 = HIBYTE(v111) & 0xF;
    unint64_t v114 = v113 + v112;
    if ((unint64_t)(v113 + v112) <= 0xF)
    {
      uint64_t v115 = v158;
      uint64_t v9 = v160;
      if (v113)
      {
        uint64_t v116 = 0;
        uint64_t v117 = 0LL;
        do
        {
          uint64_t v118 = v112 + v117;
          uint64_t v119 = v117 + 1;
          if (v117 >= 8) {
            Swift::String::Index v120 = v111;
          }
          else {
            Swift::String::Index v120 = v109;
          }
          uint64_t v121 = v120 >> (v116 & 0x38);
          uint64_t v122 = (8 * v112 + v116) & 0x38;
          uint64_t v123 = (-255LL << v122) - 1;
          uint64_t v124 = (unint64_t)v121 << v122;
          unint64_t v125 = v124 | v123 & v101;
          uint64_t v126 = v124 | v123 & v99;
          if (v118 < 8) {
            uint64_t v99 = v126;
          }
          else {
            unint64_t v101 = v125;
          }
          v116 += 8;
          uint64_t v117 = v119;
        }

        while (v113 != v119);
      }

      swift_bridgeObjectRelease(v27);
      uint64_t v127 = 0xA000000000000000LL;
      if (!(v99 & 0x8080808080808080LL | v101 & 0x80808080808080LL)) {
        uint64_t v127 = 0xE000000000000000LL;
      }
      __src = v99;
      unint64_t v164 = v127 & 0xFF00000000000000LL | (v114 << 56) | v101 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_89;
    }

    goto LABEL_128;
  }

  uint64_t v90 = _StringGuts.nativeUnusedCapacity.getter(__src, v164);
  if ((v91 & 1) != 0)
  {
LABEL_129:
    unint64_t v156 = 258LL;
LABEL_130:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v156,  0);
  }

  if (v28 < 16 && ((v27 & 0x2000000000000000LL) != 0 || v90 < v85)) {
    goto LABEL_69;
  }
LABEL_63:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v28, v85);
  swift_bridgeObjectRelease(v26);
  if ((v26 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(v6, v26, v29, v7);
    goto LABEL_85;
  }

  if ((v26 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v26);
    uint64_t v128 = HIBYTE(v26) & 0xF;
    unint64_t v161 = v6;
    unint64_t v162 = v26 & 0xFFFFFFFFFFFFFFLL;
    if (v128 < v7) {
      goto LABEL_121;
    }
    unint64_t v129 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v29, v7, (uint64_t)&v161, v128);
    _StringGuts.appendInPlace(_:isASCII:)(v129, v130, (v26 & 0x4000000000000000LL) != 0);
  }

  else
  {
    if ((v6 & 0x1000000000000000LL) != 0)
    {
      unint64_t v92 = (id)((v26 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v93 = v6 & 0xFFFFFFFFFFFFLL;
      if ((v6 & 0xFFFFFFFFFFFFLL) >= v7) {
        goto LABEL_67;
      }
LABEL_121:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

      swift_bridgeObjectRetain(v226, v222, v223, v224);
      swift_bridgeObjectRelease(v227);
      v566 = v225;
      v567 = v226;
      goto LABEL_131;
    }

    v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v484 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v484, v214, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v485 = v560._object;
    v486 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v214,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v486);
    swift_release((uint64_t)v485);
  }

BOOL _swift_dictionaryDownCastConditionalIndirect( unint64_t *a1, __objc2_class ***a2, uint64_t *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *a1;
  unint64_t v15 = swift_bridgeObjectRetain(*a1, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v17 = _dictionaryDownCastConditional<A, B, C, D>(_:)(v15, a3, (uint64_t)a4, a5, a6, v16, a8);
  swift_bridgeObjectRelease(v14);
  if (v17) {
    *a2 = v17;
  }
  return v17 != 0LL;
}

__objc2_class **_dictionaryDownCastConditional<A, B, C, D>(_:)( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v339 = a7;
  uint64_t v295 = type metadata accessor for Optional(0LL, a5, a3, a4);
  uint64_t v12 = *(void *)(v295 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v295);
  v325 = (char *)&v287 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  v309 = (char *)&v287 - v15;
  uint64_t v297 = type metadata accessor for Optional(0LL, a4, v16, v17);
  uint64_t v296 = *(void *)(v297 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v297);
  v327 = (char *)&v287 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  v312 = (char *)&v287 - v20;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a4, a5, "key value ", 0LL);
  uint64_t v21 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  v321 = (char *)&v287 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v21);
  v306 = (char *)&v287 - v23;
  v335 = swift_getTupleTypeMetadata2(0LL, a4, a5, 0LL, 0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v335);
  v320 = (char *)&v287 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v305 = (char *)&v287 - v27;
  uint64_t v337 = *(void *)(a5 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v319 = (char *)&v287 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v318 = (char *)&v287 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v317 = (char *)&v287 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v304 = (char *)&v287 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v303 = (char *)&v287 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v302 = (char *)&v287 - v39;
  v331 = (ValueMetadata *)a4;
  uint64_t v343 = *(void *)(a4 - 8);
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v316 = (char *)&v287 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v324 = (char *)&v287 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  v315 = (char *)&v287 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  v301 = (char *)&v287 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  v308 = (char *)&v287 - v49;
  MEMORY[0x1895F8858](v48);
  v300 = (char *)&v287 - v50;
  uint64_t v51 = swift_getTupleTypeMetadata2(0LL, (uint64_t)a2, a3, "key value ", 0LL);
  uint64_t v348 = *(v51 - 1);
  uint64_t v52 = MEMORY[0x1895F8858](v51);
  v330 = (char *)&v287 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v52);
  uint64_t v55 = (char *)&v287 - v54;
  uint64_t v293 = type metadata accessor for Optional(0LL, a3, v56, v57);
  uint64_t v292 = *(void *)(v293 - 8);
  uint64_t v58 = MEMORY[0x1895F8858](v293);
  v298 = (char *)&v287 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v60 = MEMORY[0x1895F8858](v58);
  v299 = (uint64_t *)((char *)&v287 - v61);
  uint64_t v62 = MEMORY[0x1895F8858](v60);
  v314 = (char *)&v287 - v63;
  MEMORY[0x1895F8858](v62);
  v313 = (char *)&v287 - v64;
  uint64_t v291 = type metadata accessor for Optional(0LL, (uint64_t)a2, v65, v66);
  uint64_t v290 = *(void *)(v291 - 8);
  uint64_t v67 = MEMORY[0x1895F8858](v291);
  v289 = (char *)&v287 - ((v68 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  v288 = (uint64_t *)((char *)&v287 - v70);
  uint64_t v71 = MEMORY[0x1895F8858](v69);
  v287 = (char *)&v287 - v72;
  uint64_t v73 = MEMORY[0x1895F8858](v71);
  int64_t i = (uint64_t *)((char *)&v287 - v74);
  v346 = (uint64_t *)a3;
  uint64_t v344 = *(void *)(a3 - 8);
  uint64_t v75 = MEMORY[0x1895F8858](v73);
  v323 = (char *)&v287 - ((v76 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v77 = MEMORY[0x1895F8858](v75);
  v307 = (char *)&v287 - v78;
  uint64_t v79 = MEMORY[0x1895F8858](v77);
  v329 = (char *)&v287 - v80;
  uint64_t v81 = *(a2 - 1);
  uint64_t v82 = MEMORY[0x1895F8858](v79);
  v326 = (char *)&v287 - ((v83 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v84 = MEMORY[0x1895F8858](v82);
  v310 = (char *)&v287 - v85;
  MEMORY[0x1895F8858](v84);
  v328 = (char *)&v287 - v86;
  uint64_t v89 = type metadata accessor for Optional(0LL, (uint64_t)v51, v87, v88);
  uint64_t v90 = MEMORY[0x1895F8858](v89);
  v341 = (char *)&v287 - ((v91 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v90);
  v332 = (char *)&v287 - v95;
  unint64_t v96 = a1 & 0xC000000000000001LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    int64_t v97 = a1;
    if (a1 < 0) {
      uint64_t v98 = (void *)a1;
    }
    else {
      uint64_t v98 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v99 = objc_msgSend(v98, sel_count);
  }

  else
  {
    int64_t v97 = a1;
    id v99 = *(id *)(a1 + 16);
  }

  v311 = v55;
  if (v99)
  {
    unint64_t v100 = v331;
    type metadata accessor for _DictionaryStorage(0LL, (uint64_t)v331, a5, v339);
    unint64_t v101 = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)((uint64_t)v99);
  }

  else
  {
    unint64_t v101 = &_swiftEmptyDictionarySingleton;
    unint64_t v100 = v331;
  }

  v334 = a2;
  v345 = v51;
  v340 = v101;
  uint64_t v347 = v81;
  uint64_t v338 = a5;
  uint64_t v294 = v12;
  if (v100 == &type metadata for String)
  {
    if (v96)
    {
      unint64_t v109 = v97;
      if (v97 >= 0) {
        v97 &= 0xFFFFFFFFFFFFFF8uLL;
      }
      uint64_t v110 = type metadata accessor for __CocoaDictionary.Iterator();
      unint64_t v111 = (unint64_t)swift_allocObject(v110, 0xE8uLL, 7uLL);
      v324 = 0LL;
      uint64_t v112 = 0LL;
      v330 = 0LL;
      *(void *)(v111 + 208) = v97;
      *(void *)(v111 + 216) = 0LL;
      *(_OWORD *)(v111 + 16) = 0u;
      *(_OWORD *)(v111 + 32) = 0u;
      *(_OWORD *)(v111 + 48) = 0u;
      *(_OWORD *)(v111 + 64) = 0u;
      *(_OWORD *)(v111 + 80) = 0u;
      *(_OWORD *)(v111 + 96) = 0u;
      *(_OWORD *)(v111 + 112) = 0u;
      *(_OWORD *)(v111 + 128) = 0u;
      *(_OWORD *)(v111 + 144) = 0u;
      *(_OWORD *)(v111 + 160) = 0u;
      *(_OWORD *)(v111 + 176) = 0u;
      *(_OWORD *)(v111 + 192) = 0u;
      *(void *)(v111 + 224) = 0LL;
      int64_t v97 = v111 | 0x8000000000000000LL;
    }

    else
    {
      unint64_t v109 = v97;
      uint64_t v202 = -1LL << *(_BYTE *)(v97 + 32);
      uint64_t v112 = ~v202;
      uint64_t v203 = *(void *)(v97 + 64);
      v324 = (char *)(v97 + 64);
      uint64_t v204 = -v202;
      if (v204 < 64) {
        uint64_t v205 = ~(-1LL << v204);
      }
      else {
        uint64_t v205 = -1LL;
      }
      v330 = (char *)(v205 & v203);
    }

    uint64_t v206 = v81;
    unint64_t v207 = i;
    v321 = (char *)((v97 & 0x7FFFFFFFFFFFFFFFLL) + 16);
    v327 = (char *)(v97 & 0x7FFFFFFFFFFFFFFFLL);
    v320 = (char *)((v97 & 0x7FFFFFFFFFFFFFFFLL) + 80);
    v319 = (char *)v112;
    v323 = (char *)((unint64_t)(v112 + 64) >> 6);
    v326 = (char *)(v101 + 8);
    swift_bridgeObjectRetain(v109, v92, v93, v94);
    uint64_t v342 = 0LL;
    v325 = (char *)&unk_189B8D230;
    unint64_t v211 = v346;
    uint64_t v212 = v348;
    char v213 = v314;
    unint64_t v214 = (uint64_t *)v313;
    v331 = (ValueMetadata *)v97;
    unint64_t v215 = (unint64_t)v330;
    while (1)
    {
      v330 = (char *)v215;
      if (v97 < 0)
      {
        uint64_t v217 = v327;
        uint64_t v218 = *((void *)v327 + 27);
        if (v218 < 0) {
          goto LABEL_121;
        }
        uint64_t v219 = (void *)*((void *)v327 + 26);
        if (v218 == *((void *)v327 + 28))
        {
          id v220 = objc_msgSend(*((id *)v327 + 26), sel_countByEnumeratingWithState_objects_count_, v321, v320, 16);
          uint64_t v217 = v327;
          *((void *)v327 + 28) = v220;
          if (!v220)
          {
            *((void *)v217 + 27) = -1LL;
            int64_t v97 = (int64_t)v331;
LABEL_121:
            (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v212 + 56))(v332, 1LL, 1LL, v51);
            uint64_t v284 = v97;
            goto LABEL_122;
          }

          uint64_t v218 = 0LL;
          *((void *)v217 + 27) = 0LL;
        }

        uint64_t v221 = *((void *)v217 + 3);
        if (!v221) {
          goto LABEL_133;
        }
        uint64_t v222 = v344;
        uint64_t v223 = (void **)(v221 + 8 * v218);
        if ((v223 & 7) != 0) {
LABEL_124:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
        uint64_t v224 = *v223;
        *((void *)v217 + 27) = v218 + 1;
        swift_unknownObjectRetain(v224, v208, v209, v210);
        uint64_t v225 = (swift *)objc_msgSend(v219, sel_objectForKey_, v224);
        if (!v225)
        {
LABEL_134:
          unint64_t v286 = 784LL;
          goto LABEL_135;
        }

        unint64_t v226 = v225;
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
        uint64_t v228 = v348;
        if (isClassOrObjCExistentialType)
        {
          v349 = (swift *)v224;
          uint64_t v229 = v332;
          swift_dynamicCast(v332, &v349, v325, a2, 7LL);
          uint64_t v230 = v345;
        }

        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v206 + 56))(v207, 1LL, 1LL, a2);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v224, (uint64_t)a2, v207);
          swift_unknownObjectRelease(v224);
          uint64_t v276 = v290;
          v277 = v207;
          v278 = v287;
          uint64_t v279 = v291;
          (*(void (**)(char *, uint64_t *, uint64_t))(v290 + 16))(v287, v277, v291);
          (*(void (**)(uint64_t *, uint64_t))(v276 + 8))(i, v279);
          uint64_t v229 = v332;
          (*(void (**)(char *, char *, uint64_t *))(v347 + 32))(v332, v278, a2);
          uint64_t v222 = v344;
          uint64_t v230 = v345;
        }

        uint64_t v231 = a2;
        uint64_t v232 = &v229[*((int *)v230 + 12)];
        if (_swift_isClassOrObjCExistentialType((uint64_t)v211, v211))
        {
          v349 = v226;
          swift_dynamicCast(v232, &v349, &unk_189B8D230, v211, 7LL);
        }

        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v222 + 56))(v214, 1LL, 1LL, v211);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v226, (uint64_t)v211, v214);
          swift_unknownObjectRelease(v226);
          uint64_t v280 = v292;
          uint64_t v281 = v222;
          uint64_t v282 = v293;
          (*(void (**)(char *, uint64_t *, uint64_t))(v292 + 16))(v213, v214, v293);
          if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v281 + 48))(v213, 1LL, v211) == 1) {
LABEL_136:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
          (*(void (**)(uint64_t *, uint64_t))(v280 + 8))(v214, v282);
          (*(void (**)(char *, char *, uint64_t *))(v281 + 32))(v232, v213, v211);
        }

        uint64_t v233 = v332;
        unint64_t v234 = v345;
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v228 + 56))(v332, 0LL, 1LL, v345);
        v341 = (char *)v342;
        uint64_t v333 = (uint64_t)v330;
        a2 = v231;
      }

      else
      {
        if (v215)
        {
          uint64_t v333 = (v215 - 1) & v215;
          unint64_t v216 = __clz(__rbit64(v215)) | (v342 << 6);
          v341 = (char *)v342;
        }

        else
        {
          uint64_t v235 = v342 + 1;
          if (__OFADD__(v342, 1LL)) {
            goto LABEL_131;
          }
          unint64_t v236 = *(void *)&v324[8 * v235];
          uint64_t v237 = v342 + 1;
          if (!v236)
          {
            uint64_t v237 = v342 + 2;
            unint64_t v236 = *(void *)&v324[8 * v237];
            if (!v236)
            {
              uint64_t v238 = v342 + 3;
              unint64_t v236 = *(void *)&v324[8 * v238];
              if (!v236)
              {
                while (1)
                {
                  uint64_t v237 = v238 + 1;
                  if (__OFADD__(v238, 1LL)) {
                    goto LABEL_132;
                  }
                  unint64_t v236 = *(void *)&v324[8 * v237];
                  ++v238;
                  if (v236) {
                    goto LABEL_98;
                  }
                }

LABEL_98:
          uint64_t v333 = (v236 - 1) & v236;
          v341 = (char *)v237;
          unint64_t v216 = __clz(__rbit64(v236)) + (v237 << 6);
        }

        uint64_t v239 = (uint64_t)v331;
        (*(void (**)(char *, unint64_t, uint64_t *))(v206 + 16))( v328,  v331[3].Kind + *(void *)(v206 + 72) * v216,  a2);
        uint64_t v240 = v344;
        __int128 v241 = v329;
        (*(void (**)(char *, unint64_t, uint64_t *))(v344 + 16))( v329,  *(void *)(v239 + 56) + *(void *)(v344 + 72) * v216,  v211);
        unint64_t v234 = v345;
        v242 = &v332[*((int *)v345 + 12)];
        uint64_t v233 = v332;
        (*(void (**)(void))(v206 + 32))();
        (*(void (**)(char *, char *, uint64_t *))(v240 + 32))(v242, v241, v211);
        uint64_t v228 = v348;
        (*(void (**)(char *, void, uint64_t, unint64_t *))(v348 + 56))(v233, 0LL, 1LL, v234);
      }

      v243 = v311;
      (*(void (**)(char *, char *, unint64_t *))(v228 + 32))(v311, v233, v234);
      uint64_t v244 = *((int *)v234 + 12);
      uint64_t v245 = v310;
      (*(void (**)(char *, char *, uint64_t *))(v206 + 16))(v310, v243, a2);
      __int128 v246 = v312;
      int v247 = swift_dynamicCast(v312, v245, a2, &type metadata for String, 6LL);
      uint64_t v248 = v343;
      v249 = *(void (**)(char *, uint64_t, uint64_t, ValueMetadata *))(v343 + 56);
      if (!v247) {
        break;
      }
      v249(v246, 0LL, 1LL, &type metadata for String);
      v250 = *(void (**)(char *, char *, ValueMetadata *))(v248 + 32);
      unint64_t v251 = v308;
      v250(v308, v246, &type metadata for String);
      v252 = v307;
      (*(void (**)(char *, char *, uint64_t *))(v344 + 16))(v307, &v243[v244], v211);
      (*(void (**)(char *, unint64_t *))(v228 + 8))(v243, v234);
      v253 = v309;
      uint64_t v254 = v338;
      char v255 = swift_dynamicCast(v309, v252, v211, v338, 6LL);
      uint64_t v256 = v337;
      v257 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v337 + 56);
      if ((v255 & 1) == 0)
      {
        v257(v253, 1LL, 1LL, v254);
        (*(void (**)(char *, ValueMetadata *))(v343 + 8))(v251, &type metadata for String);
        (*(void (**)(char *, uint64_t))(v294 + 8))(v253, v295);
LABEL_112:
        v283 = v340;
        outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v331);
        uint64_t v201 = (uint64_t)v283;
LABEL_113:
        swift_release(v201);
        return 0LL;
      }

      v257(v253, 0LL, 1LL, v254);
      uint64_t v258 = *(void (**)(char *, char *, uint64_t))(v256 + 32);
      v259 = v303;
      v258(v303, v253, v254);
      v260 = v306;
      uint64_t v261 = &v306[*((int *)TupleTypeMetadata2 + 12)];
      v250(v306, v251, &type metadata for String);
      v258(v261, v259, v254);
      v262 = v335;
      uint64_t v263 = v305;
      v264 = &v305[*((int *)v335 + 12)];
      v250(v305, v260, &type metadata for String);
      v258(v264, v261, v254);
      uint64_t v265 = &v263[*((int *)v262 + 12)];
      uint64_t v266 = v300;
      v250(v300, v263, &type metadata for String);
      v267 = v302;
      v258(v302, v265, v254);
      uint64_t v268 = (uint64_t)v301;
      v250(v301, v266, &type metadata for String);
      uint64_t v269 = v304;
      v258(v304, v267, v254);
      unint64_t v101 = v340;
      unint64_t v270 = __RawDictionaryStorage.find<A>(_:)(v268, (uint64_t)&type metadata for String, v339);
      unint64_t v271 = v270;
      if ((v272 & 1) != 0)
      {
        (*(void (**)(char *, uint64_t, ValueMetadata *))(v343 + 40))( (char *)v101[6] + *(void *)(v343 + 72) * v270,  v268,  &type metadata for String);
        (*(void (**)(char *, char *, uint64_t))(v256 + 40))( (char *)v101[7] + *(void *)(v256 + 72) * v271,  v269,  v254);
      }

      else
      {
        if (v101[2] >= v101[3]) {
          goto LABEL_126;
        }
        *(void *)&v326[(v270 >> 3) & 0x1FFFFFFFFFFFFFF8LL] |= 1LL << v270;
        v250((char *)v101[6] + *(void *)(v343 + 72) * v270, (char *)v268, &type metadata for String);
        v258((char *)v101[7] + *(void *)(v256 + 72) * v271, v269, v254);
        v273 = v101[2];
        BOOL v274 = __OFADD__(v273, 1LL);
        v275 = (__objc2_class *)((char *)&v273->isa + 1);
        if (v274)
        {
          __break(1u);
LABEL_128:
          __break(1u);
LABEL_129:
          __break(1u);
          goto LABEL_130;
        }

        v101[2] = v275;
      }

      uint64_t v342 = (uint64_t)v341;
      unint64_t v215 = v333;
      a2 = v334;
      uint64_t v51 = v345;
      unint64_t v211 = v346;
      uint64_t v206 = v347;
      uint64_t v212 = v348;
      char v213 = v314;
      unint64_t v214 = (uint64_t *)v313;
      unint64_t v207 = i;
      int64_t v97 = (int64_t)v331;
    }

    v249(v246, 1LL, 1LL, &type metadata for String);
    (*(void (**)(char *, unint64_t *))(v228 + 8))(v243, v234);
    (*(void (**)(char *, uint64_t))(v296 + 8))(v246, v297);
    goto LABEL_112;
  }

  unint64_t v102 = v97;
  if (v96)
  {
    if (v97 < 0) {
      uint64_t v103 = v97;
    }
    else {
      uint64_t v103 = v97 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v104 = type metadata accessor for __CocoaDictionary.Iterator();
    unint64_t v105 = (unint64_t)swift_allocObject(v104, 0xE8uLL, 7uLL);
    v314 = 0LL;
    uint64_t v106 = 0LL;
    unint64_t v107 = 0LL;
    *(void *)(v105 + 208) = v103;
    *(void *)(v105 + 216) = 0LL;
    *(_OWORD *)(v105 + 16) = 0u;
    *(_OWORD *)(v105 + 32) = 0u;
    *(_OWORD *)(v105 + 48) = 0u;
    *(_OWORD *)(v105 + 64) = 0u;
    *(_OWORD *)(v105 + 80) = 0u;
    *(_OWORD *)(v105 + 96) = 0u;
    *(_OWORD *)(v105 + 112) = 0u;
    *(_OWORD *)(v105 + 128) = 0u;
    *(_OWORD *)(v105 + 144) = 0u;
    *(_OWORD *)(v105 + 160) = 0u;
    *(_OWORD *)(v105 + 176) = 0u;
    *(_OWORD *)(v105 + 192) = 0u;
    *(void *)(v105 + 224) = 0LL;
    unint64_t v108 = v105 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v113 = -1LL << *(_BYTE *)(v97 + 32);
    uint64_t v106 = ~v113;
    uint64_t v114 = *(void *)(v97 + 64);
    v314 = (char *)(v97 + 64);
    uint64_t v115 = -v113;
    if (v115 < 64) {
      uint64_t v116 = ~(-1LL << v115);
    }
    else {
      uint64_t v116 = -1LL;
    }
    unint64_t v107 = v116 & v114;
    unint64_t v108 = v97;
  }

  uint64_t v117 = v81;
  v310 = (char *)((v108 & 0x7FFFFFFFFFFFFFFFLL) + 16);
  v313 = (char *)(v108 & 0x7FFFFFFFFFFFFFFFLL);
  v309 = (char *)((v108 & 0x7FFFFFFFFFFFFFFFLL) + 80);
  v308 = (char *)v106;
  v312 = (char *)((unint64_t)(v106 + 64) >> 6);
  swift_bridgeObjectRetain(v102, v92, v93, v94);
  swift_retain((unint64_t *)v101, v118, v119, v120);
  uint64_t v124 = 0LL;
  v311 = (char *)&unk_189B8D230;
  unint64_t v125 = v341;
  for (i = (uint64_t *)v108; ; unint64_t v108 = (unint64_t)i)
  {
    uint64_t v126 = a2;
    v332 = (char *)v124;
    uint64_t v333 = v107;
    if ((v108 & 0x8000000000000000LL) == 0)
    {
      uint64_t v127 = v344;
      uint64_t v128 = v330;
      if (v107)
      {
        uint64_t v342 = (v107 - 1) & v107;
        unint64_t v129 = __clz(__rbit64(v107)) | (v124 << 6);
        uint64_t v130 = v124;
        uint64_t v131 = v345;
      }

      else
      {
        uint64_t v149 = v124 + 1;
        uint64_t v131 = v345;
        if (__OFADD__(v124, 1LL)) {
          goto LABEL_128;
        }
        if (v149 >= (uint64_t)v312)
        {
          uint64_t v151 = v348;
          goto LABEL_119;
        }

        unint64_t v150 = *(void *)&v314[8 * v149];
        uint64_t v130 = v124 + 1;
        uint64_t v151 = v348;
        if (!v150)
        {
          uint64_t v130 = v124 + 2;
          unint64_t v150 = *(void *)&v314[8 * v130];
          if (!v150)
          {
            uint64_t v152 = (char *)(v124 + 3);
            unint64_t v150 = *(void *)&v314[8 * (void)v152];
            if (!v150)
            {
              while (1)
              {
                uint64_t v130 = (uint64_t)(v152 + 1);
                if (__OFADD__(v152, 1LL)) {
                  break;
                }
                unint64_t v150 = *(void *)&v314[8 * v130];
                ++v152;
                if (v150) {
                  goto LABEL_52;
                }
              }

      (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56))(v32, 1LL, 1LL, a2);
      swift_release((uint64_t)v43);
      uint64_t v114 = v50;
    }

    outlined consume of [A : B].Iterator._Variant<A, B>(v114);
    return (uint64_t)v133;
  }

  if ((v126 & 0xC000000000000001LL) != 0)
  {
    uint64_t v38 = v126 & 0xFFFFFFFFFFFFFF8LL;
    if (v126 < 0) {
      uint64_t v38 = v126;
    }
    uint64_t v39 = ~(v38 >> 1) & 0x4000000000000000LL | v38;
    swift_bridgeObjectRetain(v126, v35, v36, v37);
  }

  else
  {
    uint64_t v112 = (__objc2_class **)swift_bridgeObjectRetain(v126, v35, v36, v37);
    uint64_t v113 = _NativeSet.bridged()(v112, a2, a4);
    return ~((unint64_t)v113 >> 1) & 0x4000000000000000LL | (unint64_t)v113;
  }

  return v39;
}

LABEL_130:
              __break(1u);
LABEL_131:
              __break(1u);
LABEL_132:
              __break(1u);
LABEL_133:
              unint64_t v286 = 773LL;
LABEL_135:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v286,  0);
            }

            uint64_t v130 = v124 + 3;
          }
        }

  v202(v130, v69);
LABEL_131:
  uint64_t v294 = v605;
  uint64_t v295 = (uint64_t (*)(unint64_t *, unint64_t))v619;
  uint64_t v296 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
  ((void (*)(void (*)(char *, unint64_t *), uint64_t *, unint64_t *))v171)( v136,  v294,  v69);
  if (v296 >= 65)
  {
    v202((char *)v136, v69);
    goto LABEL_133;
  }

  v305 = v295(v69, v67);
  v202((char *)v136, v69);
  if (v305 == 64 && (((uint64_t (*)(unint64_t *, unint64_t))v617)(v69, v67) & 1) == 0)
  {
LABEL_133:
    uint64_t v297 = v587;
    ((void (*)(char *, uint64_t *, unint64_t *))v171)(v587, v605, v69);
    v624 = 0x7FFFFFFFFFFFFFFFLL;
    v298 = ((uint64_t (*)(unint64_t *, unint64_t))v617)(v69, v67);
    v299 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
    if ((v298 & 1) != 0)
    {
      if (v299 > 64)
      {
        v302 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
        v303 = lazy protocol witness table accessor for type Int and conformance Int(v299, v300, v301);
        v304 = &v624;
        goto LABEL_143;
      }
    }

    else if (v299 >= 64)
    {
      v623 = 0x7FFFFFFFFFFFFFFFLL;
      v302 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
      v303 = lazy protocol witness table accessor for type Int and conformance Int(v299, v300, v301);
      v304 = (unint64_t *)&v623;
LABEL_143:
      v302(v304, &type metadata for Int, v303, v69, v67);
      v308 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                           + 16LL))( v123,  v297,  v69);
      v202(v123, v69);
      if ((v308 & 1) == 0) {
        goto LABEL_144;
      }
      goto LABEL_142;
    }

    ((void (*)(char *, char *, unint64_t *))v171)(v123, v297, v69);
    v306 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
    v202(v123, v69);
    if ((uint64_t)v624 >= v306)
    {
LABEL_144:
      v202(v297, v69);
      goto LABEL_145;
    }

            v105._rawBits = (v22 << 16) | 1;
            v106._rawBits = 1LL;
            v107._rawBits = _StringGuts.validateScalarRange(_:)(v106, v105, v13, v14);
            if (v107._rawBits < 0x10000) {
              v107._rawBits |= 3;
            }
            unint64_t v109 = specialized String.init(_:)(v107, v108, v13, v14);
            unint64_t v111 = v110;
            swift_bridgeObjectRelease(v14);
            if ((v111 & 0x2000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v111);
            }

            else if ((v111 & 0x1000000000000000LL) != 0)
            {
              unint64_t v109 = _StringGuts._foreignConvertedToSmall()(v109, v111);
              uint64_t v222 = v221;
              swift_bridgeObjectRelease(v111);
              unint64_t v111 = v222;
            }

            else
            {
              if ((v109 & 0x1000000000000000LL) != 0)
              {
                uint64_t v201 = (unsigned __int8 *)((v111 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v202 = v109 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                uint64_t v201 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v109, v111);
              }

              closure #1 in _StringGuts._convertedToSmall()(v201, v202, &v229);
              swift_bridgeObjectRelease(v111);
              unint64_t v111 = *((void *)&v229 + 1);
              unint64_t v109 = v229;
            }

            uint64_t v112 = HIBYTE(v16) & 0xF;
            uint64_t v113 = HIBYTE(v111) & 0xF;
            uint64_t v114 = v113 + v112;
            if ((unint64_t)(v113 + v112) <= 0xF)
            {
              if (v113)
              {
                uint64_t v115 = 0LL;
                uint64_t v116 = 0LL;
                uint64_t v117 = 8 * v113;
                do
                {
                  uint64_t v118 = v112 + v116;
                  uint64_t v94 = v116++ >= 8;
                  if (v94) {
                    uint64_t v119 = v111;
                  }
                  else {
                    uint64_t v119 = v109;
                  }
                  Swift::String::Index v120 = (8 * v112 + v115) & 0x38;
                  uint64_t v121 = (-255LL << v120) - 1;
                  uint64_t v122 = (unint64_t)(v119 >> (v115 & 0x38)) << v120;
                  uint64_t v123 = v122 | v121 & v16;
                  uint64_t v124 = v122 | v121 & v20;
                  if (v118 < 8) {
                    uint64_t v20 = v124;
                  }
                  else {
                    uint64_t v16 = v123;
                  }
                  v115 += 8LL;
                }

                while (v117 != v115);
              }

        uint64_t v47 = _StringObject.sharedUTF8.getter(v14, a1);
        uint64_t v48 = v170;
        if (v170 < (uint64_t)a2) {
LABEL_133:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
        goto LABEL_26;
      }
    }

    else if (a4 >= 16)
    {
      goto LABEL_22;
    }

    swift_bridgeObjectRelease(a1);
    swift_bridgeObjectRetain(v43, v51, v52, v53);
    uint64_t v54 = _StringGuts._convertedToSmall()(v44, v43);
    uint64_t v56 = v55;
    swift_bridgeObjectRelease(v43);
    uint64_t v57 = HIBYTE(a1) & 0xF;
    if ((a1 & 0x2000000000000000LL) == 0) {
      uint64_t v57 = v14 & 0xFFFFFFFFFFFFLL;
    }
    if (v57 < a2) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
    }
    if ((v7 & 0xFFFFFFFFFFFF0000LL | 1) >= 0x10000) {
      v59._rawBits = v7 & 0xFFFFFFFFFFFF0000LL | 1;
    }
    else {
      v59._rawBits = v7 & 0xFFFFFFFFFFFF0000LL | 3;
    }
    v58._rawBits = a6 & 0xFFFFFFFFFFFF0000LL | 1;
    uint64_t v60 = specialized String.init(_:)(v59, v58, v14, a1);
    uint64_t v62 = v61;
    swift_bridgeObjectRelease(a1);
    uint64_t v63 = _StringGuts._convertedToSmall()(v60, v62);
    uint64_t v65 = v64;
    swift_bridgeObjectRelease(v62);
    uint64_t v66 = HIBYTE(v56) & 0xF;
    uint64_t v67 = HIBYTE(v65) & 0xF;
    uint64_t v68 = v67 + v66;
    if ((unint64_t)(v67 + v66) > 0xF)
    {
LABEL_148:
      char v182 = 266LL;
      goto LABEL_150;
    }

    uint64_t v69 = v192;
    uint64_t v70 = v185;
    if (v67)
    {
      uint64_t v71 = 0LL;
      uint64_t v72 = 0LL;
      uint64_t v73 = 8 * v67;
      do
      {
        uint64_t v74 = v66 + v72;
        uint64_t v75 = v72++ >= 8;
        if (v75) {
          uint64_t v76 = v65;
        }
        else {
          uint64_t v76 = v63;
        }
        uint64_t v77 = (8 * v66 + v71) & 0x38;
        uint64_t v78 = (-255LL << v77) - 1;
        uint64_t v79 = (unint64_t)(v76 >> (v71 & 0x38)) << v77;
        uint64_t v80 = v79 | v78 & v56;
        uint64_t v81 = v79 | v78 & v54;
        if (v74 < 8) {
          uint64_t v54 = v81;
        }
        else {
          uint64_t v56 = v80;
        }
        v71 += 8LL;
      }

      while (v73 != v71);
    }

    swift_bridgeObjectRelease(v43);
    uint64_t v82 = 0xA000000000000000LL;
    if (!(v54 & 0x8080808080808080LL | v56 & 0x80808080808080LL)) {
      uint64_t v82 = 0xE000000000000000LL;
    }
    unint64_t v200 = v54;
    uint64_t v201 = v82 & 0xFF00000000000000LL | (v68 << 56) | v56 & 0xFFFFFFFFFFFFFFLL;
LABEL_64:
    int64_t v97 = v200 & 0xFFFFFFFFFFFFLL;
    if ((v201 & 0x2000000000000000LL) != 0) {
      int64_t v97 = HIBYTE(v201) & 0xF;
    }
    uint64_t v185 = v97;
    specialized String.append<A>(contentsOf:)(v188, v187, v190, v69);
    uint64_t v7 = v200;
    uint64_t v43 = v201;
    if ((v201 & 0x2000000000000000LL) != 0) {
      unint64_t v100 = HIBYTE(v201) & 0xF;
    }
    else {
      unint64_t v100 = v200 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v201, 3LL, v98, v99);
    v101._rawBits = v186;
    a1 = specialized Collection.subscript.getter(v101, v70, v15);
    uint64_t v15 = v102;
    a4 = v41;
    a6 = v42;
    a2 = a1 >> 16;
    uint64_t v14 = v102 >> 16;
    Swift::String::Index v192 = v100;
    if ((v42 & 0x1000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain_n(v42, 2LL, v41, (char *)v42);
      swift_bridgeObjectRelease_n(v43, 2LL);
      a3 = v14 - a2;
      if ((v43 & 0x1000000000000000LL) == 0)
      {
LABEL_71:
        swift_bridgeObjectRelease(v43);
        uint64_t v103 = __OFADD__(v100, a3);
        a5 = v100 + a3;
        if (!v103)
        {
          if ((v7 & ~v43 & 0x2000000000000000LL) == 0
            || (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v43 & 0xFFFFFFFFFFFFFFFLL),
                uint64_t v7 = v200,
                uint64_t v43 = v201,
                !isUniquelyReferenced_nonNull_native))
          {
            if (a5 > 15) {
              goto LABEL_78;
            }
LABEL_84:
            swift_bridgeObjectRelease(a6);
            swift_bridgeObjectRetain(v43, v112, v113, v114);
            uint64_t v115 = _StringGuts._convertedToSmall()(v7, v43);
            uint64_t v117 = v116;
            swift_bridgeObjectRelease(v43);
            v118._rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 1;
            v119._rawBits = v15 & 0xFFFFFFFFFFFF0000LL | 1;
            v120._rawBits = _StringGuts.validateScalarRange(_:)(v118, v119, a4, a6);
            if (v120._rawBits < 0x10000) {
              v120._rawBits |= 3;
            }
            uint64_t v122 = specialized String.init(_:)(v120, v121, a4, a6);
            uint64_t v124 = v123;
            swift_bridgeObjectRelease(a6);
            unint64_t v125 = _StringGuts._convertedToSmall()(v122, v124);
            uint64_t v127 = v126;
            swift_bridgeObjectRelease(v124);
            uint64_t v128 = HIBYTE(v117) & 0xF;
            unint64_t v129 = HIBYTE(v127) & 0xF;
            uint64_t v130 = v129 + v128;
            if ((unint64_t)(v129 + v128) <= 0xF)
            {
              unint64_t v107 = v184;
              uint64_t v26 = v185;
              if (v129)
              {
                uint64_t v131 = 0LL;
                uint64_t v132 = 0LL;
                uint64_t v133 = 8 * v129;
                do
                {
                  uint64_t v134 = v128 + v132;
                  uint64_t v75 = v132++ >= 8;
                  if (v75) {
                    id v135 = v127;
                  }
                  else {
                    id v135 = v125;
                  }
                  uint64_t v136 = (8 * v128 + v131) & 0x38;
                  id v137 = (-255LL << v136) - 1;
                  uint64_t v138 = (unint64_t)(v135 >> (v131 & 0x38)) << v136;
                  unint64_t v139 = v138 | v137 & v117;
                  unint64_t v140 = v138 | v137 & v115;
                  if (v134 < 8) {
                    uint64_t v115 = v140;
                  }
                  else {
                    uint64_t v117 = v139;
                  }
                  v131 += 8LL;
                }

                while (v133 != v131);
              }

              swift_bridgeObjectRelease(v43);
              unint64_t v141 = 0xA000000000000000LL;
              if (!(v115 & 0x8080808080808080LL | v117 & 0x80808080808080LL)) {
                unint64_t v141 = 0xE000000000000000LL;
              }
              unint64_t v200 = v115;
              uint64_t v201 = v141 & 0xFF00000000000000LL | (v130 << 56) | v117 & 0xFFFFFFFFFFFFFFLL;
              goto LABEL_103;
            }

            goto LABEL_148;
          }

          unint64_t v105 = _StringGuts.nativeUnusedCapacity.getter(v200, v201);
          if ((v106 & 1) == 0)
          {
            if (a5 >= 16 || (v43 & 0x2000000000000000LL) == 0 && v105 >= a3)
            {
LABEL_78:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(a5, a3);
              swift_bridgeObjectRelease(a6);
              if ((a6 & 0x1000000000000000LL) != 0)
              {
                _StringGuts._foreignAppendInPlace(_:)(a4, a6, a2, v14);
                swift_bridgeObjectRelease(a6);
                unint64_t v107 = v184;
                uint64_t v26 = v185;
              }

              else
              {
                unint64_t v107 = v184;
                if ((a6 & 0x2000000000000000LL) != 0)
                {
                  swift_bridgeObjectRelease(a6);
                  int64_t v142 = HIBYTE(a6) & 0xF;
                  uint64_t v194 = a4;
                  uint64_t v195 = a6 & 0xFFFFFFFFFFFFFFLL;
                  if (v142 < v14) {
                    goto LABEL_133;
                  }
                  char v143 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a2, v14, (uint64_t)&v194, v142);
                  _StringGuts.appendInPlace(_:isASCII:)(v143, v144, (a6 & 0x4000000000000000LL) != 0);
                }

                else
                {
                  if ((a4 & 0x1000000000000000LL) != 0)
                  {
                    unint64_t v108 = (id)((a6 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    unint64_t v109 = a4 & 0xFFFFFFFFFFFFLL;
                    if ((a4 & 0xFFFFFFFFFFFFLL) < v14) {
                      goto LABEL_133;
                    }
                  }

                  else
                  {
                    unint64_t v108 = _StringObject.sharedUTF8.getter(a4, a6);
                    unint64_t v109 = v171;
                    if (v171 < v14) {
                      goto LABEL_133;
                    }
                  }

                  uint64_t v110 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a2, v14, (uint64_t)v108, v109);
                  _StringGuts.appendInPlace(_:isASCII:)(v110, v111, a4 < 0);
                  swift_bridgeObjectRelease(a6);
                }

                uint64_t v26 = v185;
              }

        uint64_t v36 = _StringObject.sharedUTF8.getter(v9, v17);
        uint64_t v37 = v163;
        if (v163 < (uint64_t)a2) {
LABEL_133:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
        goto LABEL_23;
      }
    }

    else if (v34 >= 16)
    {
      goto LABEL_19;
    }

    swift_bridgeObjectRelease(v17);
    swift_bridgeObjectRetain(v174, v45, v46, v47);
    uint64_t v41 = _StringGuts._convertedToSmall()(v173, v174);
    uint64_t v49 = v48;
    swift_bridgeObjectRelease(v174);
    uint64_t v50 = HIBYTE(v17) & 0xF;
    if ((v17 & 0x2000000000000000LL) == 0) {
      uint64_t v50 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (v50 < a2) {
      goto LABEL_127;
    }
    if ((v25 & 0xFFFFFFFFFFFF0000LL | 1) >= 0x10000) {
      v52._rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
    }
    else {
      v52._rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 3;
    }
    v51._rawBits = v27 & 0xFFFFFFFFFFFF0000LL | 1;
    uint64_t v53 = specialized String.init(_:)(v52, v51, v9, v17);
    uint64_t v55 = v54;
    swift_bridgeObjectRelease(v17);
    uint64_t v56 = _StringGuts._convertedToSmall()(v53, v55);
    uint64_t v58 = v57;
    swift_bridgeObjectRelease(v55);
    uint64_t v59 = HIBYTE(v49) & 0xF;
    uint64_t v60 = HIBYTE(v58) & 0xF;
    uint64_t v61 = v60 + v59;
    if ((unint64_t)(v60 + v59) > 0xF)
    {
LABEL_137:
      unint64_t v165 = 266LL;
      goto LABEL_139;
    }

    uint64_t v63 = v168;
    uint64_t v62 = v169;
    if (v60)
    {
      uint64_t v64 = 0LL;
      uint64_t v65 = 0LL;
      uint64_t v66 = 8 * v60;
      do
      {
        uint64_t v67 = v59 + v65;
        uint64_t v68 = v65++ >= 8;
        if (v68) {
          uint64_t v69 = v58;
        }
        else {
          uint64_t v69 = v56;
        }
        uint64_t v70 = (8 * v59 + v64) & 0x38;
        uint64_t v71 = (-255LL << v70) - 1;
        uint64_t v72 = (unint64_t)(v69 >> (v64 & 0x38)) << v70;
        uint64_t v73 = v72 | v71 & v49;
        uint64_t v74 = v72 | v71 & v41;
        if (v67 < 8) {
          uint64_t v41 = v74;
        }
        else {
          uint64_t v49 = v73;
        }
        v64 += 8LL;
      }

      while (v66 != v64);
    }

    swift_bridgeObjectRelease(v174);
    uint64_t v75 = 0xA000000000000000LL;
    if (!(v41 & 0x8080808080808080LL | v49 & 0x80808080808080LL)) {
      uint64_t v75 = 0xE000000000000000LL;
    }
    uint64_t v39 = v75 & 0xFF00000000000000LL | (v61 << 56) | v49 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v173 = v41;
    uint64_t v174 = v39;
LABEL_58:
    uint64_t v92 = HIBYTE(v39) & 0xF;
    if ((v39 & 0x2000000000000000LL) == 0) {
      uint64_t v92 = v41 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v169 = v92;
    specialized String.append<A>(contentsOf:)(v170, v42, v43, v44);
    uint64_t v17 = v173;
    uint64_t v32 = v174;
    if ((v174 & 0x2000000000000000LL) != 0) {
      uint64_t v95 = HIBYTE(v174) & 0xF;
    }
    else {
      uint64_t v95 = v173 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v174, 2LL, v93, v94);
    v96._rawBits = v62;
    a2 = specialized Collection.subscript.getter(v96, v63, v8);
    uint64_t v34 = v97;
    uint64_t v25 = v30;
    uint64_t v27 = v31;
    uint64_t v9 = a2 >> 16;
    uint64_t v8 = v97 >> 16;
    unint64_t v170 = v95;
    if ((v31 & 0x1000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain_n(v31, 2LL, v30, (char *)v31);
      swift_bridgeObjectRelease(v32);
      uint64_t v98 = v8 - v9;
      if ((v32 & 0x1000000000000000LL) == 0)
      {
LABEL_65:
        swift_bridgeObjectRelease(v32);
        id v99 = __OFADD__(v95, v98);
        unint64_t v100 = v95 + v98;
        if (v99)
        {
          __break(1u);
          goto LABEL_127;
        }

        if ((v17 & ~v32 & 0x2000000000000000LL) == 0
          || (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v32 & 0xFFFFFFFFFFFFFFFLL),
              uint64_t v17 = v173,
              uint64_t v32 = v174,
              !isUniquelyReferenced_nonNull_native))
        {
          if (v100 > 15) {
            goto LABEL_72;
          }
          goto LABEL_78;
        }

        unint64_t v102 = _StringGuts.nativeUnusedCapacity.getter(v173, v174);
        if ((v103 & 1) == 0)
        {
          if (v100 >= 16 || (v32 & 0x2000000000000000LL) == 0 && v102 >= v98)
          {
LABEL_72:
            _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v100, v98);
            swift_bridgeObjectRelease(v27);
            if ((v27 & 0x1000000000000000LL) != 0)
            {
              _StringGuts._foreignAppendInPlace(_:)(v25, v27, v9, v8);
              swift_bridgeObjectRelease(v27);
              uint64_t v127 = (unint64_t *)v167;
            }

            else
            {
              if ((v27 & 0x2000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v27);
                unint64_t v139 = HIBYTE(v27) & 0xF;
                unint64_t v171 = v25;
                uint64_t v172 = v27 & 0xFFFFFFFFFFFFFFLL;
                if (v139 < v8) {
                  goto LABEL_133;
                }
                unint64_t v140 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v8, (uint64_t)&v171, v139);
                unint64_t v141 = v174;
                closure #1 in _StringGuts.appendInPlace(_:isASCII:)( v174 & 0xFFFFFFFFFFFFFFFLL,  v140,  v142,  (v27 & 0x4000000000000000LL) != 0);
                uint64_t v173 = *(void *)(v141 + 24);
              }

              else
              {
                if ((v25 & 0x1000000000000000LL) != 0)
                {
                  uint64_t v104 = (id)((v27 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  unint64_t v105 = v25 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  uint64_t v104 = _StringObject.sharedUTF8.getter(v25, v27);
                  unint64_t v105 = v164;
                }

                uint64_t v106 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v8, (uint64_t)v104, v105);
                unint64_t v107 = v174;
                closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v174 & 0xFFFFFFFFFFFFFFFLL, v106, v108, v25 < 0);
                uint64_t v173 = *(void *)(v107 + 24);
                swift_bridgeObjectRelease(v27);
              }

              uint64_t v127 = (unint64_t *)v167;
            }

    _StringGuts._foreignGrow(_:)(v25);
LABEL_111:
    uint64_t v158 = *(void *)(v6 + 8);
    specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( v21,  a2,  a3,  a4,  (uint64_t)closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL,  v5);
    swift_bridgeObjectRelease(a4);
    *(void *)uint64_t v6 = *(void *)(v158 + 24);
    return v21;
  }

  while (1)
  {
    __break(1u);
LABEL_123:
    uint64_t v43 = _StringObject.sharedUTF8.getter(v6, a4);
    uint64_t v44 = v168;
    if (v168 < v5) {
      goto LABEL_128;
    }
LABEL_30:
    uint64_t v45 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v171, v5, (uint64_t)v43, v44);
    uint64_t v47 = v46;
    uint64_t v21 = v180;
    uint64_t v48 = v180 & 0xFFFFFFFFFFFFFFFLL;
    specialized UnsafeMutablePointer.initialize(from:count:)( v45,  v46,  (char *)((v180 & 0xFFFFFFFFFFFFFFFLL) + (*(void *)((v180 & 0xFFFFFFFFFFFFFFFLL) + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
    uint64_t v49 = *(void *)(v48 + 24);
    if (__OFADD__(v49 & 0xFFFFFFFFFFFFLL, v47))
    {
      __break(1u);
LABEL_126:
      __break(1u);
      goto LABEL_127;
    }

    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)((v49 & 0xFFFFFFFFFFFFLL) + v47, (v49 & v6) < 0);
    uint64_t v50 = *(void *)(v48 + 24);
    __src = v50;
    swift_bridgeObjectRelease(a4);
LABEL_52:
    uint64_t v71 = v173;
LABEL_53:
    uint64_t v90 = HIBYTE(v21) & 0xF;
    if ((v21 & 0x2000000000000000LL) == 0) {
      uint64_t v90 = v50 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v175 = v90;
    specialized String.append<A>(contentsOf:)(a3, v71, v51, v52);
    uint64_t v5 = __src;
    uint64_t v40 = v180;
    uint64_t v93 = HIBYTE(v180) & 0xF;
    if ((v180 & 0x2000000000000000LL) == 0) {
      uint64_t v93 = __src & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v176 = v93;
    swift_bridgeObjectRetain_n(v180, 3LL, v91, v92);
    v94._rawBits = v174;
    a4 = specialized Collection.subscript.getter(v94, v12, v11);
    uint64_t v12 = v95;
    a3 = v38;
    uint64_t v21 = v39;
    uint64_t v11 = a4 >> 16;
    a2 = v95 >> 16;
    if ((v39 & 0x1000000000000000LL) != 0)
    {
LABEL_117:
      swift_bridgeObjectRetain_n(v21, 3LL, v38, (char *)v39);
      v164._rawBits = a4 & 0xFFFFFFFFFFFF0000LL | 1;
      v165._rawBits = v12 & 0xFFFFFFFFFFFF0000LL | 1;
      v166._rawBits = _StringGuts.validateScalarRange(_:)(v164, v165, a3, v21);
      if (v166._rawBits < 0x10000) {
        v166._rawBits |= 3;
      }
      uint64_t v6 = specialized Collection.count.getter(v166, v167, a3, v21);
      swift_bridgeObjectRelease(v40);
      unint64_t v96 = v21;
    }

    else
    {
      uint64_t v6 = a2 - v11;
      swift_bridgeObjectRetain_n(v39, 2LL, v38, (char *)v39);
      unint64_t v96 = v40;
    }

    swift_bridgeObjectRelease(v40);
    swift_bridgeObjectRelease(v96);
    int64_t v97 = v176;
    if ((v40 & 0x1000000000000000LL) != 0) {
      int64_t v97 = String.UTF8View._foreignCount()();
    }
    swift_bridgeObjectRelease(v40);
    uint64_t v98 = __OFADD__(v97, v6);
    id v99 = v97 + v6;
    if (!v98) {
      break;
    }
    __break(1u);
LABEL_121:
    __break(1u);
  }

  if ((v5 & ~v40 & 0x2000000000000000LL) == 0
    || (v100 = swift_isUniquelyReferenced_nonNull_native(v40 & 0xFFFFFFFFFFFFFFFLL), uint64_t v5 = __src, v40 = v180, !v100))
  {
    if (v99 > 15) {
      goto LABEL_68;
    }
LABEL_74:
    swift_bridgeObjectRelease(v21);
    swift_bridgeObjectRetain(v40, v107, v108, v109);
    uint64_t v110 = _StringGuts._convertedToSmall()(v5, v40);
    uint64_t v112 = v111;
    swift_bridgeObjectRelease(v40);
    v113._rawBits = a4 & 0xFFFFFFFFFFFF0000LL | 1;
    v114._rawBits = v12 & 0xFFFFFFFFFFFF0000LL | 1;
    v115._rawBits = _StringGuts.validateScalarRange(_:)(v113, v114, a3, v21);
    if (v115._rawBits < 0x10000) {
      v115._rawBits |= 3;
    }
    uint64_t v117 = specialized String.init(_:)(v115, v116, a3, v21);
    uint64_t v119 = v118;
    swift_bridgeObjectRelease(v21);
    Swift::String::Index v120 = _StringGuts._convertedToSmall()(v117, v119);
    uint64_t v122 = v121;
    swift_bridgeObjectRelease(v119);
    uint64_t v123 = HIBYTE(v112) & 0xF;
    uint64_t v124 = HIBYTE(v122) & 0xF;
    unint64_t v125 = v124 + v123;
    if ((unint64_t)(v124 + v123) <= 0xF)
    {
      a4 = (Swift::UInt64)v172;
      if (v124)
      {
        uint64_t v126 = 0;
        uint64_t v127 = 0LL;
        do
        {
          uint64_t v128 = v123 + v127;
          unint64_t v129 = v127 + 1;
          if (v127 >= 8) {
            uint64_t v130 = v122;
          }
          else {
            uint64_t v130 = v120;
          }
          uint64_t v131 = v130 >> (v126 & 0x38);
          uint64_t v132 = (8 * v123 + v126) & 0x38;
          uint64_t v133 = (-255LL << v132) - 1;
          uint64_t v134 = (unint64_t)v131 << v132;
          id v135 = v134 | v133 & v112;
          uint64_t v136 = v134 | v133 & v110;
          if (v128 < 8) {
            uint64_t v110 = v136;
          }
          else {
            uint64_t v112 = v135;
          }
          v126 += 8;
          uint64_t v127 = v129;
        }

        while (v124 != v129);
      }

      swift_bridgeObjectRelease(v40);
      id v137 = 0xA000000000000000LL;
      if (!(v110 & 0x8080808080808080LL | v112 & 0x80808080808080LL)) {
        id v137 = 0xE000000000000000LL;
      }
      __src = v110;
      BOOL v180 = v137 & 0xFF00000000000000LL | (v125 << 56) | v112 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_93;
    }

    goto LABEL_133;
  }

  unint64_t v101 = _StringGuts.nativeUnusedCapacity.getter(__src, v180);
  if ((v102 & 1) != 0)
  {
LABEL_134:
    unint64_t v170 = 258LL;
LABEL_135:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v170,  0);
  }

  if (v99 < 16 && ((v40 & 0x2000000000000000LL) != 0 || v101 < v6)) {
    goto LABEL_74;
  }
LABEL_68:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v99, v6);
  swift_bridgeObjectRelease(v21);
  if ((v21 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(a3, v21, v11, a2);
    swift_bridgeObjectRelease(v21);
    a4 = (Swift::UInt64)v172;
    goto LABEL_93;
  }

  a4 = (Swift::UInt64)v172;
  if ((v21 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v21);
    uint64_t v138 = HIBYTE(v21) & 0xF;
    char v177 = a3;
    uint64_t v178 = v21 & 0xFFFFFFFFFFFFFFLL;
    if (v138 < a2) {
      goto LABEL_128;
    }
    unint64_t v139 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v11, a2, (uint64_t)&v177, v138);
    uint64_t v25 = v140;
    unint64_t v141 = v180 & 0xFFFFFFFFFFFFFFFLL;
    specialized UnsafeMutablePointer.initialize(from:count:)( v139,  v140,  (char *)((v180 & 0xFFFFFFFFFFFFFFFLL) + (*(void *)((v180 & 0xFFFFFFFFFFFFFFFLL) + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
    int64_t v142 = *(void *)(v141 + 24);
    if (!__OFADD__(v142 & 0xFFFFFFFFFFFFLL, v25))
    {
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( (v142 & 0xFFFFFFFFFFFFLL) + v25,  (v21 >> 62) & (v142 < 0));
      __src = *(void *)(v141 + 24);
      goto LABEL_93;
    }

    __break(1u);
    goto LABEL_130;
  }

  if ((a3 & 0x1000000000000000LL) != 0)
  {
    uint64_t v103 = (id)((v21 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v104 = a3 & 0xFFFFFFFFFFFFLL;
    if ((a3 & 0xFFFFFFFFFFFFLL) >= a2) {
      goto LABEL_72;
    }
LABEL_128:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

uint64_t (*__RawDictionaryStorage._count.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._capacity.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._scale.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._reservedScale.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._age.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._seed.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*__RawDictionaryStorage._rawKeys.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawDictionaryStorage._rawValues.setter(uint64_t result)
{
  *(void *)(v1 + 56) = result;
  return result;
}

uint64_t (*__RawDictionaryStorage._rawValues.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawDictionaryStorage._metadata.getter()
{
  return v0 + 64;
}

uint64_t __RawDictionaryStorage._hashTable.getter()
{
  return v0 + 64;
}

  ;
}

void __RawDictionaryStorage.__allocating_init(coder:)()
{
}

void __RawDictionaryStorage.init(coder:)()
{
}

uint64_t __RawDictionaryStorage.deinit()
{
  return v0;
}

void __RawDictionaryStorage.__deallocating_deinit()
{
}

uint64_t __EmptyDictionarySingleton.deinit()
{
  return v0;
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:)(uint64_t a1)
{
  uint64_t v3 = specialized static Hasher._hash(seed:_:)(*(void *)(v1 + 40), a1);
  return specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v3);
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v5 = _swift_stdlib_Hashing_parameters ^ *(void *)(v2 + 40);
  v8[0] = 0LL;
  v8[1] = v5 ^ 0x736F6D6570736575LL;
  _OWORD v8[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v8[3] = v5 ^ 0x6C7967656E657261LL;
  v8[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  String.hash(into:)(v8, a1, a2);
  Swift::Int v6 = Hasher._finalize()();
  return specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v6);
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:)(void *a1)
{
  uint64_t v3 = *(void *)(v1 + 40);
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 8))(v10, v4, v5);
  uint64_t v6 = v11;
  uint64_t v7 = v12;
  __swift_project_boxed_opaque_existential_0Tm(v10, v11);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(v3, v6, v7);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  return specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v8);
}

unint64_t __RawDictionaryStorage.find<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v7 = (*(uint64_t (**)(void))(a3 + 32))(*(void *)(v4 + 40));
  return __RawDictionaryStorage.find<A>(_:hashValue:)(a1, v7, a2);
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:hashValue:)(void *a1, uint64_t a2)
{
  uint64_t v3 = -1LL << *(_BYTE *)(v2 + 32);
  unint64_t v4 = a2 & ~v3;
  uint64_t v16 = v2 + 64;
  if (((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v4) & 1) != 0)
  {
    uint64_t v5 = v2;
    uint64_t v7 = ~v3;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v4, (uint64_t)v21);
      uint64_t v8 = v22;
      uint64_t v9 = v23;
      __swift_project_boxed_opaque_existential_0Tm(v21, v22);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v9 + 8))(v18, v8, v9);
      uint64_t v10 = v19;
      uint64_t v11 = v20;
      __swift_project_boxed_opaque_existential_0Tm(v18, v19);
      uint64_t v12 = a1[3];
      uint64_t v13 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v12);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v13 + 8))(v17, v12, v13);
      char v14 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v11 + 16))(v17, v10, v11);
      __swift_destroy_boxed_opaque_existential_1Tm(v17);
      if (v14 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
      }

      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
        if ((v14 & 1) != 0) {
          return v4;
        }
      }

      unint64_t v4 = (v4 + 1) & v7;
    }

    while (((*(void *)(v16 + ((v4 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v4) & 1) != 0);
  }

  return v4;
}

{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v16;
  uint64_t v17[5];
  uint64_t v18[3];
  uint64_t v19;
  uint64_t v20;
  uint64_t v21[3];
  uint64_t v22;
  uint64_t v23;
  uint64_t v3 = -1LL << *(_BYTE *)(v2 + 32);
  unint64_t v4 = a2 & ~v3;
  uint64_t v16 = v2 + 64;
  if (((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v4) & 1) != 0)
  {
    uint64_t v5 = v2;
    uint64_t v7 = ~v3;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v4, (uint64_t)v21);
      uint64_t v8 = v22;
      uint64_t v9 = v23;
      __swift_project_boxed_opaque_existential_0Tm(v21, v22);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v9 + 8))(v18, v8, v9);
      uint64_t v10 = v19;
      uint64_t v11 = v20;
      __swift_project_boxed_opaque_existential_0Tm(v18, v19);
      uint64_t v12 = a1[3];
      uint64_t v13 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v12);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v13 + 8))(v17, v12, v13);
      char v14 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v11 + 16))(v17, v10, v11);
      __swift_destroy_boxed_opaque_existential_1Tm(v17);
      if (v14 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
      }

      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v18);
        outlined destroy of AnyHashable(v21);
        if ((v14 & 1) != 0) {
          return v4;
        }
      }

      unint64_t v4 = (v4 + 1) & v7;
    }

    while (((*(void *)(v16 + ((v4 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v4) & 1) != 0);
  }

  return v4;
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:hashValue:)( uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if (((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0)
  {
    uint64_t v9 = ~v5;
    uint64_t v10 = *(void *)(v3 + 48);
    do
    {
      uint64_t v11 = (uint64_t *)(v10 + 16 * v6);
      unint64_t v12 = v11[1];
      if (*v11 == a1 && v12 == a2) {
        break;
      }
      BOOL v14 = (~v12 & 0x6000000000000000LL) != 0 || (a2 & 0x2000000000000000LL) == 0;
      BOOL v15 = v14 || (a2 & 0x4000000000000000LL) == 0;
      if (v15 && (_stringCompareInternal(_:_:expecting:)(*v11, v12, a1, a2, 0) & 1) != 0) {
        break;
      }
      unint64_t v6 = (v6 + 1) & v9;
    }

    while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
  }

  return v6;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  BOOL v14;
  BOOL v15;
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if (((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0)
  {
    uint64_t v9 = ~v5;
    uint64_t v10 = *(void *)(v3 + 48);
    do
    {
      uint64_t v11 = (uint64_t *)(v10 + 16 * v6);
      unint64_t v12 = v11[1];
      if (*v11 == a1 && v12 == a2) {
        break;
      }
      BOOL v14 = (~v12 & 0x6000000000000000LL) != 0 || (a2 & 0x2000000000000000LL) == 0;
      BOOL v15 = v14 || (a2 & 0x4000000000000000LL) == 0;
      if (v15 && (_stringCompareInternal(_:_:expecting:)(*v11, v12, a1, a2, 0) & 1) != 0) {
        break;
      }
      unint64_t v6 = (v6 + 1) & v9;
    }

    while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
  }

  return v6;
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:hashValue:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = -1LL << *(_BYTE *)(v2 + 32);
  unint64_t result = a2 & ~v4;
  if (((*(void *)(v2 + 64 + ((result >> 3) & 0xFFFFFFFFFFFFF8LL)) >> result) & 1) != 0)
  {
    uint64_t v6 = ~v4;
    do
    {
      if (*(void *)(*(void *)(v2 + 48) + 8 * result) == a1) {
        break;
      }
      unint64_t result = (result + 1) & v6;
    }

    while (((*(void *)(v2 + 64 + ((result >> 3) & 0xFFFFFFFFFFFFF8LL)) >> result) & 1) != 0);
  }

  return result;
}

unint64_t __RawDictionaryStorage.find<A>(_:hashValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = v3;
  uint64_t v9 = -1LL << *(_BYTE *)(v3 + 32);
  unint64_t v11 = v10 & ~v9;
  uint64_t v20 = v3 + 64;
  if (((*(void *)(v3 + 64 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) != 0)
  {
    uint64_t v19 = ~v9;
    uint64_t v12 = *(void *)(v5 + 8);
    uint64_t v13 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 8);
    uint64_t v14 = *(void *)(v6 + 72);
    uint64_t v15 = v6;
    uint64_t v16 = *(void (**)(char *, unint64_t, uint64_t))(v6 + 16);
    do
    {
      v16(v8, *(void *)(v22 + 48) + v14 * v11, a3);
      char v17 = v13(v8, v21, a3, v12);
      (*(void (**)(char *, uint64_t))(v15 + 8))(v8, a3);
      if ((v17 & 1) != 0) {
        break;
      }
      unint64_t v11 = (v11 + 1) & v19;
    }

    while (((*(void *)(v20 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) != 0);
  }

  return v11;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.idealBucket(forHashValue:)(Swift::Int forHashValue)
{
  return (Swift::_HashTable::Bucket)(v1 & forHashValue);
}

Swift::_HashTable::Bucket __swiftcall _HashTable.bucket(wrappedAfter:)(Swift::_HashTable::Bucket wrappedAfter)
{
  return (Swift::_HashTable::Bucket)((wrappedAfter.offset + 1) & v1);
}

void _DictionaryStorage.deinit()
{
  if (v0[2] < 1) {
    return;
  }
  uint64_t v1 = *v0;
  uint64_t v2 = *(void *)(*v0 + 176);
  uint64_t v3 = *(void *)(v2 - 8);
  if ((*(_BYTE *)(v3 + 82) & 1) == 0) {
    goto LABEL_3;
  }
  int64_t v6 = 0LL;
  uint64_t v7 = v0 + 8;
  uint64_t v8 = v0[6];
  uint64_t v9 = 1LL << *((_BYTE *)v0 + 32);
  uint64_t v10 = -1LL;
  if (v9 < 64) {
    uint64_t v10 = ~(-1LL << v9);
  }
  unint64_t v11 = v10 & v0[8];
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v6 << 6);
      goto LABEL_10;
    }

    BOOL v15 = __OFADD__(v6++, 1LL);
    if (v15) {
      goto LABEL_40;
    }
    if (v6 >= v12) {
      goto LABEL_3;
    }
    unint64_t v16 = v7[v6];
    if (!v16) {
      break;
    }
LABEL_21:
    unint64_t v11 = (v16 - 1) & v16;
    unint64_t v14 = __clz(__rbit64(v16)) + (v6 << 6);
LABEL_10:
    swift_arrayDestroy(v8 + *(void *)(v3 + 72) * v14, 1LL, v2);
  }

  int64_t v17 = v6 + 1;
  if (v6 + 1 >= v12) {
    goto LABEL_3;
  }
  unint64_t v16 = v7[v17];
  if (v16)
  {
    ++v6;
    goto LABEL_21;
  }

  while (1)
  {
    int64_t v6 = v17 + 1;
    if (__OFADD__(v17, 1LL))
    {
      __break(1u);
      goto LABEL_39;
    }

    if (v6 >= v12) {
      break;
    }
    unint64_t v16 = v7[v6];
    ++v17;
    if (v16) {
      goto LABEL_21;
    }
  }

uint64_t _DictionaryStorage._values.getter()
{
  return *(void *)(v0 + 56);
}

void _DictionaryStorage.__deallocating_deinit()
{
}

void @objc _DictionaryStorage.init(objects:forKeys:count:)()
{
}

  ;
}

uint64_t @objc _DictionaryStorage.count.getter()
{
  return _ContiguousArrayStorage.count.getter();
}

void *_DictionaryStorage.keyEnumerator()()
{
  uint64_t v1 = type metadata accessor for _SwiftDictionaryNSEnumerator( 0LL,  *(void *)(*v0 + 176),  *(void *)(*v0 + 184),  *(void *)(*v0 + 192));
  uint64_t v2 = swift_allocObject(v1, 0x30uLL, 7uLL);
  v2[2] = v0;
  v2[3] = 0LL;
  uint64_t v3 = -1LL << *((_BYTE *)v0 + 32);
  v2[4] = _HashTable.startBucket.getter(v0 + 8, ~v3);
  v2[5] = -v3;
  swift_retain(v0, v4, v5, v6);
  return v2;
}

void *@objc _DictionaryStorage.keyEnumerator()()
{
  return _DictionaryStorage.keyEnumerator()();
}

uint64_t _DictionaryStorage.countByEnumerating(with:objects:count:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *(uint64_t **)(*(void *)v2 + 176LL);
  uint64_t v6 = *(v5 - 1);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v43 = (id *)((char *)&v37 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  int64_t v12 = (id *)((char *)&v37 - v11);
  uint64_t v13 = v2 + 64;
  uint64_t v14 = -1LL << *(_BYTE *)(v2 + 32);
  uint64_t v15 = *(void *)v9;
  __int128 v16 = *(_OWORD *)(v9 + 32);
  __int128 v45 = *(_OWORD *)(v9 + 48);
  __int128 v46 = v16;
  uint64_t v49 = v10;
  if (!v15)
  {
    unint64_t v33 = _HashTable.startBucket.getter((unint64_t *)(v2 + 64), ~v14);
    if ((v33 & 0x8000000000000000LL) != 0) {
      goto LABEL_39;
    }
    unint64_t v19 = v33;
    int64_t v17 = &_fastEnumerationStorageMutationsTarget;
    uint64_t v15 = 1LL;
    uint64_t v18 = a2;
    uint64_t v10 = v49;
    if (a2) {
      goto LABEL_3;
    }
    return 0LL;
  }

  uint64_t v18 = a1[1];
  int64_t v17 = (Swift::UInt *)a1[2];
  unint64_t v19 = a1[3];
  if (!a2) {
    return 0LL;
  }
LABEL_3:
  if ((v19 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  uint64_t v48 = a2;
  uint64_t v20 = -v14;
  if (v19 + v14 && ((uint64_t)v19 >= v20 || ((*(void *)(v13 + ((v19 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v19) & 1) == 0)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid fast enumeration state",  30LL,  2,  "Swift/DictionaryStorage.swift",  29LL,  2,  0x167uLL,  0);
  }
  if (v10 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v44 = a1;
  if (!v10)
  {
    uint64_t v21 = 0LL;
    goto LABEL_35;
  }

  uint64_t v40 = v18;
  uint64_t v41 = v17;
  uint64_t v42 = v15;
  uint64_t v21 = 0LL;
  unint64_t v47 = (unint64_t)(63 - v14) >> 6;
  uint64_t v38 = v2 + 88;
  unint64_t v39 = v47 - 3;
  do
  {
    if (v19 == v20)
    {
      unint64_t v19 = v20;
      goto LABEL_34;
    }

    (*(void (**)(id *, unint64_t, uint64_t *))(v6 + 16))( v12,  *(void *)(v2 + 48) + *(void *)(v6 + 72) * v19,  v5);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v5, v5))
    {
      if (v7 != 8) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
      unint64_t v26 = *v12;
      swift_unknownObjectRetain(*v12, v23, v24, v25);
      (*(void (**)(id *, uint64_t *))(v6 + 8))(v12, v5);
    }

    else
    {
      uint64_t v30 = v43;
      (*(void (**)(id *, id *, uint64_t *))(v6 + 32))(v43, v12, v5);
      unint64_t v26 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v30, v5, v31, v32);
    }

    if (v21 == 0x1000000000000000LL)
    {
      __break(1u);
LABEL_39:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }

    *(void *)(v48 + 8 * v21) = v26;
    swift_unknownObjectRelease(v26);
    unint64_t v27 = v19 >> 6;
    if ((*(void *)(v13 + 8 * (v19 >> 6)) & (-2LL << v19)) != 0)
    {
      unint64_t v19 = __clz(__rbit64(*(void *)(v13 + 8 * (v19 >> 6)) & (-2LL << v19))) | v19 & 0xFFFFFFFFFFFFFFC0LL;
      uint64_t v22 = v49;
      goto LABEL_11;
    }

    unint64_t v28 = v27 + 1;
    unint64_t v19 = v20;
    uint64_t v22 = v49;
    if (v27 + 1 < v47)
    {
      unint64_t v29 = *(void *)(v13 + 8 * v28);
      if (v29) {
        goto LABEL_20;
      }
      unint64_t v28 = v27 + 2;
      unint64_t v19 = v20;
      if (v27 + 2 < v47)
      {
        unint64_t v29 = *(void *)(v13 + 8 * v28);
        if (v29)
        {
LABEL_20:
          unint64_t v19 = __clz(__rbit64(v29)) + (v28 << 6);
          goto LABEL_11;
        }

        while (v39 != v27)
        {
          unint64_t v29 = *(void *)(v38 + 8 * v27++);
          if (v29)
          {
            unint64_t v28 = v27 + 2;
            goto LABEL_20;
          }
        }

        unint64_t v19 = v20;
      }
    }

uint64_t @objc _DictionaryStorage.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, char *, uint64_t))_DictionaryStorage.countByEnumerating(with:objects:count:));
}

char *_DictionaryStorage.object(forKey:)(void *a1)
{
  uint64_t v3 = *v1;
  unint64_t v26 = *(uint64_t **)(*v1 + 184LL);
  uint64_t v25 = *(v26 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v5 = (id *)((char *)&v25 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v6 = *(char **)(v3 + 176);
  uint64_t v9 = type metadata accessor for Optional(0LL, (uint64_t)v6, v7, v8);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v25 - v12;
  uint64_t v14 = *((void *)v6 - 1);
  MEMORY[0x1895F8858](v11);
  __int128 v16 = (char *)&v25 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  _conditionallyBridgeFromObjectiveC<A>(_:_:)(a1, v6, v17, v13);
  if ((*(unsigned int (**)(char *, uint64_t, char *))(v14 + 48))(v13, 1LL, v6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, v9);
    return 0LL;
  }

  (*(void (**)(char *, char *, char *))(v14 + 32))(v16, v13, v6);
  unint64_t v18 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v16, (uint64_t)v6, *(void *)(v3 + 192));
  char v20 = v19;
  (*(void (**)(char *, char *))(v14 + 8))(v16, v6);
  if ((v20 & 1) == 0) {
    return 0LL;
  }
  uint64_t v22 = v25;
  uint64_t v21 = v26;
  (*(void (**)(id *, unint64_t, uint64_t *))(v25 + 16))(v5, v1[7] + *(void *)(v25 + 72) * v18, v26);
  uint64_t v23 = _bridgeAnythingToObjectiveC<A>(_:)(v5, v21);
  (*(void (**)(id *, uint64_t *))(v22 + 8))(v5, v21);
  return v23;
}

id @objc _DictionaryStorage.object(forKey:)(unint64_t *a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDeferredNSDictionary.object(forKey:)(a1, a2, a3, (char *)_DictionaryStorage.object(forKey:));
}

void _DictionaryStorage.getObjects(_:andKeys:count:)(uint64_t a1, uint64_t a2)
{
  uint64_t v131 = a2;
  uint64_t v132 = a1;
  uint64_t v3 = *(uint64_t **)(*(void *)v2 + 184LL);
  uint64_t v139 = *(v3 - 1);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v126 = (id *)((char *)&v122 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v6 = MEMORY[0x1895F8858](v4);
  uint64_t v8 = (id *)((char *)&v122 - v7);
  uint64_t v130 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v6);
  id v135 = (id *)((char *)&v122 - v11);
  uint64_t v13 = *(uint64_t **)(v12 + 176);
  uint64_t v138 = *(v13 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  uint64_t v128 = (id *)((char *)&v122 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v124 = (id *)((char *)&v122 - v17);
  unint64_t v129 = v18;
  MEMORY[0x1895F8858](v16);
  uint64_t v134 = (id *)((char *)&v122 - v19);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, (uint64_t)v13, (uint64_t)v3, "key value ", 0LL);
  uint64_t v23 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v21, v22);
  uint64_t v136 = *(void *)(v23 - 8);
  uint64_t v137 = v23;
  uint64_t v24 = MEMORY[0x1895F8858](v23);
  unint64_t v26 = (char *)&v122 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  unint64_t v29 = (char *)&v122 - v28;
  uint64_t v30 = MEMORY[0x1895F8858](v27);
  uint64_t v127 = (char *)&v122 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v122 - v33;
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  uint64_t v37 = (char *)&v122 - v36;
  MEMORY[0x1895F8858](v35);
  uint64_t v43 = (char *)&v122 - v42;
  if (v41)
  {
    uint64_t v133 = v2;
    if (v131)
    {
      uint64_t v123 = v8;
      uint64_t v44 = *(void *)(v2 + 64);
      uint64_t v125 = v2 + 64;
      uint64_t v45 = 1LL << *(_BYTE *)(v2 + 32);
      uint64_t v46 = -1LL;
      if (v45 < 64) {
        uint64_t v46 = ~(-1LL << v45);
      }
      unint64_t v47 = v46 & v44;
      unint64_t v48 = (unint64_t)(v45 + 63) >> 6;
      uint64_t v126 = (id *)v48;
      if (v132)
      {
        uint64_t v122 = (id *)(v48 - 1);
        uint64_t v127 = v41;
        swift_retain((unint64_t *)v2, v38, v39, v40);
        uint64_t v49 = 0LL;
        uint64_t v128 = 0LL;
        while (!v47)
        {
          uint64_t v68 = (id *)((char *)v128 + 1);
          if (__OFADD__(v128, 1LL)) {
            goto LABEL_98;
          }
          if ((uint64_t)v68 >= (uint64_t)v126)
          {
            unint64_t v47 = 0LL;
            uint64_t v53 = 1LL;
          }

          else
          {
            unint64_t v69 = *(void *)(v125 + 8LL * (void)v68);
            if (v69) {
              goto LABEL_24;
            }
            uint64_t v70 = (char *)v128 + 2;
            if ((uint64_t)((char *)v128 + 2) >= (uint64_t)v126)
            {
              unint64_t v47 = 0LL;
              uint64_t v53 = 1LL;
              uint64_t v128 = (id *)((char *)v128 + 1);
            }

            else
            {
              unint64_t v69 = *(void *)(v125 + 8LL * (void)v70);
              if (v69)
              {
                uint64_t v68 = (id *)((char *)v128 + 2);
LABEL_24:
                unint64_t v47 = (v69 - 1) & v69;
                unint64_t v51 = __clz(__rbit64(v69)) + ((void)v68 << 6);
                uint64_t v128 = v68;
LABEL_10:
                uint64_t v52 = v133;
                (*(void (**)(char *, unint64_t, uint64_t *))(v138 + 16))( v37,  *(void *)(v133 + 48) + *(void *)(v138 + 72) * v51,  v13);
                (*(void (**)(char *, unint64_t, uint64_t *))(v139 + 16))( &v37[*((int *)TupleTypeMetadata2 + 12)],  *(void *)(v52 + 56) + *(void *)(v139 + 72) * v51,  v3);
                uint64_t v53 = 0LL;
                goto LABEL_11;
              }

              while (1)
              {
                uint64_t v68 = (id *)(v70 + 1);
                if (__OFADD__(v70, 1LL)) {
                  goto LABEL_102;
                }
                unint64_t v69 = *(void *)(v125 + 8LL * (void)v68);
                ++v70;
                if (v69) {
                  goto LABEL_24;
                }
              }

              unint64_t v47 = 0LL;
              uint64_t v53 = 1LL;
              uint64_t v128 = v122;
            }
          }

uint64_t _NativeDictionary.makeIterator()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1LL;
  uint64_t v3 = -1LL << *(_BYTE *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t result = a1 + 64;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1LL << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0LL;
  a2[4] = v2 & v5;
  return result;
}

uint64_t @objc _DictionaryStorage.getObjects(_:andKeys:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)( a1,  a2,  a3,  a4,  a5,  (void (*)(uint64_t, char *, uint64_t))_DictionaryStorage.getObjects(_:andKeys:count:));
}

uint64_t @objc _SwiftDeferredNSDictionary.getObjects(_:andKeys:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, void (*a6)(uint64_t, char *, uint64_t))
{
  return swift_release((uint64_t)a1);
}

int64x2_t *specialized static _DictionaryStorage.copy(original:)(uint64_t a1)
{
  __int8 v1 = *(_BYTE *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1LL << v1;
  unint64_t v5 = (unint64_t)((1LL << v1) + 63) >> 6;
  uint64_t v6 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, Any>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16LL << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (32LL << v1), 7uLL);
  v7[1].i64[0] = 0LL;
  double v8 = (double)(1LL << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v5, v10);
  }
  else {
    v10->i64[0] = -1LL << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;
  __int8 v1 = *(_BYTE *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1LL << v1;
  unint64_t v5 = (unint64_t)((1LL << v1) + 63) >> 6;
  uint64_t v6 = canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, Any>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((40LL << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (32LL << v1), 7uLL);
  v7[1].i64[0] = 0LL;
  double v8 = (double)(1LL << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 40 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v5, v10);
  }
  else {
    v10->i64[0] = -1LL << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;
  __int8 v1 = *(_BYTE *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1LL << v1;
  unint64_t v5 = (unint64_t)((1LL << v1) + 63) >> 6;
  uint64_t v6 = canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, String>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((40LL << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (16LL << v1), 7uLL);
  v7[1].i64[0] = 0LL;
  double v8 = (double)(1LL << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 40 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v5, v10);
  }
  else {
    v10->i64[0] = -1LL << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;
  __int8 v1 = *(_BYTE *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1LL << v1;
  unint64_t v5 = (unint64_t)((1LL << v1) + 63) >> 6;
  uint64_t v6 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, AnyHashable>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16LL << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (40LL << v1), 7uLL);
  v7[1].i64[0] = 0LL;
  double v8 = (double)(1LL << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v5, v10);
  }
  else {
    v10->i64[0] = -1LL << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;
  __int8 v1 = *(_BYTE *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1LL << v1;
  unint64_t v5 = (unint64_t)((1LL << v1) + 63) >> 6;
  uint64_t v6 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, String>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16LL << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (16LL << v1), 7uLL);
  v7[1].i64[0] = 0LL;
  double v8 = (double)(1LL << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v5, v10);
  }
  else {
    v10->i64[0] = -1LL << v4;
  }
  return v9;
}

{
  __int8 v1;
  __int32 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  double v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;
  __int8 v1 = *(_BYTE *)(a1 + 32);
  __int32 v2 = *(_DWORD *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = 1LL << v1;
  unint64_t v5 = (unint64_t)((1LL << v1) + 63) >> 6;
  uint64_t v6 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, Int>();
  uint64_t v7 = (int64x2_t *)swift_allocObject(v6, (((16LL << v1) + 8 * v5 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (8LL << v1), 7uLL);
  v7[1].i64[0] = 0LL;
  double v8 = (double)(1LL << v1) * 0.75;
  if ((~*(void *)&v8 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v8 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v8 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v9 = v7;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = (uint64_t)&v7[4].i64[v5];
  v7[1].i64[1] = (uint64_t)v8;
  v7[2].i8[0] = v1;
  v7[2].i8[1] = 0;
  v7[2].i16[1] = 0;
  v7[2].i32[1] = v2;
  v7[2].i64[1] = v3;
  v7[3].i64[0] = v11;
  v7[3].i64[1] = v11 + 16 * v4;
  if (v4 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v5, v10);
  }
  else {
    v10->i64[0] = -1LL << v4;
  }
  return v9;
}

int64x2_t *specialized static _DictionaryStorage.copy(original:)( uint64_t a1, uint64_t (*a2)(void))
{
  __int8 v2 = *(_BYTE *)(a1 + 32);
  __int32 v3 = *(_DWORD *)(a1 + 36);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = 1LL << v2;
  unint64_t v6 = (unint64_t)((1LL << v2) + 63) >> 6;
  uint64_t v7 = a2(0LL);
  double v8 = (int64x2_t *)swift_allocObject(v7, (((8LL << v2) + 8 * v6 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (8LL << v2), 7uLL);
  v8[1].i64[0] = 0LL;
  double v9 = (double)(1LL << v2) * 0.75;
  if ((~*(void *)&v9 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v9 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v9 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v10 = v8;
  uint64_t v11 = v8 + 4;
  uint64_t v12 = (uint64_t)&v8[4].i64[v6];
  v8[1].i64[1] = (uint64_t)v9;
  v8[2].i8[0] = v2;
  v8[2].i8[1] = 0;
  v8[2].i16[1] = 0;
  v8[2].i32[1] = v3;
  v8[2].i64[1] = v4;
  v8[3].i64[0] = v12;
  v8[3].i64[1] = v12 + 8 * v5;
  if (v5 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v6, v11);
  }
  else {
    v11->i64[0] = -1LL << v5;
  }
  return v10;
}

int64x2_t *specialized static _DictionaryStorage.copy(original:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int8 v4 = *(_BYTE *)(a1 + 32);
  __int32 v5 = *(_DWORD *)(a1 + 36);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = 1LL << v4;
  unint64_t v8 = (unint64_t)((1LL << v4) + 63) >> 6;
  uint64_t v9 = type metadata accessor for _DictionaryStorage(0LL, a2, (uint64_t)&unk_189B88E40, a3);
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = v11 + 8 * v8;
  uint64_t v13 = (*(void *)(v10 + 72) << v4) + 7LL;
  uint64_t v14 = (int64x2_t *)swift_allocObject(v9, ((v13 + ((v12 + 64) & ~v11)) & 0xFFFFFFFFFFFFFFF8LL) + (16LL << v4), v11 | 7);
  v14[1].i64[0] = 0LL;
  double v15 = (double)(1LL << v4) * 0.75;
  if ((~*(void *)&v15 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v15 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v15 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v16 = v14;
  v14[1].i64[1] = (uint64_t)v15;
  uint64_t v17 = v14 + 4;
  uint64_t v18 = ((unint64_t)v14[4].u64 + v12) & ~v11;
  v14[2].i8[0] = v4;
  v14[2].i8[1] = 0;
  v14[2].i16[1] = 0;
  v14[2].i32[1] = v5;
  v14[2].i64[1] = v6;
  v14[3].i64[0] = v18;
  v14[3].i64[1] = (v13 + v18) & 0xFFFFFFFFFFFFFFF8LL;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v17);
  }
  else {
    v17->i64[0] = -1LL << v7;
  }
  return v16;
}

int64x2_t *static _DictionaryStorage.copy(original:)(uint64_t a1)
{
  __int8 v2 = *(_BYTE *)(a1 + 32);
  __int32 v3 = *(_DWORD *)(a1 + 36);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = 1LL << v2;
  uint64_t v6 = *(void *)(*(void *)(v1 + 176) - 8LL);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = v7 + 8 * ((unint64_t)((1LL << v2) + 63) >> 6);
  uint64_t v9 = *(void *)(*(void *)(v1 + 184) - 8LL);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = (*(void *)(v6 + 72) << v2) + v10;
  uint64_t v12 = (int64x2_t *)swift_allocObject( v1,  ((((v8 + 64) & ~v7) + v11) & ~v10) + (*(void *)(v9 + 72) << v2),  v7 | v10 | 7);
  v12[1].i64[0] = 0LL;
  double v13 = (double)(1LL << v2) * 0.75;
  if ((~*(void *)&v13 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v13 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v13 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  uint64_t v14 = v12;
  v12[1].i64[1] = (uint64_t)v13;
  double v15 = v12 + 4;
  uint64_t v16 = ((unint64_t)v12[4].u64 + v8) & ~v7;
  v12[2].i8[0] = v2;
  v12[2].i8[1] = 0;
  v12[2].i16[1] = 0;
  v12[2].i32[1] = v3;
  v12[2].i64[1] = v4;
  v12[3].i64[0] = v16;
  v12[3].i64[1] = (v16 + v11) & ~v10;
  if (v5 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)((1LL << v2) + 63) >> 6, v15);
  }
  else {
    v15->i64[0] = -1LL << v5;
  }
  return v14;
}

int64x2_t *static _DictionaryStorage.allocate(scale:age:seed:)(char a1, uint64_t a2, int64x2_t *a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v8 = (int64x2_t *)a1;
  uint64_t v9 = 1LL << a1;
  uint64_t v10 = *(void *)(v4 + 184);
  uint64_t v11 = *(void *)(*(void *)(v4 + 176) - 8LL);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  unint64_t v24 = (unint64_t)((1LL << a1) + 63) >> 6;
  uint64_t v13 = v12 + 8 * v24;
  uint64_t v14 = *(void *)(v10 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (*(void *)(v11 + 72) << a1) + v15;
  uint64_t v17 = (int64x2_t *)swift_allocObject( v5,  ((((v13 + 64) & ~v12) + v16) & ~v15) + (*(void *)(v14 + 72) << a1),  v12 | v15 | 7);
  uint64_t v18 = ((unint64_t)v17[4].u64 + v13) & ~v12;
  v17[1].i64[0] = 0LL;
  swift_retain((unint64_t *)v17, v19, v20, v21);
  v17[1].i64[1] = specialized static _HashTable.capacity(forScale:)(a1);
  v17[2].i8[0] = a1;
  v17[2].i8[1] = 0;
  v17[2].i16[1] = 0;
  if ((a2 & 0x100000000LL) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v17);
  }
  v17[2].i32[1] = a2;
  if ((_BYTE)qword_18C487060) {
    uint64_t v22 = v8;
  }
  else {
    uint64_t v22 = v17;
  }
  if ((a4 & 1) == 0) {
    uint64_t v22 = a3;
  }
  v17[2].i64[1] = (uint64_t)v22;
  v17[3].i64[0] = v18;
  v17[3].i64[1] = (v18 + v16) & ~v15;
  if (v9 > 63)
  {
    swift_release((uint64_t)v17);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v24, v17 + 4);
  }

  else
  {
    v17[4].i64[0] = -1LL << v9;
    swift_release((uint64_t)v17);
  }

  return v17;
}

uint64_t static _DictionaryStorage.resize(original:capacity:move:)(uint64_t a1, uint64_t a2)
{
  return specialized static _DictionaryStorage.resize(original:capacity:move:)(a2, v2[22], v2[23], v2[24]);
}

uint64_t specialized static _DictionaryStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }

  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1LL << v6;
  unint64_t v8 = (unint64_t)((1LL << v6) + 63) >> 6;
  uint64_t v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, AnyHashable>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((40LL << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (40LL << v6), 7uLL);
  v10[1].i64[0] = 0LL;
  double v11 = (double)(1LL << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v10);
  if ((_BYTE)qword_18C487060) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  uint64_t v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 40 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v13);
  }
  else {
    v13->i64[0] = -1LL << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }

  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1LL << v6;
  unint64_t v8 = (unint64_t)((1LL << v6) + 63) >> 6;
  uint64_t v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, Any>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16LL << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (32LL << v6), 7uLL);
  v10[1].i64[0] = 0LL;
  double v11 = (double)(1LL << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v10);
  if ((_BYTE)qword_18C487060) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  uint64_t v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v13);
  }
  else {
    v13->i64[0] = -1LL << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }

  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1LL << v6;
  unint64_t v8 = (unint64_t)((1LL << v6) + 63) >> 6;
  uint64_t v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, Any>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((40LL << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (32LL << v6), 7uLL);
  v10[1].i64[0] = 0LL;
  double v11 = (double)(1LL << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v10);
  if ((_BYTE)qword_18C487060) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  uint64_t v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 40 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v13);
  }
  else {
    v13->i64[0] = -1LL << v7;
  }
  return (uint64_t)v12;
}

uint64_t specialized static _DictionaryStorage.allocate(capacity:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result <= 1) {
    uint64_t v3 = 1LL;
  }
  else {
    uint64_t v3 = result;
  }
  double v4 = ceil((double)v3 / 0.75);
  if ((~*(void *)&v4 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v4 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v4 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v5 = __OFADD__(v3, 1LL);
  uint64_t v6 = v3 + 1;
  if (v5)
  {
    __break(1u);
    return result;
  }

  char v8 = 64 - __clz(v6 - 1);
  unsigned __int8 v9 = (unint64_t)v6 <= 2 ? 1 : v8;
  uint64_t v10 = 1LL << v9;
  unint64_t v11 = (unint64_t)((1LL << v9) + 63) >> 6;
  uint64_t v12 = type metadata accessor for _DictionaryStorage(0LL, a2, (uint64_t)&unk_189B88E40, a3);
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = v14 + 8 * v11;
  uint64_t v16 = (*(void *)(v13 + 72) << v9) + 7LL;
  uint64_t v17 = (int64x2_t *)swift_allocObject( v12,  ((v16 + ((v15 + 64) & ~v14)) & 0xFFFFFFFFFFFFFFF8LL) + (16LL << v9),  v14 | 7);
  v17[1].i64[0] = 0LL;
  double v18 = (double)(1LL << v9) * 0.75;
  if ((~*(void *)&v18 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v18 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v18 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v19 = (uint64_t *)v17;
  uint64_t v20 = v17 + 4;
  uint64_t v21 = ((unint64_t)v17[4].u64 + v15) & ~v14;
  v17[1].i64[1] = (uint64_t)v18;
  v17[2].i8[0] = v9;
  v17[2].i8[1] = 0;
  v17[2].i16[1] = 0;
  v17[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v17);
  if ((_BYTE)qword_18C487060) {
    uint64_t v22 = (uint64_t *)v9;
  }
  else {
    uint64_t v22 = v19;
  }
  unint64_t v19[5] = (uint64_t)v22;
  v19[6] = v21;
  v19[7] = (v16 + v21) & 0xFFFFFFFFFFFFFFF8LL;
  if (v10 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v11, v20);
  }
  else {
    v20->i64[0] = -1LL << v10;
  }
  return (uint64_t)v19;
}

uint64_t static _DictionaryStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v2 = 1LL;
  }
  else {
    uint64_t v2 = result;
  }
  double v3 = ceil((double)v2 / 0.75);
  if ((~*(void *)&v3 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v3 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v3 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v4 = __OFADD__(v2, 1LL);
  uint64_t v5 = v2 + 1;
  if (v4)
  {
    __break(1u);
    return result;
  }

  char v6 = 64 - __clz(v5 - 1);
  unsigned __int8 v7 = (unint64_t)v5 <= 2 ? 1 : v6;
  uint64_t v8 = 1LL << v7;
  uint64_t v9 = *(void *)(*(void *)(v1 + 176) - 8LL);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = v10 + 8 * ((unint64_t)((1LL << v7) + 63) >> 6);
  uint64_t v12 = *(void *)(*(void *)(v1 + 184) - 8LL);
  uint64_t v13 = *(unsigned __int8 *)(v12 + 80);
  uint64_t v14 = (*(void *)(v9 + 72) << v7) + v13;
  uint64_t v15 = (int64x2_t *)swift_allocObject( v1,  ((((v11 + 64) & ~v10) + v14) & ~v13) + (*(void *)(v12 + 72) << v7),  v10 | v13 | 7);
  v15[1].i64[0] = 0LL;
  double v16 = (double)(1LL << v7) * 0.75;
  if ((~*(void *)&v16 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v16 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v16 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v17 = (uint64_t *)v15;
  double v18 = v15 + 4;
  uint64_t v19 = ((unint64_t)v15[4].u64 + v11) & ~v10;
  v15[1].i64[1] = (uint64_t)v16;
  v15[2].i8[0] = v7;
  v15[2].i8[1] = 0;
  v15[2].i16[1] = 0;
  v15[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v15);
  if ((_BYTE)qword_18C487060) {
    uint64_t v20 = (uint64_t *)v7;
  }
  else {
    uint64_t v20 = v17;
  }
  uint64_t v17[5] = (uint64_t)v20;
  v17[6] = v19;
  v17[7] = (v19 + v14) & ~v13;
  if (v8 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)((1LL << v7) + 63) >> 6, v18);
  }
  else {
    v18->i64[0] = -1LL << v8;
  }
  return (uint64_t)v17;
}

uint64_t static _DictionaryStorage.convert(_:capacity:)(uint64_t a1, uint64_t a2)
{
  return static _DictionaryStorage.convert(_:capacity:)( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))static _DictionaryStorage.allocate(scale:age:seed:));
}

uint64_t static Int.bitWidth.getter()
{
  return 64LL;
}

uint64_t Int16.init(_builtinIntegerLiteral:)(unsigned __int16 *a1, unint64_t a2)
{
  if (a2 >> 8 <= 0x10) {
    return *a1;
  }
  else {
    return 0LL;
  }
}

uint64_t ObjectIdentifier.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0LL, a1);
}

Swift::Void __swiftcall _HashTable.clear()()
{
  if (v1 + 1 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v1 + 64) >> 6, v0);
  }
  else {
    v0->i64[0] = -1LL << (v1 + 1);
  }
}

uint64_t (*Dictionary._Variant.object.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Dictionary._Variant.guaranteedNative.getter()
{
  return 0LL;
}

__objc2_class **_NativeDictionary.init(_:capacity:)(void *a1, uint64_t a2, char *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10 = type metadata accessor for Optional(0LL, (uint64_t)a4, (uint64_t)a3, (uint64_t)a4);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v73 = (char *)&v61 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  double v16 = (uint64_t *)((char *)&v61 - v15);
  uint64_t v74 = *(a4 - 1);
  MEMORY[0x1895F8858](v14);
  double v18 = (char *)&v61 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = type metadata accessor for Optional(0LL, (uint64_t)a3, v19, v20);
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v24 = MEMORY[0x1895F8858](v23);
  uint64_t v30 = (char *)&v61 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (!a2)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptyDictionarySingleton;
  }

  uint64_t v67 = v26;
  uint64_t v68 = v28;
  uint64_t v65 = v10;
  uint64_t v66 = v25;
  uint64_t v62 = v27;
  uint64_t v63 = v24;
  unint64_t v69 = v16;
  uint64_t v64 = v11;
  type metadata accessor for _DictionaryStorage(0LL, (uint64_t)a3, (uint64_t)a4, a5);
  char v31 = specialized static _HashTable.scale(forCapacity:)(a2);
  unsigned int v32 = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)a1);
  LOBYTE(v76) = 0;
  uint64_t v33 = static _DictionaryStorage.allocate(scale:age:seed:)(v31, v32, 0LL, 1);
  uint64_t v76 = v33;
  uint64_t v34 = type metadata accessor for __CocoaDictionary.Iterator();
  uint64_t v38 = swift_allocObject(v34, 0xE8uLL, 7uLL);
  uint64_t v39 = 0LL;
  *((_OWORD *)v38 + 1) = 0u;
  uint64_t v71 = v38 + 2;
  *((_OWORD *)v38 + 5) = 0u;
  uint64_t v70 = v38 + 10;
  v38[27] = 0LL;
  uint64_t v40 = v38 + 27;
  *((_OWORD *)v38 + 2) = 0u;
  *((_OWORD *)v38 + 3) = 0u;
  *((_OWORD *)v38 + 4) = 0u;
  *((_OWORD *)v38 + 6) = 0u;
  *((_OWORD *)v38 + 7) = 0u;
  *((_OWORD *)v38 + 8) = 0u;
  *((_OWORD *)v38 + 9) = 0u;
  *((_OWORD *)v38 + 10) = 0u;
  *((_OWORD *)v38 + 11) = 0u;
  *((_OWORD *)v38 + 12) = 0u;
  v38[26] = a1;
  uint64_t v72 = (swift *)&unk_189B8D230;
  v38[28] = 0LL;
  while (1)
  {
    uint64_t v41 = (void *)v38[26];
    if (v39 != v38[28]) {
      goto LABEL_7;
    }
    id v42 = objc_msgSend((id)v38[26], sel_countByEnumeratingWithState_objects_count_, v71, v70, 16);
    v38[28] = v42;
    if (!v42) {
      break;
    }
    uint64_t v39 = 0LL;
    *uint64_t v40 = 0LL;
LABEL_7:
    uint64_t v43 = v38[3];
    if (!v43)
    {
      unint64_t v60 = 773LL;
      goto LABEL_29;
    }

    if ((unint64_t)(v39 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_26:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    uint64_t v44 = (void **)(v43 + 8 * v39);
    uint64_t v45 = a5;
    uint64_t v46 = *v44;
    *uint64_t v40 = v39 + 1;
    swift_unknownObjectRetain(v46, v35, v36, v37);
    unint64_t v47 = (swift *)objc_msgSend(v41, sel_objectForKey_, v46);
    if (!v47)
    {
      unint64_t v60 = 784LL;
LABEL_29:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v60,  0);
    }

    unint64_t v48 = v47;
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      uint64_t v75 = (swift *)v46;
      swift_dynamicCast(v30, (uint64_t *)&v75, v72, a3, 7uLL);
    }

    else
    {
      uint64_t v53 = v66;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v68 + 56))(v66, 1LL, 1LL, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v46, (uint64_t)a3, v53);
      swift_unknownObjectRelease(v46);
      uint64_t v54 = v62;
      uint64_t v55 = v53;
      uint64_t v56 = v63;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(v67 + 16))(v62, v55, v63);
      (*(void (**)(uint64_t *, uint64_t))(v67 + 8))(v66, v56);
      (*(void (**)(char *, uint64_t, char *))(v68 + 32))(v30, v54, a3);
    }

    a5 = v45;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
    unint64_t v50 = v73;
    if (isClassOrObjCExistentialType)
    {
      uint64_t v75 = v48;
      swift_dynamicCast(v18, (uint64_t *)&v75, (swift *)&unk_189B8D230, (const char *)a4, 7uLL);
    }

    else
    {
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v74 + 56))(v69, 1LL, 1LL, a4);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v48, (uint64_t)a4, v69);
      swift_unknownObjectRelease(v48);
      uint64_t v58 = v64;
      uint64_t v57 = v65;
      (*(void (**)(char *, uint64_t *, uint64_t))(v64 + 16))(v50, v69, v65);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v74 + 48))(v50, 1LL, a4) == 1) {
LABEL_30:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      (*(void (**)(uint64_t *, uint64_t))(v58 + 8))(v69, v57);
      (*(void (**)(char *, char *, uint64_t *))(v74 + 32))(v18, v50, a4);
    }

    uint64_t v33 = v76;
    unint64_t v51 = v76[1].u64[0];
    if (v76[1].i64[1] <= v51)
    {
      Swift::Int v52 = v51 + 1;
      type metadata accessor for _NativeDictionary(0LL, (uint64_t)a3, (uint64_t)a4, a5);
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v52, 1);
      uint64_t v33 = v76;
    }

    _NativeDictionary._unsafeInsertNew(key:value:)( (uint64_t)v30,  (uint64_t)v18,  v33,  (unint64_t)a3,  (uint64_t)a4,  a5);
    uint64_t v39 = *v40;
    if (*v40 < 0) {
      goto LABEL_23;
    }
  }

  v38[27] = -1LL;
LABEL_23:
  swift_release((uint64_t)v38);
  return (__objc2_class **)v33;
}

uint64_t _NativeDictionary.capacity.getter(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t _NativeDictionary.startIndex.getter(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 64);
  if (v1)
  {
    uint64_t v2 = 0LL;
    return __clz(__rbit64(v1)) + v2;
  }

  char v5 = *(_BYTE *)(a1 + 32);
  unsigned int v6 = v5 & 0x3F;
  uint64_t v3 = 1LL << v5;
  if (v6 < 7) {
    return v3;
  }
  unint64_t v1 = *(void *)(a1 + 72);
  if (v1)
  {
    uint64_t v2 = 64LL;
    return __clz(__rbit64(v1)) + v2;
  }

  if (v6 < 8) {
    return v3;
  }
  unint64_t v1 = *(void *)(a1 + 80);
  if (v1)
  {
    uint64_t v2 = 128LL;
    return __clz(__rbit64(v1)) + v2;
  }

  unint64_t v7 = (unint64_t)(v3 + 63) >> 6;
  if (v7 <= 3) {
    unint64_t v7 = 3LL;
  }
  unint64_t v8 = v7 - 3;
  uint64_t v9 = (unint64_t *)(a1 + 88);
  uint64_t v2 = 128LL;
  while (v8)
  {
    unint64_t v10 = *v9++;
    unint64_t v1 = v10;
    --v8;
    v2 += 64LL;
    if (v10) {
      return __clz(__rbit64(v1)) + v2;
    }
  }

  return v3;
}

uint64_t _NativeDictionary.endIndex.getter(uint64_t a1)
{
  return 1LL << *(_BYTE *)(a1 + 32);
}

Swift::Int _NativeDictionary.index(after:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a1;
  uint64_t v12 = *((void *)a5 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v36 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v16 & 1) == 0)
  {
    if ((v11 & 0x8000000000000000LL) == 0
      && -(-1LL << *(_BYTE *)(a4 + 32)) > v11
      && ((*(void *)(a4 + 64 + (((unint64_t)v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) != 0
      && *(_DWORD *)(a4 + 36) == (_DWORD)a2)
    {
      return _HashTable.occupiedBucket(after:)((Swift::_HashTable::Bucket)v11).offset;
    }

    unint64_t v35 = 281LL;
LABEL_21:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v35,  0);
  }

  if (v11 >= 0) {
    uint64_t v17 = v11 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v17 = v11;
  }
  outlined copy of [A : B].Index._Variant<A, B>(v11, a2, 1LL, v13);
  uint64_t v18 = type metadata accessor for __CocoaDictionary.Index.Storage();
  swift_bridgeObjectRetain(v11, v19, v20, v21);
  if (!swift_dynamicCastClass(v17, v18)) {
    goto LABEL_24;
  }
  id v37 = *(id *)(v17 + 16);
  if (!swift_dynamicCastClass(v17, v18)) {
    goto LABEL_24;
  }
  uint64_t v25 = *(void *)(v17 + 24);
  if (*(void *)(v25 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
  }
  uint64_t v36 = v12;
  uint64_t v26 = *(void **)(v25 + 8 * a2 + 24);
  swift_unknownObjectRetain(v26, v22, v23, v24);
  outlined consume of [A : B].Index._Variant<A, B>(v11, a2, 1);
  _forceBridgeFromObjectiveC<A>(_:_:)(v26, a5, v27, v15);
  swift_unknownObjectRelease(v26);
  __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, (uint64_t)a5, a7);
  char v29 = v28;
  (*(void (**)(char *, char *))(v36 + 8))(v15, a5);
  if ((v29 & 1) == 0)
  {
LABEL_25:
    unint64_t v35 = 303LL;
    goto LABEL_21;
  }

  if (!swift_dynamicCastClass(v17, v18)
    || (id v33 = v37, swift_unknownObjectRetain(v37, v30, v31, v32), !swift_dynamicCastClass(v17, v18)))
  {
LABEL_24:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if (*(void *)(*(void *)(v17 + 24) + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x1E8uLL,  0);
  }
  swift_unknownObjectRelease(v33);
  return v11;
}

unint64_t _NativeDictionary.index(forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)(a2 + 16)) {
    return 0LL;
  }
  unint64_t result = __RawDictionaryStorage.find<A>(_:)(a1, a3, a5);
  if ((v6 & 1) == 0) {
    return 0LL;
  }
  return result;
}

uint64_t _NativeDictionary.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a2 + 16)) {
    __RawDictionaryStorage.find<A>(_:)(a1, a3, a5);
  }
  else {
    char v5 = 0;
  }
  return v5 & 1;
}

uint64_t _NativeDictionary.lookup(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  if (*(void *)(a2 + 16) && (unint64_t v9 = __RawDictionaryStorage.find<A>(_:)(a1, a3, a5), (v10 & 1) != 0))
  {
    uint64_t v11 = *(void *)(a2 + 56);
    uint64_t v12 = *(void *)(a4 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v12 + 16))(a6, v11 + *(void *)(v12 + 72) * v9, a4);
    uint64_t v13 = 0LL;
  }

  else
  {
    uint64_t v12 = *(void *)(a4 - 8);
    uint64_t v13 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 56))(a6, v13, 1LL, a4);
}

uint64_t _NativeDictionary.lookup(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v16 = *((void *)a7 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v18 = (char *)&v35 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v19 & 1) != 0)
  {
    uint64_t v36 = a2;
    if (a3 >= 0) {
      uint64_t v21 = a3 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v21 = a3;
    }
    uint64_t v22 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a3, v23, v24, v25);
    if (swift_dynamicCastClass(v21, v22))
    {
      if (swift_dynamicCastClass(v21, v22))
      {
        uint64_t v29 = *(void *)(v21 + 24);
        if (*(void *)(v29 + 16) <= a4) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        uint64_t v30 = *(void **)(v29 + 8 * a4 + 24);
        swift_unknownObjectRetain(v30, v26, v27, v28);
        outlined consume of [A : B].Index._Variant<A, B>(a3, a4, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v30, a7, v31, v18);
        swift_unknownObjectRelease(v30);
        a3 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v18, (uint64_t)a7, a9);
        char v33 = v32;
        (*(void (**)(char *, char *))(v16 + 8))(v18, a7);
        if ((v33 & 1) != 0)
        {
          a2 = v36;
          goto LABEL_17;
        }

uint64_t _NativeDictionary.key(at:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X6>, uint64_t a6@<X8>)
{
  uint64_t v10 = a1;
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v15 & 1) != 0)
  {
    if (v10 >= 0) {
      uint64_t v17 = v10 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v17 = v10;
    }
    uint64_t v18 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(v10, v19, v20, v21);
    if (swift_dynamicCastClass(v17, v18))
    {
      if (swift_dynamicCastClass(v17, v18))
      {
        uint64_t v25 = *(void *)(v17 + 24);
        if (*(void *)(v25 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        uint64_t v26 = *(void **)(v25 + 8 * a2 + 24);
        swift_unknownObjectRetain(v26, v22, v23, v24);
        outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v26, a4, v27, v14);
        swift_unknownObjectRelease(v26);
        uint64_t v10 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, (uint64_t)a4, a5);
        char v29 = v28;
        (*(void (**)(char *, char *))(v12 + 8))(v14, a4);
        if ((v29 & 1) != 0) {
          return (*(uint64_t (**)(uint64_t, uint64_t, char *))(v12 + 16))( a6,  *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10,  a4);
        }
LABEL_19:
        unint64_t v16 = 303LL;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v16,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if (v10 < 0
    || 1LL << *(_BYTE *)(a3 + 32) <= v10
    || ((*(void *)(a3 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> v10) & 1) == 0
    || *(_DWORD *)(a3 + 36) != (_DWORD)a2)
  {
    unint64_t v16 = 281LL;
    goto LABEL_7;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(v12 + 16))( a6,  *(void *)(a3 + 48) + *(void *)(v12 + 72) * v10,  a4);
}

uint64_t _NativeDictionary.value(at:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v13 = *((void *)a4 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](a7);
  unint64_t v16 = (char *)&v33 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v17 & 1) != 0)
  {
    uint64_t v34 = v14;
    if (a1 >= 0) {
      uint64_t v19 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v19 = a1;
    }
    uint64_t v20 = type metadata accessor for __CocoaDictionary.Index.Storage();
    swift_bridgeObjectRetain(a1, v21, v22, v23);
    if (swift_dynamicCastClass(v19, v20))
    {
      if (swift_dynamicCastClass(v19, v20))
      {
        uint64_t v27 = *(void *)(v19 + 24);
        if (*(void *)(v27 + 16) <= a2) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
        }
        char v28 = *(void **)(v27 + 8 * a2 + 24);
        swift_unknownObjectRetain(v28, v24, v25, v26);
        outlined consume of [A : B].Index._Variant<A, B>(a1, a2, 1);
        _forceBridgeFromObjectiveC<A>(_:_:)(v28, a4, v29, v16);
        swift_unknownObjectRelease(v28);
        a1 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v16, (uint64_t)a4, a6);
        char v31 = v30;
        (*(void (**)(char *, char *))(v13 + 8))(v16, a4);
        if ((v31 & 1) != 0)
        {
          uint64_t v14 = v34;
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL))( v14,  *(void *)(a3 + 56) + *(void *)(*(void *)(a5 - 8) + 72LL) * a1,  a5);
        }

uint64_t Dictionary.subscript.getter@<X0>( id *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, char *a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16))
    {
      unint64_t v15 = __RawDictionaryStorage.find<A>(_:)((uint64_t)a1, (uint64_t)a3, a5);
      if ((v16 & 1) != 0)
      {
        uint64_t v17 = *(void *)(a2 + 56);
        uint64_t v14 = *((void *)a4 - 1);
        (*(void (**)(char *, unint64_t, char *))(v14 + 16))(a6, v17 + *(void *)(v14 + 72) * v15, a4);
        uint64_t v13 = 0LL;
        return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56))(a6, v13, 1LL, a4);
      }
    }

void (*_NativeDictionary.subscript.modify( void *a1, uint64_t a2, char a3, void *a4))(uint64_t **a1)
{
  unint64_t v8 = malloc(0x50uLL);
  *a1 = v8;
  *unint64_t v8 = a2;
  v8[1] = v4;
  uint64_t v9 = a4[3];
  _OWORD v8[2] = v9;
  uint64_t v12 = type metadata accessor for Optional(0LL, v9, v10, v11);
  v8[3] = v12;
  uint64_t v13 = *(void *)(v12 - 8);
  v8[4] = v13;
  uint64_t v14 = malloc(*(void *)(v13 + 64));
  char v31 = v4;
  uint64_t v15 = *v4;
  unint64_t v16 = a4[2];
  unint64_t v8[5] = v14;
  v8[6] = v16;
  uint64_t v17 = a4[4];
  v8[7] = v17;
  unint64_t v19 = __RawDictionaryStorage.find<A>(_:)(a2, v16, v17);
  *((_BYTE *)v8 + 72) = v18 & 1;
  uint64_t v20 = *(void *)(v15 + 16);
  BOOL v21 = (v18 & 1) == 0;
  Swift::Int v22 = v20 + v21;
  if (__OFADD__(v20, v21))
  {
    __break(1u);
    goto LABEL_15;
  }

  char v23 = v18;
  Swift::Int v24 = *(void *)(v15 + 24);
  if (v24 < v22 || (a3 & 1) == 0)
  {
    if (v24 >= v22 && (a3 & 1) == 0)
    {
      uint64_t v25 = v31;
      _NativeDictionary.copy()();
      v8[8] = v19;
      if ((v23 & 1) != 0) {
        goto LABEL_9;
      }
LABEL_12:
      uint64_t v26 = *(void *)(v9 - 8);
      uint64_t v27 = 1LL;
      goto LABEL_13;
    }

    uint64_t v25 = v31;
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v22, a3 & 1);
    unint64_t v28 = __RawDictionaryStorage.find<A>(_:)(a2, v16, v17);
    if ((v23 & 1) == (v29 & 1))
    {
      unint64_t v19 = v28;
      v8[8] = v28;
      if ((v23 & 1) != 0) {
        goto LABEL_9;
      }
      goto LABEL_12;
    }

void _NativeDictionary.subscript.modify(uint64_t **a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (void *)(*a1)[5];
  uint64_t v3 = (*a1)[3];
  uint64_t v4 = (*a1)[4];
  $defer #1 <A, B>() in _NativeDictionary.subscript.modify( (uint64_t)v2,  *((unsigned __int8 *)*a1 + 72),  (void **)(*a1)[1],  (*a1)[8],  **a1,  (*a1)[6],  (*a1)[2],  (*a1)[7]);
  (*(void (**)(void *, uint64_t))(v4 + 8))(v2, v3);
  free(v2);
  free(v1);
}

uint64_t Dictionary._Variant.subscript.setter(uint64_t a1, uint64_t a2, void *a3)
{
  char v6 = Dictionary._Variant.subscript.modify(v13, a2, a3);
  uint64_t v8 = v7;
  uint64_t v11 = type metadata accessor for Optional(0LL, a3[3], v9, v10);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 40LL))(v8, a1, v11);
  ((void (*)(void *, void))v6)(v13, 0LL);
  return (*(uint64_t (**)(uint64_t))(*(void *)(a3[2] - 8LL) + 8LL))(a2);
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)( unint64_t a1, unint64_t a2, char a3)
{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)( a1,  a2,  a3,  (void (*)(void))specialized _NativeDictionary.copy(),  (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)( a1,  a2,  a3,  (void (*)(void))specialized _NativeDictionary.copy(),  (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)( a1,  a2,  a3,  (void (*)(void))specialized _NativeDictionary.copy(),  (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)( unint64_t a1, unint64_t a2, char a3, void (*a4)(void), void (*a5)(void))
{
  uint64_t v11 = *v5;
  unint64_t v13 = specialized __RawDictionaryStorage.find<A>(_:)(a1, a2);
  uint64_t v14 = *(void *)(v11 + 16);
  BOOL v15 = (v12 & 1) == 0;
  uint64_t v16 = v14 + v15;
  if (__OFADD__(v14, v15))
  {
    __break(1u);
    goto LABEL_11;
  }

  char v17 = v12;
  uint64_t v18 = *(void *)(v11 + 24);
  if (v18 < v16 || (a3 & 1) == 0)
  {
    if (v18 >= v16 && (a3 & 1) == 0)
    {
      a4();
      return v13;
    }

    a5();
    unint64_t v19 = specialized __RawDictionaryStorage.find<A>(_:)(a1, a2);
    if ((v17 & 1) == (v20 & 1)) {
      return v19;
    }
LABEL_11:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }

  return v13;
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)(void *a1, char a2)
{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)( a1,  a2,  (void (*)(void))specialized _NativeDictionary.copy(),  (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

{
  return specialized _NativeDictionary.mutatingFind(_:isUnique:)( a1,  a2,  (void (*)(void))specialized _NativeDictionary.copy(),  (void (*)(void))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:));
}

unint64_t specialized _NativeDictionary.mutatingFind(_:isUnique:)( void *a1, char a2, void (*a3)(void), void (*a4)(void))
{
  uint64_t v9 = *v4;
  unint64_t v11 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
  uint64_t v12 = *(void *)(v9 + 16);
  BOOL v13 = (v10 & 1) == 0;
  uint64_t v14 = v12 + v13;
  if (__OFADD__(v12, v13))
  {
    __break(1u);
    goto LABEL_11;
  }

  char v15 = v10;
  uint64_t v16 = *(void *)(v9 + 24);
  if (v16 < v14 || (a2 & 1) == 0)
  {
    if (v16 >= v14 && (a2 & 1) == 0)
    {
      a3();
      return v11;
    }

    a4();
    unint64_t v17 = specialized __RawDictionaryStorage.find<A>(_:)(a1);
    if ((v15 & 1) == (v18 & 1)) {
      return v17;
    }
LABEL_11:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }

  return v11;
}

unint64_t _NativeDictionary.mutatingFind(_:isUnique:)(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v6 = *v3;
  unint64_t v7 = *(void *)(a3 + 16);
  uint64_t v8 = *(void *)(a3 + 32);
  unint64_t v10 = __RawDictionaryStorage.find<A>(_:)(a1, v7, v8);
  uint64_t v11 = *(void *)(v6 + 16);
  BOOL v12 = (v9 & 1) == 0;
  Swift::Int v13 = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_11;
  }

  char v14 = v9;
  Swift::Int v15 = *(void *)(v6 + 24);
  if (v15 < v13 || (a2 & 1) == 0)
  {
    if (v15 >= v13 && (a2 & 1) == 0)
    {
      _NativeDictionary.copy()();
      return v10;
    }

    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v13, a2 & 1);
    unint64_t v16 = __RawDictionaryStorage.find<A>(_:)(a1, v7, v8);
    if ((v14 & 1) == (v17 & 1)) {
      return v16;
    }
LABEL_11:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v7);
  }

  return v10;
}

int64x2_t *specialized _NativeDictionary.copy()()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v6 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v6;
    return result;
  }

  unint64_t result = v2 + 4;
  uint64_t v8 = v1 + 64;
  unint64_t v9 = (unint64_t)((1LL << v6[2].i8[0]) + 63) >> 6;
  int64_t v11 = 0LL;
  v6[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v12 = 1LL << *(_BYTE *)(v1 + 32);
  uint64_t v13 = -1LL;
  if (v12 < 64) {
    uint64_t v13 = ~(-1LL << v12);
  }
  unint64_t v14 = v13 & *(void *)(v1 + 64);
  int64_t v15 = (unint64_t)(v12 + 63) >> 6;
  while (1)
  {
    if (v14)
    {
      unint64_t v16 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v17 = v16 | (v11 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v11++, 1LL)) {
      goto LABEL_26;
    }
    if (v11 >= v15) {
      goto LABEL_24;
    }
    unint64_t v31 = *(void *)(v8 + 8 * v11);
    if (!v31) {
      break;
    }
LABEL_23:
    unint64_t v14 = (v31 - 1) & v31;
    unint64_t v17 = __clz(__rbit64(v31)) + (v11 << 6);
LABEL_12:
    uint64_t v18 = 16 * v17;
    unint64_t v19 = (uint64_t *)(*(void *)(v1 + 48) + v18);
    uint64_t v21 = *v19;
    unint64_t v20 = v19[1];
    Swift::Int v22 = (uint64_t *)(*(void *)(v1 + 56) + v18);
    uint64_t v23 = *v22;
    unint64_t v24 = v22[1];
    uint64_t v25 = (void *)(v6[3].i64[0] + v18);
    *uint64_t v25 = v21;
    v25[1] = v20;
    uint64_t v26 = (void *)(v6[3].i64[1] + v18);
    *uint64_t v26 = v23;
    v26[1] = v24;
    swift_bridgeObjectRetain(v20, v3, v4, v5);
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v24, v27, v28, v29);
  }

  int64_t v32 = v11 + 1;
  if (v11 + 1 >= v15) {
    goto LABEL_24;
  }
  unint64_t v31 = *(void *)(v8 + 8 * v32);
  if (v31)
  {
    ++v11;
    goto LABEL_23;
  }

  while (1)
  {
    int64_t v11 = v32 + 1;
    if (__OFADD__(v32, 1LL)) {
      break;
    }
    if (v11 >= v15) {
      goto LABEL_24;
    }
    unint64_t v31 = *(void *)(v8 + 8 * v11);
    ++v32;
    if (v31) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  unint64_t v28;
  int64_t v29;
  uint64_t *v30;
  _OWORD v31[2];
  uint64_t v32;
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
    unint64_t result = (int64x2_t *)swift_release(v1);
LABEL_26:
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }

  char v30 = v0;
  unint64_t result = v2 + 4;
  char v5 = v1 + 64;
  uint64_t v6 = (unint64_t)((1LL << v3[2].i8[0]) + 63) >> 6;
  uint64_t v8 = 0LL;
  v3[1].i64[0] = *(void *)(v1 + 16);
  unint64_t v9 = 1LL << *(_BYTE *)(v1 + 32);
  unint64_t v10 = -1LL;
  if (v9 < 64) {
    unint64_t v10 = ~(-1LL << v9);
  }
  int64_t v11 = v10 & *(void *)(v1 + 64);
  uint64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      uint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v8++, 1LL)) {
      goto LABEL_28;
    }
    if (v8 >= v12)
    {
LABEL_24:
      unint64_t result = (int64x2_t *)swift_release(v1);
      uint64_t v0 = v30;
      goto LABEL_26;
    }

    uint64_t v28 = *(void *)(v5 + 8 * v8);
    if (!v28) {
      break;
    }
LABEL_23:
    int64_t v11 = (v28 - 1) & v28;
    unint64_t v14 = __clz(__rbit64(v28)) + (v8 << 6);
LABEL_12:
    int64_t v15 = 16 * v14;
    unint64_t v16 = (uint64_t *)(*(void *)(v1 + 48) + 16 * v14);
    uint64_t v18 = *v16;
    unint64_t v17 = v16[1];
    unint64_t v19 = 40 * v14;
    outlined init with copy of AnyHashable(*(void *)(v1 + 56) + 40 * v14, (uint64_t)v31);
    unint64_t v20 = (void *)(v3[3].i64[0] + v15);
    uint64_t *v20 = v18;
    v20[1] = v17;
    uint64_t v21 = v3[3].i64[1] + v19;
    Swift::Int v22 = v32;
    uint64_t v23 = v31[1];
    *(_OWORD *)uint64_t v21 = v31[0];
    *(_OWORD *)(v21 + 16) = v23;
    *(void *)(v21 + 32) = v22;
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v17, v24, v25, v26);
  }

  char v29 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  uint64_t v28 = *(void *)(v5 + 8 * v29);
  if (v28)
  {
    ++v8;
    goto LABEL_23;
  }

  while (1)
  {
    uint64_t v8 = v29 + 1;
    if (__OFADD__(v29, 1LL)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    uint64_t v28 = *(void *)(v5 + 8 * v8);
    ++v29;
    if (v28) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v25;
  int64_t v26;
  uint64_t *v27;
  _OWORD v28[2];
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
    unint64_t result = (int64x2_t *)swift_release(v1);
LABEL_26:
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }

  uint64_t v27 = v0;
  unint64_t result = v2 + 4;
  char v5 = v1 + 64;
  uint64_t v6 = (unint64_t)((1LL << v3[2].i8[0]) + 63) >> 6;
  uint64_t v8 = 0LL;
  v3[1].i64[0] = *(void *)(v1 + 16);
  unint64_t v9 = 1LL << *(_BYTE *)(v1 + 32);
  unint64_t v10 = -1LL;
  if (v9 < 64) {
    unint64_t v10 = ~(-1LL << v9);
  }
  int64_t v11 = v10 & *(void *)(v1 + 64);
  uint64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      uint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v8++, 1LL)) {
      goto LABEL_28;
    }
    if (v8 >= v12)
    {
LABEL_24:
      unint64_t result = (int64x2_t *)swift_release(v1);
      uint64_t v0 = v27;
      goto LABEL_26;
    }

    uint64_t v25 = *(void *)(v5 + 8 * v8);
    if (!v25) {
      break;
    }
LABEL_23:
    int64_t v11 = (v25 - 1) & v25;
    unint64_t v14 = __clz(__rbit64(v25)) + (v8 << 6);
LABEL_12:
    int64_t v15 = 16 * v14;
    unint64_t v16 = (uint64_t *)(*(void *)(v1 + 48) + 16 * v14);
    uint64_t v18 = *v16;
    unint64_t v17 = v16[1];
    unint64_t v19 = 32 * v14;
    outlined init with copy of Any(*(void *)(v1 + 56) + 32 * v14, (uint64_t)v28);
    unint64_t v20 = (void *)(v3[3].i64[0] + v15);
    uint64_t *v20 = v18;
    v20[1] = v17;
    outlined init with take of Any(v28, (_OWORD *)(v3[3].i64[1] + v19));
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v17, v21, v22, v23);
  }

  uint64_t v26 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  uint64_t v25 = *(void *)(v5 + 8 * v26);
  if (v25)
  {
    ++v8;
    goto LABEL_23;
  }

  while (1)
  {
    uint64_t v8 = v26 + 1;
    if (__OFADD__(v26, 1LL)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    uint64_t v25 = *(void *)(v5 + 8 * v8);
    ++v26;
    if (v25) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  unint64_t v26;
  int64_t v27;
  _OWORD v28[2];
  uint64_t v29;
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }

  unint64_t result = v2 + 4;
  char v5 = v1 + 64;
  uint64_t v6 = (unint64_t)((1LL << v3[2].i8[0]) + 63) >> 6;
  uint64_t v8 = 0LL;
  v3[1].i64[0] = *(void *)(v1 + 16);
  unint64_t v9 = 1LL << *(_BYTE *)(v1 + 32);
  unint64_t v10 = -1LL;
  if (v9 < 64) {
    unint64_t v10 = ~(-1LL << v9);
  }
  int64_t v11 = v10 & *(void *)(v1 + 64);
  uint64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      uint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v8++, 1LL)) {
      goto LABEL_26;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    uint64_t v26 = *(void *)(v5 + 8 * v8);
    if (!v26) {
      break;
    }
LABEL_23:
    int64_t v11 = (v26 - 1) & v26;
    unint64_t v14 = __clz(__rbit64(v26)) + (v8 << 6);
LABEL_12:
    outlined init with copy of AnyHashable(*(void *)(v1 + 48) + 40 * v14, (uint64_t)v28);
    int64_t v15 = (uint64_t *)(*(void *)(v1 + 56) + 16 * v14);
    unint64_t v17 = *v15;
    unint64_t v16 = v15[1];
    uint64_t v18 = v3[3].i64[0] + 40 * v14;
    unint64_t v19 = v29;
    unint64_t v20 = v28[1];
    *(_OWORD *)uint64_t v18 = v28[0];
    *(_OWORD *)(v18 + 16) = v20;
    *(void *)(v18 + 32) = v19;
    uint64_t v21 = (void *)(v3[3].i64[1] + 16 * v14);
    *uint64_t v21 = v17;
    v21[1] = v16;
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v16, v22, v23, v24);
  }

  uint64_t v27 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  uint64_t v26 = *(void *)(v5 + 8 * v27);
  if (v26)
  {
    ++v8;
    goto LABEL_23;
  }

  while (1)
  {
    uint64_t v8 = v27 + 1;
    if (__OFADD__(v27, 1LL)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    uint64_t v26 = *(void *)(v5 + 8 * v8);
    ++v27;
    if (v26) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  int64x2_t *v3;
  int64x2_t *result;
  uint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  unint64_t v21;
  int64_t v22;
  _OWORD v23[2];
  _OWORD v24[2];
  uint64_t v25;
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v3 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v3;
    return result;
  }

  unint64_t result = v2 + 4;
  char v5 = v1 + 64;
  uint64_t v6 = (unint64_t)((1LL << v3[2].i8[0]) + 63) >> 6;
  uint64_t v8 = 0LL;
  v3[1].i64[0] = *(void *)(v1 + 16);
  unint64_t v9 = 1LL << *(_BYTE *)(v1 + 32);
  unint64_t v10 = -1LL;
  if (v9 < 64) {
    unint64_t v10 = ~(-1LL << v9);
  }
  int64_t v11 = v10 & *(void *)(v1 + 64);
  uint64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      uint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v8 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v8++, 1LL)) {
      goto LABEL_26;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    uint64_t v21 = *(void *)(v5 + 8 * v8);
    if (!v21) {
      break;
    }
LABEL_23:
    int64_t v11 = (v21 - 1) & v21;
    unint64_t v14 = __clz(__rbit64(v21)) + (v8 << 6);
LABEL_12:
    int64_t v15 = 40 * v14;
    outlined init with copy of AnyHashable(*(void *)(v1 + 48) + 40 * v14, (uint64_t)v24);
    unint64_t v16 = 32 * v14;
    outlined init with copy of Any(*(void *)(v1 + 56) + v16, (uint64_t)v23);
    unint64_t v17 = v3[3].i64[0] + v15;
    uint64_t v18 = v24[0];
    unint64_t v19 = v24[1];
    *(void *)(v17 + 32) = v25;
    *(_OWORD *)unint64_t v17 = v18;
    *(_OWORD *)(v17 + 16) = v19;
    unint64_t result = (int64x2_t *)outlined init with take of Any(v23, (_OWORD *)(v3[3].i64[1] + v16));
  }

  Swift::Int v22 = v8 + 1;
  if (v8 + 1 >= v12) {
    goto LABEL_24;
  }
  uint64_t v21 = *(void *)(v5 + 8 * v22);
  if (v21)
  {
    ++v8;
    goto LABEL_23;
  }

  while (1)
  {
    uint64_t v8 = v22 + 1;
    if (__OFADD__(v22, 1LL)) {
      break;
    }
    if (v8 >= v12) {
      goto LABEL_24;
    }
    uint64_t v21 = *(void *)(v5 + 8 * v8);
    ++v22;
    if (v21) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  int64x2_t *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  int64x2_t *v6;
  int64x2_t *result;
  uint64_t v8;
  unint64_t v9;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  unint64_t v26;
  int64_t v27;
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v6 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v6;
    return result;
  }

  unint64_t result = v2 + 4;
  uint64_t v8 = v1 + 64;
  unint64_t v9 = (unint64_t)((1LL << v6[2].i8[0]) + 63) >> 6;
  int64_t v11 = 0LL;
  v6[1].i64[0] = *(void *)(v1 + 16);
  uint64_t v12 = 1LL << *(_BYTE *)(v1 + 32);
  uint64_t v13 = -1LL;
  if (v12 < 64) {
    uint64_t v13 = ~(-1LL << v12);
  }
  unint64_t v14 = v13 & *(void *)(v1 + 64);
  int64_t v15 = (unint64_t)(v12 + 63) >> 6;
  while (1)
  {
    if (v14)
    {
      unint64_t v16 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v17 = v16 | (v11 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v11++, 1LL)) {
      goto LABEL_26;
    }
    if (v11 >= v15) {
      goto LABEL_24;
    }
    uint64_t v26 = *(void *)(v8 + 8 * v11);
    if (!v26) {
      break;
    }
LABEL_23:
    unint64_t v14 = (v26 - 1) & v26;
    unint64_t v17 = __clz(__rbit64(v26)) + (v11 << 6);
LABEL_12:
    uint64_t v18 = 16 * v17;
    unint64_t v19 = (uint64_t *)(*(void *)(v1 + 48) + 16 * v17);
    uint64_t v21 = *v19;
    unint64_t v20 = v19[1];
    Swift::Int v22 = 8 * v17;
    uint64_t v23 = *(void *)(*(void *)(v1 + 56) + v22);
    unint64_t v24 = (void *)(v6[3].i64[0] + v18);
    *unint64_t v24 = v21;
    v24[1] = v20;
    *(void *)(v6[3].i64[1] + v22) = v23;
    unint64_t result = (int64x2_t *)swift_bridgeObjectRetain(v20, v3, v4, v5);
  }

  uint64_t v27 = v11 + 1;
  if (v11 + 1 >= v15) {
    goto LABEL_24;
  }
  uint64_t v26 = *(void *)(v8 + 8 * v27);
  if (v26)
  {
    ++v11;
    goto LABEL_23;
  }

  while (1)
  {
    int64_t v11 = v27 + 1;
    if (__OFADD__(v27, 1LL)) {
      break;
    }
    if (v11 >= v15) {
      goto LABEL_24;
    }
    uint64_t v26 = *(void *)(v8 + 8 * v11);
    ++v27;
    if (v26) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

int64x2_t *specialized _NativeDictionary.copy()(uint64_t (*a1)(void))
{
  uint64_t v2 = *v1;
  uint64_t v3 = specialized static _DictionaryStorage.copy(original:)(*v1, a1);
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_24:
    unint64_t result = (int64x2_t *)swift_release(v2);
    uint64_t *v1 = (uint64_t)v4;
    return result;
  }

  unint64_t result = v3 + 4;
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1LL << v4[2].i8[0]) + 63) >> 6;
  int64_t v9 = 0LL;
  v4[1].i64[0] = *(void *)(v2 + 16);
  uint64_t v10 = 1LL << *(_BYTE *)(v2 + 32);
  uint64_t v11 = -1LL;
  if (v10 < 64) {
    uint64_t v11 = ~(-1LL << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v9++, 1LL)) {
      goto LABEL_26;
    }
    if (v9 >= v13) {
      goto LABEL_24;
    }
    unint64_t v19 = *(void *)(v6 + 8 * v9);
    if (!v19) {
      break;
    }
LABEL_23:
    unint64_t v12 = (v19 - 1) & v19;
    unint64_t v15 = __clz(__rbit64(v19)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 8 * v15;
    uint64_t v17 = *(void *)(*(void *)(v2 + 56) + v16);
    *(void *)(v4[3].i64[0] + v16) = *(void *)(*(void *)(v2 + 48) + v16);
    *(void *)(v4[3].i64[1] + v16) = v17;
  }

  int64_t v20 = v9 + 1;
  if (v9 + 1 >= v13) {
    goto LABEL_24;
  }
  unint64_t v19 = *(void *)(v6 + 8 * v20);
  if (v19)
  {
    ++v9;
    goto LABEL_23;
  }

  while (1)
  {
    int64_t v9 = v20 + 1;
    if (__OFADD__(v20, 1LL)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_24;
    }
    unint64_t v19 = *(void *)(v6 + 8 * v9);
    ++v20;
    if (v19) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

int64x2_t *specialized _NativeDictionary.copy()(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 16) - 8LL);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  uint64_t v36 = (char *)&v32 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v37 = v5;
  uint64_t v6 = *v1;
  unint64_t v7 = specialized static _DictionaryStorage.copy(original:)(*v1, v5, *(void *)(v3 + 32));
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    unint64_t result = (int64x2_t *)swift_release(v6);
LABEL_28:
    uint64_t *v1 = (uint64_t)v8;
    return result;
  }

  uint64_t v33 = v1;
  unint64_t result = v7 + 4;
  unint64_t v10 = (unint64_t)((1LL << v8[2].i8[0]) + 63) >> 6;
  int64_t v12 = 0LL;
  uint64_t v13 = *(void *)(v6 + 16);
  uint64_t v38 = v6;
  uint64_t v39 = v8;
  v8[1].i64[0] = v13;
  uint64_t v14 = 1LL << *(_BYTE *)(v6 + 32);
  uint64_t v15 = -1LL;
  if (v14 < 64) {
    uint64_t v15 = ~(-1LL << v14);
  }
  unint64_t v16 = v15 & *(void *)(v6 + 64);
  uint64_t v34 = v6 + 64;
  int64_t v35 = (unint64_t)(v14 + 63) >> 6;
  uint64_t v17 = v37;
  uint64_t v18 = v8;
  while (1)
  {
    if (v16)
    {
      unint64_t v19 = __clz(__rbit64(v16));
      v16 &= v16 - 1;
      unint64_t v20 = v19 | (v12 << 6);
      uint64_t v21 = v38;
      goto LABEL_12;
    }

    BOOL v29 = __OFADD__(v12++, 1LL);
    uint64_t v21 = v38;
    if (v29) {
      goto LABEL_30;
    }
    if (v12 >= v35)
    {
LABEL_27:
      unint64_t result = (int64x2_t *)swift_release(v38);
      uint64_t v1 = v33;
      uint64_t v8 = v39;
      goto LABEL_28;
    }

    unint64_t v30 = *(void *)(v34 + 8 * v12);
    if (!v30) {
      break;
    }
LABEL_24:
    unint64_t v16 = (v30 - 1) & v30;
    unint64_t v20 = __clz(__rbit64(v30)) + (v12 << 6);
LABEL_12:
    unint64_t v22 = *(void *)(v2 + 72) * v20;
    uint64_t v23 = v36;
    (*(void (**)(char *, unint64_t, uint64_t))(v2 + 16))(v36, *(void *)(v21 + 48) + v22, v17);
    uint64_t v24 = 16 * v20;
    uint64_t v25 = *(void *)(v21 + 56) + v24;
    uint64_t v26 = *(void *)v25;
    char v27 = *(_BYTE *)(v25 + 8);
    unint64_t result = (int64x2_t *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v2 + 32))( v18[3].i64[0] + v22,  v23,  v17);
    uint64_t v28 = v18[3].i64[1] + v24;
    *(void *)uint64_t v28 = v26;
    *(_BYTE *)(v28 + 8) = v27;
  }

  int64_t v31 = v12 + 1;
  if (v12 + 1 >= v35) {
    goto LABEL_27;
  }
  unint64_t v30 = *(void *)(v34 + 8 * v31);
  if (v30)
  {
    ++v12;
    goto LABEL_24;
  }

  uint64_t v8 = v39;
  while (1)
  {
    int64_t v12 = v31 + 1;
    if (__OFADD__(v31, 1LL)) {
      break;
    }
    if (v12 >= v35)
    {
      unint64_t result = (int64x2_t *)swift_release(v38);
      uint64_t v1 = v33;
      goto LABEL_28;
    }

    unint64_t v30 = *(void *)(v34 + 8 * v12);
    ++v31;
    if (v30) {
      goto LABEL_24;
    }
  }

  __break(1u);
LABEL_30:
  __break(1u);
  return result;
}

Swift::Void __swiftcall _NativeDictionary.copy()()
{
  uint64_t v2 = v1;
  uint64_t v42 = *(void *)(*(void *)(v0 + 24) - 8LL);
  uint64_t v3 = ((uint64_t (*)())MEMORY[0x1895F8858])();
  uint64_t v43 = (char *)&v36 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v40 = *(void *)(*(void *)(v3 + 16) - 8LL);
  uint64_t v5 = MEMORY[0x1895F8858](v3);
  uint64_t v39 = (char *)&v36 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void *)(v5 + 32);
  uint64_t v41 = v8;
  uint64_t v44 = v9;
  type metadata accessor for _DictionaryStorage(0LL, v8, v9, v7);
  uint64_t v10 = *v1;
  uint64_t v11 = static _DictionaryStorage.copy(original:)(*v1);
  uint64_t v12 = *(void *)(v10 + 16);
  uint64_t v46 = v11;
  if (!v12)
  {
    swift_release(v10);
LABEL_23:
    uint64_t *v2 = (uint64_t)v46;
    return;
  }

  uint64_t v13 = v11;
  uint64_t v14 = v11 + 4;
  unint64_t v15 = (unint64_t)((1LL << v13[2].i8[0]) + 63) >> 6;
  uint64_t v36 = v1;
  uint64_t v37 = (const void *)(v10 + 64);
  if (v13 != (int64x2_t *)v10 || (unint64_t)v14 >= v10 + 64 + 8 * v15)
  {
    memmove(v14, v37, 8 * v15);
    uint64_t v13 = v46;
  }

  int64_t v17 = 0LL;
  v13[1].i64[0] = *(void *)(v10 + 16);
  uint64_t v18 = 1LL << *(_BYTE *)(v10 + 32);
  uint64_t v45 = v10;
  uint64_t v19 = -1LL;
  if (v18 < 64) {
    uint64_t v19 = ~(-1LL << v18);
  }
  unint64_t v20 = v19 & *(void *)(v10 + 64);
  int64_t v21 = (unint64_t)(v18 + 63) >> 6;
  int64_t v38 = v21;
  unint64_t v22 = v39;
  uint64_t v23 = v40;
  uint64_t v25 = v41;
  uint64_t v24 = v42;
  uint64_t v26 = v43;
  char v27 = v46;
  while (1)
  {
    if (v20)
    {
      uint64_t v47 = (v20 - 1) & v20;
      unint64_t v28 = __clz(__rbit64(v20)) | (v17 << 6);
      uint64_t v29 = v45;
      goto LABEL_12;
    }

    int64_t v34 = v17 + 1;
    uint64_t v29 = v45;
    if (__OFADD__(v17, 1LL)) {
      goto LABEL_25;
    }
    if (v34 >= v21)
    {
LABEL_21:
      swift_release(v45);
      uint64_t v2 = v36;
      goto LABEL_23;
    }

    unint64_t v35 = *((void *)v37 + v34);
    ++v17;
    if (!v35) {
      break;
    }
LABEL_20:
    uint64_t v47 = (v35 - 1) & v35;
    unint64_t v28 = __clz(__rbit64(v35)) + (v17 << 6);
LABEL_12:
    unint64_t v30 = *(void *)(v23 + 72) * v28;
    (*(void (**)(char *, unint64_t, uint64_t))(v23 + 16))(v22, *(void *)(v29 + 48) + v30, v25);
    unint64_t v31 = *(void *)(v24 + 72) * v28;
    unint64_t v32 = *(void *)(v29 + 56) + v31;
    uint64_t v33 = v44;
    (*(void (**)(char *, unint64_t, uint64_t))(v24 + 16))(v26, v32, v44);
    (*(void (**)(unint64_t, char *, uint64_t))(v23 + 32))(v27[3].i64[0] + v30, v22, v25);
    (*(void (**)(unint64_t, char *, uint64_t))(v24 + 32))(v27[3].i64[1] + v31, v26, v33);
    int64_t v21 = v38;
    unint64_t v20 = v47;
  }

  while (1)
  {
    int64_t v17 = v34 + 1;
    if (__OFADD__(v34, 1LL)) {
      break;
    }
    if (v17 >= v21) {
      goto LABEL_21;
    }
    unint64_t v35 = *((void *)v37 + v17);
    ++v34;
    if (v35) {
      goto LABEL_20;
    }
  }

  __break(1u);
LABEL_25:
  __break(1u);
}

uint64_t _NativeDictionary.updateValue(_:forKey:isUnique:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = (void **)v5;
  uint64_t v36 = a1;
  uint64_t v37 = a5;
  unint64_t v10 = *(void *)(a4 + 16);
  uint64_t v35 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = (void *)*v5;
  uint64_t v15 = *(void *)(v14 + 32);
  unint64_t v18 = __RawDictionaryStorage.find<A>(_:)(v16, v10, v15);
  uint64_t v19 = v13[2];
  BOOL v20 = (v17 & 1) == 0;
  Swift::Int v21 = v19 + v20;
  if (__OFADD__(v19, v20))
  {
    __break(1u);
    goto LABEL_13;
  }

  char v22 = v17;
  Swift::Int v23 = v13[3];
  if (v23 < v21 || (a3 & 1) == 0)
  {
    if (v23 >= v21 && (a3 & 1) == 0)
    {
      _NativeDictionary.copy()();
      goto LABEL_7;
    }

    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v21, a3 & 1);
    unint64_t v31 = __RawDictionaryStorage.find<A>(_:)(a2, v10, v15);
    if ((v22 & 1) == (v32 & 1))
    {
      unint64_t v18 = v31;
      uint64_t v24 = *v6;
      if ((v22 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }

_OWORD *specialized _NativeDictionary.setValue(_:forKey:isUnique:)( _OWORD *a1, unint64_t a2, unint64_t a3, char a4)
{
  uint64_t v5 = (void **)v4;
  unint64_t v10 = (void *)*v4;
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
  uint64_t v13 = v10[2];
  BOOL v14 = (v11 & 1) == 0;
  uint64_t v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
    goto LABEL_13;
  }

  char v16 = v11;
  uint64_t v17 = v10[3];
  if (v17 < v15 || (a4 & 1) == 0)
  {
    if (v17 >= v15 && (a4 & 1) == 0)
    {
      specialized _NativeDictionary.copy()();
      goto LABEL_7;
    }

    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v15, a4 & 1);
    unint64_t v21 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
    if ((v16 & 1) == (v22 & 1))
    {
      unint64_t v12 = v21;
      unint64_t v18 = *v5;
      if ((v16 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }

uint64_t specialized _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:)(a2);
  uint64_t v11 = *(void *)(v8 + 16);
  BOOL v12 = (v9 & 1) == 0;
  uint64_t result = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_14;
  }

  char v14 = v9;
  uint64_t v15 = *(void *)(v8 + 24);
  if (v15 >= result && (a3 & 1) != 0) {
    goto LABEL_7;
  }
  if (v15 >= result && (a3 & 1) == 0)
  {
    uint64_t result = (uint64_t)specialized _NativeDictionary.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<ObjectIdentifier, Int>);
LABEL_7:
    char v16 = (void *)*v4;
    if ((v14 & 1) != 0)
    {
LABEL_8:
      *(void *)(v16[7] + 8 * v10) = a1;
      return result;
    }

    goto LABEL_11;
  }

  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(result, a3 & 1);
  uint64_t result = specialized __RawDictionaryStorage.find<A>(_:)(a2);
  if ((v14 & 1) != (v17 & 1)) {
    goto LABEL_15;
  }
  unint64_t v10 = result;
  char v16 = (void *)*v4;
  if ((v14 & 1) != 0) {
    goto LABEL_8;
  }
LABEL_11:
  v16[(v10 >> 6) + 8] |= 1LL << v10;
  uint64_t v18 = 8 * v10;
  *(void *)(v16[6] + v18) = a2;
  *(void *)(v16[7] + v18) = a1;
  uint64_t v19 = v16[2];
  BOOL v20 = __OFADD__(v19, 1LL);
  uint64_t v21 = v19 + 1;
  if (v20)
  {
LABEL_14:
    __break(1u);
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for ObjectIdentifier);
  }

  v16[2] = v21;
  return result;
}

_OWORD *specialized _NativeDictionary.setValue(_:forKey:isUnique:)(_OWORD *a1, void *a2, char a3)
{
  uint64_t v4 = (void **)v3;
  uint64_t v8 = (void *)*v3;
  unint64_t v10 = specialized __RawDictionaryStorage.find<A>(_:)(a2);
  uint64_t v11 = v8[2];
  BOOL v12 = (v9 & 1) == 0;
  uint64_t v13 = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_13;
  }

  char v14 = v9;
  uint64_t v15 = v8[3];
  if (v15 < v13 || (a3 & 1) == 0)
  {
    if (v15 >= v13 && (a3 & 1) == 0)
    {
      specialized _NativeDictionary.copy()();
      goto LABEL_7;
    }

    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v13, a3 & 1);
    unint64_t v19 = specialized __RawDictionaryStorage.find<A>(_:)(a2);
    if ((v14 & 1) == (v20 & 1))
    {
      unint64_t v10 = v19;
      char v16 = *v4;
      if ((v14 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }

void specialized _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:)(a3);
  uint64_t v13 = *(void *)(v10 + 16);
  BOOL v14 = (v11 & 1) == 0;
  uint64_t v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
    goto LABEL_14;
  }

  char v16 = v11;
  uint64_t v17 = *(void *)(v10 + 24);
  if (v17 >= v15 && (a4 & 1) != 0) {
    goto LABEL_7;
  }
  if (v17 >= v15 && (a4 & 1) == 0)
  {
    specialized _NativeDictionary.copy()();
LABEL_7:
    uint64_t v18 = (void *)*v5;
    if ((v16 & 1) != 0)
    {
LABEL_8:
      unint64_t v19 = (void *)(v18[7] + 16 * v12);
      uint64_t v20 = v19[1];
      *unint64_t v19 = a1;
      v19[1] = a2;
      swift_bridgeObjectRelease(v20);
      return;
    }

    goto LABEL_11;
  }

  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v15, a4 & 1);
  unint64_t v21 = specialized __RawDictionaryStorage.find<A>(_:)(a3);
  if ((v16 & 1) != (v22 & 1)) {
    goto LABEL_15;
  }
  unint64_t v12 = v21;
  uint64_t v18 = (void *)*v5;
  if ((v16 & 1) != 0) {
    goto LABEL_8;
  }
LABEL_11:
  outlined init with copy of AnyHashable((uint64_t)a3, (uint64_t)v30);
  v18[(v12 >> 6) + 8] |= 1LL << v12;
  uint64_t v23 = v18[6] + 40 * v12;
  uint64_t v24 = v31;
  __int128 v25 = v30[1];
  *(_OWORD *)uint64_t v23 = v30[0];
  *(_OWORD *)(v23 + 16) = v25;
  *(void *)(v23 + 32) = v24;
  uint64_t v26 = (void *)(v18[7] + 16 * v12);
  *uint64_t v26 = a1;
  v26[1] = a2;
  uint64_t v27 = v18[2];
  BOOL v28 = __OFADD__(v27, 1LL);
  uint64_t v29 = v27 + 1;
  if (v28)
  {
LABEL_14:
    __break(1u);
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }

  _OWORD v18[2] = v29;
}

unint64_t specialized _NativeDictionary.setValue(_:forKey:isUnique:)( uint64_t a1, unint64_t a2, unint64_t a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  unint64_t v14 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
  uint64_t v15 = *(void *)(v10 + 16);
  BOOL v16 = (v11 & 1) == 0;
  uint64_t v17 = v15 + v16;
  if (__OFADD__(v15, v16))
  {
    __break(1u);
    goto LABEL_14;
  }

  char v18 = v11;
  uint64_t v19 = *(void *)(v10 + 24);
  if (v19 >= v17 && (a4 & 1) != 0) {
    goto LABEL_7;
  }
  if (v19 >= v17 && (a4 & 1) == 0)
  {
    specialized _NativeDictionary.copy()();
LABEL_7:
    uint64_t v20 = (void *)*v5;
    if ((v18 & 1) != 0) {
      return outlined assign with take of AnyHashable((__int128 *)a1, v20[7] + 40 * v14);
    }
    goto LABEL_11;
  }

  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v17, a4 & 1);
  unint64_t v22 = specialized __RawDictionaryStorage.find<A>(_:)(a2, a3);
  if ((v18 & 1) != (v11 & 1)) {
    goto LABEL_15;
  }
  unint64_t v14 = v22;
  uint64_t v20 = (void *)*v5;
  if ((v18 & 1) != 0) {
    return outlined assign with take of AnyHashable((__int128 *)a1, v20[7] + 40 * v14);
  }
LABEL_11:
  v20[(v14 >> 6) + 8] |= 1LL << v14;
  uint64_t v23 = (unint64_t *)(v20[6] + 16 * v14);
  *uint64_t v23 = a2;
  v23[1] = a3;
  uint64_t v24 = v20[7] + 40 * v14;
  __int128 v25 = *(_OWORD *)a1;
  __int128 v26 = *(_OWORD *)(a1 + 16);
  *(void *)(v24 + 32) = *(void *)(a1 + 32);
  *(_OWORD *)uint64_t v24 = v25;
  *(_OWORD *)(v24 + 16) = v26;
  uint64_t v27 = v20[2];
  BOOL v28 = __OFADD__(v27, 1LL);
  uint64_t v29 = v27 + 1;
  if (v28)
  {
LABEL_14:
    __break(1u);
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }

  v20[2] = v29;
  return swift_bridgeObjectRetain(a3, v11, v12, v13);
}

void specialized _NativeDictionary.setValue(_:forKey:isUnique:)( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v6 = v5;
  uint64_t v12 = *v5;
  unint64_t v16 = specialized __RawDictionaryStorage.find<A>(_:)(a3, a4);
  uint64_t v17 = *(void *)(v12 + 16);
  BOOL v18 = (v13 & 1) == 0;
  uint64_t v19 = v17 + v18;
  if (__OFADD__(v17, v18))
  {
    __break(1u);
    goto LABEL_14;
  }

  char v20 = v13;
  uint64_t v21 = *(void *)(v12 + 24);
  if (v21 >= v19 && (a5 & 1) != 0) {
    goto LABEL_7;
  }
  if (v21 >= v19 && (a5 & 1) == 0)
  {
    specialized _NativeDictionary.copy()();
LABEL_7:
    unint64_t v22 = (void *)*v6;
    if ((v20 & 1) != 0)
    {
LABEL_8:
      uint64_t v23 = (void *)(v22[7] + 16 * v16);
      uint64_t v24 = v23[1];
      *uint64_t v23 = a1;
      v23[1] = a2;
      swift_bridgeObjectRelease(v24);
      return;
    }

    goto LABEL_11;
  }

  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v19, a5 & 1);
  unint64_t v25 = specialized __RawDictionaryStorage.find<A>(_:)(a3, a4);
  if ((v20 & 1) != (v13 & 1)) {
    goto LABEL_15;
  }
  unint64_t v16 = v25;
  unint64_t v22 = (void *)*v6;
  if ((v20 & 1) != 0) {
    goto LABEL_8;
  }
LABEL_11:
  v22[(v16 >> 6) + 8] |= 1LL << v16;
  __int128 v26 = (unint64_t *)(v22[6] + 16 * v16);
  *__int128 v26 = a3;
  v26[1] = a4;
  uint64_t v27 = (void *)(v22[7] + 16 * v16);
  *uint64_t v27 = a1;
  v27[1] = a2;
  uint64_t v28 = v22[2];
  BOOL v29 = __OFADD__(v28, 1LL);
  uint64_t v30 = v28 + 1;
  if (v29)
  {
LABEL_14:
    __break(1u);
LABEL_15:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }

  v22[2] = v30;
  swift_bridgeObjectRetain(a4, v13, v14, v15);
}

uint64_t _NativeDictionary.setValue(_:forKey:isUnique:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v5 = (void **)v4;
  unint64_t v9 = *(void *)(a4 + 16);
  uint64_t v28 = *(void *)(v9 - 8);
  uint64_t v29 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = (void *)*v4;
  uint64_t v14 = *(void *)(v13 + 32);
  unint64_t v17 = __RawDictionaryStorage.find<A>(_:)(v15, v9, v14);
  uint64_t v18 = v12[2];
  BOOL v19 = (v16 & 1) == 0;
  Swift::Int v20 = v18 + v19;
  if (__OFADD__(v18, v19))
  {
    __break(1u);
    goto LABEL_13;
  }

  char v21 = v16;
  Swift::Int v22 = v12[3];
  if (v22 >= v20 && (a3 & 1) != 0) {
    goto LABEL_9;
  }
  if (v22 >= v20 && (a3 & 1) == 0)
  {
    _NativeDictionary.copy()();
    goto LABEL_9;
  }

  _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v20, a3 & 1);
  unint64_t v23 = __RawDictionaryStorage.find<A>(_:)(a2, v9, v14);
  if ((v21 & 1) != (v24 & 1)) {
LABEL_13:
  }
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v9);
  unint64_t v17 = v23;
LABEL_9:
  uint64_t v25 = v29;
  __int128 v26 = *v5;
  if ((v21 & 1) != 0) {
    return (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)(*(void *)(a4 + 24) - 8LL) + 40LL))( v26[7] + *(void *)(*(void *)(*(void *)(a4 + 24) - 8LL) + 72LL) * v17,  v29);
  }
  (*(void (**)(char *, uint64_t, unint64_t))(v28 + 16))(v11, a2, v9);
  return _NativeDictionary._insert(at:key:value:)(v17, (uint64_t)v11, v25, v26, v9, *(void *)(a4 + 24));
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(void *a1, Swift::Int a2, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 56);
  uint64_t v8 = *(void *)(*(void *)(*v3 + 48) + 16 * a2);
  unint64_t v9 = (uint64_t *)(v7 + 16 * a2);
  uint64_t v11 = *v9;
  uint64_t v10 = v9[1];
  *a1 = v11;
  a1[1] = v10;
  v12.Swift::Int offset = a2;
  specialized _NativeDictionary._delete(at:)(v12, v6);
  return v8;
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(uint64_t a1, Swift::Int a2, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 56);
  uint64_t v8 = *(void *)(*(void *)(*v3 + 48) + 16 * a2);
  Swift::Int v9 = v7 + 40 * a2;
  __int128 v10 = *(_OWORD *)(v9 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v9;
  *(_OWORD *)(a1 + 16) = v10;
  *(void *)(a1 + 32) = *(void *)(v9 + 32);
  v11.Swift::Int offset = a2;
  specialized _NativeDictionary._delete(at:)(v11, v6);
  return v8;
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)(_OWORD *a1, Swift::Int a2, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*(void *)(v6 + 48) + 16 * a2);
  outlined init with take of Any((_OWORD *)(*(void *)(v6 + 56) + 32 * a2), a1);
  v8.Swift::Int offset = a2;
  specialized _NativeDictionary._delete(at:)(v8, v6);
  return v7;
}

uint64_t specialized _NativeDictionary.uncheckedRemove(at:isUnique:)( uint64_t a1, Swift::_HashTable::Bucket before, char a3)
{
  if ((a3 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 56);
  Swift::Int v8 = *(void *)(*v3 + 48) + 40 * before.offset;
  __int128 v9 = *(_OWORD *)(v8 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v8;
  *(_OWORD *)(a1 + 16) = v9;
  *(void *)(a1 + 32) = *(void *)(v8 + 32);
  uint64_t v10 = *(void *)(v7 + 16 * before.offset);
  v11.Swift::Int offset = before.offset;
  specialized _NativeDictionary._delete(at:)(v11, v6);
  return v10;
}

Swift::Int specialized _NativeDictionary.uncheckedRemove(at:isUnique:)( uint64_t a1, _OWORD *a2, Swift::Int a3, char a4)
{
  if ((a4 & 1) == 0) {
    specialized _NativeDictionary.copy()();
  }
  uint64_t v8 = *v4;
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *(void *)(v8 + 48) + 40 * a3;
  __int128 v11 = *(_OWORD *)(v10 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v10;
  *(_OWORD *)(a1 + 16) = v11;
  *(void *)(a1 + 32) = *(void *)(v10 + 32);
  outlined init with take of Any((_OWORD *)(v9 + 32 * a3), a2);
  v12.Swift::Int offset = a3;
  return specialized _NativeDictionary._delete(at:)(v12, v8);
}

void _NativeDictionary.uncheckedRemove(at:isUnique:)( uint64_t a1, uint64_t a2, Swift::_HashTable::Bucket a3, char a4, uint64_t a5)
{
  if ((a4 & 1) == 0) {
    _NativeDictionary.copy()();
  }
  uint64_t v10 = *v5;
  (*(void (**)(uint64_t, Swift::Int, void))(*(void *)(*(void *)(a5 + 16) - 8LL) + 32LL))( a1,  *(void *)(v10 + 48) + *(void *)(*(void *)(*(void *)(a5 + 16) - 8LL) + 72LL) * a3.offset,  *(void *)(a5 + 16));
  (*(void (**)(uint64_t, Swift::Int, void))(*(void *)(*(void *)(a5 + 24) - 8LL) + 32LL))( a2,  *(void *)(v10 + 56) + *(void *)(*(void *)(*(void *)(a5 + 24) - 8LL) + 72LL) * a3.offset,  *(void *)(a5 + 24));
  _NativeDictionary._delete(at:)(a3);
}

Swift::Void __swiftcall _NativeDictionary.removeAll(isUnique:)(Swift::Bool isUnique)
{
  uint64_t v5 = v4;
  uint64_t v6 = v1;
  uint64_t v7 = *v4;
  char v8 = (*v4)[2].i8[0];
  if (!isUnique)
  {
    type metadata accessor for _DictionaryStorage(0LL, v1[2], v1[3], v1[4]);
    Swift::Int v20 = static _DictionaryStorage.allocate(scale:age:seed:)(v8, 0x100000000LL, 0LL, 1);
    swift_release((uint64_t)v7);
    *uint64_t v5 = v20;
    return;
  }

  uint64_t v9 = 1LL << v8;
  uint64_t v10 = v7 + 4;
  uint64_t v11 = -1LL;
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  unint64_t v12 = v11 & v7[4].i64[0];
  int64_t v13 = (unint64_t)(v9 + 63) >> 6;
  swift_retain((unint64_t *)v7, (uint64_t)v1, v2, v3);
  int64_t v14 = 0LL;
  while (1)
  {
    if (v12)
    {
      unint64_t v15 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v16 = v15 | (v14 << 6);
      goto LABEL_6;
    }

    if (__OFADD__(v14++, 1LL)) {
      goto LABEL_24;
    }
    if (v14 >= v13) {
      break;
    }
    unint64_t v18 = v10->u64[v14];
    if (!v18)
    {
      int64_t v19 = v14 + 1;
      if (v14 + 1 >= v13) {
        break;
      }
      unint64_t v18 = v10->u64[v19];
      if (!v18)
      {
        while (1)
        {
          int64_t v14 = v19 + 1;
          if (__OFADD__(v19, 1LL)) {
            break;
          }
          if (v14 >= v13) {
            goto LABEL_19;
          }
          unint64_t v18 = v10->u64[v14];
          ++v19;
          if (v18) {
            goto LABEL_17;
          }
        }

        __break(1u);
LABEL_24:
        __break(1u);
        return;
      }

      ++v14;
    }

int64x2_t *_NativeDictionary.mapValues<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v63 = a1;
  uint64_t v64 = a2;
  uint64_t v58 = *(void *)(a6 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v62 = (char *)&v54 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v9);
  uint64_t v70 = (char *)&v54 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v66 = *(void *)(v15 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  unint64_t v18 = (char *)&v54 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v61 = (char *)&v54 - v19;
  uint64_t v59 = v20;
  type metadata accessor for _DictionaryStorage(0LL, v21, v20, v22);
  uint64_t result = static _DictionaryStorage.copy(original:)(a3);
  int64_t v24 = 0LL;
  uint64_t v65 = a3;
  uint64_t v27 = *(void *)(a3 + 64);
  uint64_t v26 = a3 + 64;
  uint64_t v25 = v27;
  uint64_t v28 = 1LL << *(_BYTE *)(v26 - 32);
  uint64_t v29 = -1LL;
  if (v28 < 64) {
    uint64_t v29 = ~(-1LL << v28);
  }
  unint64_t v30 = v29 & v25;
  uint64_t v54 = v26;
  int64_t v55 = (unint64_t)(v28 + 63) >> 6;
  uint64_t v67 = result;
  uint64_t v56 = v12;
  uint64_t v57 = result + 4;
  unint64_t v60 = v18;
  if (!v30) {
    goto LABEL_5;
  }
LABEL_4:
  uint64_t v68 = (v30 - 1) & v30;
  int64_t v69 = v24;
  for (unint64_t i = __clz(__rbit64(v30)) | (v24 << 6); ; unint64_t i = __clz(__rbit64(v34)) + (v33 << 6))
  {
    unint64_t v72 = i;
    uint64_t v36 = v65;
    uint64_t v37 = v66;
    unint64_t v38 = i;
    unint64_t v39 = *(void *)(v66 + 72) * i;
    uint64_t v40 = v61;
    (*(void (**)(char *, unint64_t, uint64_t))(v66 + 16))(v61, *(void *)(v65 + 48) + v39, a4);
    uint64_t v41 = v70;
    (*(void (**)(char *, unint64_t, uint64_t))(v12 + 16))( v70,  *(void *)(v36 + 56) + *(void *)(v12 + 72) * v38,  a5);
    uint64_t v42 = a5;
    uint64_t v43 = *(void (**)(char *, char *, uint64_t))(v37 + 32);
    uint64_t v44 = v60;
    v43(v60, v40, a4);
    uint64_t v45 = v62;
    uint64_t v46 = v41;
    uint64_t v47 = a4;
    uint64_t v48 = v71;
    v63(v46);
    if (v48)
    {
      uint64_t v53 = (uint64_t)v67;
      swift_release((uint64_t)v67);
      (*(void (**)(char *, uint64_t))(v66 + 8))(v44, a4);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v70, v42);
      return (int64x2_t *)v53;
    }

    uint64_t v71 = 0LL;
    (*(void (**)(char *, uint64_t))(v12 + 8))(v70, v42);
    unint64_t v49 = v72;
    *(uint64_t *)((char *)v57->i64 + ((v72 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v72;
    uint64_t v50 = (uint64_t)v67;
    v43((char *)(v67[3].i64[0] + v39), v44, v47);
    uint64_t result = (int64x2_t *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v58 + 32))( *(void *)(v50 + 56) + *(void *)(v58 + 72) * v49,  v45,  v59);
    uint64_t v51 = *(void *)(v50 + 16);
    BOOL v32 = __OFADD__(v51, 1LL);
    uint64_t v52 = v51 + 1;
    if (v32) {
      break;
    }
    a5 = v42;
    *(void *)(v50 + 16) = v52;
    a4 = v47;
    uint64_t v12 = v56;
    unint64_t v30 = v68;
    int64_t v24 = v69;
    if (v68) {
      goto LABEL_4;
    }
LABEL_5:
    BOOL v32 = __OFADD__(v24, 1LL);
    int64_t v33 = v24 + 1;
    if (v32) {
      goto LABEL_24;
    }
    if (v33 >= v55) {
      return v67;
    }
    unint64_t v34 = *(void *)(v54 + 8 * v33);
    if (v34) {
      goto LABEL_14;
    }
    int64_t v35 = v33 + 1;
    if (v33 + 1 >= v55) {
      return v67;
    }
    unint64_t v34 = *(void *)(v54 + 8 * v35);
    if (!v34)
    {
      while (1)
      {
        int64_t v33 = v35 + 1;
        if (__OFADD__(v35, 1LL)) {
          goto LABEL_23;
        }
        if (v33 >= v55) {
          return v67;
        }
        unint64_t v34 = *(void *)(v54 + 8 * v33);
        ++v35;
        if (v34) {
          goto LABEL_14;
        }
      }
    }

    ++v33;
LABEL_14:
    uint64_t v68 = (v34 - 1) & v34;
    int64_t v69 = v33;
  }

  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

unint64_t *DiscontiguousSlice.subranges.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, unint64_t **a5@<X8>)
{
  uint64_t v6 = *(unint64_t **)(v5 + *(int *)(a1 + 36));
  *a5 = v6;
  return swift_retain(v6, a2, a3, a4);
}

uint64_t DiscontiguousSlice.init(_base:subranges:)@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8 = *a2;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 32LL))(a5, a1);
  uint64_t result = type metadata accessor for DiscontiguousSlice(0LL, a3, a4, v9);
  *(void *)(a5 + *(int *)(result + 36)) = v8;
  return result;
}

uint64_t static DiscontiguousSlice<>.== infix(_:_:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = type metadata accessor for DiscontiguousSlice(0LL, a3, a4, a4);
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, v7, v8);
  return Sequence<>.elementsEqual<A>(_:)(a2, v7, v7, WitnessTable, WitnessTable, a5) & 1;
}

uint64_t Sequence<>.elementsEqual<A>(_:)( unint64_t a1, uint64_t a2, uint64_t a3, const char *a4, const char *a5, uint64_t a6)
{
  uint64_t v70 = a4;
  uint64_t v59 = a5;
  uint64_t v60 = a6;
  uint64_t v62 = (void (*)(const char *, unint64_t))a2;
  unint64_t v63 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v54 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v54 - v13;
  uint64_t v17 = type metadata accessor for Optional((const char *)0xFF, AssociatedTypeWitness, v15, v16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v17, v17, 0LL, 0LL);
  uint64_t v18 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v20 = (char *)&v54 - v19;
  uint64_t v67 = *(void *)(v17 - 8);
  uint64_t v68 = v17;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v54 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v64 = (char *)&v54 - v24;
  uint64_t v57 = a3;
  uint64_t v61 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v23);
  uint64_t v58 = (char *)&v54 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v72 = swift_getAssociatedTypeWitness( 0LL,  a5,  v26,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v55 = *(void *)(v72 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v72);
  uint64_t v71 = (char *)&v54 - v28;
  uint64_t v29 = (uint64_t)v62;
  uint64_t v56 = *((void *)v62 - 1);
  MEMORY[0x1895F8858](v27);
  uint64_t v31 = (char *)&v54 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  BOOL v32 = v70;
  int64_t v33 = (const char *)swift_getAssociatedTypeWitness( 0LL,  v70,  v29,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v54 = *((void *)v33 - 1);
  MEMORY[0x1895F8858](v33);
  int64_t v35 = (char *)&v54 - v34;
  (*(void (**)(char *, char *, uint64_t))(v56 + 16))(v31, v69, v29);
  uint64_t v36 = (void (*)(uint64_t, const char *))*((void *)v32 + 4);
  int64_t v69 = v35;
  v36(v29, v32);
  uint64_t v37 = v57;
  (*(void (**)(char *, unint64_t, uint64_t))(v61 + 16))(v58, v63, v57);
  uint64_t v38 = (uint64_t)v59;
  (*((void (**)(uint64_t, const char *))v59 + 4))(v37, v59);
  unint64_t v39 = v70;
  uint64_t v70 = v33;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v39,  v29,  (uint64_t)v33,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v62 = *(void (**)(const char *, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v63 = AssociatedConformanceWitness;
  unint64_t v41 = swift_getAssociatedConformanceWitness( v38,  v37,  v72,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v61 = *(void *)(v41 + 16);
  uint64_t v42 = v65;
  while (1)
  {
    uint64_t v43 = v64;
    v62(v70, v63);
    ((void (*)(unint64_t, unint64_t))v61)(v72, v41);
    uint64_t v44 = &v20[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v45 = *(void (**)(char *, char *, uint64_t))(v67 + 32);
    uint64_t v46 = v43;
    uint64_t v47 = v68;
    v45(v20, v46, v68);
    v45(v44, v42, v47);
    uint64_t v48 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v9 + 48);
    if (v48(v20, 1LL, AssociatedTypeWitness) == 1) {
      break;
    }
    if (v48(v44, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, unint64_t))(v55 + 8))(v71, v72);
      (*(void (**)(char *, const char *))(v54 + 8))(v69, v70);
      (*(void (**)(char *, unint64_t))(v9 + 8))(v20, AssociatedTypeWitness);
      return 0LL;
    }

    unint64_t v49 = *(void (**)(char *, char *, unint64_t))(v9 + 32);
    v49(v14, v20, AssociatedTypeWitness);
    v49(v12, v44, AssociatedTypeWitness);
    char v50 = (*(uint64_t (**)(char *, char *, unint64_t))(v60 + 8))(v14, v12, AssociatedTypeWitness);
    uint64_t v51 = *(void (**)(char *, unint64_t))(v9 + 8);
    v51(v12, AssociatedTypeWitness);
    v51(v14, AssociatedTypeWitness);
    if ((v50 & 1) == 0)
    {
      (*(void (**)(char *, unint64_t))(v55 + 8))(v71, v72);
      (*(void (**)(char *, const char *))(v54 + 8))(v69, v70);
      return 0LL;
    }
  }

  (*(void (**)(char *, unint64_t))(v55 + 8))(v71, v72);
  (*(void (**)(char *, const char *))(v54 + 8))(v69, v70);
  uint64_t v52 = 1LL;
  if (v48(v44, 1LL, AssociatedTypeWitness) == 1) {
    return v52;
  }
  (*(void (**)(char *, uint64_t))(v67 + 8))(v44, v68);
  return 0LL;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <> DiscontiguousSlice<A>( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  return static DiscontiguousSlice<>.== infix(_:_:)( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24),  *(void *)(a4 - 8));
}

uint64_t DiscontiguousSlice<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v103 = a3;
  uint64_t v111 = a1;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v100 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v99 = (char *)&v84 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v7,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v110 = v9;
  uint64_t v98 = type metadata accessor for Range(0LL, v9, AssociatedConformanceWitness, v10);
  uint64_t v97 = *(void *)(v98 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v98);
  uint64_t v96 = (char *)&v84 - v12;
  uint64_t v115 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v116 = (char *)&v84 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v113 = v6;
  unint64_t v95 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v94 = *(void *)(v95 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v95);
  uint64_t v93 = (char *)&v84 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v92 = (char *)&v84 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v91 = (char *)&v84 - v18;
  uint64_t v109 = v7;
  uint64_t v118 = type metadata accessor for DiscontiguousSlice.Index(0LL, v7, v6, v19);
  uint64_t v112 = *(void *)(v118 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v118);
  uint64_t v108 = (char *)&v84 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v84 - v23;
  uint64_t v25 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v84 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a2, v28);
  uint64_t v31 = type metadata accessor for IndexingIterator(0LL, a2, WitnessTable, v30);
  uint64_t v32 = *(void *)(v31 - 8);
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  int64_t v35 = (char *)&v84 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v33);
  uint64_t v37 = (char *)&v84 - v36;
  Swift::UInt v38 = DiscontiguousSlice.count.getter(a2);
  Hasher._combine(_:)(v38);
  unint64_t v39 = *(void (**)(char *, uint64_t, uint64_t))(v25 + 16);
  v39(v27, v4, a2);
  uint64_t v89 = (void (*)(char *, char *, uint64_t))v39;
  v39(v35, (uint64_t)v27, a2);
  DiscontiguousSlice.startIndex.getter(a2, v40, v24);
  unint64_t v41 = *(void (**)(char *, uint64_t))(v25 + 8);
  uint64_t v90 = v27;
  uint64_t v42 = v27;
  uint64_t v43 = v37;
  uint64_t v88 = v41;
  v41(v42, a2);
  uint64_t v44 = &v35[*(int *)(v31 + 36)];
  uint64_t v45 = v112;
  uint64_t v87 = *(void (**)(char *, char *, uint64_t))(v112 + 32);
  v87(v44, v24, v118);
  uint64_t v84 = v32;
  (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v43, v35, v31);
  uint64_t v85 = v31;
  uint64_t v46 = &v43[*(int *)(v31 + 36)];
  uint64_t v102 = a2;
  uint64_t v117 = *(int *)(a2 + 36);
  uint64_t v47 = *(void (**)(uint64_t))(v113 + 72);
  unint64_t AssociatedConformanceWitness = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v107 = v47;
  uint64_t v48 = *(uint64_t (**)(char *, char *))(AssociatedConformanceWitness + 8);
  unint64_t v104 = *(void (**)(char *, char *, uint64_t))(v45 + 16);
  unint64_t v105 = v48;
  uint64_t v114 = v43;
  uint64_t v86 = v24;
  while (1)
  {
    uint64_t v49 = v118;
    v104(v24, v46, v118);
    uint64_t v50 = *(void *)(*(void *)&v43[v117] + 16LL);
    uint64_t v51 = v108;
    uint64_t v52 = v109;
    uint64_t v53 = &v108[*(int *)(v49 + 36)];
    uint64_t v54 = v24;
    uint64_t v55 = v113;
    v107(v109);
    *(void *)uint64_t v51 = v50;
    char v56 = v105(&v54[*(int *)(v49 + 36)], v53);
    uint64_t v57 = *(void (**)(char *, uint64_t))(v112 + 8);
    v57(v51, v49);
    v57(v54, v49);
    if ((v56 & 1) != 0) {
      break;
    }
    uint64_t v58 = v52;
    (*(void (**)(char *, char *, uint64_t))(v115 + 16))(v116, v43, v52);
    unint64_t v59 = *(void *)v46;
    if ((*(void *)v46 & 0x8000000000000000LL) != 0 || (uint64_t v60 = *(void *)&v43[v117], v59 >= *(void *)(v60 + 16))) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }
    uint64_t v61 = v97;
    uint64_t v62 = v96;
    uint64_t v63 = v98;
    (*(void (**)(char *, unint64_t, uint64_t))(v97 + 16))( v96,  v60 + ((*(unsigned __int8 *)(v97 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v97 + 80))
    + *(void *)(v97 + 72) * v59,
      v98);
    uint64_t v64 = v99;
    uint64_t v65 = v116;
    (*(void (**)(char *, uint64_t, uint64_t))(v55 + 88))(v62, v58, v55);
    uint64_t v66 = v62;
    uint64_t v67 = v115;
    (*(void (**)(char *, uint64_t))(v61 + 8))(v66, v63);
    (*(void (**)(char *, uint64_t))(v67 + 8))(v65, v58);
    uint64_t v68 = v118;
    int64_t v69 = &v46[*(int *)(v118 + 36)];
    uint64_t v70 = v55;
    unint64_t v71 = AssociatedTypeWitness;
    unint64_t v72 = swift_getAssociatedConformanceWitness( v70,  v58,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    uint64_t v73 = (void (*)(char *, void))(*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v72 + 80))( v119,  v69,  v71,  v72);
    uint64_t v74 = v94;
    uint64_t v75 = v92;
    unint64_t v76 = v95;
    (*(void (**)(char *))(v94 + 16))(v92);
    v73(v119, 0LL);
    (*(void (**)(char *, unint64_t))(v100 + 8))(v64, v71);
    uint64_t v77 = v90;
    uint64_t v78 = v102;
    v89(v90, v114, v102);
    uint64_t v24 = v86;
    DiscontiguousSlice.index(after:)(v78, (uint64_t *)v86);
    v88(v77, v78);
    v57(v46, v68);
    v87(v46, v24, v68);
    uint64_t v79 = *(void (**)(char *, char *, unint64_t))(v74 + 32);
    unint64_t v80 = v91;
    v79(v91, v75, v76);
    uint64_t v81 = v93;
    v79(v93, v80, v76);
    (*(void (**)(uint64_t, unint64_t))(v103 + 24))(v111, v76);
    uint64_t v82 = v81;
    uint64_t v43 = v114;
    (*(void (**)(char *, unint64_t))(v74 + 8))(v82, v76);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v84 + 8))(v43, v85);
}

uint64_t DiscontiguousSlice.count.getter(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v4,  v3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v42 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v43 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v41 = (char *)&v39 - v6;
  unint64_t v7 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v4,  v3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v4,  v3,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v10 = type metadata accessor for Range(0LL, v7, AssociatedConformanceWitness, v9);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v39 - v15;
  uint64_t v17 = *(int *)(a1 + 36);
  uint64_t v44 = v1;
  uint64_t v18 = *(unint64_t **)(v1 + v17);
  swift_retain(v18, v19, v20, v21);
  unint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  while (1)
  {
    unint64_t v24 = v18[2];
    if (v22 == v24) {
      break;
    }
    if (v22 >= v24) {
      goto LABEL_7;
    }
    (*(void (**)(char *, unint64_t, uint64_t))(v11 + 16))( v14,  (unint64_t)v18 + ((*(unsigned __int8 *)(v11 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))
    + *(void *)(v11 + 72) * v22++,
      v10);
    (*(void (**)(char *, char *, uint64_t))(v11 + 32))(v16, v14, v10);
    uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v4 + 88);
    uint64_t v40 = v14;
    uint64_t v26 = v41;
    v25(v16, v3, v4);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v16, v10);
    uint64_t v27 = v4;
    uint64_t v28 = v3;
    unint64_t v39 = v16;
    uint64_t v29 = v10;
    uint64_t v30 = v4;
    uint64_t v31 = v3;
    uint64_t v32 = v43;
    unint64_t v33 = swift_getAssociatedConformanceWitness( v27,  v28,  v43,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    uint64_t v34 = (*(uint64_t (**)(uint64_t, unint64_t))(v33 + 112))(v32, v33);
    int64_t v35 = v26;
    uint64_t v36 = v32;
    uint64_t v3 = v31;
    uint64_t v4 = v30;
    uint64_t v10 = v29;
    uint64_t v16 = v39;
    uint64_t v14 = v40;
    (*(void (**)(char *, uint64_t))(v42 + 8))(v35, v36);
    BOOL v37 = __OFADD__(v23, v34);
    v23 += v34;
    if (v37)
    {
      __break(1u);
LABEL_7:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }
  }

  swift_release((uint64_t)v18);
  return v23;
}

Swift::Int DiscontiguousSlice<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice<>.hashValue.getter( a1,  a2,  (void (*)(void *, uint64_t, uint64_t))DiscontiguousSlice<>.hash(into:));
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> DiscontiguousSlice<A>( uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DiscontiguousSlice<>.hash(into:)(a1, a2, *(void *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 - 8);
  v5[0] = 0LL;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  void v5[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v5[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  DiscontiguousSlice<>.hash(into:)((uint64_t)v5, a2, v3);
  return Hasher._finalize()();
}

uint64_t DiscontiguousSlice.description.getter(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v4 = *(const char **)(v2 + 8);
  uint64_t v159 = v3;
  uint64_t v160 = (const char *)v2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v151 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v162 = (char *)&v139 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v150 = (uint64_t)&v139 - v8;
  uint64_t v10 = type metadata accessor for DiscontiguousSlice.Index(0LL, v3, v2, v9);
  unint64_t v161 = *(void **)(v10 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v158 = (char *)&v139 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v139 - v14;
  uint64_t v16 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v139 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a1, v19);
  uint64_t v22 = type metadata accessor for IndexingIterator(0LL, a1, WitnessTable, v21);
  uint64_t v140 = *(void *)(v22 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v139 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  unint64_t v27 = (unint64_t)&v139 - v26;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v165 = 91LL;
  unint64_t v166 = 0xE100000000000000LL;
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  v28(v18, v157, a1);
  uint64_t v147 = (void (*)(char *, unint64_t, uint64_t))v28;
  v28(v25, (uint64_t)v18, a1);
  DiscontiguousSlice.startIndex.getter(a1, v29, v15);
  uint64_t v30 = *(void (**)(char *, uint64_t))(v16 + 8);
  uint64_t v148 = v18;
  uint64_t v146 = v30;
  v30(v18, a1);
  uint64_t v31 = &v25[*(int *)(v22 + 36)];
  BOOL v145 = (void (*)(char *, char *, uint64_t))v161[4];
  v145(v31, v15, v10);
  (*(void (**)(unint64_t, char *, uint64_t))(v140 + 32))(v27, v25, v22);
  uint64_t v139 = v22;
  uint64_t v32 = (char *)(v27 + *(int *)(v22 + 36));
  uint64_t v149 = a1;
  uint64_t v33 = *(int *)(a1 + 36);
  uint64_t v35 = v159;
  uint64_t v34 = v160;
  unint64_t v156 = (void (*)(uint64_t, const char *))*((void *)v160 + 9);
  uint64_t v157 = v33;
  unint64_t v155 = swift_getAssociatedTypeWitness( 0LL,  v160,  v159,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v154 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v34,  v35,  v155,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                   + 8);
  unint64_t v153 = *(uint64_t (**)(char *, char *))(v154 + 8);
  uint64_t v152 = (void (*)(char *, char *, uint64_t))v161[2];
  char v36 = 1;
  __int128 v144 = xmmword_1817FFC60;
  __int128 v141 = xmmword_1817FFC70;
  unint64_t v143 = AssociatedTypeWitness;
  v152(v15, v32, v10);
  while (1)
  {
    unint64_t v43 = v158;
    uint64_t v44 = *(void *)(*(void *)(v27 + v157) + 16LL);
    uint64_t v45 = &v158[*(int *)(v10 + 36)];
    v156(v159, v160);
    *(void *)unint64_t v43 = v44;
    char v46 = v153(&v15[*(int *)(v10 + 36)], v45);
    uint64_t v47 = (void (*)(char *, uint64_t))v161[1];
    v47(v43, v10);
    v47(v15, v10);
    if ((v46 & 1) != 0) {
      break;
    }
    uint64_t v48 = v150;
    uint64_t v49 = v149;
    DiscontiguousSlice.subscript.getter(v32, v149, v150);
    uint64_t v50 = v148;
    v147(v148, v27, v49);
    DiscontiguousSlice.index(after:)(v49, (uint64_t *)v15);
    v146(v50, v49);
    v47(v32, v10);
    v145(v32, v15, v10);
    uint64_t v51 = *(void (**)(char *, uint64_t, unint64_t))(v151 + 32);
    unint64_t v39 = v162;
    v51(v162, v48, AssociatedTypeWitness);
    if ((v36 & 1) == 0)
    {
      uint64_t v55 = v165;
      uint64_t v54 = v166;
      unint64_t v56 = HIBYTE(v166) & 0xF;
      if ((v166 & 0x2000000000000000LL) != 0) {
        unint64_t v57 = HIBYTE(v166) & 0xF;
      }
      else {
        unint64_t v57 = v165 & 0xFFFFFFFFFFFFLL;
      }
      if (!v57 && (v165 & ~v166 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v166);
        uint64_t v165 = 8236LL;
        unint64_t v90 = 0xE200000000000000LL;
        goto LABEL_44;
      }

      if ((v166 & 0x2000000000000000LL) != 0 && v56 <= 0xD)
      {
        unint64_t v58 = 8 * (HIBYTE(v166) & 7);
        uint64_t v59 = (-255LL << v58) - 1;
        uint64_t v60 = 44LL << v58;
        char v61 = v56 + 1;
        if (v56 >= 8)
        {
          uint64_t v62 = v60 | v59 & v166;
LABEL_38:
          uint64_t v89 = (32LL << (8 * (v61 & 7u))) | ((-255LL << (8 * (v61 & 7u))) - 1) & v62;
        }

        else
        {
          uint64_t v55 = v60 | v59 & v165;
          if (v56 == 7)
          {
            char v61 = 8;
            uint64_t v62 = v166;
            goto LABEL_38;
          }

          uint64_t v55 = (32LL << (8 * (v61 & 7u))) | ((-255LL << (8 * (v61 & 7u))) - 1) & v55;
          uint64_t v89 = v166;
        }

        swift_bridgeObjectRelease(v166);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v91 = 0xE000000000000000LL;
        if (v55 & 0x8080808080808080LL | v89 & 0x80808080808080LL) {
          unint64_t v91 = 0xA000000000000000LL;
        }
        unint64_t v90 = (v91 & 0xFF00000000000000LL | (v56 << 56) | v89 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
        uint64_t v165 = v55;
LABEL_44:
        unint64_t v166 = v90;
LABEL_45:
        unint64_t AssociatedTypeWitness = v143;
LABEL_3:
        unint64_t v39 = v162;
        goto LABEL_4;
      }

      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v52, v53);
      if ((v54 & 0x1000000000000000LL) != 0) {
        unint64_t v57 = String.UTF8View._foreignCount()();
      }
      BOOL v63 = __OFADD__(v57, 2LL);
      uint64_t v64 = v57 + 2;
      unint64_t AssociatedTypeWitness = v143;
      if (v63)
      {
        __break(1u);
LABEL_105:
        Swift::Int v131 = String.UTF8View._foreignCount()();
        uint64_t v95 = v131 + 1;
        if (!__OFADD__(v131, 1LL)) {
          goto LABEL_58;
        }
LABEL_107:
        __break(1u);
LABEL_108:
        if ((v95 & 0x1000000000000000LL) != 0)
        {
          uint64_t v64 = _StringGuts._foreignConvertedToSmall()(v64, v95);
          uint64_t v137 = v136;
          swift_bridgeObjectRelease(v95);
          uint64_t v95 = v137;
        }

        else
        {
          if ((v64 & 0x1000000000000000LL) != 0)
          {
            uint64_t v132 = (unsigned __int8 *)((v95 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v133 = v64 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v132 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v64, v95);
          }

          closure #1 in _StringGuts._convertedToSmall()(v132, v133, &v163);
          swift_bridgeObjectRelease(v95);
          uint64_t v95 = *((void *)&v163 + 1);
          uint64_t v64 = v163;
        }

        goto LABEL_81;
      }

      if ((v55 & ~v54 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v54 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v65 = _StringGuts.nativeUnusedCapacity.getter(v55, v54);
        if ((v66 & 1) != 0) {
          goto LABEL_118;
        }
        BOOL v68 = (v54 & 0x2000000000000000LL) == 0 && v65 > 1;
        if (v64 > 15 || v68) {
          goto LABEL_2;
        }
      }

      else if (v64 > 15)
      {
LABEL_2:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v64, 2LL);
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
        __int128 v163 = v141;
        BOOL v37 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v163, 2LL);
        _StringGuts.appendInPlace(_:isASCII:)(v37, v38, 1);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        goto LABEL_3;
      }

      swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
      swift_bridgeObjectRetain(v54, v69, v70, v71);
      unint64_t v72 = _StringGuts._convertedToSmall()(v55, v54);
      unint64_t v142 = v73;
      swift_bridgeObjectRelease(v54);
      v74._rawBits = 131073LL;
      v75._rawBits = 1LL;
      v76._rawBits = _StringGuts.validateScalarRange(_:)(v75, v74, 0x202CuLL, 0xE200000000000000LL);
      if (v76._rawBits < 0x10000) {
        v76._rawBits |= 3;
      }
      unint64_t v78 = specialized String.init(_:)(v76, v77, 0x202CuLL, 0xE200000000000000LL);
      unint64_t v80 = v79;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v81 = _StringGuts._convertedToSmall()(v78, v80);
      unint64_t v83 = v82;
      swift_bridgeObjectRelease(v80);
      unint64_t v84 = specialized _SmallString.init(_:appending:)(v72, v142, v81, v83);
      if ((v86 & 1) != 0) {
        goto LABEL_117;
      }
      uint64_t v87 = v84;
      unint64_t v88 = v85;
      swift_bridgeObjectRelease(v54);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v165 = v87;
      unint64_t v166 = v88;
      goto LABEL_45;
    }

LABEL_117:
    unint64_t v135 = 266LL;
    goto LABEL_119;
  }

  swift_bridgeObjectRelease(v166);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v48;
}

  uint64_t v10 = v3;
  unint64_t v114 = _StringGuts.nativeUnusedCapacity.getter(v111, v7);
  uint64_t v3 = (v115 & 1) == 0 && v114 >= v110;
  if ((v111 & ~v7 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v14 = v307;
    if ((v3 & 1) != 0) {
      goto LABEL_134;
    }
    goto LABEL_128;
  }

  uint64_t v14 = v307;
  if (!(_DWORD)v3)
  {
LABEL_128:
    unint64_t v117 = _StringGuts.nativeCapacity.getter(v111, v7);
    if ((v118 & 1) != 0) {
      char v119 = 0LL;
    }
    else {
      char v119 = v117;
    }
    if (v119 + 0x4000000000000000LL < 0)
    {
      __break(1u);
LABEL_333:
      uint64_t v134 = _StringObject.sharedUTF8.getter(v18, v19);
      uint64_t v136 = v292;
      swift_bridgeObjectRelease(v19);
      if (v136 < v304) {
LABEL_311:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      uint64_t v14 = v307;
      uint64_t v22 = v303;
      unint64_t v135 = v304;
      goto LABEL_156;
    }

    uint64_t v120 = 2 * v119;
    if (v120 > v30) {
      uint64_t v30 = v120;
    }
LABEL_134:
    _StringGuts.grow(_:)(v30);
  }

  swift_bridgeObjectRelease_n(v19, 4LL);
  if ((v19 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v19);
    uint64_t v7 = (unint64_t)&v310;
    _StringGuts._foreignAppendInPlace(_:)(v18, v19, 0LL, v10);
    swift_bridgeObjectRelease_n(v19, 2LL);
    goto LABEL_182;
  }

  if (v22)
  {
    swift_bridgeObjectRelease_n(v19, 2LL);
    v308 = v18;
    v309 = v19 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v121 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v4, (uint64_t)&v308, v4);
    uint64_t v7 = (unint64_t)&v310;
    _StringGuts.appendInPlace(_:isASCII:)(v121, v122, (v19 & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease(v19);
    goto LABEL_182;
  }

  if ((v18 & 0x1000000000000000LL) == 0) {
    goto LABEL_333;
  }
  swift_bridgeObjectRelease(v19);
  uint64_t v134 = (id)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v22 = v303;
  unint64_t v135 = v304;
  uint64_t v136 = v304;
LABEL_156:
  uint64_t v137 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v135, (uint64_t)v134, v136);
  uint64_t v7 = (unint64_t)&v310;
  _StringGuts.appendInPlace(_:isASCII:)(v137, v138, v18 < 0);
  swift_bridgeObjectRelease_n(v19, 2LL);
  if (v14 != 1) {
    goto LABEL_184;
  }
  return v310;
}

  Swift::Int v131 = v33 & 0xFFFFFFFFFFFF0000LL | 1;
  swift_bridgeObjectRetain_n(v32, 3LL, v34, (char *)v35);
  v132._rawBits = v28 & 0xFFFFFFFFFFFF0000LL | 1;
  v133._rawBits = v131;
  v134._rawBits = _StringGuts.validateScalarRange(_:)(v132, v133, v27, v32);
  if (v134._rawBits < 0x10000) {
    v134._rawBits |= 3;
  }
  unint64_t v79 = v27;
  unint64_t v80 = specialized Collection.count.getter(v134, v135, v27, v32);
  swift_bridgeObjectRelease(v32);
  unint64_t v82 = v144;
  unint64_t v81 = v145;
  if ((v145 & 0x1000000000000000LL) != 0) {
    goto LABEL_120;
  }
LABEL_66:
  if ((v81 & 0x2000000000000000LL) == 0)
  {
    unint64_t v83 = (v82 & 0xFFFFFFFFFFFFLL) + v80;
    if (!__OFADD__(v82 & 0xFFFFFFFFFFFFLL, v80)) {
      goto LABEL_71;
    }
LABEL_122:
    __break(1u);
    goto LABEL_123;
  }

  unint64_t v84 = HIBYTE(v81) & 0xF;
  unint64_t v83 = v84 + v80;
  if (__OFADD__(v84, v80)) {
    goto LABEL_122;
  }
LABEL_71:
  if ((v82 & ~v81 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v81 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v83 > 15) {
      goto LABEL_77;
    }
LABEL_83:
    swift_bridgeObjectRelease(v32);
    swift_bridgeObjectRetain(v81, v91, v92, v93);
    unint64_t v94 = _StringGuts._convertedToSmall()(v82, v81);
    uint64_t v96 = v95;
    swift_bridgeObjectRelease(v81);
    int64_t v97 = HIBYTE(v32) & 0xF;
    if ((v32 & 0x2000000000000000LL) == 0) {
      int64_t v97 = v79 & 0xFFFFFFFFFFFFLL;
    }
    if (v97 >= v37)
    {
      if ((v28 & 0xFFFFFFFFFFFF0000LL | 1) >= 0x10000) {
        v98._rawBits = v28 & 0xFFFFFFFFFFFF0000LL | 1;
      }
      else {
        v98._rawBits = v28 & 0xFFFFFFFFFFFF0000LL | 3;
      }
      if (v98._rawBits >> 16 || v37 != v97)
      {
        v99._rawBits = v141._rawBits & 0xFFFFFFFFFFFF0000LL | 1;
        unint64_t v79 = specialized static String._copying(_:)(v98, v99, v79, v32);
        unint64_t v101 = v100;
        swift_bridgeObjectRelease(v32);
        uint64_t v32 = v101;
      }

      BOOL v102 = _StringGuts._convertedToSmall()(v79, v32);
      uint64_t v104 = v103;
      swift_bridgeObjectRelease(v32);
      unint64_t v105 = HIBYTE(v96) & 0xF;
      Swift::String::Index v106 = HIBYTE(v104) & 0xF;
      Swift::String::Index v107 = v106 + v105;
      if ((unint64_t)(v106 + v105) <= 0xF)
      {
        if (v106)
        {
          Swift::String::Index v108 = 0;
          Swift::String::Index v109 = 0LL;
          do
          {
            uint64_t v110 = v105 + v109;
            uint64_t v111 = v109 + 1;
            if (v109 >= 8) {
              uint64_t v112 = v104;
            }
            else {
              uint64_t v112 = v102;
            }
            char v113 = v112 >> (v108 & 0x38);
            unint64_t v114 = (8 * v105 + v108) & 0x38;
            unint64_t v115 = (-255LL << v114) - 1;
            unint64_t v116 = (unint64_t)v113 << v114;
            unint64_t v117 = v116 | v115 & v96;
            unint64_t v118 = v116 | v115 & v94;
            if (v110 < 8) {
              unint64_t v94 = v118;
            }
            else {
              uint64_t v96 = v117;
            }
            v108 += 8;
            Swift::String::Index v109 = v111;
          }

          while (v106 != v111);
        }

        swift_bridgeObjectRelease(v81);
        char v119 = 0xA000000000000000LL;
        if (!(v94 & 0x8080808080808080LL | v96 & 0x80808080808080LL)) {
          char v119 = 0xE000000000000000LL;
        }
        __int128 v144 = v94;
        BOOL v145 = v119 & 0xFF00000000000000LL | (v107 << 56) | v96 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_109;
      }

      goto LABEL_128;
    }

  uint64_t v21 = 0;
  uint64_t v8 = 0;
LABEL_118:
  char v100 = v8;
  return v21 | ((unint64_t)v100 << 32) | (((a2 >> 60) & 1) << 40);
}

  uint64_t v21 = 0;
  uint64_t v8 = 0;
LABEL_118:
  char v100 = v8;
  return v21 | ((unint64_t)v100 << 32) | (((a2 >> 60) & 1) << 40);
}

  uint64_t result = 0LL;
  uint64_t v8 = 0;
LABEL_118:
  uint64_t v103 = v8;
LABEL_119:
  LOBYTE(v102[0]) = (a2 & 0x1000000000000000LL) != 0;
  return result;
}

  uint64_t result = 0LL;
  uint64_t v8 = 0;
LABEL_118:
  BOOL v102 = v8;
LABEL_119:
  LOBYTE(v101[0]) = (a2 & 0x1000000000000000LL) != 0;
  return result;
}

    uint64_t v124 = v118 & 0xFFFFFFFFFFFF0000LL;
    unint64_t v123 = 1LL;
    goto LABEL_118;
  }

  if ((v125 & 0x1000000000000000LL) != 0)
  {
    uint64_t v127 = (char *)((v126 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v128 = v125 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v127 = (char *)_StringObject.sharedUTF8.getter(v17[2], v17[3]);
  }

  if (v119 + 1 == v128) {
    goto LABEL_117;
  }
  if (!v127) {
    goto LABEL_225;
  }
  size_t v129 = *(unsigned __int16 *)&v127[v119];
LABEL_115:
  if (v129 != 2573 && (v129 & 0x80808080) == 0) {
    goto LABEL_117;
  }
LABEL_164:
  unint64_t v123 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v119);
  uint64_t v124 = v118 & 0xFFFFFFFFFFFF0000LL;
  if (v123 <= 63) {
LABEL_118:
  }
    v124 |= v123 << 8;
  uint64_t v130 = v124 | 5;
  if ((v118 & 2) != 0 && (v119 < v18 || _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v124 | 5)))) {
    uint64_t v130 = v124 | 7;
  }
  *uint64_t v17 = v130;
LABEL_124:
  if (v120) {
LABEL_125:
  }
    v17[1] = (v121 << 16) | 5;
}

        uint64_t v229 = v225 & 0xFFFFFFFFFFFFLL;
        goto LABEL_130;
      }

      if ((v222 & 0x2000000000000000LL) == 0) {
        goto LABEL_117;
      }
      v250 = specialized _SmallString.init(_:appending:)(v566, v567, v225, v222);
      if ((v252 & 1) != 0)
      {
        uint64_t v229 = HIBYTE(v226) & 0xF;
        unint64_t v162 = v558;
        uint64_t v151 = v559;
        goto LABEL_130;
      }

      v253 = v250;
      uint64_t v254 = v251;
      swift_bridgeObjectRelease(v227);
      v566 = v253;
      v567 = v254;
      unint64_t v162 = v558;
      uint64_t v151 = v559;
LABEL_131:
      swift_bridgeObjectRelease(v226);
      goto LABEL_132;
    }

    goto LABEL_128;
  }

  uint64_t v230 = v540;
  memcpy(v540, v214, v2);
  if ((swift_dynamicCast((char *)&v560, v230, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t v235 = v560._countAndFlagsBits;
    unint64_t v234 = v560._object;
    unint64_t v236 = v567;
    uint64_t v237 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000LL) == 0) {
      uint64_t v237 = v566 & 0xFFFFFFFFFFFFLL;
    }
    if (v237 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v560._countAndFlagsBits, (unint64_t)v560._object);
    }

    else
    {
      swift_bridgeObjectRetain((unint64_t)v560._object, v231, v232, v233);
      swift_bridgeObjectRelease(v236);
      v566 = v235;
      v567 = (unint64_t)v234;
    }

    swift_bridgeObjectRelease((uint64_t)v234);
  }

  else
  {
    uint64_t v238 = v531;
    memcpy(v531, v214, v2);
    uint64_t v239 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v238, v1, v239, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      uint64_t v240 = (uint64_t)v561;
      __int128 v241 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v241 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v240,  v241);
LABEL_132:
      __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
      goto LABEL_133;
    }

    v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v242 = v523;
    memcpy(v523, v214, v2);
    v243 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v242, v1, v243, 6uLL)
      || (v565 = 0LL,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  v244 = v513,  memcpy(v513, v214, v2),  uint64_t v245 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v244, v1, v245, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      __int128 v246 = (uint64_t)v561;
      int v247 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      uint64_t v248 = (*(uint64_t (**)(uint64_t, uint64_t))(v247 + 8))(v246, v247);
      uint64_t v225 = v248;
      unint64_t v226 = v222;
      uint64_t v227 = v567;
      v249 = HIBYTE(v567) & 0xF;
      if ((v567 & 0x2000000000000000LL) == 0) {
        v249 = v566 & 0xFFFFFFFFFFFFLL;
      }
      if (v249 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
      {
        _StringGuts.append(_:)(v248, v222);
        goto LABEL_131;
      }

              if (v71 == v245)
              {
                uint64_t v263 = &v260;
                (*(void (**)(void *, uint64_t *))(v245[0] + 24LL))(v245, &v260);
              }

              else
              {
                uint64_t v263 = (uint64_t *)(*(uint64_t (**)(void *))(*v71 + 16LL))(v71);
              }

uint64_t static DiscontiguousSlice.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(int *)(type metadata accessor for DiscontiguousSlice.Index(0LL, a3, (uint64_t)a4, v9) + 36);
  uint64_t v11 = a1 + v10;
  uint64_t v12 = a2 + v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                       + 8LL))( v11,  v12,  AssociatedTypeWitness) & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance DiscontiguousSlice<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static DiscontiguousSlice.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(const char **)(a3 + 24));
}

uint64_t DiscontiguousSlice.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return v5(a1, AssociatedTypeWitness, a3);
}

Swift::Int DiscontiguousSlice.Index<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  uint64_t v3 = *(void (**)(void *, unint64_t, uint64_t))(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  v3(v6, AssociatedTypeWitness, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> DiscontiguousSlice<A>.Index( uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice.Index<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> DiscontiguousSlice<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DiscontiguousSlice.Index<>.hash(into:)(a1, a2, *(void *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> DiscontiguousSlice<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 - 8);
  v5[0] = 0LL;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  void v5[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v5[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  DiscontiguousSlice.Index<>.hash(into:)((uint64_t)v5, a2, v3);
  return Hasher._finalize()();
}

uint64_t static DiscontiguousSlice.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(int *)(type metadata accessor for DiscontiguousSlice.Index(0LL, a3, (uint64_t)a4, v9) + 36);
  uint64_t v11 = a1 + v10;
  uint64_t v12 = a2 + v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16))( v11,  v12,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance DiscontiguousSlice<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static DiscontiguousSlice.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(const char **)(a3 + 24));
}

uint64_t DiscontiguousSlice.Index.description.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  Swift::Int v3 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t countAndFlagsBits = (uint64_t)&v284 - v4;
  uint64_t v6 = specialized static String._createEmpty(withInitialCapacity:)(27LL);
  uint64_t v10 = v6;
  unint64_t object = v7;
  v289._uint64_t countAndFlagsBits = v6;
  v289._unint64_t object = (void *)v7;
  unint64_t v12 = HIBYTE(v7) & 0xF;
  uint64_t v13 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000LL) != 0) {
    uint64_t v14 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v14 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (!v14 && (v6 & ~v7 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v289._uint64_t countAndFlagsBits = 0x203A657361623CLL;
    v289._unint64_t object = (void *)0xE700000000000000LL;
    goto LABEL_78;
  }

  if ((v7 & 0x2000000000000000LL) == 0 || v12 > 8)
  {
    swift_bridgeObjectRetain_n(0xE700000000000000LL, 6LL, v8, v9);
    if ((object & 0x1000000000000000LL) == 0)
    {
      Swift::Int v20 = v14 + 7;
      if (!__OFADD__(v14, 7LL)) {
        goto LABEL_13;
      }
      goto LABEL_303;
    }

    goto LABEL_301;
  }

  uint64_t v15 = 8 * HIBYTE(v7);
  uint64_t v16 = (-255LL << (v15 & 0x38)) - 1;
  uint64_t v17 = 60LL << (v15 & 0x38);
  if (v12 >= 8)
  {
    unint64_t v19 = v17 | v16 & v7;
    char v18 = 8;
    goto LABEL_32;
  }

  uint64_t v10 = v17 | v16 & v6;
  if (v12 == 7)
  {
    char v18 = 0;
    unint64_t v19 = v7;
LABEL_32:
    uint64_t v28 = (98LL << v18) | ((-255LL << v18) - 1) & v19;
    char v29 = v12 + 2;
LABEL_33:
    uint64_t v30 = (97LL << (8 * (v29 & 7u))) | ((-255LL << (8 * (v29 & 7u))) - 1) & v28;
    char v31 = v12 + 3;
LABEL_34:
    uint64_t v32 = (115LL << (8 * (v31 & 7u))) | ((-255LL << (8 * (v31 & 7u))) - 1) & v30;
    char v33 = v12 + 4;
LABEL_35:
    uint64_t v34 = (101LL << (8 * (v33 & 7u))) | ((-255LL << (8 * (v33 & 7u))) - 1) & v32;
    char v35 = v12 + 5;
LABEL_36:
    uint64_t v36 = (58LL << (8 * (v35 & 7u))) | ((-255LL << (8 * (v35 & 7u))) - 1) & v34;
    char v37 = v12 + 6;
LABEL_37:
    uint64_t v38 = (32LL << (8 * (v37 & 7u))) | ((-255LL << (8 * (v37 & 7u))) - 1) & v36;
    goto LABEL_38;
  }

  uint64_t v10 = (98LL << ((v15 + 8) & 0x38)) | ((-255LL << ((v15 + 8) & 0x38)) - 1) & v10;
  if (v12 >= 6)
  {
    char v29 = 8;
    uint64_t v28 = v7;
    goto LABEL_33;
  }

  uint64_t v10 = (97LL << ((v15 + 16) & 0x38)) | ((-255LL << ((v15 + 16) & 0x38)) - 1) & v10;
  if (v12 == 5)
  {
    char v31 = 8;
    uint64_t v30 = v7;
    goto LABEL_34;
  }

  uint64_t v10 = (115LL << ((v15 + 24) & 0x38)) | ((-255LL << ((v15 + 24) & 0x38)) - 1) & v10;
  if (v12 >= 4)
  {
    char v33 = 8;
    uint64_t v32 = v7;
    goto LABEL_35;
  }

  uint64_t v10 = (101LL << ((v15 + 32) & 0x38)) | ((-255LL << ((v15 + 32) & 0x38)) - 1) & v10;
  if (v12 == 3)
  {
    char v35 = 8;
    uint64_t v34 = v7;
    goto LABEL_36;
  }

  uint64_t v10 = (58LL << ((v15 + 40) & 0x38)) | ((-255LL << ((v15 + 40) & 0x38)) - 1) & v10;
  if (v12 >= 2)
  {
    char v37 = 8;
    uint64_t v36 = v7;
    goto LABEL_37;
  }

  uint64_t v10 = (32LL << ((v15 + 48) & 0x38)) | ((-255LL << ((v15 + 48) & 0x38)) - 1) & v10;
  uint64_t v38 = v7;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE700000000000000LL);
  unint64_t v39 = 0xA000000000000000LL;
  if (!(v10 & 0x8080808080808080LL | v38 & 0x80808080808080LL)) {
    unint64_t v39 = 0xE000000000000000LL;
  }
  uint64_t v40 = (void *)((v39 & 0xFF00000000000000LL | (v12 << 56) | v38 & 0xFFFFFFFFFFFFFFLL) + 0x700000000000000LL);
LABEL_77:
  v289._uint64_t countAndFlagsBits = v10;
  v289._unint64_t object = v40;
LABEL_78:
  (*(void (**)(uint64_t, char *, uint64_t))(v3 + 16))( countAndFlagsBits,  (char *)v287 + *(int *)(v1 + 36),  AssociatedTypeWitness);
  *(void *)&__int128 v288 = 0LL;
  *((void *)&v288 + 1) = 0xE000000000000000LL;
  _debugPrint_unlocked<A, B>(_:_:)( countAndFlagsBits,  (uint64_t)&v288,  (swift *)AssociatedTypeWitness,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  (*(void (**)(uint64_t, uint64_t))(v3 + 8))(countAndFlagsBits, AssociatedTypeWitness);
  uint64_t AssociatedTypeWitness = *((void *)&v288 + 1);
  uint64_t v1 = v288;
  uint64_t countAndFlagsBits = v289._countAndFlagsBits;
  unint64_t object = (unint64_t)v289._object;
  unint64_t v76 = ((unint64_t)v289._object >> 56) & 0xF;
  unint64_t v56 = v289._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  else {
    unint64_t v77 = v289._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v77 && (v289._countAndFlagsBits & ~(uint64_t)v289._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v289._object);
    v289._uint64_t countAndFlagsBits = v1;
    v289._unint64_t object = (void *)AssociatedTypeWitness;
    goto LABEL_163;
  }

  unint64_t v58 = *((void *)&v288 + 1) & 0x2000000000000000LL;
  unint64_t v51 = HIBYTE(*((void *)&v288 + 1)) & 0xFLL;
  if (((uint64_t)v289._object & 0x2000000000000000LL) != 0 && v58)
  {
    unint64_t v78 = v76 + v51;
    if (v76 + v51 <= 0xF)
    {
      if (v51)
      {
        char v121 = 0;
        unint64_t v122 = 0LL;
        unint64_t v123 = (unint64_t)v289._object;
        do
        {
          unint64_t v124 = v76 + v122;
          unint64_t v125 = v122 + 1;
          if (v122 >= 8) {
            unint64_t v126 = *((void *)&v288 + 1);
          }
          else {
            unint64_t v126 = v288;
          }
          unint64_t v127 = v126 >> (v121 & 0x38);
          char v128 = (8 * v76 + v121) & 0x38;
          uint64_t v129 = (-255LL << v128) - 1;
          unint64_t v130 = (unint64_t)v127 << v128;
          unint64_t v131 = v130 | v129 & v123;
          unint64_t v132 = v130 | v129 & countAndFlagsBits;
          if (v124 < 8) {
            uint64_t countAndFlagsBits = v132;
          }
          else {
            unint64_t v123 = v131;
          }
          v121 += 8;
          unint64_t v122 = v125;
        }

        while (v51 != v125);
      }

      else
      {
        unint64_t v123 = (unint64_t)v289._object;
      }

      swift_bridgeObjectRelease((uint64_t)v289._object);
      swift_bridgeObjectRelease(AssociatedTypeWitness);
      unint64_t v138 = 0xA000000000000000LL;
      if (!(countAndFlagsBits & 0x8080808080808080LL | v123 & 0x80808080808080LL)) {
        unint64_t v138 = 0xE000000000000000LL;
      }
      for (unint64_t i = (void *)(v138 & 0xFF00000000000000LL | (v78 << 56) | v123 & 0xFFFFFFFFFFFFFFLL);
            ;
            unint64_t i = (void *)(v113 & 0xFF00000000000000LL | (v101 << 56) | v13 & 0xFFFFFFFFFFFFFFLL))
      {
        v289._uint64_t countAndFlagsBits = countAndFlagsBits;
        v289._unint64_t object = i;
LABEL_163:
        Swift::String v141 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", rangeOffset: ", 0xFuLL, 1);
        uint64_t countAndFlagsBits = v141._countAndFlagsBits;
        uint64_t AssociatedTypeWitness = (uint64_t)v141._object;
        uint64_t v13 = v289._countAndFlagsBits;
        unint64_t object = (unint64_t)v289._object;
        unint64_t v142 = ((unint64_t)v289._object >> 56) & 0xF;
        unint64_t v143 = v289._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (!v143 && (v289._countAndFlagsBits & ~(uint64_t)v289._object & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease((uint64_t)v289._object);
          Swift::String v289 = v141;
          goto LABEL_215;
        }

        Swift::Int v3 = (uint64_t)v141._object & 0x2000000000000000LL;
        uint64_t v1 = ((unint64_t)v141._object >> 56) & 0xF;
        if (((uint64_t)v289._object & 0x2000000000000000LL) != 0 && v3)
        {
          unint64_t v144 = v142 + v1;
          if (v142 + v1 <= 0xF)
          {
            if (v1)
            {
              char v176 = 0;
              unint64_t v177 = 0LL;
              unint64_t v178 = (unint64_t)v289._object;
              do
              {
                unint64_t v179 = v142 + v177;
                unint64_t v180 = v177 + 1;
                if (v177 >= 8) {
                  unint64_t v181 = (unint64_t)v141._object;
                }
                else {
                  unint64_t v181 = v141._countAndFlagsBits;
                }
                unint64_t v182 = v181 >> (v176 & 0x38);
                char v183 = (8 * v142 + v176) & 0x38;
                uint64_t v184 = (-255LL << v183) - 1;
                unint64_t v185 = (unint64_t)v182 << v183;
                unint64_t v186 = v185 | v184 & v178;
                unint64_t v187 = v185 | v184 & v13;
                if (v179 < 8) {
                  uint64_t v13 = v187;
                }
                else {
                  unint64_t v178 = v186;
                }
                v176 += 8;
                unint64_t v177 = v180;
              }

              while (v1 != v180);
            }

            else
            {
              unint64_t v178 = (unint64_t)v289._object;
            }

            swift_bridgeObjectRelease((uint64_t)v289._object);
            swift_bridgeObjectRelease((uint64_t)v141._object);
            unint64_t v192 = 0xA000000000000000LL;
            if (!(v13 & 0x8080808080808080LL | v178 & 0x80808080808080LL)) {
              unint64_t v192 = 0xE000000000000000LL;
            }
            v289._uint64_t countAndFlagsBits = v13;
            v289._unint64_t object = (void *)(v192 & 0xFF00000000000000LL | (v144 << 56) | v178 & 0xFFFFFFFFFFFFFFLL);
            goto LABEL_215;
          }

          Swift::Int v3 = 1LL;
        }

        uint64_t v10 = v141._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (v3) {
          unint64_t v58 = ((unint64_t)v141._object >> 56) & 0xF;
        }
        else {
          unint64_t v58 = v141._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n((uint64_t)v141._object, 2LL, v139, v140);
        swift_bridgeObjectRetain_n((uint64_t)v141._object, 4LL, v81, v82);
        Swift::Int v147 = v58;
        if ((object & 0x1000000000000000LL) != 0) {
          goto LABEL_292;
        }
LABEL_176:
        if ((object & 0x2000000000000000LL) != 0)
        {
          uint64_t v149 = HIBYTE(object) & 0xF;
          uint64_t v148 = v149 + v147;
          if (!__OFADD__(v149, v147)) {
            goto LABEL_181;
          }
        }

        else
        {
          uint64_t v148 = (v13 & 0xFFFFFFFFFFFFLL) + v147;
          if (!__OFADD__(v13 & 0xFFFFFFFFFFFFLL, v147)) {
            goto LABEL_181;
          }
        }

LABEL_294:
        __break(1u);
LABEL_295:
        swift_bridgeObjectRetain_n(v148, 5LL, v145, v146);
        v263._rawBits = 1LL;
        v264._rawBits = (v10 << 16) | 1;
        v265._rawBits = _StringGuts.validateScalarRange(_:)(v263, v264, AssociatedTypeWitness, v148);
        if (v265._rawBits < 0x10000) {
          v265._rawBits |= 3;
        }
        Swift::Int v199 = specialized Collection.count.getter(v265, v266, AssociatedTypeWitness, v148);
        swift_bridgeObjectRelease(v148);
        if ((v1 & 0x1000000000000000LL) == 0) {
          goto LABEL_229;
        }
LABEL_298:
        Swift::Int v267 = String.UTF8View._foreignCount()();
        int64_t v200 = v267 + v199;
        if (!__OFADD__(v267, v199)) {
          goto LABEL_230;
        }
LABEL_300:
        __break(1u);
LABEL_301:
        Swift::Int v268 = String.UTF8View._foreignCount()();
        Swift::Int v20 = v268 + 7;
        if (!__OFADD__(v268, 7LL))
        {
LABEL_13:
          unint64_t v21 = v10 & ~object;
          if ((v21 & 0x2000000000000000LL) == 0
            || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v20 > 15) {
              goto LABEL_21;
            }
            if ((object & 0x2000000000000000LL) == 0) {
              goto LABEL_51;
            }
            goto LABEL_59;
          }

          int64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v10, object);
          if ((v23 & 1) == 0)
          {
            if (v20 > 15) {
              goto LABEL_21;
            }
            if ((object & 0x2000000000000000LL) == 0)
            {
              if (v22 <= 6)
              {
LABEL_51:
                swift_bridgeObjectRelease_n(0xE700000000000000LL, 5LL);
                if ((object & 0x1000000000000000LL) == 0)
                {
                  if ((v10 & 0x1000000000000000LL) != 0)
                  {
                    uint64_t v50 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
                  }

                  else
                  {
                    uint64_t v50 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, object);
                    uint64_t v13 = v47;
                  }

                  swift_bridgeObjectRetain(object, v47, v48, v49);
                  closure #1 in _StringGuts._convertedToSmall()(v50, v13, &v288);
                  swift_bridgeObjectRelease(object);
                  unint64_t v51 = *((void *)&v288 + 1);
                  uint64_t v10 = v288;
LABEL_60:
                  v52._rawBits = 1LL;
                  v53._rawBits = 458753LL;
                  v54._rawBits = _StringGuts.validateScalarRange(_:)( v52,  v53,  0x203A657361623CuLL,  0xE700000000000000LL);
                  if (v54._rawBits < 0x10000) {
                    v54._rawBits |= 3;
                  }
                  unint64_t v56 = specialized String.init(_:)(v54, v55, 0x203A657361623CuLL, 0xE700000000000000LL);
                  unint64_t v58 = v57;
                  swift_bridgeObjectRelease(0xE700000000000000LL);
                  if ((v58 & 0x2000000000000000LL) != 0)
                  {
                    swift_bridgeObjectRelease(v58);
                    goto LABEL_64;
                  }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    goto LABEL_112;
  }

  if ((v89->i16[0] & 0x8080) == 0)
  {
    uint64_t v89 = (uint8x16_t *)((char *)v89 + 2);
    goto LABEL_108;
  }

LABEL_313:
                  if ((v58 & 0x1000000000000000LL) != 0)
                  {
                    unint64_t v56 = _StringGuts._foreignConvertedToSmall()(v56, v58);
                    unint64_t v283 = v282;
                    swift_bridgeObjectRelease(v58);
                    unint64_t v58 = v283;
                  }

                  else
                  {
                    if ((v56 & 0x1000000000000000LL) != 0)
                    {
                      char v272 = (unsigned __int8 *)((v58 & 0xFFFFFFFFFFFFFFFLL) + 32);
                      uint64_t v273 = v56 & 0xFFFFFFFFFFFFLL;
                    }

                    else
                    {
                      char v272 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v56, v58);
                    }

                    closure #1 in _StringGuts._convertedToSmall()(v272, v273, &v288);
                    swift_bridgeObjectRelease(v58);
                    unint64_t v58 = *((void *)&v288 + 1);
                    unint64_t v56 = v288;
                  }

LABEL_326:
                  unint64_t v278 = 266LL;
LABEL_328:
                  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v278,  0);
                }

            Swift::String::Index v75 = 0LL;
          }

          unint64_t v249 = 353;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChild( this,  v249,  (swift::Demangle::__runtime::Node *)v75,  (uint64_t)v75,  a5);
        case 'b':
          uint64_t v189 = *((_DWORD *)this + 24);
          if (!v189) {
            goto LABEL_327;
          }
          uint64_t v190 = v189 - 1;
          size_t v191 = *((void *)this + 11);
          Swift::String::Index v75 = *(unsigned __int16 **)(v191 + 8LL * (v189 - 1));
          unint64_t v192 = v75[8];
          if (v192 == 232)
          {
            *((_DWORD *)this + 24) = v190;
          }

          else
          {
            if (v192 == 43)
            {
              *((_DWORD *)this + 24) = v190;
              else {
                *((_DWORD *)this + 24) = v193;
              }
              unint64_t v250 = 282;
              return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v250,  (swift::Demangle::__runtime::Node *)v78,  (swift::Demangle::__runtime::Node *)v75,  a5);
            }

LABEL_318:
                uint64_t v10 = _StringGuts._foreignConvertedToSmall()(v10, object);
                unint64_t v51 = v274;
                goto LABEL_60;
              }

LABEL_327:
          unint64_t v278 = 258LL;
          goto LABEL_328;
        }

            Swift::String::Index v75 = 0LL;
          }

          unint64_t v249 = 282;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChild( this,  v249,  (swift::Demangle::__runtime::Node *)v75,  (uint64_t)v75,  a5);
        case 'c':
          unint64_t v194 = *((_DWORD *)this + 24);
          if (!v194) {
            goto LABEL_328;
          }
          uint64_t v195 = v194 - 1;
          uint64_t v196 = *((void *)this + 11);
          Swift::String::Index v75 = *(unsigned __int16 **)(v196 + 8LL * (v194 - 1));
          unint64_t v197 = v75[8];
          if (v197 == 232)
          {
            *((_DWORD *)this + 24) = v195;
          }

          else
          {
            if (v197 == 43)
            {
              *((_DWORD *)this + 24) = v195;
              else {
                *((_DWORD *)this + 24) = v198;
              }
              unint64_t v250 = 283;
              return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v250,  (swift::Demangle::__runtime::Node *)v78,  (swift::Demangle::__runtime::Node *)v75,  a5);
            }

LABEL_303:
        __break(1u);
LABEL_304:
        if ((v1 & 0x1000000000000000LL) != 0)
        {
          uint64_t v10 = _StringGuts._foreignConvertedToSmall()(v10, v1);
          uint64_t v280 = v279;
          swift_bridgeObjectRelease(v1);
          uint64_t v1 = v280;
        }

        else
        {
          if ((v10 & 0x1000000000000000LL) != 0)
          {
            uint64_t v269 = (unsigned __int8 *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v270 = v10 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v269 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v1);
          }

          closure #1 in _StringGuts._convertedToSmall()(v269, v270, &v288);
          swift_bridgeObjectRelease(v1);
          uint64_t v1 = *((void *)&v288 + 1);
          uint64_t v10 = v288;
        }

LABEL_116:
        uint64_t v99 = HIBYTE(v13) & 0xF;
        uint64_t v100 = HIBYTE(v1) & 0xF;
        uint64_t v101 = v100 + v99;
        if (v100)
        {
          char v102 = 0;
          unint64_t v103 = 0LL;
          do
          {
            unint64_t v104 = v99 + v103;
            unint64_t v105 = v103 + 1;
            if (v103 >= 8) {
              unint64_t v106 = v1;
            }
            else {
              unint64_t v106 = v10;
            }
            unint64_t v107 = v106 >> (v102 & 0x38);
            char v108 = (8 * v99 + v102) & 0x38;
            uint64_t v109 = (-255LL << v108) - 1;
            unint64_t v110 = (unint64_t)v107 << v108;
            unint64_t v111 = v110 | v109 & v13;
            unint64_t v112 = v110 | v109 & countAndFlagsBits;
            if (v104 < 8) {
              uint64_t countAndFlagsBits = v112;
            }
            else {
              uint64_t v13 = v111;
            }
            v102 += 8;
            unint64_t v103 = v105;
          }

          while (v100 != v105);
        }

        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        unint64_t v113 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | v13 & 0x80808080808080LL)) {
          unint64_t v113 = 0xE000000000000000LL;
        }
      }
    }

    unint64_t v58 = 1LL;
  }

  uint64_t v285 = v288 & 0xFFFFFFFFFFFFLL;
  if (v58) {
    uint64_t v10 = HIBYTE(*((void *)&v288 + 1)) & 0xFLL;
  }
  else {
    uint64_t v10 = v288 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v288 + 1), 2LL, v74, v75);
  uint64_t v286 = v10;
  if ((AssociatedTypeWitness & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(AssociatedTypeWitness, 4LL, v79, v80);
    if ((object & 0x1000000000000000LL) == 0) {
      goto LABEL_92;
    }
LABEL_286:
    Swift::Int v257 = String.UTF8View._foreignCount()();
    Swift::Int v3 = v257 + v10;
    if (!__OFADD__(v257, v10)) {
      goto LABEL_93;
    }
    goto LABEL_288;
  }

  swift_bridgeObjectRetain_n(AssociatedTypeWitness, 5LL, v79, v80);
  v253._rawBits = 1LL;
  v254._rawBits = (v10 << 16) | 1;
  v255._rawBits = _StringGuts.validateScalarRange(_:)(v253, v254, v1, AssociatedTypeWitness);
  if (v255._rawBits < 0x10000) {
    v255._rawBits |= 3;
  }
  uint64_t v10 = specialized Collection.count.getter(v255, v256, v1, AssociatedTypeWitness);
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  if ((object & 0x1000000000000000LL) != 0) {
    goto LABEL_286;
  }
LABEL_92:
  BOOL v83 = __OFADD__(v77, v10);
  Swift::Int v3 = v77 + v10;
  if (!v83)
  {
LABEL_93:
    unint64_t v84 = countAndFlagsBits & ~object;
    if ((v84 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v85 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
      if ((v86 & 1) != 0) {
        goto LABEL_327;
      }
      if (v3 <= 15)
      {
        if ((object & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease_n(AssociatedTypeWitness, 5LL);
          uint64_t v13 = object;
          uint64_t v93 = v286;
          goto LABEL_112;
        }

        if (v85 >= v10) {
          goto LABEL_99;
        }
LABEL_110:
        swift_bridgeObjectRelease_n(AssociatedTypeWitness, 5LL);
        uint64_t v93 = v286;
        if ((object & 0x2000000000000000LL) != 0)
        {
          uint64_t v13 = object;
        }

        else if ((object & 0x1000000000000000LL) != 0)
        {
          uint64_t countAndFlagsBits = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, object);
          uint64_t v13 = v281;
        }

        else
        {
          if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
          {
            unint64_t v271 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            unint64_t v271 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
            unint64_t v56 = v90;
          }

          swift_bridgeObjectRetain(object, v90, v91, v92);
          closure #1 in _StringGuts._convertedToSmall()(v271, v56, &v288);
          swift_bridgeObjectRelease(object);
          uint64_t v13 = *((void *)&v288 + 1);
          uint64_t countAndFlagsBits = v288;
        }

LABEL_112:
        v94._rawBits = (v93 << 16) | 1;
        v95._rawBits = 1LL;
        v96._rawBits = _StringGuts.validateScalarRange(_:)(v95, v94, v1, AssociatedTypeWitness);
        if (v96._rawBits < 0x10000) {
          v96._rawBits |= 3;
        }
        uint64_t v10 = specialized String.init(_:)(v96, v97, v1, AssociatedTypeWitness);
        uint64_t v1 = v98;
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        if ((v1 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v1);
          goto LABEL_116;
        }

        goto LABEL_304;
      }
    }

    else if (v3 <= 15)
    {
      goto LABEL_110;
    }

      uint64_t v100 = String.UTF8View._foreignCount()();
      goto LABEL_71;
    }

  uint64_t v93 = 0LL;
  Swift::String::Index v94 = (uint8x16_t *)((char *)TypeName + v84);
  uint64_t v92 = 1;
  Swift::String::Index v95 = TypeName;
  Swift::String::Index v96 = TypeName;
  while (1)
  {
    uint64_t v99 = v96->i8[0];
    Swift::String::Index v96 = (uint8x16_t *)((char *)v96 + 1);
    uint64_t v98 = v99;
    if (v99 < 0) {
      break;
    }
    Swift::String::Index v97 = 1LL;
LABEL_114:
    v93 += v97;
    Swift::String::Index v95 = v96;
    if (v96 == v94)
    {
      if (v84 > 15) {
        goto LABEL_152;
      }
      goto LABEL_162;
    }
  }

  if (v98 <= 0xDFu)
  {
    if (v96 == v94 || (v96->i8[0] & 0xC0) != 0x80) {
      goto LABEL_153;
    }
    uint64_t v92 = 0;
    Swift::String::Index v96 = (uint8x16_t *)&v95->i16[1];
    Swift::String::Index v97 = 2LL;
    goto LABEL_114;
  }

  if (v98 == 224)
  {
    if (v96 == v94 || (v95->i8[1] & 0xE0) != 0xA0) {
      goto LABEL_153;
    }
    goto LABEL_132;
  }

  if (v98 <= 0xECu)
  {
LABEL_126:
    if (v96 == v94) {
      goto LABEL_153;
    }
    LOBYTE(v100) = v95->i8[1];
LABEL_131:
    if ((v100 & 0xC0) != 0x80) {
      goto LABEL_153;
    }
LABEL_132:
    uint64_t v92 = 0;
    Swift::String::Index v96 = (uint8x16_t *)((char *)v95->i32 + 3);
    Swift::String::Index v97 = 3LL;
    goto LABEL_114;
  }

  if (v98 == 237)
  {
    if (v96 == v94) {
      goto LABEL_153;
    }
    uint64_t v100 = v95->u8[1];
    if (v100 > 0x9F) {
      goto LABEL_153;
    }
    goto LABEL_131;
  }

  if (v98 <= 0xEFu) {
    goto LABEL_126;
  }
  if (v98 == 240)
  {
    goto LABEL_146;
  }

  if ((v98 + 15) <= 2u)
  {
    if (v96 == v94) {
      goto LABEL_153;
    }
    LOBYTE(v101) = v95->i8[1];
LABEL_145:
    if ((v101 & 0xC0) != 0x80) {
      goto LABEL_153;
    }
LABEL_146:
    if (&v95->i16[1] == (__int16 *)v94
      || (v95->i8[2] & 0xC0) != 0x80
      || (uint8x16_t *)((char *)v95->i32 + 3) == v94
      || (v95->i8[3] & 0xC0) != 0x80)
    {
      goto LABEL_153;
    }

    uint64_t v92 = 0;
    Swift::String::Index v96 = (uint8x16_t *)((char *)v95->i64 + 4);
    Swift::String::Index v97 = 4LL;
    goto LABEL_114;
  }

  if (v96 != v94)
  {
    uint64_t v101 = v95->u8[1];
    if (v101 <= 0x8F) {
      goto LABEL_145;
    }
  }

  if (!v29) {
    return v8;
  }
  unint64_t v73 = *(unsigned __int8 *)(v44 + 18);
  char v37 = 0LL;
  uint64_t v74 = *(unsigned __int16 *)(v8 + 16);
  if (v74 > 0xA6)
  {
    if (*(unsigned __int16 *)(v8 + 16) > 0xDAu)
    {
      if (v74 == 234)
      {
        Swift::String::Index v75 = 18;
      }

      else
      {
        if (v74 != 219) {
          return v37;
        }
        Swift::String::Index v75 = 15;
      }
    }

    else if (v74 == 167)
    {
      Swift::String::Index v75 = 17;
    }

    else
    {
      if (v74 != 180) {
        return v37;
      }
      Swift::String::Index v75 = 16;
    }

    goto LABEL_136;
  }

  if (*(unsigned __int16 *)(v8 + 16) > 0x3Cu)
  {
    if (v74 != 61)
    {
      if (v74 != 76) {
        return v37;
      }
      goto LABEL_128;
    }

    Swift::String::Index v75 = 14;
LABEL_136:
    Type = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::createType( a1,  (swift::Demangle::__runtime::Node *)v8,  a3,  a4,  a5);
    unint64_t v76 = a1;
    unint64_t v77 = v75;
    return swift::Demangle::__runtime::Demangler::createWithChildren( v76,  v77,  Type,  (swift::Demangle::__runtime::Node *)v44,  a5);
  }

  if (v74 == 24)
  {
    Swift::String::Index v75 = 13;
    goto LABEL_136;
  }

  if (v74 != 29) {
    return v37;
  }
LABEL_128:
  unint64_t v76 = a1;
  unint64_t v77 = 19;
  Type = (swift::Demangle::__runtime::Node *)v8;
  return swift::Demangle::__runtime::Demangler::createWithChildren( v76,  v77,  Type,  (swift::Demangle::__runtime::Node *)v44,  a5);
}

  std::string::append((std::string *)a1, v12, v11);
  if ((v31 & 0x80000000) == 0)
  {
    snprintf(__str, 0x20uLL, "%lld", v31);
    std::string::append((std::string *)a1, __str);
  }

LABEL_99:
    int64_t v87 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
    uint64_t v10 = (v88 & 1) == 0 && v87 >= v10;
    if ((v84 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v10 & 1) != 0) {
        goto LABEL_137;
      }
    }

    else if ((v10 & 1) != 0)
    {
LABEL_136:
      _StringGuts.grow(_:)(v3);
LABEL_137:
      swift_bridgeObjectRelease_n(AssociatedTypeWitness, 4LL);
      if ((AssociatedTypeWitness & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        _StringGuts._foreignAppendInPlace(_:)(v1, AssociatedTypeWitness, 0LL, v286);
LABEL_155:
        swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2LL);
        goto LABEL_163;
      }

      if (v58)
      {
        swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2LL);
        *(void *)&__int128 v288 = v1;
        *((void *)&v288 + 1) = AssociatedTypeWitness & 0xFFFFFFFFFFFFFFLL;
        char v119 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(AssociatedTypeWitness) & 0xF,  (uint64_t)&v288,  HIBYTE(AssociatedTypeWitness) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v119, v120, (AssociatedTypeWitness & 0x4000000000000000LL) != 0);
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        goto LABEL_163;
      }

      if ((v1 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        id v133 = (id)((AssociatedTypeWitness & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v134 = v285;
        uint64_t v135 = v285;
LABEL_154:
        uint64_t v136 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v134, (uint64_t)v133, v135);
        _StringGuts.appendInPlace(_:isASCII:)(v136, v137, v1 < 0);
        goto LABEL_155;
      }

      id v133 = _StringObject.sharedUTF8.getter(v1, AssociatedTypeWitness);
      uint64_t v135 = v277;
      swift_bridgeObjectRelease(AssociatedTypeWitness);
      if (v135 >= v285)
      {
        uint64_t v134 = v285;
        goto LABEL_154;
      }

    unint64_t v84 = v16;
    goto LABEL_100;
  }

  unint64_t v232 = a1;
  uint64_t v34 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v229, &v232, (swift *)v2, v34, 6uLL))
  {
    outlined init with take of MirrorPath(&v229, (uint64_t)v226);
    char v35 = (uint64_t)v227;
    uint64_t v36 = v228;
    __swift_project_boxed_opaque_existential_0Tm(v226, (uint64_t)v227);
    (*(void (**)(uint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v36 + 8))( &v233,  &type metadata for String,  &protocol witness table for String,  v35,  v36);
    goto LABEL_176;
  }

  char v231 = 0LL;
  uint64_t v229 = 0u;
  uint64_t v230 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v229,  &demangling cache variable for type metadata for TextOutputStreamable?);
  unint64_t v232 = a1;
  uint64_t v40 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v229, &v232, (swift *)v2, v40, 6uLL))
  {
    outlined init with take of MirrorPath(&v229, (uint64_t)v226);
    uint64_t v41 = (uint64_t)v227;
    char v42 = v228;
    __swift_project_boxed_opaque_existential_0Tm(v226, (uint64_t)v227);
    uint64_t v43 = (*(uint64_t (**)(uint64_t, uint64_t))(v42 + 8))(v41, v42);
    uint64_t v13 = v43;
    uint64_t v14 = v44;
    uint64_t v15 = v233;
    uint64_t v16 = v234;
    uint64_t v47 = HIBYTE(v234) & 0xF;
    if ((v234 & 0x2000000000000000LL) != 0) {
      uint64_t v30 = HIBYTE(v234) & 0xF;
    }
    else {
      uint64_t v30 = v233 & 0xFFFFFFFFFFFFLL;
    }
    if (v30 || (v233 & ~v234 & 0x2000000000000000LL) != 0)
    {
      char v31 = v44 & 0x2000000000000000LL;
      Swift::Int v20 = HIBYTE(v44) & 0xF;
      if ((v234 & 0x2000000000000000LL) != 0 && v31)
      {
        unint64_t v21 = v47 + v20;
        if (v47 + v20 <= 0xF)
        {
          if (v20)
          {
            int64_t v150 = 0LL;
            char v151 = 0LL;
            uint64_t v152 = 8 * v20;
            uint64_t v92 = v234;
            do
            {
              size_t v153 = v47 + v151;
              Swift::String::Index v94 = v151++ >= 8;
              if (v94) {
                unint64_t v154 = v44;
              }
              else {
                unint64_t v154 = v43;
              }
              uint64_t v155 = (8 * v47 + v150) & 0x38;
              uint64_t v156 = (-255LL << v155) - 1;
              uint64_t v157 = (unint64_t)(v154 >> (v150 & 0x38)) << v155;
              unint64_t v158 = v157 | v156 & v92;
              unint64_t v159 = v157 | v156 & v15;
              if (v153 < 8) {
                uint64_t v15 = v159;
              }
              else {
                uint64_t v92 = v158;
              }
              v150 += 8LL;
            }

            while (v152 != v150);
            goto LABEL_172;
          }

          goto LABEL_171;
        }

        char v31 = 1LL;
      }

      int64_t v22 = v43 & 0xFFFFFFFFFFFFLL;
      if (v31) {
        unint64_t v19 = HIBYTE(v44) & 0xF;
      }
      else {
        unint64_t v19 = v43 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v44, 2LL, v45, v46);
      if ((v14 & 0x1000000000000000LL) == 0)
      {
        swift_bridgeObjectRetain_n(v14, 4LL, v48, v49);
        Swift::String::Index v52 = v19;
        if ((v16 & 0x1000000000000000LL) != 0) {
          goto LABEL_228;
        }
        goto LABEL_53;
      }

    unint64_t v19 = v9;
    if (v9 <= a2) {
      return v6 - v19;
    }
  }

  if (v61 > 0xCu) {
    goto LABEL_178;
  }
  if (((1 << v61) & 0x1204) != 0) {
    goto LABEL_99;
  }
  if (((1 << v61) & 3) == 0) {
LABEL_178:
  }
    _swift_stdlib_isLinkingConsonant(v55);
  return v6 - v19;
}

LABEL_325:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    uint64_t v115 = _StringGuts.nativeCapacity.getter(countAndFlagsBits, object);
    if ((v116 & 1) != 0) {
      uint64_t v117 = 0LL;
    }
    else {
      uint64_t v117 = v115;
    }
    if (v117 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_313;
    }

    uint64_t v118 = 2 * v117;
    if (v118 > v3) {
      Swift::Int v3 = v118;
    }
    goto LABEL_136;
  }

            Swift::String::Index v75 = 0LL;
          }

          unint64_t v249 = 352;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChild( this,  v249,  (swift::Demangle::__runtime::Node *)v75,  (uint64_t)v75,  a5);
        case 'H':
          uint64_t v184 = *((_DWORD *)this + 24);
          if (!v184) {
            goto LABEL_326;
          }
          unint64_t v185 = v184 - 1;
          unint64_t v186 = *((void *)this + 11);
          Swift::String::Index v75 = *(unsigned __int16 **)(v186 + 8LL * (v184 - 1));
          unint64_t v187 = v75[8];
          if (v187 == 232)
          {
            *((_DWORD *)this + 24) = v185;
          }

          else
          {
            if (v187 == 43)
            {
              *((_DWORD *)this + 24) = v185;
              else {
                *((_DWORD *)this + 24) = v188;
              }
              unint64_t v250 = 353;
              return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v250,  (swift::Demangle::__runtime::Node *)v78,  (swift::Demangle::__runtime::Node *)v75,  a5);
            }

LABEL_288:
  __break(1u);
LABEL_289:
  swift_bridgeObjectRetain_n(AssociatedTypeWitness, 5LL, v81, v82);
  v258._rawBits = 1LL;
  v259._rawBits = (v58 << 16) | 1;
  v260._rawBits = _StringGuts.validateScalarRange(_:)(v258, v259, countAndFlagsBits, AssociatedTypeWitness);
  if (v260._rawBits < 0x10000) {
    v260._rawBits |= 3;
  }
  Swift::Int v147 = specialized Collection.count.getter(v260, v261, countAndFlagsBits, AssociatedTypeWitness);
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  uint64_t v13 = v289._countAndFlagsBits;
  unint64_t object = (unint64_t)v289._object;
LABEL_292:
  Swift::Int v262 = String.UTF8View._foreignCount()();
  uint64_t v148 = v262 + v147;
  if (__OFADD__(v262, v147)) {
    goto LABEL_294;
  }
LABEL_181:
  if ((v13 & ~object & 0x2000000000000000LL) != 0
    && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v150 = _StringGuts.nativeUnusedCapacity.getter(v13, object);
    if ((v151 & 1) != 0) {
      goto LABEL_327;
    }
    if (v148 > 15 || (object & 0x2000000000000000LL) == 0 && v150 >= v147)
    {
LABEL_187:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v148, v147);
      swift_bridgeObjectRelease_n(AssociatedTypeWitness, 4LL);
      if ((AssociatedTypeWitness & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(AssociatedTypeWitness);
        _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, AssociatedTypeWitness, 0LL, v58);
      }

      else
      {
        if (v3)
        {
          swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2LL);
          *(void *)&__int128 v288 = countAndFlagsBits;
          *((void *)&v288 + 1) = AssociatedTypeWitness & 0xFFFFFFFFFFFFFFLL;
          uint64_t v152 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v1, (uint64_t)&v288, v1);
          _StringGuts.appendInPlace(_:isASCII:)(v152, v153, (AssociatedTypeWitness & 0x4000000000000000LL) != 0);
          swift_bridgeObjectRelease(AssociatedTypeWitness);
          goto LABEL_215;
        }

        if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(AssociatedTypeWitness);
          id v188 = (id)((AssociatedTypeWitness & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v189 = v10;
        }

        else
        {
          id v188 = _StringObject.sharedUTF8.getter(countAndFlagsBits, AssociatedTypeWitness);
          uint64_t v189 = v275;
          swift_bridgeObjectRelease(AssociatedTypeWitness);
          if (v189 < v10) {
            goto LABEL_325;
          }
        }

        uint64_t v190 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v10, (uint64_t)v188, v189);
        _StringGuts.appendInPlace(_:isASCII:)(v190, v191, countAndFlagsBits < 0);
      }

      swift_bridgeObjectRelease_n(AssociatedTypeWitness, 2LL);
      goto LABEL_215;
    }
  }

  else if (v148 > 15)
  {
    goto LABEL_187;
  }

  swift_bridgeObjectRelease_n(AssociatedTypeWitness, 5LL);
  unint64_t v154 = v289._countAndFlagsBits;
  swift_bridgeObjectRetain(object, v155, v156, v157);
  unint64_t v158 = _StringGuts._convertedToSmall()(v154, object);
  unint64_t v160 = v159;
  swift_bridgeObjectRelease(object);
  v161._rawBits = (v58 << 16) | 1;
  v162._rawBits = 1LL;
  v163._rawBits = _StringGuts.validateScalarRange(_:)(v162, v161, countAndFlagsBits, AssociatedTypeWitness);
  if (v163._rawBits < 0x10000) {
    v163._rawBits |= 3;
  }
  unint64_t v165 = specialized String.init(_:)(v163, v164, countAndFlagsBits, AssociatedTypeWitness);
  unint64_t v167 = v166;
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  unint64_t v168 = _StringGuts._convertedToSmall()(v165, v167);
  unint64_t v170 = v169;
  swift_bridgeObjectRelease(v167);
  unint64_t v171 = specialized _SmallString.init(_:appending:)(v158, v160, v168, v170);
  if ((v173 & 1) != 0) {
    goto LABEL_326;
  }
  uint64_t v174 = v171;
  uint64_t v175 = v172;
  swift_bridgeObjectRelease(object);
  swift_bridgeObjectRelease(AssociatedTypeWitness);
  v289._uint64_t countAndFlagsBits = v174;
  v289._unint64_t object = v175;
LABEL_215:
  unint64_t v193 = _int64ToString(_:radix:uppercase:)( *v287,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  uint64_t AssociatedTypeWitness = v193;
  uint64_t v148 = v194;
  unint64_t object = v289._countAndFlagsBits;
  uint64_t v1 = (uint64_t)v289._object;
  unint64_t v197 = ((unint64_t)v289._object >> 56) & 0xF;
  else {
    unint64_t v58 = v289._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v58 && (v289._countAndFlagsBits & ~(uint64_t)v289._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v289._object);
    v289._uint64_t countAndFlagsBits = AssociatedTypeWitness;
    v289._unint64_t object = (void *)v148;
    goto LABEL_266;
  }

  Swift::Int v3 = v194 & 0x2000000000000000LL;
  uint64_t countAndFlagsBits = HIBYTE(v194) & 0xF;
  if (((uint64_t)v289._object & 0x2000000000000000LL) != 0 && v3)
  {
    unint64_t v198 = v197 + countAndFlagsBits;
    if (v197 + countAndFlagsBits <= 0xF)
    {
      if (countAndFlagsBits)
      {
        char v231 = 0;
        unint64_t v232 = 0LL;
        unint64_t v233 = (unint64_t)v289._object;
        do
        {
          unint64_t v234 = v197 + v232;
          unint64_t v235 = v232 + 1;
          if (v232 >= 8) {
            unint64_t v236 = v194;
          }
          else {
            unint64_t v236 = v193;
          }
          unint64_t v237 = v236 >> (v231 & 0x38);
          char v238 = (8 * v197 + v231) & 0x38;
          uint64_t v239 = (-255LL << v238) - 1;
          unint64_t v240 = (unint64_t)v237 << v238;
          unint64_t v241 = v240 | v239 & v233;
          unint64_t v242 = v240 | v239 & object;
          if (v234 < 8) {
            unint64_t object = v242;
          }
          else {
            unint64_t v233 = v241;
          }
          v231 += 8;
          unint64_t v232 = v235;
        }

        while (countAndFlagsBits != v235);
      }

      else
      {
        unint64_t v233 = (unint64_t)v289._object;
      }

      swift_bridgeObjectRelease((uint64_t)v289._object);
      swift_bridgeObjectRelease(v148);
      unint64_t v247 = 0xA000000000000000LL;
      if (!(object & 0x8080808080808080LL | v233 & 0x80808080808080LL)) {
        unint64_t v247 = 0xE000000000000000LL;
      }
      v289._uint64_t countAndFlagsBits = object;
      v289._unint64_t object = (void *)(v247 & 0xFF00000000000000LL | (v198 << 56) | v233 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_266;
    }

    Swift::Int v3 = 1LL;
  }

  uint64_t v13 = v193 & 0xFFFFFFFFFFFFLL;
  if (v3) {
    uint64_t v10 = HIBYTE(v194) & 0xF;
  }
  else {
    uint64_t v10 = v193 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v194, 2LL, v195, v196);
  if ((v148 & 0x1000000000000000LL) != 0) {
    goto LABEL_295;
  }
  swift_bridgeObjectRetain_n(v148, 4LL, v145, v146);
  Swift::Int v199 = v10;
  if ((v1 & 0x1000000000000000LL) != 0) {
    goto LABEL_298;
  }
LABEL_229:
  BOOL v83 = __OFADD__(v58, v199);
  int64_t v200 = v58 + v199;
  if (v83) {
    goto LABEL_300;
  }
LABEL_230:
  if ((object & ~v1 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v1 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v201 = (unint64_t)v289._object;
    int64_t v202 = _StringGuts.nativeUnusedCapacity.getter(v289._countAndFlagsBits, (uint64_t)v289._object);
    if ((v203 & 1) != 0) {
      goto LABEL_327;
    }
    if (v200 <= 15 && ((v201 & 0x2000000000000000LL) != 0 || v202 < v199)) {
      goto LABEL_242;
    }
  }

  else if (v200 <= 15)
  {
    unint64_t v201 = (unint64_t)v289._object;
LABEL_242:
    swift_bridgeObjectRelease_n(v148, 5LL);
    unint64_t v209 = v289._countAndFlagsBits;
    swift_bridgeObjectRetain(v201, v210, v211, v212);
    unint64_t v213 = _StringGuts._convertedToSmall()(v209, v201);
    unint64_t v215 = v214;
    swift_bridgeObjectRelease(v201);
    v216._rawBits = (v10 << 16) | 1;
    v217._rawBits = 1LL;
    v218._rawBits = _StringGuts.validateScalarRange(_:)(v217, v216, AssociatedTypeWitness, v148);
    if (v218._rawBits < 0x10000) {
      v218._rawBits |= 3;
    }
    unint64_t v220 = specialized String.init(_:)(v218, v219, AssociatedTypeWitness, v148);
    unint64_t v222 = v221;
    swift_bridgeObjectRelease(v148);
    unint64_t v223 = _StringGuts._convertedToSmall()(v220, v222);
    unint64_t v225 = v224;
    swift_bridgeObjectRelease(v222);
    unint64_t v226 = specialized _SmallString.init(_:appending:)(v213, v215, v223, v225);
    if ((v228 & 1) != 0) {
      goto LABEL_326;
    }
    uint64_t v229 = v226;
    uint64_t v230 = v227;
    swift_bridgeObjectRelease(v201);
    swift_bridgeObjectRelease(v148);
    v289._uint64_t countAndFlagsBits = v229;
    v289._unint64_t object = v230;
    goto LABEL_266;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v200, v199);
  swift_bridgeObjectRelease_n(v148, 4LL);
  if ((v148 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v148);
    _StringGuts._foreignAppendInPlace(_:)(AssociatedTypeWitness, v148, 0LL, v10);
  }

  else
  {
    if (v3)
    {
      swift_bridgeObjectRelease_n(v148, 2LL);
      *(void *)&__int128 v288 = AssociatedTypeWitness;
      *((void *)&v288 + 1) = v148 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v204 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  countAndFlagsBits,  (uint64_t)&v288,  countAndFlagsBits);
      _StringGuts.appendInPlace(_:isASCII:)(v204, v205, (v148 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v148);
      goto LABEL_266;
    }

    if ((AssociatedTypeWitness & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v148);
      id v243 = (id)((v148 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v244 = v13;
    }

    else
    {
      id v243 = _StringObject.sharedUTF8.getter(AssociatedTypeWitness, v148);
      uint64_t v244 = v276;
      swift_bridgeObjectRelease(v148);
      if (v244 < v13) {
        goto LABEL_325;
      }
    }

    uint64_t v245 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v13, (uint64_t)v243, v244);
    _StringGuts.appendInPlace(_:isASCII:)(v245, v246, AssociatedTypeWitness < 0);
  }

  swift_bridgeObjectRelease_n(v148, 2LL);
LABEL_266:
  uint64_t v248 = v289._object;
  unint64_t v249 = ((unint64_t)v289._object >> 56) & 0xF;
  if (v249 || (v289._countAndFlagsBits & ~(uint64_t)v289._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v289._object & 0x2000000000000000LL) == 0
      || (unint64_t v250 = specialized _SmallString.init(_:appending:)( v289._countAndFlagsBits,  (unint64_t)v289._object,  0x3EuLL,  0xE100000000000000LL),  (v207 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v206, v207, v208);
      _StringGuts.append(_:)(62LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      return v289._countAndFlagsBits;
    }

    else
    {
      unint64_t v251 = v250;
      swift_bridgeObjectRelease((uint64_t)v248);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v289._object);
    return 62LL;
  }

  return v251;
}

                      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
                    }

                    goto LABEL_201;
                  }

                  char v203 = *(void *)(v203 + 16);
                  ((void (*)(char *, char *, unint64_t *))v203)(v620, v211, v69);
                  v660 = -1LL;
                  Swift::String::Index v217 = ((uint64_t (*)(unint64_t *, char *))v656)(v69, v67);
                  Swift::String::Index v218 = v180(v69, v67);
                  if ((v217 & 1) != 0)
                  {
                    if (v218 <= 64)
                    {
                      unint64_t v221 = v648;
                      unint64_t v222 = v646;
                      unint64_t v223 = swift_getAssociatedConformanceWitness( (uint64_t)v648,  (uint64_t)v69,  (uint64_t)v646,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                      unint64_t v224 = v647;
                      (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v223 + 8))( &qword_18180BE68,  256LL,  v222,  v223);
                      (*((void (**)(unsigned int (*)(void), unint64_t *, const char *))v221
                       + 3))( v224,  v69,  v221);
                      unint64_t v180 = (uint64_t (*)(unint64_t *, char *))v620;
                      LOBYTE(v221) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL) + 40LL))( v620,  v169,  v69);
                      ((void (*)(float *, unint64_t *))v149)(v169, v69);
                      unint64_t v225 = v660;
                      unint64_t v226 = v597;
                      ((void (*)(char *, uint64_t (*)(unint64_t *, char *), unint64_t *))v203)( v597,  v180,  v69);
                      if ((v221 & 1) != 0)
                      {
                        uint64_t v227 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                        ((void (*)(char *, unint64_t *))v149)(v226, v69);
                        if (v225 < v227) {
                          goto LABEL_232;
                        }
                      }

                      else
                      {
                        ((void (*)(char *, unint64_t *))v149)(v226, v69);
                      }

                      goto LABEL_131;
                    }
                  }

                  else if (v218 <= 64)
                  {
                    unint64_t v180 = (uint64_t (*)(unint64_t *, char *))v620;
                    ((void (*)(float *, char *, unint64_t *))v203)(v169, v620, v69);
                    uint64_t v277 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                    ((void (*)(float *, unint64_t *))v149)(v169, v69);
                    if (v660 < v277) {
                      goto LABEL_232;
                    }
LABEL_131:
                    ((void (*)(uint64_t (*)(unint64_t *, char *), unint64_t *))v149)( v180,  v69);
                    uint64_t v211 = v633;
                    goto LABEL_132;
                  }

                  char v231 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
                  unint64_t v232 = lazy protocol witness table accessor for type UInt and conformance UInt(v218, v219, v220);
                  v231(&v660, &type metadata for UInt, v232, v69, v67);
                  unint64_t v180 = (uint64_t (*)(unint64_t *, char *))v620;
                  LOBYTE(v231) = (*(uint64_t (**)(float *, char *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                                + 16LL))( v169,  v620,  v69);
                  ((void (*)(float *, unint64_t *))v149)(v169, v69);
                  goto LABEL_131;
                }

uint64_t DiscontiguousSlice._customContainsEquatableElement(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for DiscontiguousSlice.Index(255LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  uint64_t v9 = type metadata accessor for Optional(0LL, v6, v7, v8);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  unint64_t v12 = (char *)&v24 - v11;
  uint64_t v15 = type metadata accessor for Optional(0LL, v9, v13, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)&v24 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  unint64_t v21 = (char *)&v24 - v20;
  DiscontiguousSlice._customIndexOfEquatableElement(_:)(a1, a2, (uint64_t *)((char *)&v24 - v20));
  (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v19, v21, v15);
  (*(void (**)(char *, char *, uint64_t))(v10 + 32))(v12, v19, v9);
  BOOL v22 = (*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(v6 - 8) + 48LL))(v12, 1LL, v6) != 1;
  (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
  return v22;
}

uint64_t DiscontiguousSlice._customIndexOfEquatableElement(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v129 = a1;
  unint64_t v111 = a3;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v123 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v108 = (char *)&v107 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v127 = *(void *)(v9 - 8);
  unint64_t v128 = v9;
  MEMORY[0x1895F8858](v9);
  unint64_t v126 = (char *)&v107 - v10;
  uint64_t v13 = type metadata accessor for Optional((const char *)0xFF, AssociatedTypeWitness, v11, v12);
  uint64_t v110 = type metadata accessor for Optional(0LL, v13, v14, v15);
  uint64_t v109 = *(void *)(v110 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v110);
  uint64_t v18 = (char *)&v107 - v17;
  uint64_t v19 = *(void *)(v13 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v16);
  char v121 = (char *)&v107 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  size_t v120 = (char *)&v107 - v22;
  uint64_t v134 = v6;
  uint64_t v135 = v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v136 = AssociatedTypeWitness;
  uint64_t v24 = AssociatedTypeWitness;
  uint64_t v25 = v19;
  unint64_t v118 = AssociatedConformanceWitness;
  uint64_t v27 = type metadata accessor for Range((const char *)0xFF, v24, AssociatedConformanceWitness, v26);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&type metadata for Int, v27, "offset element ", 0LL);
  uint64_t v133 = *(TupleTypeMetadata2 - 1);
  uint64_t v29 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v117 = (char *)&v107 - v30;
  uint64_t v137 = *(void *)(v27 - 8);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  unint64_t v124 = (char *)&v107 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  char v116 = (char *)&v107 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v115 = (char *)&v107 - v36;
  MEMORY[0x1895F8858](v35);
  unint64_t v114 = (char *)&v107 - v37;
  uint64_t v40 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v38, v39);
  uint64_t v131 = *(void *)(v40 - 8);
  uint64_t v132 = v40;
  uint64_t v41 = MEMORY[0x1895F8858](v40);
  unint64_t v138 = (uint64_t *)((char *)&v107 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v41);
  uint64_t v44 = (uint64_t *)((char *)&v107 - v43);
  uint64_t v45 = *(int *)(a2 + 36);
  uint64_t v130 = v3;
  size_t v46 = *(unint64_t **)(v3 + v45);
  unint64_t v113 = (char *)&v141;
  unint64_t v141 = 0LL;
  uint64_t v142 = 0LL;
  uint64_t v140 = v46;
  swift_retain(v46, v47, v48, v49);
  int v112 = 1;
  unint64_t v125 = v18;
  for (i = v44; ; uint64_t v44 = i)
  {
    unint64_t v50 = v141;
    unint64_t v51 = v140[2];
    if (v141 == v51)
    {
      uint64_t v52 = 1LL;
    }

    else
    {
      if (v141 >= v51) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      uint64_t v53 = v137;
      Swift::String::Index v54 = v116;
      (*(void (**)(char *, unint64_t, uint64_t))(v137 + 16))( v116,  (unint64_t)v140 + ((*(unsigned __int8 *)(v137 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v137 + 80))
      + *(void *)(v137 + 72) * v141,
        v27);
      Swift::String::Index v55 = *(void (**)(char *, char *, uint64_t))(v53 + 32);
      unint64_t v56 = v115;
      v55(v115, v54, v27);
      v139[0] = 0LL;
      v139[1] = v51;
      uint64_t v58 = type metadata accessor for RangeSet.Ranges(0LL, v136, v118, v57);
      uint64_t WitnessTable = (const char *)swift_getWitnessTable( &protocol conformance descriptor for RangeSet<A>.Ranges,  v58,  v59);
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v113, (uint64_t)v139, v58, WitnessTable);
      unint64_t v141 = v50 + 1;
      uint64_t v61 = v114;
      v55(v114, v56, v27);
      char v62 = &v117[*((int *)TupleTypeMetadata2 + 12)];
      uint64_t v63 = v142;
      uint64_t result = ((uint64_t (*)(char *, char *, uint64_t))v55)(v62, v61, v27);
      if (__OFADD__(v63, 1LL))
      {
        __break(1u);
        return result;
      }

      uint64_t v142 = v63 + 1;
      unint64_t v65 = (char *)v138 + *((int *)TupleTypeMetadata2 + 12);
      *unint64_t v138 = v63;
      v55(v65, v62, v27);
      uint64_t v52 = 0LL;
    }

    uint64_t v66 = v133;
    unint64_t v67 = v138;
    (*(void (**)(void *, uint64_t, uint64_t, unint64_t *))(v133 + 56))( v138,  v52,  1LL,  TupleTypeMetadata2);
    (*(void (**)(void *, void *, uint64_t))(v131 + 32))(v44, v67, v132);
    if ((*(unsigned int (**)(void *, uint64_t, unint64_t *))(v66 + 48))( v44,  1LL,  TupleTypeMetadata2) == 1) {
      break;
    }
    uint64_t v119 = *v44;
    char v68 = TupleTypeMetadata2;
    uint64_t v69 = (char *)v44 + *((int *)TupleTypeMetadata2 + 12);
    uint64_t v70 = v137;
    unint64_t v71 = v124;
    (*(void (**)(char *, char *, uint64_t))(v137 + 32))(v124, v69, v27);
    uint64_t v72 = (uint64_t)v135;
    uint64_t v73 = v13;
    uint64_t v74 = v126;
    uint64_t v75 = v25;
    uint64_t v76 = v134;
    (*((void (**)(char *, uint64_t, const char *))v135 + 11))(v71, v134, v135);
    unint64_t v77 = *(void (**)(char *, uint64_t))(v70 + 8);
    uint64_t v78 = v27;
    v77(v71, v27);
    uint64_t v79 = v76;
    uint64_t v80 = v128;
    unint64_t v81 = swift_getAssociatedConformanceWitness( v72,  v79,  v128,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    unint64_t v82 = v125;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v81 + 120))(v129, v80, v81);
    BOOL v83 = v74;
    uint64_t v13 = v73;
    uint64_t v84 = v80;
    uint64_t v25 = v75;
    (*(void (**)(char *, uint64_t))(v127 + 8))(v83, v84);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v75 + 48))(v82, 1LL, v73) == 1)
    {
      (*(void (**)(char *, uint64_t))(v109 + 8))(v82, v110);
      int v112 = 0;
    }

    else
    {
      int64_t v85 = *(void (**)(char *, char *, uint64_t))(v75 + 32);
      char v86 = v120;
      v85(v120, v82, v73);
      int64_t v87 = v121;
      v85(v121, v86, v13);
      if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v123 + 48))(v87, 1LL, v136) != 1)
      {
        swift_release((uint64_t)v140);
        Swift::String::Index v94 = *(void (**)(char *, char *, unint64_t))(v123 + 32);
        Swift::String::Index v95 = v108;
        uint64_t v96 = v136;
        v94(v108, v87, v136);
        uint64_t v98 = type metadata accessor for DiscontiguousSlice.Index(0LL, v134, (uint64_t)v135, v97);
        uint64_t v99 = v111;
        v94((char *)v111 + *(int *)(v98 + 36), v95, v96);
        void *v99 = v119;
        (*(void (**)(void *, void, uint64_t, uint64_t))(*(void *)(v98 - 8) + 56LL))(v99, 0LL, 1LL, v98);
        uint64_t v102 = type metadata accessor for Optional(0LL, v98, v100, v101);
        return (*(uint64_t (**)(void *, void, uint64_t, uint64_t))(*(void *)(v102 - 8) + 56LL))( v99,  0LL,  1LL,  v102);
      }

      (*(void (**)(char *, uint64_t))(v75 + 8))(v87, v13);
    }

    uint64_t v27 = v78;
    TupleTypeMetadata2 = v68;
  }

  swift_release((uint64_t)v140);
  if ((v112 & 1) != 0)
  {
    uint64_t v89 = type metadata accessor for DiscontiguousSlice.Index(0LL, v134, (uint64_t)v135, v88);
    uint64_t v90 = v111;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(v89 - 8) + 56LL))(v111, 1LL, 1LL, v89);
    uint64_t v93 = type metadata accessor for Optional(0LL, v89, v91, v92);
    return (*(uint64_t (**)(void *, void, uint64_t, uint64_t))(*(void *)(v93 - 8) + 56LL))( v90,  0LL,  1LL,  v93);
  }

  else
  {
    uint64_t v103 = type metadata accessor for DiscontiguousSlice.Index(255LL, v134, (uint64_t)v135, v88);
    uint64_t v106 = type metadata accessor for Optional(0LL, v103, v104, v105);
    return (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(v106 - 8) + 56LL))( v111,  1LL,  1LL,  v106);
  }

__objc2_class **DiscontiguousSlice._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v3 = specialized DiscontiguousSlice._copyToContiguousArray()(v1, *(void *)(a1 + 16), *(void *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v1, a1);
  return v3;
}

unint64_t *RangeSet.ranges.getter@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, unint64_t **a4@<X8>)
{
  uint64_t v5 = *v4;
  *a4 = *v4;
  return swift_retain(v5, a1, a2, a3);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance DiscontiguousSlice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v6 = type metadata accessor for DiscontiguousSlice.Index(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](v6);
  unint64_t v9 = (char *)&v17 - v8;
  uint64_t v10 = *(void *)(a1 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 16))(a3, v3, a1);
  DiscontiguousSlice.startIndex.getter(a1, v11, v9);
  (*(void (**)(uint64_t, uint64_t))(v10 + 8))(v3, a1);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a1, v12);
  uint64_t v15 = type metadata accessor for IndexingIterator(0LL, a1, WitnessTable, v14);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v7 + 32))(a3 + *(int *)(v15 + 36), v9, v6);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance DiscontiguousSlice<A>( uint64_t a1)
{
  uint64_t v3 = specialized DiscontiguousSlice._copyToContiguousArray()(v1, *(void *)(a1 + 16), *(void *)(a1 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v1, a1);
  return v3;
}

uint64_t DiscontiguousSlice.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, char *a3@<X8>)
{
  uint64_t v5 = *(void *)(v3 + *(int *)(a1 + 36));
  uint64_t v6 = *(void *)(a1 + 24);
  if (*(void *)(v5 + 16))
  {
    uint64_t v7 = *(void *)(a1 + 16);
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    uint64_t v11 = *(unsigned __int8 *)(*(void *)(type metadata accessor for Range( 0LL,  AssociatedTypeWitness,  AssociatedConformanceWitness,  v10)
                                         - 8)
                             + 80LL);
    uint64_t v12 = v5 + ((v11 + 32) & ~v11);
    uint64_t v14 = type metadata accessor for DiscontiguousSlice.Index(0LL, v7, v6, v13);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( &a3[*(int *)(v14 + 36)],  v12,  AssociatedTypeWitness);
  }

  else
  {
    uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 72);
    uint64_t v17 = *(void *)(a1 + 16);
    type metadata accessor for DiscontiguousSlice.Index(0LL, v17, v6, a2);
    uint64_t result = v16(v17, v6);
  }

  *(void *)a3 = 0LL;
  return result;
}

BOOL RangeSet.isEmpty.getter()
{
  return *(void *)(*(void *)v0 + 16LL) == 0LL;
}

uint64_t DiscontiguousSlice.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(*(void *)(v3 + *(int *)(a1 + 36)) + 16LL);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 72);
  type metadata accessor for DiscontiguousSlice.Index(0LL, v7, v6, a2);
  uint64_t result = v8(v7, v6);
  *a3 = v5;
  return result;
}

uint64_t RangeSet.Ranges.subscript.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  if ((a1 & 0x8000000000000000LL) != 0 || (uint64_t v7 = *v4, *(void *)(v7 + 16) <= a1)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
  uint64_t v8 = type metadata accessor for Range(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)(v8 - 8) + 16LL))( a4,  v7 + ((*(unsigned __int8 *)(*(void *)(v8 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v8 - 8) + 80LL))
         + *(void *)(*(void *)(v8 - 8) + 72LL) * a1,
           v8);
}

BOOL DiscontiguousSlice.isEmpty.getter(uint64_t a1)
{
  return *(void *)(*(void *)(v1 + *(int *)(a1 + 36)) + 16LL) == 0LL;
}

uint64_t DiscontiguousSlice.distance(from:to:)(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v103 = *(uint64_t (**)(void, void, void, void))(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v102 = (char *)&v95 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v108 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v95 - v12;
  unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v11,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  v8,  v13,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v16 = type metadata accessor for Range((const char *)0xFF, v13, AssociatedConformanceWitness, v15);
  uint64_t v19 = type metadata accessor for Optional(0LL, v16, v17, v18);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  uint64_t v101 = (uint64_t *)((char *)&v95 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v112 = v16;
  uint64_t v110 = *(void *)(v16 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v95 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v111 = (char *)&v95 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v105 = (char *)&v95 - v30;
  uint64_t v107 = (uint64_t)a1;
  uint64_t v31 = *a1;
  uint64_t v32 = *a2;
  if (*a2 < v31) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }
  uint64_t v100 = v29;
  uint64_t v104 = a2;
  uint64_t v33 = *(unint64_t **)(v4 + *(int *)(a3 + 36));
  uint64_t v117 = v33;
  uint64_t v118 = 0LL;
  uint64_t v115 = v32;
  uint64_t v119 = (uint64_t (*)(void, void, void, void))v33[2];
  uint64_t v34 = (uint64_t *)type metadata accessor for RangeSet.Ranges(0LL, v13, AssociatedConformanceWitness, v28);
  swift_retain(v33, v35, v36, v37);
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v34, v38);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v115, (uint64_t)&v118, (uint64_t)v34, WitnessTable);
  if (__OFADD__(v32, 1LL))
  {
    __break(1u);
    goto LABEL_17;
  }

  uint64_t v113 = v4;
  uint64_t v115 = v31;
  char v116 = (uint64_t (*)(void, void, void, void))(v32 + 1);
  Collection<>.subscript.getter((uint64_t)&v115, (uint64_t)v34, (uint64_t)WitnessTable, (char *)&v118);
  swift_release((uint64_t)v33);
  uint64_t v40 = v118;
  uint64_t v41 = v119;
  uint64_t v42 = v120;
  uint64_t v115 = v118;
  uint64_t v117 = (unint64_t *)v119;
  uint64_t v44 = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v34, v43);
  if (RandomAccessCollection<>.distance(from:to:)( (uint64_t)&v115,  (uint64_t)&v117,  (uint64_t)v34,  v44,  (uint64_t)&protocol witness table for Int) < 2) {
    goto LABEL_12;
  }
  uint64_t v102 = (char *)v11;
  uint64_t v118 = v40;
  uint64_t v119 = v41;
  size_t v120 = v42;
  uint64_t v46 = type metadata accessor for Slice(0LL, (uint64_t)v34, (uint64_t)WitnessTable, v45);
  uint64_t v48 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v46, v47);
  uint64_t v49 = v100;
  Collection.first.getter(v46, v48, v100);
  uint64_t v50 = v110;
  unint64_t v51 = *(unsigned int (**)(void, uint64_t, uint64_t))(v110 + 48);
  uint64_t v103 = v41;
  uint64_t v52 = v112;
  uint64_t v99 = v51;
  if (v51(v49, 1LL, v112) == 1) {
    goto LABEL_21;
  }
  uint64_t v98 = WitnessTable;
  uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v50 + 32);
  Swift::String::Index v54 = v105;
  v53(v105, v49, v52);
  uint64_t v96 = v40;
  uint64_t v118 = v40;
  uint64_t v119 = v103;
  uint64_t v97 = (uint64_t)v42;
  size_t v120 = v42;
  uint64_t v114 = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v34, v55);
  uint64_t v56 = swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, v46, &v114);
  uint64_t v57 = (void (*)(void, void, void))v101;
  uint64_t v95 = v46;
  BidirectionalCollection.last.getter(v46, v56, (uint64_t)v101);
  if (v99(v57, 1LL, v52) == 1)
  {
    unint64_t v91 = 161LL;
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  v91,  0);
  }

  v53(v111, (uint64_t)v57, v52);
  uint64_t v58 = (uint64_t)v102;
  uint64_t v101 = (uint64_t *)*((void *)v102 + 11);
  uint64_t WitnessTable = v109;
  ((void (*)(char *, uint64_t, char *))v101)(v54, v8, v102);
  uint64_t v100 = type metadata accessor for DiscontiguousSlice.Index(0LL, v8, v58, v59);
  unint64_t v60 = AssociatedTypeWitness;
  uint64_t v61 = v107 + *(int *)(v100 + 36);
  char v62 = &v54[*(int *)(v52 + 36)];
  uint64_t v25 = (char *)swift_getAssociatedConformanceWitness( v58,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v41 = (uint64_t (*)(void, void, void, void))*((void *)v25 + 19);
  uint64_t v107 = v41(v61, v62, v60, v25);
  uint64_t v63 = *(void (**)(const char *, unint64_t))(v108 + 8);
  v63(WitnessTable, v60);
  unint64_t v64 = v111;
  uint64_t v108 = v8;
  ((void (*)(char *, uint64_t, uint64_t))v101)(v111, v8, v58);
  uint64_t v65 = v41(v64, (char *)v104 + *(int *)(v100 + 36), v60, v25);
  v63(WitnessTable, v60);
  uint64_t v66 = v103;
  uint64_t v67 = (uint64_t)v103 - 1;
  if (__OFSUB__(v103, 1LL))
  {
LABEL_17:
    __break(1u);
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }

  if (v67 <= 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  char v68 = *(void (**)(char *, uint64_t))(v110 + 8);
  uint64_t v69 = v112;
  v68(v111, v112);
  v68(v105, v69);
  uint64_t v118 = 1LL;
  uint64_t v119 = (uint64_t (*)(void, void, void, void))v67;
  uint64_t v115 = v96;
  char v116 = v66;
  uint64_t v70 = specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v118, (char *)&v115, (uint64_t)v34, v98);
  uint64_t v34 = &v95;
  uint64_t v118 = 1LL;
  uint64_t v119 = (uint64_t (*)(void, void, void, void))v67;
  size_t v120 = (uint64_t *)v97;
  MEMORY[0x1895F8858](v70);
  uint64_t v42 = &v95 - 6;
  uint64_t v92 = v108;
  uint64_t v93 = v102;
  uint64_t v94 = v113;
  uint64_t v71 = v95;
  uint64_t v73 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v95, v72);
  uint64_t v11 = 0LL;
  uint64_t v74 = _sSTsE6reduceyqd__qd___qd__qd___7ElementQztKXEtKlFSixq_q0_s5Error_pRi_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lySiACSiIsgnnrzo_xSisAD_pSTRzSiRsd__r__lIetMygndzo_Tp5( 0LL,  (void (*)(char **__return_ptr, char **, char *))partial apply for closure #1 in DiscontiguousSlice.distance(from:to:),  (uint64_t)(&v95 - 6),  v71,  v73);
  swift_release((uint64_t)v120);
  uint64_t v75 = v107 + v74;
  if (__OFADD__(v107, v74))
  {
    __break(1u);
LABEL_21:
    unint64_t v91 = 160LL;
    goto LABEL_23;
  }

  uint64_t v40 = v75 + v65;
  if (!__OFADD__(v75, v65)) {
    return v40;
  }
  __break(1u);
LABEL_12:
  uint64_t v76 = v41;
  unint64_t v77 = v102;
  uint64_t v78 = (void (**)(char *, uint64_t))v103;
  (*((void (**)(char *, uint64_t, uint64_t))v103 + 2))(v102, v113, v8);
  uint64_t v115 = 0LL;
  uint64_t v118 = v40;
  uint64_t v119 = v76;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v115, (uint64_t)&v118, (uint64_t)v34, WitnessTable);
  uint64_t v79 = v112;
  if (!v42[2]) {
    goto LABEL_18;
  }
  uint64_t v80 = v110;
  (*(void (**)(char *, unint64_t, uint64_t))(v110 + 16))( v25,  (unint64_t)v42 + ((*(unsigned __int8 *)(v110 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v110 + 80)),  v112);
  swift_release((uint64_t)v42);
  unint64_t v81 = v109;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 88))(v25, v8, v11);
  (*(void (**)(char *, uint64_t))(v80 + 8))(v25, v79);
  v78[1](v77, v8);
  uint64_t v83 = *(int *)(type metadata accessor for DiscontiguousSlice.Index(0LL, v8, v11, v82) + 36);
  unint64_t v84 = AssociatedTypeWitness;
  uint64_t v85 = v107 + v83;
  char v86 = (char *)v104 + v83;
  unint64_t v87 = swift_getAssociatedConformanceWitness( v11,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v88 = (*(uint64_t (**)(uint64_t, char *, unint64_t, unint64_t))(v87 + 152))(v85, v86, v84, v87);
  unint64_t v89 = v84;
  uint64_t v40 = v88;
  (*(void (**)(const char *, unint64_t))(v108 + 8))(v81, v89);
  return v40;
}

uint64_t specialized Slice.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x714uLL,  0);
  }
  if (a1 >= a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x715uLL,  0);
  }
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
  }
  if (a1 >= a5) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  return *(unsigned __int8 *)(a4 + a1);
}

uint64_t specialized Slice.subscript.getter(unsigned int a1, uint64_t a2)
{
  if (a2 < a1 || HIDWORD(a2) >= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return a1 - 1;
}

uint64_t Slice.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v49 = a1;
  uint64_t v50 = a3;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(const char **)(a2 + 24);
  uint64_t v45 = a2;
  uint64_t v47 = v6;
  uint64_t v48 = v5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v12 = (char *)&v43 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v43 - v13;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v44 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v46 = *(void *)(v44 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v44);
  uint64_t v19 = (char *)&v43 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v43 - v20;
  uint64_t v22 = *(int *)(a2 + 36);
  uint64_t v23 = v4;
  uint64_t v43 = v4;
  uint64_t v24 = v4 + v22;
  uint64_t v25 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v26 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v27 = (void (*)(char *, uint64_t, unint64_t))v26[2];
  v27(v14, v23, AssociatedTypeWitness);
  v27(v25, v24, AssociatedTypeWitness);
  uint64_t v28 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  v27(v12, (uint64_t)v14, AssociatedTypeWitness);
  v27(v28, (uint64_t)v25, AssociatedTypeWitness);
  uint64_t v29 = (void (*)(char *, char *, unint64_t))v26[4];
  v29(v19, v12, AssociatedTypeWitness);
  uint64_t v30 = (void (*)(char *, unint64_t))v26[1];
  v30(v28, AssociatedTypeWitness);
  uint64_t v31 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  v29(v12, v14, AssociatedTypeWitness);
  v29(v31, v25, AssociatedTypeWitness);
  uint64_t v32 = v44;
  v29(&v19[*(int *)(v44 + 36)], v31, AssociatedTypeWitness);
  v30(v12, AssociatedTypeWitness);
  uint64_t v33 = v46;
  uint64_t v34 = v32;
  (*(void (**)(char *, char *, uint64_t))(v46 + 32))(v21, v19, v32);
  uint64_t v36 = v47;
  uint64_t v35 = v48;
  uint64_t v37 = v49;
  (*((void (**)(uint64_t, char *, uint64_t, const char *))v47 + 20))(v49, v21, v48, v47);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v21, v34);
  uint64_t v38 = (uint64_t (*)(_BYTE *, void))(*((uint64_t (**)(_BYTE *, uint64_t, uint64_t, const char *))v36
                                                  + 10))( v51,  v37,  v35,  v36);
  uint64_t v40 = v39;
  unint64_t v41 = swift_getAssociatedTypeWitness( 0LL,  *((const char **)v36 + 1),  v35,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v41 - 8) + 16LL))(v50, v40, v41);
  return v38(v51, 0LL);
}

uint64_t specialized Slice.subscript.getter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result < a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x71BuLL,  0);
  }
  if (a4 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x71CuLL,  0);
  }
  return result;
}

uint64_t Slice.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v48 = a3;
  uint64_t v47 = a1;
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(const char **)(a2 + 24);
  uint64_t v43 = a2;
  uint64_t v45 = v4;
  uint64_t v46 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v10 = (char *)&v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v40 - v11;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v42 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v44 = *(void *)(v42 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v42);
  uint64_t v17 = (char *)&v40 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v40 - v18;
  uint64_t v20 = v49 + *(int *)(a2 + 36);
  unint64_t v41 = TupleTypeMetadata2;
  uint64_t v21 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v22 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v23 = (void (*)(char *))v22[2];
  v23(v12);
  ((void (*)(char *, uint64_t, unint64_t))v23)(v21, v20, AssociatedTypeWitness);
  uint64_t v24 = &v10[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, unint64_t))v23)(v10, v12, AssociatedTypeWitness);
  ((void (*)(char *, char *, unint64_t))v23)(v24, v21, AssociatedTypeWitness);
  uint64_t v25 = (void (*)(char *, char *, unint64_t))v22[4];
  v25(v17, v10, AssociatedTypeWitness);
  uint64_t v26 = (void (*)(char *, unint64_t))v22[1];
  v26(v24, AssociatedTypeWitness);
  uint64_t v27 = &v10[*((int *)v41 + 12)];
  v25(v10, v12, AssociatedTypeWitness);
  v25(v27, v21, AssociatedTypeWitness);
  uint64_t v28 = v42;
  v25(&v17[*(int *)(v42 + 36)], v27, AssociatedTypeWitness);
  v26(v10, AssociatedTypeWitness);
  uint64_t v29 = v44;
  uint64_t v30 = v28;
  (*(void (**)(char *, char *, uint64_t))(v44 + 32))(v19, v17, v28);
  uint64_t v31 = v43;
  uint64_t v32 = v49 + *(int *)(v43 + 40);
  uint64_t v33 = v46;
  uint64_t v34 = v47;
  (*((void (**)(uint64_t, char *, uint64_t))v45 + 22))(v47, v19, v46);
  uint64_t v35 = v29;
  (*(void (**)(char *, uint64_t))(v29 + 8))(v19, v30);
  uint64_t v36 = *(int *)(v31 + 40);
  uint64_t v37 = v31;
  uint64_t v38 = v48;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v33 - 8) + 16LL))(&v48[v36], v32, v33);
  (*(void (**)(char *, uint64_t, uint64_t))(v35 + 16))(v19, v34, v30);
  v25(v38, v19, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, unint64_t))v25)( &v38[*(int *)(v37 + 36)],  &v19[*(int *)(v30 + 36)],  AssociatedTypeWitness);
}

uint64_t closure #1 in DiscontiguousSlice.distance(from:to:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v18 - v12;
  uint64_t v14 = *a1;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 88))(a2, a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v16 = (*(uint64_t (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 112))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  if (__OFADD__(v14, v16)) {
    __break(1u);
  }
  else {
    *a5 = v14 + v16;
  }
  return result;
}

uint64_t _sSTsE6reduceyqd__qd___qd__qd___7ElementQztKXEtKlFSixq_q0_s5Error_pRi_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lySiACSiIsgnnrzo_xSisAD_pSTRzSiRsd__r__lIetMygndzo_Tp5( char *a1, void (*a2)(char **__return_ptr, char **, char *), uint64_t a3, uint64_t a4, const char *a5)
{
  void (*v33)(char **__return_ptr, char **, char *);
  char *v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  uint64_t v34 = a1;
  uint64_t v30 = a3;
  uint64_t v32 = a5;
  uint64_t v33 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v36 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v30 - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v30 - v15;
  uint64_t v17 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v30 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v31 = *(void *)(v20 - 8);
  MEMORY[0x1895F8858](v20);
  uint64_t v22 = (char *)&v30 - v21;
  uint64_t v38 = v34;
  (*(void (**)(char *, unint64_t, uint64_t))(v17 + 16))(v19, v35, a4);
  uint64_t v23 = (uint64_t)v32;
  (*((void (**)(uint64_t, const char *))v32 + 4))(a4, v32);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v23,  a4,  v20,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v25 = *(const char **)(AssociatedConformanceWitness + 16);
  uint64_t v34 = v22;
  uint64_t v35 = v20;
  ((void (*)(unint64_t, unint64_t))v25)(v20, AssociatedConformanceWitness);
  uint64_t v26 = v36;
  uint64_t v27 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v36 + 48);
  if (v27(v16, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_5:
    (*(void (**)(char *, unint64_t))(v31 + 8))(v34, v35);
    return (uint64_t)v38;
  }

  else
  {
    uint64_t v32 = v25;
    uint64_t v28 = *(void (**)(char *, char *, unint64_t))(v26 + 32);
    while (1)
    {
      v28(v10, v16, AssociatedTypeWitness);
      v33(&v37, &v38, v10);
      if (v5) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v36 + 8))(v10, AssociatedTypeWitness);
      uint64_t v38 = v37;
      ((void (*)(unint64_t, unint64_t))v32)(v35, AssociatedConformanceWitness);
      if (v27(v16, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_5;
      }
    }

    (*(void (**)(char *, unint64_t))(v36 + 8))(v10, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, unint64_t))(v31 + 8))(v34, v35);
  }

uint64_t Sequence.reduce<A>(_:_:)@<X0>( void (*a1)(char *, char *, unint64_t)@<X0>, void (*a2)(uint64_t, char *)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, const char *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v8 = v7;
  uint64_t v52 = a5;
  uint64_t v48 = a3;
  uint64_t v49 = a2;
  uint64_t v47 = a1;
  uint64_t v12 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v42 = (char *)&v41 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v43 = v14;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v14,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v51 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v41 - v16;
  uint64_t v20 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v18, v19);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v41 - v22;
  uint64_t v45 = *(unsigned int (**)(char *, uint64_t, unint64_t))(a4 - 8);
  MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v41 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v54 = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v44 = *(void *)(v54 - 8);
  MEMORY[0x1895F8858](v54);
  uint64_t v53 = (char *)&v41 - v26;
  uint64_t v50 = v12;
  (*(void (**)(uint64_t, void, uint64_t))(v12 + 16))(a7, v47, v52);
  (*((void (**)(char *, uint64_t, uint64_t))v45 + 2))(v25, v55, a4);
  uint64_t v27 = a4;
  uint64_t v28 = a4;
  uint64_t v29 = (uint64_t)v43;
  (*((void (**)(uint64_t))v43 + 4))(v27);
  unint64_t v30 = v54;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v29,  v28,  v54,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v32 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v32(v30, AssociatedConformanceWitness);
  uint64_t v33 = v51;
  uint64_t v34 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v51 + 48);
  if (v34(v23, 1LL, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(char *, unint64_t))(v44 + 8))(v53, v54);
  }
  uint64_t v35 = *(void (**)(char *, char *, unint64_t))(v33 + 32);
  uint64_t v46 = v23;
  uint64_t v47 = v35;
  uint64_t v36 = v42;
  uint64_t v45 = v34;
  while (1)
  {
    v47(v17, v23, AssociatedTypeWitness);
    v49(a7, v17);
    if (v8) {
      break;
    }
    (*(void (**)(char *, unint64_t))(v51 + 8))(v17, AssociatedTypeWitness);
    uint64_t v55 = 0LL;
    uint64_t v37 = v50;
    uint64_t v38 = v52;
    (*(void (**)(uint64_t, uint64_t))(v50 + 8))(a7, v52);
    uint64_t v39 = *(void (**)(uint64_t, char *, uint64_t))(v37 + 32);
    uint64_t v23 = v46;
    uint64_t v8 = v55;
    v39(a7, v36, v38);
    v32(v54, AssociatedConformanceWitness);
    if (v45(v23, 1LL, AssociatedTypeWitness) == 1) {
      return (*(uint64_t (**)(char *, unint64_t))(v44 + 8))(v53, v54);
    }
  }

  (*(void (**)(char *, unint64_t))(v51 + 8))(v17, AssociatedTypeWitness);
  (*(void (**)(char *, unint64_t))(v44 + 8))(v53, v54);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v50 + 8))(a7, v52);
}

uint64_t DiscontiguousSlice.index(after:)@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v50 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v4,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v52 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v53 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v43 - v7;
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v4,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v54 = *(void *)(v9 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v46 = (char *)&v43 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v43 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v4,  v5,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0LL, v9, AssociatedConformanceWitness, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v43 - v18;
  unint64_t v20 = *v17;
  if ((*v17 & 0x8000000000000000LL) != 0) {
    goto LABEL_11;
  }
  uint64_t v21 = *(void *)(v2 + *(int *)(a1 + 36));
  if (v20 >= *(void *)(v21 + 16)) {
    goto LABEL_11;
  }
  uint64_t v47 = *(int *)(a1 + 36);
  unint64_t v44 = (*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80);
  uint64_t v43 = *(void *)(v16 + 72);
  uint64_t v22 = (uint64_t *)v17;
  (*(void (**)(char *, unint64_t, uint64_t))(v16 + 16))(v19, v21 + v44 + v43 * v20, v15);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v4 + 88);
  uint64_t v48 = v2;
  v23(v19, v5, v4);
  uint64_t v25 = v8;
  uint64_t v26 = type metadata accessor for DiscontiguousSlice.Index(0LL, v5, v4, v24);
  uint64_t v27 = *(int *)(v26 + 36);
  uint64_t v28 = v5;
  uint64_t v49 = v22;
  uint64_t v29 = (char *)v22 + v27;
  uint64_t v45 = v28;
  uint64_t v30 = v53;
  unint64_t v31 = swift_getAssociatedConformanceWitness( v4,  v28,  v53,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  (*(void (**)(char *, uint64_t, unint64_t))(v31 + 184))(v29, v30, v31);
  (*(void (**)(char *, uint64_t))(v52 + 8))(v25, v30);
  LOBYTE(v25) = (*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 16))( v13,  &v19[*(int *)(v15 + 36)],  v9);
  (*(void (**)(char *, uint64_t))(v16 + 8))(v19, v15);
  if ((v25 & 1) != 0)
  {
    uint64_t v32 = v50;
    uint64_t v33 = *v49;
    uint64_t result = (*(uint64_t (**)(char *, char *, unint64_t))(v54 + 32))( (char *)v50 + *(int *)(v26 + 36),  v13,  v9);
    *uint64_t v32 = v33;
    return result;
  }

  uint64_t v35 = v26;
  uint64_t v36 = v54;
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v54 + 8))(v13, v9);
  uint64_t v37 = *v49 + 1;
  if (__OFADD__(*v49, 1LL))
  {
    __break(1u);
  }

  else
  {
    uint64_t v38 = *(void *)(v48 + v47);
    uint64_t v39 = *(void *)(v38 + 16);
    if (v37 < v39)
    {
      if ((v37 & 0x8000000000000000LL) == 0)
      {
        uint64_t v40 = v46;
        (*(void (**)(char *, unint64_t, unint64_t))(v36 + 16))(v46, v38 + v44 + v37 * v43, v9);
        uint64_t v41 = v50;
        *uint64_t v50 = v37;
        return (*(uint64_t (**)(char *, char *, unint64_t))(v36 + 32))( (char *)v41 + *(int *)(v35 + 36),  v40,  v9);
      }

uint64_t DiscontiguousSlice.subscript.getter@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v40 = a3;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v38 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v39 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v37 = (char *)&v35 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v8,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v7,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for Range(0LL, v11, AssociatedConformanceWitness, v13);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v35 - v17;
  uint64_t v19 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v35 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v21, v4, v7);
  uint64_t v36 = a1;
  unint64_t v22 = *a1;
  if ((*a1 & 0x8000000000000000LL) != 0 || (uint64_t v23 = *(void *)(v4 + *(int *)(a2 + 36)), v22 >= *(void *)(v23 + 16))) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
  (*(void (**)(char *, unint64_t, uint64_t))(v15 + 16))( v18,  v23 + ((*(unsigned __int8 *)(v15 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80))
  + *(void *)(v15 + 72) * v22,
    v14);
  uint64_t v24 = v37;
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 88))(v18, v7, v8);
  (*(void (**)(char *, uint64_t))(v15 + 8))(v18, v14);
  (*(void (**)(char *, uint64_t))(v19 + 8))(v21, v7);
  uint64_t v26 = type metadata accessor for DiscontiguousSlice.Index(0LL, v7, v8, v25);
  uint64_t v27 = (char *)v36 + *(int *)(v26 + 36);
  uint64_t v28 = v39;
  unint64_t v29 = swift_getAssociatedConformanceWitness( v8,  v7,  v39,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v30 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t, unint64_t))(v29 + 80))( v41,  v27,  v28,  v29);
  uint64_t v32 = v31;
  unint64_t v33 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v33 - 8) + 16LL))(v40, v32, v33);
  v30(v41, 0LL);
  return (*(uint64_t (**)(char *, uint64_t))(v38 + 8))(v24, v28);
}

uint64_t DiscontiguousSlice.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v104 = a3;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v4 = *(const char **)(a2 + 24);
  uint64_t v105 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v103 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v101 - v6;
  unint64_t v7 = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v119 = (char *)&v101 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v123 = (char *)&v101 - v11;
  uint64_t v113 = *(void *)(v7 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v107 = (char *)&v101 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v118 = (char *)&v101 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  char v121 = (char *)&v101 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  size_t v120 = (char *)&v101 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v111 = (char *)&v101 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v112 = (char *)&v101 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v127 = (char *)&v101 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v27 = (char *)&v101 - v26;
  uint64_t v29 = type metadata accessor for DiscontiguousSlice.Index(0LL, v5, (uint64_t)v4, v28);
  uint64_t v30 = *(void *)(v29 - 8);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  unint64_t v33 = (char *)&v101 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v31);
  uint64_t v35 = (char *)&v101 - v34;
  uint64_t v108 = v4;
  uint64_t v125 = v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v117 = type metadata accessor for Range(0LL, v7, AssociatedConformanceWitness, v37);
  uint64_t v115 = *(void *)(v117 - 8);
  uint64_t v38 = MEMORY[0x1895F8858](v117);
  uint64_t v40 = (char *)&v101 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v41 = MEMORY[0x1895F8858](v38);
  char v116 = (char *)&v101 - v42;
  MEMORY[0x1895F8858](v41);
  uint64_t v114 = (char *)&v101 - v43;
  unint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(v30 + 16);
  v44(v35, a1, v29);
  uint64_t v45 = &v35[*(int *)(v29 + 36)];
  uint64_t v46 = v113;
  uint64_t v47 = *(void (**)(char *, char *, unint64_t))(v113 + 32);
  v47(v27, v45, v7);
  uint64_t v49 = a1
      + *(int *)(type metadata accessor for Range( 0LL,  v29,  (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index,  v48)
               + 36);
  uint64_t v50 = v111;
  v44(v33, v49, v29);
  uint64_t v51 = &v33[*(int *)(v29 + 36)];
  uint64_t v52 = v127;
  v47(v127, v51, v7);
  unint64_t v53 = *(void (**)(char *, char *, unint64_t))(v46 + 16);
  uint64_t v54 = v112;
  uint64_t v106 = v27;
  v53(v112, v27, v7);
  v53(v50, v52, v7);
  uint64_t v55 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  unint64_t v122 = AssociatedConformanceWitness;
  if ((v55(v54, v50, v7, AssociatedConformanceWitness) & 1) == 0) {
    goto LABEL_4;
  }
  uint64_t v102 = v40;
  uint64_t v56 = *(void (**)(char *, unint64_t))(v46 + 8);
  v56(v50, v7);
  v56(v54, v7);
  uint64_t v58 = v123;
  uint64_t v57 = TupleTypeMetadata2;
  uint64_t v59 = &v123[*((int *)TupleTypeMetadata2 + 12)];
  v47(v123, v106, v7);
  v47(v59, v127, v7);
  uint64_t v60 = *((int *)v57 + 12);
  uint64_t v127 = (char *)v55;
  uint64_t v61 = v119;
  char v62 = &v119[v60];
  v53(v119, v58, v7);
  v53(v62, v59, v7);
  uint64_t v63 = v116;
  v47(v116, v61, v7);
  v56(v62, v7);
  unint64_t v64 = &v61[*((int *)v57 + 12)];
  v47(v61, v58, v7);
  v47(v64, v59, v7);
  uint64_t v65 = v117;
  v47(&v63[*(int *)(v117 + 36)], v64, v7);
  v56(v61, v7);
  uint64_t v66 = v114;
  uint64_t v113 = *(void *)(v115 + 32);
  ((void (*)(char *, char *, uint64_t))v113)(v114, v63, v65);
  uint64_t v67 = (uint64_t)v108;
  char v68 = v109;
  uint64_t v69 = v125;
  (*((void (**)(char *, uint64_t, const char *))v108 + 11))(v66, v125, v108);
  uint64_t v70 = v69;
  unint64_t v71 = AssociatedTypeWitness;
  unint64_t v72 = swift_getAssociatedConformanceWitness( v67,  v70,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v73 = v120;
  (*(void (**)(unint64_t, unint64_t))(v72 + 64))(v71, v72);
  uint64_t v74 = v121;
  (*(void (**)(unint64_t, unint64_t))(v72 + 72))(v71, v72);
  uint64_t v75 = v118;
  v53(v118, v73, v7);
  uint64_t v76 = v107;
  v53(v107, v74, v7);
  if ((((uint64_t (*)(char *, char *, unint64_t, unint64_t))v127)(v75, v76, v7, v122) & 1) == 0) {
LABEL_4:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  v56(v76, v7);
  v56(v118, v7);
  (*(void (**)(char *, unint64_t))(v103 + 8))(v68, v71);
  uint64_t v77 = v117;
  (*(void (**)(char *, uint64_t))(v115 + 8))(v114, v117);
  uint64_t v79 = v123;
  uint64_t v78 = TupleTypeMetadata2;
  uint64_t v80 = &v123[*((int *)TupleTypeMetadata2 + 12)];
  v47(v123, v120, v7);
  v47(v80, v121, v7);
  unint64_t v81 = v119;
  uint64_t v82 = &v119[*((int *)v78 + 12)];
  v53(v119, v79, v7);
  v53(v82, v80, v7);
  uint64_t v83 = v116;
  v47(v116, v81, v7);
  v56(v82, v7);
  unint64_t v84 = &v81[*((int *)v78 + 12)];
  v47(v81, v79, v7);
  v47(v84, v80, v7);
  v47(&v83[*(int *)(v77 + 36)], v84, v7);
  v56(v81, v7);
  uint64_t v85 = (uint64_t)v102;
  ((void (*)(char *, char *, uint64_t))v113)(v102, v83, v77);
  uint64_t v86 = v105;
  uint64_t v87 = v126;
  uint64_t v88 = *(unint64_t **)(v126 + *(int *)(v105 + 36));
  swift_retain(v88, v89, v90, v91);
  uint64_t v92 = v85;
  uint64_t v93 = v122;
  RangeSet.init(_:)(v92, v7, v122, v94, &v130);
  uint64_t v95 = v130;
  v128[0] = (uint64_t)v130;
  v128[1] = (uint64_t)v88;
  uint64_t v97 = type metadata accessor for RangeSet.Ranges(0LL, v7, v93, v96);
  RangeSet.Ranges._intersection(_:)(v128, v97, &v129);
  swift_release((uint64_t)v95);
  swift_release((uint64_t)v88);
  uint64_t v98 = v129;
  uint64_t v99 = v104;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v125 - 8) + 16LL))(v104, v87);
  *(void *)(v99 + *(int *)(v86 + 36)) = v98;
  return result;
}

void RangeSet.init(_:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char **a5@<X8>)
{
  uint64_t v9 = type metadata accessor for Range(0LL, a2, a3, a4);
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 + 8) + 8LL))( a1,  a1 + *(int *)(v9 + 36),  a2) & 1) == 0)
  {
    uint64_t v18 = type metadata accessor for _ContiguousArrayStorage(0LL, v9, v10, v11);
    uint64_t v19 = *(void *)(v9 - 8);
    uint64_t v12 = (__objc2_class **)swift_allocObject( v18,  ((*(unsigned __int8 *)(v19 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80))
                            + *(void *)(v19 + 72),
                              *(unsigned __int8 *)(v19 + 80) | 7LL);
    vtable = (uint64_t *)(*v12)[3].vtable;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)vtable, vtable);
    v12[2] = (__objc2_class *)1;
    uint64_t v12[3] = (__objc2_class *)(isClassOrObjCExistentialType | 2LL);
    uint64_t v22 = *(unsigned __int8 *)(*(vtable - 1) + 80);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v19 + 32))((uint64_t)v12 + ((v22 + 32) & ~v22), a1, v9);
    uint64_t v13 = (const char *)_ArrayBuffer.requestNativeBuffer()((unint64_t)v12, (uint64_t *)v9);
    if (v13)
    {
LABEL_6:
      uint64_t v16 = v13;
      uint64_t v17 = v12;
      goto LABEL_7;
    }

uint64_t RangeSet.intersection(_:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v6 = *v4;
  v9[0] = *a1;
  v9[1] = v6;
  uint64_t v7 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  RangeSet.Ranges._intersection(_:)(v9, v7, &v10);
  uint64_t result = swift_release(v6);
  *a4 = v10;
  return result;
}

uint64_t DiscontiguousSlice._index(of:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  uint64_t v48 = a3;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v6 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v53 = (char *)&v44 - v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v51 = v13;
  uint64_t v52 = v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v50 = (char *)&v44 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v44 - v17;
  uint64_t v19 = *(int *)(a2 + 36);
  uint64_t v59 = *(unint64_t **)(v3 + v19);
  uint64_t v20 = v59;
  uint64_t v46 = v7;
  uint64_t v47 = v6;
  uint64_t v55 = v7;
  uint64_t v56 = v6;
  uint64_t v57 = a1;
  uint64_t v22 = type metadata accessor for RangeSet.Ranges(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v21);
  swift_retain(v20, v23, v24, v25);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v22, v26);
  Collection._partitioningIndex(where:)( (uint64_t (*)(char *))partial apply for closure #1 in DiscontiguousSlice._index(of:),  (uint64_t)v54,  v22,  WitnessTable,  (char *)&v60);
  swift_release((uint64_t)v59);
  unint64_t v28 = v60;
  uint64_t v58 = *(void *)(v49 + v19);
  RangeSet.Ranges.subscript.getter(v60, v22, v29, (uint64_t)v18);
  char v30 = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                       + 24))( v18,  a1,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v49 = v9;
  uint64_t v31 = *(void (**)(char *, uint64_t, unint64_t))(v9 + 16);
  uint64_t v32 = v51;
  uint64_t v45 = a1;
  v31(v53, a1, AssociatedTypeWitness);
  uint64_t v33 = v52;
  uint64_t v34 = v50;
  (*(void (**)(void))(v52 + 32))();
  if ((v30 & 1) != 0)
  {
    unint64_t v44 = v31;
    uint64_t v35 = v53;
    char v36 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 16))( v53,  &v34[*(int *)(v32 + 36)],  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t))(v33 + 8))(v34, v32);
    (*(void (**)(char *, unint64_t))(v49 + 8))(v35, AssociatedTypeWitness);
    uint64_t v38 = (uint64_t)v47;
    uint64_t v39 = v48;
    uint64_t v40 = v46;
    if ((v36 & 1) != 0)
    {
      uint64_t v41 = type metadata accessor for DiscontiguousSlice.Index(0LL, v46, (uint64_t)v47, v37);
      v44((char *)v39 + *(int *)(v41 + 36), v45, AssociatedTypeWitness);
      *uint64_t v39 = v28;
      return (*(uint64_t (**)(unint64_t *, void, uint64_t, uint64_t))(*(void *)(v41 - 8) + 56LL))( v39,  0LL,  1LL,  v41);
    }
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v33 + 8))(v34, v32);
    (*(void (**)(char *, unint64_t))(v49 + 8))(v53, AssociatedTypeWitness);
    uint64_t v38 = (uint64_t)v47;
    uint64_t v39 = v48;
    uint64_t v40 = v46;
  }

  uint64_t v43 = type metadata accessor for DiscontiguousSlice.Index(0LL, v40, v38, v37);
  return (*(uint64_t (**)(unint64_t *, uint64_t, uint64_t, uint64_t))(*(void *)(v43 - 8) + 56LL))( v39,  1LL,  1LL,  v43);
}

uint64_t Range.contains(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(v15 + 24);
  char v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 24))(v3, a1, v11, v16);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, a1, v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v9, v3, a2);
  if ((v17 & 1) != 0) {
    char v18 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v16 + 16))( v14,  &v9[*(int *)(a2 + 36)],  v11,  v16);
  }
  else {
    char v18 = 0;
  }
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
  return v18 & 1;
}

uint64_t Sequence.enumerated()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a2, v2);
}

uint64_t DiscontiguousSlice._customLastIndexOfEquatableElement(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v121 = a1;
  uint64_t v104 = a3;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v113 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v101 = (char *)&v100 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v119 = *(void *)(v9 - 8);
  unint64_t v120 = v9;
  MEMORY[0x1895F8858](v9);
  uint64_t v118 = (char *)&v100 - v10;
  uint64_t v127 = v6;
  unint64_t v128 = v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v116 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v115 = (char *)&v100 - v14;
  uint64_t v17 = type metadata accessor for Optional((const char *)0xFF, AssociatedTypeWitness, v15, v16);
  uint64_t v103 = type metadata accessor for Optional(0LL, v17, v18, v19);
  uint64_t v102 = *(void *)(v103 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v103);
  uint64_t v22 = (char *)&v100 - v21;
  uint64_t v23 = *(void *)(v17 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v20);
  uint64_t v26 = (char *)&v100 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v24);
  uint64_t v108 = (char *)&v100 - v27;
  uint64_t v117 = v13;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( (const char *)0xFF,  (uint64_t)&type metadata for Int,  v13,  "offset element ",  0LL);
  uint64_t v31 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v29, v30);
  uint64_t v124 = *(void *)(v31 - 8);
  uint64_t v125 = v31;
  uint64_t v32 = MEMORY[0x1895F8858](v31);
  uint64_t v34 = (char *)&v100 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v32);
  uint64_t v126 = (char *)&v100 - v35;
  uint64_t v36 = *(int *)(a2 + 36);
  uint64_t v122 = v3;
  uint64_t v37 = *(unint64_t **)(v3 + v36);
  uint64_t v130 = v37;
  unint64_t v114 = AssociatedTypeWitness;
  uint64_t v39 = type metadata accessor for RangeSet.Ranges(255LL, AssociatedTypeWitness, AssociatedConformanceWitness, v38);
  swift_retain(v37, v40, v41, v42);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v39, v43);
  uint64_t v46 = type metadata accessor for EnumeratedSequence(0LL, v39, WitnessTable, v45);
  uint64_t v48 = swift_getWitnessTable(&protocol conformance descriptor for EnumeratedSequence<A>, v46, v47);
  uint64_t v49 = (uint64_t)Sequence.reversed()(v46, v48);
  Swift::Int v50 = Array._getCount()();
  unint64_t v51 = 0LL;
  unint64_t v106 = v49 & 0xC000000000000001LL;
  int v105 = 1;
  Swift::Int v110 = v50;
  uint64_t v109 = v26;
  unint64_t v111 = v34;
  uint64_t v112 = TupleTypeMetadata2;
  uint64_t v123 = v49;
LABEL_2:
  uint64_t v52 = (uint64_t *)v126;
  if (v51 == v50)
  {
LABEL_3:
    uint64_t v53 = *(TupleTypeMetadata2 - 1);
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v53 + 56))(v34, 1LL, 1LL, TupleTypeMetadata2);
    unint64_t v129 = v50;
    goto LABEL_8;
  }

  while (1)
  {
    BOOL v54 = v106 == 0;
    char v55 = v54 | ~_swift_isClassOrObjCExistentialType((uint64_t)TupleTypeMetadata2, (uint64_t *)TupleTypeMetadata2);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v51, v55 & 1);
    if ((v55 & 1) != 0)
    {
      unint64_t v56 = v51;
      uint64_t v53 = *(TupleTypeMetadata2 - 1);
      (*(void (**)(char *, unint64_t, unint64_t *))(v53 + 16))( v34,  v49 + ((*(unsigned __int8 *)(v53 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v53 + 80))
      + *(void *)(v53 + 72) * v56,
        TupleTypeMetadata2);
    }

    else
    {
      unint64_t v129 = v51;
      id v79 = _ArrayBuffer._getElementSlowPath(_:)(v51, v49, (uint64_t *)TupleTypeMetadata2);
      uint64_t v58 = v79;
      uint64_t v53 = *(TupleTypeMetadata2 - 1);
      if (*(void *)(v53 + 64) != 8LL) {
        goto LABEL_22;
      }
      uint64_t v130 = (unint64_t *)v79;
      (*(void (**)(char *, unint64_t **, unint64_t *))(v53 + 16))( v34,  &v130,  TupleTypeMetadata2);
      swift_unknownObjectRelease(v58);
      unint64_t v56 = v129;
    }

    BOOL v57 = __OFADD__(v56, 1LL);
    uint64_t v58 = (void *)(v56 + 1);
    unint64_t v129 = (unint64_t)v58;
    if (v57)
    {
      __break(1u);
LABEL_22:
      swift_unknownObjectRelease(v58);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    (*(void (**)(char *, void, uint64_t, unint64_t *))(v53 + 56))(v34, 0LL, 1LL, TupleTypeMetadata2);
LABEL_8:
    (*(void (**)(uint64_t *, char *, uint64_t))(v124 + 32))(v52, v34, v125);
    if ((*(unsigned int (**)(uint64_t *, uint64_t, unint64_t *))(v53 + 48))( v52,  1LL,  TupleTypeMetadata2) == 1) {
      break;
    }
    uint64_t v107 = *v52;
    uint64_t v59 = (char *)v52 + *((int *)TupleTypeMetadata2 + 12);
    uint64_t v60 = v23;
    uint64_t v61 = v116;
    uint64_t v62 = v17;
    uint64_t v63 = v115;
    unint64_t v64 = v22;
    uint64_t v65 = v117;
    (*(void (**)(char *, char *, uint64_t))(v116 + 32))(v115, v59, v117);
    uint64_t v66 = v127;
    uint64_t v67 = (uint64_t)v128;
    char v68 = v118;
    (*((void (**)(char *, uint64_t, const char *))v128 + 11))(v63, v127, v128);
    uint64_t v69 = *(void (**)(char *, uint64_t))(v61 + 8);
    uint64_t v23 = v60;
    uint64_t v70 = v63;
    uint64_t v17 = v62;
    uint64_t v71 = v65;
    uint64_t v22 = v64;
    v69(v70, v71);
    uint64_t v72 = v66;
    uint64_t v73 = v120;
    unint64_t v74 = swift_getAssociatedConformanceWitness( v67,  v72,  v120,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v74 + 128))(v121, v73, v74);
    (*(void (**)(char *, uint64_t))(v119 + 8))(v68, v73);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v60 + 48))(v64, 1LL, v62) == 1)
    {
      (*(void (**)(char *, uint64_t))(v102 + 8))(v64, v103);
      int v105 = 0;
      uint64_t v34 = v111;
      TupleTypeMetadata2 = v112;
      uint64_t v49 = v123;
      Swift::Int v50 = v110;
      unint64_t v51 = v129;
      goto LABEL_2;
    }

    uint64_t v75 = *(void (**)(char *, char *, uint64_t))(v60 + 32);
    uint64_t v76 = v108;
    v75(v108, v64, v17);
    uint64_t v77 = v109;
    v75(v109, v76, v17);
    int v78 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v113 + 48))(v77, 1LL, v114);
    uint64_t v49 = v123;
    unint64_t v51 = v129;
    if (v78 != 1)
    {
      swift_bridgeObjectRelease(v123);
      unint64_t v87 = v114;
      uint64_t v88 = *(void (**)(char *, char *, unint64_t))(v113 + 32);
      uint64_t v89 = v101;
      v88(v101, v77, v114);
      uint64_t v91 = type metadata accessor for DiscontiguousSlice.Index(0LL, v127, (uint64_t)v128, v90);
      uint64_t v92 = v104;
      v88((char *)v104 + *(int *)(v91 + 36), v89, v87);
      *uint64_t v92 = v107;
      (*(void (**)(void *, void, uint64_t, uint64_t))(*(void *)(v91 - 8) + 56LL))(v92, 0LL, 1LL, v91);
      uint64_t v95 = type metadata accessor for Optional(0LL, v91, v93, v94);
      return (*(uint64_t (**)(void *, void, uint64_t, uint64_t))(*(void *)(v95 - 8) + 56LL))( v92,  0LL,  1LL,  v95);
    }

    (*(void (**)(char *, uint64_t))(v23 + 8))(v77, v17);
    uint64_t v34 = v111;
    TupleTypeMetadata2 = v112;
    uint64_t v52 = (uint64_t *)v126;
    Swift::Int v50 = v110;
    if (v51 == v110) {
      goto LABEL_3;
    }
  }

  swift_bridgeObjectRelease(v49);
  if ((v105 & 1) != 0)
  {
    uint64_t v81 = type metadata accessor for DiscontiguousSlice.Index(0LL, v127, (uint64_t)v128, v80);
    uint64_t v82 = v104;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(v81 - 8) + 56LL))(v104, 1LL, 1LL, v81);
    uint64_t v85 = type metadata accessor for Optional(0LL, v81, v83, v84);
    return (*(uint64_t (**)(void *, void, uint64_t, uint64_t))(*(void *)(v85 - 8) + 56LL))( v82,  0LL,  1LL,  v85);
  }

  else
  {
    uint64_t v96 = type metadata accessor for DiscontiguousSlice.Index(255LL, v127, (uint64_t)v128, v80);
    uint64_t v99 = type metadata accessor for Optional(0LL, v96, v97, v98);
    return (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(v99 - 8) + 56LL))( v104,  1LL,  1LL,  v99);
  }

unint64_t *Sequence.reversed()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v7 = *(AssociatedTypeWitness - 1);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v53 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v53 - v12;
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v58 = (char *)&v53 - v15;
  uint64_t v16 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v14);
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))( (char *)&v53 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v2,  a1);
  uint64_t v18 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, a2);
  uint64_t v60 = v18;
  swift_retain(v18, v19, v20, v21);
  Swift::Int v22 = Array._getCount()();
  swift_release((uint64_t)v18);
  if (v22 >= 0) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = v22 + 1;
  }
  if (v22 <= -2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  (*(void (**)(uint64_t, uint64_t))(v16 + 8))(v3, a1);
  if ((unint64_t)(v22 + 1) >= 3)
  {
    unint64_t v25 = 0LL;
    uint64_t v26 = v23 >> 1;
    while (1)
    {
      if (v26 == v25) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
      }
      unint64_t v27 = v25 + 1;
      Swift::Int v28 = v22 - (v25 + 1);
      if (__OFSUB__(v22, v25 + 1)) {
        break;
      }
      if (v25 != v28)
      {
        unint64_t v55 = v25 + 1;
        BOOL v57 = v13;
        uint64_t v29 = (uint64_t)v60;
        char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( (uint64_t)AssociatedTypeWitness,  AssociatedTypeWitness);
        unint64_t v56 = v29 & 0xC000000000000001LL;
        char v31 = ((v29 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
        Array._checkSubscript(_:wasNativeTypeChecked:)( v25,  (v29 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
        if ((v31 & 1) != 0)
        {
          unint64_t v32 = v29
          uint64_t v53 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
          v53(v58, v32, AssociatedTypeWitness);
        }

        else
        {
          id v50 = _ArrayBuffer._getElementSlowPath(_:)(v25, v29, AssociatedTypeWitness);
          if (v8 != 8) {
            goto LABEL_30;
          }
          id v59 = v50;
          unint64_t v51 = v50;
          uint64_t v53 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
          v53(v58, (unint64_t)&v59, AssociatedTypeWitness);
          swift_unknownObjectRelease(v51);
        }

        uint64_t v54 = v26;
        BOOL v33 = v56 == 0;
        char v34 = v33 | ~_swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v22 - (v25 + 1), v34 & 1);
        if ((v34 & 1) != 0)
        {
          uint64_t v35 = v57;
          v53( v57,  v29 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
          + *(void *)(v7 + 72) * v28,
            AssociatedTypeWitness);
        }

        else
        {
          id v52 = _ArrayBuffer._getElementSlowPath(_:)(v22 - (v25 + 1), v29, AssociatedTypeWitness);
          uint64_t v23 = (uint64_t)v52;
          if (v8 != 8) {
            goto LABEL_29;
          }
          id v59 = v52;
          uint64_t v35 = v57;
          v53(v57, (unint64_t)&v59, AssociatedTypeWitness);
          swift_unknownObjectRelease((id)v23);
        }

        (*(void (**)(char *, char *, uint64_t *))(v7 + 32))(v10, v35, AssociatedTypeWitness);
        unint64_t v56 = type metadata accessor for Array(0LL, (uint64_t)AssociatedTypeWitness, v36, v37);
        Array._makeMutableAndUnique()();
        uint64_t v38 = (uint64_t)v60;
        Array._checkSubscript_mutating(_:)(v25);
        BOOL v39 = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v40 = v38 & 0xFFFFFFFFFFFFFF8LL;
        if (!v39) {
          uint64_t v40 = v38;
        }
        uint64_t v41 = v10;
        unint64_t v42 = (*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80);
        uint64_t v43 = *(void *)(v7 + 72);
        unint64_t v44 = v40 + v42 + v43 * v25;
        uint64_t v45 = *(void (**)(unint64_t, char *, uint64_t *))(v7 + 40);
        v45(v44, v41, AssociatedTypeWitness);
        Array._makeMutableAndUnique()();
        uint64_t v23 = (uint64_t)v60;
        Array._checkSubscript_mutating(_:)(v28);
        BOOL v46 = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v47 = v23 & 0xFFFFFFFFFFFFFF8LL;
        if (!v46) {
          uint64_t v47 = v23;
        }
        unint64_t v48 = v47 + v42;
        uint64_t v10 = v41;
        unint64_t v49 = v48 + v43 * v28;
        uint64_t v13 = v57;
        v45(v49, v58, AssociatedTypeWitness);
        uint64_t v26 = v54;
        unint64_t v27 = v55;
      }

      unint64_t v25 = v27;
      if (v26 == v27) {
        return v60;
      }
    }

    __break(1u);
LABEL_29:
    id v50 = (id)v23;
LABEL_30:
    swift_unknownObjectRelease(v50);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }

  return v60;
}

uint64_t DiscontiguousSlice._failEarlyRangeCheck(_:bounds:)(unint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v130 = a1;
  uint64_t v146 = a2;
  uint64_t v125 = *(void *)(a3 - 8);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  uint64_t v121 = (char *)&v113 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v3);
  unint64_t v120 = (char *)&v113 - v5;
  uint64_t v7 = *(void *)(v6 + 16);
  uint64_t v8 = *(const char **)(v6 + 24);
  uint64_t v141 = v6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v137 = (char *)&v113 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v135 = (char *)&v113 - v13;
  uint64_t v14 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v119 = (char *)&v113 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v117 = (char *)&v113 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v140 = (char *)&v113 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v139 = (void (*)(void))((char *)&v113 - v22);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v25 = (char *)&v113 - v24;
  MEMORY[0x1895F8858](v23);
  unint64_t v27 = (char *)&v113 - v26;
  uint64_t v29 = type metadata accessor for DiscontiguousSlice.Index(0LL, v7, (uint64_t)v8, v28);
  uint64_t v30 = *(void *)(v29 - 8);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v118 = (unint64_t *)((char *)&v113 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v116 = (char *)&v113 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v124 = (unint64_t **)((char *)&v113 - v36);
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v126 = (char *)&v113 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v41 = (char *)&v113 - v40;
  MEMORY[0x1895F8858](v39);
  uint64_t v43 = (char *)&v113 - v42;
  uint64_t v128 = v7;
  unint64_t v129 = v8;
  uint64_t v44 = (uint64_t)v8;
  uint64_t v45 = v14;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v44,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v48 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v47);
  uint64_t v144 = *(void *)(v48 - 8);
  uint64_t v145 = v48;
  uint64_t v49 = MEMORY[0x1895F8858](v48);
  uint64_t v115 = (char *)&v113 - ((v50 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  uint64_t v114 = (uint64_t)&v113 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  uint64_t v133 = (char *)&v113 - v54;
  MEMORY[0x1895F8858](v53);
  unint64_t v143 = (char *)&v113 - v55;
  uint64_t v123 = v30;
  unint64_t v56 = *(void (**)(char *, uint64_t *, uint64_t))(v30 + 16);
  BOOL v57 = v146;
  v56(v43, v146, v29);
  uint64_t v58 = &v43[*(int *)(v29 + 36)];
  id v59 = (void (*)(char *, char *, unint64_t))v45[4];
  v59(v27, v58, AssociatedTypeWitness);
  uint64_t v132 = (uint64_t *)((char *)v57
                   + *(int *)(type metadata accessor for Range( 0LL,  v29,  (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index,  v60)
                            + 36));
  uint64_t v142 = (void (*)(char *, unint64_t **, uint64_t))v56;
  ((void (*)(char *))v56)(v41);
  uint64_t v127 = v29;
  v59(v25, &v41[*(int *)(v29 + 36)], AssociatedTypeWitness);
  uint64_t v61 = (void (*)(void))v45[2];
  uint64_t v62 = v139;
  uint64_t v134 = v27;
  ((void (*)(void (*)(void), char *, unint64_t))v61)(v139, v27, AssociatedTypeWitness);
  unint64_t v136 = v25;
  uint64_t v63 = v140;
  v61();
  unint64_t v64 = *(uint64_t (**)(void (*)(void), char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 24);
  unint64_t v122 = AssociatedConformanceWitness;
  if ((v64(v62, v63, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0) {
    goto LABEL_14;
  }
  uint64_t v113 = (uint64_t (*)(uint64_t, char *, unint64_t, uint64_t))v64;
  uint64_t v65 = v135;
  uint64_t v66 = (void (*)(char *, unint64_t))v45[1];
  v66(v63, AssociatedTypeWitness);
  v66((char *)v62, AssociatedTypeWitness);
  uint64_t v67 = TupleTypeMetadata2;
  char v68 = &v65[*((int *)TupleTypeMetadata2 + 12)];
  v59(v65, v134, AssociatedTypeWitness);
  v59(v68, v136, AssociatedTypeWitness);
  uint64_t v69 = v137;
  uint64_t v70 = v145;
  uint64_t v71 = &v137[*((int *)v67 + 12)];
  ((void (*)(char *, char *, unint64_t))v61)(v137, v65, AssociatedTypeWitness);
  uint64_t v139 = v61;
  ((void (*)(char *, char *, unint64_t))v61)(v71, v68, AssociatedTypeWitness);
  uint64_t v72 = v133;
  v59(v133, v69, AssociatedTypeWitness);
  v66(v71, AssociatedTypeWitness);
  uint64_t v73 = &v69[*((int *)v67 + 12)];
  v59(v69, v65, AssociatedTypeWitness);
  v59(v73, v68, AssociatedTypeWitness);
  v59(&v72[*(int *)(v70 + 36)], v73, AssociatedTypeWitness);
  uint64_t v140 = (char *)v66;
  v66(v69, AssociatedTypeWitness);
  unint64_t v74 = v143;
  uint64_t v75 = *(void (**)(char *, char *, uint64_t))(v144 + 32);
  v75(v143, v72, v70);
  uint64_t v76 = *v146;
  uint64_t v77 = *v132;
  if (*v132 < *v146) {
LABEL_14:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v146 = (uint64_t *)v75;
  uint64_t v78 = v127;
  uint64_t v79 = v128;
  uint64_t v80 = v129;
  uint64_t v81 = v130;
  uint64_t v82 = v131;
  (*((void (**)(char *, char *, uint64_t, const char *))v129 + 20))( (char *)v130 + *(int *)(v127 + 36),  v74,  v128,  v129);
  uint64_t v83 = v126;
  v142(v126, v81, v78);
  if (*v83 < v76 || *v83 >= v77) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x106uLL,  0);
  }
  uint64_t v84 = *(char **)(v123 + 8);
  ((void (*)(void *, uint64_t))v84)(v83, v78);
  TupleTypeMetadata2 = *v81;
  uint64_t v85 = *(unint64_t **)(*(void *)(v82 + *(int *)(v141 + 36)) + 16LL);
  uint64_t v86 = v80;
  unint64_t v87 = (void (*)(uint64_t, const char *))*((void *)v80 + 9);
  uint64_t v88 = v124;
  v87(v79, v86);
  unint64_t *v88 = v85;
  uint64_t v137 = v84;
  ((void (*)(unint64_t **, uint64_t))v84)(v88, v78);
  if (TupleTypeMetadata2 == v85)
  {
    uint64_t v89 = v116;
    v142(v116, v81, v78);
    uint64_t v90 = v120;
    (*(void (**)(char *, uint64_t, uint64_t))(v125 + 16))(v120, v82, v141);
    uint64_t v91 = &v89[*(int *)(v78 + 36)];
    uint64_t v92 = v117;
    v87(v79, v86);
    LOBYTE(v91) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(v122 + 8) + 8LL))( v91,  v92,  AssociatedTypeWitness);
    ((void (*)(char *, unint64_t))v140)(v92, AssociatedTypeWitness);
    if ((v91 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x108uLL,  0);
    }
    (*(void (**)(char *, uint64_t))(v125 + 8))(v90, v141);
    ((void (*)(char *, uint64_t))v137)(v89, v78);
    return (*(uint64_t (**)(char *, uint64_t))(v144 + 8))(v143, v145);
  }

  else
  {
    uint64_t v94 = v121;
    uint64_t v95 = v141;
    (*(void (**)(char *, uint64_t, uint64_t))(v125 + 16))(v121, v82, v141);
    uint64_t v96 = v118;
    v142((char *)v118, v81, v78);
    unint64_t v97 = *v96;
    uint64_t v147 = *(void *)&v94[*(int *)(v95 + 36)];
    uint64_t v98 = v122;
    uint64_t v100 = type metadata accessor for RangeSet.Ranges(0LL, AssociatedTypeWitness, v122, v99);
    uint64_t v101 = v114;
    RangeSet.Ranges.subscript.getter(v97, v100, v102, v114);
    uint64_t v103 = (char *)v96 + *(int *)(v78 + 36);
    char v104 = v113(v101, v103, AssociatedTypeWitness, v98);
    int v105 = v119;
    ((void (*)(char *, char *, unint64_t))v139)(v119, v103, AssociatedTypeWitness);
    unint64_t v106 = v115;
    uint64_t v107 = v101;
    uint64_t v108 = v145;
    ((void (*)(char *, uint64_t, uint64_t))v146)(v115, v107, v145);
    if ((v104 & 1) != 0)
    {
      char v109 = (*(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v98 + 16))( v105,  &v106[*(int *)(v108 + 36)],  AssociatedTypeWitness,  v98);
      Swift::Int v110 = v106;
      char v111 = v109;
    }

    else
    {
      Swift::Int v110 = v106;
      char v111 = 0;
    }

    uint64_t v112 = *(void (**)(char *, uint64_t))(v144 + 8);
    v112(v110, v108);
    ((void (*)(char *, unint64_t))v140)(v105, AssociatedTypeWitness);
    if ((v111 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x10AuLL,  0);
    }
    ((void (*)(unint64_t *, uint64_t))v137)(v96, v78);
    (*(void (**)(char *, uint64_t))(v125 + 8))(v94, v95);
    return ((uint64_t (*)(char *, uint64_t))v112)(v143, v108);
  }

uint64_t DiscontiguousSlice._failEarlyRangeCheck(_:bounds:)(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int64_t v150 = a2;
  uint64_t v147 = a1;
  uint64_t v4 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v148 = AssociatedConformanceWitness;
  uint64_t v121 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v8);
  uint64_t v120 = *(void *)(v121 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v121);
  uint64_t v119 = (char *)&v116 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v118 = (char *)&v116 - v12;
  uint64_t v130 = a3;
  uint64_t v129 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v125 = (char *)&v116 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v124 = (char *)&v116 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v137 = (char *)&v116 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v138 = (char *)&v116 - v19;
  uint64_t v20 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v117 = (char *)&v116 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v123 = (char *)&v116 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v141 = (char *)&v116 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v140 = (char *)&v116 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v31 = (char *)&v116 - v30;
  MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v116 - v32;
  uint64_t v131 = v4;
  uint64_t v132 = v5;
  uint64_t v35 = type metadata accessor for DiscontiguousSlice.Index(0LL, v4, (uint64_t)v5, v34);
  uint64_t v36 = *(void *)(v35 - 8);
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v128 = (char *)&v116 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  unint64_t v122 = (char *)&v116 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v127 = (char *)&v116 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  uint64_t v142 = (char *)&v116 - v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v47 = (char *)&v116 - v46;
  MEMORY[0x1895F8858](v45);
  uint64_t v49 = (char *)&v116 - v48;
  uint64_t v51 = type metadata accessor for ClosedRange(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v50);
  uint64_t v145 = *(void *)(v51 - 8);
  uint64_t v146 = v51;
  uint64_t v52 = MEMORY[0x1895F8858](v51);
  uint64_t v135 = (char *)&v116 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v52);
  uint64_t v144 = (char *)&v116 - v54;
  uint64_t v126 = v36;
  uint64_t v55 = *(void (**)(char *, uint64_t *, uint64_t))(v36 + 16);
  unint64_t v56 = v150;
  v55(v49, v150, v35);
  BOOL v57 = &v49[*(int *)(v35 + 36)];
  uint64_t v58 = *(void (**)(char *, char *, unint64_t))(v20 + 32);
  v58(v33, v57, AssociatedTypeWitness);
  uint64_t v134 = (uint64_t *)((char *)v56
                   + *(int *)(type metadata accessor for ClosedRange( 0LL,  v35,  (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index,  v59)
                            + 36));
  unint64_t v143 = v55;
  ((void (*)(char *))v55)(v47);
  v58(v31, &v47[*(int *)(v35 + 36)], AssociatedTypeWitness);
  uint64_t v60 = v20;
  uint64_t v61 = *(void (**)(char *, char *, unint64_t))(v20 + 16);
  uint64_t v62 = v140;
  uint64_t v63 = v141;
  unint64_t v136 = v33;
  v61(v140, v33, AssociatedTypeWitness);
  v61(v63, v31, AssociatedTypeWitness);
  unint64_t v64 = *(uint64_t (**)(char *, char *, unint64_t))(v148 + 24);
  if ((v64(v62, v63, AssociatedTypeWitness) & 1) == 0) {
    goto LABEL_15;
  }
  uint64_t v116 = (uint64_t (*)(char *, char *, unint64_t, unint64_t))v64;
  uint64_t v149 = v35;
  uint64_t v65 = *(void (**)(char *, unint64_t))(v60 + 8);
  v65(v63, AssociatedTypeWitness);
  v65(v62, AssociatedTypeWitness);
  uint64_t v67 = v138;
  uint64_t v66 = TupleTypeMetadata2;
  char v68 = &v138[*((int *)TupleTypeMetadata2 + 12)];
  v58(v138, v136, AssociatedTypeWitness);
  v58(v68, v31, AssociatedTypeWitness);
  uint64_t v69 = v137;
  uint64_t v70 = &v137[*((int *)v66 + 12)];
  v61(v137, v67, AssociatedTypeWitness);
  uint64_t v140 = (char *)v61;
  v61(v70, v68, AssociatedTypeWitness);
  uint64_t v71 = v135;
  v58(v135, v69, AssociatedTypeWitness);
  v65(v70, AssociatedTypeWitness);
  uint64_t v72 = &v69[*((int *)v66 + 12)];
  v58(v69, v67, AssociatedTypeWitness);
  v58(v72, v68, AssociatedTypeWitness);
  uint64_t v73 = v146;
  v58(&v71[*(int *)(v146 + 36)], v72, AssociatedTypeWitness);
  uint64_t v141 = (char *)v65;
  v65(v69, AssociatedTypeWitness);
  unint64_t v74 = v144;
  (*(void (**)(char *, char *, uint64_t))(v145 + 32))(v144, v71, v73);
  uint64_t v75 = *v150;
  uint64_t v76 = *v134;
  if (*v134 < *v150) {
LABEL_15:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  uint64_t v77 = v74;
  uint64_t v78 = v149;
  uint64_t v79 = v147;
  uint64_t v81 = v132;
  uint64_t v80 = v133;
  uint64_t v82 = v131;
  (*((void (**)(char *, char *, uint64_t, const char *))v132 + 21))( (char *)v147 + *(int *)(v149 + 36),  v77,  v131,  v132);
  uint64_t v83 = v142;
  v143(v142, v79, v78);
  if (*v83 < v75 || v76 < *v83) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x113uLL,  0);
  }
  uint64_t v84 = *(void (**)(char *, uint64_t))(v126 + 8);
  uint64_t v85 = v78;
  v84(v142, v78);
  uint64_t v86 = *v79;
  uint64_t v87 = *(void *)(*(void *)(v80 + *(int *)(v130 + 36)) + 16LL);
  uint64_t v88 = (void (*)(uint64_t, const char *))*((void *)v81 + 9);
  uint64_t v89 = v127;
  v88(v82, v81);
  char *v89 = v87;
  uint64_t v90 = (char *)v89;
  uint64_t v91 = v85;
  int64_t v150 = (uint64_t *)v84;
  v84(v90, v85);
  if (v86 != v87)
  {
    uint64_t v97 = v129;
    uint64_t v98 = v125;
    uint64_t v99 = v130;
    (*(void (**)(char *, uint64_t, uint64_t))(v129 + 16))(v125, v80, v130);
    uint64_t v100 = (unint64_t *)v128;
    v143(v128, v147, v91);
    unint64_t v101 = *v100;
    if ((*v100 & 0x8000000000000000LL) != 0
      || (uint64_t v102 = *(void *)&v98[*(int *)(v99 + 36)], v101 >= *(void *)(v102 + 16)))
    {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }

    uint64_t v103 = v97;
    uint64_t v104 = v120;
    int v105 = v118;
    uint64_t v106 = v121;
    (*(void (**)(char *, unint64_t, uint64_t))(v120 + 16))( v118,  v102 + ((*(unsigned __int8 *)(v120 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v120 + 80))
    + *(void *)(v120 + 72) * v101,
      v121);
    unint64_t v107 = v148;
    uint64_t v108 = &v128[*(int *)(v149 + 36)];
    char v109 = v116(v105, v108, AssociatedTypeWitness, v148);
    Swift::Int v110 = v117;
    ((void (*)(char *, char *, unint64_t))v140)(v117, v108, AssociatedTypeWitness);
    char v111 = v119;
    (*(void (**)(char *, char *, uint64_t))(v104 + 32))(v119, v105, v106);
    if ((v109 & 1) != 0)
    {
      char v112 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v107 + 16))( v110,  &v111[*(int *)(v106 + 36)],  AssociatedTypeWitness,  v107);
      uint64_t v113 = v111;
      char v114 = v112;
      (*(void (**)(char *, uint64_t))(v104 + 8))(v113, v106);
      ((void (*)(char *, unint64_t))v141)(v110, AssociatedTypeWitness);
      if ((v114 & 1) != 0)
      {
        ((void (*)(char *, uint64_t))v150)(v128, v149);
        (*(void (**)(char *, uint64_t))(v103 + 8))(v125, v99);
        return (*(uint64_t (**)(char *, uint64_t))(v145 + 8))(v144, v146);
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t))(v104 + 8))(v111, v106);
      ((void (*)(char *, unint64_t))v141)(v110, AssociatedTypeWitness);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x117uLL,  0);
  }

  uint64_t v92 = v122;
  v143(v122, v147, v85);
  uint64_t v93 = v124;
  uint64_t v94 = v130;
  (*(void (**)(char *, uint64_t, uint64_t))(v129 + 16))(v124, v80, v130);
  uint64_t v95 = &v92[*(int *)(v91 + 36)];
  uint64_t v96 = v123;
  v88(v82, v81);
  LOBYTE(v95) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(v148 + 8) + 8LL))( v95,  v96,  AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v141)(v96, AssociatedTypeWitness);
  if ((v95 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x115uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v129 + 8))(v93, v94);
  ((void (*)(char *, uint64_t))v150)(v92, v149);
  return (*(uint64_t (**)(char *, uint64_t))(v145 + 8))(v144, v146);
}

uint64_t DiscontiguousSlice._failEarlyRangeCheck(_:bounds:)(void *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v225 = a2;
  Swift::String::Index v217 = a1;
  uint64_t v200 = *(void *)(a3 - 8);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  id v188 = (char *)&v184 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = MEMORY[0x1895F8858](v3);
  unint64_t v187 = (char *)&v184 - v6;
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  unint64_t v193 = (char *)&v184 - v8;
  MEMORY[0x1895F8858](v7);
  unint64_t v192 = (char *)&v184 - v9;
  uint64_t v12 = *(void *)(v10 + 16);
  uint64_t v11 = *(const char **)(v10 + 24);
  uint64_t v210 = v10;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v222 = (char *)&v184 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v223 = (char *)&v184 - v17;
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  unint64_t v186 = (char *)&v184 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v195 = (char *)&v184 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v196 = (char *)&v184 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v208 = (char *)&v184 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v220 = (char *)&v184 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v221 = (char *)&v184 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  Swift::String::Index v219 = (char *)&v184 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  unint64_t v209 = (char **)((char *)&v184 - v34);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  unint64_t v226 = (char *)&v184 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v227 = (char *)&v184 - v38;
  MEMORY[0x1895F8858](v37);
  uint64_t v40 = (char *)&v184 - v39;
  uint64_t v42 = type metadata accessor for DiscontiguousSlice.Index(0LL, v12, (uint64_t)v11, v41);
  uint64_t v43 = *(void *)(v42 - 8);
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  unint64_t v201 = (char *)&v184 - ((v45 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  uint64_t v207 = (char *)&v184 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  uint64_t v206 = (char *)&v184 - v49;
  uint64_t v50 = MEMORY[0x1895F8858](v48);
  uint64_t v52 = (char *)&v184 - v51;
  MEMORY[0x1895F8858](v50);
  uint64_t v54 = (char *)&v184 - v53;
  uint64_t v211 = v12;
  uint64_t v212 = v11;
  uint64_t v55 = v18;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v11,  v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v229 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v57);
  uint64_t v215 = *(void *)(v229 - 8);
  uint64_t v58 = MEMORY[0x1895F8858](v229);
  unint64_t v185 = (char *)&v184 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v60 = MEMORY[0x1895F8858](v58);
  uint64_t v184 = (char *)&v184 - v61;
  uint64_t v62 = MEMORY[0x1895F8858](v60);
  unint64_t v194 = (char *)&v184 - v63;
  uint64_t v64 = MEMORY[0x1895F8858](v62);
  unint64_t v198 = (char *)&v184 - v65;
  uint64_t v66 = MEMORY[0x1895F8858](v64);
  uint64_t v190 = (char *)&v184 - v67;
  uint64_t v68 = MEMORY[0x1895F8858](v66);
  uint64_t v189 = (char *)&v184 - v69;
  uint64_t v70 = MEMORY[0x1895F8858](v68);
  Swift::Int v199 = (char *)&v184 - v71;
  uint64_t v72 = MEMORY[0x1895F8858](v70);
  size_t v191 = (char *)&v184 - v73;
  uint64_t v74 = MEMORY[0x1895F8858](v72);
  uint64_t v230 = (char *)&v184 - v75;
  uint64_t v76 = MEMORY[0x1895F8858](v74);
  Swift::String::Index v218 = (char *)&v184 - v77;
  MEMORY[0x1895F8858](v76);
  char v228 = (char *)&v184 - v78;
  uint64_t v197 = v43;
  uint64_t v79 = *(void (**)(char *, uint64_t *, uint64_t))(v43 + 16);
  uint64_t v80 = v225;
  v79(v54, v225, v42);
  uint64_t v81 = *(void (**)(char *, char *, unint64_t))(v55 + 32);
  v81(v40, &v54[*(int *)(v42 + 36)], AssociatedTypeWitness);
  uint64_t v203 = type metadata accessor for Range( 0LL,  v42,  (uint64_t)&protocol witness table for DiscontiguousSlice<A>.Index,  v82);
  uint64_t v83 = (uint64_t *)((char *)v80 + *(int *)(v203 + 36));
  v79(v52, v83, v42);
  uint64_t v216 = v42;
  uint64_t v84 = &v52[*(int *)(v42 + 36)];
  uint64_t v85 = v227;
  v81(v227, v84, AssociatedTypeWitness);
  uint64_t v205 = v55;
  uint64_t v86 = *(unint64_t **)(v55 + 16);
  uint64_t v87 = v226;
  uint64_t v204 = v40;
  ((void (*)(char *, char *, unint64_t))v86)(v226, v40, AssociatedTypeWitness);
  uint64_t v88 = v209;
  ((void (*)(void *, char *, unint64_t))v86)(v209, v85, AssociatedTypeWitness);
  uint64_t v89 = *(char **)(AssociatedConformanceWitness + 24);
  if ((((uint64_t (*)(char *, void *, unint64_t, unint64_t))v89)( v87,  v88,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    goto LABEL_27;
  }
  int64_t v202 = v83;
  unint64_t v214 = AssociatedConformanceWitness;
  uint64_t v90 = *(void **)(v205 + 8);
  ((void (*)(void *, unint64_t))v90)(v88, AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v90)(v226, AssociatedTypeWitness);
  uint64_t v91 = v223;
  uint64_t v92 = TupleTypeMetadata2;
  uint64_t v93 = &v223[*((int *)TupleTypeMetadata2 + 12)];
  v81(v223, v204, AssociatedTypeWitness);
  v81(v93, v227, AssociatedTypeWitness);
  uint64_t v94 = *((int *)v92 + 12);
  unint64_t v226 = (char *)v79;
  uint64_t v227 = v89;
  uint64_t v95 = v222;
  uint64_t v96 = &v222[v94];
  ((void (*)(char *, char *, unint64_t))v86)(v222, v91, AssociatedTypeWitness);
  ((void (*)(char *, char *, unint64_t))v86)(v96, v93, AssociatedTypeWitness);
  uint64_t v97 = v218;
  v81(v218, v95, AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v90)(v96, AssociatedTypeWitness);
  uint64_t v98 = &v95[*((int *)v92 + 12)];
  v81(v95, v91, AssociatedTypeWitness);
  v81(v98, v93, AssociatedTypeWitness);
  uint64_t v99 = v229;
  v81(&v97[*(int *)(v229 + 36)], v98, AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v90)(v95, AssociatedTypeWitness);
  uint64_t v100 = *(void (**)(char *, char *, uint64_t))(v215 + 32);
  v100(v228, v97, v99);
  unint64_t v101 = v206;
  uint64_t v102 = v216;
  uint64_t v103 = v217;
  uint64_t v104 = (void (*)(char *, void *, uint64_t))v226;
  ((void (*)(char *, void *, uint64_t))v226)(v206, v217, v216);
  int v105 = v219;
  v81(v219, &v101[*(int *)(v102 + 36)], AssociatedTypeWitness);
  uint64_t v106 = (void *)((char *)v103 + *(int *)(v203 + 36));
  unint64_t v107 = v207;
  v104(v207, v106, v102);
  uint64_t v108 = &v107[*(int *)(v102 + 36)];
  char v109 = v221;
  v81(v221, v108, AssociatedTypeWitness);
  Swift::Int v110 = v220;
  ((void (*)(char *, char *, unint64_t))v86)(v220, v105, AssociatedTypeWitness);
  char v111 = v208;
  ((void (*)(char *, char *, unint64_t))v86)(v208, v109, AssociatedTypeWitness);
  if ((((uint64_t (*)(char *, char *, unint64_t, unint64_t))v227)( v110,  v111,  AssociatedTypeWitness,  v214) & 1) == 0) {
    goto LABEL_27;
  }
  unint64_t v209 = v106;
  ((void (*)(char *, unint64_t))v90)(v111, AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v90)(v220, AssociatedTypeWitness);
  char v112 = v223;
  uint64_t v113 = TupleTypeMetadata2;
  char v114 = &v223[*((int *)TupleTypeMetadata2 + 12)];
  v81(v223, v219, AssociatedTypeWitness);
  v81(v114, v221, AssociatedTypeWitness);
  uint64_t v115 = *((int *)v113 + 12);
  unint64_t v226 = (char *)v100;
  uint64_t v116 = v222;
  uint64_t v117 = &v222[v115];
  ((void (*)(char *, char *, unint64_t))v86)(v222, v112, AssociatedTypeWitness);
  ((void (*)(char *, char *, unint64_t))v86)(v117, v114, AssociatedTypeWitness);
  uint64_t v118 = v218;
  v81(v218, v116, AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v90)(v117, AssociatedTypeWitness);
  uint64_t v119 = &v116[*((int *)v113 + 12)];
  v81(v116, v112, AssociatedTypeWitness);
  v81(v119, v114, AssociatedTypeWitness);
  uint64_t v120 = v229;
  v81(&v118[*(int *)(v229 + 36)], v119, AssociatedTypeWitness);
  ((void (*)(char *, unint64_t))v90)(v116, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v226)(v230, v118, v120);
  uint64_t v121 = *v225;
  uint64_t v122 = *v202;
  if (*v202 < *v225 || (uint64_t v123 = *v217, v124 = (char *)*v209, *v209 < *v217)) {
LABEL_27:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  TupleTypeMetadata2 = v86;
  unint64_t v225 = v90;
  uint64_t v126 = v212;
  uint64_t v125 = v213;
  uint64_t v127 = v211;
  (*((void (**)(char *, char *, uint64_t, const char *))v212 + 22))(v230, v228, v211, v212);
  if (v123 < v121 || v123 >= v122) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x124uLL,  0);
  }
  if (v122 < (uint64_t)v124) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x125uLL,  0);
  }
  uint64_t v128 = v210;
  unint64_t v221 = (char *)*(int *)(v210 + 36);
  unint64_t v222 = v124;
  uint64_t v129 = *(void *)(*(void *)&v221[v125] + 16LL);
  uint64_t v130 = (void (*)(uint64_t, const char *))*((void *)v126 + 9);
  uint64_t v131 = v216;
  uint64_t v132 = v201;
  v130(v127, v126);
  void *v132 = v129;
  unint64_t v220 = *(char **)(v197 + 8);
  ((void (*)(void *, uint64_t))v220)(v132, v131);
  unint64_t v223 = (char *)v130;
  if (v123 == v129)
  {
    uint64_t v133 = v191;
    Swift::String::Index v218 = *(char **)(v215 + 16);
    ((void (*)(char *, char *, uint64_t))v218)(v191, v230, v229);
    uint64_t v134 = v200;
    uint64_t v135 = v192;
    Swift::String::Index v219 = *(char **)(v200 + 16);
    ((void (*)(char *, uint64_t, uint64_t))v219)(v192, v125, v128);
    unint64_t v136 = v196;
    uint64_t v137 = v126;
    unint64_t v138 = v133;
    v130(v127, v137);
    LOBYTE(v133) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(v214 + 8) + 8LL))( v133,  v136,  AssociatedTypeWitness);
    ((void (*)(char *, unint64_t))v225)(v136, AssociatedTypeWitness);
    if ((v133 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x128uLL,  0);
    }
    Swift::String::Index v217 = *(void **)(v134 + 8);
    ((void (*)(char *, uint64_t))v217)(v135, v128);
    uint64_t v139 = *(void (**)(char *, uint64_t))(v215 + 8);
    v139(v138, v229);
  }

  else
  {
    uint64_t v140 = *(void (**)(char *, uint64_t, uint64_t))(v200 + 16);
    uint64_t v141 = v193;
    v140(v193, v125, v128);
    uint64_t v142 = v215;
    unint64_t v143 = *(void (**)(char *, char *, uint64_t))(v215 + 16);
    uint64_t v144 = v229;
    v143(v199, v230, v229);
    if (v123 < 0) {
      goto LABEL_29;
    }
    uint64_t v145 = *(void *)&v141[*(int *)(v128 + 36)];
    Swift::String::Index v219 = (char *)v140;
    uint64_t v146 = v189;
    v143( v189,  (char *)(v145 + ((*(unsigned __int8 *)(v142 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v142 + 80))
             + *(void *)(v142 + 72) * v123),
      v144);
    uint64_t v147 = v199;
    unint64_t v148 = v214;
    char v149 = ((uint64_t (*)(char *, char *, unint64_t, unint64_t))v227)( v146,  v199,  AssociatedTypeWitness,  v214);
    int64_t v150 = v195;
    ((void (*)(char *, char *, unint64_t))TupleTypeMetadata2)(v195, v147, AssociatedTypeWitness);
    char v151 = v190;
    ((void (*)(char *, char *, uint64_t))v226)(v190, v146, v144);
    if ((v149 & 1) != 0)
    {
      char v152 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v148 + 16))( v150,  &v151[*(int *)(v144 + 36)],  AssociatedTypeWitness,  v148);
      int64_t v150 = v195;
      char v153 = v152;
    }

    else
    {
      char v153 = 0;
    }

    unint64_t v154 = v151;
    uint64_t v139 = *(void (**)(char *, uint64_t))(v142 + 8);
    v139(v154, v144);
    ((void (*)(char *, unint64_t))v225)(v150, AssociatedTypeWitness);
    if ((v153 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x12AuLL,  0);
    }
    Swift::String::Index v218 = (char *)v143;
    v139(v199, v144);
    Swift::String::Index v217 = *(void **)(v200 + 8);
    ((void (*)(char *, uint64_t))v217)(v141, v210);
  }

  uint64_t v156 = v212;
  uint64_t v155 = v213;
  uint64_t v157 = *(char **)(*(void *)&v221[v213] + 16LL);
  uint64_t v158 = v216;
  unint64_t v159 = (char **)v201;
  uint64_t v160 = v211;
  Swift::String::Index v161 = (void (*)(uint64_t, const char *))v223;
  ((void (*)(uint64_t, const char *))v223)(v211, v212);
  *unint64_t v159 = v157;
  ((void (*)(char **, uint64_t))v220)(v159, v158);
  Swift::String::Index v162 = v222;
  if (v222 != v157)
  {
    unint64_t v171 = v188;
    uint64_t v172 = v210;
    ((void (*)(char *, uint64_t, uint64_t))v219)(v188, v155, v210);
    char v173 = v194;
    uint64_t v170 = v229;
    uint64_t v174 = (void (*)(char *, unint64_t, uint64_t))v218;
    ((void (*)(char *, char *, uint64_t))v218)(v194, v230, v229);
    if (((unint64_t)v162 & 0x8000000000000000LL) == 0)
    {
      uint64_t v175 = *(void *)&v171[*(int *)(v172 + 36)];
      if ((unint64_t)v162 < *(void *)(v175 + 16))
      {
        char v176 = v184;
        v174( v184,  v175 + ((*(unsigned __int8 *)(v215 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v215 + 80))
        + *(void *)(v215 + 72) * (void)v162,
          v170);
        unint64_t v177 = &v173[*(int *)(v170 + 36)];
        unint64_t v178 = v214;
        char v179 = ((uint64_t (*)(char *, char *, unint64_t, unint64_t))v227)( v176,  v177,  AssociatedTypeWitness,  v214);
        unint64_t v180 = v186;
        ((void (*)(char *, char *, unint64_t))TupleTypeMetadata2)(v186, v177, AssociatedTypeWitness);
        unint64_t v181 = v185;
        ((void (*)(char *, char *, uint64_t))v226)(v185, v176, v170);
        if ((v179 & 1) != 0)
        {
          char v182 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v178 + 16))( v180,  &v181[*(int *)(v170 + 36)],  AssociatedTypeWitness,  v178);
          v139(v181, v170);
          ((void (*)(char *, unint64_t))v225)(v180, AssociatedTypeWitness);
          if ((v182 & 1) != 0)
          {
            v139(v194, v170);
            ((void (*)(char *, uint64_t))v217)(v171, v210);
            goto LABEL_26;
          }
        }

        else
        {
          v139(v181, v170);
          ((void (*)(char *, unint64_t))v225)(v180, AssociatedTypeWitness);
        }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x131uLL,  0);
      }
    }

uint64_t (*protocol witness for Collection.subscript.read in conformance DiscontiguousSlice<A>( unint64_t **a1, void *a2, uint64_t a3))()
{
  uint64_t v6 = (unint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (unint64_t)DiscontiguousSlice.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*DiscontiguousSlice.subscript.read(unint64_t *a1, void *a2, uint64_t a3))()
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  *a1 = AssociatedTypeWitness;
  unint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  a1[1] = v7;
  uint64_t v8 = malloc(*(void *)(v7 + 64));
  a1[2] = (unint64_t)v8;
  DiscontiguousSlice.subscript.getter(a2, a3, (uint64_t)v8);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for DiscontiguousSlice.Index(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](v6);
  uint64_t v9 = (char *)&v11 - v8;
  DiscontiguousSlice.index(after:)(a2, (uint64_t *)((char *)&v11 - v8));
  (*(void (**)(uint64_t, uint64_t))(v7 + 8))(a1, v6);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v7 + 32))(a1, v9, v6);
}

uint64_t DiscontiguousSlice<>.index(before:)@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v4 = a2;
  uint64_t v132 = a1;
  uint64_t v120 = a4;
  uint64_t v116 = a3;
  uint64_t v5 = *(const char **)(a3 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v118 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v119 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v117 = (char *)&v108 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, v9, AssociatedConformanceWitness, v11);
  uint64_t v126 = *(void *)(v12 - 8);
  uint64_t v127 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  char v109 = (char *)&v108 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  char v114 = (char *)&v108 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v113 = (char *)&v108 - v18;
  uint64_t v128 = *(void *)(v9 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v121 = (char *)&v108 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v108 - v22;
  uint64_t v24 = *(uint64_t (**)(unint64_t *, uint64_t))(v4 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v21);
  uint64_t v131 = (char *)&v108 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v28 = (char *)&v108 - v27;
  uint64_t v129 = v6;
  uint64_t v130 = v5;
  uint64_t v30 = type metadata accessor for DiscontiguousSlice.Index(0LL, v6, (uint64_t)v5, v29);
  uint64_t v31 = *(void *)(v30 - 8);
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v124 = (char *)&v108 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v108 - v35;
  MEMORY[0x1895F8858](v34);
  uint64_t v38 = (char *)&v108 - v37;
  uint64_t v122 = *(void (**)(char *, unint64_t *, uint64_t))(v31 + 16);
  v122((char *)&v108 - v37, v132, v30);
  uint64_t v123 = v24;
  uint64_t v39 = (void (*)(char *, uint64_t, uint64_t))*((void *)v24 + 2);
  v39(v28, v134, v4);
  uint64_t v133 = v4;
  DiscontiguousSlice.startIndex.getter(v4, v40, v36);
  uint64_t v41 = *(int *)(v30 + 36);
  uint64_t v42 = &v36[v41];
  uint64_t v43 = &v38[v41];
  uint64_t v44 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v125 = (char *)AssociatedConformanceWitness;
  LOBYTE(v4) = v44(v42, v43, v9, AssociatedConformanceWitness);
  uint64_t v45 = *(void (**)(char *, uint64_t))(v31 + 8);
  v45(v36, v30);
  if ((v4 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't move index before startIndex",  34LL,  2,  "Swift/DiscontiguousSlice.swift",  30LL,  2,  0x13CuLL,  0);
  }
  uint64_t v46 = (void (*)(char *, uint64_t))*((void *)v123 + 1);
  uint64_t v47 = v28;
  uint64_t v48 = v133;
  v46(v47, v133);
  uint64_t v123 = (uint64_t (*)(unint64_t *, uint64_t))v45;
  v45(v38, v30);
  uint64_t v49 = v39;
  uint64_t v50 = v132;
  uint64_t v51 = (char *)v132 + *(int *)(v30 + 36);
  uint64_t v52 = v134;
  (*((void (**)(uint64_t))v130 + 9))(v129);
  uint64_t v53 = *((void *)v125 + 1);
  uint64_t v54 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v53 + 8);
  uint64_t v108 = v51;
  uint64_t v110 = v53;
  char v111 = v54;
  LOBYTE(v51) = ((uint64_t (*)(char *, char *, unint64_t))v54)(v51, v23, v9);
  uint64_t v55 = v128;
  unint64_t v56 = *(uint64_t (**)(char *, unint64_t))(v128 + 8);
  uint64_t v125 = v23;
  char v112 = v56;
  v56(v23, v9);
  uint64_t v57 = (unint64_t *)v124;
  v122(v124, v50, v30);
  v49(v131, v52, v48);
  uint64_t v58 = v55;
  uint64_t v59 = v30;
  uint64_t v115 = v30;
  if ((v51 & 1) != 0)
  {
    unint64_t v60 = v9;
    uint64_t v61 = v133;
    v46(v131, v133);
    uint64_t result = v123(v57, v59);
    uint64_t v63 = v125;
    uint64_t v64 = v61;
  }

  else
  {
    uint64_t v65 = *(void (**)(char *, char *, unint64_t))(v58 + 16);
    v65(v121, (char *)v57 + *(int *)(v30 + 36), v9);
    uint64_t v66 = v57;
    uint64_t v67 = v133;
    uint64_t v68 = v131;
    uint64_t v69 = *(unint64_t **)&v131[*(int *)(v133 + 36)];
    swift_retain(v69, v70, v71, v72);
    v46(v68, v67);
    unint64_t v73 = *v66;
    v123(v66, v30);
    if ((v73 & 0x8000000000000000LL) != 0 || v73 >= v69[2]) {
      goto LABEL_15;
    }
    unint64_t v74 = v9;
    uint64_t v75 = v126;
    uint64_t v76 = v127;
    uint64_t v131 = (char *)((*(unsigned __int8 *)(v126 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v126 + 80));
    uint64_t v77 = *(void *)(v126 + 72);
    uint64_t v78 = *(void (**)(char *, char *, uint64_t))(v126 + 16);
    uint64_t v79 = v113;
    v78(v113, &v131[(void)v69 + v77 * v73], v127);
    swift_release((uint64_t)v69);
    uint64_t v63 = v125;
    v65(v125, v79, v74);
    uint64_t v124 = *(char **)(v75 + 8);
    ((void (*)(char *, uint64_t))v124)(v79, v76);
    uint64_t v80 = v121;
    char v81 = v111(v121, v63, v74, v110);
    uint64_t v82 = v112;
    v112(v63, v74);
    unint64_t v60 = v74;
    uint64_t result = v82(v80, v74);
    uint64_t v64 = v133;
    if ((v81 & 1) == 0)
    {
      uint64_t v95 = v78;
      unint64_t v96 = *v50;
      uint64_t v97 = v129;
      uint64_t v98 = v130;
      if ((*v50 & 0x8000000000000000LL) == 0)
      {
        uint64_t v99 = *(void *)(v134 + *(int *)(v133 + 36));
        if (v96 < *(void *)(v99 + 16))
        {
          uint64_t v100 = v50;
          unint64_t v101 = v109;
          uint64_t v102 = v127;
          v95(v109, &v131[v99 + v96 * v77], v127);
          uint64_t v103 = v117;
          (*((void (**)(char *, uint64_t, const char *))v98 + 11))(v101, v97, v98);
          ((void (*)(char *, uint64_t))v124)(v101, v102);
          uint64_t v104 = v97;
          uint64_t v105 = v119;
          unint64_t v106 = swift_getAssociatedConformanceWitness( v116,  v104,  v119,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
          (*(void (**)(char *, uint64_t, unint64_t))(v106 + 32))(v108, v105, v106);
          (*(void (**)(char *, uint64_t))(v118 + 8))(v103, v105);
          unint64_t v83 = *v100;
          goto LABEL_14;
        }
      }

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> DiscontiguousSlice<A>@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  return DiscontiguousSlice<>.index(before:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> DiscontiguousSlice<A>( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = type metadata accessor for DiscontiguousSlice.Index(0LL, *(void *)(a2 + 16), *(void *)(v6 + 8), a4);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v12 - v9;
  DiscontiguousSlice<>.index(before:)(a1, a2, v6, (unint64_t *)((char *)&v12 - v9));
  (*(void (**)(unint64_t *, uint64_t))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(unint64_t *, char *, uint64_t))(v8 + 32))(a1, v10, v7);
}

uint64_t DiscontiguousSlice<>.subscript.getter@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v39 = a4;
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v37 = AssociatedTypeWitness;
  uint64_t v38 = v10;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v36 = (char *)&v35 - v11;
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v8,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0LL, v12, AssociatedConformanceWitness, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v35 - v17;
  uint64_t v19 = *(void *)(v4 + *(int *)(a2 + 36));
  uint64_t v20 = a1;
  unint64_t v21 = *a1;
  v40[0] = v19;
  uint64_t v23 = type metadata accessor for RangeSet.Ranges(0LL, v12, AssociatedConformanceWitness, v22);
  RangeSet.Ranges.subscript.getter(v21, v23, v24, (uint64_t)v18);
  uint64_t v25 = v36;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 88))(v18, v8, v7);
  (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v15);
  uint64_t v27 = (char *)v20 + *(int *)(type metadata accessor for DiscontiguousSlice.Index(0LL, v8, v7, v26) + 36);
  uint64_t v28 = v37;
  unint64_t v29 = swift_getAssociatedConformanceWitness( v7,  v8,  v37,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v30 = (void (*)(void *, void))(*(uint64_t (**)(void *, char *, uint64_t, unint64_t))(v29 + 80))( v40,  v27,  v28,  v29);
  uint64_t v32 = v31;
  unint64_t v33 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v33 - 8) + 16LL))(v39, v32, v33);
  v30(v40, 0LL);
  return (*(uint64_t (**)(char *, uint64_t))(v38 + 8))(v25, v28);
}

uint64_t key path getter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for DiscontiguousSlice,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))DiscontiguousSlice<>.subscript.getter);
}

uint64_t key path setter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + a3 - 16);
  uint64_t v6 = *(void *)(a4 + a3 - 8);
  uint64_t v8 = *(void *)(v6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v12 = (char *)&v21 - v11;
  uint64_t v14 = type metadata accessor for DiscontiguousSlice.Index(0LL, v7, v8, v13);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = (unint64_t *)((char *)&v21 - v15);
  (*(void (**)(char *, uint64_t))(v17 + 16))((char *)&v21 - v15, a3);
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))(v12, a1, AssociatedTypeWitness);
  uint64_t v19 = type metadata accessor for DiscontiguousSlice(0LL, v7, v8, v18);
  return DiscontiguousSlice<>.subscript.setter((uint64_t)v12, v16, v19, v6);
}

uint64_t DiscontiguousSlice<>.subscript.setter(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v36 = a1;
  uint64_t v9 = *(const char **)(a4 + 8);
  uint64_t v10 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v32 = (char *)&v31 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v34 = *(void *)(v15 - 8);
  uint64_t v35 = v15;
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v31 - v16;
  unint64_t v18 = *a2;
  v37[0] = *(void *)(v5 + *(int *)(a3 + 36));
  uint64_t v20 = type metadata accessor for RangeSet.Ranges(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v19);
  RangeSet.Ranges.subscript.getter(v18, v20, v21, (uint64_t)v17);
  uint64_t v23 = type metadata accessor for DiscontiguousSlice.Index(0LL, v10, (uint64_t)v9, v22);
  uint64_t v24 = v32;
  (*(void (**)(char *, char *, unint64_t))(v33 + 32))( v32,  (char *)a2 + *(int *)(v23 + 36),  AssociatedTypeWitness);
  uint64_t v25 = (void (*)(void *, void))(*(uint64_t (**)(void *, char *, uint64_t, uint64_t))(a4 + 48))( v37,  v17,  v10,  a4);
  unint64_t v26 = swift_getAssociatedTypeWitness( 255LL,  v9,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  unint64_t v27 = swift_getAssociatedConformanceWitness( a4,  v10,  v26,  (uint64_t)&protocol requirements base descriptor for MutableCollection,  (uint64_t)&associated conformance descriptor for MutableCollection.Collection.SubSequence: MutableCollection);
  uint64_t v28 = *(void (**)(uint64_t, char *, unint64_t *, unint64_t))(v27 + 24);
  unint64_t v29 = swift_checkMetadataState(0LL, v26);
  v28(v36, v24, v29, v27);
  v25(v37, 0LL);
  return (*(uint64_t (**)(char *, uint64_t))(v34 + 8))(v17, v35);
}

void (*DiscontiguousSlice<>.subscript.modify( void *a1, unint64_t *a2, uint64_t a3, uint64_t a4))(uint64_t *a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = malloc(0x110uLL);
  *a1 = v8;
  v8[12] = a4;
  v8[13] = v4;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v10 = *(void *)(a3 + 16);
  v8[14] = v10;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  v8[15] = AssociatedTypeWitness;
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  v8[16] = v12;
  v8[17] = malloc(*(void *)(v12 + 64));
  unint64_t v38 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  v8[18] = v38;
  uint64_t v40 = *(void *)(v38 - 8);
  uint64_t v36 = malloc(*(void *)(v40 + 64));
  v8[19] = v36;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  v8[20] = v14;
  uint64_t v33 = *(void *)(v14 - 8);
  uint64_t v34 = v14;
  uint64_t v15 = malloc(*(void *)(v33 + 64));
  v8[21] = v15;
  unint64_t v37 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v9 + 8),  v10,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  v8[22] = v37;
  uint64_t v35 = *(void *)(v37 - 8);
  v8[23] = v35;
  size_t v16 = *(void *)(v35 + 64);
  v8[24] = malloc(v16);
  uint64_t v32 = malloc(v16);
  v8[25] = v32;
  uint64_t v18 = type metadata accessor for DiscontiguousSlice.Index(0LL, v10, v9, v17);
  v8[26] = v18;
  uint64_t v19 = *(void *)(v18 - 8);
  v8[27] = v19;
  size_t v20 = *(void *)(v19 + 64);
  v8[28] = malloc(v20);
  v8[29] = malloc(v20);
  (*(void (**)(void))(v19 + 16))();
  *((_DWORD *)v8 + 66) = *(_DWORD *)(a3 + 36);
  unint64_t v21 = *a2;
  uint64_t v23 = type metadata accessor for RangeSet.Ranges(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v22);
  v8[30] = v23;
  RangeSet.Ranges.subscript.getter(v21, v23, v24, (uint64_t)v15);
  (*(void (**)(void *, uint64_t, uint64_t))(v9 + 88))(v15, v10, v9);
  uint64_t v25 = *(void (**)(void *, uint64_t))(v33 + 8);
  v8[31] = v25;
  v25(v15, v34);
  unint64_t v26 = (char *)a2 + *(int *)(v18 + 36);
  unint64_t v27 = swift_getAssociatedConformanceWitness( v9,  v10,  v38,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v28 = (void (*)(void *, void))(*(uint64_t (**)(void *, char *, unint64_t, unint64_t))(v27 + 80))( v8,  v26,  v38,  v27);
  unint64_t v29 = *(void (**)(void *))(v35 + 16);
  v8[32] = v29;
  v29(v32);
  v28(v8, 0LL);
  (*(void (**)(void *, unint64_t))(v40 + 8))(v36, v38);
  return DiscontiguousSlice<>.subscript.modify;
}

void DiscontiguousSlice<>.subscript.modify(uint64_t *a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = *(unint64_t **)(v4 + 232);
    uint64_t v33 = *(void *)(v4 + 240);
    uint64_t v7 = *(void *)(v4 + 216);
    uint64_t v6 = *(unint64_t **)(v4 + 224);
    uint64_t v8 = *(void *)(v4 + 208);
    uint64_t v42 = *(void (**)(void *, uint64_t))(v4 + 248);
    uint64_t v44 = *(void **)(v4 + 200);
    uint64_t v46 = *(void **)(v4 + 192);
    uint64_t v9 = *(void **)(v4 + 168);
    uint64_t v37 = *(void *)(v4 + 176);
    uint64_t v39 = *(void *)(v4 + 160);
    uint64_t v40 = *(void *)(v4 + 184);
    uint64_t v48 = *(void **)(v4 + 152);
    uint64_t v10 = *(void **)(v4 + 136);
    uint64_t v34 = *(void *)(v4 + 144);
    uint64_t v11 = *(void *)(v4 + 112);
    uint64_t v31 = *(void *)(v4 + 128);
    uint64_t v32 = *(void *)(v4 + 120);
    uint64_t v12 = *(void *)(v4 + 96);
    (*(void (**)(void))(v4 + 256))();
    uint64_t v13 = *(void (**)(unint64_t *, unint64_t *, uint64_t))(v7 + 32);
    uint64_t v14 = v6;
    v13(v6, v5, v8);
    RangeSet.Ranges.subscript.getter(*v6, v33, v15, (uint64_t)v9);
    (*(void (**)(void *, char *, uint64_t))(v31 + 32))(v10, (char *)v6 + *(int *)(v8 + 36), v32);
    size_t v16 = (void (*)(uint64_t, void))(*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(v12 + 48))( v4 + 32,  v9,  v11,  v12);
    uint64_t v17 = v12;
    uint64_t v18 = v46;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v17,  v11,  v34,  (uint64_t)&protocol requirements base descriptor for MutableCollection,  (uint64_t)&associated conformance descriptor for MutableCollection.Collection.SubSequence: MutableCollection);
    (*(void (**)(void *, void *, uint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v46,  v10,  v34,  AssociatedConformanceWitness);
    v16(v4 + 32, 0LL);
    size_t v20 = v44;
    v42(v9, v39);
    (*(void (**)(void *, uint64_t))(v40 + 8))(v44, v37);
    unint64_t v21 = v5;
  }

  else
  {
    uint64_t v22 = *(unint64_t **)(v4 + 232);
    uint64_t v36 = *(unint64_t **)(v4 + 224);
    uint64_t v35 = *(void *)(v4 + 208);
    uint64_t v43 = *(void (**)(void *, uint64_t))(v4 + 248);
    uint64_t v45 = *(void **)(v4 + 200);
    uint64_t v47 = *(void **)(v4 + 192);
    uint64_t v9 = *(void **)(v4 + 168);
    uint64_t v41 = *(void *)(v4 + 160);
    uint64_t v48 = *(void **)(v4 + 152);
    uint64_t v10 = *(void **)(v4 + 136);
    uint64_t v38 = *(void *)(v4 + 144);
    uint64_t v23 = *(void *)(v4 + 120);
    uint64_t v24 = *(void *)(v4 + 128);
    uint64_t v25 = *(void *)(v4 + 112);
    uint64_t v26 = *(void *)(v4 + 96);
    RangeSet.Ranges.subscript.getter(*v22, *(void *)(v4 + 240), a4, (uint64_t)v9);
    unint64_t v27 = *(void (**)(void *, char *, uint64_t))(v24 + 32);
    uint64_t v14 = v36;
    v27(v10, (char *)v22 + *(int *)(v35 + 36), v23);
    uint64_t v28 = (void (*)(uint64_t, void))(*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(v26 + 48))( v4 + 64,  v9,  v25,  v26);
    uint64_t v29 = v26;
    size_t v20 = v45;
    unint64_t v30 = swift_getAssociatedConformanceWitness( v29,  v25,  v38,  (uint64_t)&protocol requirements base descriptor for MutableCollection,  (uint64_t)&associated conformance descriptor for MutableCollection.Collection.SubSequence: MutableCollection);
    (*(void (**)(void *, void *, uint64_t, unint64_t))(v30 + 24))(v45, v10, v38, v30);
    v28(v4 + 64, 0LL);
    uint64_t v18 = v47;
    v43(v9, v41);
    unint64_t v21 = v22;
  }

  free(v21);
  free(v14);
  free(v20);
  free(v18);
  free(v9);
  free(v48);
  free(v10);
  free((void *)v4);
}

unint64_t *Collection.subscript.getter@<X0>( unint64_t **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *a1;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, v4, a2);
  *(void *)(a4 + *(int *)(type metadata accessor for DiscontiguousSlice(0LL, a2, a3, v9) + 36)) = v8;
  return swift_retain(v8, v10, v11, v12);
}

uint64_t Collection.removingSubranges(_:)@<X0>(uint64_t a1@<X1>, const char *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v11 = type metadata accessor for RangeSet(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v10);
  RangeSet._inverted<A>(within:)(v11, a1, (uint64_t)a2, &v15);
  uint64_t v12 = v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a3, v4, a1);
  uint64_t result = type metadata accessor for DiscontiguousSlice(0LL, a1, (uint64_t)a2, v13);
  *(void *)(a3 + *(int *)(result + 36)) = v12;
  return result;
}

uint64_t RangeSet._inverted<A>(within:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v61 = a4;
  uint64_t v7 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v53 = (char *)&v52 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v57 = (char *)&v52 - v11;
  uint64_t v12 = *(void **)(v7 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v62 = (char *)&v52 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  size_t v20 = (char *)&v52 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v52 - v21;
  uint64_t v23 = *(unint64_t ***)(a1 + 24);
  uint64_t v25 = type metadata accessor for Range(0LL, v7, (uint64_t)v23, v24);
  uint64_t v58 = *(void *)(v25 - 8);
  uint64_t v59 = v25;
  uint64_t v26 = MEMORY[0x1895F8858](v25);
  uint64_t v55 = (char *)&v52 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  unint64_t v56 = (char *)&v52 - v28;
  uint64_t v64 = *v63;
  uint64_t v29 = *(void (**)(uint64_t, uint64_t))(a3 + 64);
  swift_retain(v64, v30, v31, v32);
  v29(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(a2, a3);
  uint64_t v33 = (void (*)(void))v12[2];
  ((void (*)(char *, char *, uint64_t))v33)(v17, v22, v7);
  uint64_t v54 = v20;
  uint64_t v34 = v17;
  uint64_t v35 = v62;
  v33();
  uint64_t v36 = v23[3];
  uint64_t v63 = v23;
  if ((((uint64_t (*)(char *, char *, uint64_t, unint64_t **))v36)(v34, v35, v7, v23) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v37 = (void (*)(char *, uint64_t))v12[1];
  v37(v35, v7);
  v37(v34, v7);
  uint64_t v38 = TupleTypeMetadata2;
  uint64_t v39 = v57;
  uint64_t v40 = &v57[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v41 = (void (*)(char *, char *, uint64_t))v12[4];
  v41(v57, v22, v7);
  v41(v40, v54, v7);
  uint64_t v42 = v53;
  uint64_t v43 = &v53[*((int *)v38 + 12)];
  ((void (*)(char *, char *, uint64_t))v33)(v53, v39, v7);
  ((void (*)(char *, char *, uint64_t))v33)(v43, v40, v7);
  uint64_t v44 = v55;
  v41(v55, v42, v7);
  v37(v43, v7);
  uint64_t v45 = &v42[*((int *)v38 + 12)];
  v41(v42, v39, v7);
  v41(v45, v40, v7);
  uint64_t v46 = v59;
  v41(&v44[*(int *)(v59 + 36)], v45, v7);
  v37(v42, v7);
  uint64_t v47 = v58;
  uint64_t v48 = (uint64_t)v56;
  (*(void (**)(char *, char *, uint64_t))(v58 + 32))(v56, v44, v46);
  uint64_t v50 = type metadata accessor for RangeSet.Ranges(0LL, v7, (uint64_t)v63, v49);
  RangeSet.Ranges._gaps(boundedBy:)(v48, v50, &v65);
  (*(void (**)(uint64_t, uint64_t))(v47 + 8))(v48, v46);
  uint64_t result = swift_release((uint64_t)v64);
  *uint64_t v61 = v65;
  return result;
}

uint64_t (*LazyDropWhileSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.init(_base:predicate:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return LazyDropWhileSequence.init(_base:predicate:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyDropWhileSequence,  a6);
}

uint64_t LazyDropWhileSequence.Iterator._predicateHasFailed.getter()
{
  return *v0;
}

uint64_t LazyDropWhileSequence.Iterator._predicateHasFailed.setter(uint64_t result)
{
  _BYTE *v1 = result;
  return result;
}

uint64_t (*LazyDropWhileSequence.Iterator._predicateHasFailed.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t LazyDropWhileSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*LazyDropWhileSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.Iterator.init(_base:predicate:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, _BYTE *a6@<X8>)
{
  return LazyDropWhileSequence.Iterator.init(_base:predicate:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, uint64_t, const char *))type metadata accessor for LazyDropWhileSequence.Iterator,  a6);
}

uint64_t LazyDropWhileSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v31 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v28 = *(void *)(v9 - 8);
  uint64_t v29 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v27 - v11;
  uint64_t v30 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v27 - v13;
  LODWORD(v33) = *v2;
  uint64_t v15 = *(int *)(a1 + 36);
  uint64_t v34 = v2;
  uint64_t v16 = &v2[v15];
  unint64_t v17 = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  v17,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v19 = *(uint64_t (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
  size_t v20 = swift_checkMetadataState(0LL, v17);
  if ((_DWORD)v33 == 1) {
    return v19(v20, AssociatedConformanceWitness);
  }
  uint64_t v32 = v16;
  uint64_t v33 = a1;
  v19(v20, AssociatedConformanceWitness);
  uint64_t v22 = v30;
  uint64_t v23 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v30 + 48);
  if (v23(v12, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_7:
    (*(void (**)(char *, uint64_t))(v28 + 8))(v12, v29);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v22 + 56))( v31,  1LL,  1LL,  AssociatedTypeWitness);
  }

  else
  {
    uint64_t v24 = *(void (**)(char *, char *, unint64_t))(v22 + 32);
    while (1)
    {
      v24(v14, v12, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v22 + 8))(v14, AssociatedTypeWitness);
      uint64_t v25 = swift_checkMetadataState(0LL, v17);
      v19(v25, AssociatedConformanceWitness);
      if (v23(v12, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_7;
      }
    }

    *uint64_t v34 = 1;
    uint64_t v26 = v31;
    v24(v31, v14, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, void, uint64_t, unint64_t))(v22 + 56))( v26,  0LL,  1LL,  AssociatedTypeWitness);
  }

double LazyDropWhileSequence.makeIterator()@<D0>(uint64_t a1@<X0>, _BYTE *a2@<X8>)
{
  *(void *)&double result = LazyDropWhileSequence.makeIterator()( a1,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyDropWhileSequence.Iterator,  a2).n128_u64[0];
  return result;
}

unint64_t *LazySequenceProtocol.drop(while:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazySequenceProtocol.drop(while:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, unint64_t, unint64_t))type metadata accessor for LazyDropWhileSequence,  a5);
}

uint64_t LazyDropWhileSequence<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a1 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 8),  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v46 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v47 = AssociatedTypeWitness;
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v45 = (char *)&v44 - v11;
  uint64_t v12 = a1;
  uint64_t v13 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v17 = *(void *)(v16 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v53 = (char *)&v44 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v52 = (char *)&v44 - v20;
  uint64_t v21 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v58 = a3;
  v21(v8, v5);
  uint64_t v51 = *(void (**)(uint64_t, uint64_t))(v5 + 72);
  uint64_t v57 = v8;
  unint64_t v55 = v16;
  uint64_t v50 = *(void *)(swift_getAssociatedConformanceWitness( v5,  v8,  v16,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v22 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v50 + 8);
  uint64_t v54 = v17;
  uint64_t v48 = *(void (**)(char *, uint64_t, unint64_t))(v17 + 16);
  uint64_t v49 = v22;
  uint64_t v44 = v4;
  while (1)
  {
    uint64_t v23 = v52;
    unint64_t v24 = v55;
    v48(v52, v58, v55);
    uint64_t v25 = v53;
    v51(v57, v5);
    char v26 = v49(v23, v25, v24, v50);
    uint64_t v27 = *(void (**)(char *, unint64_t))(v54 + 8);
    v27(v25, v24);
    v27(v23, v24);
    (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, v4, v12);
    if ((v26 & 1) != 0) {
      break;
    }
    uint64_t v31 = v12;
    uint64_t v32 = &v15[*(int *)(v12 + 36)];
    uint64_t v33 = (unint64_t *)*((void *)v32 + 1);
    unint64_t v56 = *(uint64_t (**)(char *))v32;
    uint64_t v34 = *(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v5 + 80);
    swift_retain(v33, v28, v29, v30);
    uint64_t v35 = v5;
    uint64_t v36 = v34(v59, v58, v57, v5);
    uint64_t v37 = v13;
    uint64_t v39 = v45;
    uint64_t v38 = v46;
    unint64_t v40 = v47;
    (*(void (**)(char *))(v46 + 16))(v45);
    ((void (*)(_BYTE *, void))v36)(v59, 0LL);
    uint64_t v41 = v37;
    uint64_t v42 = *(void (**)(char *, uint64_t))(v37 + 8);
    uint64_t v12 = v31;
    v42(v15, v31);
    LOBYTE(v36) = v56(v39);
    swift_release((uint64_t)v33);
    uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v38 + 8))(v39, v40);
    if ((v36 & 1) == 0) {
      return result;
    }
    uint64_t v5 = v35;
    uint64_t v4 = v44;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v35 + 192))(v58, v57, v35);
    uint64_t v13 = v41;
  }

  return (*(uint64_t (**)(char *, uint64_t))(v13 + 8))(v15, v12);
}

uint64_t LazyDropWhileSequence<>.index(after:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = a1;
  v24[1] = a4;
  uint64_t v7 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)v24 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v12,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)v24 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)v24 - v18;
  uint64_t v20 = *(void (**)(char *, uint64_t, unint64_t))(v14 + 16);
  uint64_t v25 = v6;
  v20((char *)v24 - v18, v6, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, v26, a2);
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v11, a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v6) = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 16))( v19,  v17,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v22 = *(void (**)(char *, unint64_t))(v14 + 8);
  v22(v17, AssociatedTypeWitness);
  if ((v6 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't advance past endIndex",  27LL,  2,  "Swift/DropWhile.swift",  21LL,  2,  0x94uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v7 + 8))(v9, a2);
  v22(v19, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 184))(v25, v11, a3);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazyDropWhileSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyDropWhileSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), a3);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> LazyDropWhileSequence<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x28uLL);
  *a1 = v8;
  v8[4] = LazyDropWhileSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*LazyDropWhileSequence<>.subscript.read( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x38uLL);
  *a1 = v8;
  uint64_t v9 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  v8[4] = AssociatedTypeWitness;
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v8[5] = v11;
  uint64_t v12 = malloc(*(void *)(v11 + 64));
  v8[6] = v12;
  uint64_t v13 = (void (*)(void *, void))(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(a4 + 80))( v8,  a2,  v9,  a4);
  (*(void (**)(void *))(v11 + 16))(v12);
  v13(v8, 0LL);
  return LazyDropWhileSequence<>.subscript.read;
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazyDropWhileSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyDropWhileSequence<>.index(after:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, const char *))LazyDropWhileSequence<>.index(after:));
}

uint64_t LazyDropWhileSequence<>.index(before:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = a3;
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v23 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = v8;
  uint64_t v9 = *(const char **)(v8 + 8);
  uint64_t v11 = *(void *)(v10 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v16 = (char *)&v23 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v23 - v17;
  uint64_t v19 = *(void (**)(char *, uint64_t, unint64_t))(v13 + 16);
  uint64_t v26 = a1;
  v19((char *)&v23 - v17, a1, AssociatedTypeWitness);
  uint64_t v24 = v5;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v28, a2);
  LazyDropWhileSequence<>.startIndex.getter(a2, (uint64_t)v9, (uint64_t)v16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v5) = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 40))( v18,  v16,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v21 = *(void (**)(char *, unint64_t))(v13 + 8);
  v21(v16, AssociatedTypeWitness);
  if ((v5 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't move before startIndex",  28LL,  2,  "Swift/DropWhile.swift",  21LL,  2,  0xA2uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v24 + 8))(v7, a2);
  v21(v18, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v27 + 32))(v26, v11);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> LazyDropWhileSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyDropWhileSequence<>.index(before:)(a1, a2, a3);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t))LazyDropWhileSequence<>.index(before:));
}

uint64_t dump<A, B>(_:to:name:indent:maxDepth:maxItems:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, void *a9@<X8>, uint64_t a10, uint64_t a11)
{
  uint64_t v24 = a7;
  uint64_t v23 = &_swiftEmptyDictionarySingleton;
  (*(void (**)(uint64_t, uint64_t))(a11 + 8))(a10, a11);
  v22[3] = a8;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v22);
  uint64_t v19 = *(void (**)(void *, uint64_t, uint64_t))(*(void *)(a8 - 8) + 16LL);
  v19(boxed_opaque_existential_0Tm, a1, a8);
  _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)( (uint64_t)v22,  a2,  a3,  a4,  a5,  a6,  &v24,  (uint64_t)&v23,  a10,  a11);
  swift_bridgeObjectRelease((uint64_t)v23);
  __swift_destroy_boxed_opaque_existential_1Tm(v22);
  v19(a9, a1, a8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a11 + 16))(a10, a11);
}

void _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  void (*v66)(uint64_t *__return_ptr, id, uint64_t);
  id v67;
  uint64_t v68;
  uint64_t v69;
  int isUniquelyReferenced_nonNull;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  unint64_t v74;
  void (*v75)(id, uint64_t);
  id v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  Swift::String v82;
  uint64_t v83;
  void (*v85)(uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v86;
  unint64_t *v87;
  BOOL v88;
  void (*v89)(uint64_t *__return_ptr, unint64_t *);
  uint64_t v92;
  uint64_t v94;
  unint64_t *v95;
  uint64_t v96;
  unint64_t *v97;
  __int128 v98;
  unint64_t *v99;
  char v100;
  _OWORD v101[2];
  if (*a7 < 1) {
    return;
  }
  --*a7;
  if (a5 < 0) {
    goto LABEL_59;
  }
  if (a5)
  {
    uint64_t v14 = *(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a10 + 24);
    uint64_t v15 = a5;
    do
    {
      v14(32LL, 0xE100000000000000LL, a9, a10);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      --v15;
    }

    while (v15);
  }

  unint64_t v83 = a5;
  outlined init with copy of Any(a1, (uint64_t)v101);
  Mirror.init(reflecting:)((uint64_t *)v101, (uint64_t)&v96);
  char v16 = v98;
  uint64_t v89 = (void (*)(uint64_t *__return_ptr, unint64_t *))*((void *)&v98 + 1);
  uint64_t v86 = v96;
  uint64_t v87 = v99;
  char v17 = v100;
  uint64_t v18 = *(uint64_t (**)(void))(*v97 + 320);
  uint64_t v95 = (unint64_t *)swift_retain_n((uint64_t)v97, 3LL, v19, v20);
  uint64_t v21 = v18();
  uint64_t v22 = 12162786LL;
  if (a6 > 0) {
    uint64_t v22 = 12556002LL;
  }
  unint64_t v94 = v21;
  BOOL v23 = v21 == 0;
  if (v21) {
    uint64_t v24 = v22;
  }
  else {
    uint64_t v24 = 45LL;
  }
  if (v23) {
    uint64_t v25 = 0xE100000000000000LL;
  }
  else {
    uint64_t v25 = 0xA300000000000000LL;
  }
  uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a10 + 24);
  v26(v24, v25, a9, a10);
  swift_bridgeObjectRelease(v25);
  v26(32LL, 0xE100000000000000LL, a9, a10);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  if (a4)
  {
    v26(a3, a4, a9, a10);
    v26(8250LL, 0xE200000000000000LL, a9, a10);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  uint64_t v85 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v26;
  unint64_t v96 = v86;
  uint64_t v97 = v95;
  LOBYTE(v98) = v16;
  *((void *)&v98 + 1) = v89;
  uint64_t v99 = v87;
  uint64_t v100 = v17;
  _dumpPrint_unlocked<A, B>(_:_:_:)((swift::SwiftError **)a1, (uint64_t)&v96, a2, (swift *)byte_189B8D218, a9, a10);
  uint64_t v27 = *(uint64_t **)(a1 + 24);
  uint64_t v28 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm((void *)a1, (uint64_t)v27);
  unint64_t DynamicType = (uint64_t *)swift_getDynamicType(v28, v27, 1);
  if (swift_isClassType(DynamicType)) {
    uint64_t v30 = DynamicType;
  }
  else {
    uint64_t v30 = 0LL;
  }
  if (v30)
  {
    uint64_t v31 = _unsafeDowncastToAnyObject(fromAny:)((void *)a1);
    swift_unknownObjectRelease(v31);
    uint64_t v32 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v26;
    uint64_t v33 = a8;
  }

  else
  {
    outlined init with copy of Any(a1, (uint64_t)&v96);
    uint64_t v34 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any.Type);
    uint64_t v32 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v26;
    uint64_t v33 = a8;
    uint64_t v31 = *(char **)&v101[0];
  }

  uint64_t v35 = *(void *)v33;
  if (*(void *)(*(void *)v33 + 16LL))
  {
    unint64_t v36 = specialized __RawDictionaryStorage.find<A>(_:)((uint64_t)v31);
    if ((v37 & 1) != 0)
    {
      uint64_t v38 = *(void *)(*(void *)(v35 + 56) + 8 * v36);
      swift_release((uint64_t)v87);
      swift_release_n((uint64_t)v95, 4LL);
      v32(8992LL, 0xE200000000000000LL, a9, a10);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v96 = v38;
      _print_unlocked<A, B>(_:_:)((uint64_t)&v96, a2, (swift *)&type metadata for Int, a9, a10);
      v32(10LL, 0xE100000000000000LL, a9, a10);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return;
    }

    uint64_t v39 = *(void *)(v35 + 16);
    uint64_t v35 = *(void *)v33;
  }

  else
  {
    uint64_t v39 = 0LL;
  }

  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v35);
  unint64_t v96 = *(void *)v33;
  *(void *)uint64_t v33 = 0x8000000000000000LL;
  specialized _NativeDictionary.setValue(_:forKey:isUnique:)(v39, (uint64_t)v31, isUniquelyReferenced_nonNull_native);
  uint64_t v41 = *(void *)v33;
  *(void *)uint64_t v33 = v96;
  swift_bridgeObjectRelease(v41);
  v32(8992LL, 0xE200000000000000LL, a9, a10);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  unint64_t v96 = v39;
  _print_unlocked<A, B>(_:_:)((uint64_t)&v96, a2, (swift *)&type metadata for Int, a9, a10);
LABEL_29:
  v32(10LL, 0xE100000000000000LL, a9, a10);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  BOOL v45 = a6 < 1;
  uint64_t v92 = a6 - 1;
  uint64_t v46 = (uint64_t)v95;
  if (v45)
  {
    swift_release((uint64_t)v87);
    uint64_t v79 = (uint64_t)v95;
    uint64_t v80 = 4LL;
    goto LABEL_47;
  }

  swift_retain(v95, v42, v43, v44);
  uint64_t v50 = swift_retain(v87, v47, v48, v49);
  v89(&v96, v50);
  swift_release((uint64_t)v87);
  swift_release((uint64_t)v95);
  uint64_t v54 = v96;
  if (v96)
  {
    uint64_t v55 = (uint64_t)v97;
    __int128 v57 = v98;
    uint64_t v56 = (uint64_t)v99;
    v100 &= 1u;
    if (__OFADD__(v83, 2LL))
    {
      __break(1u);
LABEL_61:
      __break(1u);
      return;
    }

    _dumpSuperclass_unlocked<A>(mirror:to:indent:maxDepth:maxItemCounter:visitedItems:)( &v96,  a2,  v83 + 2,  v92,  a7,  v33,  a9,  a10);
    outlined consume of Mirror?(v54, v55, v57, *((uint64_t *)&v57 + 1), v56);
    uint64_t v46 = (uint64_t)v95;
  }

  uint64_t v59 = *(void **)(v46 + 16);
  uint64_t v58 = *(void *)(v46 + 24);
  swift_unknownObjectRetain(v59, v51, v52, v53);
  swift_release((uint64_t)v87);
  swift_release(v46);
  if (v94 < 0) {
    goto LABEL_59;
  }
  if (!v94)
  {
LABEL_45:
    swift_unknownObjectRelease(v59);
    uint64_t v79 = (uint64_t)v95;
    uint64_t v80 = 3LL;
LABEL_47:
    swift_release_n(v79, v80);
    return;
  }

  uint64_t v63 = 0LL;
  BOOL v64 = __OFADD__(v83, 2LL);
  uint64_t v88 = v64;
  uint64_t v65 = a7;
  while (*v65 > 0)
  {
    uint64_t v66 = *(void (**)(uint64_t *__return_ptr, id, uint64_t))(*v95 + 256);
    uint64_t v67 = swift_unknownObjectRetain(v59, v60, v61, v62);
    v66(&v96, v67, v58);
    swift_unknownObjectRelease(v59);
    uint64_t v68 = v96;
    uint64_t v69 = (uint64_t)v97;
    outlined init with take of Any(&v98, v101);
    isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull((unint64_t)v59);
    unint64_t v74 = *v95;
    if (isUniquelyReferenced_nonNull)
    {
      uint64_t v75 = *(void (**)(id, uint64_t))(v74 + 272);
      uint64_t v76 = swift_unknownObjectRetain(v59, v71, v72, v73);
      v75(v76, v58);
      uint64_t v33 = a8;
      swift_unknownObjectRelease(v59);
    }

    else
    {
      uint64_t v77 = (*(uint64_t (**)(void *, uint64_t))(v74 + 264))(v59, v58);
      uint64_t v58 = v78;
      swift_unknownObjectRelease(v59);
      uint64_t v59 = (void *)v77;
    }

    uint64_t v65 = a7;
    if (v88)
    {
      __break(1u);
LABEL_59:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    ++v63;
    _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)( v101,  a2,  v68,  v69,  v83 + 2,  v92,  a7,  v33,  a9,  a10);
    swift_bridgeObjectRelease(v69);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v101);
    if (v94 == v63) {
      goto LABEL_45;
    }
  }

  swift_release_n((uint64_t)v95, 3LL);
  char v81 = v83 + 4;
  if (__OFADD__(v83, 4LL)) {
    goto LABEL_61;
  }
  if (v81 < 0) {
    goto LABEL_59;
  }
  swift_unknownObjectRelease(v59);
  if (v83 != -4)
  {
    do
    {
      unint64_t v96 = 32LL;
      uint64_t v97 = (unint64_t *)0xE100000000000000LL;
      _print_unlocked<A, B>(_:_:)((uint64_t)&v96, a2, (swift *)&type metadata for String, a9, a10);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      --v81;
    }

    while (v81);
  }

  v85(40LL, 0xE100000000000000LL, a9, a10);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  unint64_t v96 = v94 - v63;
  _print_unlocked<A, B>(_:_:)((uint64_t)&v96, a2, (swift *)&type metadata for Int, a9, a10);
  if (v63)
  {
    v85(0x65726F6D20LL, 0xE500000000000000LL, a9, a10);
    swift_bridgeObjectRelease(0xE500000000000000LL);
  }

  if (v94 - 1 == v63)
  {
    v85(0xA29646C69686320LL, 0xE800000000000000LL, a9, a10);
    swift_bridgeObjectRelease(0xE800000000000000LL);
  }

  else
  {
    uint64_t v82 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" children)\n", 0xBuLL, 1);
    ((void (*)(uint64_t))v85)(v82._countAndFlagsBits);
    swift_bridgeObjectRelease((uint64_t)v82._object);
  }

void dump<A>(_:name:indent:maxDepth:maxItems:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  uint64_t v20 = a6;
  uint64_t v19 = &_swiftEmptyDictionarySingleton;
  _swift_stdlib_flockfile_stdout();
  uint64_t v18[3] = a7;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v18);
  char v16 = *(void (**)(void *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL);
  v16(boxed_opaque_existential_0Tm, a1, a7);
  _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)( (uint64_t)v18,  v17,  a2,  a3,  a4,  a5,  &v20,  (uint64_t)&v19,  (uint64_t)&type metadata for _Stdout,  (uint64_t)&protocol witness table for _Stdout);
  swift_bridgeObjectRelease((uint64_t)v19);
  __swift_destroy_boxed_opaque_existential_1Tm(v18);
  v16(a8, a1, a7);
  _swift_stdlib_funlockfile_stdout();
}

void _dumpPrint_unlocked<A, B>(_:_:_:)( swift::SwiftError **a1, uint64_t a2, uint64_t a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v179 = a5;
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v12 = (uint64_t *)((char *)&v176 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (uint64_t *)((char *)&v176 - v14);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v20 = (uint64_t *)((char *)&v176 - v19);
  unint64_t v21 = *(void *)v17;
  unint64_t v22 = *(void *)(v17 + 8);
  unsigned int v23 = *(unsigned __int8 *)(v17 + 16);
  __n128 v24 = *(__n128 *)(v17 + 24);
  char v25 = *(_BYTE *)(v17 + 40);
  if (v23 != 8)
  {
    switch(*(_BYTE *)(v17 + 16))
    {
      case 3:
        uint64_t v28 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v22 + 320LL))(v16, v24);
        if (v28 == 1)
        {
          uint64_t v29 = "(1 element)";
          Builtin::Word v30 = 11LL;
          goto LABEL_15;
        }

        uint64_t v60 = v28;
        unint64_t v61 = specialized static String._createEmpty(withInitialCapacity:)(13LL);
        uint64_t v63 = v62;
        unint64_t v180 = v61;
        unint64_t v181 = v62;
        uint64_t v64 = HIBYTE(v62) & 0xF;
        if ((v62 & 0x2000000000000000LL) == 0) {
          uint64_t v64 = v61 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v42 = v179;
        if (v64 || (v61 & ~v62 & 0x2000000000000000LL) != 0)
        {
          if ((v62 & 0x2000000000000000LL) == 0
            || (unint64_t v65 = specialized _SmallString.init(_:appending:)(v61, v62, 0x28uLL, 0xE100000000000000LL),
                (v67 & 1) != 0))
          {
            _StringGuts.append(_:)(40LL, 0xE100000000000000LL, 0LL, 1LL);
            swift_bridgeObjectRelease(0xE100000000000000LL);
            unint64_t v68 = v180;
            unint64_t v69 = v181;
            goto LABEL_67;
          }

          unint64_t v68 = v65;
          unint64_t v69 = v66;
          swift_bridgeObjectRelease(v63);
          swift_bridgeObjectRelease(0xE100000000000000LL);
        }

        else
        {
          swift_bridgeObjectRelease(v62);
          unint64_t v68 = 40LL;
          unint64_t v69 = 0xE100000000000000LL;
        }

        unint64_t v180 = v68;
        unint64_t v181 = v69;
LABEL_67:
        uint64_t v112 = _int64ToString(_:radix:uppercase:)( v60,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v113 = v111;
        uint64_t v114 = HIBYTE(v69) & 0xF;
        if ((v69 & 0x2000000000000000LL) == 0) {
          uint64_t v114 = v68 & 0xFFFFFFFFFFFFLL;
        }
        if (v114 || (v68 & ~v69 & 0x2000000000000000LL) != 0)
        {
          if ((v69 & 0x2000000000000000LL) != 0)
          {
            if ((v111 & 0x2000000000000000LL) != 0)
            {
              unint64_t v116 = specialized _SmallString.init(_:appending:)(v68, v69, v112, v111);
              if ((v118 & 1) == 0)
              {
                uint64_t v119 = v116;
                unint64_t v120 = v117;
                swift_bridgeObjectRelease(v69);
                swift_bridgeObjectRelease(v113);
                unint64_t v180 = v119;
                unint64_t v181 = v120;
                unint64_t v113 = v120;
                uint64_t v112 = v119;
                goto LABEL_80;
              }

              goto LABEL_78;
            }
          }

          else if ((v111 & 0x2000000000000000LL) != 0)
          {
LABEL_78:
            uint64_t v115 = HIBYTE(v113) & 0xF;
            goto LABEL_79;
          }

          uint64_t v115 = v112 & 0xFFFFFFFFFFFFLL;
LABEL_79:
          _StringGuts.append(_:)(v112, v113, 0LL, v115);
          swift_bridgeObjectRelease(v113);
          uint64_t v112 = v180;
          unint64_t v113 = v181;
          goto LABEL_80;
        }

        swift_bridgeObjectRelease(v69);
        unint64_t v180 = v112;
        unint64_t v181 = v113;
LABEL_80:
        Swift::String v121 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements)", 0xAuLL, 1);
        uint64_t countAndFlagsBits = v121._countAndFlagsBits;
        unint64_t object = (unint64_t)v121._object;
        uint64_t v122 = HIBYTE(v113) & 0xF;
        if ((v113 & 0x2000000000000000LL) == 0) {
          uint64_t v122 = v112 & 0xFFFFFFFFFFFFLL;
        }
        if (v122 || (v112 & ~v113 & 0x2000000000000000LL) != 0) {
          goto LABEL_104;
        }
LABEL_114:
        swift_bridgeObjectRelease(v113);
        goto LABEL_113;
      case 5:
        uint64_t v38 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v22 + 320LL))(v16, v24);
        if (v38 == 1)
        {
          uint64_t v29 = "1 element";
          Builtin::Word v30 = 9LL;
LABEL_15:
          Swift::String v39 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(v29, v30, 1);
          uint64_t countAndFlagsBits = v39._countAndFlagsBits;
          unint64_t object = (unint64_t)v39._object;
          uint64_t v42 = v179;
          goto LABEL_113;
        }

        uint64_t v70 = v38;
        unint64_t v71 = specialized static String._createEmpty(withInitialCapacity:)(11LL);
        uint64_t v73 = v72;
        unint64_t v180 = v71;
        unint64_t v181 = v72;
        uint64_t v74 = HIBYTE(v72) & 0xF;
        if ((v72 & 0x2000000000000000LL) == 0) {
          uint64_t v74 = v71 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v42 = v179;
        if (v74 || (v71 & ~v72 & 0x2000000000000000LL) != 0)
        {
          if ((v72 & 0x2000000000000000LL) == 0
            || (unint64_t v75 = specialized _SmallString.init(_:appending:)(v71, v72, 0LL, 0xE000000000000000LL), (v77 & 1) != 0))
          {
            _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
            swift_bridgeObjectRelease(0xE000000000000000LL);
            unint64_t v78 = v180;
            unint64_t v79 = v181;
            goto LABEL_87;
          }

          unint64_t v78 = v75;
          unint64_t v79 = v76;
          swift_bridgeObjectRelease(v73);
          swift_bridgeObjectRelease(0xE000000000000000LL);
          unint64_t v180 = v78;
        }

        else
        {
          swift_bridgeObjectRelease(v72);
          unint64_t v78 = 0LL;
          unint64_t v79 = 0xE000000000000000LL;
          unint64_t v180 = 0LL;
        }

        unint64_t v181 = v79;
LABEL_87:
        uint64_t v112 = _int64ToString(_:radix:uppercase:)( v70,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v113 = v123;
        uint64_t v124 = HIBYTE(v79) & 0xF;
        if ((v79 & 0x2000000000000000LL) == 0) {
          uint64_t v124 = v78 & 0xFFFFFFFFFFFFLL;
        }
        if (v124 || (v78 & ~v79 & 0x2000000000000000LL) != 0)
        {
          if ((v79 & 0x2000000000000000LL) != 0)
          {
            if ((v123 & 0x2000000000000000LL) != 0)
            {
              unint64_t v126 = specialized _SmallString.init(_:appending:)(v78, v79, v112, v123);
              if ((v128 & 1) == 0)
              {
                uint64_t v129 = v126;
                unint64_t v130 = v127;
                swift_bridgeObjectRelease(v79);
                swift_bridgeObjectRelease(v113);
                unint64_t v180 = v129;
                unint64_t v181 = v130;
                unint64_t v113 = v130;
                uint64_t v112 = v129;
                goto LABEL_100;
              }

              goto LABEL_98;
            }
          }

          else if ((v123 & 0x2000000000000000LL) != 0)
          {
LABEL_98:
            uint64_t v125 = HIBYTE(v113) & 0xF;
            goto LABEL_99;
          }

          uint64_t v125 = v112 & 0xFFFFFFFFFFFFLL;
LABEL_99:
          _StringGuts.append(_:)(v112, v113, 0LL, v125);
          swift_bridgeObjectRelease(v113);
          uint64_t v112 = v180;
          unint64_t v113 = v181;
          goto LABEL_100;
        }

        swift_bridgeObjectRelease(v79);
        unint64_t v180 = v112;
        unint64_t v181 = v113;
LABEL_100:
        Swift::String v131 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements", 9uLL, 1);
        uint64_t countAndFlagsBits = v131._countAndFlagsBits;
        unint64_t object = (unint64_t)v131._object;
        uint64_t v132 = HIBYTE(v113) & 0xF;
        if ((v113 & 0x2000000000000000LL) == 0) {
          uint64_t v132 = v112 & 0xFFFFFFFFFFFFLL;
        }
        if (!v132 && (v112 & ~v113 & 0x2000000000000000LL) == 0) {
          goto LABEL_114;
        }
LABEL_104:
        if ((v113 & 0x2000000000000000LL) != 0)
        {
          if ((object & 0x2000000000000000LL) != 0)
          {
            unint64_t v134 = specialized _SmallString.init(_:appending:)(v112, v113, countAndFlagsBits, object);
            if ((v136 & 1) == 0)
            {
              unint64_t v137 = v134;
              unint64_t v138 = v135;
              swift_bridgeObjectRelease(v113);
              swift_bridgeObjectRelease(object);
              uint64_t countAndFlagsBits = v137;
              unint64_t object = v138;
LABEL_113:
              (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a6 + 24))( countAndFlagsBits,  object,  v42,  a6);
LABEL_144:
              swift_bridgeObjectRelease(object);
              return;
            }

            goto LABEL_111;
          }
        }

        else if ((object & 0x2000000000000000LL) != 0)
        {
LABEL_111:
          uint64_t v133 = HIBYTE(object) & 0xF;
          goto LABEL_112;
        }

        uint64_t v133 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_112:
        _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v133);
        swift_bridgeObjectRelease(object);
        uint64_t countAndFlagsBits = v180;
        unint64_t object = v181;
        goto LABEL_113;
      case 6:
        unint64_t v43 = 0xD000000000000010LL;
        uint64_t v44 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v22 + 320LL))(v16, v24);
        if (v44 == 1)
        {
          unint64_t object = 0x80000001818BB280LL | 0x8000000000000000LL;
          uint64_t v45 = v179;
          goto LABEL_143;
        }

        uint64_t v80 = v44;
        unint64_t v81 = specialized static String._createEmpty(withInitialCapacity:)(18LL);
        uint64_t v83 = v82;
        unint64_t v180 = v81;
        unint64_t v181 = v82;
        uint64_t v84 = HIBYTE(v82) & 0xF;
        if ((v82 & 0x2000000000000000LL) == 0) {
          uint64_t v84 = v81 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v45 = v179;
        if (v84 || (v81 & ~v82 & 0x2000000000000000LL) != 0)
        {
          if ((v82 & 0x2000000000000000LL) == 0
            || (unint64_t v85 = specialized _SmallString.init(_:appending:)(v81, v82, 0LL, 0xE000000000000000LL), (v87 & 1) != 0))
          {
            _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
            swift_bridgeObjectRelease(0xE000000000000000LL);
            unint64_t v88 = v180;
            unint64_t v89 = v181;
            goto LABEL_117;
          }

          unint64_t v88 = v85;
          unint64_t v89 = v86;
          swift_bridgeObjectRelease(v83);
          swift_bridgeObjectRelease(0xE000000000000000LL);
          unint64_t v180 = v88;
        }

        else
        {
          swift_bridgeObjectRelease(v82);
          unint64_t v88 = 0LL;
          unint64_t v89 = 0xE000000000000000LL;
          unint64_t v180 = 0LL;
        }

        unint64_t v181 = v89;
LABEL_117:
        uint64_t v140 = _int64ToString(_:radix:uppercase:)( v80,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v141 = v139;
        uint64_t v142 = HIBYTE(v89) & 0xF;
        if ((v89 & 0x2000000000000000LL) == 0) {
          uint64_t v142 = v88 & 0xFFFFFFFFFFFFLL;
        }
        if (!v142 && (v88 & ~v89 & 0x2000000000000000LL) == 0)
        {
          uint64_t v149 = a6;
          swift_bridgeObjectRelease(v89);
          unint64_t v180 = v140;
          unint64_t v181 = v141;
LABEL_130:
          uint64_t v150 = HIBYTE(v141) & 0xF;
          if ((v141 & 0x2000000000000000LL) == 0) {
            uint64_t v150 = v140 & 0xFFFFFFFFFFFFLL;
          }
          if (v150 || (v140 & ~v141 & 0x2000000000000000LL) != 0)
          {
            if ((v141 & 0x2000000000000000LL) != 0
              && (0x80000001818BB260LL & 0x2000000000000000LL) != 0
              && (unint64_t v151 = specialized _SmallString.init(_:appending:)( v140,  v141,  0xD000000000000010LL,  0x80000001818BB260LL | 0x8000000000000000LL),  (v153 & 1) == 0))
            {
              unint64_t v43 = v151;
              unint64_t object = v152;
              swift_bridgeObjectRelease(v141);
              swift_bridgeObjectRelease(0x80000001818BB260LL | 0x8000000000000000LL);
            }

            else
            {
              if ((0x80000001818BB260LL & 0x2000000000000000LL) != 0) {
                unint64_t v154 = (0x80000001818BB260LL >> 56) & 0xF;
              }
              else {
                unint64_t v154 = 16LL;
              }
              _StringGuts.append(_:)(0xD000000000000010LL, 0x80000001818BB260LL | 0x8000000000000000LL, 0LL, v154);
              swift_bridgeObjectRelease(0x80000001818BB260LL | 0x8000000000000000LL);
              unint64_t v43 = v180;
              unint64_t object = v181;
            }
          }

          else
          {
            swift_bridgeObjectRelease(v141);
            unint64_t object = 0x80000001818BB260LL | 0x8000000000000000LL;
          }

          a6 = v149;
LABEL_143:
          (*(void (**)(unint64_t, unint64_t, uint64_t, uint64_t))(a6 + 24))(v43, object, v45, a6);
          goto LABEL_144;
        }

        if ((v89 & 0x2000000000000000LL) != 0)
        {
          if ((v139 & 0x2000000000000000LL) != 0)
          {
            unint64_t v144 = specialized _SmallString.init(_:appending:)(v88, v89, v140, v139);
            if ((v146 & 1) == 0)
            {
              uint64_t v147 = v144;
              unint64_t v148 = v145;
              uint64_t v149 = a6;
              swift_bridgeObjectRelease(v89);
              swift_bridgeObjectRelease(v141);
              unint64_t v180 = v147;
              unint64_t v181 = v148;
              unint64_t v141 = v148;
              uint64_t v140 = v147;
              goto LABEL_130;
            }

            goto LABEL_128;
          }
        }

        else if ((v139 & 0x2000000000000000LL) != 0)
        {
LABEL_128:
          uint64_t v143 = HIBYTE(v141) & 0xF;
          goto LABEL_129;
        }

        uint64_t v143 = v140 & 0xFFFFFFFFFFFFLL;
LABEL_129:
        uint64_t v149 = a6;
        _StringGuts.append(_:)(v140, v141, 0LL, v143);
        swift_bridgeObjectRelease(v141);
        uint64_t v140 = v180;
        unint64_t v141 = v181;
        goto LABEL_130;
      case 7:
        uint64_t v46 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v22 + 320LL))(v16, v24);
        if (v46 == 1)
        {
          uint64_t v47 = 0xE800000000000000LL;
          unint64_t v48 = 0x7265626D656D2031LL;
          uint64_t v49 = v179;
          goto LABEL_168;
        }

        uint64_t v90 = v46;
        unint64_t v91 = specialized static String._createEmpty(withInitialCapacity:)(10LL);
        uint64_t v93 = v92;
        unint64_t v180 = v91;
        unint64_t v181 = v92;
        uint64_t v94 = HIBYTE(v92) & 0xF;
        if ((v92 & 0x2000000000000000LL) == 0) {
          uint64_t v94 = v91 & 0xFFFFFFFFFFFFLL;
        }
        uint64_t v49 = v179;
        if (v94 || (v91 & ~v92 & 0x2000000000000000LL) != 0)
        {
          if ((v92 & 0x2000000000000000LL) == 0
            || (unint64_t v95 = specialized _SmallString.init(_:appending:)(v91, v92, 0LL, 0xE000000000000000LL), (v97 & 1) != 0))
          {
            _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
            swift_bridgeObjectRelease(0xE000000000000000LL);
            unint64_t v98 = v180;
            unint64_t v99 = v181;
            goto LABEL_147;
          }

          unint64_t v98 = v95;
          unint64_t v99 = v96;
          swift_bridgeObjectRelease(v93);
          swift_bridgeObjectRelease(0xE000000000000000LL);
          unint64_t v180 = v98;
        }

        else
        {
          swift_bridgeObjectRelease(v92);
          unint64_t v98 = 0LL;
          unint64_t v99 = 0xE000000000000000LL;
          unint64_t v180 = 0LL;
        }

        unint64_t v181 = v99;
LABEL_147:
        uint64_t v156 = _int64ToString(_:radix:uppercase:)( v90,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v157 = v155;
        uint64_t v158 = HIBYTE(v99) & 0xF;
        if ((v99 & 0x2000000000000000LL) == 0) {
          uint64_t v158 = v98 & 0xFFFFFFFFFFFFLL;
        }
        if (!v158 && (v98 & ~v99 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v99);
          unint64_t v180 = v156;
          unint64_t v181 = v157;
LABEL_160:
          unint64_t v48 = 0x737265626D656D20LL;
          uint64_t v165 = HIBYTE(v157) & 0xF;
          if ((v157 & 0x2000000000000000LL) == 0) {
            uint64_t v165 = v156 & 0xFFFFFFFFFFFFLL;
          }
          if (v165 || (v156 & ~v157 & 0x2000000000000000LL) != 0)
          {
            if ((v157 & 0x2000000000000000LL) == 0
              || (unint64_t v166 = specialized _SmallString.init(_:appending:)( v156,  v157,  0x737265626D656D20uLL,  0xE800000000000000LL),  (v168 & 1) != 0))
            {
              _StringGuts.append(_:)(0x737265626D656D20LL, 0xE800000000000000LL, 0LL, 8LL);
              swift_bridgeObjectRelease(0xE800000000000000LL);
              unint64_t v48 = v180;
              uint64_t v47 = v181;
            }

            else
            {
              unint64_t v48 = v166;
              uint64_t v47 = v167;
              swift_bridgeObjectRelease(v157);
              swift_bridgeObjectRelease(0xE800000000000000LL);
            }
          }

          else
          {
            swift_bridgeObjectRelease(v157);
            uint64_t v47 = 0xE800000000000000LL;
          }

LABEL_168:
          (*(void (**)(unint64_t, uint64_t, uint64_t, uint64_t))(a6 + 24))(v48, v47, v49, a6);
          swift_bridgeObjectRelease(v47);
          return;
        }

        if ((v99 & 0x2000000000000000LL) != 0)
        {
          if ((v155 & 0x2000000000000000LL) != 0)
          {
            unint64_t v160 = specialized _SmallString.init(_:appending:)(v98, v99, v156, v155);
            if ((v162 & 1) == 0)
            {
              uint64_t v163 = v160;
              unint64_t v164 = v161;
              swift_bridgeObjectRelease(v99);
              swift_bridgeObjectRelease(v157);
              unint64_t v180 = v163;
              unint64_t v181 = v164;
              unint64_t v157 = v164;
              uint64_t v156 = v163;
              goto LABEL_160;
            }

            goto LABEL_158;
          }
        }

        else if ((v155 & 0x2000000000000000LL) != 0)
        {
LABEL_158:
          uint64_t v159 = HIBYTE(v157) & 0xF;
          goto LABEL_159;
        }

        uint64_t v159 = v156 & 0xFFFFFFFFFFFFLL;
LABEL_159:
        _StringGuts.append(_:)(v156, v157, 0LL, v159);
        swift_bridgeObjectRelease(v157);
        uint64_t v156 = v180;
        unint64_t v157 = v181;
        goto LABEL_160;
      default:
        break;
    }
  }

  __int128 v176 = *(_OWORD *)(v17 + 24);
  unint64_t v177 = v21;
  uint64_t v178 = a6;
  uint64_t v26 = *(void (**)(uint64_t *, swift::SwiftError **, swift *))(v18 + 16);
  v26(v20, a1, a4);
  uint64_t v27 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v185, v20, a4, v27, 6uLL)
    || (uint64_t v187 = 0LL,
        __int128 v185 = 0u,
        __int128 v186 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v185,  &demangling cache variable for type metadata for CustomDebugStringConvertible?),  v26(v15, a1, a4),  uint64_t v31 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible),  swift_dynamicCast((char *)&v185, v15, a4, v31, 6uLL)))
  {
    outlined init with take of MirrorPath(&v185, (uint64_t)&v180);
    __int128 v32 = v183;
    __swift_project_boxed_opaque_existential_0Tm(&v180, v183);
    uint64_t v33 = (*(uint64_t (**)(void, void))(*((void *)&v32 + 1) + 8LL))(v32, *((void *)&v32 + 1));
    uint64_t v35 = v34;
    (*(void (**)(uint64_t))(v178 + 24))(v33);
    swift_bridgeObjectRelease(v35);
LABEL_9:
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v180);
    return;
  }

  uint64_t v187 = 0LL;
  __int128 v185 = 0u;
  __int128 v186 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v185,  &demangling cache variable for type metadata for CustomStringConvertible?);
  v26(v12, a1, a4);
  unint64_t v36 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v185, v12, a4, v36, 6uLL))
  {
    outlined init with take of MirrorPath(&v185, (uint64_t)&v180);
    __int128 v37 = v183;
    __swift_project_boxed_opaque_existential_0Tm(&v180, v183);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*((void *)&v37 + 1) + 8LL))( a3,  v179,  v178,  v37,  *((void *)&v37 + 1));
    goto LABEL_9;
  }

  uint64_t v187 = 0LL;
  __int128 v185 = 0u;
  __int128 v186 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v185,  &demangling cache variable for type metadata for TextOutputStreamable?);
  uint64_t v50 = v178;
  if (v23 == 8) {
    goto LABEL_61;
  }
  if (v23 < 2)
  {
    TypeName = (uint64_t *)swift_getTypeName(v177, 1);
    if ((v52 & 0x8000000000000000LL) == 0)
    {
      uint64_t v53 = (uint8x16_t *)TypeName;
      int64_t v54 = v52;
      int64_t v55 = validateUTF8(_:)(TypeName, v52);
      if ((v57 & 1) != 0) {
        uint64_t v58 = repairUTF8(_:firstKnownBrokenRange:)(v53->i8, v54, v55, v56);
      }
      else {
        uint64_t v58 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v53, v54, v55 & 1);
      }
      uint64_t v110 = v59;
      (*(void (**)(uint64_t))(v50 + 24))(v58);
      goto LABEL_64;
    }

          v371 = v623;
          ((void (*)(uint64_t, char *))v149)(v334, v67);
          v372 = (uint64_t (*)(unint64_t *, unint64_t *))v336[8];
          v373 = v649;
          if ((v372(v649, v336) & 1) != 0)
          {
            v374 = v607;
            (*(void (**)(char *, char *, unint64_t *))(v644 + 16))(v607, v371, v373);
            v375 = v641;
            v376 = v645;
            v377 = v642;
            v378 = swift_getAssociatedConformanceWitness( (uint64_t)v645,  (uint64_t)v649,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v378 + 8))( &qword_18180BE68,  256LL,  v377,  v378);
            v379 = v658;
            v373 = v649;
            (*((void (**)(char *, unint64_t *, const char *))v376 + 3))(v375, v649, v376);
            v380 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v336[4] + 8) + 32LL))( v374,  v379,  v373);
            v381 = v656;
            ((void (*)(char *, unint64_t *))v656)(v379, v373);
            if ((v380 & 1) == 0) {
              goto LABEL_272;
            }
            ((void (*)(char *, unint64_t *))v381)(v374, v373);
            v336 = (unint64_t *)v657;
            v371 = v623;
            unint64_t v130 = (uint64_t)v646;
          }

          v356 = v373;
          v382 = (uint64_t (*)(unint64_t *, unint64_t *))v336[16];
          if (v382(v373, v336) < 32)
          {
LABEL_195:
            v425 = ((uint64_t (*)(unint64_t *, unint64_t *))v336[15])(v356, v336);
            v426 = v371;
            v302 = v656;
            ((void (*)(char *, unint64_t *))v656)(v426, v356);
            if (v203 < 0x20) {
              v427 = v425 << v203;
            }
            else {
              v427 = 0;
            }
LABEL_247:
            v439 = v645;
            v536 = v648;
            v537 = 0;
            v535 = v647 | v427;
            v492 = v657;
            goto LABEL_248;
          }

          v383 = *(void (**)(char *, char *, unint64_t *))(v644 + 16);
          v383(v619, v371, v373);
          LODWORD(v660) = -1;
          v384 = v372(v373, v336);
          v385 = v336;
          v386 = v384;
          v387 = v382(v373, v385);
          if ((v386 & 1) != 0)
          {
            if (v387 <= 32)
            {
              v390 = (void (**)(char *, unint64_t *, const char *))v645;
              v356 = v649;
              v391 = v642;
              v392 = swift_getAssociatedConformanceWitness( (uint64_t)v645,  (uint64_t)v649,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v393 = v641;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v392 + 8))( &qword_18180BE68,  256LL,  v391,  v392);
              v394 = v658;
              v390[3](v393, v356, (const char *)v390);
              v395 = v657;
              v396 = v619;
              LOBYTE(v390) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v657 + 32) + 8LL)
                                                                                           + 40LL))( v619,  v394,  v356);
              v397 = v656;
              ((void (*)(char *, unint64_t *))v656)(v394, v356);
              v398 = v660;
              v399 = v596;
              v383(v596, v396, v356);
              if ((v390 & 1) == 0)
              {
                ((void (*)(char *, unint64_t *))v397)(v399, v356);
                uint64_t v203 = v655;
                unint64_t v130 = (uint64_t)v646;
LABEL_194:
                ((void (*)(char *, unint64_t *))v397)(v396, v356);
                v336 = (unint64_t *)v657;
                goto LABEL_195;
              }

              v400 = (*(uint64_t (**)(unint64_t *, uint64_t))(v395 + 120))(v356, v395);
              ((void (*)(char *, unint64_t *))v397)(v399, v356);
              v401 = v398 >= v400;
LABEL_186:
              uint64_t v203 = v655;
              unint64_t v130 = (uint64_t)v646;
              if (!v401) {
                goto LABEL_232;
              }
              goto LABEL_194;
            }
          }

          else if (v387 <= 32)
          {
            v412 = v658;
            v396 = v619;
            v356 = v649;
            v383(v658, v619, v649);
            v413 = (*(uint64_t (**)(unint64_t *))(v657 + 120))(v356);
            v397 = v656;
            ((void (*)(char *, unint64_t *))v656)(v412, v356);
            v401 = v660 >= v413;
            goto LABEL_186;
          }

          v402 = v657;
          v403 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v657 + 96);
          v404 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v387, v388, v389);
          v405 = v658;
          v356 = v649;
          v403(&v660, &type metadata for UInt32, v404, v649, v402);
          v396 = v619;
          LOBYTE(v403) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v402 + 32) + 8LL)
                                                                                       + 16LL))( v405,  v619,  v356);
          v397 = v656;
          ((void (*)(char *, unint64_t *))v656)(v405, v356);
          uint64_t v203 = v655;
          unint64_t v130 = (uint64_t)v646;
          goto LABEL_194;
        }
      }

      else
      {
        ((void (*)(char *, unint64_t *))v149)(v313, v69);
      }

      ((void (*)(char *, char *, unint64_t *))v203)(v314, v279, v69);
      v660 = 0x7FFFFFFFFFFFFFFFLL;
      v315 = ((uint64_t (*)(unint64_t *, char *))v656)(v69, v67);
      v316 = v180(v69, v67);
      if ((v315 & 1) != 0)
      {
        if (v316 > 64)
        {
          v319 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
          v320 = lazy protocol witness table accessor for type Int and conformance Int(v316, v317, v318);
          v321 = &v660;
          goto LABEL_150;
        }
      }

      else if (v316 >= 64)
      {
        v659 = 0x7FFFFFFFFFFFFFFFLL;
        v319 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
        v320 = lazy protocol witness table accessor for type Int and conformance Int(v316, v317, v318);
        v321 = &v659;
LABEL_150:
        v319(v321, &type metadata for Int, v320, v69, v67);
        v325 = (*(uint64_t (**)(float *, char *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                              + 16LL))( v169,  v314,  v69);
        ((void (*)(float *, unint64_t *))v149)(v169, v69);
        if ((v325 & 1) == 0) {
          goto LABEL_151;
        }
        goto LABEL_149;
      }

      ((void (*)(float *, char *, unint64_t *))v203)(v169, v314, v69);
      v323 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
      ((void (*)(float *, unint64_t *))v149)(v169, v69);
      if (v660 >= v323)
      {
LABEL_151:
        ((void (*)(char *, unint64_t *))v149)(v314, v69);
        goto LABEL_152;
      }

        v6 *= 60;
      }
    }

      *(_BYTE *)(a4 + 16) = v18;
      return result;
    case 0x1DuLL:
      uint64_t result = (void *)memcmp(result, "UnsafeMutableRawBufferPointer", a2);
      if ((_DWORD)result) {
        goto LABEL_97;
      }
      uint64_t v8 = "w";
      goto LABEL_167;
    case 0x21uLL:
      if (*result != 0x656C65726F747541LL
        || result[1] != 0x736E55676E697361LL
        || result[2] != 0x626174754D656661LL
        || result[3] != 0x65746E696F50656CLL
        || *((_BYTE *)result + 32) != 114)
      {
        goto LABEL_97;
      }

      uint64_t v18 = 1;
      *(void *)a4 = "A";
      *(void *)(a4 + 8) = 1LL;
      goto LABEL_168;
    default:
      goto LABEL_97;
  }

              unint64_t v86 = 0LL;
              goto LABEL_169;
            }

      this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<(v64, v65);
LABEL_169:
      if ((v8 & 0x100) == 0) {
        goto LABEL_61;
      }
      uint64_t v18 = *(_DWORD *)(v4 + 12736);
      uint64_t v110 = *(unsigned int *)(v4 + 12740);
      uint64_t v20 = *(char **)(v4 + 12728);
      unint64_t v111 = *(void **)(v4 + 12744);
      uint64_t v112 = (char *)v111[1];
      if (&v20[v110] != v112)
      {
        unint64_t v113 = v111[2];
LABEL_180:
        else {
          uint64_t v115 = (2 * v110);
        }
        unint64_t v116 = v115 + v110;
        if (!v112 || (unint64_t)&v112[v116] > v113)
        {
          unint64_t v117 = 2LL * v111[4];
          if (v117 <= v116 + 1) {
            unint64_t v117 = v116 + 1;
          }
          v111[4] = v117;
          char v118 = v117 + 8;
          this = (uint64_t)malloc(v117 + 8);
          uint64_t v119 = this + v118;
          *(void *)this = v111[3];
          uint64_t v112 = (char *)(this + 8);
          v111[2] = v119;
          v111[3] = this;
        }

        v111[1] = &v112[v116];
        if ((_DWORD)v110)
        {
          this = (uint64_t)memcpy(v112, *(const void **)(v4 + 12728), v110);
          LODWORD(v110) = *(_DWORD *)(v4 + 12740);
          uint64_t v18 = *(_DWORD *)(v4 + 12736);
        }

        *(void *)(v4 + 12728) = v112;
        uint64_t v20 = v112;
        goto LABEL_191;
      }

      uint64_t v114 = (unint64_t)&v20[v110 + 1];
      unint64_t v113 = v111[2];
      if (v114 > v113) {
        goto LABEL_180;
      }
      v111[1] = v114;
      LODWORD(v115) = 1;
LABEL_191:
      *(_DWORD *)(v4 + 12740) = v110 + v115;
LABEL_192:
      uint64_t v31 = 0;
      uint64_t v3 = 0LL;
      __int128 v32 = 0;
      *(_DWORD *)(v4 + 12736) = v18 + 1;
      unint64_t v79 = 88;
LABEL_193:
      v20[v18] = v79;
LABEL_194:
      *(_DWORD *)a3 = v31;
      *(void *)(a3 + 8) = v3;
      *(_DWORD *)(a3 + 16) = v32;
      return this;
  }

LABEL_179:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  if (v23 != 2)
  {
LABEL_61:
    unint64_t v180 = v177;
    unint64_t v181 = v22;
    char v182 = v23;
    __int128 v183 = v176;
    char v184 = v25;
    ((void (*)(swift::SwiftError **, unint64_t *, uint64_t, uint64_t, swift *, uint64_t, uint64_t))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( a1,  &v180,  a3,  1LL,  a4,  v179,  v178);
    return;
  }

  uint64_t v100 = (uint64_t *)swift_getTypeName(v177, 1);
  if (v101 < 0) {
    goto LABEL_179;
  }
  uint64_t v102 = (uint8x16_t *)v100;
  int64_t v103 = v101;
  int64_t v104 = validateUTF8(_:)(v100, v101);
  uint64_t v106 = v179;
  if ((v107 & 1) != 0) {
    uint64_t v108 = repairUTF8(_:firstKnownBrokenRange:)(v102->i8, v103, v104, v105);
  }
  else {
    uint64_t v108 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v102, v103, v104 & 1);
  }
  uint64_t v169 = v109;
  uint64_t v170 = *(void (**)(uint64_t))(v50 + 24);
  v170(v108);
  swift_bridgeObjectRelease(v169);
  uint64_t v171 = swift_EnumCaseName(a1, (uint64_t *)a4);
  if (v171)
  {
    unint64_t v172 = specialized String.init(validatingUTF8:)(v171);
    if (v173)
    {
      unint64_t v174 = v172;
      uint64_t v110 = v173;
      uint64_t v175 = v178;
      ((void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v170)(46LL, 0xE100000000000000LL, v106, v178);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      ((void (*)(unint64_t, uint64_t, uint64_t, uint64_t))v170)(v174, v110, v106, v175);
LABEL_64:
      swift_bridgeObjectRelease(v110);
    }
  }

            *((_WORD *)v6 + 8) = 1;
            uint64_t v84 = v545;
            uint64_t v83 = (uint64_t (*)(const void *, uint64_t, void))v546;
            v6[1] = v546;
            *uint64_t v6 = v83(v84, 2LL, 0LL);
            v83(v84, 3LL, 0LL);
            goto LABEL_662;
          default:
            goto LABEL_183;
        }

      case 0x10:
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
            unint64_t v135 = 0;
            unint64_t v134 = "";
            uint64_t v14 = 1LL;
            goto LABEL_347;
          case 2:
            goto LABEL_38;
          case 3:
            uint64_t v14 = 0LL;
            unint64_t v135 = *((_DWORD *)v10 + 2);
            unint64_t v134 = *(const char **)v10;
            goto LABEL_347;
          case 5:
            uint64_t v14 = *((unsigned int *)v10 + 2);
            if (v14 <= 1)
            {
              unint64_t v135 = 0;
LABEL_346:
              unint64_t v134 = "";
LABEL_347:
              Swift::String v39 = operator new(0x28uLL);
              unint64_t v40 = v39;
              *Swift::String v39 = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (2)";
              char v136 = 0x10000002BDLL;
              goto LABEL_480;
            }

            uint64_t v10 = *(void (**)(uint64_t, int))v10;
LABEL_38:
            uint64_t v10 = (void (*)(uint64_t, int))*((void *)v10 + 1);
            uint64_t v20 = *((unsigned __int8 *)v10 + 18);
            if (v20 == 1) {
              goto LABEL_50;
            }
            if (v20 != 5)
            {
              if (v20 == 2)
              {
                unint64_t v152 = 0;
                char v153 = *((unsigned __int16 *)v10 + 8);
                uint64_t v90 = "";
                unint64_t v21 = 2LL;
              }

              else
              {
                char v153 = *((unsigned __int16 *)v10 + 8);
                if (v20 == 3)
                {
                  unint64_t v21 = 0LL;
                  unint64_t v152 = *((_DWORD *)v10 + 2);
                  uint64_t v90 = *(const char **)v10;
                }

                else
                {
                  unint64_t v152 = 0;
                  unint64_t v21 = 0LL;
LABEL_473:
                  uint64_t v90 = "";
                }
              }

              unint64_t v40 = operator new(0x28uLL);
              *(void *)unint64_t v40 = "TypeDecoder.h:%u: Node kind %u %.*s - expected 1 generic argument, saw %zu";
              v40[2] = 707;
              v40[3] = v153;
              void v40[4] = v152;
              *((void *)v40 + 3) = v90;
              *((void *)v40 + 4) = v21;
LABEL_537:
              *((_WORD *)v6 + 8) = 1;
              uint64_t v211 = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
              goto LABEL_769;
            }

            unint64_t v21 = *((unsigned int *)v10 + 2);
            if ((_DWORD)v21 != 1)
            {
              unint64_t v152 = 0;
              char v153 = *((unsigned __int16 *)v10 + 8);
              goto LABEL_473;
            }

            break;
          default:
            unint64_t v135 = 0;
            uint64_t v14 = 0LL;
            goto LABEL_346;
        }

        goto LABEL_49;
      case 0x14:
        swift::Demangle::__runtime::mangleNode((swift::Demangle::__runtime *)v10, a2);
        uint64_t v59 = v541;
        if ((_DWORD)v541)
        {
          uint64_t v60 = *((unsigned __int16 *)v10 + 8);
          if (*((_BYTE *)v10 + 18) == 3)
          {
            unint64_t v61 = *((_DWORD *)v10 + 2);
            unint64_t v62 = *(const char **)v10;
          }

          else
          {
            unint64_t v61 = 0;
            unint64_t v62 = "";
          }

          char v168 = v542;
          uint64_t v165 = operator new(0x28uLL);
          *(void *)uint64_t v165 = "TypeDecoder.h:%u: Node kind %u %.*s - failed to mangle node (%d:%u)";
          v165[2] = 717;
          v165[3] = v60;
          v165[4] = v61;
          *((void *)v165 + 3) = v62;
          v165[8] = v59;
          v165[9] = v168;
          *((_WORD *)v6 + 8) = 1;
          v6[1] = (unint64_t)swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,swift::Demangle::__runtime::ManglingError::Code,unsigned int>(char const*,int,unsigned int,int,char const*,swift::Demangle::__runtime::ManglingError::Code,unsigned int)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,swift::Demangle::__runtime::ManglingError::Code,unsigned int>(char const*,int,unsigned int,int,char const*,swift::Demangle::__runtime::ManglingError::Code,unsigned int)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
          uint64_t v169 = operator new(0x28uLL);
          uint64_t v170 = *((_OWORD *)v165 + 1);
          *uint64_t v169 = *(_OWORD *)v165;
          v169[1] = v170;
          *((void *)v169 + 4) = *((void *)v165 + 4);
          *uint64_t v6 = (unint64_t)v169;
        }

        else
        {
          v538 = *(_OWORD *)v10;
          __swift::__runtime::llvm::StringRef::str((const void **)&v538, (uint64_t)&v545);
          unint64_t v164 = SHIBYTE(v547[0]);
          uint64_t v165 = v545;
          if ((v544 & 0x80u) == 0) {
            unint64_t v166 = __p;
          }
          else {
            unint64_t v166 = (void **)__p[0];
          }
          if ((v544 & 0x80u) == 0) {
            uint64_t v167 = v544;
          }
          else {
            uint64_t v167 = (uint64_t)__p[1];
          }
          if ((v164 & 0x80000000) == 0)
          {
LABEL_430:
            return;
          }
        }

        operator delete(v165);
        goto LABEL_430;
      case 0x18:
        swift::Demangle::__runtime::getObjCClassOrProtocolName((unsigned __int16 ***)v10, (uint64_t)&v541);
        if (!(_BYTE)v542) {
          goto LABEL_115;
        }
        __swift::__runtime::llvm::StringRef::str((const void **)&v541, (uint64_t)&v545);
        if (SHIBYTE(v547[0]) < 0) {
          operator delete(v545);
        }
        return;
      case 0x23:
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
            unint64_t v135 = 0;
            unint64_t v134 = "";
            uint64_t v14 = 1LL;
            goto LABEL_344;
          case 2:
            goto LABEL_45;
          case 3:
            uint64_t v14 = 0LL;
            unint64_t v135 = *((_DWORD *)v10 + 2);
            unint64_t v134 = *(const char **)v10;
            goto LABEL_344;
          case 5:
            uint64_t v14 = *((unsigned int *)v10 + 2);
            unint64_t v135 = 0;
LABEL_343:
            unint64_t v134 = "";
LABEL_344:
            Swift::String v39 = operator new(0x28uLL);
            unint64_t v40 = v39;
            *Swift::String v39 = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (2)";
            char v136 = 0x23000004F4LL;
            break;
          default:
            unint64_t v135 = 0;
            uint64_t v14 = 0LL;
            goto LABEL_343;
        }

        goto LABEL_480;
      case 0x26:
        uint64_t v46 = *((unsigned __int8 *)v10 + 18);
        if ((v46 - 1) >= 2)
        {
          if (v46 == 5) {
            uint64_t v47 = *(const char **)v10;
          }
          else {
            uint64_t v47 = (const char *)v10;
          }
          uint64_t v10 = *(void (**)(uint64_t, int))v10;
        }

        else
        {
          uint64_t v47 = (const char *)v10;
        }

        unint64_t v86 = **(_DWORD **)v10;
        char v87 = **((_DWORD **)v47 + 1);
        unint64_t v85 = (_anonymous_namespace_::DecodedMetadataBuilder *)*a1;
        goto LABEL_316;
      case 0x2C:
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
            unint64_t v135 = 0;
            unint64_t v134 = "";
            uint64_t v14 = 1LL;
            goto LABEL_341;
          case 2:
            goto LABEL_45;
          case 3:
            uint64_t v14 = 0LL;
            unint64_t v135 = *((_DWORD *)v10 + 2);
            unint64_t v134 = *(const char **)v10;
            goto LABEL_341;
          case 5:
            uint64_t v14 = *((unsigned int *)v10 + 2);
            unint64_t v135 = 0;
LABEL_340:
            unint64_t v134 = "";
LABEL_341:
            Swift::String v39 = operator new(0x28uLL);
            unint64_t v40 = v39;
            *Swift::String v39 = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (2)";
            char v136 = 0x2C000004D7LL;
            break;
          default:
            unint64_t v135 = 0;
            uint64_t v14 = 0LL;
            goto LABEL_340;
        }

        goto LABEL_480;
      case 0x2D:
        uint64_t v14 = 0LL;
        unint64_t v48 = 0;
        uint64_t v49 = (uint64_t *)"";
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
            unint64_t v48 = 0;
            uint64_t v14 = 1LL;
            goto LABEL_507;
          case 2:
            uint64_t v208 = (const char *)v10;
            goto LABEL_705;
          case 3:
            uint64_t v14 = 0LL;
            unint64_t v48 = *((_DWORD *)v10 + 2);
            uint64_t v49 = *(uint64_t **)v10;
            goto LABEL_507;
          case 5:
            uint64_t v14 = *((unsigned int *)v10 + 2);
            if (v14 <= 1)
            {
              unint64_t v48 = 0;
LABEL_507:
              Swift::String v39 = operator new(0x28uLL);
              unint64_t v40 = v39;
              *Swift::String v39 = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (2)";
              uint64_t v196 = 0x2D000004DFLL;
              goto LABEL_535;
            }

            uint64_t v208 = *(const char **)v10;
LABEL_705:
            char v272 = (swift::Demangle::__runtime::NodeFactory *)(v9 + 1);
            uint64_t v273 = *((unsigned __int8 *)v10 + 18);
            if (v273 == 2) {
              goto LABEL_710;
            }
            if (v273 == 5 && *((_DWORD *)v10 + 2) >= 2u)
            {
              uint64_t v10 = *(void (**)(uint64_t, int))v10;
LABEL_710:
              unint64_t v274 = (_OWORD *)*((void *)v10 + 1);
            }

            else
            {
              unint64_t v274 = 0LL;
            }

            v299 = *((unsigned __int8 *)v274 + 18);
            v300 = (__int128 **)v274;
            v538 = **v300;
            if (v299 == 2) {
              goto LABEL_1053;
            }
            if (v299 != 5 || *((_DWORD *)v274 + 2) <= 1u)
            {
              __swift::__runtime::llvm::StringRef::str((const void **)&v538, (uint64_t)&v545);
              v301 = SHIBYTE(v547[0]);
              v302 = v545;
              *((_WORD *)v6 + 8) = 1;
              v6[1] = (unint64_t)_ZZN5swift15TypeLookupErrorC1IZNS_L19TypeLookupErrorImplIJEEES0_PKcDpT_EUlvE_EERKT_ENUlPvNS0_7CommandESB_E_8__invokeESB_SC_SB_;
              v303 = operator new(8uLL);
              char *v303 = "Unbound dependent member type cannot be demangled";
              *uint64_t v6 = (unint64_t)v303;
              if ((v301 & 0x80000000) == 0) {
                goto LABEL_819;
              }
              goto LABEL_817;
            }

            unint64_t v274 = *(_OWORD **)v274;
LABEL_1053:
            if (v433)
            {
              v434 = v433;
              __swift::__runtime::llvm::StringRef::str((const void **)&v538, (uint64_t)&v545);
              if (v547[0] >= 0) {
                v435 = &v545;
              }
              else {
                v435 = (void **)v545;
              }
              if (v547[0] >= 0) {
                v436 = HIBYTE(v547[0]);
              }
              else {
                v436 = v546;
              }
              if ((_WORD)v542) {
                v437 = 0LL;
              }
              else {
                v437 = v541;
              }
              if (SHIBYTE(v547[0]) < 0)
              {
                v326 = v545;
                goto LABEL_818;
              }
            }

            else
            {
              *uint64_t v6 = (unint64_t)"unknown error";
              v6[1] = (unint64_t)swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
              *((_WORD *)v6 + 8) = 1;
            }

            break;
          default:
            goto LABEL_507;
        }

        goto LABEL_819;
      case 0x39:
        uint64_t v14 = 0LL;
        unint64_t v48 = 0;
        uint64_t v49 = (uint64_t *)"";
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
            goto LABEL_545;
          case 2:
            unint64_t v48 = 0;
            uint64_t v14 = 2LL;
            break;
          case 3:
            uint64_t v14 = 0LL;
            unint64_t v48 = *((_DWORD *)v10 + 2);
            uint64_t v49 = *(uint64_t **)v10;
            break;
          case 5:
            uint64_t v14 = *((unsigned int *)v10 + 2);
            if ((_DWORD)v14 == 1) {
              goto LABEL_544;
            }
            unint64_t v48 = 0;
            break;
          default:
            break;
        }

        Swift::String v39 = operator new(0x28uLL);
        unint64_t v40 = v39;
        *Swift::String v39 = "TypeDecoder.h:%u: Node kind %u %.*s - expected 1 child, saw %zu";
        uint64_t v196 = 0x390000035CLL;
        goto LABEL_535;
      case 0x3D:
      case 0xDB:
      case 0xE9:
      case 0xEA:
LABEL_115:
        v545 = 0LL;
        *(void *)&v538 = 0LL;
        if ((_BYTE)v542)
        {
          *((_WORD *)v6 + 8) = 1;
          uint64_t v63 = (uint64_t (*)(uint64_t, uint64_t, void))*((void *)&v541 + 1);
          uint64_t v64 = v541;
          v6[1] = *((void *)&v541 + 1);
          *uint64_t v6 = v63(v64, 2LL, 0LL);
          v63(v64, 3LL, 0LL);
        }

        else
        {
        }

        return;
      case 0x45:
      case 0x91:
        uint64_t v26 = 0;
        uint64_t v35 = *((unsigned __int8 *)v10 + 18);
        uint64_t v27 = "";
        unint64_t v36 = (const char *)v10;
        switch(*((_BYTE *)v10 + 18))
        {
          case 1:
            __int128 v37 = 0LL;
            goto LABEL_78;
          case 2:
            goto LABEL_393;
          case 3:
            uint64_t v26 = *((_DWORD *)v10 + 2);
            uint64_t v27 = *(const char **)v10;
            goto LABEL_390;
          case 5:
            unint64_t v155 = *((_DWORD *)v10 + 2);
            if (v155 < 2)
            {
              if (!v155)
              {
                uint64_t v26 = 0;
LABEL_390:
                char v97 = operator new(0x28uLL);
                unint64_t v40 = v97;
                *char v97 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
                unint64_t v154 = 741;
LABEL_477:
                *((_DWORD *)v97 + 2) = v154;
                *((_DWORD *)v97 + 3) = v12;
LABEL_767:
                *((_DWORD *)v97 + 4) = v26;
                uint64_t v100 = "no children";
                v97[3] = v27;
                goto LABEL_768;
              }

              __int128 v37 = 0LL;
              goto LABEL_553;
            }

            unint64_t v36 = *(const char **)v10;
LABEL_393:
            uint64_t v156 = *(void *)v36;
            unint64_t v157 = *(unsigned __int16 *)(v156 + 16);
            uint64_t v158 = *(unsigned __int8 *)(v156 + 18);
            if (v157 == 146)
            {
              if (v158 == 3)
              {
                if (v35 == 2)
                {
                  __int128 v37 = 1LL;
LABEL_78:
                  uint64_t v38 = (const char *)v10;
                  goto LABEL_554;
                }

                if (v35 != 5 || *((_DWORD *)v10 + 2) < 2u)
                {
                  uint64_t v212 = 0LL;
                  goto LABEL_555;
                }

                __int128 v37 = 1LL;
LABEL_553:
                uint64_t v38 = *(const char **)v10;
LABEL_554:
                uint64_t v212 = *(void *)&v38[8 * v37];
LABEL_555:
                if ((unsigned __int16)v542 == 1)
                {
                  *((_WORD *)v6 + 8) = 1;
                  *(_OWORD *)uint64_t v6 = v541;
                  *((void *)&v541 + 1) = swift::TypeLookupError::nop;
                  *(void *)&v541 = 0LL;
                }

                else
                {
                  uint64_t v213 = *((unsigned __int16 *)v10 + 8);
                  if (v213 == 69)
                  {
                    if ((_WORD)v542) {
                      Swift::String::Index v266 = 0LL;
                    }
                    else {
                      Swift::String::Index v266 = (uint64_t *)v541;
                    }
                  }

                  else if (v213 == 145)
                  {
                    if ((_WORD)v542) {
                      unint64_t v214 = 0LL;
                    }
                    else {
                      unint64_t v214 = v541;
                    }
                  }

                  else
                  {
                    if (*((_BYTE *)v10 + 18) == 3)
                    {
                      Swift::Int v267 = *((_DWORD *)v10 + 2);
                      Swift::Int v268 = *(const char **)v10;
                    }

                    else
                    {
                      Swift::Int v267 = 0;
                      Swift::Int v268 = "";
                    }

                    v302 = operator new(0x28uLL);
                    *(void *)v302 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
                    v302[2] = 755;
                    v302[3] = v213;
                    v302[4] = v267;
                    *((void *)v302 + 3) = v268;
                    *((void *)v302 + 4) = "Metatype/ExistentialMetatype Node had a different kind when re-checked";
                    *((_WORD *)v6 + 8) = 1;
                    v6[1] = (unint64_t)swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,char const*>(char const*,int,unsigned int,int,char const*,char const*)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
                    v324 = operator new(0x28uLL);
                    v325 = *((_OWORD *)v302 + 1);
                    char *v324 = *(_OWORD *)v302;
                    v324[1] = v325;
                    *((void *)v324 + 4) = *((void *)v302 + 4);
                    *uint64_t v6 = (unint64_t)v324;
LABEL_817:
                    v326 = v302;
LABEL_818:
                    operator delete(v326);
                  }
                }

void _print_unlocked<A, B>(_:_:)(uint64_t a1, uint64_t a2, swift *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v54 = a4;
  uint64_t v9 = *((void *)a3 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v53 = (uint64_t *)((char *)&v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (uint64_t *)((char *)&v53 - v13);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (uint64_t *)((char *)&v53 - v16);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (uint64_t *)((char *)&v53 - v19);
  MEMORY[0x1895F8858](v18);
  unint64_t v22 = (uint64_t *)((char *)&v53 - v21);
  char v57 = (uint64_t *)v23;
  __n128 v24 = __swift_allocate_boxed_opaque_existential_0Tm(&v55);
  char v25 = *(void (**)(uint64_t *, uint64_t, swift *))(v9 + 16);
  v25(v24, a1, a3);
  uint64_t v26 = v57;
  uint64_t v27 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v55, (uint64_t)v57);
  unint64_t DynamicType = (void *)swift_getDynamicType(v27, v26, 1);
  LODWORD(v26) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v55);
  if ((_DWORD)v26)
  {
    v25(v22, a1, a3);
    uint64_t v29 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v55, v22, a3, v29, 7uLL);
    uint64_t v30 = (uint64_t)v57;
    uint64_t v31 = v58;
    __swift_project_boxed_opaque_existential_0Tm(&v55, (uint64_t)v57);
    uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v31 + 8))(v30, v31);
    uint64_t v34 = v33;
    (*(void (**)(uint64_t))(a5 + 24))(v32);
LABEL_3:
    swift_bridgeObjectRelease(v34);
LABEL_4:
    __swift_destroy_boxed_opaque_existential_1Tm(&v55);
    return;
  }

  uint64_t v35 = a2;
  uint64_t v36 = v54;
  v25(v20, a1, a3);
  if (swift_dynamicCast((char *)&v55, v20, a3, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v37 = v56;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 24))(v55, v56, v36, a5);
    swift_bridgeObjectRelease(v37);
  }

  else
  {
    v25(v17, a1, a3);
    uint64_t v38 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    int v39 = swift_dynamicCast((char *)&v59, v17, a3, v38, 6uLL);
    uint64_t v40 = a5;
    if (v39)
    {
      outlined init with take of MirrorPath(&v59, (uint64_t)&v55);
      uint64_t v41 = (uint64_t)v57;
      uint64_t v42 = v58;
      __swift_project_boxed_opaque_existential_0Tm(&v55, (uint64_t)v57);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v42 + 8))(v35, v36, a5, v41, v42);
      goto LABEL_4;
    }

    uint64_t v61 = 0LL;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v59,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v25(v14, a1, a3);
    unint64_t v43 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v59, v14, a3, v43, 6uLL)
      || (uint64_t v61 = 0LL,
          __int128 v59 = 0u,
          __int128 v60 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v59,  &demangling cache variable for type metadata for CustomStringConvertible?),  v44 = v53,  v25(v53, a1, a3),  uint64_t v45 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v59, v44, a3, v45, 6uLL)))
    {
      outlined init with take of MirrorPath(&v59, (uint64_t)&v55);
      uint64_t v46 = (uint64_t)v57;
      uint64_t v47 = v58;
      __swift_project_boxed_opaque_existential_0Tm(&v55, (uint64_t)v57);
      uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(v47 + 8))(v46, v47);
      uint64_t v34 = v49;
      (*(void (**)(uint64_t))(a5 + 24))(v48);
      goto LABEL_3;
    }

    uint64_t v61 = 0LL;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v59,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v60 + 1) = a3;
    uint64_t v50 = __swift_allocate_boxed_opaque_existential_0Tm(&v59);
    v25(v50, a1, a3);
    Mirror.init(reflecting:)((uint64_t *)&v59, (uint64_t)&v55);
    uint64_t v51 = v56;
    uint64_t v52 = v58;
    ((void (*)(uint64_t, uint64_t *, uint64_t, void, swift *, uint64_t, uint64_t))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( a1,  &v55,  v35,  0LL,  a3,  v36,  v40);
    swift_release(v52);
    swift_release(v51);
  }

void _dumpSuperclass_unlocked<A>(mirror:to:indent:maxDepth:maxItemCounter:visitedItems:)( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void (*v9)(uint64_t *__return_ptr, unint64_t *);
  unint64_t *v10;
  uint64_t v11;
  void (*v16)(uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t, uint64_t);
  swift *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  unint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  BOOL v48;
  uint64_t *v49;
  void (*v50)(uint64_t *__return_ptr, id, unint64_t);
  id v51;
  uint64_t v52;
  int isUniquelyReferenced_nonNull;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void (*v62)(id, unint64_t);
  id v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  Swift::String v67;
  void (*v68)(uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v71;
  BOOL v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t *v75;
  unint64_t *v76;
  unint64_t v77;
  void (*v78)(uint64_t *__return_ptr, unint64_t *);
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  __int128 v82;
  uint64_t v83;
  char v84;
  uint64_t v85[5];
  if (*a5 < 1) {
    return;
  }
  uint64_t v8 = *a1;
  unint64_t v75 = (unint64_t *)a1[1];
  uint64_t v9 = (void (*)(uint64_t *__return_ptr, unint64_t *))a1[3];
  uint64_t v10 = (unint64_t *)a1[4];
  --*a5;
  if (a3 < 0) {
    goto LABEL_42;
  }
  uint64_t v11 = a8;
  unint64_t v76 = v10;
  unint64_t v78 = v9;
  if (a3)
  {
    uint64_t v16 = *(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a8 + 24);
    uint64_t v17 = a3;
    do
    {
      v16(32LL, 0xE100000000000000LL, a7, v11);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      --v17;
    }

    while (v17);
  }

  uint64_t v18 = v75;
  uint64_t v19 = (*(uint64_t (**)(void))(*v75 + 320))();
  uint64_t v20 = 12162786LL;
  if (a4 > 0) {
    uint64_t v20 = 12556002LL;
  }
  uint64_t v74 = v19;
  uint64_t v21 = v19 == 0;
  unint64_t v22 = v19 ? v20 : 45LL;
  uint64_t v23 = v21 ? 0xE100000000000000LL : 0xA300000000000000LL;
  __n128 v24 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 24);
  v24(v22, v23, a7, v11);
  swift_bridgeObjectRelease(v23);
  v24(0x203A726570757320LL, 0xE800000000000000LL, a7, v11);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  uint64_t v80 = v8;
  char v25 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any.Type);
  _debugPrint_unlocked<A, B>(_:_:)((uint64_t)&v80, a2, v25, a7, v11);
  unint64_t v68 = (void (*)(uint64_t, unint64_t, uint64_t, uint64_t))v24;
  v24(10LL, 0xE100000000000000LL, a7, v11);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  uint64_t v73 = a4 - 1;
  uint64_t v29 = a3;
  if (a4 < 1) {
    return;
  }
  swift_retain(v75, v26, v27, v28);
  uint64_t v33 = swift_retain(v76, v30, v31, v32);
  v78(&v80, v33);
  swift_release((uint64_t)v76);
  swift_release((uint64_t)v75);
  uint64_t v37 = v80;
  if (v80)
  {
    uint64_t v38 = v81;
    uint64_t v40 = v82;
    int v39 = v83;
    v84 &= 1u;
    if (__OFADD__(a3, 2LL))
    {
      __break(1u);
      goto LABEL_44;
    }

    _dumpSuperclass_unlocked<A>(mirror:to:indent:maxDepth:maxItemCounter:visitedItems:)( &v80,  a2,  a3 + 2,  v73,  a5,  a6,  a7,  v11);
    outlined consume of Mirror?(v37, v38, v40, *((uint64_t *)&v40 + 1), v39);
    uint64_t v18 = v75;
    uint64_t v29 = a3;
  }

  uint64_t v41 = v74;
  if (v74 < 0) {
    goto LABEL_42;
  }
  unint64_t v43 = (void *)v18[2];
  uint64_t v42 = v18[3];
  swift_unknownObjectRetain(v43, v34, v35, v36);
  if (!v74)
  {
LABEL_30:
    swift_unknownObjectRelease(v43);
    return;
  }

  char v77 = v42;
  uint64_t v47 = 0LL;
  unint64_t v71 = v29 + 2;
  uint64_t v48 = __OFADD__(v29, 2LL);
  unint64_t v72 = v48;
  uint64_t v49 = a5;
  while (*v49 > 0)
  {
    uint64_t v50 = *(void (**)(uint64_t *__return_ptr, id, unint64_t))(*v75 + 256);
    uint64_t v51 = swift_unknownObjectRetain(v43, v44, v45, v46);
    v50(&v80, v51, v77);
    swift_unknownObjectRelease(v43);
    uint64_t v52 = v81;
    unint64_t v79 = v80;
    outlined init with take of Any(&v82, v85);
    isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull((unint64_t)v43);
    char v57 = *v75;
    if (isUniquelyReferenced_nonNull)
    {
      uint64_t v58 = a6;
      __int128 v59 = v11;
      __int128 v60 = a2;
      uint64_t v61 = a7;
      unint64_t v62 = *(void (**)(id, unint64_t))(v57 + 272);
      uint64_t v63 = swift_unknownObjectRetain(v43, v54, v55, v56);
      v62(v63, v77);
      a7 = v61;
      a2 = v60;
      uint64_t v11 = v59;
      a6 = v58;
      uint64_t v49 = a5;
      swift_unknownObjectRelease(v43);
    }

    else
    {
      uint64_t v64 = (*(uint64_t (**)(void *, unint64_t))(v57 + 264))(v43, v77);
      char v77 = v65;
      swift_unknownObjectRelease(v43);
      unint64_t v43 = (void *)v64;
    }

    if (v72)
    {
      __break(1u);
LABEL_42:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    ++v47;
    _dump_unlocked<A>(_:to:name:indent:maxDepth:maxItemCounter:visitedItems:)( v85,  a2,  v79,  v52,  v71,  v73,  v49,  a6,  a7,  v11);
    swift_bridgeObjectRelease(v52);
    __swift_destroy_boxed_opaque_existential_1Tm(v85);
    uint64_t v41 = v74;
    if (v74 == v47) {
      goto LABEL_30;
    }
  }

  unint64_t v66 = a3 + 4;
  if (__OFADD__(a3, 4LL))
  {
LABEL_44:
    __break(1u);
    return;
  }

  if (v66 < 0) {
    goto LABEL_42;
  }
  swift_unknownObjectRelease(v43);
  if (a3 != -4)
  {
    do
    {
      v68(32LL, 0xE100000000000000LL, a7, v11);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      --v66;
    }

    while (v66);
  }

  v68(40LL, 0xE100000000000000LL, a7, v11);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  uint64_t v80 = v41 - v47;
  _print_unlocked<A, B>(_:_:)((uint64_t)&v80, a2, (swift *)&type metadata for Int, a7, v11);
  if (v47)
  {
    v68(0x65726F6D20LL, 0xE500000000000000LL, a7, v11);
    swift_bridgeObjectRelease(0xE500000000000000LL);
  }

  if (v41 - 1 == v47)
  {
    v68(0xA29646C69686320LL, 0xE800000000000000LL, a7, v11);
    swift_bridgeObjectRelease(0xE800000000000000LL);
  }

  else
  {
    char v67 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" children)\n", 0xBuLL, 1);
    ((void (*)(uint64_t))v68)(v67._countAndFlagsBits);
    swift_bridgeObjectRelease((uint64_t)v67._object);
  }

id AnyCollection.startIndex.getter(uint64_t a1)
{
  uint64_t v1 = (void *)specialized AnyCollection.startIndex.getter(a1);
  return swift_unknownObjectRetain(v1, v2, v3, v4);
}

uint64_t AnyCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 256LL))();
}

uint64_t _debugPrint_unlocked<A, B>(_:_:)(uint64_t a1, uint64_t a2, swift *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v12 = (uint64_t *)((char *)v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (uint64_t *)((char *)v34 - v14);
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (uint64_t *)((char *)v34 - v16);
  uint64_t v19 = *(void (**)(char *, uint64_t))(v18 + 16);
  v19((char *)v34 - v16, a1);
  uint64_t v20 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v37, v17, a3, v20, 6uLL)
    || (uint64_t v39 = 0LL,
        __int128 v37 = 0u,
        __int128 v38 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v37,  &demangling cache variable for type metadata for CustomDebugStringConvertible?),  ((void (*)(uint64_t *, uint64_t, swift *))v19)(v15, a1, a3),  uint64_t v21 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible),  swift_dynamicCast((char *)&v37, v15, a3, v21, 6uLL)))
  {
    outlined init with take of MirrorPath(&v37, (uint64_t)v34);
    uint64_t v22 = v35;
    uint64_t v23 = v36;
    __swift_project_boxed_opaque_existential_0Tm(v34, v35);
    uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v23 + 8))(v22, v23);
    uint64_t v26 = v25;
    (*(void (**)(uint64_t))(a5 + 24))(v24);
    swift_bridgeObjectRelease(v26);
  }

  else
  {
    uint64_t v39 = 0LL;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v37,  &demangling cache variable for type metadata for CustomStringConvertible?);
    ((void (*)(uint64_t *, uint64_t, swift *))v19)(v12, a1, a3);
    uint64_t v28 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (!swift_dynamicCast((char *)&v37, v12, a3, v28, 6uLL))
    {
      uint64_t v39 = 0LL;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v37,  &demangling cache variable for type metadata for TextOutputStreamable?);
      *((void *)&v38 + 1) = a3;
      uint64_t v31 = __swift_allocate_boxed_opaque_existential_0Tm(&v37);
      ((void (*)(void *, uint64_t, swift *))v19)(v31, a1, a3);
      Mirror.init(reflecting:)((uint64_t *)&v37, (uint64_t)v34);
      uint64_t v32 = v34[1];
      uint64_t v33 = v36;
      ((void (*)(uint64_t, uint64_t *, uint64_t, uint64_t, swift *, uint64_t, uint64_t))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( a1,  v34,  a2,  1LL,  a3,  a4,  a5);
      swift_release(v32);
      return swift_release(v33);
    }

    outlined init with take of MirrorPath(&v37, (uint64_t)v34);
    uint64_t v29 = v35;
    uint64_t v30 = v36;
    __swift_project_boxed_opaque_existential_0Tm(v34, v35);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v30 + 8))(a2, a4, a5, v29, v30);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v34);
}

uint64_t EmptyCollection.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 56LL))( a2,  1LL,  1LL);
}

uint64_t protocol witness for IteratorProtocol.next() in conformance EmptyCollection<A>.Iterator@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return EmptyCollection.Iterator.next()(a1, a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance EmptyCollection<A>.Iterator@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return Sequence<>.makeIterator()(a1, a2);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance EmptyCollection<A>.Iterator( uint64_t a1, uint64_t a2)
{
  return Sequence._copyToContiguousArray()(a1, a2);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance EmptyCollection<A>.Iterator()
{
  return Sequence._copyContents(initializing:)();
}

uint64_t protocol witness for Sequence.makeIterator() in conformance EmptyCollection<A>( uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence._base.modify(*(void *)(a1 + 16), a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance EmptyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance EmptyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t EmptyCollection.startIndex.getter()
{
  return 0LL;
}

uint64_t EmptyCollection.endIndex.getter()
{
  return 0LL;
}

Swift::Int __swiftcall EmptyCollection.index(after:)(Swift::Int after)
{
}

Swift::Int __swiftcall EmptyCollection.index(before:)(Swift::Int before)
{
}

void EmptyCollection.subscript.getter()
{
}

void key path getter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A()
{
}

void key path setter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void EmptyCollection.subscript.setter()
{
}

void EmptyCollection.subscript.modify()
{
}

uint64_t EmptyCollection.subscript.getter(uint64_t result, uint64_t a2)
{
  if (result | a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x71uLL,  0);
  }
  return result;
}

uint64_t key path getter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A(uint64_t a1, uint64_t *a2)
{
  return EmptyCollection.subscript.getter(*a2, a2[1]);
}

uint64_t key path setter for EmptyCollection.subscript(_:) : <A>EmptyCollection<A>A( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  type metadata accessor for EmptyCollection(0LL, *(uint64_t *)((char *)a3 + a4 - 8), (uint64_t)a3, a4);
  return specialized EmptyCollection.subscript.setter(v4, v5);
}

uint64_t (*EmptyCollection.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3))()
{
  if (a2 | a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x71uLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t EmptyCollection.count.getter()
{
  return 0LL;
}

Swift::Int __swiftcall EmptyCollection.index(_:offsetBy:)(Swift::Int _, Swift::Int offsetBy)
{
  if (_ | offsetBy) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x83uLL,  0);
  }
  return 0LL;
}

Swift::Int_optional __swiftcall EmptyCollection.index(_:offsetBy:limitedBy:)( Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  if (_ | limitedBy) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x8BuLL,  0);
  }
  Swift::Bool v3 = offsetBy != 0;
  Swift::Int v4 = 0LL;
  result.value = v4;
  result.is_nil = v3;
  return result;
}

Swift::Int __swiftcall EmptyCollection.distance(from:to:)(Swift::Int from, Swift::Int to)
{
  if (from) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "From must be startIndex (or endIndex)",  37LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x93uLL,  0);
  }
  if (to) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "To must be endIndex (or startIndex)",  35LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x94uLL,  0);
  }
  return 0LL;
}

uint64_t EmptyCollection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "out of bounds",  13LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x9AuLL,  0);
  }
  uint64_t v6 = type metadata accessor for EmptyCollection(0LL, a4, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v6, v7);
  uint64_t result = RandomAccessCollection<>.indices.getter( v6,  WitnessTable,  (uint64_t)&protocol witness table for Int,  (char *)v10);
  if (v10[0] != a2 || v10[1] != a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid bounds for an empty collection",  38LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x9BuLL,  0);
  }
  return result;
}

uint64_t static Range.== infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4)
{
  return static ClosedRange.== infix(_:_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for Range);
}

uint64_t static ClosedRange.== infix(_:_:)( char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, uint64_t, uint64_t))
{
  uint64_t v9 = a5(0LL, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v22 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v22 - v14;
  uint64_t v16 = *(void *)(a4 + 8);
  uint64_t v23 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v16 + 8);
  char v17 = v23(a1, a2, a3, v16);
  uint64_t v18 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
  v18(v15, a1, v9);
  v18(v13, a2, v9);
  if ((v17 & 1) != 0) {
    char v19 = v23(&v15[*(int *)(v9 + 36)], &v13[*(int *)(v9 + 36)], a3, v16);
  }
  else {
    char v19 = 0;
  }
  uint64_t v20 = *(void (**)(char *, uint64_t))(v10 + 8);
  v20(v13, v9);
  v20(v15, v9);
  return v19 & 1;
}

uint64_t EmptyCollection._failEarlyRangeCheck(_:bounds:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = type metadata accessor for EmptyCollection(0LL, a5, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v9, v10);
  RandomAccessCollection<>.indices.getter(v9, WitnessTable, (uint64_t)&protocol witness table for Int, (char *)&v13);
  if (v13 != a1 || v14 != a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid range for an empty collection",  37LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0xA2uLL,  0);
  }
  uint64_t result = RandomAccessCollection<>.indices.getter( v9,  WitnessTable,  (uint64_t)&protocol witness table for Int,  (char *)&v13);
  if (v13 != a3 || v14 != a4) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid bounds for an empty collection",  38LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0xA3uLL,  0);
  }
  return result;
}

void protocol witness for MutableCollection.subscript.setter in conformance EmptyCollection<A>()
{
}

void protocol witness for MutableCollection.subscript.modify in conformance EmptyCollection<A>()
{
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance EmptyCollection<A>( uint64_t a1, uint64_t *a2)
{
  return specialized EmptyCollection.subscript.setter(*a2, a2[1]);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance EmptyCollection<A>( uint64_t a1, _OWORD *a2))()
{
  if (*a2 != 0LL) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x71uLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

void *protocol witness for MutableCollection.partition(by:) in conformance EmptyCollection<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void protocol witness for BidirectionalCollection.index(before:) in conformance EmptyCollection<A>()
{
}

void protocol witness for Collection.subscript.read in conformance EmptyCollection<A>(void **a1)
{
  *a1 = malloc(0x28uLL);
  protocol witness for MutableCollection.subscript.modify in conformance EmptyCollection<A>();
}

uint64_t protocol witness for Collection.subscript.getter in conformance EmptyCollection<A>(uint64_t *a1)
{
  return EmptyCollection.subscript.getter(*a1, a1[1]);
}

uint64_t protocol witness for Collection.indices.getter in conformance EmptyCollection<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance EmptyCollection<A>@<X0>( void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*result | a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x83uLL,  0);
  }
  *a3 = 0LL;
  return result;
}

void *protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance EmptyCollection<A>@<X0>( void *result@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  if (*result | *a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x8BuLL,  0);
  }
  *(void *)a4 = 0LL;
  *(_BYTE *)(a4 + 8) = a2 != 0;
  return result;
}

uint64_t protocol witness for RandomAccessCollection.distance(from:to:) in conformance EmptyCollection<A>( void *a1, void *a2)
{
  if (*a1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "From must be startIndex (or endIndex)",  37LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x93uLL,  0);
  }
  if (*a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "To must be endIndex (or startIndex)",  35LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x94uLL,  0);
  }
  return 0LL;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance EmptyCollection<A>( uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return EmptyCollection._failEarlyRangeCheck(_:bounds:)(*a1, *a2, a2[1], *(void *)(a3 + 16));
}

{
  return EmptyCollection._failEarlyRangeCheck(_:bounds:)(*a1, a1[1], *a2, a2[1], *(void *)(a3 + 16));
}

void protocol witness for Collection.index(after:) in conformance EmptyCollection<A>()
{
}

uint64_t static EmptyCollection.== infix(_:_:)()
{
  return 1LL;
}

uint64_t _swift_stdlib_Equatable_isEqual_indirect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v16 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v16 - v11;
  uint64_t v13 = *(void (**)(char *))(v7 + 16);
  v13((char *)&v16 - v11);
  ((void (*)(char *, uint64_t, uint64_t))v13)(v10, a2, a3);
  LOBYTE(a4) = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a4 + 8))(v12, v10, a3, a4);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v7 + 8);
  v14(v10, a3);
  v14(v12, a3);
  return a4 & 1;
}

BOOL static ObjectIdentifier.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL !== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = (a1 | a2) == 0;
  BOOL v3 = a1 == a2;
  if (!a2) {
    BOOL v3 = a1 == 0;
  }
  if (a1) {
    BOOL v2 = v3;
  }
  return !v2;
}

uint64_t protocol self-conformance witness for Error._domain.getter()
{
  return (*(uint64_t (**)(unint64_t))(v2[2] + 8))(v2[1]);
}

uint64_t protocol self-conformance witness for Error._code.getter()
{
  return (*(uint64_t (**)(unint64_t))(v2[2] + 16))(v2[1]);
}

uint64_t protocol self-conformance witness for Error._userInfo.getter()
{
  return (*(uint64_t (**)(unint64_t))(v2[2] + 24))(v2[1]);
}

uint64_t protocol self-conformance witness for Error._getEmbeddedNSError()()
{
  return (*(uint64_t (**)(unint64_t))(v2[2] + 32))(v2[1]);
}

unint64_t _getErrorDomainNSString<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  unint64_t v10 = v9;
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  unint64_t v13 = String._bridgeToObjectiveCImpl()(v8, v10, v11, v12);
  swift_bridgeObjectRelease(v10);
  return v13;
}

unint64_t String._bridgeToObjectiveCImpl()(uint64_t a1, unint64_t a2, void *a3, char *a4)
{
  if (one-time initialization token for _bridgeInitializedSuccessfully != -1) {
    swift_once( &one-time initialization token for _bridgeInitializedSuccessfully,  (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully,  a3);
  }
  if (!_bridgeInitializedSuccessfully) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0x82uLL,  0);
  }
  _orphanedFoundationSubclassesReparented = 1;
  if ((a2 & 0x2000000000000000LL) != 0)
  {
    if ((a2 & 0x4000000000000000LL) == 0
      || (uint64_t v15 = a1,
          uint64_t v16 = a2 & 0xFFFFFFFFFFFFFFLL,
          (uint64_t v6 = objc_msgSend( (id)type metadata accessor for __StringStorage(),  sel_newTaggedNSStringWithASCIIBytes__length__,  &v15,  HIBYTE(a2) & 0xF)) == 0))
    {
      uint64_t v15 = a1;
      uint64_t v16 = a2;
      swift_bridgeObjectRetain(a2, a2, (uint64_t)a3, a4);
      _StringGuts.grow(_:)(16LL);
      uint64_t v10 = v16;
      uint64_t v6 = (void *)String._bridgeToObjectiveCImpl()(v15, v16);
      swift_bridgeObjectRelease(v10);
    }
  }

  else if ((a2 & 0x8000000000000000LL) != 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      id v11 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      id v11 = _StringObject.sharedUTF8.getter(a1, a2);
      if (!v11) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x2BDuLL,  0);
      }
    }

    if (a1 >= 0) {
      unint64_t v12 = a1 & 0xFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = a1 & 0xFFFFFFFFFFFFLL | 0xC000000000000000LL;
    }
    uint64_t v13 = type metadata accessor for __SharedStringStorage();
    uint64_t v6 = swift_allocObject(v13, 0x31uLL, 7uLL);
    v6[2] = 0LL;
    v6[3] = v11;
    *((_BYTE *)v6 + 48) = 1;
    v6[4] = v12;
    void v6[5] = 0LL;
  }

  else
  {
    uint64_t v6 = (void *)(a2 & 0xFFFFFFFFFFFFFFFLL);
    swift_unknownObjectRetain((id)(a2 & 0xFFFFFFFFFFFFFFFLL), a2, (uint64_t)a3, a4);
    if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
    {
      swift_unknownObjectRetain((id)(a2 & 0xFFFFFFFFFFFFFF8LL | 0xC000000000000007LL), v7, v8, v9);
      swift_unknownObjectRelease((id)(a2 & 0xFFFFFFFFFFFFFFFLL));
      return a2 & 0xFFFFFFFFFFFFFF8LL | 0xC000000000000007LL;
    }
  }

  return (unint64_t)v6;
}

uint64_t _getErrorUserInfoNSDictionary<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  return v8;
}

uint64_t _getErrorEmbeddedNSErrorIndirect<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  return v8;
}

uint64_t _getErrorEmbeddedNSError<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
}

void swift_errorInMain(uint64_t a1)
{
  unint64_t v2 = 0xD00000000000001BLL;
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(29LL);
  uint64_t v5 = v4;
  unint64_t v28 = v3;
  unint64_t v29 = v4;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 || (v3 & ~v4 & 0x2000000000000000LL) != 0)
  {
    if ((v4 & 0x2000000000000000LL) == 0
      || ((unint64_t)"Swift/StringBridge.swift" & 0x2000000000000000LL) == 0
      || (unint64_t v8 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD00000000000001BLL, 0x80000001818B6590LL),
          (v10 & 1) != 0))
    {
      else {
        unint64_t v11 = 27LL;
      }
      _StringGuts.append(_:)(0xD00000000000001BLL, 0x80000001818B6590LL, 0LL, v11);
      unint64_t v2 = v28;
      unint64_t v7 = v29;
LABEL_15:
      unint64_t v25 = 0LL;
      unint64_t v26 = 0xE000000000000000LL;
      uint64_t v27 = a1;
      unint64_t v12 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
      _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)&v27,  (uint64_t)&v25,  v12,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
      uint64_t v13 = v25;
      unint64_t v14 = v26;
      uint64_t v15 = HIBYTE(v7) & 0xF;
      if ((v7 & 0x2000000000000000LL) == 0) {
        uint64_t v15 = v2 & 0xFFFFFFFFFFFFLL;
      }
      if (!v15 && (v2 & ~v7 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v7);
        unint64_t v28 = v13;
        unint64_t v29 = v14;
        goto LABEL_29;
      }

      if ((v7 & 0x2000000000000000LL) != 0)
      {
        if ((v26 & 0x2000000000000000LL) != 0)
        {
          unint64_t v17 = specialized _SmallString.init(_:appending:)(v2, v7, v25, v26);
          if ((v19 & 1) == 0)
          {
            unint64_t v20 = v17;
            unint64_t v21 = v18;
            swift_bridgeObjectRelease(v7);
            swift_bridgeObjectRelease(v14);
            unint64_t v28 = v20;
            unint64_t v29 = v21;
            unint64_t v14 = v21;
            uint64_t v13 = v20;
            goto LABEL_29;
          }

          goto LABEL_27;
        }
      }

      else if ((v26 & 0x2000000000000000LL) != 0)
      {
LABEL_27:
        uint64_t v16 = HIBYTE(v14) & 0xF;
        goto LABEL_28;
      }

      uint64_t v16 = v25 & 0xFFFFFFFFFFFFLL;
LABEL_28:
      _StringGuts.append(_:)(v13, v14, 0LL, v16);
      swift_bridgeObjectRelease(v14);
      uint64_t v13 = v28;
      unint64_t v14 = v29;
LABEL_29:
      uint64_t v22 = v13 & 0xFFFFFFFFFFFFLL;
      if ((v14 & 0x2000000000000000LL) != 0) {
        uint64_t v22 = HIBYTE(v14) & 0xF;
      }
      if (v22 || (v13 & ~v14 & 0x2000000000000000LL) != 0)
      {
        if ((v14 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v14);
          unint64_t v24 = 0xA000000000000000LL;
          if (!(v14 & 0x80808080808080LL | v13 & 0x8080808080808080LL)) {
            unint64_t v24 = 0xE000000000000000LL;
          }
          unint64_t v23 = v24 & 0xFF00000000000000LL | ((HIBYTE(v14) & 0xF) << 56) | v14 & 0xFFFFFFFFFFFFFFLL;
        }

        else
        {
          _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
          uint64_t v13 = v28;
          unint64_t v23 = v29;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v14);
        uint64_t v13 = 0LL;
        unint64_t v23 = 0xE000000000000000LL;
      }

      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)v13,  v23,  "Swift/ErrorType.swift",  21LL,  2,  0xFDuLL,  0);
    }

    unint64_t v2 = v8;
    unint64_t v7 = v9;
    swift_bridgeObjectRelease(v5);
  }

  else
  {
    swift_bridgeObjectRelease(v4);
    unint64_t v7 = 0x80000001818B6590LL;
  }

  unint64_t v28 = v2;
  unint64_t v29 = v7;
  goto LABEL_15;
}

uint64_t Error<>._code.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a1,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v10 = (char *)&v16 - v9;
  uint64_t v11 = *(void *)(a4 + 8);
  char v12 = (*(uint64_t (**)(void))(v11 + 64))();
  (*(void (**)(uint64_t, uint64_t))(a3 + 24))(a1, a3);
  if ((v12 & 1) != 0) {
    uint64_t v13 = specialized numericCast<A, B>(_:)((uint64_t)v10, AssociatedTypeWitness, v11);
  }
  else {
    uint64_t v13 = specialized numericCast<A, B>(_:)((uint64_t)v10, AssociatedTypeWitness, v11);
  }
  uint64_t v14 = v13;
  (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
  return v14;
}

void _abstract(file:line:)(const char *a1, uint64_t a2, char a3, unint64_t a4)
{
}

char *AnyIterator.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for _IteratorBox(0LL, a3, a4, a4);
  unint64_t v7 = (char *)swift_allocObject(v6, *(unsigned int *)(v6 + 48), *(unsigned __int16 *)(v6 + 52));
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 32LL))( &v7[*(void *)(*(void *)v7 + 120LL)],  a1,  a3);
  return v7;
}

char *_IteratorBox.__allocating_init(_:)(uint64_t a1)
{
  unint64_t v3 = (char *)swift_allocObject(v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  (*(void (**)(char *, uint64_t))(*(void *)(*(void *)(v1 + 104) - 8LL) + 32LL))( &v3[*(void *)(*(void *)v3 + 120LL)],  a1);
  return v3;
}

void *AnyIterator.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for _ClosureBasedIterator(255LL, a3, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ClosureBasedIterator<A>, v6, v7);
  uint64_t v10 = type metadata accessor for _IteratorBox(0LL, v6, WitnessTable, v9);
  uint64_t result = swift_allocObject(v10, 0x20uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  return result;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance AnyIterator<A>()
{
  return AnyIterator.next()(*v0);
}

uint64_t _ClosureBasedIterator._body.getter(uint64_t a1, unint64_t *a2, uint64_t a3, char *a4)
{
  return a1;
}

uint64_t _ClosureBasedIterator.next()(uint64_t (*a1)(void))
{
  return a1();
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _ClosureBasedIterator<A>()
{
  return _ClosureBasedIterator.next()(*v0);
}

void *_AnyIteratorBoxBase.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t _AnyIteratorBoxBase.init()()
{
  return v0;
}

uint64_t _AnyIteratorBoxBase.deinit()
{
  return v0;
}

void _AnyIteratorBoxBase.next()()
{
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _AnyIteratorBoxBase<A>()
{
  return (*(uint64_t (**)(void))(**(void **)v0 + 96LL))();
}

uint64_t _IteratorBox.init(_:)(uint64_t a1)
{
  return v1;
}

uint64_t _IteratorBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 104LL) - 8LL) + 8LL))(v0 + *(void *)(*(void *)v0 + 120LL));
}

uint64_t _IteratorBox.deinit()
{
  return v0;
}

void _IteratorBox.__deallocating_deinit()
{
}

uint64_t _IteratorBox.next()()
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)v0 + 112LL) + 16LL))(*(void *)(*(void *)v0 + 104LL));
}

uint64_t _IteratorBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 104LL) - 8LL) + 16LL))( a1,  v1 + *(void *)(*(void *)v1 + 120LL));
}

uint64_t _IteratorBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 104LL) - 8LL) + 40LL))( v1 + *(void *)(*(void *)v1 + 120LL),  a1);
}

uint64_t (*_IteratorBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _IteratorBox.__allocating_init()()
{
}

void _IteratorBox.init()()
{
}

void *_AnySequenceBox.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t _AnySequenceBox.init()()
{
  return v0;
}

void _AnySequenceBox._makeIterator()()
{
}

void _AnySequenceBox._underestimatedCount.getter()
{
}

void _AnySequenceBox._map<A>(_:)()
{
}

void _AnySequenceBox._filter(_:)()
{
}

void _AnySequenceBox._forEach(_:)()
{
}

void _AnySequenceBox.__customContainsEquatableElement(_:)()
{
}

void _AnySequenceBox.__copyToContiguousArray()()
{
}

void _AnySequenceBox.__copyContents(initializing:)()
{
}

uint64_t _AnySequenceBox.deinit()
{
  return v0;
}

void _AnySequenceBox.__deallocating_deinit()
{
}

void _AnySequenceBox._drop(while:)()
{
}

void _AnySequenceBox._dropFirst(_:)()
{
}

void _AnySequenceBox._dropLast(_:)()
{
}

void _AnySequenceBox._prefix(_:)()
{
}

void _AnySequenceBox._prefix(while:)()
{
}

void _AnySequenceBox._suffix(_:)()
{
}

void _AnyCollectionBox.__ivar_destroyer()
{
}

void _AnyCollectionBox.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (void *)v4[2];
  swift_retain(v4, a2, a3, a4);
  swift_unknownObjectRelease(v5);
  uint64_t v6 = (void *)v4[4];
  swift_release((uint64_t)v4);
  swift_unknownObjectRelease(v6);
  swift_deallocClassInstance((uint64_t)v4);
}

void _AnyCollectionBox._drop(while:)()
{
}

void _AnyCollectionBox._dropFirst(_:)()
{
}

void _AnyCollectionBox._dropLast(_:)()
{
}

void _AnyCollectionBox._prefix(_:)()
{
}

void _AnyCollectionBox._prefix(while:)()
{
}

void _AnyCollectionBox._suffix(_:)()
{
}

void _AnyCollectionBox.subscript.getter()
{
}

{
  _abstract(file:line:)("Swift/ExistentialCollection.swift", 33LL, 2, 0x192uLL);
}

void _AnyCollectionBox._index(after:)()
{
}

void _AnyCollectionBox._formIndex(after:)()
{
}

void _AnyCollectionBox._index(_:offsetBy:)()
{
}

void _AnyCollectionBox._index(_:offsetBy:limitedBy:)()
{
}

void _AnyCollectionBox._formIndex(_:offsetBy:)()
{
}

void _AnyCollectionBox._formIndex(_:offsetBy:limitedBy:)()
{
}

void _AnyCollectionBox._distance(from:to:)()
{
}

void _AnyCollectionBox._count.getter()
{
}

void *_AnyCollectionBox.__allocating_init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_allocObject(v4, 0x30uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

void *_AnyCollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[2] = a1;
  v4[3] = a2;
  v4[4] = a3;
  v4[5] = a4;
  return v4;
}

id _AnyCollectionBox._startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_unknownObjectRetain(*(id *)(v4 + 16), a2, a3, a4);
}

id _AnyCollectionBox._endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_unknownObjectRetain(*(id *)(v4 + 32), a2, a3, a4);
}

void _AnyCollectionBox.__allocating_init()()
{
}

void _AnyCollectionBox.init()()
{
}

void _AnyBidirectionalCollectionBox._drop(while:)()
{
}

void _AnyBidirectionalCollectionBox._dropFirst(_:)()
{
}

void _AnyBidirectionalCollectionBox._dropLast(_:)()
{
}

void _AnyBidirectionalCollectionBox._prefix(_:)()
{
}

void _AnyBidirectionalCollectionBox._prefix(while:)()
{
}

void _AnyBidirectionalCollectionBox._suffix(_:)()
{
}

void _AnyBidirectionalCollectionBox.subscript.getter()
{
}

void _AnyBidirectionalCollectionBox._index(before:)()
{
}

void _AnyBidirectionalCollectionBox._formIndex(before:)()
{
}

void *_AnyBidirectionalCollectionBox.__allocating_init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_allocObject(v4, 0x30uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

void *_AnyBidirectionalCollectionBox.init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[2] = a1;
  v4[3] = a2;
  v4[4] = a3;
  v4[5] = a4;
  return v4;
}

uint64_t _AnyCollectionBox.deinit()
{
  return v0;
}

void _AnyBidirectionalCollectionBox.__deallocating_deinit()
{
}

void _AnyRandomAccessCollectionBox._drop(while:)()
{
}

void _AnyRandomAccessCollectionBox._dropFirst(_:)()
{
}

void _AnyRandomAccessCollectionBox._dropLast(_:)()
{
}

void _AnyRandomAccessCollectionBox._prefix(_:)()
{
}

void _AnyRandomAccessCollectionBox._prefix(while:)()
{
}

void _AnyRandomAccessCollectionBox._suffix(_:)()
{
}

void _AnyRandomAccessCollectionBox.subscript.getter()
{
}

void *_AnyRandomAccessCollectionBox.__allocating_init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_allocObject(v4, 0x30uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

void *_AnyRandomAccessCollectionBox.init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[2] = a1;
  v4[3] = a2;
  v4[4] = a3;
  v4[5] = a4;
  return v4;
}

char *_SequenceBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 208);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void *)(v2 + 216);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 224), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject(v14, *(unsigned int *)(v14 + 48), *(unsigned __int16 *)(v14 + 52));
  (*(void (**)(char *, char *, unint64_t))(v9 + 32))( &v15[*(void *)(*(void *)v15 + 120LL)],  v11,  AssociatedTypeWitness);
  return v15;
}

uint64_t _SequenceBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 208);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 224), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 216) + 40LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_SequenceBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 208);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = &v14[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v9 + 16))(v11, (uint64_t)v3 + *(void *)(v7 + 224), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 216);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  char v12 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSTRzsAE_pRsd_0_r_0_lIetMgnozo_Tpq5Tm( (void (*)(char *, uint64_t *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error),  (uint64_t)v14,  v8,  a3,  v17);
  (*(void (**)(_BYTE *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSS17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( uint64_t a1, unint64_t a2)
{
  v4._rawBits = specialized Collection.count.getter(a1, a2)._rawBits;
  unint64_t v25 = &_swiftEmptyArrayStorage;
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v4._rawBits & ~((uint64_t)v4._rawBits >> 63),  0);
  uint64_t v5 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v21 = a1;
  uint64_t v22 = v5;
  if ((v4._rawBits & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v6 = v25;
  for (uint64_t i = 0LL; v4._rawBits; --v4._rawBits)
  {
    if (i >= v22) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x2B9uLL,  0);
    }
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v13 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(i << 16));
      Swift::UInt32 value = v13._0._value;
      Swift::Int scalarLength = v13.scalarLength;
    }

    else
    {
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        uint64_t v23 = v21;
        uint64_t v24 = a2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt32 value = *((unsigned __int8 *)&v23 + i);
        if (*((char *)&v23 + i) < 0) {
          __asm { BR              X9 }
        }
      }

      else
      {
        uint64_t v8 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v21 & 0x1000000000000000LL) == 0) {
          uint64_t v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v21, a2);
        }
        Swift::UInt32 value = v8[i];
        if ((char)v8[i] < 0) {
          __asm { BR              X9 }
        }
      }

      Swift::Int scalarLength = 1LL;
    }

    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v6))
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v6[2]->isa + 1,  1);
      uint64_t v6 = v25;
    }

    char v12 = v6[2];
    unint64_t v11 = (unint64_t)v6[3];
    if ((unint64_t)v12 >= v11 >> 1)
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v11 > 1,  (int64_t)&v12->isa + 1,  1);
      uint64_t v6 = v25;
    }

    i += scalarLength;
    v6[2] = (__objc2_class *)((char *)&v12->isa + 1);
    *((_DWORD *)v6 + (void)v12 + 8) = value;
  }

  for (; i < v22; *((_DWORD *)v6 + (void)v18 + 8) = v15)
  {
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v19 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(i << 16));
      Swift::UInt32 v15 = v19._0._value;
      Swift::Int v16 = v19.scalarLength;
    }

    else
    {
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        uint64_t v23 = v21;
        uint64_t v24 = a2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt32 v15 = *((unsigned __int8 *)&v23 + i);
        if (*((char *)&v23 + i) < 0) {
          __asm { BR              X9 }
        }
      }

      else
      {
        uint64_t v14 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v21 & 0x1000000000000000LL) == 0) {
          uint64_t v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v21, a2);
        }
        Swift::UInt32 v15 = v14[i];
        if ((char)v14[i] < 0) {
          __asm { BR              X9 }
        }
      }

      Swift::Int v16 = 1LL;
    }

    uint64_t v6 = v25;
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v25))
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v6[2]->isa + 1,  1);
      uint64_t v6 = v25;
    }

    uint64_t v18 = v6[2];
    unint64_t v17 = (unint64_t)v6[3];
    if ((unint64_t)v18 >= v17 >> 1)
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v17 > 1,  (int64_t)&v18->isa + 1,  1);
      uint64_t v6 = v25;
    }

    i += v16;
    v6[2] = (__objc2_class *)((char *)&v18->isa + 1);
  }

  return v6;
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a1._rawBits;
  v7._Swift::UInt64 rawBits = specialized Collection.count.getter(a1, a2, a3, a4)._rawBits;
  uint64_t v102 = &_swiftEmptyArrayStorage;
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v7._rawBits & ~((uint64_t)v7._rawBits >> 63),  0);
  if ((v7._rawBits & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v11 = v102;
  swift_bridgeObjectRetain(a4, v8, v9, v10);
  Swift::UInt64 v12 = a2._rawBits >> 14;
  if (v7._rawBits)
  {
    uint64_t v13 = (a3 >> 59) & 1;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v13) = 1;
    }
    uint64_t v14 = 4LL << v13;
    Swift::UInt64 v15 = rawBits >> 14;
    if ((a4 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v16 = HIBYTE(a4) & 0xF;
    }
    else {
      Swift::UInt64 v16 = a3 & 0xFFFFFFFFFFFFLL;
    }
    v17._Swift::UInt64 rawBits = rawBits;
    Swift::UInt64 v97 = rawBits;
    Swift::UInt64 v98 = rawBits >> 14;
    while (1)
    {
      Swift::UInt64 v18 = v17._rawBits >> 14;
      if (v17._rawBits >> 14 == v12) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x2B9uLL,  0);
      }
      uint64_t v19 = v17._rawBits & 0xC;
      BOOL v20 = (v17._rawBits & 1) == 0 || v19 == v14;
      int v21 = v20;
      if (v20)
      {
        Swift::UInt64 v22 = v17._rawBits;
        if (v19 == v14)
        {
          Swift::UInt64 v34 = v12;
          uint64_t v35 = v14;
          Swift::UInt64 v36 = v16;
          Swift::UInt64 v22 = _StringGuts._slowEnsureMatchingEncoding(_:)(v17)._rawBits;
          Swift::UInt64 v16 = v36;
          uint64_t v14 = v35;
          Swift::UInt64 v12 = v34;
          Swift::UInt64 v18 = v22 >> 14;
          if (v22 >> 14 < v98)
          {
LABEL_117:
            unint64_t v93 = 43LL;
            goto LABEL_119;
          }
        }

        else if (v18 < v15)
        {
          goto LABEL_117;
        }

        if (v18 >= v12) {
          goto LABEL_117;
        }
        if ((v22 & 1) == 0)
        {
          Swift::UInt64 v23 = v12;
          uint64_t v24 = v14;
          Swift::UInt64 v25 = v16;
          v26._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v22)._rawBits;
          Swift::UInt64 v16 = v25;
          uint64_t v14 = v24;
          Swift::UInt64 v12 = v23;
          Swift::UInt64 v22 = v26._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
        }
      }

      else if (v18 < v15 || (Swift::UInt64 v22 = v17._rawBits, v18 >= v12))
      {
LABEL_118:
        unint64_t v93 = 143LL;
LABEL_119:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v93,  0);
      }

      if ((a4 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v37 = v12;
        uint64_t v38 = v14;
        Swift::UInt64 v39 = v16;
        Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v22 & 0xFFFFFFFFFFFF0000LL))._0._value;
        Swift::UInt64 v16 = v39;
        uint64_t v14 = v38;
        Swift::UInt64 v12 = v37;
        Swift::UInt32 v29 = value;
        if (v21) {
          goto LABEL_34;
        }
      }

      else
      {
        Swift::UInt64 v27 = v22 >> 16;
        if ((a4 & 0x2000000000000000LL) != 0)
        {
          unint64_t v100 = a3;
          uint64_t v101 = a4 & 0xFFFFFFFFFFFFFFLL;
          Swift::UInt32 v29 = *((unsigned __int8 *)&v100 + v27);
          if (*((char *)&v100 + v27) < 0) {
            __asm { BR              X9 }
          }
        }

        else
        {
          unint64_t v28 = (unsigned __int8 *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a3 & 0x1000000000000000LL) == 0)
          {
            Swift::UInt64 v95 = v12;
            uint64_t v51 = v14;
            Swift::UInt64 v52 = v16;
            unint64_t v28 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a3, a4);
            Swift::UInt64 v16 = v52;
            uint64_t v14 = v51;
            Swift::UInt64 v12 = v95;
          }

          Swift::UInt32 v29 = v28[v27];
          if ((char)v28[v27] < 0) {
            __asm { BR              X9 }
          }
        }

        if (v21)
        {
LABEL_34:
          if (v19 == v14)
          {
            v53._Swift::UInt64 rawBits = v17._rawBits;
            Swift::UInt64 v54 = v12;
            uint64_t v55 = v14;
            Swift::UInt64 v56 = v16;
            v57._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v53)._rawBits;
            Swift::UInt64 v16 = v56;
            uint64_t v14 = v55;
            Swift::UInt64 v12 = v54;
            v17._Swift::UInt64 rawBits = v57._rawBits;
            if (v16 <= v57._rawBits >> 16)
            {
LABEL_122:
              unint64_t v94 = 31LL;
LABEL_123:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v94,  0);
            }
          }

          else if (v16 <= v17._rawBits >> 16)
          {
            goto LABEL_122;
          }

          if ((v17._rawBits & 1) == 0)
          {
            Swift::UInt64 v30 = v12;
            uint64_t v31 = v14;
            Swift::UInt64 v32 = v16;
            v33._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v17)._rawBits;
            Swift::UInt64 v16 = v32;
            uint64_t v14 = v31;
            Swift::UInt64 v12 = v30;
            v17._Swift::UInt64 rawBits = v17._rawBits & 0xC | v33._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
          }

          goto LABEL_42;
        }
      }

      if (v16 <= v17._rawBits >> 16)
      {
LABEL_121:
        unint64_t v94 = 121LL;
        goto LABEL_123;
      }

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s15CollectionOfOneVys7UnicodeO6ScalarVG_Tg506_sSS17ij42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n( int a1)
{
  uint64_t result = &_swiftEmptyArrayStorage;
  uint64_t v3 = qword_18C565BC8;
  uint64_t v4 = qword_18C565BC8 + 1;
  if (qword_18C565BC8 >= (unint64_t)qword_18C565BD0 >> 1)
  {
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (unint64_t)qword_18C565BD0 > 1,  qword_18C565BC8 + 1,  1);
    uint64_t result = &_swiftEmptyArrayStorage;
  }

  qword_18C565BC8 = v4;
  *((_DWORD *)&_swiftEmptyArrayStorage + v3 + 8) = a1;
  return result;
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s8RepeatedVys7UnicodeO6ScalarVG_Tg506_sSS17gh42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n( uint64_t a1, int a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t result = &_swiftEmptyArrayStorage;
  if (a1)
  {
    uint64_t v5 = a1 - 1;
    uint64_t v6 = v5 + 1;
    uint64_t v7 = a1;
    do
    {
      uint64_t v13 = result;
      uint64_t v9 = result[2];
      unint64_t v8 = (unint64_t)result[3];
      if ((unint64_t)v9 >= v8 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v8 > 1,  (int64_t)&v9->isa + 1,  1);
        uint64_t result = v13;
      }

      result[2] = (__objc2_class *)((char *)&v9->isa + 1);
      *((_DWORD *)result + (void)v9 + 8) = a2;
      --v7;
    }

    while (v7);
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  uint64_t v10 = a1 - v6;
  if (a1 != v6)
  {
    unint64_t v11 = result[2];
    do
    {
      uint64_t v14 = result;
      unint64_t v12 = (unint64_t)result[3];
      if ((unint64_t)v11 >= v12 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v12 > 1,  (int64_t)&v11->isa + 1,  1);
        uint64_t result = v14;
      }

      result[2] = (__objc2_class *)((char *)&v11->isa + 1);
      *((_DWORD *)result + (void)v11 + 8) = a2;
      unint64_t v11 = (__objc2_class *)((char *)v11 + 1);
      --v10;
    }

    while (v10);
  }

  return result;
}

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5( void (*a1)(uint64_t *__return_ptr, char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  void (*v51)(uint64_t *__return_ptr, char *);
  uint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  __objc2_class **v56;
  uint64_t v5 = v4;
  uint64_t v51 = a1;
  Swift::UInt64 v52 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = *(char **)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v47 = (char *)&v44 - v10;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v44 = *(void *)(v13 - 8);
  uint64_t v45 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  unsigned int v48 = (char *)&v44 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  Swift::UInt64 v18 = (char *)&v44 - v17;
  Swift::UInt64 v54 = *(char **)(a3 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v50 = (char *)&v44 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::String::Index v53 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v46 = *(void *)(v53 - 8);
  MEMORY[0x1895F8858](v53);
  int v21 = (char *)&v44 - v20;
  uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 40))(a3, a4);
  Swift::UInt64 v56 = &_swiftEmptyArrayStorage;
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v22 & ~(v22 >> 63),  0);
  (*((void (**)(char *, unint64_t, uint64_t))v54 + 2))(v50, v49, a3);
  Swift::UInt64 v23 = *(void (**)(uint64_t, uint64_t))(a4 + 32);
  Swift::UInt64 v54 = v21;
  v23(a3, a4);
  if (v22 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v24 = a3;
  unint64_t v25 = v53;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  v24,  v53,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v27 = AssociatedConformanceWitness;
  unint64_t v49 = AssociatedConformanceWitness;
  uint64_t v50 = v9;
  if (v22)
  {
    unint64_t v28 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
    while (1)
    {
      v28(v25, v27);
      if ((*((unsigned int (**)(char *, uint64_t, unint64_t))v9 + 6))(v18, 1LL, AssociatedTypeWitness) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x2B9uLL,  0);
      }
      v51(&v55, v18);
      if (v5) {
        break;
      }
      uint64_t v5 = 0LL;
      (*((void (**)(char *, unint64_t))v9 + 1))(v18, AssociatedTypeWitness);
      int v29 = v55;
      Swift::UInt64 v30 = v56;
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v56))
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v30[2]->isa + 1,  1);
        Swift::UInt64 v30 = v56;
      }

      Swift::UInt64 v32 = v30[2];
      unint64_t v31 = (unint64_t)v30[3];
      if ((unint64_t)v32 >= v31 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v31 > 1,  (int64_t)&v32->isa + 1,  1);
        Swift::UInt64 v30 = v56;
      }

      _OWORD v30[2] = (__objc2_class *)((char *)&v32->isa + 1);
      *((_DWORD *)v30 + (void)v32 + 8) = v29;
      --v22;
      unint64_t v27 = v49;
      uint64_t v9 = v50;
      unint64_t v25 = v53;
      if (!v22) {
        goto LABEL_11;
      }
    }

    (*(void (**)(char *, unint64_t))(v46 + 8))(v54, v25);
    swift_release((uint64_t)v56);
    return (__objc2_class **)(*((uint64_t (**)(char *, unint64_t))v9 + 1))(v18, AssociatedTypeWitness);
  }

  else
  {
LABEL_11:
    Swift::String::Index v33 = *(void (**)(unint64_t))(v27 + 16);
    Swift::UInt64 v34 = v48;
    v33(v25);
    uint64_t v35 = (uint64_t (*)(char *, uint64_t, unint64_t))*((void *)v9 + 6);
    if (v35(v34, 1LL, AssociatedTypeWitness) == 1)
    {
LABEL_12:
      (*(void (**)(char *, unint64_t))(v46 + 8))(v54, v25);
      (*(void (**)(char *, uint64_t))(v44 + 8))(v34, v45);
      return v56;
    }

    else
    {
      Swift::UInt64 v37 = (void (*)(char *, char *, unint64_t))*((void *)v9 + 4);
      while (1)
      {
        uint64_t v38 = v47;
        v37(v47, v34, AssociatedTypeWitness);
        v51(&v55, v38);
        if (v5) {
          break;
        }
        uint64_t v5 = 0LL;
        (*((void (**)(char *, unint64_t))v9 + 1))(v38, AssociatedTypeWitness);
        int v39 = v55;
        uint64_t v40 = v56;
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v56))
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v40[2]->isa + 1,  1);
          uint64_t v40 = v56;
        }

        uint64_t v42 = v40[2];
        unint64_t v41 = (unint64_t)v40[3];
        if ((unint64_t)v42 >= v41 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v41 > 1,  (int64_t)&v42->isa + 1,  1);
          uint64_t v40 = v56;
        }

        v40[2] = (__objc2_class *)((char *)&v42->isa + 1);
        *((_DWORD *)v40 + (void)v42 + 8) = v39;
        Swift::UInt64 v34 = v48;
        unint64_t v25 = v53;
        ((void (*)(unint64_t, unint64_t))v33)(v53, v49);
        int v43 = v35(v34, 1LL, AssociatedTypeWitness);
        uint64_t v9 = v50;
        if (v43 == 1) {
          goto LABEL_12;
        }
      }

      (*((void (**)(char *, unint64_t))v9 + 1))(v38, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v46 + 8))(v54, v53);
      return (__objc2_class **)swift_release((uint64_t)v56);
    }
  }

__objc2_class **_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSTRzsAE_pRsd_0_r_0_lIetMgnozo_Tpq5Tm( void (*a1)(char *, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  Swift::UInt64 v54 = (char *)a4;
  uint64_t v51 = a1;
  uint64_t v52 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v53 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v42 = (char *)&v41 - v10;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v43 = *(void *)(v13 - 8);
  uint64_t v44 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v45 = (char *)&v41 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  Swift::UInt64 v18 = (char *)&v41 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  unint64_t v41 = (char *)&v41 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  Swift::UInt64 v23 = (char *)&v41 - v22;
  uint64_t v49 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v21);
  unsigned int v48 = (char *)&v41 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v55 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v46 = *(void *)(v55 - 8);
  MEMORY[0x1895F8858](v55);
  Swift::String::Index v26 = (char *)&v41 - v25;
  Swift::Int v27 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 40))(a3, a5);
  Swift::String::Index v57 = &_swiftEmptyArrayStorage;
  uint64_t v50 = type metadata accessor for ContiguousArray(0LL, (uint64_t)v54, v28, v29);
  ContiguousArray.reserveCapacity(_:)(v27);
  (*(void (**)(char *, uint64_t, uint64_t))(v49 + 16))(v48, v47, a3);
  Swift::UInt64 v30 = *(void (**)(uint64_t, uint64_t))(a5 + 32);
  Swift::UInt64 v54 = v26;
  v30(a3, a5);
  if (v27 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  v55,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v32 = AssociatedConformanceWitness;
  if (v27)
  {
    Swift::String::Index v33 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v34 = v53;
    while (1)
    {
      v33(v55, v32);
      if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v34 + 48))( v18,  1LL,  AssociatedTypeWitness) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x2B9uLL,  0);
      }
      v51(v18, &v56);
      if (v6) {
        break;
      }
      uint64_t v6 = 0LL;
      uint64_t v34 = v53;
      (*(void (**)(char *, unint64_t))(v53 + 8))(v18, AssociatedTypeWitness);
      ContiguousArray.append(_:)((uint64_t)v23, v50);
      if (!--v27) {
        goto LABEL_9;
      }
    }

    (*(void (**)(char *, unint64_t))(v46 + 8))(v54, v55);
    swift_release((uint64_t)v57);
    return (__objc2_class **)(*(uint64_t (**)(char *, unint64_t))(v53 + 8))(v18, AssociatedTypeWitness);
  }

  else
  {
    uint64_t v34 = v53;
LABEL_9:
    uint64_t v35 = v45;
    uint64_t v49 = *(void *)(v32 + 16);
    ((void (*)(unint64_t, unint64_t))v49)(v55, v32);
    unsigned int v48 = *(char **)(v34 + 48);
    if (((unsigned int (*)(char *, uint64_t, unint64_t))v48)(v35, 1LL, AssociatedTypeWitness) == 1)
    {
      uint64_t v36 = v46;
LABEL_14:
      (*(void (**)(char *, unint64_t))(v36 + 8))(v54, v55);
      (*(void (**)(char *, uint64_t))(v43 + 8))(v35, v44);
      return v57;
    }

    else
    {
      Swift::UInt64 v37 = *(void (**)(char *, char *, unint64_t))(v34 + 32);
      uint64_t v38 = (uint64_t)v41;
      int v39 = v42;
      uint64_t v36 = v46;
      while (1)
      {
        v37(v39, v35, AssociatedTypeWitness);
        v51(v39, &v56);
        if (v6) {
          break;
        }
        uint64_t v6 = 0LL;
        (*(void (**)(char *, unint64_t))(v53 + 8))(v39, AssociatedTypeWitness);
        ContiguousArray.append(_:)(v38, v50);
        ((void (*)(unint64_t, unint64_t))v49)(v55, v32);
      }

      (*(void (**)(char *, unint64_t))(v53 + 8))(v39, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v36 + 8))(v54, v55);
      return (__objc2_class **)swift_release((uint64_t)v57);
    }
  }

uint64_t _SequenceBox._filter(_:)(uint64_t a1, uint64_t a2)
{
  return _SequenceBox._filter(_:)( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))Sequence.filter(_:));
}

__objc2_class **Sequence.filter(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v43 = a2;
  uint64_t v44 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t v36 = *(void *)(v10 - 8);
  uint64_t v37 = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v36 - v12;
  uint64_t v41 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  int v39 = (char *)&v36 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v17 = (char *)&v36 - v16;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v38 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v20 = (char *)&v36 - v19;
  uint64_t v46 = &_swiftEmptyArrayStorage;
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  v18,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v22 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v40 = v20;
  unint64_t v45 = v18;
  unint64_t v23 = v18;
  uint64_t v24 = v22;
  v22(v23, AssociatedConformanceWitness);
  uint64_t v25 = v41;
  Swift::String::Index v26 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v41 + 48);
  if (v26(v13, 1LL, AssociatedTypeWitness) == 1)
  {
    Swift::Int v27 = v40;
LABEL_3:
    (*(void (**)(char *, unint64_t))(v38 + 8))(v27, v45);
    (*(void (**)(char *, uint64_t))(v36 + 8))(v13, v37);
    return v46;
  }

  else
  {
    uint64_t v42 = v24;
    uint64_t v29 = *(void (**)(char *, char *, unint64_t))(v25 + 32);
    Swift::Int v27 = v40;
    v29(v17, v13, AssociatedTypeWitness);
    while (1)
    {
      char v30 = v44(v17);
      if (v4) {
        break;
      }
      if ((v30 & 1) != 0)
      {
        unint64_t v31 = v39;
        v29(v39, v17, AssociatedTypeWitness);
        uint64_t v34 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v32, v33);
        uint64_t v35 = (uint64_t)v31;
        Swift::Int v27 = v40;
        ContiguousArray.append(_:)(v35, v34);
      }

      else
      {
        (*(void (**)(char *, unint64_t))(v41 + 8))(v17, AssociatedTypeWitness);
      }

      v42(v45, AssociatedConformanceWitness);
      if (v26(v13, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_3;
      }
      v29(v17, v13, AssociatedTypeWitness);
    }

    (*(void (**)(char *, unint64_t))(v41 + 8))(v17, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v38 + 8))(v27, v45);
    return (__objc2_class **)swift_release((uint64_t)v46);
  }

uint64_t _SequenceBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 208);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, (uint64_t)v2 + *(void *)(v5 + 224), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(const char **)(v5 + 216));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t Sequence.forEach(_:)(void (*a1)(char *), uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v36 = a4;
  unint64_t v31 = a1;
  uint64_t v32 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v38 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v30 - v8;
  uint64_t v12 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v30 - v14;
  uint64_t v16 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v13);
  unint64_t v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v33 = *(void *)(v19 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (char *)&v30 - v20;
  (*(void (**)(char *, unint64_t, uint64_t))(v16 + 16))(v18, v37, a3);
  uint64_t v22 = (uint64_t)v36;
  (*((void (**)(uint64_t, const char *))v36 + 4))(a3, v36);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v22,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v24 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v36 = v21;
  unint64_t v37 = v19;
  v24(v19, AssociatedConformanceWitness);
  uint64_t v25 = v38;
  Swift::String::Index v26 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v38 + 48);
  if (v26(v15, 1LL, AssociatedTypeWitness) != 1)
  {
    uint64_t v34 = v26;
    uint64_t v35 = v24;
    Swift::Int v27 = v31;
    uint64_t v28 = *(void (**)(char *, char *, unint64_t))(v25 + 32);
    while (1)
    {
      v28(v9, v15, AssociatedTypeWitness);
      v27(v9);
      if (v4) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v38 + 8))(v9, AssociatedTypeWitness);
      v35(v37, AssociatedConformanceWitness);
      if (v34(v15, 1LL, AssociatedTypeWitness) == 1) {
        return (*(uint64_t (**)(const char *, unint64_t))(v33 + 8))(v36, v37);
      }
    }

    (*(void (**)(char *, unint64_t))(v38 + 8))(v9, AssociatedTypeWitness);
  }

  return (*(uint64_t (**)(const char *, unint64_t))(v33 + 8))(v36, v37);
}

uint64_t _SequenceBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 224), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v3 + 216) + 48LL))(a1, v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _SequenceBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 208);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))( (char *)&v7 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v1 + *(void *)(v2 + 224),  v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 216) + 56LL))(v3);
}

char *_SequenceBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v3 + 216);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 224), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject(v15, *(unsigned int *)(v15 + 48), *(unsigned __int16 *)(v15 + 52));
  (*(void (**)(char *, char *, unint64_t))(v10 + 32))( &v16[*(void *)(*(void *)v16 + 120LL)],  v12,  AssociatedTypeWitness);
  return v16;
}

char *_SequenceBox._dropFirst(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v23 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t Sequence = type metadata accessor for DropFirstSequence(0LL, v4, *(void *)(v3 + 216), v8);
  uint64_t v10 = *(void *)(Sequence - 8);
  uint64_t v11 = MEMORY[0x1895F8858](Sequence);
  uint64_t v13 = (char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v23 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 224), v4);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a sequence",  56LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x1E3uLL,  0);
  }
  (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v13, v7, v4);
  *(void *)&v13[*(int *)(Sequence + 36)] = a1;
  uint64_t v16 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
  v16(v15, v13, Sequence);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DropFirstSequence<A>, Sequence, v17);
  uint64_t v20 = type metadata accessor for _SequenceBox(0LL, Sequence, WitnessTable, v19);
  uint64_t v21 = (char *)swift_allocObject(v20, *(unsigned int *)(v20 + 48), *(unsigned __int16 *)(v20 + 52));
  v16(&v21[*(void *)(*(void *)v21 + 224LL)], v15, Sequence);
  return v21;
}

uint64_t Sequence.dropFirst(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Sequence.dropFirst(_:)( a1,  a2,  a3,  "Can't drop a negative number of elements from a sequence",  56LL,  0x1E3uLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for DropFirstSequence,  a4);
}

char *_SequenceBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v3 = (char *)swift_allocObject(v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  (*(void (**)(char *, uint64_t))(*(void *)(*(void *)(v1 + 208) - 8LL) + 32LL))( &v3[*(void *)(*(void *)v3 + 224LL)],  a1);
  return v3;
}

uint64_t _SequenceBox._drop(while:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v3 = v2;
  int v39 = a1;
  uint64_t v40 = a2;
  uint64_t v4 = *(void *)v2;
  uint64_t v6 = *(void *)(*(void *)v2 + 208LL);
  uint64_t v5 = *(void *)(*(void *)v2 + 216LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v37 - v9;
  uint64_t v11 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v37 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = type metadata accessor for DropWhileSequence(0LL, v6, v5, v14);
  uint64_t v37 = *(void *)(v15 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v37 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v38 = (char *)&v37 - v20;
  uint64_t v21 = *(void (**)(char *, char *, uint64_t))(v11 + 16);
  uint64_t v23 = v22;
  v21(v13, &v3[*(void *)(v4 + 224)], v6);
  uint64_t v24 = &v19[*(int *)(v15 + 36)];
  uint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v25 - 8) + 56LL))(v24, 1LL, 1LL, v25);
  (*(void (**)(uint64_t, uint64_t))(v5 + 32))(v6, v5);
  uint64_t v26 = v41;
  DropWhileSequence.init(iterator:predicate:)((uint64_t)v10, v39, v40, v6, (const char *)v5, v23);
  uint64_t v29 = type metadata accessor for Optional(0LL, v25, v27, v28);
  (*(void (**)(char *, uint64_t))(*(void *)(v29 - 8) + 8LL))(v24, v29);
  if (!v26)
  {
    uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t))(v37 + 32);
    v30(v19, v23, v15);
    unint64_t v31 = v38;
    v30(v38, (uint64_t)v19, v15);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DropWhileSequence<A>, v15, v32);
    uint64_t v35 = type metadata accessor for _SequenceBox(0LL, v15, WitnessTable, v34);
    uint64_t v25 = (uint64_t)swift_allocObject(v35, *(unsigned int *)(v35 + 48), *(unsigned __int16 *)(v35 + 52));
    v30((char *)(v25 + *(void *)(*(void *)v25 + 224LL)), (uint64_t)v31, v15);
  }

  return v25;
}

uint64_t Sequence.drop(while:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v27 = a1;
  uint64_t v28 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v25 - v9;
  uint64_t v12 = type metadata accessor for DropWhileSequence(0LL, a3, a4, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v25 - v15;
  uint64_t v17 = *(int *)(v14 + 36);
  uint64_t v26 = a5;
  uint64_t v18 = a5 + v17;
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v19 - 8) + 56LL))( v18,  1LL,  1LL,  v19);
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  uint64_t v20 = v29;
  DropWhileSequence.init(iterator:predicate:)((uint64_t)v10, v27, v28, a3, (const char *)a4, (uint64_t)v16);
  uint64_t v23 = type metadata accessor for Optional(0LL, v19, v21, v22);
  if (v20) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v23 - 8) + 8LL))(v18, v23);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v23 - 8) + 8LL))(v18, v23);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v13 + 32))(v26, v16, v12);
}

uint64_t _SequenceBox._dropLast(_:)(uint64_t a1)
{
  return _SequenceBox._dropLast(_:)(a1, Sequence.dropLast(_:));
}

uint64_t Sequence.dropLast(_:)(int64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v47 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v47 - v11;
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v47 - v16;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  MEMORY[0x1895F8858](v18);
  uint64_t v56 = (char *)&v47 - v24;
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a sequence",  56LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x436uLL,  0);
  }
  if (!a1) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 56))(a2, a3);
  }
  uint64_t v51 = v23;
  Swift::String::Index v57 = &_swiftEmptyArrayStorage;
  Swift::UInt64 v58 = &_swiftEmptyArrayStorage;
  uint64_t v55 = v22;
  uint64_t v50 = v10;
  int64_t v25 = a1;
  uint64_t v26 = v7;
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(a3 + 32);
  swift_retain((unint64_t *)&_swiftEmptyArrayStorage, v19, v20, v21);
  unint64_t v52 = AssociatedTypeWitness;
  v27(a2, a3);
  uint64_t v28 = v26;
  int64_t v29 = v25;
  uint64_t v30 = v55;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  v55,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v32 = v52;
  Swift::UInt64 v54 = *(void (**)(uint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v54(v30, AssociatedConformanceWitness);
  uint64_t v33 = *(unsigned int (**)(void, void, void))(v28 + 48);
  if (v33(v17, 1LL, v32) != 1)
  {
    unint64_t v36 = 0LL;
    uint64_t v53 = *(void (**)(char *, char *, uint64_t))(v28 + 32);
    do
    {
      v53(v12, v17, v32);
      int v39 = v57[2];
      if ((uint64_t)v39 >= v29)
      {
        if (v36 >= (unint64_t)v39) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }
        unint64_t v49 = (*(unsigned __int8 *)(v28 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v28 + 80);
        unint64_t v41 = *(void *)(v28 + 72) * v36;
        uint64_t v47 = v33;
        unint64_t v48 = v41;
        uint64_t v42 = (uint64_t)v50;
        (*(void (**)(char *, unint64_t, uint64_t))(v28 + 16))( v50,  (unint64_t)v57 + v49 + v41,  v32);
        uint64_t v45 = type metadata accessor for ContiguousArray(0LL, v32, v43, v44);
        ContiguousArray.append(_:)(v42, v45);
        uint64_t v46 = v57;
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v57))
        {
          uint64_t v46 = _ContiguousArrayBuffer._consumeAndCreateNew()((uint64_t)v46, *(uint64_t **)(v45 + 16));
          Swift::String::Index v57 = v46;
        }

        uint64_t v30 = v55;
        uint64_t v33 = v47;
        specialized Array._checkSubscript_mutating(_:)(v36, (uint64_t)v46);
        (*(void (**)(char *, char *, uint64_t))(v28 + 40))((char *)v46 + v49 + v48, v12, v32);
        else {
          unint64_t v36 = 0LL;
        }
      }

      else
      {
        uint64_t v40 = type metadata accessor for ContiguousArray(0LL, v32, v37, v38);
        ContiguousArray.append(_:)((uint64_t)v12, v40);
      }

      v54(v30, AssociatedConformanceWitness);
    }

    while (v33(v17, 1LL, v32) != 1);
  }

  (*(void (**)(char *, uint64_t))(v51 + 8))(v56, v30);
  uint64_t v34 = v58;
  swift_release((uint64_t)v57);
  return (uint64_t)v34;
}

char *_SequenceBox._prefix(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 208);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v23 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for PrefixSequence(0LL, v4, *(void *)(v3 + 216), v8);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v23 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 224), v4);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a prefix of negative length",  38LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x211uLL,  0);
  }
  (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v13, v7, v4);
  *(void *)&v13[*(int *)(v9 + 36)] = a1;
  uint64_t v16 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
  v16(v15, v13, v9);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for PrefixSequence<A>, v9, v17);
  uint64_t v20 = type metadata accessor for _SequenceBox(0LL, v9, WitnessTable, v19);
  uint64_t v21 = (char *)swift_allocObject(v20, *(unsigned int *)(v20 + 48), *(unsigned __int16 *)(v20 + 52));
  v16(&v21[*(void *)(*(void *)v21 + 224LL)], v15, v9);
  return v21;
}

uint64_t Sequence.prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Sequence.dropFirst(_:)( a1,  a2,  a3,  "Can't take a prefix of negative length",  38LL,  0x211uLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for PrefixSequence,  a4);
}

uint64_t Sequence.dropFirst(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t (*a7)(void, uint64_t, uint64_t)@<X6>, uint64_t a8@<X8>)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a4,  a5,  2,  "Swift/Sequence.swift",  20LL,  2,  a6,  0);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a8, v8, a2);
  uint64_t result = a7(0LL, a2, a3);
  *(void *)(a8 + *(int *)(result + 36)) = a1;
  return result;
}

uint64_t _SequenceBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _SequenceBox._filter(_:)( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void))Sequence.prefix(while:));
}

uint64_t _SequenceBox._filter(_:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, void))
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 208);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))( (char *)&v12 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v3 + *(void *)(v7 + 224),  v8);
  return a3(a1, a2, v8, *(void *)(v7 + 216));
}

__objc2_class **Sequence.prefix(while:)( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = a1;
  uint64_t v36 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v31 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v31 - v10;
  uint64_t v14 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v12, v13);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = (char *)&v31 - v15;
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v32 = *(void *)(v17 - 8);
  MEMORY[0x1895F8858](v17);
  uint64_t v19 = (char *)&v31 - v18;
  int v39 = &_swiftEmptyArrayStorage;
  (*(void (**)(uint64_t))(a4 + 32))(a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  v17,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v21 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v37 = v19;
  unint64_t v38 = v17;
  uint64_t v22 = v33;
  uint64_t v34 = v21;
  v21(v17, AssociatedConformanceWitness);
  uint64_t v23 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v22 + 48);
  if (v23(v16, 1LL, AssociatedTypeWitness) != 1)
  {
    uint64_t v24 = *(void (**)(char *, char *, unint64_t))(v22 + 32);
    uint64_t v25 = (uint64_t)v31;
    while (1)
    {
      v24(v11, v16, AssociatedTypeWitness);
      char v26 = v35(v11);
      if (v4)
      {
        (*(void (**)(char *, unint64_t))(v33 + 8))(v11, AssociatedTypeWitness);
        (*(void (**)(char *, unint64_t))(v32 + 8))(v37, v38);
        return (__objc2_class **)swift_release((uint64_t)v39);
      }

      if ((v26 & 1) == 0) {
        break;
      }
      v24((char *)v25, v11, AssociatedTypeWitness);
      uint64_t v29 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v27, v28);
      ContiguousArray.append(_:)(v25, v29);
      v34(v38, AssociatedConformanceWitness);
      if (v23(v16, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_9;
      }
    }

    (*(void (**)(char *, unint64_t))(v33 + 8))(v11, AssociatedTypeWitness);
  }

uint64_t _SequenceBox._suffix(_:)(uint64_t a1)
{
  return _SequenceBox._dropLast(_:)(a1, (uint64_t (*)(uint64_t, uint64_t, void))Sequence.suffix(_:));
}

uint64_t _SequenceBox._dropLast(_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, void))
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 208);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))( (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v2 + *(void *)(v5 + 224),  v6);
  return a2(a1, v6, *(void *)(v5 + 216));
}

__objc2_class **Sequence.suffix(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v7 = *(AssociatedTypeWitness - 1);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v61 - v8;
  uint64_t v12 = type metadata accessor for Optional(0LL, (uint64_t)AssociatedTypeWitness, v10, v11);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v61 - v14;
  uint64_t v66 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v13);
  unint64_t v17 = (void (*)(unint64_t, unint64_t))((char *)&v61 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  unint64_t v70 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  MEMORY[0x1895F8858](v70);
  uint64_t v23 = (char *)&v61 - v22;
  if (a1 < 0) {
LABEL_27:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a suffix of negative length from a sequence",  54LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x3E6uLL,  0);
  if (!a1)
  {
    (*(void (**)(uint64_t, uint64_t))(v66 + 8))(v65, a2);
    _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
    return &_swiftEmptyArrayStorage;
  }

  uint64_t v63 = v21;
  Swift::UInt64 v76 = &_swiftEmptyArrayStorage;
  uint64_t v67 = v7;
  uint64_t v24 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 40);
  swift_retain((unint64_t *)&_swiftEmptyArrayStorage, v18, v19, v20);
  int v69 = v17;
  uint64_t v25 = a2;
  uint64_t v26 = v65;
  uint64_t v27 = v24(v25, a3);
  int64_t v30 = a1;
  if (v27 >= a1) {
    uint64_t v31 = a1;
  }
  else {
    uint64_t v31 = v27;
  }
  Swift::Int v68 = v31;
  uint64_t v32 = type metadata accessor for ContiguousArray(0LL, (uint64_t)AssociatedTypeWitness, v28, v29);
  Swift::Int v33 = v68;
  Swift::Int v68 = v32;
  ContiguousArray.reserveCapacity(_:)(v33);
  uint64_t v34 = v26;
  uint64_t v35 = v25;
  (*(void (**)(void (*)(unint64_t, unint64_t), uint64_t, uint64_t))(v66 + 16))( v69,  v34,  v25);
  (*(void (**)(uint64_t, uint64_t))(a3 + 32))(v25, a3);
  uint64_t v36 = a3;
  unint64_t v37 = v70;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v36,  v25,  v70,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int v39 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v64 = v23;
  int v69 = v39;
  v39(v37, AssociatedConformanceWitness);
  uint64_t v40 = v67;
  unint64_t v41 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v67 + 48);
  if (v41(v15, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, unint64_t))(v63 + 8))(v64, v37);
LABEL_24:
    swift_release((uint64_t)&_swiftEmptyArrayStorage);
    (*(void (**)(uint64_t, uint64_t))(v66 + 8))(v65, v35);
    return v76;
  }

  uint64_t v43 = v64;
  uint64_t v62 = v35;
  int64_t v44 = 0LL;
  uint64_t v45 = *(void (**)(char *, char *, uint64_t *))(v40 + 32);
  v45(v9, v15, AssociatedTypeWitness);
  while (1)
  {
    uint64_t v46 = v76;
    if ((uint64_t)v76[2] < v30)
    {
      ContiguousArray.append(_:)((uint64_t)v9, v68);
    }

    else
    {
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v76))
      {
        uint64_t v46 = _ContiguousArrayBuffer._consumeAndCreateNew()((uint64_t)v46, *(uint64_t **)(v68 + 16));
        Swift::UInt64 v76 = v46;
      }

      specialized Array._checkSubscript_mutating(_:)(v44, (uint64_t)v46);
      (*(void (**)(unint64_t, char *, uint64_t *))(v67 + 40))( (unint64_t)v46 + ((*(unsigned __int8 *)(v67 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v67 + 80))
      + *(void *)(v67 + 72) * v44,
        v9,
        AssociatedTypeWitness);
      if (__OFADD__(v44, 1LL))
      {
        __break(1u);
        goto LABEL_27;
      }

      if (v44 + 1 >= v30) {
        int64_t v44 = 0LL;
      }
      else {
        ++v44;
      }
    }

    v69(v70, AssociatedConformanceWitness);
    if (v41(v15, 1LL, AssociatedTypeWitness) == 1) {
      break;
    }
    v45(v9, v15, AssociatedTypeWitness);
  }

  (*(void (**)(char *, unint64_t))(v63 + 8))(v43, v70);
  uint64_t v35 = v62;
  if (!v44) {
    goto LABEL_24;
  }
  Swift::UInt32 v75 = &_swiftEmptyArrayStorage;
  uint64_t v47 = (unint64_t *)v76;
  Swift::Int v48 = (Swift::Int)v76[2];
  uint64_t v49 = v68;
  ContiguousArray.reserveCapacity(_:)(v48);
  uint64_t v50 = v66;
  if (v48 < v44) {
    goto LABEL_28;
  }
  ContiguousArray._checkIndex(_:)(v44);
  ContiguousArray._checkIndex(_:)(v48);
  unint64_t v51 = (*(unsigned __int8 *)(v67 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v67 + 80);
  Swift::UInt64 v71 = v47;
  Swift::String::Index v72 = (char *)v47 + v51;
  int64_t v73 = v44;
  uint64_t v74 = (2 * v48) | 1;
  uint64_t v54 = type metadata accessor for ArraySlice(0LL, (uint64_t)AssociatedTypeWitness, v52, v53);
  swift_retain(v47, v55, v56, v57);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v54, v58);
  ContiguousArray.append<A>(contentsOf:)((uint64_t)&v71, v49, v54, WitnessTable);
  if (v44 < 0) {
LABEL_28:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  (*(void (**)(uint64_t, uint64_t))(v50 + 8))(v65, v35);
  Swift::UInt64 v60 = v76;
  ContiguousArray._checkIndex(_:)(0LL);
  ContiguousArray._checkIndex(_:)(v44);
  Swift::UInt64 v71 = v60;
  Swift::String::Index v72 = (char *)v60 + v51;
  int64_t v73 = 0LL;
  uint64_t v74 = (2 * v44) | 1;
  ContiguousArray.append<A>(contentsOf:)((uint64_t)&v71, v49, v54, WitnessTable);
  return v75;
}

uint64_t _SequenceBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 208LL) - 8LL) + 8LL))(v0 + *(void *)(*(void *)v0 + 224LL));
}

uint64_t _SequenceBox.deinit()
{
  return v0;
}

void _SequenceBox.__deallocating_deinit()
{
}

uint64_t _SequenceBox.init(_base:)(uint64_t a1)
{
  return v1;
}

uint64_t _SequenceBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 208LL) - 8LL) + 16LL))( a1,  v1 + *(void *)(*(void *)v1 + 224LL));
}

uint64_t _SequenceBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 208LL) - 8LL) + 40LL))( v1 + *(void *)(*(void *)v1 + 224LL),  a1);
}

uint64_t (*_SequenceBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _SequenceBox.__allocating_init()()
{
}

void _SequenceBox.init()()
{
}

char *_CollectionBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void *)(*(void *)(v2 + 352) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 360), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject(v14, *(unsigned int *)(v14 + 48), *(unsigned __int16 *)(v14 + 52));
  (*(void (**)(char *, char *, unint64_t))(v9 + 32))( &v15[*(void *)(*(void *)v15 + 120LL)],  v11,  AssociatedTypeWitness);
  return v15;
}

uint64_t _CollectionBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 360), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v2 + 352) + 8LL) + 40LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_CollectionBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 344);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = &v14[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v9 + 16))(v11, (uint64_t)v3 + *(void *)(v7 + 360), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 352);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm( (void (*)(char *, void *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error),  (uint64_t)v14,  v8,  a3,  v17);
  (*(void (**)(_BYTE *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_CollectionBox._filter(_:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 344);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))( (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v2 + *(void *)(v5 + 360),  v6);
  return Sequence.filter(_:)(a1, a2, v6, *(void *)(*(void *)(v5 + 352) + 8LL));
}

uint64_t _CollectionBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 344);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, (uint64_t)v2 + *(void *)(v5 + 360), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(const char **)(*(void *)(v5 + 352) + 8LL));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t _CollectionBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 360), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v3 + 352) + 8LL) + 48LL))(a1, v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _CollectionBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))( (char *)&v7 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v1 + *(void *)(v2 + 360),  v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v2 + 352) + 8LL) + 56LL))(v3);
}

char *_CollectionBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(v3 + 352) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 360), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject(v15, *(unsigned int *)(v15 + 48), *(unsigned __int16 *)(v15 + 52));
  (*(void (**)(char *, char *, unint64_t))(v10 + 32))( &v16[*(void *)(*(void *)v16 + 120LL)],  v12,  AssociatedTypeWitness);
  return v16;
}

char *_CollectionBox._drop(while:)(uint64_t a1, uint64_t a2)
{
  return _CollectionBox._drop(while:)( a1,  a2,  (void (*)(uint64_t, uint64_t, uint64_t, const char *))Collection.drop(while:));
}

char *_CollectionBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_allocObject(v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  uint64_t v4 = specialized _CollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 344) - 8LL) + 8LL))(a1);
  return v4;
}

char *_CollectionBox._dropFirst(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)( a1,  (void (*)(uint64_t, uint64_t, const char *))Collection.dropFirst(_:));
}

char *_CollectionBox._dropLast(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, const char *))Collection.dropLast(_:));
}

char *_CollectionBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _CollectionBox._drop(while:)( a1,  a2,  (void (*)(uint64_t, uint64_t, uint64_t, const char *))Collection.prefix(while:));
}

char *_CollectionBox._drop(while:)( uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, uint64_t, const char *))
{
  uint64_t v24 = a3;
  uint64_t v22 = a2;
  uint64_t v4 = v3;
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 344);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(const char **)(v6 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v11,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v21 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v20 - v13;
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v10, (uint64_t)v4 + *(void *)(v6 + 360), v7);
  uint64_t v15 = v23;
  v24(a1, v22, v7, v11);
  if (!v15)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v11,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    uint64_t v18 = type metadata accessor for _CollectionBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v17);
    swift_allocObject(v18, *(unsigned int *)(v18 + 48), *(unsigned __int16 *)(v18 + 52));
    uint64_t v10 = specialized _CollectionBox.init(_base:)((uint64_t)v14);
    (*(void (**)(char *, unint64_t))(v21 + 8))(v14, AssociatedTypeWitness);
  }

  return v10;
}

char *_CollectionBox._prefix(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, const char *))Collection.prefix(_:));
}

char *_CollectionBox._suffix(_:)(uint64_t a1)
{
  return _CollectionBox._dropFirst(_:)(a1, (void (*)(uint64_t, uint64_t, const char *))Collection.suffix(_:));
}

char *_CollectionBox._dropFirst(_:)(uint64_t a1, void (*a2)(uint64_t, uint64_t, const char *))
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(const char **)(v3 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v8,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 360), v4);
  v19(v18, v4, v8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v15 = type metadata accessor for _CollectionBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  swift_allocObject(v15, *(unsigned int *)(v15 + 48), *(unsigned __int16 *)(v15 + 52));
  uint64_t v16 = specialized _CollectionBox.init(_base:)((uint64_t)v12);
  (*(void (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
  return v16;
}

uint64_t _CollectionBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 344LL) - 8LL) + 8LL))(v0 + *(void *)(*(void *)v0 + 360LL));
}

id *_CollectionBox.deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[43] - 8LL) + 8LL))((char *)v0 + *((void *)*v0 + 45));
  return v0;
}

void _CollectionBox.__deallocating_deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[43] - 8LL) + 8LL))((char *)v0 + *((void *)*v0 + 45));
  swift_deallocClassInstance((uint64_t)v0);
}

char *_CollectionBox.init(_base:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = specialized _CollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v3 + 344) - 8LL) + 8LL))(a1);
  return v4;
}

char *_IndexBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v3 = (char *)swift_allocObject(v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  (*(void (**)(char *, uint64_t))(*(void *)(*(void *)(v1 + 80) - 8LL) + 32LL))( &v3[*(void *)(*(void *)v3 + 96LL)],  a1);
  return v3;
}

uint64_t _CollectionBox._unbox(_:file:line:)@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v24 = a6;
  uint64_t v25 = a3;
  int v27 = a5;
  uint64_t v26 = a4;
  uint64_t v28 = a7;
  uint64_t v11 = *(void *)(*(void *)v7 + 344LL);
  uint64_t v10 = *(const char **)(*(void *)v7 + 352LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v23 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t v15 = *(void *)(v23 - 8);
  MEMORY[0x1895F8858](v23);
  uint64_t v17 = (char *)&v23 - v16;
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v19 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v19(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v21 = *(void *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v21 + 48))(v17, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v15 + 8))(v17, v23);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  v25,  v26,  v27,  v24,  0);
  }

  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v21 + 32))(v28, v17, AssociatedTypeWitness);
}

uint64_t _CollectionBox.subscript.getter@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = a3;
  uint64_t v6 = *(void *)(*(void *)v3 + 344LL);
  uint64_t v7 = *(void *)(*(void *)v3 + 352LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v38 = *(void *)(v11 - 8);
  uint64_t v39 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v38 - v13;
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v12);
  uint64_t v18 = (char *)&v38 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  unint64_t v41 = (char *)&v38 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v38 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = v23;
  unint64_t v24 = *(void (**)(void))(v23 + 16);
  uint64_t v40 = v22;
  v24();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v26 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v28 = ObjectType;
  uint64_t v29 = v15;
  v26(AssociatedTypeWitness, AssociatedConformanceWitness, v28, a2);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v15 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v38 + 8))(v14, v39);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x2F0uLL,  0);
  }

  int64_t v30 = *(void (**)(char *, char *, unint64_t))(v15 + 32);
  v30(v18, v14, AssociatedTypeWitness);
  uint64_t v31 = v41;
  v30(v41, v18, AssociatedTypeWitness);
  uint64_t v32 = v40;
  Swift::Int v33 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v7 + 80))( v44,  v31,  v6,  v7);
  uint64_t v35 = v34;
  unint64_t v36 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v36 - 8) + 16LL))(v43, v35, v36);
  v33(v44, 0LL);
  (*(void (**)(char *, unint64_t))(v29 + 8))(v31, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v32, v6);
}

char *_CollectionBox.subscript.getter(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v89 = a3;
  uint64_t v90 = a4;
  unint64_t v91 = a1;
  uint64_t v92 = a2;
  uint64_t v6 = *(void *)(*(void *)v4 + 344LL);
  uint64_t v5 = *(const char **)(*(void *)v4 + 352LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v84 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v85 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v83 = (char *)&v71 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v9, "lower upper ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v12 = (char *)&v71 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  Swift::UInt64 v79 = (char *)&v71 - v13;
  uint64_t v72 = type metadata accessor for Optional(0LL, v9, v14, v15);
  uint64_t v71 = *(void *)(v72 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v72);
  uint64_t v18 = (char *)&v71 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v71 - v20;
  uint64_t v22 = *(void **)(v9 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v19);
  unint64_t v87 = (char *)&v71 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  unsigned int v86 = (char *)&v71 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v88 = (char *)&v71 - v28;
  MEMORY[0x1895F8858](v27);
  unint64_t v93 = (char *)&v71 - v29;
  unint64_t v82 = v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = type metadata accessor for Range(0LL, v9, AssociatedConformanceWitness, v31);
  uint64_t v77 = *(void *)(v32 - 8);
  uint64_t v78 = v32;
  uint64_t v33 = MEMORY[0x1895F8858](v32);
  int64_t v73 = (char *)&v71 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  Swift::UInt32 v75 = (char *)&v71 - v36;
  MEMORY[0x1895F8858](v35);
  uint64_t v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v76 = v39;
  uint64_t v40 = *(void (**)(void))(v39 + 16);
  uint64_t v74 = v38;
  uint64_t v81 = v6;
  v40();
  unint64_t ObjectType = swift_getObjectType(v91);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v92 + 16))( v9,  AssociatedConformanceWitness,  ObjectType);
  uint64_t v42 = (unsigned int (*)(char *, uint64_t, unint64_t))v22[6];
  if (v42(v21, 1LL, v9) == 1)
  {
    (*(void (**)(char *, uint64_t))(v71 + 8))(v21, v72);
    goto LABEL_8;
  }

  uint64_t v43 = (void (*)(char *, char *, unint64_t))v22[4];
  v43(v93, v21, v9);
  unint64_t v44 = swift_getObjectType(v89);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v90 + 16))( v9,  AssociatedConformanceWitness,  v44);
  if (v42(v18, 1LL, v9) == 1)
  {
    (*(void (**)(char *, uint64_t))(v71 + 8))(v18, v72);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x2F8uLL,  0);
  }

  uint64_t v45 = v88;
  v43(v88, v18, v9);
  uint64_t v46 = (void (*)(char *, char *, unint64_t))v22[2];
  uint64_t v47 = v86;
  v46(v86, v93, v9);
  Swift::Int v48 = v87;
  v46(v87, v45, v9);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v47,  v48,  v9,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v49 = (void (*)(char *, unint64_t))v22[1];
  v49(v48, v9);
  v49(v47, v9);
  uint64_t v50 = TupleTypeMetadata2;
  unint64_t v51 = v45;
  uint64_t v52 = v79;
  uint64_t v53 = &v79[*((int *)TupleTypeMetadata2 + 12)];
  v43(v79, v93, v9);
  v43(v53, v51, v9);
  uint64_t v54 = &v12[*((int *)v50 + 12)];
  v46(v12, v52, v9);
  v46(v54, v53, v9);
  uint64_t v55 = v73;
  v43(v73, v12, v9);
  v49(v54, v9);
  uint64_t v56 = &v12[*((int *)v50 + 12)];
  v43(v12, v52, v9);
  v43(v56, v53, v9);
  uint64_t v57 = v78;
  v43(&v55[*(int *)(v78 + 36)], v56, v9);
  v49(v12, v9);
  uint64_t v58 = v77;
  uint64_t v59 = v75;
  (*(void (**)(char *, char *, uint64_t))(v77 + 32))(v75, v55, v57);
  uint64_t v60 = (uint64_t)v82;
  uint64_t v61 = (uint64_t)v83;
  uint64_t v62 = v74;
  uint64_t v63 = v81;
  (*((void (**)(char *, uint64_t, const char *))v82 + 11))(v59, v81, v82);
  (*(void (**)(char *, uint64_t))(v58 + 8))(v59, v57);
  (*(void (**)(char *, uint64_t))(v76 + 8))(v62, v63);
  uint64_t v64 = v63;
  uint64_t v65 = v85;
  unint64_t v66 = swift_getAssociatedConformanceWitness( v60,  v64,  v85,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v68 = type metadata accessor for _CollectionBox(0LL, v65, v66, v67);
  swift_allocObject(v68, *(unsigned int *)(v68 + 48), *(unsigned __int16 *)(v68 + 52));
  int v69 = specialized _CollectionBox.init(_base:)(v61);
  (*(void (**)(uint64_t, uint64_t))(v84 + 8))(v61, v65);
  return v69;
}

char *_CollectionBox._index(after:)(unint64_t a1, uint64_t a2)
{
  uint64_t v35 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 344);
  uint64_t v36 = *(const char **)(*v2 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v36,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v30 = *(void *)(v9 - 8);
  uint64_t v31 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v29 - v11;
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v13);
  uint64_t v19 = (char *)&v29 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v33 = v21;
  uint64_t v34 = (char *)&v29 - v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v15, (uint64_t)v2 + *(void *)(v4 + 360), v5);
  swift_getObjectType(a1);
  uint64_t v22 = *(void (**)(unint64_t))(v35 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v36,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v22(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v16 + 48))(v12, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v30 + 8))(v12, v31);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x2FEuLL,  0);
  }

  uint64_t v23 = *(void (**)(char *, char *, unint64_t))(v16 + 32);
  v23(v19, v12, AssociatedTypeWitness);
  uint64_t v24 = v34;
  (*((void (**)(char *, uint64_t))v36 + 23))(v19, v5);
  (*(void (**)(char *, unint64_t))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v15, v5);
  uint64_t v26 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v27 = (char *)swift_allocObject(v26, *(unsigned int *)(v26 + 48), *(unsigned __int16 *)(v26 + 52));
  v23(&v27[*(void *)(*(void *)v27 + 96LL)], v24, AssociatedTypeWitness);
  return v27;
}

uint64_t _CollectionBox._formIndex(after:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 344);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v16 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v3 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v8,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v13 = swift_dynamicCastClass(a1, v12);
  if (!v13) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x306uLL,  0);
  }
  uint64_t v14 = v13;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 360), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 192))(v14 + *(void *)(*(void *)v14 + 96LL), v4, v8);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

char *_CollectionBox._index(_:offsetBy:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = a3;
  uint64_t v36 = a2;
  uint64_t v5 = *v3;
  uint64_t v6 = *(void *)(*v3 + 344);
  uint64_t v37 = *(const char **)(*v3 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v37,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t v30 = *(void *)(v10 - 8);
  uint64_t v31 = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v30 - v12;
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v14);
  uint64_t v20 = (char *)&v30 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v33 = v22;
  uint64_t v34 = (char *)&v30 - v21;
  (*(void (**)(char *, uint64_t, uint64_t))(v22 + 16))(v16, (uint64_t)v3 + *(void *)(v5 + 360), v6);
  swift_getObjectType(a1);
  uint64_t v23 = *(void (**)(unint64_t))(v36 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v37,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v23(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v17 + 48))(v13, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v30 + 8))(v13, v31);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x30DuLL,  0);
  }

  uint64_t v24 = *(void (**)(char *, char *, unint64_t))(v17 + 32);
  v24(v20, v13, AssociatedTypeWitness);
  uint64_t v25 = v34;
  (*((void (**)(char *, uint64_t, uint64_t))v37 + 17))(v20, v35, v6);
  (*(void (**)(char *, unint64_t))(v17 + 8))(v20, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v16, v6);
  uint64_t v27 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v26);
  uint64_t v28 = (char *)swift_allocObject(v27, *(unsigned int *)(v27 + 48), *(unsigned __int16 *)(v27 + 52));
  v24(&v28[*(void *)(*(void *)v28 + 96LL)], v25, AssociatedTypeWitness);
  return v28;
}

char *_CollectionBox._index(_:offsetBy:limitedBy:)( unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v64 = a4;
  uint64_t v65 = a5;
  uint64_t v63 = a3;
  uint64_t v69 = a2;
  uint64_t v7 = *v5;
  uint64_t v8 = *(void *)(*v5 + 344);
  uint64_t v9 = *(const char **)(*v5 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v68 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v56 = (char *)&v55 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v61 = (char *)&v55 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v70 = (char *)&v55 - v16;
  uint64_t v17 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v55 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v66 = *(void *)(v22 - 8);
  uint64_t v67 = v22;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v60 = (char *)&v55 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v55 - v26;
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v30 = (char *)&v55 - v29;
  MEMORY[0x1895F8858](v28);
  uint64_t v58 = (char *)&v55 - v31;
  uint64_t v59 = v17;
  uint64_t v32 = (uint64_t)v5 + *(void *)(v7 + 360);
  uint64_t v33 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 16);
  uint64_t v57 = v19;
  v33(v19, v32, v8);
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v35 = v69;
  uint64_t v36 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(v69 + 16);
  uint64_t v62 = v9;
  uint64_t v37 = (uint64_t)v9;
  uint64_t v38 = v68;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v37,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v36(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, v35);
  uint64_t v40 = (unsigned int (*)(char *, uint64_t, unint64_t))v38[6];
  if (v40(v30, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v66 + 8))(v30, v67);
    goto LABEL_9;
  }

  unint64_t v41 = (void (*)(char *, char *, unint64_t))v38[4];
  v41(v70, v30, AssociatedTypeWitness);
  unint64_t v42 = swift_getObjectType(v64);
  uint64_t v43 = *(void (**)(unint64_t, unint64_t, unint64_t))(v65 + 16);
  uint64_t v69 = AssociatedConformanceWitness;
  v43(AssociatedTypeWitness, AssociatedConformanceWitness, v42);
  if (v40(v27, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v66 + 8))(v27, v67);
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x316uLL,  0);
  }

  unint64_t v44 = v61;
  v41(v61, v27, AssociatedTypeWitness);
  uint64_t v45 = v57;
  uint64_t v46 = v58;
  uint64_t v47 = v70;
  (*((void (**)(char *, uint64_t, char *, uint64_t))v62 + 18))(v70, v63, v44, v8);
  Swift::Int v48 = (void (*)(char *, unint64_t))v38[1];
  v48(v44, AssociatedTypeWitness);
  v48(v47, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v59 + 8))(v45, v8);
  uint64_t v49 = v60;
  (*(void (**)(char *, char *, uint64_t))(v66 + 32))(v60, v46, v67);
  if (v40(v49, 1LL, AssociatedTypeWitness) == 1) {
    return 0LL;
  }
  unint64_t v51 = v56;
  v41(v56, v49, AssociatedTypeWitness);
  uint64_t v53 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, v69, v52);
  uint64_t v50 = (char *)swift_allocObject(v53, *(unsigned int *)(v53 + 48), *(unsigned __int16 *)(v53 + 52));
  v41(&v50[*(void *)(*(void *)v50 + 96LL)], v51, AssociatedTypeWitness);
  return v50;
}

uint64_t _CollectionBox._formIndex(_:offsetBy:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v23 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 344);
  uint64_t v6 = *(void *)(*v2 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v24 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v23 - v9;
  uint64_t v11 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *a1;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = swift_dynamicCastClass(v14, v17);
  if (!v18) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x321uLL,  0);
  }
  uint64_t v19 = v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, (uint64_t)v2 + *(void *)(v4 + 360), v5);
  uint64_t v20 = v19 + *(void *)(*(void *)v19 + 96LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 136))(v20, v23, v5, v6);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v5);
  uint64_t v21 = v24;
  (*(void (**)(uint64_t, unint64_t))(v24 + 8))(v20, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v21 + 32))(v20, v10, AssociatedTypeWitness);
}

BOOL _CollectionBox._formIndex(_:offsetBy:limitedBy:)( uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v45 = a3;
  uint64_t v46 = a4;
  uint64_t v42 = a2;
  uint64_t v6 = *v4;
  uint64_t v8 = *(void *)(*v4 + 344);
  uint64_t v7 = *(const char **)(*v4 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v39 = *(void *)(v12 - 8);
  uint64_t v40 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v44 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t v18 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  unint64_t v41 = (char *)&v38 - v20;
  uint64_t v47 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v38 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = *a1;
  uint64_t v43 = v7;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v26 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v27 = swift_dynamicCastClass(v23, v26);
  if (!v27) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x32BuLL,  0);
  }
  uint64_t v28 = v27;
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))(v22, (uint64_t)v4 + *(void *)(v6 + 360), v8);
  unint64_t ObjectType = swift_getObjectType(v45);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v46 + 16))( AssociatedTypeWitness,  AssociatedConformanceWitness,  ObjectType);
  uint64_t v30 = (unsigned int (*)(char *, uint64_t, unint64_t))v18[6];
  if (v30(v17, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v17, v40);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x329uLL,  0);
  }

  uint64_t v31 = (void (*)(void))v18[4];
  uint64_t v32 = v41;
  v31();
  uint64_t v33 = v28 + *(void *)(*(void *)v28 + 96LL);
  uint64_t v34 = v44;
  (*((void (**)(uint64_t, uint64_t, char *, uint64_t))v43 + 18))(v33, v42, v32, v8);
  (*(void (**)(char *, uint64_t))(v47 + 8))(v22, v8);
  uint64_t v35 = (void (*)(uint64_t, unint64_t))v18[1];
  v35(v33, AssociatedTypeWitness);
  unsigned int v36 = v30(v34, 1LL, AssociatedTypeWitness);
  if (v36 == 1)
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v34, v40);
    uint64_t v34 = v32;
  }

  else
  {
    v35((uint64_t)v32, AssociatedTypeWitness);
  }

  ((void (*)(uint64_t, char *, unint64_t))v31)(v33, v34, AssociatedTypeWitness);
  return v36 != 1;
}

uint64_t _CollectionBox._distance(from:to:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v49 = a3;
  uint64_t v50 = a4;
  uint64_t v7 = *v4;
  uint64_t v9 = *(void *)(*v4 + 344);
  uint64_t v8 = *(const char **)(*v4 + 352);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v41 = *(void *)(v13 - 8);
  uint64_t v42 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  Swift::Int v48 = (char *)&v40 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t v19 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v16);
  unint64_t v45 = (char *)&v40 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v47 = (char *)&v40 - v23;
  MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v40 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = (uint64_t)v4 + *(void *)(v7 + 360);
  uint64_t v44 = v27;
  (*(void (**)(char *, uint64_t, uint64_t))(v27 + 16))(v25, v26, v9);
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v29 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t v46 = v8;
  uint64_t v43 = v9;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v29(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v51 = v19;
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v19 + 48);
  if (v31(v18, 1LL, AssociatedTypeWitness) == 1
    || (uint64_t v32 = *(void (**)(char *, char *, unint64_t))(v51 + 32),
        uint64_t v33 = v47,
        v32(v47, v18, AssociatedTypeWitness),
        unint64_t v34 = swift_getObjectType(v49),
        uint64_t v18 = v48,
        (*(void (**)(unint64_t, unint64_t, unint64_t))(v50 + 16))( AssociatedTypeWitness,  AssociatedConformanceWitness,  v34),  v31(v18, 1LL, AssociatedTypeWitness) == 1))
  {
    (*(void (**)(char *, uint64_t))(v41 + 8))(v18, v42);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x333uLL,  0);
  }

  uint64_t v35 = v45;
  v32(v45, v18, AssociatedTypeWitness);
  uint64_t v36 = v43;
  uint64_t v37 = (*((uint64_t (**)(char *, char *, uint64_t))v46 + 19))(v33, v35, v43);
  uint64_t v38 = *(void (**)(char *, unint64_t))(v51 + 8);
  v38(v35, AssociatedTypeWitness);
  v38(v33, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v25, v36);
  return v37;
}

uint64_t _CollectionBox._count.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 344);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 360), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(v2 + 352) + 112LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

uint64_t _CollectionBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 344LL) - 8LL) + 16LL))( a1,  v1 + *(void *)(*(void *)v1 + 360LL));
}

uint64_t _CollectionBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 344LL) - 8LL) + 40LL))( v1 + *(void *)(*(void *)v1 + 360LL),  a1);
}

uint64_t (*_CollectionBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _CollectionBox.__allocating_init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _CollectionBox.init(_startIndex:endIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

char *_BidirectionalCollectionBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(v2 + 376) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 384), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject(v14, *(unsigned int *)(v14 + 48), *(unsigned __int16 *)(v14 + 52));
  (*(void (**)(char *, char *, unint64_t))(v9 + 32))( &v15[*(void *)(*(void *)v15 + 120LL)],  v11,  AssociatedTypeWitness);
  return v15;
}

uint64_t _BidirectionalCollectionBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 384), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(v2 + 376) + 8LL) + 8LL) + 40LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_BidirectionalCollectionBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 368);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = &v14[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v9 + 16))(v11, (uint64_t)v3 + *(void *)(v7 + 384), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 376);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm( (void (*)(char *, void *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error),  (uint64_t)v14,  v8,  a3,  *(void *)(v17 + 8));
  (*(void (**)(_BYTE *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_BidirectionalCollectionBox._filter(_:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 368);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))( (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v2 + *(void *)(v5 + 384),  v6);
  return Sequence.filter(_:)(a1, a2, v6, *(void *)(*(void *)(*(void *)(v5 + 376) + 8LL) + 8LL));
}

uint64_t _BidirectionalCollectionBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 368);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, (uint64_t)v2 + *(void *)(v5 + 384), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(const char **)(*(void *)(*(void *)(v5 + 376) + 8LL) + 8LL));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t _BidirectionalCollectionBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 384), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)(v3 + 376) + 8LL) + 8LL) + 48LL))( a1,  v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _BidirectionalCollectionBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))( (char *)&v7 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v1 + *(void *)(v2 + 384),  v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(v2 + 376) + 8LL) + 8LL) + 56LL))(v3);
}

char *_BidirectionalCollectionBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(v3 + 376) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 384), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject(v15, *(unsigned int *)(v15 + 48), *(unsigned __int16 *)(v15 + 52));
  (*(void (**)(char *, char *, unint64_t))(v10 + 32))( &v16[*(void *)(*(void *)v16 + 120LL)],  v12,  AssociatedTypeWitness);
  return v16;
}

char *_BidirectionalCollectionBox._drop(while:)(uint64_t a1, uint64_t a2)
{
  return _BidirectionalCollectionBox._drop(while:)( a1,  a2,  (void (*)(uint64_t, uint64_t, uint64_t, const char *))Collection.drop(while:));
}

char *_BidirectionalCollectionBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_allocObject(v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  uint64_t v4 = specialized _BidirectionalCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 368) - 8LL) + 8LL))(a1);
  return v4;
}

char *_BidirectionalCollectionBox._dropFirst(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropFirst(_:)( a1,  (void (*)(uint64_t, uint64_t, const char *))Collection.dropFirst(_:));
}

char *_BidirectionalCollectionBox._dropLast(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropLast(_:)( a1,  (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.dropLast(_:));
}

char *_BidirectionalCollectionBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _BidirectionalCollectionBox._drop(while:)( a1,  a2,  (void (*)(uint64_t, uint64_t, uint64_t, const char *))Collection.prefix(while:));
}

char *_BidirectionalCollectionBox._drop(while:)( uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, uint64_t, const char *))
{
  uint64_t v24 = a3;
  uint64_t v22 = a2;
  uint64_t v4 = v3;
  uint64_t v21 = a1;
  uint64_t v5 = *v3;
  uint64_t v6 = *(void *)(*v3 + 368);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v5 + 376);
  uint64_t v11 = *(const char **)(v10 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v11,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v20 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v20 - v13;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, (uint64_t)v4 + *(void *)(v5 + 384), v6);
  uint64_t v15 = v23;
  v24(v21, v22, v6, v11);
  if (!v15)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v10,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
    uint64_t v18 = type metadata accessor for _BidirectionalCollectionBox( 0LL,  AssociatedTypeWitness,  AssociatedConformanceWitness,  v17);
    swift_allocObject(v18, *(unsigned int *)(v18 + 48), *(unsigned __int16 *)(v18 + 52));
    uint64_t v9 = specialized _BidirectionalCollectionBox.init(_base:)((uint64_t)v14);
    (*(void (**)(char *, unint64_t))(v20 + 8))(v14, AssociatedTypeWitness);
  }

  return v9;
}

char *_BidirectionalCollectionBox._prefix(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropFirst(_:)( a1,  (void (*)(uint64_t, uint64_t, const char *))Collection.prefix(_:));
}

char *_BidirectionalCollectionBox._dropFirst(_:)( uint64_t a1, void (*a2)(uint64_t, uint64_t, const char *))
{
  uint64_t v19 = a1;
  uint64_t v20 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v3 + 376);
  uint64_t v9 = *(const char **)(v8 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 384), v4);
  v20(v19, v4, v9);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
  uint64_t v16 = type metadata accessor for _BidirectionalCollectionBox( 0LL,  AssociatedTypeWitness,  AssociatedConformanceWitness,  v15);
  swift_allocObject(v16, *(unsigned int *)(v16 + 48), *(unsigned __int16 *)(v16 + 52));
  uint64_t v17 = specialized _BidirectionalCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

char *_BidirectionalCollectionBox._suffix(_:)(uint64_t a1)
{
  return _BidirectionalCollectionBox._dropLast(_:)( a1,  (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.suffix(_:));
}

char *_BidirectionalCollectionBox._dropLast(_:)( uint64_t a1, void (*a2)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v20 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 368);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v4 + 376);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v9 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, (uint64_t)v2 + *(void *)(v4 + 384), v5);
  v20(a1, v5, v9);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
  uint64_t v16 = type metadata accessor for _BidirectionalCollectionBox( 0LL,  AssociatedTypeWitness,  AssociatedConformanceWitness,  v15);
  swift_allocObject(v16, *(unsigned int *)(v16 + 48), *(unsigned __int16 *)(v16 + 52));
  uint64_t v17 = specialized _BidirectionalCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

uint64_t _BidirectionalCollectionBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 368LL) - 8LL) + 8LL))(v0 + *(void *)(*(void *)v0 + 384LL));
}

id *_BidirectionalCollectionBox.deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[46] - 8LL) + 8LL))((char *)v0 + *((void *)*v0 + 48));
  return v0;
}

void _BidirectionalCollectionBox.__deallocating_deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[46] - 8LL) + 8LL))((char *)v0 + *((void *)*v0 + 48));
  swift_deallocClassInstance((uint64_t)v0);
}

char *_BidirectionalCollectionBox.init(_base:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = specialized _BidirectionalCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v3 + 368) - 8LL) + 8LL))(a1);
  return v4;
}

uint64_t _BidirectionalCollectionBox._unbox(_:file:line:)@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v25 = a6;
  uint64_t v26 = a3;
  int v28 = a5;
  uint64_t v27 = a4;
  uint64_t v29 = a7;
  uint64_t v10 = *v7;
  uint64_t v11 = *(void *)(*v7 + 368);
  uint64_t v12 = *(const char **)(*(void *)(v10 + 376) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v12,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v24 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v14, v15);
  uint64_t v16 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v18 = (char *)&v24 - v17;
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v12,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v20(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v22 + 48))(v18, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v24);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  v26,  v27,  v28,  v25,  0);
  }

  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v22 + 32))(v29, v18, AssociatedTypeWitness);
}

uint64_t _BidirectionalCollectionBox.subscript.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = a3;
  uint64_t v6 = *(void *)(*(void *)v3 + 368LL);
  uint64_t v7 = *(void *)(*(void *)(*(void *)v3 + 376LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v38 = *(void *)(v11 - 8);
  uint64_t v39 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v38 - v13;
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v12);
  uint64_t v18 = (char *)&v38 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v41 = (char *)&v38 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v38 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = v23;
  uint64_t v24 = *(void (**)(void))(v23 + 16);
  uint64_t v40 = v22;
  v24();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v26 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v28 = ObjectType;
  uint64_t v29 = v15;
  v26(AssociatedTypeWitness, AssociatedConformanceWitness, v28, a2);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v15 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v38 + 8))(v14, v39);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3BEuLL,  0);
  }

  uint64_t v30 = *(void (**)(char *, char *, unint64_t))(v15 + 32);
  v30(v18, v14, AssociatedTypeWitness);
  uint64_t v31 = v41;
  v30(v41, v18, AssociatedTypeWitness);
  uint64_t v32 = v40;
  uint64_t v33 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v7 + 80))( v44,  v31,  v6,  v7);
  uint64_t v35 = v34;
  unint64_t v36 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v36 - 8) + 16LL))(v43, v35, v36);
  v33(v44, 0LL);
  (*(void (**)(char *, unint64_t))(v29 + 8))(v31, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v32, v6);
}

char *_BidirectionalCollectionBox.subscript.getter( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v90 = a3;
  uint64_t v91 = a4;
  unint64_t v92 = a1;
  uint64_t v93 = a2;
  uint64_t v5 = *(void *)(*(void *)v4 + 368LL);
  uint64_t v83 = *(void *)(*(void *)v4 + 376LL);
  uint64_t v6 = *(const char **)(v83 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v85 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v86 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v84 = (char *)&v69 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v9, "lower upper ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  int64_t v73 = (char *)&v69 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  Swift::UInt64 v79 = (char *)&v69 - v12;
  uint64_t v71 = type metadata accessor for Optional(0LL, v9, v13, v14);
  uint64_t v70 = *(void *)(v71 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v71);
  uint64_t v17 = (char *)&v69 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v69 - v19;
  uint64_t v21 = *(void **)(v9 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v18);
  unint64_t v89 = (char *)&v69 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v88 = (char *)&v69 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v87 = (char *)&v69 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v69 - v28;
  uint64_t v81 = v6;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v5,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = type metadata accessor for Range(0LL, v9, AssociatedConformanceWitness, v31);
  uint64_t v77 = *(void *)(v32 - 8);
  uint64_t v78 = v32;
  uint64_t v33 = MEMORY[0x1895F8858](v32);
  uint64_t v72 = (char *)&v69 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  Swift::UInt32 v75 = (char *)&v69 - v36;
  MEMORY[0x1895F8858](v35);
  uint64_t v38 = (char *)&v69 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v76 = v39;
  uint64_t v40 = *(void (**)(void))(v39 + 16);
  uint64_t v74 = v38;
  uint64_t v82 = v5;
  v40();
  unint64_t ObjectType = swift_getObjectType(v92);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v93 + 16))( v9,  AssociatedConformanceWitness,  ObjectType);
  uint64_t v42 = (unsigned int (*)(char *, uint64_t, unint64_t))v21[6];
  if (v42(v20, 1LL, v9) == 1)
  {
    (*(void (**)(char *, uint64_t))(v70 + 8))(v20, v71);
    goto LABEL_8;
  }

  uint64_t v43 = (void (*)(char *, char *, unint64_t))v21[4];
  v43(v29, v20, v9);
  unint64_t v44 = swift_getObjectType(v90);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v91 + 16))( v9,  AssociatedConformanceWitness,  v44);
  if (v42(v17, 1LL, v9) == 1)
  {
    (*(void (**)(char *, uint64_t))(v70 + 8))(v17, v71);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3C7uLL,  0);
  }

  unint64_t v45 = v87;
  v43(v87, v17, v9);
  uint64_t v46 = (void (*)(char *, char *, unint64_t))v21[2];
  uint64_t v47 = v88;
  v46(v88, v29, v9);
  Swift::Int v48 = v89;
  v46(v89, v45, v9);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v47,  v48,  v9,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v49 = (void (*)(char *, unint64_t))v21[1];
  v49(v48, v9);
  v49(v47, v9);
  uint64_t v51 = v79;
  uint64_t v50 = TupleTypeMetadata2;
  uint64_t v52 = &v79[*((int *)TupleTypeMetadata2 + 12)];
  v43(v79, v29, v9);
  v43(v52, v45, v9);
  uint64_t v53 = v73;
  uint64_t v54 = &v73[*((int *)v50 + 12)];
  v46(v73, v51, v9);
  v46(v54, v52, v9);
  uint64_t v55 = v72;
  v43(v72, v53, v9);
  v49(v54, v9);
  uint64_t v56 = &v53[*((int *)v50 + 12)];
  v43(v53, v51, v9);
  v43(v56, v52, v9);
  uint64_t v57 = v78;
  v43(&v55[*(int *)(v78 + 36)], v56, v9);
  v49(v53, v9);
  uint64_t v58 = v77;
  uint64_t v59 = v75;
  (*(void (**)(char *, char *, uint64_t))(v77 + 32))(v75, v55, v57);
  uint64_t v60 = v82;
  uint64_t v61 = (uint64_t)v84;
  uint64_t v62 = v74;
  (*((void (**)(char *, uint64_t))v81 + 11))(v59, v82);
  (*(void (**)(char *, uint64_t))(v58 + 8))(v59, v57);
  (*(void (**)(char *, uint64_t))(v76 + 8))(v62, v60);
  uint64_t v63 = v86;
  unint64_t v64 = swift_getAssociatedConformanceWitness( v83,  v60,  v86,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
  uint64_t v66 = type metadata accessor for _BidirectionalCollectionBox(0LL, v63, v64, v65);
  swift_allocObject(v66, *(unsigned int *)(v66 + 48), *(unsigned __int16 *)(v66 + 52));
  uint64_t v67 = specialized _BidirectionalCollectionBox.init(_base:)(v61);
  (*(void (**)(uint64_t, uint64_t))(v85 + 8))(v61, v63);
  return v67;
}

char *_BidirectionalCollectionBox._index(after:)(unint64_t a1, uint64_t a2)
{
  uint64_t v35 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 368);
  uint64_t v36 = *(const char **)(*(void *)(*v2 + 376) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v36,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v30 = *(void *)(v9 - 8);
  uint64_t v31 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v29 - v11;
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v13);
  uint64_t v19 = (char *)&v29 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v33 = v21;
  uint64_t v34 = (char *)&v29 - v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v15, (uint64_t)v2 + *(void *)(v4 + 384), v5);
  swift_getObjectType(a1);
  uint64_t v22 = *(void (**)(unint64_t))(v35 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v36,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v22(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v16 + 48))(v12, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v30 + 8))(v12, v31);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3CDuLL,  0);
  }

  uint64_t v23 = *(void (**)(char *, char *, unint64_t))(v16 + 32);
  v23(v19, v12, AssociatedTypeWitness);
  uint64_t v24 = v34;
  (*((void (**)(char *, uint64_t))v36 + 23))(v19, v5);
  (*(void (**)(char *, unint64_t))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v15, v5);
  uint64_t v26 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v27 = (char *)swift_allocObject(v26, *(unsigned int *)(v26 + 48), *(unsigned __int16 *)(v26 + 52));
  v23(&v27[*(void *)(*(void *)v27 + 96LL)], v24, AssociatedTypeWitness);
  return v27;
}

uint64_t _BidirectionalCollectionBox._formIndex(after:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v16 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(v3 + 376) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v8,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v13 = swift_dynamicCastClass(a1, v12);
  if (!v13) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3D5uLL,  0);
  }
  uint64_t v14 = v13;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 384), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 192))(v14 + *(void *)(*(void *)v14 + 96LL), v4, v8);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

char *_BidirectionalCollectionBox._index(_:offsetBy:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 368);
  uint64_t v36 = *(void *)(*v3 + 376);
  uint64_t v37 = a3;
  unint64_t AssociatedConformanceWitness = *(const char **)(v36 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  AssociatedConformanceWitness,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v32 = *(void *)(v11 - 8);
  uint64_t v33 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v21 = (char *)&v31 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v34 = v23;
  uint64_t v35 = (char *)&v31 - v22;
  (*(void (**)(char *, uint64_t, uint64_t))(v23 + 16))(v17, (uint64_t)v3 + *(void *)(v6 + 384), v7);
  swift_getObjectType(a1);
  uint64_t v24 = *(void (**)(unint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = (const char *)swift_getAssociatedConformanceWitness( (uint64_t)AssociatedConformanceWitness,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v24(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v32 + 8))(v14, v33);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3DCuLL,  0);
  }

  uint64_t v25 = *(void (**)(char *, char *, unint64_t))(v18 + 32);
  v25(v21, v14, AssociatedTypeWitness);
  uint64_t v26 = v35;
  (*(void (**)(char *, uint64_t, uint64_t))(v36 + 48))(v21, v37, v7);
  (*(void (**)(char *, unint64_t))(v18 + 8))(v21, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v34 + 8))(v17, v7);
  uint64_t v28 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, (uint64_t)AssociatedConformanceWitness, v27);
  uint64_t v29 = (char *)swift_allocObject(v28, *(unsigned int *)(v28 + 48), *(unsigned __int16 *)(v28 + 52));
  v25(&v29[*(void *)(*(void *)v29 + 96LL)], v26, AssociatedTypeWitness);
  return v29;
}

char *_BidirectionalCollectionBox._index(_:offsetBy:limitedBy:)( unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v62 = a4;
  uint64_t v63 = a5;
  uint64_t v7 = *v5;
  uint64_t v8 = *(void *)(*v5 + 368);
  uint64_t v60 = *(void *)(*v5 + 376);
  uint64_t v61 = a3;
  uint64_t v66 = *(const char **)(v60 + 8);
  unint64_t v67 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v66,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v59 = (char *)&v53 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v68 = (char *)&v53 - v16;
  uint64_t v17 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v64 = *(void *)(v22 - 8);
  uint64_t v65 = v22;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v58 = (char *)&v53 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v53 - v26;
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v30 = (char *)&v53 - v29;
  MEMORY[0x1895F8858](v28);
  uint64_t v56 = (char *)&v53 - v31;
  uint64_t v57 = v17;
  uint64_t v32 = (uint64_t)v5 + *(void *)(v7 + 384);
  uint64_t v33 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 16);
  uint64_t v55 = v19;
  v33(v19, v32, v8);
  unint64_t ObjectType = swift_getObjectType(v67);
  uint64_t v35 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v66,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v35(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v37 = v10;
  uint64_t v38 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v10 + 48);
  if (v38(v30, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v64 + 8))(v30, v65);
    goto LABEL_9;
  }

  uint64_t v39 = *(void (**)(char *, char *, unint64_t))(v10 + 32);
  v39(v68, v30, AssociatedTypeWitness);
  unint64_t v40 = swift_getObjectType(v62);
  uint64_t v41 = *(void (**)(unint64_t, unint64_t, unint64_t))(v63 + 16);
  unint64_t v67 = AssociatedConformanceWitness;
  v41(AssociatedTypeWitness, AssociatedConformanceWitness, v40);
  if (v38(v27, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v64 + 8))(v27, v65);
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3E5uLL,  0);
  }

  uint64_t v42 = v59;
  v39(v59, v27, AssociatedTypeWitness);
  uint64_t v43 = v55;
  unint64_t v44 = v56;
  unint64_t v45 = v68;
  (*(void (**)(char *, uint64_t, char *, uint64_t))(v60 + 56))(v68, v61, v42, v8);
  uint64_t v46 = *(void (**)(char *, unint64_t))(v37 + 8);
  v46(v42, AssociatedTypeWitness);
  v46(v45, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v57 + 8))(v43, v8);
  uint64_t v47 = v58;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v58, v44, v65);
  if (v38(v47, 1LL, AssociatedTypeWitness) == 1) {
    return 0LL;
  }
  unint64_t v49 = v54;
  v39(v54, v47, AssociatedTypeWitness);
  uint64_t v51 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, v67, v50);
  Swift::Int v48 = (char *)swift_allocObject(v51, *(unsigned int *)(v51 + 48), *(unsigned __int16 *)(v51 + 52));
  v39(&v48[*(void *)(*(void *)v48 + 96LL)], v49, AssociatedTypeWitness);
  return v48;
}

uint64_t _BidirectionalCollectionBox._formIndex(_:offsetBy:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v23 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 368);
  uint64_t v6 = *(void *)(*(void *)(*v2 + 376) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v24 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v23 - v9;
  uint64_t v11 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *a1;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = swift_dynamicCastClass(v14, v17);
  if (!v18) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3F0uLL,  0);
  }
  uint64_t v19 = v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, (uint64_t)v2 + *(void *)(v4 + 384), v5);
  uint64_t v20 = v19 + *(void *)(*(void *)v19 + 96LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 136))(v20, v23, v5, v6);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v5);
  uint64_t v21 = v24;
  (*(void (**)(uint64_t, unint64_t))(v24 + 8))(v20, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v21 + 32))(v20, v10, AssociatedTypeWitness);
}

BOOL _BidirectionalCollectionBox._formIndex(_:offsetBy:limitedBy:)( uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v45 = a3;
  uint64_t v46 = a4;
  uint64_t v43 = a2;
  uint64_t v6 = *v4;
  uint64_t v7 = *(void *)(*v4 + 368);
  uint64_t v8 = *(const char **)(*(void *)(*v4 + 376) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v39 = *(void *)(v12 - 8);
  uint64_t v40 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v44 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t v18 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v41 = (char *)&v38 - v20;
  uint64_t v47 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v38 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = *a1;
  uint64_t v42 = v8;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v26 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v27 = swift_dynamicCastClass(v23, v26);
  if (!v27) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3FAuLL,  0);
  }
  uint64_t v28 = v27;
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))(v22, (uint64_t)v4 + *(void *)(v6 + 384), v7);
  unint64_t ObjectType = swift_getObjectType(v45);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v46 + 16))( AssociatedTypeWitness,  AssociatedConformanceWitness,  ObjectType);
  uint64_t v30 = (unsigned int (*)(char *, uint64_t, unint64_t))v18[6];
  if (v30(v17, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v17, v40);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x3F8uLL,  0);
  }

  uint64_t v31 = (void (*)(void))v18[4];
  uint64_t v32 = v41;
  v31();
  uint64_t v33 = v28 + *(void *)(*(void *)v28 + 96LL);
  uint64_t v34 = v44;
  (*((void (**)(uint64_t, uint64_t, char *, uint64_t))v42 + 18))(v33, v43, v32, v7);
  (*(void (**)(char *, uint64_t))(v47 + 8))(v22, v7);
  uint64_t v35 = (void (*)(uint64_t, unint64_t))v18[1];
  v35(v33, AssociatedTypeWitness);
  unsigned int v36 = v30(v34, 1LL, AssociatedTypeWitness);
  if (v36 == 1)
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v34, v40);
    uint64_t v34 = v32;
  }

  else
  {
    v35((uint64_t)v32, AssociatedTypeWitness);
  }

  ((void (*)(uint64_t, char *, unint64_t))v31)(v33, v34, AssociatedTypeWitness);
  return v36 != 1;
}

uint64_t _BidirectionalCollectionBox._distance(from:to:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v46 = a3;
  uint64_t v47 = a4;
  uint64_t v7 = *v4;
  uint64_t v8 = *(void *)(*v4 + 368);
  uint64_t v44 = *(void *)(*v4 + 376);
  Swift::Int v48 = *(const char **)(v44 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v48,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v39 = *(void *)(v12 - 8);
  uint64_t v40 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v45 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v43 = (char *)&v39 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v39 - v22;
  MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v39 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = (uint64_t)v4 + *(void *)(v7 + 384);
  uint64_t v42 = v27;
  (*(void (**)(char *, uint64_t, uint64_t))(v27 + 16))(v25, v26, v8);
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v29 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t v41 = v8;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v48,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v29(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  Swift::Int v48 = (const char *)v18;
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48);
  if (v31(v17, 1LL, AssociatedTypeWitness) == 1
    || (uint64_t v32 = (void (*)(char *, char *, unint64_t))*((void *)v48 + 4),
        v32(v23, v17, AssociatedTypeWitness),
        unint64_t v33 = swift_getObjectType(v46),
        uint64_t v17 = v45,
        (*(void (**)(unint64_t, unint64_t, unint64_t))(v47 + 16))( AssociatedTypeWitness,  AssociatedConformanceWitness,  v33),  v31(v17, 1LL, AssociatedTypeWitness) == 1))
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v17, v40);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x402uLL,  0);
  }

  uint64_t v34 = v43;
  v32(v43, v17, AssociatedTypeWitness);
  uint64_t v35 = v41;
  uint64_t v36 = (*(uint64_t (**)(char *, char *, uint64_t))(v44 + 64))(v23, v34, v41);
  uint64_t v37 = (void (*)(char *, unint64_t))*((void *)v48 + 1);
  v37(v34, AssociatedTypeWitness);
  v37(v23, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v42 + 8))(v25, v35);
  return v36;
}

uint64_t _BidirectionalCollectionBox._count.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 368);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 384), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v2 + 376) + 8LL) + 112LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

char *_BidirectionalCollectionBox._index(before:)(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 368);
  uint64_t v7 = *(const char **)(*(void *)(*v2 + 376) + 8LL);
  uint64_t v35 = *(void *)(*v2 + 376);
  unint64_t AssociatedConformanceWitness = (unint64_t)v7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v31 = *(void *)(v11 - 8);
  uint64_t v32 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v21 = (char *)&v31 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v33 = v23;
  uint64_t v34 = (char *)&v31 - v22;
  (*(void (**)(char *, uint64_t, uint64_t))(v23 + 16))(v17, (uint64_t)v2 + *(void *)(v5 + 384), v6);
  swift_getObjectType(a1);
  uint64_t v24 = *(void (**)(unint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( AssociatedConformanceWitness,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v24(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v31 + 8))(v14, v32);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x40CuLL,  0);
  }

  uint64_t v25 = *(void (**)(char *, char *, unint64_t))(v18 + 32);
  v25(v21, v14, AssociatedTypeWitness);
  uint64_t v26 = v34;
  (*(void (**)(char *, uint64_t))(v35 + 32))(v21, v6);
  (*(void (**)(char *, unint64_t))(v18 + 8))(v21, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v17, v6);
  uint64_t v28 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v27);
  uint64_t v29 = (char *)swift_allocObject(v28, *(unsigned int *)(v28 + 48), *(unsigned __int16 *)(v28 + 52));
  v25(&v29[*(void *)(*(void *)v29 + 96LL)], v26, AssociatedTypeWitness);
  return v29;
}

uint64_t _BidirectionalCollectionBox._formIndex(before:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 368);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v3 + 376);
  uint64_t v9 = *(const char **)(v8 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = swift_dynamicCastClass(a1, v13);
  if (!v14) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x414uLL,  0);
  }
  uint64_t v15 = v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 384), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 40))(v15 + *(void *)(*(void *)v15 + 96LL), v4, v8);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

uint64_t _BidirectionalCollectionBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 368LL) - 8LL) + 16LL))( a1,  v1 + *(void *)(*(void *)v1 + 384LL));
}

uint64_t _BidirectionalCollectionBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 368LL) - 8LL) + 40LL))( v1 + *(void *)(*(void *)v1 + 384LL),  a1);
}

uint64_t (*_BidirectionalCollectionBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _BidirectionalCollectionBox.__allocating_init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _BidirectionalCollectionBox.init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

char *_RandomAccessCollectionBox._makeIterator()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(*(void *)(v2 + 384) + 8LL) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 392), v3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v3, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v14 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = (char *)swift_allocObject(v14, *(unsigned int *)(v14 + 48), *(unsigned __int16 *)(v14 + 52));
  (*(void (**)(char *, char *, unint64_t))(v9 + 32))( &v15[*(void *)(*(void *)v15 + 120LL)],  v11,  AssociatedTypeWitness);
  return v15;
}

uint64_t _RandomAccessCollectionBox._underestimatedCount.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 392), v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

__objc2_class **_RandomAccessCollectionBox._map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(void *)(*v3 + 376);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = &v14[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v9 + 16))(v11, (uint64_t)v3 + *(void *)(v7 + 392), v8);
  uint64_t v15 = v8;
  uint64_t v16 = a3;
  uint64_t v17 = *(void *)(v7 + 384);
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm( (void (*)(char *, void *))partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error),  (uint64_t)v14,  v8,  a3,  *(void *)(*(void *)(v17 + 8) + 8LL));
  (*(void (**)(_BYTE *, uint64_t))(v9 + 8))(v11, v8);
  return v12;
}

__objc2_class **_RandomAccessCollectionBox._filter(_:)(uint64_t (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 376);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))( (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v2 + *(void *)(v5 + 392),  v6);
  return Sequence.filter(_:)(a1, a2, v6, *(void *)(*(void *)(*(void *)(*(void *)(v5 + 384) + 8LL) + 8LL) + 8LL));
}

uint64_t _RandomAccessCollectionBox._forEach(_:)(void (*a1)(char *), uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 376);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, (uint64_t)v2 + *(void *)(v5 + 392), v6);
  Sequence.forEach(_:)(a1, a2, v6, *(const char **)(*(void *)(*(void *)(*(void *)(v5 + 384) + 8LL) + 8LL) + 8LL));
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, v6);
}

uint64_t _RandomAccessCollectionBox.__customContainsEquatableElement(_:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 392), v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)(*(void *)(v3 + 384) + 8LL)
                                                                           + 8LL)
                                                               + 8LL)
                                                   + 48LL))( a1,  v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  return v8;
}

uint64_t _RandomAccessCollectionBox.__copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))( (char *)&v7 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL),  (uint64_t)v1 + *(void *)(v2 + 392),  v3);
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(*(void *)(v2 + 384) + 8LL) + 8LL)
                                                        + 8LL)
                                            + 56LL))(v3);
}

char *_RandomAccessCollectionBox.__copyContents(initializing:)(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(*(void *)(v3 + 384) + 8LL) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 392), v4);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 64))(v12, v18, v19, v4, v8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v15 = type metadata accessor for _IteratorBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (char *)swift_allocObject(v15, *(unsigned int *)(v15 + 48), *(unsigned __int16 *)(v15 + 52));
  (*(void (**)(char *, char *, unint64_t))(v10 + 32))( &v16[*(void *)(*(void *)v16 + 120LL)],  v12,  AssociatedTypeWitness);
  return v16;
}

char *_RandomAccessCollectionBox._drop(while:)(uint64_t a1, uint64_t a2)
{
  return _RandomAccessCollectionBox._drop(while:)( a1,  a2,  (void (*)(uint64_t, uint64_t, uint64_t, const char *))Collection.drop(while:));
}

char *_RandomAccessCollectionBox.__allocating_init(_base:)(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_allocObject(v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  uint64_t v4 = specialized _RandomAccessCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 376) - 8LL) + 8LL))(a1);
  return v4;
}

char *_RandomAccessCollectionBox._dropFirst(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropFirst(_:)( a1,  (void (*)(uint64_t, uint64_t, const char *))Collection.dropFirst(_:));
}

char *_RandomAccessCollectionBox._dropLast(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropLast(_:)( a1,  (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.dropLast(_:));
}

char *_RandomAccessCollectionBox._prefix(while:)(uint64_t a1, uint64_t a2)
{
  return _RandomAccessCollectionBox._drop(while:)( a1,  a2,  (void (*)(uint64_t, uint64_t, uint64_t, const char *))Collection.prefix(while:));
}

char *_RandomAccessCollectionBox._drop(while:)( uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, uint64_t, const char *))
{
  uint64_t v24 = a3;
  uint64_t v22 = a2;
  uint64_t v4 = v3;
  uint64_t v21 = a1;
  uint64_t v5 = *v3;
  uint64_t v6 = *(void *)(*v3 + 376);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v5 + 384);
  uint64_t v11 = *(const char **)(*(void *)(v10 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v11,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v20 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v20 - v13;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, (uint64_t)v4 + *(void *)(v5 + 392), v6);
  uint64_t v15 = v23;
  v24(v21, v22, v6, v11);
  if (!v15)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v10,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RandomAccessCollection,  (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
    uint64_t v18 = type metadata accessor for _RandomAccessCollectionBox( 0LL,  AssociatedTypeWitness,  AssociatedConformanceWitness,  v17);
    swift_allocObject(v18, *(unsigned int *)(v18 + 48), *(unsigned __int16 *)(v18 + 52));
    uint64_t v9 = specialized _RandomAccessCollectionBox.init(_base:)((uint64_t)v14);
    (*(void (**)(char *, unint64_t))(v20 + 8))(v14, AssociatedTypeWitness);
  }

  return v9;
}

char *_RandomAccessCollectionBox._prefix(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropFirst(_:)( a1,  (void (*)(uint64_t, uint64_t, const char *))Collection.prefix(_:));
}

char *_RandomAccessCollectionBox._dropFirst(_:)( uint64_t a1, void (*a2)(uint64_t, uint64_t, const char *))
{
  uint64_t v19 = a1;
  uint64_t v20 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v3 + 384);
  uint64_t v9 = *(const char **)(*(void *)(v8 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 392), v4);
  v20(v19, v4, v9);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RandomAccessCollection,  (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
  uint64_t v16 = type metadata accessor for _RandomAccessCollectionBox( 0LL,  AssociatedTypeWitness,  AssociatedConformanceWitness,  v15);
  swift_allocObject(v16, *(unsigned int *)(v16 + 48), *(unsigned __int16 *)(v16 + 52));
  uint64_t v17 = specialized _RandomAccessCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

char *_RandomAccessCollectionBox._suffix(_:)(uint64_t a1)
{
  return _RandomAccessCollectionBox._dropLast(_:)( a1,  (void (*)(uint64_t, uint64_t, uint64_t))BidirectionalCollection.suffix(_:));
}

char *_RandomAccessCollectionBox._dropLast(_:)(uint64_t a1, void (*a2)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v19 = a1;
  uint64_t v20 = a2;
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(*v2 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v3 + 384);
  uint64_t v9 = *(void *)(v8 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v9 + 8),  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v19 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v2 + *(void *)(v3 + 392), v4);
  v20(v19, v4, v9);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RandomAccessCollection,  (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
  uint64_t v16 = type metadata accessor for _RandomAccessCollectionBox( 0LL,  AssociatedTypeWitness,  AssociatedConformanceWitness,  v15);
  swift_allocObject(v16, *(unsigned int *)(v16 + 48), *(unsigned __int16 *)(v16 + 52));
  uint64_t v17 = specialized _RandomAccessCollectionBox.init(_base:)((uint64_t)v13);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  return v17;
}

uint64_t _RandomAccessCollectionBox.__ivar_destroyer()
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)v0 + 376LL) - 8LL) + 8LL))(v0 + *(void *)(*(void *)v0 + 392LL));
}

id *_RandomAccessCollectionBox.deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[47] - 8LL) + 8LL))((char *)v0 + *((void *)*v0 + 49));
  return v0;
}

void _RandomAccessCollectionBox.__deallocating_deinit()
{
  uint64_t v1 = *v0;
  swift_unknownObjectRelease(v0[2]);
  swift_unknownObjectRelease(v0[4]);
  (*(void (**)(char *))(*(void *)(v1[47] - 8LL) + 8LL))((char *)v0 + *((void *)*v0 + 49));
  swift_deallocClassInstance((uint64_t)v0);
}

char *_RandomAccessCollectionBox.init(_base:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = specialized _RandomAccessCollectionBox.init(_base:)(a1);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v3 + 376) - 8LL) + 8LL))(a1);
  return v4;
}

uint64_t _RandomAccessCollectionBox._unbox(_:file:line:)@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v25 = a6;
  uint64_t v26 = a3;
  int v28 = a5;
  uint64_t v27 = a4;
  uint64_t v29 = a7;
  uint64_t v10 = *v7;
  uint64_t v11 = *(void *)(*v7 + 376);
  uint64_t v12 = *(const char **)(*(void *)(*(void *)(v10 + 384) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v12,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v24 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v14, v15);
  uint64_t v16 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v18 = (char *)&v24 - v17;
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v12,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v20(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v22 + 48))(v18, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v24);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  v26,  v27,  v28,  v25,  0);
  }

  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v22 + 32))(v29, v18, AssociatedTypeWitness);
}

uint64_t _RandomAccessCollectionBox.subscript.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = a3;
  uint64_t v6 = *(void *)(*(void *)v3 + 376LL);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(*(void *)v3 + 384LL) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v38 = *(void *)(v11 - 8);
  uint64_t v39 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v38 - v13;
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v12);
  uint64_t v18 = (char *)&v38 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v41 = (char *)&v38 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v38 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = v23;
  uint64_t v24 = *(void (**)(void))(v23 + 16);
  uint64_t v40 = v22;
  v24();
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v26 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v28 = ObjectType;
  uint64_t v29 = v15;
  v26(AssociatedTypeWitness, AssociatedConformanceWitness, v28, a2);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v15 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v38 + 8))(v14, v39);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x49AuLL,  0);
  }

  uint64_t v30 = *(void (**)(char *, char *, unint64_t))(v15 + 32);
  v30(v18, v14, AssociatedTypeWitness);
  uint64_t v31 = v41;
  v30(v41, v18, AssociatedTypeWitness);
  uint64_t v32 = v40;
  uint64_t v33 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v7 + 80))( v44,  v31,  v6,  v7);
  uint64_t v35 = v34;
  unint64_t v36 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v36 - 8) + 16LL))(v43, v35, v36);
  v33(v44, 0LL);
  (*(void (**)(char *, unint64_t))(v29 + 8))(v31, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v32, v6);
}

char *_RandomAccessCollectionBox.subscript.getter( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v90 = a3;
  uint64_t v91 = a4;
  unint64_t v92 = a1;
  uint64_t v93 = a2;
  uint64_t v5 = *(void *)(*(void *)v4 + 376LL);
  uint64_t v83 = *(void *)(*(void *)v4 + 384LL);
  uint64_t v6 = *(const char **)(*(void *)(v83 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v85 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v86 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v84 = (char *)&v69 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v9, "lower upper ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  int64_t v73 = (char *)&v69 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  Swift::UInt64 v79 = (char *)&v69 - v12;
  uint64_t v71 = type metadata accessor for Optional(0LL, v9, v13, v14);
  uint64_t v70 = *(void *)(v71 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v71);
  uint64_t v17 = (char *)&v69 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v69 - v19;
  uint64_t v21 = *(void **)(v9 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v18);
  unint64_t v89 = (char *)&v69 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v88 = (char *)&v69 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v87 = (char *)&v69 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v69 - v28;
  uint64_t v81 = v6;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v5,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = type metadata accessor for Range(0LL, v9, AssociatedConformanceWitness, v31);
  uint64_t v77 = *(void *)(v32 - 8);
  uint64_t v78 = v32;
  uint64_t v33 = MEMORY[0x1895F8858](v32);
  uint64_t v72 = (char *)&v69 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  Swift::UInt32 v75 = (char *)&v69 - v36;
  MEMORY[0x1895F8858](v35);
  uint64_t v38 = (char *)&v69 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v76 = v39;
  uint64_t v40 = *(void (**)(void))(v39 + 16);
  uint64_t v74 = v38;
  uint64_t v82 = v5;
  v40();
  unint64_t ObjectType = swift_getObjectType(v92);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v93 + 16))( v9,  AssociatedConformanceWitness,  ObjectType);
  uint64_t v42 = (unsigned int (*)(char *, uint64_t, unint64_t))v21[6];
  if (v42(v20, 1LL, v9) == 1)
  {
    (*(void (**)(char *, uint64_t))(v70 + 8))(v20, v71);
    goto LABEL_8;
  }

  uint64_t v43 = (void (*)(char *, char *, unint64_t))v21[4];
  v43(v29, v20, v9);
  unint64_t v44 = swift_getObjectType(v90);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v91 + 16))( v9,  AssociatedConformanceWitness,  v44);
  if (v42(v17, 1LL, v9) == 1)
  {
    (*(void (**)(char *, uint64_t))(v70 + 8))(v17, v71);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4A2uLL,  0);
  }

  unint64_t v45 = v87;
  v43(v87, v17, v9);
  unint64_t v46 = (void (*)(char *, char *, unint64_t))v21[2];
  uint64_t v47 = v88;
  v46(v88, v29, v9);
  Swift::Int v48 = v89;
  v46(v89, v45, v9);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v47,  v48,  v9,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v49 = (void (*)(char *, unint64_t))v21[1];
  v49(v48, v9);
  v49(v47, v9);
  uint64_t v51 = v79;
  uint64_t v50 = TupleTypeMetadata2;
  uint64_t v52 = &v79[*((int *)TupleTypeMetadata2 + 12)];
  v43(v79, v29, v9);
  v43(v52, v45, v9);
  uint64_t v53 = v73;
  uint64_t v54 = &v73[*((int *)v50 + 12)];
  v46(v73, v51, v9);
  v46(v54, v52, v9);
  uint64_t v55 = v72;
  v43(v72, v53, v9);
  v49(v54, v9);
  uint64_t v56 = &v53[*((int *)v50 + 12)];
  v43(v53, v51, v9);
  v43(v56, v52, v9);
  uint64_t v57 = v78;
  v43(&v55[*(int *)(v78 + 36)], v56, v9);
  v49(v53, v9);
  uint64_t v58 = v77;
  uint64_t v59 = v75;
  (*(void (**)(char *, char *, uint64_t))(v77 + 32))(v75, v55, v57);
  uint64_t v60 = v82;
  uint64_t v61 = (uint64_t)v84;
  unint64_t v62 = v74;
  (*((void (**)(char *, uint64_t))v81 + 11))(v59, v82);
  (*(void (**)(char *, uint64_t))(v58 + 8))(v59, v57);
  (*(void (**)(char *, uint64_t))(v76 + 8))(v62, v60);
  uint64_t v63 = v86;
  unint64_t v64 = swift_getAssociatedConformanceWitness( v83,  v60,  v86,  (uint64_t)&protocol requirements base descriptor for RandomAccessCollection,  (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection);
  uint64_t v66 = type metadata accessor for _RandomAccessCollectionBox(0LL, v63, v64, v65);
  swift_allocObject(v66, *(unsigned int *)(v66 + 48), *(unsigned __int16 *)(v66 + 52));
  unint64_t v67 = specialized _RandomAccessCollectionBox.init(_base:)(v61);
  (*(void (**)(uint64_t, uint64_t))(v85 + 8))(v61, v63);
  return v67;
}

char *_RandomAccessCollectionBox._index(after:)(unint64_t a1, uint64_t a2)
{
  uint64_t v35 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 376);
  uint64_t v36 = *(const char **)(*(void *)(*(void *)(*v2 + 384) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v36,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v30 = *(void *)(v9 - 8);
  uint64_t v31 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v29 - v11;
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v13);
  uint64_t v19 = (char *)&v29 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v33 = v21;
  uint64_t v34 = (char *)&v29 - v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v15, (uint64_t)v2 + *(void *)(v4 + 392), v5);
  swift_getObjectType(a1);
  uint64_t v22 = *(void (**)(unint64_t))(v35 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v36,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v22(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v16 + 48))(v12, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v30 + 8))(v12, v31);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4A8uLL,  0);
  }

  uint64_t v23 = *(void (**)(char *, char *, unint64_t))(v16 + 32);
  v23(v19, v12, AssociatedTypeWitness);
  uint64_t v24 = v34;
  (*((void (**)(char *, uint64_t))v36 + 23))(v19, v5);
  (*(void (**)(char *, unint64_t))(v16 + 8))(v19, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v15, v5);
  uint64_t v26 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v27 = (char *)swift_allocObject(v26, *(unsigned int *)(v26 + 48), *(unsigned __int16 *)(v26 + 52));
  v23(&v27[*(void *)(*(void *)v27 + 96LL)], v24, AssociatedTypeWitness);
  return v27;
}

uint64_t _RandomAccessCollectionBox._formIndex(after:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v16 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(v3 + 384) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v8,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v13 = swift_dynamicCastClass(a1, v12);
  if (!v13) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4B0uLL,  0);
  }
  uint64_t v14 = v13;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 392), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 192))(v14 + *(void *)(*(void *)v14 + 96LL), v4, v8);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

char *_RandomAccessCollectionBox._index(_:offsetBy:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *v3;
  uint64_t v7 = *(void *)(*v3 + 376);
  uint64_t v36 = *(void *)(*v3 + 384);
  uint64_t v37 = a3;
  unint64_t AssociatedConformanceWitness = *(const char **)(*(void *)(v36 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  AssociatedConformanceWitness,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v32 = *(void *)(v11 - 8);
  uint64_t v33 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v21 = (char *)&v31 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v34 = v23;
  uint64_t v35 = (char *)&v31 - v22;
  (*(void (**)(char *, uint64_t, uint64_t))(v23 + 16))(v17, (uint64_t)v3 + *(void *)(v6 + 392), v7);
  swift_getObjectType(a1);
  uint64_t v24 = *(void (**)(unint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = (const char *)swift_getAssociatedConformanceWitness( (uint64_t)AssociatedConformanceWitness,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v24(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v32 + 8))(v14, v33);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4B7uLL,  0);
  }

  uint64_t v25 = *(void (**)(char *, char *, unint64_t))(v18 + 32);
  v25(v21, v14, AssociatedTypeWitness);
  uint64_t v26 = v35;
  (*(void (**)(char *, uint64_t, uint64_t))(v36 + 32))(v21, v37, v7);
  (*(void (**)(char *, unint64_t))(v18 + 8))(v21, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v34 + 8))(v17, v7);
  uint64_t v28 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, (uint64_t)AssociatedConformanceWitness, v27);
  uint64_t v29 = (char *)swift_allocObject(v28, *(unsigned int *)(v28 + 48), *(unsigned __int16 *)(v28 + 52));
  v25(&v29[*(void *)(*(void *)v29 + 96LL)], v26, AssociatedTypeWitness);
  return v29;
}

char *_RandomAccessCollectionBox._index(_:offsetBy:limitedBy:)( unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v62 = a4;
  uint64_t v63 = a5;
  uint64_t v7 = *v5;
  uint64_t v8 = *(void *)(*v5 + 376);
  uint64_t v60 = *(void *)(*v5 + 384);
  uint64_t v61 = a3;
  uint64_t v66 = *(const char **)(*(void *)(v60 + 8) + 8LL);
  unint64_t v67 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v66,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v59 = (char *)&v53 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v68 = (char *)&v53 - v16;
  uint64_t v17 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v64 = *(void *)(v22 - 8);
  uint64_t v65 = v22;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v58 = (char *)&v53 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v53 - v26;
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v30 = (char *)&v53 - v29;
  MEMORY[0x1895F8858](v28);
  uint64_t v56 = (char *)&v53 - v31;
  uint64_t v57 = v17;
  uint64_t v32 = (uint64_t)v5 + *(void *)(v7 + 392);
  uint64_t v33 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 16);
  uint64_t v55 = v19;
  v33(v19, v32, v8);
  unint64_t ObjectType = swift_getObjectType(v67);
  uint64_t v35 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v66,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v35(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  uint64_t v37 = v10;
  uint64_t v38 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v10 + 48);
  if (v38(v30, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v64 + 8))(v30, v65);
    goto LABEL_9;
  }

  uint64_t v39 = *(void (**)(char *, char *, unint64_t))(v10 + 32);
  v39(v68, v30, AssociatedTypeWitness);
  unint64_t v40 = swift_getObjectType(v62);
  uint64_t v41 = *(void (**)(unint64_t, unint64_t, unint64_t))(v63 + 16);
  unint64_t v67 = AssociatedConformanceWitness;
  v41(AssociatedTypeWitness, AssociatedConformanceWitness, v40);
  if (v38(v27, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v64 + 8))(v27, v65);
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4C0uLL,  0);
  }

  uint64_t v42 = v59;
  v39(v59, v27, AssociatedTypeWitness);
  uint64_t v43 = v55;
  unint64_t v44 = v56;
  unint64_t v45 = v68;
  (*(void (**)(char *, uint64_t, char *, uint64_t))(v60 + 40))(v68, v61, v42, v8);
  unint64_t v46 = *(void (**)(char *, unint64_t))(v37 + 8);
  v46(v42, AssociatedTypeWitness);
  v46(v45, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v57 + 8))(v43, v8);
  uint64_t v47 = v58;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v58, v44, v65);
  if (v38(v47, 1LL, AssociatedTypeWitness) == 1) {
    return 0LL;
  }
  unint64_t v49 = v54;
  v39(v54, v47, AssociatedTypeWitness);
  uint64_t v51 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, v67, v50);
  Swift::Int v48 = (char *)swift_allocObject(v51, *(unsigned int *)(v51 + 48), *(unsigned __int16 *)(v51 + 52));
  v39(&v48[*(void *)(*(void *)v48 + 96LL)], v49, AssociatedTypeWitness);
  return v48;
}

uint64_t _RandomAccessCollectionBox._formIndex(_:offsetBy:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v24 = a2;
  uint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 376);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(*v2 + 384) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v23 - v9;
  uint64_t v11 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v23 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *a1;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = swift_dynamicCastClass(v14, v17);
  if (!v18) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4CBuLL,  0);
  }
  uint64_t v19 = v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, (uint64_t)v2 + *(void *)(v4 + 392), v5);
  uint64_t v20 = v19 + *(void *)(*(void *)v19 + 96LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 136))(v20, v24, v5, v6);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v5);
  uint64_t v21 = v23;
  (*(void (**)(uint64_t, unint64_t))(v23 + 8))(v20, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v21 + 32))(v20, v10, AssociatedTypeWitness);
}

BOOL _RandomAccessCollectionBox._formIndex(_:offsetBy:limitedBy:)( uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v45 = a3;
  uint64_t v46 = a4;
  uint64_t v43 = a2;
  uint64_t v6 = *v4;
  uint64_t v7 = *(void *)(*v4 + 376);
  uint64_t v8 = *(const char **)(*(void *)(*(void *)(*v4 + 384) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v39 = *(void *)(v12 - 8);
  uint64_t v40 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v44 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t v18 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v41 = (char *)&v38 - v20;
  uint64_t v47 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v38 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = *a1;
  uint64_t v42 = v8;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v26 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v27 = swift_dynamicCastClass(v23, v26);
  if (!v27) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4D5uLL,  0);
  }
  uint64_t v28 = v27;
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))(v22, (uint64_t)v4 + *(void *)(v6 + 392), v7);
  unint64_t ObjectType = swift_getObjectType(v45);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v46 + 16))( AssociatedTypeWitness,  AssociatedConformanceWitness,  ObjectType);
  uint64_t v30 = (unsigned int (*)(char *, uint64_t, unint64_t))v18[6];
  if (v30(v17, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v17, v40);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4D3uLL,  0);
  }

  uint64_t v31 = (void (*)(void))v18[4];
  uint64_t v32 = v41;
  v31();
  uint64_t v33 = v28 + *(void *)(*(void *)v28 + 96LL);
  uint64_t v34 = v44;
  (*((void (**)(uint64_t, uint64_t, char *, uint64_t))v42 + 18))(v33, v43, v32, v7);
  (*(void (**)(char *, uint64_t))(v47 + 8))(v22, v7);
  uint64_t v35 = (void (*)(uint64_t, unint64_t))v18[1];
  v35(v33, AssociatedTypeWitness);
  unsigned int v36 = v30(v34, 1LL, AssociatedTypeWitness);
  if (v36 == 1)
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v34, v40);
    uint64_t v34 = v32;
  }

  else
  {
    v35((uint64_t)v32, AssociatedTypeWitness);
  }

  ((void (*)(uint64_t, char *, unint64_t))v31)(v33, v34, AssociatedTypeWitness);
  return v36 != 1;
}

uint64_t _RandomAccessCollectionBox._distance(from:to:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v46 = a3;
  uint64_t v47 = a4;
  uint64_t v7 = *v4;
  uint64_t v8 = *(void *)(*v4 + 376);
  uint64_t v44 = *(void *)(*v4 + 384);
  Swift::Int v48 = *(const char **)(*(void *)(v44 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v48,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v39 = *(void *)(v12 - 8);
  uint64_t v40 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v45 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v43 = (char *)&v39 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v39 - v22;
  MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v39 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = (uint64_t)v4 + *(void *)(v7 + 392);
  uint64_t v42 = v27;
  (*(void (**)(char *, uint64_t, uint64_t))(v27 + 16))(v25, v26, v8);
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v29 = *(void (**)(unint64_t, unint64_t, unint64_t, uint64_t))(a2 + 16);
  uint64_t v41 = v8;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v48,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v29(AssociatedTypeWitness, AssociatedConformanceWitness, ObjectType, a2);
  Swift::Int v48 = (const char *)v18;
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48);
  if (v31(v17, 1LL, AssociatedTypeWitness) == 1
    || (uint64_t v32 = (void (*)(char *, char *, unint64_t))*((void *)v48 + 4),
        v32(v23, v17, AssociatedTypeWitness),
        unint64_t v33 = swift_getObjectType(v46),
        uint64_t v17 = v45,
        (*(void (**)(unint64_t, unint64_t, unint64_t))(v47 + 16))( AssociatedTypeWitness,  AssociatedConformanceWitness,  v33),  v31(v17, 1LL, AssociatedTypeWitness) == 1))
  {
    (*(void (**)(char *, uint64_t))(v39 + 8))(v17, v40);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4DDuLL,  0);
  }

  uint64_t v34 = v43;
  v32(v43, v17, AssociatedTypeWitness);
  uint64_t v35 = v41;
  uint64_t v36 = (*(uint64_t (**)(char *, char *, uint64_t))(v44 + 48))(v23, v34, v41);
  uint64_t v37 = (void (*)(char *, unint64_t))*((void *)v48 + 1);
  v37(v34, AssociatedTypeWitness);
  v37(v23, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v42 + 8))(v25, v35);
  return v36;
}

uint64_t _RandomAccessCollectionBox._count.getter(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 376);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, (uint64_t)v1 + *(void *)(v2 + 392), v3);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(*(void *)(v2 + 384) + 8LL) + 8LL) + 112LL))(v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  return v7;
}

char *_RandomAccessCollectionBox._index(before:)(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 376);
  uint64_t v7 = *(const char **)(*(void *)(*(void *)(*v2 + 384) + 8LL) + 8LL);
  uint64_t v35 = *(void *)(*(void *)(*v2 + 384) + 8LL);
  unint64_t AssociatedConformanceWitness = (unint64_t)v7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v31 = *(void *)(v11 - 8);
  uint64_t v32 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v21 = (char *)&v31 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v33 = v23;
  uint64_t v34 = (char *)&v31 - v22;
  (*(void (**)(char *, uint64_t, uint64_t))(v23 + 16))(v17, (uint64_t)v2 + *(void *)(v5 + 392), v6);
  swift_getObjectType(a1);
  uint64_t v24 = *(void (**)(unint64_t))(a2 + 16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( AssociatedConformanceWitness,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v24(AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v31 + 8))(v14, v32);
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4E7uLL,  0);
  }

  uint64_t v25 = *(void (**)(char *, char *, unint64_t))(v18 + 32);
  v25(v21, v14, AssociatedTypeWitness);
  uint64_t v26 = v34;
  (*(void (**)(char *, uint64_t))(v35 + 32))(v21, v6);
  (*(void (**)(char *, unint64_t))(v18 + 8))(v21, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v17, v6);
  uint64_t v28 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v27);
  uint64_t v29 = (char *)swift_allocObject(v28, *(unsigned int *)(v28 + 48), *(unsigned __int16 *)(v28 + 52));
  v25(&v29[*(void *)(*(void *)v29 + 96LL)], v26, AssociatedTypeWitness);
  return v29;
}

uint64_t _RandomAccessCollectionBox._formIndex(before:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 376);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(v3 + 384) + 8LL);
  uint64_t v9 = *(const char **)(v8 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = swift_dynamicCastClass(a1, v13);
  if (!v14) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B6750LL,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x4EFuLL,  0);
  }
  uint64_t v15 = v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, (uint64_t)v1 + *(void *)(v3 + 392), v4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 40))(v15 + *(void *)(*(void *)v15 + 96LL), v4, v8);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

uint64_t _RandomAccessCollectionBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 376LL) - 8LL) + 16LL))( a1,  v1 + *(void *)(*(void *)v1 + 392LL));
}

uint64_t _RandomAccessCollectionBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 376LL) - 8LL) + 40LL))( v1 + *(void *)(*(void *)v1 + 392LL),  a1);
}

uint64_t (*_RandomAccessCollectionBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _RandomAccessCollectionBox.__allocating_init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _CollectionBox.__allocating_init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, unint64_t a7)
{
}

void _RandomAccessCollectionBox.init(_startIndex:endIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t _ClosureBasedSequence._makeUnderlyingIterator.getter( uint64_t a1, unint64_t *a2, uint64_t a3, char *a4)
{
  return a1;
}

uint64_t _ClosureBasedSequence._makeUnderlyingIterator.setter(uint64_t a1, uint64_t a2)
{
  uint64_t result = swift_release(v2[1]);
  void *v2 = a1;
  v2[1] = a2;
  return result;
}

uint64_t (*_ClosureBasedSequence._makeUnderlyingIterator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _ClosureBasedSequence.makeIterator()(uint64_t (*a1)(void))
{
  return a1();
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _ClosureBasedSequence<A>()
{
  uint64_t v1 = *(void *)(v0 + 8);
  _ClosureBasedSequence.makeIterator()(*(uint64_t (**)(void))v0);
  return swift_release(v1);
}

void *AnySequence.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = type metadata accessor for _ClosureBasedSequence(255LL, a4, a5, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ClosureBasedSequence<A>, v7, v8);
  uint64_t v11 = type metadata accessor for _SequenceBox(0LL, v7, WitnessTable, v10);
  uint64_t result = swift_allocObject(v11, 0x20uLL, 7uLL);
  result[2] = a1;
  result[3] = a2;
  return result;
}

char *AnySequence.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for _SequenceBox(0LL, a3, a4, a4);
  uint64_t v7 = (char *)swift_allocObject(v6, *(unsigned int *)(v6 + 48), *(unsigned __int16 *)(v6 + 52));
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 32LL))( &v7[*(void *)(*(void *)v7 + 224LL)],  a1,  a3);
  return v7;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance AnySequence<A>()
{
  return AnySequence.underestimatedCount.getter(*v0);
}

uint64_t AnySequence.underestimatedCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 104LL))();
}

uint64_t protocol witness for Sequence._customContainsEquatableElement(_:) in conformance AnySequence<A>( uint64_t a1)
{
  return AnySequence._customContainsEquatableElement(_:)(a1, *v1);
}

uint64_t AnySequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)a2 + 136LL))();
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance AnySequence<A>()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized AnySequence._copyToContiguousArray()(*v0);
  swift_release(v1);
  return v2;
}

uint64_t AnySequence._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = specialized AnySequence._copyToContiguousArray()(a1);
  swift_release(a1);
  return v2;
}

void *AnySequence._copyContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = specialized AnyBidirectionalCollection._copyContents(initializing:)(a1, a2, a3, a4);
  swift_release(a3);
  return v5;
}

uint64_t AnySequence.dropLast(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 176LL))();
  swift_release(a2);
  return v3;
}

uint64_t AnySequence.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 192LL))();
  swift_release(a3);
  return v4;
}

uint64_t AnySequence.suffix(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 200LL))();
  swift_release(a2);
  return v3;
}

void *specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)( uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t *))
{
  uint64_t result = (void *)a2(a1, &v7);
  if (v2)
  {
    uint64_t v4 = v7;
    uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
    uint64_t result = swift_allocError(v5, (uint64_t)&protocol self-conformance witness table for Error, 0LL, 0);
    *uint64_t v6 = v4;
  }

  return result;
}

uint64_t AnySequence.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)( a1,  a2,  a3,  a4,  a5,  (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error),  (uint64_t)partial apply for specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1));
}

uint64_t AnySequence.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

{
  uint64_t v4;
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 120LL))();
  swift_release(a3);
  return v4;
}

uint64_t AnySequence.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

{
  (*(void (**)(void))(*(void *)a3 + 128LL))();
  return swift_release(a3);
}

uint64_t AnySequence.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

{
  uint64_t v4;
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 160LL))();
  swift_release(a3);
  return v4;
}

uint64_t AnyCollection.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnyCollection.prefix(while:)(a1, a2, a3);
}

{
  uint64_t v4;
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a3 + 240LL))();
  swift_release(a3);
  return v4;
}

uint64_t AnyCollection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)( a1,  a2,  a3,  a4,  a5,  (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error),  (uint64_t)thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply);
}

uint64_t AnySequence.map<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = a4;
  uint64_t v14 = a5;
  uint64_t v15 = a1;
  uint64_t v16 = a2;
  _OWORD v11[2] = a4;
  v11[3] = a5;
  v11[4] = a6;
  uint64_t v11[5] = &v12;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a3 + 112LL))(a7, v11, a5);
  if (v7)
  {
    uint64_t v17 = v7;
    uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
    swift_willThrowTypedImpl((uint64_t)&v17, v9, (uint64_t)&protocol self-conformance witness table for Error);
  }

  return v8;
}

uint64_t AnyCollection.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

uint64_t AnyCollection.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

uint64_t AnyCollection.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnyCollection.prefix(while:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)( a1,  a2,  a3,  a4,  a5,  (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error),  (uint64_t)thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply);
}

uint64_t AnyBidirectionalCollection.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

uint64_t AnyBidirectionalCollection.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

uint64_t AnyCollection.makeIterator()(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96LL))(a1);
  swift_release(a1);
  return v2;
}

uint64_t AnyCollection.dropLast(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 232LL))();
  swift_release(a2);
  return v3;
}

uint64_t AnyRandomAccessCollection.prefix(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnyCollection.prefix(while:)(a1, a2, a3);
}

uint64_t AnyCollection.suffix(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 248LL))();
  swift_release(a2);
  return v3;
}

uint64_t AnyRandomAccessCollection.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AnySequence.map<A>(_:)( a1,  a2,  a3,  a4,  a5,  (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error),  (uint64_t)thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply);
}

uint64_t AnyRandomAccessCollection.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.filter(_:)(a1, a2, a3);
}

uint64_t AnyRandomAccessCollection.forEach(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.forEach(_:)(a1, a2, a3);
}

uint64_t AnyRandomAccessCollection.drop(while:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return AnySequence.drop(while:)(a1, a2, a3);
}

uint64_t AnySequence.dropFirst(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 168LL))();
  swift_release(a2);
  return v3;
}

uint64_t AnySequence.prefix(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)a2 + 184LL))();
  swift_release(a2);
  return v3;
}

uint64_t (*_IndexBox._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _IndexBox.init(_base:)(uint64_t a1)
{
  return v1;
}

uint64_t _IndexBox._unsafeUnbox(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  if (!swift_dynamicCastClass(a1, *v2)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v5 + 80) - 8LL) + 16LL))( a2,  a1 + *(void *)(*(void *)a1 + 96LL));
}

uint64_t _IndexBox._typeID.getter()
{
  return *(void *)v0;
}

uint64_t _IndexBox._unbox<A>()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v8 = type metadata accessor for _IndexBox(0LL, a1, a2, a3);
  uint64_t v9 = swift_dynamicCastClass(v5, v8);
  uint64_t v10 = *(void *)(a1 - 8);
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 16))(a4, v9 + *(void *)(*(void *)v9 + 96LL), a1);
    uint64_t v11 = 0LL;
  }

  else
  {
    uint64_t v11 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a4, v11, 1LL, a1);
}

uint64_t _IndexBox._isEqual(to:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 80);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v16 - v9;
  uint64_t v11 = (char *)v1 + *(void *)(v3 + 96);
  char v12 = *(void (**)(char *, char *, uint64_t))(v5 + 16);
  v12((char *)&v16 - v9, v11, v4);
  if (!swift_dynamicCastClass(a1, v3)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  v12(v8, (char *)(a1 + *(void *)(*(void *)a1 + 96LL)), v4);
  char v13 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v3 + 88) + 8LL) + 8LL))( v10,  v8,  v4);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v5 + 8);
  v14(v8, v4);
  v14(v10, v4);
  return v13 & 1;
}

uint64_t _IndexBox._isLess(than:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = *(void *)(*v1 + 80);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v16 - v9;
  uint64_t v11 = (char *)v1 + *(void *)(v3 + 96);
  char v12 = *(void (**)(char *, char *, uint64_t))(v5 + 16);
  v12((char *)&v16 - v9, v11, v4);
  if (!swift_dynamicCastClass(a1, v3)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  v12(v8, (char *)(a1 + *(void *)(*(void *)a1 + 96LL)), v4);
  char v13 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v3 + 88) + 16LL))(v10, v8, v4);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v5 + 8);
  v14(v8, v4);
  v14(v10, v4);
  return v13 & 1;
}

uint64_t ManagedBuffer.deinit()
{
  return v0;
}

id AnyIndex._box.getter(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_unknownObjectRetain(a1, a2, a3, a4);
}

void AnyIndex._box.setter(uint64_t a1, uint64_t a2)
{
  *(void *)uint64_t v2 = a1;
  *(void *)(v2 + 8) = a2;
}

uint64_t (*AnyIndex._box.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

char *AnyIndex.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for _IndexBox(0LL, a2, a3, a4);
  uint64_t v7 = (char *)swift_allocObject(v6, *(unsigned int *)(v6 + 48), *(unsigned __int16 *)(v6 + 52));
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))( &v7[*(void *)(*(void *)v7 + 96LL)],  a1,  a2);
  return v7;
}

uint64_t AnyIndex._typeID.getter(unint64_t a1, uint64_t a2)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance AnyIndex(uint64_t a1, uint64_t a2)
{
  return specialized static AnyIndex.< infix(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)a2,  *(void *)(a2 + 8));
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance AnyIndex( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))static AnyIndex.< infix(_:_:));
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void, void))
{
  return (a5(*a2, a2[1], *a1, a1[1]) & 1) == 0;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance AnyIndex( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))static AnyIndex.< infix(_:_:));
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void, void))
{
  return (a5(*a1, a1[1], *a2, a2[1]) & 1) == 0;
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance AnyIndex(uint64_t a1, uint64_t a2)
{
  return specialized static Comparable.> infix(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)a2,  *(void *)(a2 + 8));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance AnyIndex(uint64_t a1, uint64_t a2)
{
  return specialized static AnyIndex.== infix(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)a2,  *(void *)(a2 + 8));
}

uint64_t AnyCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AnyCollection.init<A>(_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _CollectionBox,  (uint64_t (*)(uint64_t))specialized _CollectionBox.init(_base:));
}

{
  return AnyCollection.init<A>(_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _BidirectionalCollectionBox,  (uint64_t (*)(uint64_t))specialized _BidirectionalCollectionBox.init(_base:));
}

{
  return AnyCollection.init<A>(_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _RandomAccessCollectionBox,  (uint64_t (*)(uint64_t))specialized _RandomAccessCollectionBox.init(_base:));
}

id AnyCollection.endIndex.getter(uint64_t a1)
{
  uint64_t v1 = (void *)specialized AnyCollection.endIndex.getter(a1);
  return swift_unknownObjectRetain(v1, v2, v3, v4);
}

uint64_t AnyCollection.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 264LL))();
}

uint64_t AnyCollection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(void *)a4 + 280LL))();
}

id protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>@<X0>( uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void))specialized AnyCollection.startIndex.getter,  a2);
}

id protocol witness for Collection.endIndex.getter in conformance AnyCollection<A>@<X0>( uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void))specialized AnyCollection.endIndex.getter,  a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance AnyCollection<A>( void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = AnyCollection.subscript.read(v7, *a2, a2[1], *v3, *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*AnyCollection.subscript.read( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v8 = *(void *)(a5 - 8);
  *a1 = a5;
  a1[1] = v8;
  a1[2] = malloc(*(void *)(v8 + 64));
  (*(void (**)(uint64_t, uint64_t))(*(void *)a4 + 256LL))(a2, a3);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void, void, void, void))AnyCollection.subscript.getter,  a2);
}

uint64_t protocol witness for Collection.count.getter in conformance AnyCollection<A>()
{
  return AnyCollection.count.getter(*v0);
}

double protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance AnyCollection<A>@<D0>( _OWORD *a1@<X8>)
{
  *(void *)&double result = 1LL;
  *a1 = xmmword_1817FFD30;
  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>( a1,  a2,  AnyCollection.index(_:offsetBy:),  a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, uint64_t, void, void, void))AnyCollection.index(_:offsetBy:limitedBy:),  a4);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance AnyCollection<A>( void *a1, void *a2)
{
  return AnyCollection.distance(from:to:)(*a1, a1[1], *a2, a2[1], *v2);
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>( a1,  AnyCollection.index(after:),  a2);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance AnyCollection<A>(uint64_t a1)
{
  return AnyCollection.formIndex(after:)(a1, *v1);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance AnySequence<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *v4;
  uint64_t v7 = specialized AnyBidirectionalCollection._copyContents(initializing:)(a2, a3, v6, *(void *)(a4 + 16));
  uint64_t v9 = v8;
  swift_release(v6);
  *a1 = v7;
  return v9;
}

uint64_t AnyBidirectionalCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AnyCollection.init<A>(_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _BidirectionalCollectionBox,  (uint64_t (*)(uint64_t))specialized _BidirectionalCollectionBox.init(_base:));
}

{
  return AnyCollection.init<A>(_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _RandomAccessCollectionBox,  (uint64_t (*)(uint64_t))specialized _RandomAccessCollectionBox.init(_base:));
}

uint64_t AnyBidirectionalCollection.init(_:)(uint64_t a1, uint64_t a2)
{
  return AnyBidirectionalCollection.init(_:)( a1,  a2,  (uint64_t (*)(void))type metadata accessor for _AnyBidirectionalCollectionBox);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance AnyBidirectionalCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void, void))AnyBidirectionalCollection.index(before:),  a2);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance AnyBidirectionalCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>( a1,  a2,  (uint64_t (*)(void, void, uint64_t, void))AnyBidirectionalCollection.index(_:offsetBy:),  a3);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance AnyBidirectionalCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, uint64_t, void, void, void))AnyBidirectionalCollection.index(_:offsetBy:limitedBy:),  a4);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, void, uint64_t, void, void, void)@<X5>, uint64_t *a5@<X8>)
{
  uint64_t result = a4(*a1, a1[1], a2, *a3, a3[1], *v5);
  *a5 = result;
  a5[1] = v8;
  return result;
}

id protocol witness for Collection.startIndex.getter in conformance AnyBidirectionalCollection<A>@<X0>( uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void))specialized AnyRandomAccessCollection.startIndex.getter,  a2);
}

id protocol witness for Collection.endIndex.getter in conformance AnyBidirectionalCollection<A>@<X0>( uint64_t a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void))specialized AnyRandomAccessCollection.endIndex.getter,  a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyBidirectionalCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void, void, void, void))AnyBidirectionalCollection.subscript.getter,  a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t (*a2)(void, void, void, void, void)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], a1[2], a1[3], *v3);
  *a3 = result;
  return result;
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyBidirectionalCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void, void))AnyBidirectionalCollection.index(after:),  a2);
}

uint64_t AnyRandomAccessCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AnyCollection.init<A>(_:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for _RandomAccessCollectionBox,  (uint64_t (*)(uint64_t))specialized _RandomAccessCollectionBox.init(_base:));
}

uint64_t AnyCollection.init<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, uint64_t, uint64_t), uint64_t (*a6)(uint64_t))
{
  uint64_t v9 = a5(0LL, a3, a4);
  swift_allocObject(v9, *(unsigned int *)(v9 + 48), *(unsigned __int16 *)(v9 + 52));
  uint64_t v10 = a6(a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  return v10;
}

uint64_t AnyRandomAccessCollection.init(_:)(uint64_t a1, uint64_t a2)
{
  return AnyBidirectionalCollection.init(_:)( a1,  a2,  (uint64_t (*)(void))type metadata accessor for _AnyRandomAccessCollectionBox);
}

{
  return AnyBidirectionalCollection.init(_:)( a1,  a2,  (uint64_t (*)(void))type metadata accessor for _AnyRandomAccessCollectionBox);
}

uint64_t AnyBidirectionalCollection.init(_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v4 = a3(0LL);
  uint64_t result = swift_dynamicCastClass(a1, v4);
  if (!result)
  {
    swift_release(a1);
    return 0LL;
  }

  return result;
}

uint64_t AnyCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(*(void *)a5 + 336LL))();
}

void AnyCollection.formIndex(after:)(unint64_t *a1, uint64_t *a2)
{
  int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*a1);
  uint64_t v8 = (void *)*a1;
  unint64_t v9 = a1[1];
  uint64_t v10 = *a2;
  if (isUniquelyReferenced_nonNull)
  {
    uint64_t v11 = *(void (**)(id, unint64_t))(v10 + 272);
    id v12 = swift_unknownObjectRetain(v8, v5, v6, v7);
    v11(v12, v9);
    swift_unknownObjectRelease(v8);
  }

  else
  {
    uint64_t v13 = (*(uint64_t (**)(unint64_t, unint64_t))(v10 + 264))(*a1, a1[1]);
    unint64_t v15 = v14;
    swift_unknownObjectRelease(v8);
    *a1 = v13;
    a1[1] = v15;
  }

uint64_t AnyCollection.index(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(*(void *)a6 + 288LL))();
}

void AnyCollection.formIndex(_:offsetBy:)(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (swift_isUniquelyReferenced_nonNull(*a1))
  {
    (*(void (**)(unint64_t *, uint64_t))(*(void *)a3 + 296LL))(a1, a2);
  }

  else
  {
    uint64_t v6 = (void *)*a1;
    uint64_t v7 = (*(uint64_t (**)(unint64_t, unint64_t, uint64_t))(*(void *)a3 + 280LL))( *a1,  a1[1],  a2);
    unint64_t v9 = v8;
    swift_unknownObjectRelease(v6);
    *a1 = v7;
    a1[1] = v9;
  }

uint64_t AnyCollection.formIndex(_:offsetBy:limitedBy:)( unint64_t *a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5)
{
  if (swift_isUniquelyReferenced_nonNull(*a1)) {
    return (*(uint64_t (**)(unint64_t *, uint64_t, void *, unint64_t))(*(void *)a5 + 304LL))( a1,  a2,  a3,  a4) & 1;
  }
  uint64_t v11 = (void *)*a1;
  uint64_t v12 = (*(uint64_t (**)(unint64_t, unint64_t, uint64_t, void *, unint64_t))(*(void *)a5 + 288LL))( *a1,  a1[1],  a2,  a3,  a4);
  unint64_t v14 = v13;
  swift_unknownObjectRelease(v11);
  if (v12)
  {
    *a1 = v12;
    a1[1] = v14;
    return 1LL;
  }

  else
  {
    *a1 = (unint64_t)a3;
    a1[1] = a4;
    swift_unknownObjectRetain(a3, v15, v16, v17);
    return 0LL;
  }

uint64_t AnyCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(*(void *)a5 + 312LL))();
}

uint64_t AnyRandomAccessCollection.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 352LL))();
}

void AnyBidirectionalCollection.formIndex(before:)(unint64_t *a1, uint64_t *a2)
{
  int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*a1);
  unint64_t v8 = (void *)*a1;
  unint64_t v9 = a1[1];
  uint64_t v10 = *a2;
  if (isUniquelyReferenced_nonNull)
  {
    uint64_t v11 = *(void (**)(id, unint64_t))(v10 + 360);
    id v12 = swift_unknownObjectRetain(v8, v5, v6, v7);
    v11(v12, v9);
    swift_unknownObjectRelease(v8);
  }

  else
  {
    uint64_t v13 = (*(uint64_t (**)(unint64_t, unint64_t))(v10 + 352))(*a1, a1[1]);
    unint64_t v15 = v14;
    swift_unknownObjectRelease(v8);
    *a1 = v13;
    a1[1] = v15;
  }

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance AnyRandomAccessCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>( a1,  a2,  (uint64_t (*)(void, void, uint64_t, void))AnyRandomAccessCollection.index(_:offsetBy:),  a3);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance AnyRandomAccessCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance AnyCollection<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, uint64_t, void, void, void))AnyRandomAccessCollection.index(_:offsetBy:limitedBy:),  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance AnyRandomAccessCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>( a1,  AnyRandomAccessCollection.index(before:),  a2);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance AnyRandomAccessCollection<A>( uint64_t a1)
{
  return AnyRandomAccessCollection.formIndex(before:)(a1, *v1);
}

id protocol witness for Collection.startIndex.getter in conformance AnyCollection<A>@<X0>( uint64_t a1@<X0>, uint64_t (*a2)(void, void)@<X2>, void *a3@<X8>)
{
  uint64_t v5 = (void *)a2(*v3, *(void *)(a1 + 16));
  *a3 = v5;
  a3[1] = v6;
  return swift_unknownObjectRetain(v5, v6, v7, v8);
}

uint64_t protocol witness for Collection.subscript.getter in conformance AnyRandomAccessCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void, void, void, void))AnyRandomAccessCollection.subscript.getter,  a2);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(void, void, uint64_t, void)@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result = a3(*a1, a1[1], a2, *v4);
  *a4 = result;
  a4[1] = v7;
  return result;
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyRandomAccessCollection<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance AnyCollection<A>( a1,  (uint64_t (*)(void, void, void))AnyRandomAccessCollection.index(after:),  a2);
}

uint64_t protocol witness for Collection.index(after:) in conformance AnyCollection<A>@<X0>( void *a1@<X0>, uint64_t (*a2)(void, void, void)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], *v3);
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance AnySequence<A>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v3 + 96LL))();
  uint64_t result = swift_release(v3);
  *a1 = v4;
  return result;
}

uint64_t (*LazyFilterSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyFilterSequence.init(_base:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return LazyDropWhileSequence.init(_base:predicate:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyFilterSequence,  a6);
}

uint64_t LazyFilterSequence.Iterator.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t LazyFilterSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t LazyFilterSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*LazyFilterSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyFilterSequence.Iterator.init(_base:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a6,  a1,  AssociatedTypeWitness);
  uint64_t result = type metadata accessor for LazyFilterSequence.Iterator(0LL, a4, (uint64_t)a5, v13);
  unint64_t v15 = (void *)(a6 + *(int *)(result + 36));
  *unint64_t v15 = a2;
  v15[1] = a3;
  return result;
}

uint64_t LazyFilterSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v29 = a2;
  uint64_t v30 = a1;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v27 = *(void *)(v9 - 8);
  uint64_t v28 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  id v12 = (char *)&v26 - v11;
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](v10);
  unint64_t v15 = (char *)&v26 - v14;
  unint64_t v16 = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  v16,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v18 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v19 = swift_checkMetadataState(0LL, v16);
  v18(v19, AssociatedConformanceWitness);
  uint64_t v31 = v13;
  uint64_t v20 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v13 + 48);
  if (v20(v12, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_5:
    (*(void (**)(char *, uint64_t))(v27 + 8))(v12, v28);
    uint64_t v23 = 1LL;
    uint64_t v24 = v29;
  }

  else
  {
    uint64_t v21 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
    while (1)
    {
      v21(v15, v12, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v31 + 8))(v15, AssociatedTypeWitness);
      uint64_t v22 = swift_checkMetadataState(0LL, v16);
      v18(v22, AssociatedConformanceWitness);
      if (v20(v12, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_5;
      }
    }

    uint64_t v24 = v29;
    v21(v29, v15, AssociatedTypeWitness);
    uint64_t v23 = 0LL;
  }

  return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v31 + 56))( v24,  v23,  1LL,  AssociatedTypeWitness);
}

__n128 LazyFilterSequence.makeIterator()@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 32))( (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v2,  v6);
  uint64_t v9 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t, uint64_t))(v9 + 32))(v6, v9);
  uint64_t v10 = *(int *)(a1 + 36);
  uint64_t v12 = type metadata accessor for LazyFilterSequence.Iterator(0LL, v6, v9, v11);
  __n128 result = *(__n128 *)(v3 + v10);
  *(__n128 *)(a2 + *(int *)(v12 + 36)) = result;
  return result;
}

uint64_t LazyFilterSequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

uint64_t LazyFilterSequence<>.underestimatedCount.getter()
{
  return 0LL;
}

uint64_t LazyFilterSequence<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v5 = a2;
  uint64_t v8 = *(void *)(a1 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 8),  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v46 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v47 = AssociatedTypeWitness;
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v45 = (char *)&v44 - v11;
  uint64_t v12 = a1;
  uint64_t v13 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v10);
  unint64_t v15 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v17 = *(void *)(v16 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v53 = (char *)&v44 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v52 = (char *)&v44 - v20;
  uint64_t v21 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v58 = a3;
  v21(v8, v5);
  uint64_t v51 = *(void (**)(uint64_t, uint64_t))(v5 + 72);
  uint64_t v57 = v8;
  unint64_t v55 = v16;
  uint64_t v50 = *(void *)(swift_getAssociatedConformanceWitness( v5,  v8,  v16,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v22 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v50 + 8);
  uint64_t v54 = v17;
  Swift::Int v48 = *(void (**)(char *, uint64_t, unint64_t))(v17 + 16);
  unint64_t v49 = v22;
  uint64_t v44 = v4;
  while (1)
  {
    uint64_t v23 = v52;
    unint64_t v24 = v55;
    v48(v52, v58, v55);
    uint64_t v25 = v53;
    v51(v57, v5);
    char v26 = v49(v23, v25, v24, v50);
    uint64_t v27 = *(void (**)(char *, unint64_t))(v54 + 8);
    v27(v25, v24);
    v27(v23, v24);
    (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, v4, v12);
    if ((v26 & 1) != 0) {
      break;
    }
    uint64_t v31 = v12;
    uint64_t v32 = &v15[*(int *)(v12 + 36)];
    uint64_t v33 = (unint64_t *)*((void *)v32 + 1);
    uint64_t v56 = *(uint64_t (**)(char *))v32;
    uint64_t v34 = *(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v5 + 80);
    swift_retain(v33, v28, v29, v30);
    uint64_t v35 = v5;
    uint64_t v36 = v34(v59, v58, v57, v5);
    uint64_t v37 = v13;
    uint64_t v39 = v45;
    uint64_t v38 = v46;
    unint64_t v40 = v47;
    (*(void (**)(char *))(v46 + 16))(v45);
    ((void (*)(_BYTE *, void))v36)(v59, 0LL);
    uint64_t v41 = v37;
    uint64_t v42 = *(void (**)(char *, uint64_t))(v37 + 8);
    uint64_t v12 = v31;
    v42(v15, v31);
    LOBYTE(v36) = v56(v39);
    swift_release((uint64_t)v33);
    uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v38 + 8))(v39, v40);
    if ((v36 & 1) != 0) {
      return result;
    }
    uint64_t v5 = v35;
    uint64_t v4 = v44;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v35 + 192))(v58, v57, v35);
    uint64_t v13 = v41;
  }

  return (*(uint64_t (**)(char *, uint64_t))(v13 + 8))(v15, v12);
}

uint64_t LazyFilterSequence<>.index(after:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, char *a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(char *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a4,  a1,  AssociatedTypeWitness);
  return LazyFilterSequence<>.formIndex(after:)(a4, a2, (uint64_t)a3);
}

uint64_t LazyFilterSequence<>.formIndex(after:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = *(const char **)(a3 + 8);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = a2;
  uint64_t v76 = v7;
  uint64_t v77 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v62 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v63 = AssociatedTypeWitness;
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v61 = (char *)&v59 - v11;
  uint64_t v65 = *(void *)(v8 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v59 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v16 = (char *)&v59 - v15;
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v3,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v59 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v24 = (char *)&v59 - v23;
  MEMORY[0x1895F8858](v22);
  char v26 = (char *)&v59 - v25;
  uint64_t v27 = *(void (**)(char *, uint64_t, unint64_t))(v18 + 16);
  v27((char *)&v59 - v25, (uint64_t)a1, v17);
  uint64_t v70 = *(void (**)(char *, uint64_t, uint64_t))(v65 + 16);
  v70(v16, v75, v77);
  uint64_t v74 = v26;
  uint64_t v28 = v26;
  uint64_t v29 = v16;
  uint64_t v71 = (void (*)(char *, char *, unint64_t))v27;
  v27(v24, (uint64_t)v28, v17);
  uint64_t v30 = v76;
  uint64_t v69 = *(void (**)(uint64_t, uint64_t))(v3 + 72);
  v69(v76, v3);
  uint64_t v31 = *(void *)(swift_getAssociatedConformanceWitness( v3,  v30,  v17,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  unint64_t v67 = *(uint64_t (**)(char *, char *, unint64_t))(v31 + 8);
  uint64_t v68 = v31;
  LOBYTE(v27) = v67(v24, v21, v17);
  uint64_t v59 = v18;
  uint64_t v32 = *(void (**)(char *, unint64_t))(v18 + 8);
  int64_t v73 = v21;
  v32(v21, v17);
  uint64_t v72 = v24;
  v32(v24, v17);
  if ((v27 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't advance past endIndex",  27LL,  2,  "Swift/Filter.swift",  18LL,  2,  0xB1uLL,  0);
  }
  uint64_t v66 = v32;
  v32(a1, v17);
  uint64_t v64 = *(void (**)(char *, uint64_t))(v65 + 8);
  v64(v29, v77);
  uint64_t v65 = *(void *)(v3 + 192);
  uint64_t v33 = v74;
  unint64_t v60 = v17;
  while (1)
  {
    uint64_t v34 = v75;
    uint64_t v35 = v76;
    ((void (*)(char *, uint64_t, uint64_t))v65)(v33, v76, v3);
    uint64_t v36 = v72;
    v71(v72, v33, v17);
    uint64_t v37 = v73;
    v69(v35, v3);
    char v38 = ((uint64_t (*)(char *, char *, unint64_t, uint64_t))v67)(v36, v37, v17, v68);
    uint64_t v39 = v66;
    v66(v37, v17);
    v39(v36, v17);
    v70(v14, v34, v77);
    if ((v38 & 1) != 0) {
      break;
    }
    uint64_t v43 = &v14[*(int *)(v77 + 36)];
    uint64_t v44 = a1;
    uint64_t v46 = *(uint64_t (**)(char *))v43;
    unint64_t v45 = (unint64_t *)*((void *)v43 + 1);
    unint64_t v47 = v14;
    uint64_t v48 = v77;
    unint64_t v49 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v3 + 80);
    swift_retain(v45, v40, v41, v42);
    uint64_t v50 = v49(v78, v33, v76, v3);
    uint64_t v51 = v3;
    uint64_t v53 = v61;
    uint64_t v52 = v62;
    unint64_t v54 = v63;
    (*(void (**)(char *))(v62 + 16))(v61);
    ((void (*)(_BYTE *, void))v50)(v78, 0LL);
    v64(v47, v48);
    char v55 = v46(v53);
    a1 = v44;
    LOBYTE(v5specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v55;
    swift_release((uint64_t)v45);
    uint64_t v56 = *(void (**)(char *, unint64_t))(v52 + 8);
    uint64_t v3 = v51;
    uint64_t v33 = v74;
    unint64_t v57 = v54;
    unint64_t v17 = v60;
    uint64_t v14 = v47;
    v56(v53, v57);
    if ((v50 & 1) != 0) {
      return (*(uint64_t (**)(char *, char *, unint64_t))(v59 + 32))(a1, v33, v17);
    }
  }

  v64(v14, v77);
  return (*(uint64_t (**)(char *, char *, unint64_t))(v59 + 32))(a1, v33, v17);
}

uint64_t LazyFilterSequence<>._advanceIndex(_:step:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v51 = a2;
  uint64_t v7 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v43 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v44 = AssociatedTypeWitness;
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v42 = (char *)&v41 - v10;
  uint64_t v11 = a3;
  uint64_t v57 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v56 = (char *)&v41 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v50 = *(void *)(v13 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  unint64_t v49 = (char *)&v41 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  unint64_t v17 = (char *)&v41 - v16;
  uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 136);
  unint64_t v47 = *(void (**)(uint64_t, uint64_t))(a4 + 72);
  uint64_t v48 = v18;
  uint64_t v54 = v7;
  uint64_t v55 = a4;
  uint64_t v46 = *(void *)(swift_getAssociatedConformanceWitness( a4,  v7,  v13,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  unint64_t v45 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v46 + 8);
  while (1)
  {
    uint64_t v19 = v52;
    uint64_t v20 = v54;
    uint64_t v21 = v55;
    v48(a1, v51, v54, v55);
    uint64_t v22 = v50;
    uint64_t v23 = *(void (**)(uint64_t, unint64_t))(v50 + 8);
    v23(a1, v13);
    (*(void (**)(uint64_t, char *, unint64_t))(v22 + 32))(a1, v17, v13);
    (*(void (**)(char *, uint64_t, unint64_t))(v22 + 16))(v17, a1, v13);
    unint64_t v24 = v49;
    v47(v20, v21);
    LOBYTE(v22) = v45(v17, v24, v13, v46);
    v23((uint64_t)v24, v13);
    v23((uint64_t)v17, v13);
    (*(void (**)(char *, uint64_t, uint64_t))(v57 + 16))(v56, v19, v11);
    if ((v22 & 1) != 0) {
      break;
    }
    uint64_t v28 = v11;
    uint64_t v30 = v55;
    uint64_t v29 = v56;
    uint64_t v31 = &v56[*(int *)(v11 + 36)];
    uint64_t v32 = (unint64_t *)*((void *)v31 + 1);
    uint64_t v53 = *(uint64_t (**)(char *))v31;
    uint64_t v33 = *(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v55 + 80);
    swift_retain(v32, v25, v26, v27);
    uint64_t v34 = v33(v58, a1, v54, v30);
    uint64_t v35 = a1;
    uint64_t v36 = (void (*)(_BYTE *, void))v34;
    char v38 = v42;
    uint64_t v37 = v43;
    unint64_t v39 = v44;
    (*(void (**)(char *))(v43 + 16))(v42);
    v36(v58, 0LL);
    a1 = v35;
    uint64_t v11 = v28;
    (*(void (**)(char *, uint64_t))(v57 + 8))(v29, v28);
    LOBYTE(v29) = v53(v38);
    swift_release((uint64_t)v32);
    uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v37 + 8))(v38, v39);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v57 + 8))(v56, v11);
}

uint64_t LazyFilterSequence<>._ensureBidirectional(step:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v20 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v20 - v10;
  uint64_t v14 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v12, v13);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t result = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v20 - v17;
  uint64_t v21 = a1;
  if (a1 < 0)
  {
    (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v5, a3);
    (*(void (**)(uint64_t, uint64_t))(a3 + 64))(v5, a3);
    (*(void (**)(char *, uint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v11, v21, v9, v5, a3);
    uint64_t v19 = *(void (**)(char *, unint64_t))(v20 + 8);
    v19(v9, AssociatedTypeWitness);
    v19(v11, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v18, v14);
  }

  return result;
}

uint64_t LazyFilterSequence<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v33 = a3;
  uint64_t v8 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v32 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v31 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 152);
  uint64_t v34 = v4;
  v15(a1, a2, v8, a4);
  uint64_t v16 = a4;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v18 = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 40))( a1,  a2,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v19 = v32;
  uint64_t v20 = *(void (**)(char *, uint64_t, unint64_t))(v32 + 16);
  if ((v18 & 1) != 0) {
    uint64_t v21 = a2;
  }
  else {
    uint64_t v21 = a1;
  }
  if ((v18 & 1) != 0) {
    uint64_t v22 = a1;
  }
  else {
    uint64_t v22 = a2;
  }
  if ((v18 & 1) != 0) {
    uint64_t v23 = -1LL;
  }
  else {
    uint64_t v23 = 1LL;
  }
  v20(v14, v21, AssociatedTypeWitness);
  v20(v12, v22, AssociatedTypeWitness);
  uint64_t v24 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v25 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v24 + 8);
  uint64_t result = v25(v14, v12, AssociatedTypeWitness, v24);
  uint64_t v27 = v19;
  uint64_t v28 = 0LL;
  if ((result & 1) != 0)
  {
LABEL_15:
    uint64_t v30 = *(void (**)(char *, unint64_t))(v27 + 8);
    v30(v12, AssociatedTypeWitness);
    v30(v14, AssociatedTypeWitness);
    return v28;
  }

  else
  {
    uint64_t v29 = 0LL;
    while (1)
    {
      uint64_t v28 = v29 + v23;
      if (__OFADD__(v29, v23)) {
        break;
      }
      LazyFilterSequence<>.formIndex(after:)(v14, v33, v16);
      uint64_t result = v25(v14, v12, AssociatedTypeWitness, v24);
      v29 += v23;
      if ((result & 1) != 0)
      {
        uint64_t v27 = v32;
        goto LABEL_15;
      }
    }

    __break(1u);
  }

  return result;
}

uint64_t LazyFilterSequence<>.index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4[1],  v10,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v68 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v69 = AssociatedTypeWitness;
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v67 = (char *)&v64 - v13;
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v83 = a3;
  uint64_t v84 = v14;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v64 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v81 = v10;
  uint64_t v82 = a4;
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v77 = (char *)&v64 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v76 = (char *)&v64 - v21;
  uint64_t v24 = type metadata accessor for Optional(0LL, v17, v22, v23);
  uint64_t v25 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v27 = (char *)&v64 - v26;
  uint64_t v78 = v18;
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 16);
  unint64_t v80 = v17;
  uint64_t v74 = v28;
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, unint64_t))v28)(a5, a1, v17);
  unint64_t v75 = (a2 > 0) | (unint64_t)(a2 >> 63);
  if ((v75 & 0x8000000000000000LL) != 0)
  {
    uint64_t v30 = v82;
    uint64_t v31 = (void (*)(uint64_t, void *))v82[9];
    uint64_t v32 = v76;
    int64_t v73 = (void (*)(uint64_t, unint64_t, uint64_t, void *))v24;
    uint64_t v33 = v81;
    v31(v81, v82);
    uint64_t v34 = v77;
    ((void (*)(uint64_t, void *))v30[8])(v33, v30);
    ((void (*)(char *, unint64_t, char *, uint64_t, void *))v30[18])(v32, v75, v34, v33, v30);
    uint64_t v35 = *(void (**)(char *, unint64_t))(v78 + 8);
    uint64_t v36 = v80;
    v35(v34, v80);
    v35(v32, v36);
    uint64_t result = (*(uint64_t (**)(char *, void (*)(uint64_t, unint64_t, uint64_t, void *)))(v25 + 8))( v27,  v73);
    if ((a2 & 0x8000000000000000LL) == 0)
    {
LABEL_3:
      if (!a2) {
        return result;
      }
      goto LABEL_8;
    }
  }

  else if ((a2 & 0x8000000000000000LL) == 0)
  {
    goto LABEL_3;
  }

  BOOL v37 = __OFSUB__(0LL, a2);
  a2 = -a2;
  if (v37)
  {
    __break(1u);
    return result;
  }

  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
LABEL_8:
  char v38 = (void (*)(uint64_t, unint64_t, uint64_t, void *))v82[17];
  uint64_t v72 = (void (*)(uint64_t, void *))v82[9];
  int64_t v73 = v38;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v82,  v81,  v80,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v40 = 0LL;
  uint64_t v71 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v70 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v71 + 8);
  uint64_t v65 = a2;
  do
  {
    uint64_t v66 = v40 + 1;
    while (1)
    {
      uint64_t v41 = v76;
      uint64_t v42 = v79;
      uint64_t v44 = v81;
      uint64_t v43 = v82;
      v73(a5, v75, v81, v82);
      uint64_t v45 = v78;
      uint64_t v46 = *(void (**)(uint64_t, unint64_t))(v78 + 8);
      uint64_t v47 = v80;
      v46(a5, v80);
      (*(void (**)(uint64_t, char *, uint64_t))(v45 + 32))(a5, v41, v47);
      v74(v41, a5, v47);
      uint64_t v48 = v77;
      v72(v44, v43);
      LOBYTE(v45) = v70(v41, v48, v47, v71);
      v46((uint64_t)v48, v47);
      v46((uint64_t)v41, v47);
      (*(void (**)(char *, uint64_t, uint64_t))(v84 + 16))(v16, v42, v83);
      if ((v45 & 1) != 0) {
        break;
      }
      uint64_t v52 = v82;
      uint64_t v53 = v83;
      uint64_t v54 = &v16[*(int *)(v83 + 36)];
      uint64_t v56 = *(uint64_t (**)(char *))v54;
      uint64_t v55 = (unint64_t *)*((void *)v54 + 1);
      uint64_t v57 = (uint64_t (*)(_BYTE *, uint64_t, uint64_t, void *))v82[10];
      swift_retain(v55, v49, v50, v51);
      uint64_t v58 = v57(v85, a5, v81, v52);
      uint64_t v59 = a5;
      uint64_t v60 = v68;
      unint64_t v61 = v69;
      uint64_t v62 = v67;
      (*(void (**)(char *))(v68 + 16))(v67);
      ((void (*)(_BYTE *, void))v58)(v85, 0LL);
      (*(void (**)(char *, uint64_t))(v84 + 8))(v16, v53);
      LOBYTE(v58) = v56(v62);
      swift_release((uint64_t)v55);
      unint64_t v63 = *(uint64_t (**)(char *, unint64_t))(v60 + 8);
      a5 = v59;
      uint64_t result = v63(v62, v61);
      if ((v58 & 1) != 0) {
        goto LABEL_10;
      }
    }

    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v84 + 8))(v16, v83);
LABEL_10:
    uint64_t v40 = v66;
  }

  while (v66 != v65);
  return result;
}

Swift::Int __swiftcall Int.signum()()
{
  return (v0 > 0) | (unint64_t)(v0 >> 63);
}

uint64_t abs<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v26 = a3;
  uint64_t v27 = a4;
  uint64_t v28 = *(void *)(a2 - 8);
  uint64_t v29 = a1;
  uint64_t v5 = *(void *)(v28 + 64);
  MEMORY[0x1895F8858](a1);
  uint64_t v25 = v6;
  uint64_t v7 = *(void *)(v6 + 8);
  uint64_t v8 = *(void *)(v7 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v24 - v10;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = *(void *)(v13 + 64);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unint64_t v17 = (char *)&v24 - v16;
  if (v15 == a2)
  {
    uint64_t v23 = v28;
    (*(void (**)(uint64_t, uint64_t))(v7 + 56))(a2, v7);
    if (v14 != v5) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }
    (*(void (**)(uint64_t, char *, uint64_t))(v23 + 16))(v27, v17, a2);
    return (*(uint64_t (**)(char *, uint64_t))(v13 + 8))(v17, a2);
  }

  else
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v11, a2, v8);
    uint64_t v19 = v29;
    char v20 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(v26 + 16))( v29,  (char *)&v24 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a2);
    uint64_t v21 = v28;
    (*(void (**)(char *, uint64_t))(v28 + 8))((char *)&v24 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL), a2);
    if ((v20 & 1) != 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(v25 + 16))(v19, a2);
    }
    else {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v21 + 16))(v27, v19, a2);
    }
  }

uint64_t LazyFilterSequence<>.formIndex(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v13 - v10;
  LazyFilterSequence<>.index(_:offsetBy:)(a1, a2, a3, a4, (uint64_t)&v13 - v10);
  (*(void (**)(uint64_t, unint64_t))(v9 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v9 + 32))(a1, v11, AssociatedTypeWitness);
}

uint64_t LazyFilterSequence<>.index(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v69 = a2;
  uint64_t v67 = a5;
  uint64_t v8 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v73 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v74 = AssociatedTypeWitness;
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v72 = (char *)&v67 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v87 = a3;
  uint64_t v88 = v12;
  MEMORY[0x1895F8858](v10);
  uint64_t v85 = v8;
  unint64_t v86 = (char *)&v67 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v89 = a4;
  unint64_t v14 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v17 = type metadata accessor for Optional(0LL, v14, v15, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v67 - v20;
  uint64_t v22 = *(void *)(v14 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v19);
  uint64_t v79 = (char *)&v67 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v78 = (char *)&v67 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v28 = (char *)&v67 - v27;
  uint64_t v76 = *(uint64_t (**)(void))(v22 + 16);
  uint64_t result = v76();
  unint64_t v77 = (a1 > 0) | (unint64_t)(a1 >> 63);
  if ((v77 & 0x8000000000000000LL) == 0)
  {
    if ((a1 & 0x8000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    BOOL v38 = __OFSUB__(0LL, a1);
    a1 = -a1;
    if (v38)
    {
      __break(1u);
      return result;
    }

    if (a1 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    goto LABEL_8;
  }

  uint64_t v84 = v18;
  uint64_t v31 = v21;
  uint64_t v32 = v89;
  uint64_t v33 = v78;
  uint64_t v34 = v85;
  (*(void (**)(uint64_t, uint64_t))(v89 + 72))(v85, v89);
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v32 + 64);
  uint64_t v83 = (uint64_t (*)(char *, uint64_t, unint64_t, uint64_t))v17;
  uint64_t v36 = v79;
  v35(v34, v32);
  (*(void (**)(char *, unint64_t, char *, uint64_t, uint64_t))(v32 + 144))(v33, v77, v36, v34, v32);
  BOOL v37 = *(void (**)(char *, unint64_t))(v22 + 8);
  v37(v36, v14);
  v37(v33, v14);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t (*)(char *, uint64_t, unint64_t, uint64_t)))(v84 + 8))( v31,  v83);
  if (a1 < 0) {
    goto LABEL_6;
  }
LABEL_3:
  if (a1)
  {
LABEL_8:
    uint64_t v39 = 0LL;
    uint64_t v84 = *(void *)(swift_getAssociatedConformanceWitness( v89,  v85,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    uint64_t v83 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v84 + 8);
    uint64_t v68 = a1;
    uint64_t v71 = v22;
    for (char i = v83(v28, v69, v14, v84); ; char i = v83(v28, v69, v14, v84))
    {
      if ((i & 1) != 0)
      {
        (*(void (**)(char *, unint64_t))(v22 + 8))(v28, v14);
        uint64_t v65 = 1LL;
        uint64_t v66 = v67;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v22 + 56))(v66, v65, 1LL, v14);
      }

      uint64_t v70 = v39 + 1;
      uint64_t v41 = *(void (**)(char *, unint64_t, uint64_t, uint64_t))(v89 + 136);
      uint64_t v81 = *(void (**)(uint64_t, uint64_t))(v89 + 72);
      uint64_t v82 = v41;
      while (1)
      {
        uint64_t v42 = v78;
        uint64_t v43 = v80;
        uint64_t v44 = v85;
        uint64_t v45 = v89;
        v82(v28, v77, v85, v89);
        uint64_t v46 = *(void (**)(char *, unint64_t))(v22 + 8);
        v46(v28, v14);
        unint64_t v75 = *(void (**)(char *, char *, unint64_t))(v22 + 32);
        v75(v28, v42, v14);
        ((void (*)(char *, char *, unint64_t))v76)(v42, v28, v14);
        uint64_t v47 = v79;
        v81(v44, v45);
        char v48 = v83(v42, (uint64_t)v47, v14, v84);
        v46(v47, v14);
        v46(v42, v14);
        (*(void (**)(char *, uint64_t, uint64_t))(v88 + 16))(v86, v43, v87);
        if ((v48 & 1) != 0) {
          break;
        }
        uint64_t v52 = v86;
        uint64_t v53 = v87;
        uint64_t v54 = &v86[*(int *)(v87 + 36)];
        uint64_t v55 = *(uint64_t (**)(char *))v54;
        uint64_t v56 = (unint64_t *)*((void *)v54 + 1);
        uint64_t v57 = v89;
        uint64_t v58 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v89 + 80);
        swift_retain(v56, v49, v50, v51);
        uint64_t v59 = v58(v90, v28, v85, v57);
        uint64_t v60 = v53;
        unint64_t v61 = (void (*)(_BYTE *, void))v59;
        uint64_t v62 = v73;
        unint64_t v63 = v74;
        uint64_t v64 = v72;
        (*(void (**)(char *))(v73 + 16))(v72);
        v61(v90, 0LL);
        (*(void (**)(char *, uint64_t))(v88 + 8))(v52, v60);
        LOBYTE(v61) = v55(v64);
        swift_release((uint64_t)v56);
        uint64_t v22 = v71;
        (*(void (**)(char *, unint64_t))(v62 + 8))(v64, v63);
      }

      (*(void (**)(char *, uint64_t))(v88 + 8))(v86, v87);
LABEL_10:
      uint64_t v39 = v70;
      if (v70 == v68) {
        break;
      }
    }

    uint64_t v30 = (void (*)(uint64_t, char *, unint64_t))v75;
    goto LABEL_19;
  }

  uint64_t v30 = *(void (**)(uint64_t, char *, unint64_t))(v22 + 32);
LABEL_19:
  uint64_t v66 = v67;
  v30(v67, v28, v14);
  uint64_t v65 = 0LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v22 + 56))(v66, v65, 1LL, v14);
}

BOOL LazyFilterSequence<>.formIndex(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a5,  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v20 - v15;
  LazyFilterSequence<>.index(_:offsetBy:limitedBy:)(a2, a3, a4, (uint64_t)a5, (uint64_t)&v20 - v15);
  uint64_t v17 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v17 + 8))(a1, AssociatedTypeWitness);
  int v18 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v17 + 48))(v16, 1LL, AssociatedTypeWitness);
  if (v18 == 1)
  {
    (*(void (**)(char *, uint64_t))(v14 + 8))(v16, v13);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v17 + 16))(a1, a3, AssociatedTypeWitness);
  }

  else
  {
    (*(void (**)(uint64_t, char *, unint64_t))(v17 + 32))(a1, v16, AssociatedTypeWitness);
  }

  return v18 != 1;
}

unint64_t *LazyFilterSequence<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 + 16);
  (*(void (**)(uint64_t, uint64_t))(a3 + 88))(a1, v8);
  uint64_t v9 = (uint64_t *)(v4 + *(int *)(a2 + 36));
  uint64_t v11 = *v9;
  uint64_t v10 = (unint64_t *)v9[1];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  uint64_t v15 = (void *)(a4
                 + *(int *)(type metadata accessor for LazyFilterSequence( 0LL,  AssociatedTypeWitness,  *(void *)(AssociatedConformanceWitness + 8),  v14)
                          + 36));
  *uint64_t v15 = v11;
  v15[1] = v10;
  return swift_retain(v10, v16, v17, v18);
}

uint64_t LazyFilterSequence<>._customLastIndexOfEquatableElement(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56LL))( a4,  1LL,  1LL,  AssociatedTypeWitness);
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56LL))(a4, 0LL, 1LL, v13);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyFilterSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), a3);
}

unint64_t *protocol witness for Collection.subscript.getter in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyFilterSequence<>.subscript.getter(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection._customLastIndexOfEquatableElement(_:) in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyFilterSequence<>._customLastIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:)(a1, a2, a3, *(void **)(a4 - 8), a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, *(void *)(a4 - 8), a5);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazyFilterSequence<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  return LazyFilterSequence<>.index(after:)(a1, a2, *(const char **)(a3 - 8), a4);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyFilterSequence<A>( char *a1, uint64_t a2, uint64_t a3)
{
  return LazyFilterSequence<>.formIndex(after:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t LazyFilterSequence<>.index(before:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a4,  a1,  AssociatedTypeWitness);
  return LazyFilterSequence<>.formIndex(before:)(a4, a2, a3);
}

uint64_t LazyFilterSequence<>.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v47 = a3;
  uint64_t v44 = a1;
  uint64_t v4 = *(void *)(a3 + 8);
  uint64_t v5 = *(const char **)(v4 + 8);
  uint64_t v43 = *(void *)(a2 + 16);
  uint64_t v6 = v43;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v43,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v41 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v42 = AssociatedTypeWitness;
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v37 - v9;
  uint64_t v11 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v37 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v4,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  int v18 = (char *)&v37 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v37 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v37 - v22;
  uint64_t v40 = *(void (**)(char *, uint64_t, unint64_t))(v15 + 32);
  v40((char *)&v37 - v22, v44, v14);
  uint64_t v45 = v11;
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v39 = a2;
  v24(v13, v48, a2);
  (*(void (**)(char *, char *, unint64_t))(v15 + 16))(v21, v23, v14);
  uint64_t v25 = v43;
  (*(void (**)(uint64_t, uint64_t))(v4 + 64))(v43, v4);
  uint64_t v46 = v4;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v4,  v25,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(a2) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                           + 8LL))( v21,  v18,  v14);
  uint64_t v27 = *(void (**)(char *, unint64_t))(v15 + 8);
  v27(v18, v14);
  v27(v21, v14);
  if ((a2 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't retreat before startIndex",  31LL,  2,  "Swift/Filter.swift",  18LL,  2,  0x140uLL,  0);
  }
  unint64_t v38 = v14;
  uint64_t v28 = v39;
  (*(void (**)(char *, uint64_t))(v45 + 8))(v13, v39);
  uint64_t v45 = *(void *)(v47 + 40);
  uint64_t v29 = v25;
  uint64_t v31 = v41;
  unint64_t v30 = v42;
  uint64_t v32 = (uint64_t (**)(char *))(v48 + *(int *)(v28 + 36));
  uint64_t v33 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v46 + 80);
  do
  {
    ((void (*)(char *, uint64_t, uint64_t))v45)(v23, v29, v47);
    uint64_t v34 = *v32;
    uint64_t v35 = v33(v49, v23, v29, v46);
    (*(void (**)(char *))(v31 + 16))(v10);
    ((void (*)(_BYTE *, void))v35)(v49, 0LL);
    LOBYTE(v35) = v34(v10);
    (*(void (**)(char *, unint64_t))(v31 + 8))(v10, v30);
  }

  while ((v35 & 1) == 0);
  return ((uint64_t (*)(uint64_t, char *, unint64_t))v40)(v44, v23, v38);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyFilterSequence<>.index(before:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazyFilterSequence<>.formIndex(before:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:)(a1, a2, a3, *(void **)(*(void *)(a4 - 8) + 8LL), a5);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance <> LazyFilterSequence<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  return LazyFilterSequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8LL), a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazyFilterSequence<>.distance(from:to:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8LL));
}

unint64_t *LazySequenceProtocol.filter(_:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazySequenceProtocol.drop(while:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, unint64_t, unint64_t))type metadata accessor for LazyFilterSequence,  a5);
}

unint64_t *LazyFilterSequence.filter(_:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v30 = a1;
  uint64_t v31 = a2;
  uint64_t v8 = *(void *)(a3 - 8);
  uint64_t v9 = *(void *)(v8 + 64);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v16, v5, v13);
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 32);
  v17(v11, v5, a3);
  uint64_t v18 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v19 = (v18 + 32) & ~v18;
  unint64_t v20 = (v9 + v19 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v21 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))swift_allocObject( (uint64_t)&unk_189B782D0,  v20 + 16,  v18 | 7);
  uint64_t v22 = *(void *)(a3 + 24);
  *((void *)v21 + 2) = v13;
  *((void *)v21 + 3) = v22;
  v17((char *)v21 + v19, (uint64_t)v11, a3);
  uint64_t v23 = (void *)((char *)v21 + v20);
  uint64_t v24 = v31;
  *uint64_t v23 = v30;
  v23[1] = v24;
  (*(void (**)(uint64_t, char *, uint64_t))(v14 + 32))(a4, v16, v13);
  uint64_t v25 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + *(int *)(a3 + 36));
  *uint64_t v25 = partial apply for closure #1 in LazyFilterSequence.filter(_:);
  v25[1] = v21;
  return swift_retain(v24, v26, v27, v28);
}

uint64_t closure #1 in LazyFilterSequence.filter(_:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(char *), uint64_t a4, uint64_t a5, const char *a6)
{
  uint64_t v6 = (uint64_t)a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a6,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v19 - v13;
  uint64_t v16 = type metadata accessor for LazyFilterSequence(0LL, a5, v6, v15);
  LOBYTE(v6) = (*(uint64_t (**)(uint64_t))(a2 + *(int *)(v16 + 36)))(a1);
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))(v14, a1, AssociatedTypeWitness);
  if ((v6 & 1) != 0) {
    char v17 = a3(v14);
  }
  else {
    char v17 = 0;
  }
  (*(void (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
  return v17 & 1;
}

uint64_t _FixedArray16.endIndex.getter(uint64_t a1)
{
  return *(char *)(v1 + *(int *)(a1 + 28));
}

uint64_t UnsafeRawBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  if (a1) {
    return a2 - a1;
  }
  else {
    return 0LL;
  }
}

uint64_t _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned __int8 *)(v3 + *(int *)(a3 + 28));
  v7[0] = *(void *)(a3 + 16);
  v7[1] = v7[0];
  v7[2] = v7[0];
  v7[3] = v7[0];
  v7[4] = v7[0];
  v7[5] = v7[0];
  v7[6] = v7[0];
  v7[7] = v7[0];
  v7[8] = v7[0];
  v7[9] = v7[0];
  v7[10] = v7[0];
  v7[11] = v7[0];
  v7[12] = v7[0];
  v7[13] = v7[0];
  v7[14] = v7[0];
  v7[15] = v7[0];
  if ((*(void *)(*(swift_getTupleTypeMetadata(0LL, 16, (uint64_t)v7, 0LL, 0LL) - 1) + 64) & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }
  if ((v5 & 0x80) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  return a1(v3, v5);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _FixedArray16<A>( uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v5 = v8;
  uint64_t v9 = v4;
  uint64_t v10 = a1;
  _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5( (uint64_t (*)(uint64_t, uint64_t))partial apply for closure #1 in _FixedArray16.subscript.setter,  (uint64_t)&v7,  a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8LL))(a1, v5);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _FixedArray16<A>( void *a1, uint64_t *a2, uint64_t a3))(void **a1, char a2)
{
  uint64_t v7 = malloc(0xD0uLL);
  *a1 = v7;
  uint64_t v69 = a3;
  void v7[16] = v3;
  v7[17] = a3;
  uint64_t v8 = *(void *)(a3 + 16);
  v7[18] = v8;
  *uint64_t v7 = v8;
  v7[1] = v8;
  v7[2] = v8;
  v7[3] = v8;
  v7[4] = v8;
  v7[5] = v8;
  v7[6] = v8;
  v7[7] = v8;
  v7[8] = v8;
  v7[9] = v8;
  v7[10] = v8;
  v7[11] = v8;
  v7[12] = v8;
  v7[13] = v8;
  v7[14] = v8;
  v7[15] = v8;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 16, (uint64_t)v7, 0LL, 0LL);
  uint64_t v47 = *((void *)TupleTypeMetadata - 1);
  size_t v10 = *(void *)(v47 + 64);
  size_t v71 = v10;
  uint64_t v11 = (char *)malloc(v10);
  v7[19] = v11;
  uint64_t v12 = (char *)malloc(v10);
  v7[20] = v12;
  uint64_t v13 = *(void *)(v8 - 8);
  v7[21] = v13;
  size_t v14 = *(void *)(v13 + 64);
  uint64_t v15 = v13;
  uint64_t v72 = v13;
  v7[22] = malloc(v14);
  uint64_t v16 = (char *)malloc(v14);
  uint64_t v44 = *a2;
  uint64_t v17 = *a2;
  uint64_t v45 = v16;
  v7[23] = v16;
  v7[24] = v17;
  uint64_t v18 = TupleTypeMetadata[12];
  uint64_t v73 = &v12[v18];
  uint64_t v19 = TupleTypeMetadata[16];
  unint64_t v74 = &v12[v19];
  uint64_t v20 = TupleTypeMetadata[20];
  unint64_t v75 = &v12[v20];
  uint64_t v21 = TupleTypeMetadata[24];
  uint64_t v76 = &v12[v21];
  uint64_t v22 = TupleTypeMetadata[28];
  unint64_t v77 = &v12[v22];
  uint64_t v23 = TupleTypeMetadata[32];
  uint64_t v79 = &v12[v23];
  uint64_t v24 = TupleTypeMetadata[36];
  uint64_t v81 = &v12[v24];
  uint64_t v25 = TupleTypeMetadata[40];
  uint64_t v83 = &v12[v25];
  uint64_t v26 = TupleTypeMetadata[44];
  uint64_t v85 = &v12[v26];
  uint64_t v27 = TupleTypeMetadata[48];
  unint64_t v86 = &v12[v27];
  uint64_t v28 = TupleTypeMetadata[52];
  uint64_t v87 = &v12[v28];
  uint64_t v29 = TupleTypeMetadata[56];
  uint64_t v30 = TupleTypeMetadata[60];
  uint64_t v31 = TupleTypeMetadata[64];
  uint64_t v32 = TupleTypeMetadata[68];
  uint64_t v33 = *(void (**)(char *, uint64_t, uint64_t))(v15 + 16);
  v7[25] = v33;
  uint64_t v80 = &v12[v29];
  uint64_t v34 = v3 + v18;
  uint64_t v35 = v3 + v19;
  uint64_t v36 = v3 + v20;
  uint64_t v37 = v3 + v21;
  uint64_t v48 = v3 + v22;
  uint64_t v49 = v3 + v23;
  uint64_t v51 = v3 + v24;
  uint64_t v53 = v3 + v25;
  uint64_t v55 = v3 + v26;
  uint64_t v57 = v3 + v27;
  uint64_t v59 = v3 + v28;
  uint64_t v61 = v3 + v29;
  uint64_t v78 = &v12[v30];
  uint64_t v63 = v3 + v30;
  uint64_t v82 = &v12[v31];
  uint64_t v65 = v3 + v31;
  uint64_t v84 = &v12[v32];
  uint64_t v67 = v3 + v32;
  int v46 = *(char *)(v3 + *(int *)(v69 + 28));
  v33(v12, v3, v8);
  v33(v73, v34, v8);
  v33(v74, v35, v8);
  v33(v75, v36, v8);
  v33(v76, v37, v8);
  v33(v77, v48, v8);
  v33(v79, v49, v8);
  v33(v81, v51, v8);
  v33(v83, v53, v8);
  v33(v85, v55, v8);
  v33(v86, v57, v8);
  v33(v87, v59, v8);
  v33(v80, v61, v8);
  v33(v78, v63, v8);
  v33(v82, v65, v8);
  v33(v84, v67, v8);
  unint64_t v38 = &v11[TupleTypeMetadata[12]];
  uint64_t v39 = &v11[TupleTypeMetadata[16]];
  uint64_t v40 = &v11[TupleTypeMetadata[20]];
  uint64_t v41 = &v11[TupleTypeMetadata[24]];
  uint64_t v50 = &v11[TupleTypeMetadata[28]];
  uint64_t v52 = &v11[TupleTypeMetadata[32]];
  uint64_t v54 = &v11[TupleTypeMetadata[36]];
  uint64_t v56 = &v11[TupleTypeMetadata[40]];
  uint64_t v58 = &v11[TupleTypeMetadata[44]];
  uint64_t v60 = &v11[TupleTypeMetadata[48]];
  uint64_t v62 = &v11[TupleTypeMetadata[52]];
  uint64_t v64 = &v11[TupleTypeMetadata[56]];
  uint64_t v66 = &v11[TupleTypeMetadata[60]];
  uint64_t v68 = &v11[TupleTypeMetadata[64]];
  uint64_t v70 = &v11[TupleTypeMetadata[68]];
  unint64_t v42 = *(void (**)(char *, char *, uint64_t))(v72 + 32);
  v42(v11, v12, v8);
  v42(v38, v73, v8);
  v42(v39, v74, v8);
  v42(v40, v75, v8);
  v42(v41, v76, v8);
  v42(v50, v77, v8);
  v42(v52, v79, v8);
  v42(v54, v81, v8);
  v42(v56, v83, v8);
  v42(v58, v85, v8);
  v42(v60, v86, v8);
  v42(v62, v87, v8);
  v42(v64, v80, v8);
  v42(v66, v78, v8);
  v42(v68, v82, v8);
  v42(v70, v84, v8);
  if ((v71 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  (*(void (**)(char *, int *))(v47 + 8))(v11, TupleTypeMetadata);
  if (v46 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  v33(v45, (uint64_t)&v11[*(void *)(v72 + 72) * v44], v8);
  return protocol witness for MutableCollection.subscript.modify in conformance _FixedArray16<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _FixedArray16<A>( void **a1, char a2)
{
  uint64_t v2 = *a1;
  if ((a2 & 1) != 0)
  {
    uint64_t v4 = v2[24];
    uint64_t v3 = (uint64_t (*)(void *, void *, uint64_t))v2[25];
    uint64_t v6 = (void *)v2[22];
    uint64_t v5 = (void *)v2[23];
    uint64_t v7 = (void *)v2[20];
    uint64_t v22 = v2[21];
    uint64_t v9 = v2[18];
    uint64_t v8 = (void *)v2[19];
    uint64_t v10 = v2[17];
    uint64_t v11 = v3(v6, v5, v9);
    MEMORY[0x1895F8858](v11);
    uint64_t v19 = v9;
    uint64_t v20 = v4;
    uint64_t v21 = v6;
    _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5( (uint64_t (*)(uint64_t, uint64_t))partial apply for closure #1 in _FixedArray16.subscript.setter,  (uint64_t)v18,  v10);
    uint64_t v12 = v7;
    uint64_t v13 = *(void (**)(void *, uint64_t))(v22 + 8);
    v13(v6, v9);
    v13(v5, v9);
  }

  else
  {
    uint64_t v5 = (void *)v2[23];
    uint64_t v14 = v2[21];
    uint64_t v6 = (void *)v2[22];
    uint64_t v8 = (void *)v2[19];
    uint64_t v12 = (void *)v2[20];
    uint64_t v15 = v2[18];
    MEMORY[0x1895F8858](a1);
    uint64_t v19 = v15;
    uint64_t v20 = v16;
    uint64_t v21 = v5;
    _ss13_FixedArray16V30withUnsafeMutableBufferPointeryqd__qd__SryxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxytIsgyrzo_AByxGytsAE_pytRsd__r__lIetMglrzo_Tp5( (uint64_t (*)(uint64_t, uint64_t))partial apply for closure #1 in _FixedArray16.subscript.setter,  (uint64_t)v18,  v17);
    (*(void (**)(void *, uint64_t))(v14 + 8))(v5, v15);
  }

  free(v5);
  free(v6);
  free(v12);
  free(v8);
  free(v2);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _FixedArray16<A>( uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  __int128 v11 = *a2;
  specialized MutableCollection<>.subscript.setter(a1, (char *)&v11, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a3, v6);
  uint64_t v9 = type metadata accessor for Slice(0LL, a3, WitnessTable, v8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v9 - 8) + 8LL))(a1, v9);
}

void *protocol witness for MutableCollection.partition(by:) in conformance _FixedArray16<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _FixedArray16<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _FixedArray16<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _FixedArray16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance _FixedArray16<A>@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = _FixedArray16.endIndex.getter(a1);
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _FixedArray16<A>( void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = _FixedArray16.subscript.read(v6, *a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*_FixedArray16.subscript.read(void *a1, uint64_t a2, uint64_t a3))(uint64_t a1)
{
  uint64_t v4 = v3;
  uint64_t v7 = malloc(0xA8uLL);
  *a1 = v7;
  uint64_t v8 = *(void *)(a3 + 16);
  v7[15] = v8;
  void v7[16] = v8;
  *uint64_t v7 = v8;
  v7[1] = v8;
  v7[2] = v8;
  v7[3] = v8;
  v7[4] = v8;
  v7[5] = v8;
  v7[6] = v8;
  v7[7] = v8;
  v7[8] = v8;
  v7[9] = v8;
  v7[10] = v8;
  v7[11] = v8;
  v7[12] = v8;
  v7[13] = v8;
  v7[14] = v8;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 16, (uint64_t)v7, 0LL, 0LL);
  uint64_t v42 = *((void *)TupleTypeMetadata - 1);
  size_t v10 = *(void *)(v42 + 64);
  size_t v69 = v10;
  __int128 v11 = (char *)malloc(v10);
  v7[17] = v11;
  uint64_t v12 = (char *)malloc(v10);
  v7[18] = v12;
  uint64_t v83 = *(void **)(v8 - 8);
  v7[19] = v83;
  uint64_t v39 = (char *)malloc(v83[8]);
  v7[20] = v39;
  uint64_t v13 = TupleTypeMetadata[12];
  uint64_t v14 = &v12[v13];
  uint64_t v15 = TupleTypeMetadata[16];
  uint64_t v16 = &v12[v15];
  uint64_t v67 = &v12[v13];
  uint64_t v68 = &v12[v15];
  uint64_t v17 = TupleTypeMetadata[20];
  uint64_t v70 = &v12[v17];
  uint64_t v18 = TupleTypeMetadata[24];
  size_t v71 = &v12[v18];
  uint64_t v19 = TupleTypeMetadata[28];
  uint64_t v72 = &v12[v19];
  uint64_t v20 = TupleTypeMetadata[32];
  uint64_t v73 = &v12[v20];
  uint64_t v21 = TupleTypeMetadata[36];
  unint64_t v74 = &v12[v21];
  uint64_t v22 = TupleTypeMetadata[40];
  unint64_t v75 = &v12[v22];
  uint64_t v23 = TupleTypeMetadata[44];
  uint64_t v76 = &v12[v23];
  uint64_t v24 = TupleTypeMetadata[48];
  unint64_t v77 = &v12[v24];
  uint64_t v25 = TupleTypeMetadata[52];
  uint64_t v78 = &v12[v25];
  uint64_t v26 = TupleTypeMetadata[56];
  uint64_t v80 = &v12[v26];
  uint64_t v27 = TupleTypeMetadata[60];
  uint64_t v81 = &v12[v27];
  uint64_t v28 = TupleTypeMetadata[64];
  uint64_t v82 = &v12[v28];
  uint64_t v29 = v4 + v13;
  uint64_t v30 = v4 + v15;
  uint64_t v43 = v4 + v17;
  uint64_t v44 = v4 + v18;
  uint64_t v45 = v4 + v19;
  uint64_t v47 = v4 + v20;
  uint64_t v49 = v4 + v21;
  uint64_t v51 = v4 + v22;
  uint64_t v53 = v4 + v23;
  uint64_t v55 = v4 + v24;
  uint64_t v57 = v4 + v25;
  int v41 = *(char *)(v4 + *(int *)(a3 + 28));
  uint64_t v59 = v4 + v26;
  uint64_t v61 = v4 + v27;
  uint64_t v31 = TupleTypeMetadata[68];
  uint64_t v63 = v4 + v28;
  uint64_t v79 = &v12[v31];
  uint64_t v65 = v4 + v31;
  uint64_t v32 = (void (*)(char *, uint64_t, uint64_t))v83[2];
  v32(v12, v4, v8);
  v32(v14, v29, v8);
  v32(v16, v30, v8);
  v32(v70, v43, v8);
  v32(v71, v44, v8);
  v32(v72, v45, v8);
  v32(v73, v47, v8);
  v32(v74, v49, v8);
  v32(v75, v51, v8);
  v32(v76, v53, v8);
  v32(v77, v55, v8);
  v32(v78, v57, v8);
  v32(v80, v59, v8);
  v32(v81, v61, v8);
  v32(v82, v63, v8);
  v32(v79, v65, v8);
  uint64_t v33 = &v11[TupleTypeMetadata[12]];
  uint64_t v34 = &v11[TupleTypeMetadata[16]];
  uint64_t v35 = &v11[TupleTypeMetadata[20]];
  uint64_t v36 = &v11[TupleTypeMetadata[24]];
  int v46 = &v11[TupleTypeMetadata[28]];
  uint64_t v48 = &v11[TupleTypeMetadata[32]];
  uint64_t v50 = &v11[TupleTypeMetadata[36]];
  uint64_t v52 = &v11[TupleTypeMetadata[40]];
  uint64_t v54 = &v11[TupleTypeMetadata[44]];
  uint64_t v56 = &v11[TupleTypeMetadata[48]];
  uint64_t v58 = &v11[TupleTypeMetadata[52]];
  uint64_t v60 = &v11[TupleTypeMetadata[56]];
  uint64_t v62 = &v11[TupleTypeMetadata[60]];
  uint64_t v64 = &v11[TupleTypeMetadata[64]];
  uint64_t v66 = &v11[TupleTypeMetadata[68]];
  uint64_t v37 = (void (*)(char *, char *, uint64_t))v83[4];
  v37(v11, v12, v8);
  v37(v33, v67, v8);
  v37(v34, v68, v8);
  v37(v35, v70, v8);
  v37(v36, v71, v8);
  v37(v46, v72, v8);
  v37(v48, v73, v8);
  v37(v50, v74, v8);
  v37(v52, v75, v8);
  v37(v54, v76, v8);
  v37(v56, v77, v8);
  v37(v58, v78, v8);
  v37(v60, v80, v8);
  v37(v62, v81, v8);
  v37(v64, v82, v8);
  v37(v66, v79, v8);
  if ((v69 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  (*(void (**)(char *, int *))(v42 + 8))(v11, TupleTypeMetadata);
  if (v41 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  v32(v39, (uint64_t)&v11[v83[9] * a2], v8);
  return _FixedArray16.subscript.read;
}

void _FixedArray16.subscript.read(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 160LL);
  uint64_t v4 = *(void **)(*(void *)a1 + 136LL);
  uint64_t v3 = *(void **)(*(void *)a1 + 144LL);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 152LL) + 8LL))( v2,  *(void *)(*(void *)a1 + 128LL));
  free(v2);
  free(v3);
  free(v4);
  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance _FixedArray16<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  return MutableCollection<>.subscript.getter(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Collection.indices.getter in conformance _FixedArray16<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>( a1,  (uint64_t)&protocol conformance descriptor for _FixedArray16<A>,  a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _FixedArray16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _FixedArray16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

_BYTE *static Int8.+= infix(_:_:)(_BYTE *result, char a2)
{
  int v2 = (char)*result + a2;
  else {
    __break(1u);
  }
  return result;
}

unint64_t *LazySequenceProtocol.flatMap<A>(_:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  (uint64_t)&associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v14 = (void *)(a6
                 + *(int *)(type metadata accessor for LazyMapSequence( 0LL,  AssociatedTypeWitness,  a4,  AssociatedConformanceWitness)
                          + 44));
  *uint64_t v14 = a1;
  v14[1] = a2;
  return swift_retain(a2, v15, v16, v17);
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t AssociatedConformanceWitness;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t WitnessTable;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  unint64_t *v27;
  void *v28;
  uint64_t v29;
  char *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t *v43;
  int v41 = a4;
  uint64_t v42 = a6;
  uint64_t v43 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v13 = type metadata accessor for Optional((const char *)0xFF, a4, v11, v12);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  (uint64_t)&associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v15 = type metadata accessor for LazyMapSequence(0LL, AssociatedTypeWitness, v13, AssociatedConformanceWitness);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v15, v19);
  uint64_t v22 = type metadata accessor for LazyFilterSequence(0LL, v15, WitnessTable, v21);
  uint64_t v23 = *(void *)(v22 - 8);
  MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v40 - v24;
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  uint64_t v26 = &v18[*(int *)(v15 + 44)];
  uint64_t v27 = v43;
  *(void *)uint64_t v26 = a1;
  *((void *)v26 + 1) = v27;
  uint64_t v28 = swift_allocObject((uint64_t)&unk_189B783C0, 0x28uLL, 7uLL);
  uint64_t v29 = v41;
  v28[2] = a3;
  void v28[3] = v29;
  v28[4] = a5;
  (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v25, v18, v15);
  uint64_t v30 = &v25[*(int *)(v22 + 36)];
  *(void *)uint64_t v30 = partial apply for closure #1 in LazySequenceProtocol.compactMap<A>(_:);
  *((void *)v30 + 1) = v28;
  uint64_t v31 = swift_allocObject((uint64_t)&unk_189B783E8, 0x28uLL, 7uLL);
  v31[2] = a3;
  uint64_t v31[3] = v29;
  v31[4] = a5;
  uint64_t v32 = v42;
  (*(void (**)(uint64_t, char *, uint64_t))(v23 + 32))(v42, v25, v22);
  uint64_t v34 = swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>, v22, v33);
  uint64_t v35 = (void *)(v32 + *(int *)(type metadata accessor for LazyMapSequence(0LL, v22, v29, v34) + 44));
  *uint64_t v35 = closure #2 in LazySequenceProtocol.compactMap<A>(_:)partial apply;
  v35[1] = v31;
  return swift_retain(v43, v36, v37, v38);
}

uint64_t LazySequenceProtocol<>.joined()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  size_t v10 = (char *)&v12 - v9;
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v3, a1);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v8 + 32))(a3, v10, AssociatedTypeWitness);
}

unint64_t *LazySequenceProtocol.compactMap<A>(_:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v41 = a4;
  uint64_t v42 = a6;
  uint64_t v43 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v13 = type metadata accessor for Optional((const char *)0xFF, a4, v11, v12);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  (uint64_t)&associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v15 = type metadata accessor for LazyMapSequence(0LL, AssociatedTypeWitness, v13, AssociatedConformanceWitness);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v15, v19);
  uint64_t v22 = type metadata accessor for LazyFilterSequence(0LL, v15, WitnessTable, v21);
  uint64_t v23 = *(void *)(v22 - 8);
  MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v40 - v24;
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  uint64_t v26 = &v18[*(int *)(v15 + 44)];
  uint64_t v27 = v43;
  *(void *)uint64_t v26 = a1;
  *((void *)v26 + 1) = v27;
  uint64_t v28 = swift_allocObject((uint64_t)&unk_189B782F8, 0x28uLL, 7uLL);
  uint64_t v29 = v41;
  v28[2] = a3;
  void v28[3] = v29;
  v28[4] = a5;
  (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v25, v18, v15);
  uint64_t v30 = &v25[*(int *)(v22 + 36)];
  *(void *)uint64_t v30 = partial apply for closure #1 in LazySequenceProtocol.compactMap<A>(_:);
  *((void *)v30 + 1) = v28;
  uint64_t v31 = (uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X8>))swift_allocObject( (uint64_t)&unk_189B78320,  0x28uLL,  7uLL);
  *((void *)v31 + 2) = a3;
  *((void *)v31 + 3) = v29;
  *((void *)v31 + 4) = a5;
  uint64_t v32 = v42;
  (*(void (**)(uint64_t, char *, uint64_t))(v23 + 32))(v42, v25, v22);
  uint64_t v34 = swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>, v22, v33);
  uint64_t v35 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v32
                                                                 + *(int *)(type metadata accessor for LazyMapSequence( 0LL,  v22,  v29,  v34)
                                                                          + 44));
  *uint64_t v35 = partial apply for closure #2 in LazySequenceProtocol.compactMap<A>(_:);
  v35[1] = v31;
  return swift_retain(v43, v36, v37, v38);
}

uint64_t closure #2 in LazySequenceProtocol.compactMap<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = type metadata accessor for Optional(0LL, a2, a2, a3);
  MEMORY[0x1895F8858](v7);
  uint64_t v9 = (char *)&v13 - v8;
  (*(void (**)(char *, uint64_t))(v10 + 16))((char *)&v13 - v8, a1);
  uint64_t v11 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v11 + 48))(v9, 1LL, a2) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/FlatMap.swift",  19LL,  2,  0x31uLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v11 + 32))(a4, v9, a2);
}

uint64_t (*FlattenSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t FlattenSequence.init(_base:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a3, a1);
}

uint64_t FlattenSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t FlattenSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*FlattenSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*FlattenSequence.Iterator._inner.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t FlattenSequence.Iterator.init(_base:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = a5 + *(int *)(type metadata accessor for FlattenSequence.Iterator(0LL, a2, (uint64_t)a3, (uint64_t)a4) + 44);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v12 - 8) + 56LL))( v10,  1LL,  1LL,  v12);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v13 - 8) + 32LL))(a5, a1, v13);
}

uint64_t specialized FlattenSequence.Iterator.next()()
{
  unint64_t v1 = v0[7];
  if (!v1) {
    goto LABEL_6;
  }
  while (1)
  {
    Swift::UInt64 rawBits = v0[8];
    unint64_t v3 = v0[6];
    if ((v1 & 0x2000000000000000LL) != 0) {
      unint64_t v4 = HIBYTE(v1) & 0xF;
    }
    else {
      unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 != 4 * v4)
    {
      uint64_t v9 = (v3 >> 59) & 1;
      if ((v1 & 0x1000000000000000LL) == 0) {
        LOBYTE(v9) = 1;
      }
      if ((v0[8] & 0xCLL) == 4LL << v9) {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
      }
      Swift::UInt64 v10 = rawBits >> 16;
      if (rawBits >> 16 >= v4)
      {
        unint64_t v18 = 228LL;
      }

      else
      {
        if ((v1 & 0x1000000000000000LL) != 0)
        {
          LOBYTE(v1) = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        }

        else if ((v1 & 0x2000000000000000LL) != 0)
        {
          v20[0] = v3;
          v20[1] = v1 & 0xFFFFFFFFFFFFFFLL;
          LOBYTE(v1) = *((_BYTE *)v20 + v10);
        }

        else
        {
          if ((v3 & 0x1000000000000000LL) != 0) {
            uint64_t v11 = (_BYTE *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            uint64_t v11 = _StringObject.sharedUTF8.getter(v3, v1);
          }
          LOBYTE(v1) = v11[v10];
        }

        unint64_t v12 = v0[6];
        unint64_t v13 = v0[7];
        Swift::UInt64 v14 = v0[8];
        uint64_t v15 = (v12 >> 59) & 1;
        if ((v13 & 0x1000000000000000LL) == 0) {
          LOBYTE(v15) = 1;
        }
        if ((v0[8] & 0xCLL) == 4LL << v15)
        {
          Swift::UInt64 v14 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v14)._rawBits;
          if ((v13 & 0x1000000000000000LL) == 0) {
            goto LABEL_24;
          }
        }

        else if ((v13 & 0x1000000000000000LL) == 0)
        {
LABEL_24:
          Swift::UInt64 v16 = (v14 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_25:
          int v8 = 0;
          v0[8] = v16;
          return v1 | (v8 << 8);
        }

        unint64_t v19 = HIBYTE(v13) & 0xF;
        if ((v13 & 0x2000000000000000LL) == 0) {
          unint64_t v19 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (v19 > v14 >> 16)
        {
          Swift::UInt64 v16 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v14)._rawBits;
          goto LABEL_25;
        }

        unint64_t v18 = 144LL;
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v18,  0);
    }

{
  void *v0;
  unint64_t v1;
  Swift::UInt64 rawBits;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  Swift::UInt64 v10;
  _BYTE *v11;
  unint64_t v12;
  unint64_t v13;
  Swift::UInt64 v14;
  uint64_t v15;
  Swift::UInt64 v16;
  unint64_t v18;
  unint64_t v19;
  void v20[3];
  unint64_t v1 = v0[8];
  if (!v1) {
    goto LABEL_6;
  }
  while (1)
  {
    Swift::UInt64 rawBits = v0[9];
    unint64_t v3 = v0[7];
    if ((v1 & 0x2000000000000000LL) != 0) {
      unint64_t v4 = HIBYTE(v1) & 0xF;
    }
    else {
      unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 != 4 * v4)
    {
      uint64_t v9 = (v3 >> 59) & 1;
      if ((v1 & 0x1000000000000000LL) == 0) {
        LOBYTE(v9) = 1;
      }
      if ((v0[9] & 0xCLL) == 4LL << v9) {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
      }
      Swift::UInt64 v10 = rawBits >> 16;
      if (rawBits >> 16 >= v4)
      {
        unint64_t v18 = 228LL;
      }

      else
      {
        if ((v1 & 0x1000000000000000LL) != 0)
        {
          LOBYTE(v1) = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        }

        else if ((v1 & 0x2000000000000000LL) != 0)
        {
          v20[0] = v3;
          v20[1] = v1 & 0xFFFFFFFFFFFFFFLL;
          LOBYTE(v1) = *((_BYTE *)v20 + v10);
        }

        else
        {
          if ((v3 & 0x1000000000000000LL) != 0) {
            uint64_t v11 = (_BYTE *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            uint64_t v11 = _StringObject.sharedUTF8.getter(v3, v1);
          }
          LOBYTE(v1) = v11[v10];
        }

        unint64_t v12 = v0[7];
        unint64_t v13 = v0[8];
        Swift::UInt64 v14 = v0[9];
        uint64_t v15 = (v12 >> 59) & 1;
        if ((v13 & 0x1000000000000000LL) == 0) {
          LOBYTE(v15) = 1;
        }
        if ((v0[9] & 0xCLL) == 4LL << v15)
        {
          Swift::UInt64 v14 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v14)._rawBits;
          if ((v13 & 0x1000000000000000LL) == 0) {
            goto LABEL_24;
          }
        }

        else if ((v13 & 0x1000000000000000LL) == 0)
        {
LABEL_24:
          Swift::UInt64 v16 = (v14 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_25:
          int v8 = 0;
          v0[9] = v16;
          return v1 | (v8 << 8);
        }

        unint64_t v19 = HIBYTE(v13) & 0xF;
        if ((v13 & 0x2000000000000000LL) == 0) {
          unint64_t v19 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (v19 > v14 >> 16)
        {
          Swift::UInt64 v16 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v14)._rawBits;
          goto LABEL_25;
        }

        unint64_t v18 = 144LL;
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v18,  0);
    }

{
  unint64_t *v0;
  unint64_t *v1;
  unint64_t v2;
  Swift::UInt64 rawBits;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  void (*v8)(void *__return_ptr, unint64_t *);
  unint64_t v9;
  Swift::UInt8 v10;
  int v11;
  uint64_t v12;
  Swift::UInt64 v13;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  Swift::UInt64 v17;
  uint64_t v18;
  Swift::UInt64 v19;
  unint64_t v21;
  unint64_t v22;
  void v23[2];
  unint64_t v24;
  uint64_t v25;
  unint64_t v1 = v0;
  int v2 = v0[5];
  if (!v2) {
    goto LABEL_6;
  }
LABEL_2:
  Swift::UInt64 rawBits = v1[6];
  unint64_t v4 = v1[4];
  if ((v2 & 0x2000000000000000LL) != 0) {
    uint64_t v5 = HIBYTE(v2) & 0xF;
  }
  else {
    uint64_t v5 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (rawBits >> 14 != 4 * v5)
  {
    unint64_t v12 = (v4 >> 59) & 1;
    if ((v2 & 0x1000000000000000LL) == 0) {
      LOBYTE(v12) = 1;
    }
    if ((v1[6] & 0xC) == 4LL << v12) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    unint64_t v13 = rawBits >> 16;
    if (rawBits >> 16 >= v5)
    {
      uint64_t v21 = 228LL;
    }

    else
    {
      if ((v2 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v10 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
      }

      else if ((v2 & 0x2000000000000000LL) != 0)
      {
        uint64_t v24 = v4;
        uint64_t v25 = v2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt64 v10 = *((_BYTE *)&v24 + v13);
      }

      else
      {
        if ((v4 & 0x1000000000000000LL) != 0) {
          Swift::UInt64 v14 = (_BYTE *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          Swift::UInt64 v14 = _StringObject.sharedUTF8.getter(v4, v2);
        }
        Swift::UInt64 v10 = v14[v13];
      }

      uint64_t v15 = v1[4];
      Swift::UInt64 v16 = v1[5];
      uint64_t v17 = v1[6];
      unint64_t v18 = (v15 >> 59) & 1;
      if ((v16 & 0x1000000000000000LL) == 0) {
        LOBYTE(v18) = 1;
      }
      if ((v1[6] & 0xC) == 4LL << v18)
      {
        uint64_t v17 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v17)._rawBits;
        if ((v16 & 0x1000000000000000LL) == 0) {
          goto LABEL_25;
        }
      }

      else if ((v16 & 0x1000000000000000LL) == 0)
      {
LABEL_25:
        unint64_t v19 = (v17 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_26:
        uint64_t v11 = 0;
        v1[6] = v19;
        return v10 | (v11 << 8);
      }

      uint64_t v22 = HIBYTE(v16) & 0xF;
      if ((v16 & 0x2000000000000000LL) == 0) {
        uint64_t v22 = v15 & 0xFFFFFFFFFFFFLL;
      }
      if (v22 > v17 >> 16)
      {
        unint64_t v19 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v17)._rawBits;
        goto LABEL_26;
      }

      uint64_t v21 = 144LL;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v21,  0);
  }

{
  void *v0;
  unint64_t v1;
  Swift::UInt64 rawBits;
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  Swift::UInt64 v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  Swift::UInt64 v11;
  uint64_t v12;
  Swift::UInt64 v13;
  unint64_t v15;
  unint64_t v16;
  void v17[3];
  unint64_t v1 = v0[3];
  if (!v1) {
    goto LABEL_7;
  }
  Swift::UInt64 rawBits = v0[4];
  unint64_t v3 = v0[2];
  if ((v1 & 0x2000000000000000LL) != 0) {
    unint64_t v4 = HIBYTE(v1) & 0xF;
  }
  else {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (rawBits >> 14 != 4 * v4)
  {
    unint64_t v6 = (v3 >> 59) & 1;
    if ((v1 & 0x1000000000000000LL) == 0) {
      LOBYTE(v6) = 1;
    }
    if ((v0[4] & 0xCLL) == 4LL << v6) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    uint64_t v7 = rawBits >> 16;
    if (rawBits >> 16 >= v4)
    {
      uint64_t v15 = 228LL;
    }

    else
    {
      if ((v1 & 0x1000000000000000LL) != 0)
      {
        LOBYTE(v1) = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
      }

      else if ((v1 & 0x2000000000000000LL) != 0)
      {
        v17[0] = v3;
        v17[1] = v1 & 0xFFFFFFFFFFFFFFLL;
        LOBYTE(v1) = *((_BYTE *)v17 + v7);
      }

      else
      {
        if ((v3 & 0x1000000000000000LL) != 0) {
          int v8 = (_BYTE *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          int v8 = _StringObject.sharedUTF8.getter(v3, v1);
        }
        LOBYTE(v1) = v8[v7];
      }

      uint64_t v9 = v0[2];
      Swift::UInt64 v10 = v0[3];
      uint64_t v11 = v0[4];
      unint64_t v12 = (v9 >> 59) & 1;
      if ((v10 & 0x1000000000000000LL) == 0) {
        LOBYTE(v12) = 1;
      }
      if ((v0[4] & 0xCLL) == 4LL << v12)
      {
        uint64_t v11 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v11)._rawBits;
        if ((v10 & 0x1000000000000000LL) == 0) {
          goto LABEL_23;
        }
      }

      else if ((v10 & 0x1000000000000000LL) == 0)
      {
LABEL_23:
        unint64_t v13 = (v11 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_24:
        uint64_t v5 = 0;
        v0[4] = v13;
        return v1 | (v5 << 8);
      }

      Swift::UInt64 v16 = HIBYTE(v10) & 0xF;
      if ((v10 & 0x2000000000000000LL) == 0) {
        Swift::UInt64 v16 = v9 & 0xFFFFFFFFFFFFLL;
      }
      if (v16 > v11 >> 16)
      {
        unint64_t v13 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v11)._rawBits;
        goto LABEL_24;
      }

      uint64_t v15 = 144LL;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v15,  0);
  }

  LOBYTE(v1) = 0;
LABEL_7:
  uint64_t v5 = 1;
  return v1 | (v5 << 8);
}

uint64_t specialized FlattenSequence.Iterator.next()(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  void (*v15)(unint64_t *__return_ptr, void *);
  Swift::UInt64 v16;
  Swift::UInt8 v17;
  int v18;
  uint64_t v19;
  Swift::UInt64 v20;
  _BYTE *v21;
  Swift::UInt64 v22;
  Swift::UInt64 v23;
  Swift::UInt64 v24;
  uint64_t v25;
  Swift::UInt64 v26;
  unint64_t v28;
  unint64_t v29;
  Swift::UInt8 v30;
  Swift::String::Index v31;
  unint64_t v32;
  Swift::UInt8 v33;
  Swift::UInt64 v34;
  Swift::UInt64 v35;
  void v36[2];
  unint64_t v37;
  uint64_t v38;
  uint64_t v5 = v4;
  unint64_t rawBits = v4[5]._rawBits;
  if (!rawBits) {
    goto LABEL_5;
  }
LABEL_2:
  Swift::UInt64 v7 = v5[6]._rawBits;
  a2 = v5[4]._rawBits;
  unint64_t v8 = HIBYTE(rawBits) & 0xF;
  if ((rawBits & 0x2000000000000000LL) == 0) {
    unint64_t v8 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >> 14 != 4 * v8)
  {
    unint64_t v19 = (a2 >> 59) & 1;
    if ((rawBits & 0x1000000000000000LL) == 0) {
      LOBYTE(v19) = 1;
    }
    if ((v5[6]._rawBits & 0xC) == 4LL << v19)
    {
      uint64_t v34 = v5[4]._rawBits;
      uint64_t v28 = v8;
      Swift::UInt64 v7 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v7)._rawBits;
      unint64_t v8 = v28;
      a2 = v34;
    }

    uint64_t v20 = v7 >> 16;
    if (v7 >> 16 >= v8)
    {
      uint64_t v29 = 228LL;
    }

    else
    {
      if ((rawBits & 0x1000000000000000LL) != 0)
      {
        uint64_t v17 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)v7);
      }

      else if ((rawBits & 0x2000000000000000LL) != 0)
      {
        uint64_t v37 = a2;
        unint64_t v38 = rawBits & 0xFFFFFFFFFFFFFFLL;
        uint64_t v17 = *((_BYTE *)&v37 + v20);
      }

      else
      {
        if ((a2 & 0x1000000000000000LL) != 0) {
          uint64_t v21 = (_BYTE *)((rawBits & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          uint64_t v21 = _StringObject.sharedUTF8.getter(a2, rawBits);
        }
        uint64_t v17 = v21[v20];
      }

      uint64_t v23 = v5[4]._rawBits;
      uint64_t v22 = v5[5]._rawBits;
      uint64_t v24 = v5[6]._rawBits;
      uint64_t v25 = (v23 >> 59) & 1;
      if ((v22 & 0x1000000000000000LL) == 0) {
        LOBYTE(v25) = 1;
      }
      if ((v5[6]._rawBits & 0xC) == 4LL << v25)
      {
        uint64_t v30 = v17;
        uint64_t v35 = v5[5]._rawBits;
        v31._unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v5[6])._rawBits;
        uint64_t v22 = v35;
        uint64_t v24 = v31._rawBits;
        uint64_t v17 = v30;
        if ((v35 & 0x1000000000000000LL) == 0) {
          goto LABEL_26;
        }
      }

      else if ((v22 & 0x1000000000000000LL) == 0)
      {
LABEL_26:
        uint64_t v26 = (v24 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_27:
        unint64_t v18 = 0;
        v5[6]._unint64_t rawBits = v26;
        return v17 | (v18 << 8);
      }

      if ((v22 & 0x2000000000000000LL) != 0) {
        uint64_t v32 = HIBYTE(v22) & 0xF;
      }
      else {
        uint64_t v32 = v23 & 0xFFFFFFFFFFFFLL;
      }
      if (v32 > v24 >> 16)
      {
        uint64_t v33 = v17;
        uint64_t v26 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v24)._rawBits;
        uint64_t v17 = v33;
        goto LABEL_27;
      }

      uint64_t v29 = 144LL;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v29,  0);
  }

uint64_t FlattenSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v57 = a2;
  unint64_t v4 = *(const char **)(a1 + 24);
  uint64_t v66 = *(void *)(a1 + 16);
  uint64_t v67 = v4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v66,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v6, v7);
  uint64_t v64 = *(void *)(v8 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  Swift::UInt64 v11 = (char *)&v56 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v65 = (char *)&v56 - v12;
  unint64_t v13 = *(const char **)(a1 + 32);
  unint64_t v61 = swift_getAssociatedTypeWitness( 255LL,  v13,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v16 = type metadata accessor for Optional(0LL, v61, v14, v15);
  uint64_t v58 = *(void *)(v16 - 8);
  uint64_t v59 = v16;
  MEMORY[0x1895F8858](v16);
  uint64_t v60 = (char *)&v56 - v17;
  size_t v71 = v13;
  unint64_t v73 = AssociatedTypeWitness;
  unint64_t v18 = v11;
  unint64_t v19 = swift_getAssociatedTypeWitness( 255LL,  v13,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v22 = type metadata accessor for Optional(0LL, v19, v20, v21);
  uint64_t v23 = *(void *)(v22 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v63 = (char *)&v56 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v70 = (char *)&v56 - v27;
  uint64_t v28 = *(int *)(a1 + 44);
  uint64_t v68 = v2;
  uint64_t v29 = (char *)(v2 + v28);
  size_t v69 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  uint64_t v72 = v29;
  for (uint64_t i = v26; ; (*(void (**)(char *, char *, uint64_t))(v36 + 40))(v72, v53, i))
  {
    uint64_t v30 = v70;
    v69(v70, (uint64_t)v29, v22);
    uint64_t v31 = *(void *)(v19 - 8);
    uint64_t v32 = *(uint64_t (**)(char *, uint64_t, unint64_t))(v31 + 48);
    int v33 = v32(v30, 1LL, v19);
    (*(void (**)(char *, uint64_t))(v23 + 8))(v30, v22);
    if (v33 == 1) {
      goto LABEL_6;
    }
    if (v32(v72, 1LL, v19) == 1)
    {
      unint64_t v55 = 76LL;
LABEL_14:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Flatten.swift",  19LL,  2,  v55,  0);
    }

    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v71,  v73,  v19,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v35 = v60;
    (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( v19,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t))(v58 + 8))(v35, v59);
LABEL_6:
    uint64_t v36 = v23;
    uint64_t v37 = v18;
    uint64_t v38 = v8;
    uint64_t v40 = v66;
    uint64_t v39 = v67;
    unint64_t v41 = swift_getAssociatedTypeWitness( 255LL,  v67,  v66,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    unint64_t v42 = swift_getAssociatedConformanceWitness( (uint64_t)v39,  v40,  v41,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v43 = *(void (**)(unint64_t *, unint64_t))(v42 + 16);
    uint64_t v44 = swift_checkMetadataState(0LL, v41);
    uint64_t v45 = v65;
    v43(v44, v42);
    uint64_t v46 = v73;
    uint64_t v47 = *(unsigned int (**)(char *, uint64_t, unint64_t))(*(void *)(v73 - 8) + 48LL);
    if (v47(v45, 1LL, v73) == 1)
    {
      (*(void (**)(char *, uint64_t))(v64 + 8))(v45, v38);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v61 - 8) + 56LL))(v57, 1LL, 1LL);
    }

    uint64_t v48 = v64;
    unint64_t v18 = v37;
    uint64_t v49 = v37;
    uint64_t v50 = v45;
    uint64_t v51 = v45;
    uint64_t v8 = v38;
    (*(void (**)(char *, char *, uint64_t))(v64 + 16))(v49, v50, v38);
    if (v47(v18, 1LL, v46) == 1)
    {
      unint64_t v55 = 85LL;
      goto LABEL_14;
    }

    uint64_t v52 = v46;
    uint64_t v53 = v63;
    (*((void (**)(uint64_t))v71 + 4))(v52);
    (*(void (**)(char *, uint64_t))(v48 + 8))(v51, v38);
    (*(void (**)(char *, void, uint64_t, unint64_t))(v31 + 56))(v53, 0LL, 1LL, v19);
    uint64_t v23 = v36;
    uint64_t v29 = v72;
    uint64_t v22 = i;
  }

  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v58 + 32))(v57, v35, v59);
}

uint64_t FlattenSequence.makeIterator()@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = a1[2];
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *))(v6 + 32))((char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v7 = a1[3];
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v4, v7);
  uint64_t v8 = (const char *)a1[4];
  uint64_t v9 = a2 + *(int *)(type metadata accessor for FlattenSequence.Iterator(0LL, v4, v7, (uint64_t)v8) + 44);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v11 - 8) + 56LL))( v9,  1LL,  1LL,  v11);
}

uint64_t Sequence<>.joined()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 32LL))(a2, v2);
}

uint64_t FlattenSequence<>.Index._outer.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index,  a2);
}

uint64_t FlattenSequence<>.Index._inner.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 44);
  uint64_t v5 = *(const char **)(a1 + 32);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(*(void *)(a1 + 24) + 8LL),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v7 = swift_getAssociatedTypeWitness( 255LL,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = type metadata accessor for Optional(0LL, v7, v8, v9);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 16LL))(a2, v4, v10);
}

uint64_t FlattenSequence<>.Index.init(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a6,  a1,  AssociatedTypeWitness);
  uint64_t v13 = a6 + *(int *)(type metadata accessor for FlattenSequence<>.Index(0LL, a3, a4, (uint64_t)a5) + 44);
  unint64_t v14 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v15 = swift_getAssociatedTypeWitness( 255LL,  a5,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v18 = type metadata accessor for Optional(0LL, v15, v16, v17);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v18 - 8) + 32LL))(v13, a2, v18);
}

uint64_t static FlattenSequence<>.Index.== infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v7 = a3;
  uint64_t v56 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v53 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v46 = (char *)&v45 - v10;
  uint64_t v54 = v11;
  uint64_t v14 = type metadata accessor for Optional(0LL, v11, v12, v13);
  uint64_t v52 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v49 = (char *)&v45 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v14, v14, 0LL, 0LL);
  uint64_t v50 = *(TupleTypeMetadata2 - 1);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v51 = (char *)&v45 - v16;
  uint64_t v47 = a5;
  uint64_t v17 = type metadata accessor for FlattenSequence<>.Index(0LL, v7, a4, (uint64_t)a5);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v45 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v45 - v22;
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  v7,  v24,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v26 = v56;
  LOBYTE(v7) = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness
                                                                                         + 8)
                                                                             + 8LL))( a1,  v56,  v24);
  uint64_t v27 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 16);
  v27(v23, a1, v17);
  v27(v21, v26, v17);
  if ((v7 & 1) == 0)
  {
    uint64_t v39 = *(void (**)(char *, uint64_t))(v18 + 8);
    v39(v21, v17);
    v39(v23, v17);
LABEL_9:
    char v38 = 0;
    return v38 & 1;
  }

  uint64_t v28 = *(int *)(v17 + 44);
  uint64_t v29 = &v21[v28];
  uint64_t v30 = v51;
  uint64_t v31 = v52;
  uint64_t v32 = &v51[*((int *)TupleTypeMetadata2 + 12)];
  int v33 = *(void (**)(char *, char *, uint64_t))(v52 + 16);
  v33(v51, &v23[v28], v14);
  uint64_t v34 = *(void (**)(char *, uint64_t))(v18 + 8);
  v34(v23, v17);
  v33(v32, v29, v14);
  v34(v21, v17);
  uint64_t v36 = v53;
  uint64_t v35 = v54;
  uint64_t v37 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v53 + 48);
  if (v37(v30, 1LL, v54) != 1)
  {
    uint64_t v40 = v49;
    v33(v49, v30, v14);
    if (v37(v32, 1LL, v35) != 1)
    {
      unint64_t v42 = v46;
      (*(void (**)(char *, char *, uint64_t))(v36 + 32))(v46, v32, v35);
      unint64_t v43 = swift_getAssociatedConformanceWitness( (uint64_t)v47,  AssociatedTypeWitness,  v35,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
      char v38 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v43 + 8) + 8LL))(v40, v42, v35);
      uint64_t v44 = *(void (**)(char *, uint64_t))(v36 + 8);
      v44(v42, v35);
      v44(v40, v35);
      (*(void (**)(char *, uint64_t))(v31 + 8))(v30, v14);
      return v38 & 1;
    }

    (*(void (**)(char *, uint64_t))(v36 + 8))(v40, v35);
    goto LABEL_8;
  }

  if (v37(v32, 1LL, v35) != 1)
  {
LABEL_8:
    (*(void (**)(char *, unint64_t *))(v50 + 8))(v30, TupleTypeMetadata2);
    goto LABEL_9;
  }

  (*(void (**)(char *, uint64_t))(v31 + 8))(v30, v14);
  char v38 = 1;
  return v38 & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance FlattenSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static FlattenSequence<>.Index.== infix(_:_:)( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24),  *(const char **)(a3 + 32));
}

BOOL specialized static FlattenSequence<>.Index.< infix(_:_:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  BOOL v6 = a1 < a4;
  if (a1 != a4) {
    return v6;
  }
  if ((a3 & 1) != 0)
  {
    if ((a6 & 1) != 0) {
      return 0LL;
    }
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

  if ((a6 & 1) != 0) {
    goto LABEL_10;
  }
  return a2 < a5;
}

BOOL specialized static FlattenSequence<>.Index.< infix(_:_:)( uint64_t a1, unint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6)
{
  if (a1 != a4) {
    return a1 < a4;
  }
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0) {
      return a2 >> 14 < a5 >> 14;
    }
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

  if ((a6 & 1) == 0) {
    goto LABEL_8;
  }
  return 0LL;
}

uint64_t static FlattenSequence<>.Index.< infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v75 = type metadata accessor for FlattenSequence<>.Index(0LL, a3, a4, (uint64_t)a5);
  uint64_t v72 = *(void *)(v75 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v75);
  size_t v71 = (char *)&v61 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  unint64_t v73 = (char *)&v61 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v76 = (char *)&v61 - v14;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v65 = a5;
  unint64_t v15 = swift_getAssociatedTypeWitness( 255LL,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v74 = type metadata accessor for Optional(0LL, v15, v16, v17);
  uint64_t v18 = *(void *)(v74 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v74);
  size_t v69 = (char *)&v61 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v70 = (char *)&v61 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v68 = (void (*)(char *, uint64_t))((char *)&v61 - v24);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v61 - v26;
  uint64_t v28 = *(void **)(v15 - 8);
  uint64_t v29 = MEMORY[0x1895F8858](v25);
  uint64_t v63 = (char *)&v61 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v29);
  uint64_t v67 = (char *)&v61 - v31;
  unint64_t v32 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v33 = a2;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  v32,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v35 = a1;
  if (((*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                      + 8LL))( a1,  v33,  v32) & 1) == 0)
    return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 16))( a1,  v33,  v32,  AssociatedConformanceWitness) & 1;
  uint64_t v66 = v33;
  uint64_t v37 = v74;
  uint64_t v36 = v75;
  char v38 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 16);
  v38(v27, v35 + *(int *)(v75 + 44), v74);
  uint64_t v39 = (uint64_t (*)(char *, uint64_t, unint64_t))v28[6];
  int v40 = v39(v27, 1LL, v15);
  uint64_t v62 = v38;
  if (v40 == 1)
  {
    uint64_t v68 = *(void (**)(char *, uint64_t))(v18 + 8);
    v68(v27, v37);
  }

  else
  {
    uint64_t v61 = v35;
    unint64_t v42 = (void (*)(char *, char *, unint64_t))v28[4];
    unint64_t v43 = v67;
    v42(v67, v27, v15);
    uint64_t v44 = (char *)v68;
    v38((char *)v68, v66 + *(int *)(v36 + 44), v37);
    if (v39(v44, 1LL, v15) != 1)
    {
      uint64_t v58 = v63;
      v42(v63, v44, v15);
      unint64_t v59 = swift_getAssociatedConformanceWitness( (uint64_t)v65,  AssociatedTypeWitness,  v15,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
      char v57 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v59 + 16))( v43,  v58,  v15,  v59);
      uint64_t v60 = (void (*)(char *, unint64_t))v28[1];
      v60(v58, v15);
      v60(v43, v15);
      return v57 & 1;
    }

    ((void (*)(char *, unint64_t))v28[1])(v43, v15);
    uint64_t v68 = *(void (**)(char *, uint64_t))(v18 + 8);
    v68(v44, v37);
    uint64_t v35 = v61;
  }

  uint64_t v45 = v72;
  uint64_t v46 = *(void (**)(char *, uint64_t, uint64_t))(v72 + 16);
  uint64_t v47 = v76;
  v46(v76, v35, v36);
  uint64_t v48 = v73;
  v46(v73, v66, v36);
  uint64_t v49 = &v47[*(int *)(v36 + 44)];
  uint64_t v50 = v70;
  uint64_t v51 = (void (*)(char *, char *, uint64_t))v62;
  v62(v70, (uint64_t)v49, v37);
  int v52 = v39(v50, 1LL, v15);
  v68(v50, v37);
  uint64_t v53 = v71;
  v46(v71, (uint64_t)v48, v36);
  if (v52 != 1)
  {
    (*(void (**)(char *, uint64_t))(v45 + 8))(v53, v36);
LABEL_14:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

  uint64_t v54 = v39;
  unint64_t v55 = v69;
  v51(v69, &v53[*(int *)(v36 + 44)], v37);
  uint64_t v56 = *(void (**)(char *, uint64_t))(v45 + 8);
  v56(v53, v36);
  LODWORD(v54) = v54(v55, 1LL, v15);
  v68(v55, v37);
  if ((_DWORD)v54 != 1) {
    goto LABEL_14;
  }
  v56(v48, v36);
  v56(v76, v36);
  char v57 = 0;
  return v57 & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance FlattenSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static FlattenSequence<>.Index.< infix(_:_:)( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24),  *(const char **)(a3 + 32));
}

void FlattenSequence<>.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = a1;
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(const char **)(a2 + 32);
  uint64_t v26 = a4;
  uint64_t v27 = (const char *)v6;
  uint64_t v8 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v25 = (char *)&v24 - v12;
  uint64_t v15 = type metadata accessor for Optional(0LL, v10, v13, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v24 - v17;
  uint64_t v19 = *(void (**)(uint64_t, unint64_t, uint64_t))(a3 + 24);
  uint64_t v20 = v28;
  unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  v27,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v22 = v29;
  v19(v20, v21, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))(v18, v22 + *(int *)(a2 + 44), v15);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v11 + 48))(v18, 1LL, v10) == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    uint64_t v23 = v25;
    (*(void (**)(char *, char *, unint64_t))(v11 + 32))(v25, v18, v10);
    Hasher._combine(_:)(1u);
    (*(void (**)(uint64_t, unint64_t))(v26 + 24))(v20, v10);
    (*(void (**)(char *, unint64_t))(v11 + 8))(v23, v10);
  }

Swift::Int FlattenSequence<>.Index<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = a3;
  uint64_t v5 = *(const char **)(a1 + 32);
  uint64_t v25 = *(const char ***)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v25[1],  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v23 = (char *)&v22 - v10;
  uint64_t v13 = type metadata accessor for Optional(0LL, v8, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v22 - v15;
  v27[0] = 0LL;
  v27[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v27[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v27[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v27[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t))(a2 + 24);
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v25,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v19 = v26;
  v17(v27, v18, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v16, v19 + *(int *)(a1 + 44), v13);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v9 + 48))(v16, 1LL, v8) == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    uint64_t v20 = v23;
    (*(void (**)(char *, char *, unint64_t))(v9 + 32))(v23, v16, v8);
    Hasher._combine(_:)(1u);
    (*(void (**)(void *, unint64_t))(v24 + 24))(v27, v8);
    (*(void (**)(char *, unint64_t))(v9 + 8))(v20, v8);
  }

  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> FlattenSequence<A><>.Index( uint64_t a1, uint64_t a2)
{
  return FlattenSequence<>.Index<>.hashValue.getter(a1, *(void *)(a2 - 8), *(void *)(a2 - 16));
}

void protocol witness for Hashable.hash(into:) in conformance <> FlattenSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t, uint64_t))FlattenSequence<>.Index<>.hash(into:));
}

uint64_t specialized FlattenSequence<>.startIndex.getter( uint64_t a1, unint64_t a2, void (*a3)(void *__return_ptr, Swift::UInt32 *))
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v6 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v6)
  {
    uint64_t v7 = 15LL;
    v8._unint64_t rawBits = 15LL;
    specialized LazyMapSequence<>.subscript.getter(v8, a1, a2, a3);
  }

  else if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0)
  {
    return 11LL;
  }

  else
  {
    return 7LL;
  }

  return v7;
}

Swift::UInt64 specialized FlattenSequence<>.startIndex.getter( uint64_t a1, unint64_t a2, void (*a3)(uint64_t *__return_ptr, void *), unint64_t *a4)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  BOOL v23 = (a1 & 0x800000000000000LL) == 0;
  v24._Swift::UInt64 rawBits = 15LL;
  if (v5)
  {
    Swift::UInt64 rawBits = 15LL;
    while (1)
    {
      v10._Swift::UInt64 rawBits = rawBits;
      uint64_t v11 = specialized LazyMapSequence<>.subscript.getter(v10, a1, a2, a3);
      unint64_t v13 = v12;
      swift_bridgeObjectRelease(v12);
      uint64_t v17 = HIBYTE(v13) & 0xF;
      if ((v13 & 0x2000000000000000LL) == 0) {
        uint64_t v17 = v11 & 0xFFFFFFFFFFFFLL;
      }
      if (v17) {
        break;
      }
      swift_bridgeObjectRetain(a2, v14, v15, v16);
      swift_retain(a4, v18, v19, v20);
      specialized LazyMapSequence<>.formIndex(after:)(&v24, a1, a2);
      swift_release((uint64_t)a4);
      swift_bridgeObjectRelease(a2);
      Swift::UInt64 rawBits = v24._rawBits;
      if (4 * v5 == v24._rawBits >> 14) {
        goto LABEL_10;
      }
    }
  }

  else
  {
LABEL_10:
    uint64_t v21 = 7LL;
    if (((a2 >> 60) & v23) != 0) {
      uint64_t v21 = 11LL;
    }
    return (v5 << 16) | v21;
  }

  return rawBits;
}

Swift::UInt64 specialized FlattenSequence<>.startIndex.getter()
{
  __int128 v1 = v0[2];
  __int128 v19 = v0[1];
  __int128 v20 = v1;
  __int128 v18 = *v0;
  v21[0] = v18;
  v21[1] = v19;
  uint64_t v2 = (unint64_t *)*((void *)&v1 + 1);
  uint64_t v3 = *((void *)&v18 + 1);
  Swift::UInt64 v4 = v18;
  Swift::UInt64 v17 = v18;
  uint64_t v5 = *((void *)&v18 + 1) >> 14;
  if (*((void *)&v18 + 1) >> 14 != (unint64_t)v18 >> 14)
  {
    while (1)
    {
      uint64_t v6 = specialized LazyMapSequence<>.subscript.getter(v4);
      unint64_t v8 = v7;
      swift_bridgeObjectRelease(v7);
      uint64_t v12 = HIBYTE(v8) & 0xF;
      if ((v8 & 0x2000000000000000LL) == 0) {
        uint64_t v12 = v6 & 0xFFFFFFFFFFFFLL;
      }
      if (v12) {
        break;
      }
      outlined retain of Substring((uint64_t)v21, v9, v10, v11);
      swift_retain(v2, v13, v14, v15);
      specialized LazyMapSequence<>.formIndex(after:)(&v17);
      outlined release of Substring((uint64_t)v21);
      swift_release((uint64_t)v2);
      Swift::UInt64 v4 = v17;
      if (v5 == v17 >> 14) {
        return v3;
      }
    }

    return v4;
  }

  return v3;
}

uint64_t FlattenSequence<>.startIndex.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, char *a4@<X8>)
{
  char v57 = a4;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v62 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v49 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v10 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v64 = a3;
  unint64_t v56 = swift_getAssociatedTypeWitness( 255LL,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = type metadata accessor for Optional(0LL, v56, v12, v13);
  uint64_t v52 = *(void *)(v14 - 8);
  uint64_t v53 = v14;
  MEMORY[0x1895F8858](v14);
  uint64_t v51 = (char *)&v49 - v15;
  uint64_t v16 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v17 = *(v16 - 1);
  MEMORY[0x1895F8858](v16);
  __int128 v19 = (char *)&v49 - v18;
  unint64_t v65 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v55 = *(void *)(v65 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v65);
  uint64_t v50 = (char *)&v49 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::String::Index v24 = (char *)&v49 - v23;
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (void (*)(char *, char *, unint64_t))((char *)&v49 - v25);
  uint64_t v54 = *(void (**)(uint64_t, uint64_t))(a2 + 72);
  v54(v7, a2);
  uint64_t v27 = v4;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(v7, a2);
  unint64_t v28 = v65;
  uint64_t v29 = *(void *)(swift_getAssociatedConformanceWitness( a2,  v7,  v65,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v30 = *(uint64_t (**)(char *, void (*)(char *, char *, unint64_t)))(v29 + 8);
  uint64_t v63 = v26;
  uint64_t v60 = v30;
  uint64_t v61 = v29;
  if ((((uint64_t (*)(char *, void, unint64_t))v30)(v24, v26, v28) & 1) != 0)
  {
LABEL_5:
    uint64_t v36 = *(void (**)(char *, unint64_t))(v55 + 8);
    unint64_t v37 = v65;
    v36(v24, v65);
    v36((char *)v63, v37);
    char v38 = v57;
    v54(v7, a2);
    uint64_t v39 = type metadata accessor for FlattenSequence<>.Index(0LL, v7, a2, (uint64_t)v64);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v56 - 8) + 56LL))( &v38[*(int *)(v39 + 44)],  1LL,  1LL);
  }

  else
  {
    uint64_t v31 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a2 + 80);
    uint64_t v58 = (uint64_t (*)(unint64_t *, const char *))*((void *)v64 + 13);
    unint64_t v59 = v31;
    while (1)
    {
      unint64_t v32 = (void (*)(_BYTE *, void))v59(v66, v24, v7, a2);
      (*(void (**)(char *))(v17 + 16))(v19);
      v32(v66, 0LL);
      if ((v58(v16, v64) & 1) == 0) {
        break;
      }
      (*(void (**)(char *, unint64_t *))(v17 + 8))(v19, v16);
      uint64_t v33 = v17;
      uint64_t v34 = v62;
      (*(void (**)(char *, uint64_t, uint64_t))(v62 + 16))(v9, v27, v7);
      (*(void (**)(char *, uint64_t, uint64_t))(a2 + 192))(v24, v7, a2);
      uint64_t v35 = *(void (**)(char *, uint64_t))(v34 + 8);
      uint64_t v17 = v33;
      v35(v9, v7);
      if ((v60(v24, v63) & 1) != 0) {
        goto LABEL_5;
      }
    }

    uint64_t v41 = v55;
    unint64_t v42 = v65;
    (*(void (**)(void (*)(char *, char *, unint64_t), unint64_t))(v55 + 8))( v63,  v65);
    uint64_t v63 = *(void (**)(char *, char *, unint64_t))(v41 + 32);
    unint64_t v43 = v50;
    v63(v50, v24, v42);
    uint64_t v44 = (uint64_t)v64;
    uint64_t v45 = v17;
    uint64_t v46 = v51;
    (*((void (**)(unint64_t *, const char *))v64 + 8))(v16, v64);
    (*(void (**)(char *, unint64_t *))(v45 + 8))(v19, v16);
    (*(void (**)(char *, void, uint64_t))(*(void *)(v56 - 8) + 56LL))(v46, 0LL, 1LL);
    uint64_t v47 = v57;
    v63(v57, v43, v42);
    uint64_t v48 = type metadata accessor for FlattenSequence<>.Index(0LL, v7, a2, v44);
    return (*(uint64_t (**)(char *, char *, uint64_t))(v52 + 32))(&v47[*(int *)(v48 + 44)], v46, v53);
  }

uint64_t FlattenSequence<>.endIndex.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(a2 + 72))(v7);
  uint64_t v8 = a4 + *(int *)(type metadata accessor for FlattenSequence<>.Index(0LL, v7, a2, (uint64_t)a3) + 44);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a2 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v10 - 8) + 56LL))( v8,  1LL,  1LL,  v10);
}

uint64_t FlattenSequence<>._index(after:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v94 = a4;
  uint64_t v101 = a1;
  uint64_t v91 = a5;
  uint64_t v79 = a2;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v84 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v81 = (char *)&v75 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v97 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v98 = AssociatedTypeWitness;
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v88 = (char *)&v75 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v89 = (char *)&v75 - v14;
  MEMORY[0x1895F8858](v13);
  uint64_t v80 = (char *)&v75 - v15;
  unint64_t v16 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a3 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v17 = swift_getAssociatedTypeWitness( 255LL,  a4,  v16,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v20 = type metadata accessor for Optional(0LL, v17, v18, v19);
  uint64_t v95 = *(void *)(v20 - 8);
  Swift::UInt64 v96 = (void (*)(char *, unint64_t))v20;
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v78 = (char *)&v75 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v75 - v24;
  uint64_t v26 = *(void *)(v17 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v23);
  uint64_t v93 = (char *)&v75 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v27);
  unint64_t v100 = (char *)&v75 - v29;
  uint64_t v30 = swift_checkMetadataState(0LL, v16);
  uint64_t v31 = *(v30 - 1);
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v87 = (char *)&v75 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v32);
  uint64_t v35 = (char *)&v75 - v34;
  uint64_t v36 = v101;
  unint64_t v86 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a3 + 80);
  unint64_t v37 = (void (*)(_BYTE *, void))v86(v102, v101, v7, a3);
  uint64_t v92 = v31;
  char v38 = *(void (**)(char *))(v31 + 16);
  uint64_t v39 = (uint64_t)v94;
  uint64_t v85 = v38;
  v38(v35);
  v37(v102, 0LL);
  uint64_t v82 = v7;
  uint64_t v40 = v7;
  uint64_t v41 = v17;
  uint64_t v83 = a3;
  uint64_t v42 = a3;
  uint64_t v43 = v26;
  uint64_t v90 = type metadata accessor for FlattenSequence<>.Index(0LL, v40, v42, v39);
  (*(void (**)(char *, char *, void (*)(char *, unint64_t)))(v95 + 16))( v25,  &v36[*(int *)(v90 + 44)],  v96);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v26 + 48))(v25, 1LL, v17) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xFCuLL,  0);
  }
  uint64_t v44 = v100;
  (*(void (**)(char *, unint64_t *, uint64_t))(v39 + 184))(v25, v30, v39);
  uint64_t v45 = *(void (**)(char *, uint64_t))(v43 + 8);
  v45(v25, v41);
  uint64_t v46 = v93;
  (*(void (**)(unint64_t *, uint64_t))(v39 + 72))(v30, v39);
  uint64_t v47 = *(void (**)(char *, unint64_t *))(v92 + 8);
  v47(v35, v30);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v39,  (uint64_t)v30,  v41,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v44,  v46,  v41);
  v45(v46, v41);
  if ((v49 & 1) != 0)
  {
    uint64_t v53 = v39;
    unint64_t v77 = v30;
    uint64_t v75 = v43;
    uint64_t v76 = v41;
    v45(v100, v41);
    uint64_t v54 = v81;
    uint64_t v55 = v82;
    unint64_t v100 = *(char **)(v84 + 16);
    ((void (*)(char *, uint64_t, uint64_t))v100)(v81, v99, v82);
    uint64_t v56 = v97;
    char v57 = v89;
    uint64_t v95 = *(void *)(v97 + 16);
    ((void (*)(char *, char *, unint64_t))v95)(v89, v101, v98);
    uint64_t v58 = v83;
    unint64_t v59 = v80;
    (*(void (**)(char *, uint64_t, uint64_t))(v83 + 184))(v57, v55, v83);
    uint64_t v60 = v98;
    Swift::UInt64 v96 = *(void (**)(char *, unint64_t))(v56 + 8);
    v96(v57, v98);
    uint64_t v101 = *(char **)(v84 + 8);
    ((void (*)(char *, uint64_t))v101)(v54, v55);
    uint64_t v93 = *(char **)(v58 + 72);
    uint64_t v61 = v55;
    uint64_t v92 = *(void *)(swift_getAssociatedConformanceWitness( v58,  v55,  v60,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    uint64_t v90 = *(void *)(v92 + 8);
    while (1)
    {
      uint64_t v62 = v89;
      unint64_t v63 = v98;
      ((void (*)(char *, char *, unint64_t))v95)(v89, v59, v98);
      ((void (*)(char *, uint64_t, uint64_t))v100)(v54, v99, v61);
      uint64_t v64 = v59;
      unint64_t v65 = v88;
      ((void (*)(uint64_t, uint64_t))v93)(v61, v58);
      ((void (*)(char *, uint64_t))v101)(v54, v61);
      char v66 = ((uint64_t (*)(char *, char *, unint64_t, uint64_t))v90)(v62, v65, v63, v92);
      uint64_t v67 = v65;
      uint64_t v68 = v96;
      v96(v67, v63);
      v68(v62, v63);
      if ((v66 & 1) != 0)
      {
        v96(v64, v98);
        return FlattenSequence<>.endIndex.getter(v79, v58, (const char *)v53, v91);
      }

      ((void (*)(char *, uint64_t, uint64_t))v100)(v54, v99, v61);
      size_t v69 = (void (*)(_BYTE *, void))v86(v102, v64, v61, v58);
      uint64_t v70 = v87;
      size_t v71 = v77;
      v85(v87);
      v69(v102, 0LL);
      ((void (*)(char *, uint64_t))v101)(v54, v61);
      unint64_t v59 = v64;
      v47(v70, v71);
      ((void (*)(char *, uint64_t, uint64_t))v100)(v54, v99, v61);
      (*(void (**)(char *, uint64_t, uint64_t))(v58 + 192))(v64, v61, v58);
      ((void (*)(char *, uint64_t))v101)(v54, v61);
    }

    uint64_t v72 = v70;
    uint64_t v73 = (uint64_t)v89;
    (*(void (**)(char *, char *, unint64_t))(v97 + 32))(v89, v64, v98);
    uint64_t v74 = (uint64_t)v78;
    (*(void (**)(unint64_t *, uint64_t))(v53 + 64))(v71, v53);
    v47(v72, v71);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v75 + 56))(v74, 0LL, 1LL, v76);
    return FlattenSequence<>.Index.init(_:_:)(v73, v74, v61, v58, (const char *)v53, v91);
  }

  else
  {
    uint64_t v50 = v91;
    (*(void (**)(uint64_t, char *, unint64_t))(v97 + 16))(v91, v101, v98);
    uint64_t v51 = v50 + *(int *)(v90 + 44);
    (*(void (**)(uint64_t, char *, uint64_t))(v43 + 32))(v51, v100, v41);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v43 + 56))(v51, 0LL, 1LL, v41);
  }

uint64_t FlattenSequence<>._index(before:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v114 = a1;
  uint64_t v87 = a5;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v105 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  int64_t v104 = (char *)&v85 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v10 + 8),  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v89 = type metadata accessor for Optional(0LL, v12, v13, v14);
  uint64_t v90 = *(void *)(v89 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v89);
  unint64_t v86 = (char *)&v85 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v113 = (char *)&v85 - v18;
  unint64_t v117 = v12;
  uint64_t v88 = *(void *)(v12 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v108 = (char *)&v85 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v115 = (char *)&v85 - v21;
  unint64_t v116 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v111 = *(v116 - 1);
  MEMORY[0x1895F8858](v116);
  uint64_t v112 = (char *)&v85 - v22;
  uint64_t v23 = v5;
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v25 = *(void *)(v24 - 8);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v85 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  uint64_t v31 = (char *)&v85 - v30;
  MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v85 - v32;
  uint64_t v34 = *(void (**)(char *, char *, unint64_t))(v25 + 16);
  v34((char *)&v85 - v32, v114, v24);
  unint64_t v100 = v34;
  v34(v31, v33, v24);
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v8, a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  v8,  v24,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v34) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness
                                                                                        + 8)
                                                                            + 8LL))( v31,  v28,  v24);
  uint64_t v107 = v25;
  uint64_t v36 = *(void (**)(char *, unint64_t))(v25 + 8);
  v36(v28, v24);
  uint64_t v110 = v31;
  v36(v31, v24);
  if ((v34 & 1) != 0)
  {
    unint64_t v37 = v110;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(a3 + 136))(v33, -1LL, v8, a3);
    v36(v33, v24);
    (*(void (**)(char *, char *, unint64_t))(v107 + 32))(v33, v37, v24);
  }

  uint64_t v99 = v36;
  unint64_t v109 = v24;
  char v38 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a3 + 80);
  uint64_t v106 = v33;
  uint64_t v39 = a3;
  uint64_t v103 = v23;
  unint64_t v98 = v38;
  uint64_t v40 = (void (*)(char *, void))v38(v118, v33, v8, a3);
  uint64_t v41 = (uint64_t)v116;
  uint64_t v97 = *(void (**)(char *))(v111 + 16);
  v97(v112);
  v40(v118, 0LL);
  uint64_t v102 = v8;
  uint64_t v95 = v39;
  uint64_t v85 = type metadata accessor for FlattenSequence<>.Index(0LL, v8, v39, a4);
  uint64_t v42 = v113;
  uint64_t v43 = v89;
  (*(void (**)(char *, char *, uint64_t))(v90 + 16))(v113, &v114[*(int *)(v85 + 44)], v89);
  uint64_t v44 = v88;
  uint64_t v45 = v117;
  int v46 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v88 + 48))(v42, 1LL, v117);
  uint64_t v101 = v28;
  uint64_t v47 = v115;
  if (v46 == 1)
  {
    (*(void (**)(uint64_t, uint64_t))(a4 + 72))(v41, a4);
    (*(void (**)(char *, uint64_t))(v90 + 8))(v42, v43);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v44 + 32))(v115, v42, v45);
  }

  uint64_t v48 = v44;
  char v49 = *(void (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v50 = *(void *)(swift_getAssociatedConformanceWitness( a4,  v41,  v45,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v51 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v50 + 8);
  uint64_t v52 = v108;
  uint64_t v53 = v41;
  uint64_t v54 = v50;
  v49(v53, a4);
  Swift::UInt64 v96 = v51;
  char v55 = v51(v47, v52, v45, v54);
  uint64_t v114 = *(char **)(v48 + 8);
  ((void (*)(char *, uint64_t))v114)(v52, v45);
  if ((v55 & 1) != 0)
  {
    uint64_t v93 = (void (*)(unint64_t *, uint64_t))v49;
    uint64_t v92 = v54;
    uint64_t v56 = v112;
    uint64_t v94 = a4;
    uint64_t v57 = v102;
    uint64_t v58 = v95;
    unint64_t v59 = v110;
    do
    {
      ((void (*)(char *, unint64_t))v114)(v115, v117);
      (*(void (**)(char *, unint64_t *))(v111 + 8))(v56, v116);
      uint64_t v60 = v104;
      uint64_t v61 = v105;
      unint64_t v113 = *(char **)(v105 + 16);
      uint64_t v62 = v103;
      ((void (*)(char *, uint64_t, uint64_t))v113)(v104, v103, v57);
      unint64_t v63 = v106;
      uint64_t v64 = *(void (**)(char *, char *, unint64_t))(v107 + 32);
      unint64_t v65 = v101;
      unint64_t v66 = v109;
      v64(v101, v106, v109);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v58 + 136))(v65, -1LL, v57, v58);
      uint64_t v67 = v65;
      uint64_t v68 = v99;
      v99(v67, v66);
      size_t v69 = *(void (**)(char *, uint64_t))(v61 + 8);
      v69(v60, v57);
      uint64_t v91 = v64;
      v64(v63, v59, v66);
      ((void (*)(char *, uint64_t, uint64_t))v113)(v60, v62, v57);
      uint64_t v56 = v112;
      v100(v59, v63, v66);
      uint64_t v70 = (void (*)(char *, void))v98(v118, v59, v57, v58);
      size_t v71 = v116;
      v97(v56);
      v70(v118, 0LL);
      v68(v59, v66);
      v69(v60, v57);
      a4 = v94;
      uint64_t v72 = v115;
      (*(void (**)(unint64_t *, uint64_t))(v94 + 72))(v71, v94);
      uint64_t v73 = v108;
      v93(v71, a4);
      uint64_t v74 = v72;
      unint64_t v75 = v117;
      LOBYTE(v6specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v96(v74, v73, v117, v92);
      ((void (*)(char *, unint64_t))v114)(v73, v75);
    }

    while ((v60 & 1) != 0);
    uint64_t v76 = v87;
    uint64_t v47 = v115;
    unint64_t v77 = v91;
  }

  else
  {
    unint64_t v77 = *(void (**)(char *, char *, unint64_t))(v107 + 32);
    uint64_t v76 = v87;
  }

  unint64_t v79 = v109;
  uint64_t v78 = v110;
  v77(v110, v106, v109);
  uint64_t v80 = v86;
  uint64_t v81 = v112;
  uint64_t v82 = v116;
  (*(void (**)(char *, uint64_t, unint64_t *, uint64_t))(a4 + 136))(v47, -1LL, v116, a4);
  unint64_t v83 = v117;
  ((void (*)(char *, unint64_t))v114)(v47, v117);
  (*(void (**)(char *, unint64_t *))(v111 + 8))(v81, v82);
  (*(void (**)(char *, void, uint64_t, unint64_t))(v88 + 56))(v80, 0LL, 1LL, v83);
  v77(v76, v78, v79);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v90 + 32))(&v76[*(int *)(v85 + 44)], v80, v89);
}

uint64_t FlattenSequence<>.formIndex(after:)(char *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v8 = type metadata accessor for FlattenSequence<>.Index(0LL, *(void *)(a2 + 16), a3, (uint64_t)a4);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v13 - v10;
  FlattenSequence<>._index(after:)(a1, a2, a3, a4, (uint64_t)&v13 - v10);
  (*(void (**)(char *, uint64_t))(v9 + 8))(a1, v8);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v9 + 32))(a1, v11, v8);
}

unint64_t specialized FlattenSequence<>.distance(from:to:)( unint64_t a1, uint64_t a2, uint64_t a3, Swift::UInt64 a4, int64_t a5, char a6, uint64_t a7, unint64_t a8, void (*a9)(void *__return_ptr, Swift::UInt32 *), unint64_t *a10)
{
  Swift::UInt64 rawBits = a4;
  unint64_t v13 = a2;
  unint64_t v14 = a1;
  int v15 = a3 & 1;
  char v16 = a3 & 1;
  unint64_t v17 = a4 >> 14;
  unint64_t v18 = a1 >> 14;
  if (a4 >> 14 != a1 >> 14)
  {
    int v90 = a6 & 1;
    if (a4 >> 14 >= a1 >> 14) {
      goto LABEL_16;
    }
    goto LABEL_9;
  }

  if ((a6 & 1) != 0)
  {
    if ((a3 & 1) == 0) {
LABEL_52:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
    return 0LL;
  }

  int v90 = 0;
  if ((a3 & 1) != 0) {
    goto LABEL_52;
  }
  if (a5 < a2)
  {
LABEL_9:
    uint64_t v19 = HIBYTE(a8) & 0xF;
    if ((a8 & 0x2000000000000000LL) == 0) {
      uint64_t v19 = a7;
    }
    uint64_t v20 = 7LL;
    if (((a8 >> 60) & ((a7 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v20 = 11LL;
    }
    Swift::UInt64 v22 = v20 | (v19 << 16);
    char v88 = a3 & 1;
    swift_bridgeObjectRetain(a8, a2, a3, (char *)a4);
    swift_retain(a10, v23, v24, v25);
    v26._Swift::UInt64 rawBits = v22;
    Swift::UInt64 rawBits = a4;
    unint64_t v14 = a1;
    v27._Swift::UInt64 rawBits = 15LL;
    specialized Collection.count.getter(v26, v27, a7, a8);
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    char v16 = v88;
    if (v17 == v18) {
      goto LABEL_14;
    }
LABEL_16:
    char v29 = v16;
    char v30 = v90;
    uint64_t v85 = v13;
    Swift::UInt64 v86 = rawBits;
    char v89 = v16;
    if ((specialized static Comparable.<= infix(_:_:)(v14, v13, v16, rawBits, a5, v90) & 1) != 0)
    {
      char v31 = specialized static Comparable.<= infix(_:_:)(v14, v13, v29, rawBits, a5, v90);
      unint64_t v35 = a5;
      char v36 = v90;
      Swift::UInt64 v37 = rawBits;
      unint64_t v38 = v14;
      Swift::UInt64 rawBits = v14;
      char v30 = v15;
      if ((v31 & 1) == 0) {
        goto LABEL_18;
      }
    }

    else
    {
      char v39 = specialized static Comparable.<= infix(_:_:)(rawBits, a5, v90, v14, v13, v29);
      unint64_t v35 = v13;
      char v36 = v15;
      unint64_t v38 = v14;
      Swift::UInt64 v37 = v14;
      unint64_t v13 = a5;
      if ((v39 & 1) == 0) {
LABEL_18:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    char v84 = v36;
    v92._Swift::UInt64 rawBits = rawBits;
    unint64_t v83 = v35;
    if ((v30 & 1) != 0)
    {
      unint64_t v28 = 0LL;
    }

    else
    {
      Swift::UInt64 v40 = v37;
      swift_bridgeObjectRetain(a8, v32, v33, v34);
      swift_retain(a10, v41, v42, v43);
      v44._Swift::UInt64 rawBits = rawBits;
      unsigned int v45 = specialized LazyMapSequence<>.subscript.getter(v44, a7, a8, a9);
      swift_release((uint64_t)a10);
      swift_bridgeObjectRelease(a8);
      uint64_t v46 = 2LL;
      uint64_t v47 = 3LL;
      if (v45 >= 0x10000) {
        uint64_t v47 = 4LL;
      }
      if (v45 >= 0x800) {
        uint64_t v46 = v47;
      }
      if (v45 <= 0x7F) {
        unint64_t v48 = 1LL;
      }
      else {
        unint64_t v48 = v46;
      }
      unint64_t v28 = specialized RandomAccessCollection<>.distance(from:to:)(v13, v48, v45);
      swift_bridgeObjectRetain(a8, v49, v50, v51);
      swift_retain(a10, v52, v53, v54);
      specialized LazyMapSequence<>.formIndex(after:)(&v92, a7, a8);
      swift_release((uint64_t)a10);
      swift_bridgeObjectRelease(a8);
      Swift::UInt64 v37 = v40;
      Swift::UInt64 rawBits = v92._rawBits;
    }

    Swift::UInt64 v55 = v37 >> 14;
    if (v37 >> 14 > rawBits >> 14)
    {
      while (1)
      {
        swift_bridgeObjectRetain(a8, v32, v33, v34);
        swift_retain(a10, v56, v57, v58);
        v59._Swift::UInt64 rawBits = rawBits;
        unsigned int v60 = specialized LazyMapSequence<>.subscript.getter(v59, a7, a8, a9);
        swift_release((uint64_t)a10);
        swift_bridgeObjectRelease(a8);
        if (v60 < 0x10000) {
          uint64_t v61 = 3LL;
        }
        else {
          uint64_t v61 = 4LL;
        }
        if (v60 <= 0x7FF) {
          uint64_t v61 = 2LL;
        }
        unint64_t v62 = v60 >= 0x80 ? v61 : 1LL;
        unint64_t v63 = specialized RandomAccessCollection<>.distance(from:to:)(0LL, v62, v60);
        BOOL v67 = __OFADD__(v28, v63);
        v28 += v63;
        if (v67) {
          break;
        }
        swift_bridgeObjectRetain(a8, v64, v65, v66);
        swift_retain(a10, v68, v69, v70);
        specialized LazyMapSequence<>.formIndex(after:)(&v92, a7, a8);
        swift_release((uint64_t)a10);
        swift_bridgeObjectRelease(a8);
        Swift::UInt64 rawBits = v92._rawBits;
        if (v55 <= v92._rawBits >> 14) {
          goto LABEL_41;
        }
      }

      __break(1u);
      goto LABEL_50;
    }

Swift::UInt64 specialized FlattenSequence<>.distance(from:to:)( Swift::UInt64 a1, unint64_t a2, char a3, Swift::UInt64 a4, unint64_t a5, char a6, uint64_t a7, unint64_t a8, void (*a9)(uint64_t *__return_ptr, void *), unint64_t *a10)
{
  unint64_t v12 = a5;
  Swift::UInt64 v13 = a4;
  unint64_t v14 = a2;
  Swift::UInt64 v15 = a1;
  unint64_t v16 = a3 & 1;
  char v17 = v16;
  unint64_t v18 = a4 >> 14;
  Swift::UInt64 v19 = a1 >> 14;
  if (a4 >> 14 == a1 >> 14)
  {
    if ((a6 & 1) != 0)
    {
      if (!(_DWORD)v16) {
LABEL_86:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
      return 0LL;
    }

    unsigned int v101 = 0;
    if ((_DWORD)v16) {
      goto LABEL_86;
    }
    if (a5 >> 14 >= a2 >> 14)
    {
LABEL_14:
      if (!(v16 | v101))
      {
        Swift::UInt64 v55 = v12;
        v56._Swift::UInt64 rawBits = v15;
        unint64_t v16 = specialized LazyMapSequence<>.subscript.getter(v56, a7, a8, a9);
        Swift::UInt64 v40 = v57;
        uint64_t v58 = (v16 >> 59) & 1;
        if ((v57 & 0x1000000000000000LL) == 0) {
          LOBYTE(v58) = 1;
        }
        Swift::UInt64 v13 = v14;
        unint64_t v59 = v14 & 0xC;
        unint64_t v14 = 4LL << v58;
        if (v59 == 4LL << v58) {
          goto LABEL_78;
        }
        goto LABEL_34;
      }

      return 0LL;
    }
  }

  else
  {
    unsigned int v101 = a6 & 1;
    if (a4 >> 14 >= a1 >> 14) {
      goto LABEL_16;
    }
  }

  uint64_t v20 = HIBYTE(a8) & 0xF;
  if ((a8 & 0x2000000000000000LL) == 0) {
    uint64_t v20 = a7;
  }
  uint64_t v21 = 7LL;
  if (((a8 >> 60) & ((a7 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v21 = 11LL;
  }
  Swift::UInt64 v25 = v21 | (v20 << 16);
  swift_bridgeObjectRetain(a8, a2, v16, (char *)a4);
  swift_retain(a10, v26, v27, v28);
  v29._Swift::UInt64 rawBits = v25;
  unint64_t v12 = a5;
  unint64_t v14 = a2;
  Swift::UInt64 v13 = a4;
  Swift::UInt64 v15 = a1;
  v30._Swift::UInt64 rawBits = 15LL;
  specialized LazyMapSequence<>.distance(from:to:)(v29, v30, a7, a8);
  swift_release((uint64_t)a10);
  swift_bridgeObjectRelease(a8);
  char v17 = v16;
  if (v18 == v19) {
    goto LABEL_14;
  }
LABEL_16:
  char v32 = v17;
  unint64_t v99 = v12;
  char v100 = v17;
  if ((specialized static Comparable.<= infix(_:_:)(v15, v14, v17, v13, v12, v101) & 1) != 0)
  {
    char v33 = specialized static Comparable.<= infix(_:_:)(v15, v14, v32, v13, v12, v101);
    to._Swift::UInt64 rawBits = v12;
    char v37 = v101;
    Swift::UInt64 v38 = v13;
    Swift::UInt64 rawBits = v14;
    Swift::UInt64 v40 = v15;
    if ((v33 & 1) == 0) {
      goto LABEL_18;
    }
  }

  else
  {
    char v41 = specialized static Comparable.<= infix(_:_:)(v13, v12, v101, v15, v14, v32);
    to._Swift::UInt64 rawBits = v14;
    char v37 = v16;
    Swift::UInt64 v38 = v15;
    Swift::UInt64 rawBits = v12;
    unint64_t v16 = v101;
    Swift::UInt64 v40 = v13;
    if ((v41 & 1) == 0) {
LABEL_18:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  char v98 = v37;
  v102._Swift::UInt64 rawBits = v40;
  if ((v16 & 1) != 0)
  {
    Swift::Int v42 = 0LL;
    goto LABEL_45;
  }

  Swift::UInt64 v95 = v38;
  swift_bridgeObjectRetain(a8, v34, v35, v36);
  swift_retain(a10, v43, v44, v45);
  v46._Swift::UInt64 rawBits = v40;
  uint64_t v47 = specialized LazyMapSequence<>.subscript.getter(v46, a7, a8, a9);
  unint64_t v49 = v48;
  swift_release((uint64_t)a10);
  swift_bridgeObjectRelease(a8);
  uint64_t v50 = v47;
  if ((v49 & 0x2000000000000000LL) != 0) {
    unint64_t v51 = HIBYTE(v49) & 0xF;
  }
  else {
    unint64_t v51 = v47 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v52 = v51 << 16;
  int v53 = (v49 & 0x1000000000000000LL) == 0 || (v47 & 0x800000000000000LL) != 0;
  if (v53 == 1)
  {
    unint64_t v16 = v52 | 7;
    if ((v49 & 0x1000000000000000LL) == 0)
    {
      LOBYTE(v54) = 1;
      goto LABEL_39;
    }
  }

  else
  {
    unint64_t v16 = v52 | 0xB;
  }

  unint64_t v54 = (v50 & 0x800000000000000uLL) >> 59;
LABEL_39:
  if ((rawBits & 0xC) == 4LL << v54)
  {
    v85._Swift::UInt64 rawBits = rawBits;
    unint64_t v86 = v51;
    v87._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v85)._rawBits;
    unint64_t v51 = v86;
    Swift::UInt64 rawBits = v87._rawBits;
  }

  if ((v16 & 0xC) == 4LL << v53)
  {
    v88._Swift::UInt64 rawBits = v16;
    Swift::UInt64 v89 = rawBits;
    unint64_t v90 = v51;
    v91._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v88)._rawBits;
    unint64_t v51 = v90;
    Swift::UInt64 rawBits = v89;
    unint64_t v16 = v91._rawBits;
    if ((v49 & 0x1000000000000000LL) == 0) {
      goto LABEL_43;
    }
LABEL_68:
    if (v51 < rawBits >> 16 || v51 < v16 >> 16) {
      goto LABEL_85;
    }
    Swift::Int v42 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, (Swift::String::Index)v16);
    swift_bridgeObjectRelease(v49);
    goto LABEL_44;
  }

  if ((v49 & 0x1000000000000000LL) != 0) {
    goto LABEL_68;
  }
LABEL_43:
  swift_bridgeObjectRelease(v49);
  Swift::Int v42 = (v16 >> 16) - (rawBits >> 16);
LABEL_44:
  swift_bridgeObjectRetain(a8, v61, v62, v63);
  swift_retain(a10, v64, v65, v66);
  specialized LazyMapSequence<>.formIndex(after:)(&v102, a7, a8);
  swift_release((uint64_t)a10);
  swift_bridgeObjectRelease(a8);
  Swift::UInt64 v40 = v102._rawBits;
  Swift::UInt64 v38 = v95;
LABEL_45:
  Swift::UInt64 v55 = v38 >> 14;
  if (v38 >> 14 <= v40 >> 14) {
    goto LABEL_56;
  }
  while (1)
  {
    swift_bridgeObjectRetain(a8, v34, v35, v36);
    swift_retain(a10, v67, v68, v69);
    v70._Swift::UInt64 rawBits = v40;
    uint64_t v71 = specialized LazyMapSequence<>.subscript.getter(v70, a7, a8, a9);
    Swift::UInt64 v40 = v72;
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    if ((v40 & 0x1000000000000000LL) == 0) {
      break;
    }
    unint64_t v16 = String.UTF8View._foreignCount()();
    swift_bridgeObjectRelease(v40);
    BOOL v73 = __OFADD__(v42, v16);
    v42 += v16;
    if (v73) {
      goto LABEL_55;
    }
LABEL_51:
    swift_bridgeObjectRetain(a8, v34, v35, v36);
    swift_retain(a10, v74, v75, v76);
    specialized LazyMapSequence<>.formIndex(after:)(&v102, a7, a8);
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    Swift::UInt64 v40 = v102._rawBits;
    if (v55 <= v102._rawBits >> 14) {
      goto LABEL_56;
    }
  }

  swift_bridgeObjectRelease(v40);
  if ((v40 & 0x2000000000000000LL) != 0) {
    unint64_t v16 = HIBYTE(v40) & 0xF;
  }
  else {
    unint64_t v16 = v71 & 0xFFFFFFFFFFFFLL;
  }
  BOOL v73 = __OFADD__(v42, v16);
  v42 += v16;
  if (!v73) {
    goto LABEL_51;
  }
LABEL_55:
  __break(1u);
LABEL_56:
  if ((v98 & 1) == 0)
  {
    swift_bridgeObjectRetain(a8, v34, v35, v36);
    swift_retain(a10, v78, v79, v80);
    v81._Swift::UInt64 rawBits = v40;
    unint64_t v82 = specialized LazyMapSequence<>.subscript.getter(v81, a7, a8, a9);
    Swift::UInt64 v40 = v83;
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(a8);
    uint64_t v84 = (v82 >> 59) & 1;
    if ((v40 & 0x1000000000000000LL) == 0) {
      LOBYTE(v84) = 1;
    }
    Swift::UInt64 v55 = to._rawBits;
    if ((to._rawBits & 0xC) == 4LL << v84)
    {
      Swift::UInt64 v55 = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
      if ((v40 & 0x1000000000000000LL) == 0) {
        goto LABEL_62;
      }
    }

    else if ((v40 & 0x1000000000000000LL) == 0)
    {
LABEL_62:
      swift_bridgeObjectRelease(v40);
      unint64_t v16 = v55 >> 16;
      goto LABEL_63;
    }

    unint64_t v92 = v82 & 0xFFFFFFFFFFFFLL;
    if ((v40 & 0x2000000000000000LL) != 0) {
      unint64_t v92 = HIBYTE(v40) & 0xF;
    }
    if (v92 < v55 >> 16) {
      goto LABEL_85;
    }
    unint64_t v16 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)v55);
    swift_bridgeObjectRelease(v40);
LABEL_63:
    BOOL v73 = __OFADD__(v42, v16);
    v42 += v16;
    unint64_t v77 = v99;
    if (!v73) {
      goto LABEL_64;
    }
    __break(1u);
    goto LABEL_77;
  }

  unint64_t v77 = v99;
LABEL_64:
  if ((specialized static Comparable.<= infix(_:_:)(v15, v14, v100, v13, v77, v101) & 1) != 0) {
    return v42;
  }
  BOOL v73 = __OFSUB__(0LL, v42);
  Swift::Int v42 = -v42;
  if (!v73) {
    return v42;
  }
LABEL_77:
  __break(1u);
LABEL_78:
  Swift::UInt64 v13 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v13)._rawBits;
LABEL_34:
  if ((v55 & 0xC) == v14)
  {
    Swift::UInt64 v55 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v55)._rawBits;
    Swift::UInt64 v60 = v13;
    if ((v40 & 0x1000000000000000LL) == 0) {
      goto LABEL_36;
    }
  }

  else
  {
    Swift::UInt64 v60 = v13;
    if ((v40 & 0x1000000000000000LL) == 0)
    {
LABEL_36:
      swift_bridgeObjectRelease(v40);
      return (v55 >> 16) - (v60 >> 16);
    }
  }

  unint64_t v93 = HIBYTE(v40) & 0xF;
  if ((v40 & 0x2000000000000000LL) == 0) {
    unint64_t v93 = v16 & 0xFFFFFFFFFFFFLL;
  }
  if (v93 < v60 >> 16 || v93 < v55 >> 16) {
LABEL_85:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  Swift::Int v94 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v13, (Swift::String::Index)v55);
  swift_bridgeObjectRelease(v40);
  return v94;
}

unint64_t specialized FlattenSequence<>.distance(from:to:)( Swift::UInt64 a1, unint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, char a6)
{
  unint64_t v7 = a5;
  Swift::UInt64 v8 = a2;
  Swift::UInt64 v9 = a1;
  uint64_t v10 = a3 & 1;
  char v11 = a3 & 1;
  Swift::UInt64 v12 = a6 & 1;
  __int128 v13 = *(_OWORD *)(v6 + 16);
  __int128 v95 = *(_OWORD *)v6;
  __int128 v96 = v13;
  __int128 v97 = *(_OWORD *)(v6 + 32);
  unint64_t v14 = a4 >> 14;
  Swift::UInt64 v15 = a1 >> 14;
  if (a4 >> 14 == a1 >> 14)
  {
    if ((a6 & 1) != 0)
    {
      if ((a3 & 1) == 0) {
LABEL_83:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
      return 0LL;
    }

    if ((a3 & 1) != 0) {
      goto LABEL_83;
    }
    if (a5 >> 14 >= a2 >> 14)
    {
LABEL_10:
      Swift::UInt64 v37 = specialized LazyMapSequence<>.subscript.getter(v9);
      unint64_t v6 = v52;
      uint64_t v53 = (v37 >> 59) & 1;
      if ((v52 & 0x1000000000000000LL) == 0) {
        LOBYTE(v53) = 1;
      }
      Swift::UInt64 v39 = 4LL << v53;
      if ((v8 & 0xC) != 4LL << v53) {
        goto LABEL_30;
      }
      goto LABEL_75;
    }
  }

  else if (a4 >> 14 >= a1 >> 14)
  {
    goto LABEL_12;
  }

  __int128 v16 = *(_OWORD *)(v6 + 16);
  v98[0] = *(_OWORD *)v6;
  v98[1] = v16;
  Swift::UInt64 v17 = a6 & 1;
  Swift::UInt64 v19 = *((void *)&v98[0] + 1);
  Swift::UInt64 v18 = *(void *)&v98[0];
  uint64_t v21 = *((void *)&v97 + 1);
  outlined retain of Substring((uint64_t)v98, a2, a3, (char *)a4);
  swift_retain(*((unint64_t **)&v97 + 1), v22, v23, v24);
  unint64_t v6 = (unint64_t)&v95;
  v25._Swift::UInt64 rawBits = v19;
  Swift::UInt64 v12 = v17;
  v26._Swift::UInt64 rawBits = v18;
  specialized LazyMapSequence<>.distance(from:to:)(v25, v26, v27);
  outlined release of Substring((uint64_t)v98);
  uint64_t v28 = v21;
  unint64_t v7 = a5;
  Swift::UInt64 v8 = a2;
  Swift::UInt64 v9 = a1;
  swift_release(v28);
  if (v14 == v15) {
    goto LABEL_10;
  }
LABEL_12:
  char v92 = v11;
  if ((specialized static Comparable.<= infix(_:_:)(v9, v8, v11, a4, v7, v12) & 1) != 0)
  {
    char v29 = v11;
    unint64_t v30 = a4;
    char v31 = specialized static Comparable.<= infix(_:_:)(v9, v8, v29, a4, v7, v12);
    to._Swift::UInt64 rawBits = v7;
    Swift::UInt64 v35 = v12;
    Swift::UInt64 rawBits = v8;
    Swift::UInt64 v37 = v9;
    if ((v31 & 1) == 0) {
      goto LABEL_14;
    }
  }

  else
  {
    char v38 = specialized static Comparable.<= infix(_:_:)(a4, v7, v12, v9, v8, v11);
    to._Swift::UInt64 rawBits = v8;
    Swift::UInt64 v35 = v10;
    unint64_t v30 = v9;
    Swift::UInt64 rawBits = v7;
    LOBYTE(v1specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v12;
    Swift::UInt64 v37 = a4;
    if ((v38 & 1) == 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  Swift::UInt64 v39 = v35;
  unint64_t v90 = v7;
  Swift::UInt64 v94 = v37;
  char v91 = v12;
  if ((v10 & 1) == 0)
  {
    v99[0] = v95;
    v99[1] = v96;
    Swift::UInt64 v40 = (unint64_t *)*((void *)&v97 + 1);
    outlined retain of Substring((uint64_t)v99, v32, v33, v34);
    swift_retain(v40, v41, v42, v43);
    uint64_t v44 = specialized LazyMapSequence<>.subscript.getter(v37);
    unint64_t v46 = v45;
    outlined release of Substring((uint64_t)v99);
    swift_release((uint64_t)v40);
    if ((v46 & 0x2000000000000000LL) != 0) {
      unint64_t v47 = HIBYTE(v46) & 0xF;
    }
    else {
      unint64_t v47 = v44 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v48 = v47 << 16;
    int v49 = (v46 & 0x1000000000000000LL) == 0 || (v44 & 0x800000000000000LL) != 0;
    if (v49 == 1)
    {
      v50._Swift::UInt64 rawBits = v48 | 7;
      if ((v46 & 0x1000000000000000LL) == 0)
      {
        LOBYTE(v51) = 1;
        goto LABEL_35;
      }
    }

    else
    {
      v50._Swift::UInt64 rawBits = v48 | 0xB;
    }

    unint64_t v51 = (v44 & 0x800000000000000uLL) >> 59;
LABEL_35:
    if ((rawBits & 0xC) == 4LL << v51)
    {
      v79._Swift::UInt64 rawBits = rawBits;
      unint64_t v80 = v47;
      v81._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v79)._rawBits;
      unint64_t v47 = v80;
      Swift::UInt64 rawBits = v81._rawBits;
    }

    if ((v50._rawBits & 0xC) == 4LL << v49)
    {
      v82._Swift::UInt64 rawBits = v50._rawBits;
      unint64_t v83 = v47;
      v84._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v82)._rawBits;
      unint64_t v47 = v83;
      v50._Swift::UInt64 rawBits = v84._rawBits;
      if ((v46 & 0x1000000000000000LL) == 0) {
        goto LABEL_39;
      }
    }

    else if ((v46 & 0x1000000000000000LL) == 0)
    {
LABEL_39:
      swift_bridgeObjectRelease(v46);
      unint64_t v7 = (v50._rawBits >> 16) - (rawBits >> 16);
LABEL_40:
      outlined retain of Substring((uint64_t)v99, v54, v55, v56);
      swift_retain(v40, v57, v58, v59);
      unint64_t v6 = (unint64_t)&v95;
      specialized LazyMapSequence<>.formIndex(after:)(&v94);
      outlined release of Substring((uint64_t)v99);
      swift_release((uint64_t)v40);
      Swift::UInt64 v37 = v94;
      goto LABEL_41;
    }

    if (v47 < rawBits >> 16 || v47 < v50._rawBits >> 16) {
      goto LABEL_82;
    }
    unint64_t v7 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, v50);
    swift_bridgeObjectRelease(v46);
    goto LABEL_40;
  }

  unint64_t v7 = 0LL;
LABEL_41:
  if (v30 >> 14 <= v37 >> 14) {
    goto LABEL_53;
  }
  v100[0] = v95;
  v100[1] = v96;
  Swift::UInt64 v60 = (unint64_t *)*((void *)&v97 + 1);
  while (1)
  {
    outlined retain of Substring((uint64_t)v100, v32, v33, v34);
    swift_retain(v60, v61, v62, v63);
    uint64_t v64 = specialized LazyMapSequence<>.subscript.getter(v37);
    unint64_t v6 = v65;
    outlined release of Substring((uint64_t)v100);
    swift_release((uint64_t)v60);
    if ((v6 & 0x1000000000000000LL) == 0) {
      break;
    }
    Swift::UInt64 v37 = String.UTF8View._foreignCount()();
    swift_bridgeObjectRelease(v6);
    BOOL v66 = __OFADD__(v7, v37);
    v7 += v37;
    if (v66) {
      goto LABEL_52;
    }
LABEL_48:
    outlined retain of Substring((uint64_t)v100, v32, v33, v34);
    swift_retain(v60, v67, v68, v69);
    unint64_t v6 = (unint64_t)&v95;
    specialized LazyMapSequence<>.formIndex(after:)(&v94);
    outlined release of Substring((uint64_t)v100);
    swift_release((uint64_t)v60);
    Swift::UInt64 v37 = v94;
    if (v30 >> 14 <= v94 >> 14) {
      goto LABEL_53;
    }
  }

  swift_bridgeObjectRelease(v6);
  if ((v6 & 0x2000000000000000LL) != 0) {
    Swift::UInt64 v37 = HIBYTE(v6) & 0xF;
  }
  else {
    Swift::UInt64 v37 = v64 & 0xFFFFFFFFFFFFLL;
  }
  BOOL v66 = __OFADD__(v7, v37);
  v7 += v37;
  if (!v66) {
    goto LABEL_48;
  }
LABEL_52:
  __break(1u);
LABEL_53:
  if ((v39 & 1) == 0)
  {
    v101[0] = v95;
    v101[1] = v96;
    uint64_t v71 = (unint64_t *)*((void *)&v97 + 1);
    outlined retain of Substring((uint64_t)v101, v32, v33, v34);
    swift_retain(v71, v72, v73, v74);
    unint64_t v75 = specialized LazyMapSequence<>.subscript.getter(v37);
    unint64_t v6 = v76;
    outlined release of Substring((uint64_t)v101);
    swift_release((uint64_t)v71);
    uint64_t v77 = (v75 >> 59) & 1;
    if ((v6 & 0x1000000000000000LL) == 0) {
      LOBYTE(v77) = 1;
    }
    Swift::UInt64 v39 = to._rawBits;
    if ((to._rawBits & 0xC) == 4LL << v77)
    {
      Swift::UInt64 v39 = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
      char v70 = v91;
      if ((v6 & 0x1000000000000000LL) == 0)
      {
LABEL_59:
        swift_bridgeObjectRelease(v6);
        Swift::UInt64 v37 = v39 >> 16;
        BOOL v66 = __OFADD__(v7, v39 >> 16);
        v7 += v39 >> 16;
        if (!v66) {
          goto LABEL_60;
        }
LABEL_73:
        __break(1u);
LABEL_74:
        __break(1u);
LABEL_75:
        Swift::UInt64 v8 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v8)._rawBits;
LABEL_30:
        if ((v7 & 0xC) == v39)
        {
          unint64_t v7 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v7)._rawBits;
          if ((v6 & 0x1000000000000000LL) == 0) {
            goto LABEL_32;
          }
        }

        else if ((v6 & 0x1000000000000000LL) == 0)
        {
LABEL_32:
          swift_bridgeObjectRelease(v6);
          return (v7 >> 16) - (v8 >> 16);
        }

        unint64_t v86 = HIBYTE(v6) & 0xF;
        if ((v6 & 0x2000000000000000LL) == 0) {
          unint64_t v86 = v37 & 0xFFFFFFFFFFFFLL;
        }
        if (v86 >= v8 >> 16 && v86 >= v7 >> 16)
        {
          unint64_t v7 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v8, (Swift::String::Index)v7);
          swift_bridgeObjectRelease(v6);
          return v7;
        }

Swift::UInt64 specialized FlattenSequence<>.distance(from:to:)( uint64_t a1, unint64_t a2, char a3, unint64_t a4, unint64_t a5, char a6, uint64_t a7, void (*a8)(unint64_t *__return_ptr, uint64_t *), unint64_t *a9)
{
  Swift::UInt64 rawBits = a7;
  Swift::UInt64 v11 = a5;
  Swift::UInt64 v13 = a2;
  unint64_t v14 = (unint64_t)a9;
  char v15 = a3 & 1;
  char v16 = a3 & 1;
  char v17 = a6 & 1;
  if (a4 != a1)
  {
    uint64_t v19 = a1;
    char v93 = a6 & 1;
    if ((specialized static Comparable.<= infix(_:_:)(a1, a2, a3 & 1, a4, a5, a6 & 1) & 1) != 0)
    {
      char v20 = specialized static Comparable.<= infix(_:_:)(v19, v13, v16, a4, v11, v17);
      to._Swift::UInt64 rawBits = v11;
      char v91 = v17;
      int64_t v24 = v19;
      uint64_t v19 = a4;
      Swift::UInt64 v25 = v13;
      if ((v20 & 1) == 0) {
        goto LABEL_7;
      }
    }

    else
    {
      char v36 = specialized static Comparable.<= infix(_:_:)(a4, v11, v17, v19, v13, v16);
      to._Swift::UInt64 rawBits = v13;
      char v91 = v15;
      Swift::UInt64 v25 = v11;
      char v15 = v17;
      int64_t v24 = a4;
      if ((v36 & 1) == 0) {
LABEL_7:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    char v87 = v16;
    unint64_t v88 = a4;
    Swift::UInt64 v89 = v13;
    Swift::UInt64 v90 = v11;
    if ((v15 & 1) != 0)
    {
      Swift::Int v35 = 0LL;
LABEL_35:
      if (v24 >= v19) {
        goto LABEL_49;
      }
      int64_t v53 = v24;
      uint64_t v54 = (unint64_t *)(rawBits + 16 * v24 + 40);
      while (1)
      {
        if (v53 < 0 || (unint64_t)v24 >= *(void *)(rawBits + 16)) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }
        unint64_t v55 = *v54;
        uint64_t v94 = *(v54 - 1);
        unint64_t v95 = v55;
        swift_bridgeObjectRetain(rawBits, v21, v22, v23);
        swift_retain(a9, v56, v57, v58);
        swift_bridgeObjectRetain(v55, v59, v60, v61);
        a8(&v96, &v94);
        swift_release((uint64_t)a9);
        swift_bridgeObjectRelease(rawBits);
        swift_bridgeObjectRelease(v55);
        unint64_t v63 = v96;
        unint64_t v62 = v97;
        if ((v97 & 0x1000000000000000LL) != 0)
        {
          Swift::Int v65 = String.UTF8View._foreignCount()();
          swift_bridgeObjectRelease(v62);
          BOOL v52 = __OFADD__(v35, v65);
          v35 += v65;
          if (v52) {
            goto LABEL_48;
          }
        }

        else
        {
          swift_bridgeObjectRelease(v97);
          if ((v62 & 0x2000000000000000LL) != 0) {
            uint64_t v64 = HIBYTE(v62) & 0xF;
          }
          else {
            uint64_t v64 = v63 & 0xFFFFFFFFFFFFLL;
          }
          BOOL v52 = __OFADD__(v35, v64);
          v35 += v64;
          if (v52)
          {
LABEL_48:
            __break(1u);
LABEL_49:
            if ((v91 & 1) != 0)
            {
              unint64_t v50 = v89;
              Swift::UInt64 v37 = v90;
              uint64_t v49 = v88;
              char v66 = v93;
              a8 = (void (*)(unint64_t *__return_ptr, uint64_t *))a1;
LABEL_56:
              BOOL v52 = __OFSUB__(0LL, v35);
              Swift::Int v35 = -v35;
              if (!v52) {
                return v35;
              }
              __break(1u);
LABEL_81:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
            }

            swift_bridgeObjectRetain(rawBits, v21, v22, v23);
            swift_retain(a9, v67, v68, v69);
            specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v24, 1, rawBits);
            Swift::UInt64 v70 = rawBits + 16 * v24;
            unint64_t v71 = *(void *)(v70 + 40);
            uint64_t v94 = *(void *)(v70 + 32);
            unint64_t v95 = v71;
            swift_bridgeObjectRetain(v71, v72, v73, v74);
            a8(&v96, &v94);
            swift_release((uint64_t)a9);
            swift_bridgeObjectRelease(rawBits);
            swift_bridgeObjectRelease(v71);
            uint64_t v46 = v96;
            unint64_t v14 = v97;
            uint64_t v75 = (v96 >> 59) & 1;
            if ((v97 & 0x1000000000000000LL) == 0) {
              LOBYTE(v75) = 1;
            }
            Swift::UInt64 rawBits = to._rawBits;
            unint64_t v50 = v89;
            Swift::UInt64 v37 = v90;
            uint64_t v49 = v88;
            a8 = (void (*)(unint64_t *__return_ptr, uint64_t *))a1;
            if ((to._rawBits & 0xC) != 4LL << v75)
            {
              char v66 = v93;
              if ((v97 & 0x1000000000000000LL) == 0)
              {
LABEL_55:
                swift_bridgeObjectRelease(v14);
                BOOL v52 = __OFADD__(v35, rawBits >> 16);
                v35 += rawBits >> 16;
                if (!v52) {
                  goto LABEL_56;
                }
LABEL_78:
                __break(1u);
                goto LABEL_79;
              }

LABEL_72:
            Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
            char v66 = v93;
            if ((v14 & 0x1000000000000000LL) == 0) {
              goto LABEL_55;
            }
            goto LABEL_73;
          }
        }

        ++v24;
        v54 += 2;
        if (v24 >= v19) {
          goto LABEL_49;
        }
      }
    }

    Swift::UInt64 v37 = v25;
    swift_bridgeObjectRetain(rawBits, v21, v22, v23);
    swift_retain(a9, v38, v39, v40);
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v24, 1, rawBits);
    Swift::UInt64 v41 = rawBits + 16 * v24;
    unint64_t v42 = *(void *)(v41 + 40);
    uint64_t v94 = *(void *)(v41 + 32);
    unint64_t v95 = v42;
    swift_bridgeObjectRetain(v42, v43, v44, v45);
    a8(&v96, &v94);
    swift_release((uint64_t)a9);
    swift_bridgeObjectRelease(rawBits);
    swift_bridgeObjectRelease(v42);
    uint64_t v46 = v97;
    if ((v97 & 0x2000000000000000LL) != 0) {
      unint64_t v47 = HIBYTE(v97) & 0xF;
    }
    else {
      unint64_t v47 = v96 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v48 = v47 << 16;
    if ((v97 & 0x1000000000000000LL) != 0) {
      uint64_t v49 = (v96 >> 59) & 1;
    }
    else {
      uint64_t v49 = 1LL;
    }
    if ((_DWORD)v49 == 1)
    {
      unint64_t v50 = v48 | 7;
      if ((v97 & 0x1000000000000000LL) == 0)
      {
        LOBYTE(v51) = 1;
        goto LABEL_30;
      }
    }

    else
    {
      unint64_t v50 = v48 | 0xB;
    }

    unint64_t v51 = (v96 & 0x800000000000000LL) >> 59;
LABEL_30:
    if ((v37 & 0xC) == 4LL << v51)
    {
      v78._Swift::UInt64 rawBits = v37;
      unint64_t v79 = v47;
      v80._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v78)._rawBits;
      unint64_t v47 = v79;
      Swift::UInt64 v37 = v80._rawBits;
    }

    if ((v50 & 0xC) == 4LL << v49)
    {
      v81._Swift::UInt64 rawBits = v50;
      unint64_t v82 = v47;
      v83._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v81)._rawBits;
      unint64_t v47 = v82;
      unint64_t v50 = v83._rawBits;
      if ((v46 & 0x1000000000000000LL) == 0)
      {
LABEL_34:
        swift_bridgeObjectRelease(v46);
        Swift::Int v35 = (v50 >> 16) - (v37 >> 16);
        BOOL v52 = __OFADD__(v24++, 1LL);
        if (!v52) {
          goto LABEL_35;
        }
LABEL_71:
        __break(1u);
        goto LABEL_72;
      }
    }

    else if ((v46 & 0x1000000000000000LL) == 0)
    {
      goto LABEL_34;
    }

    if (v47 < v37 >> 16 || v47 < v50 >> 16) {
      goto LABEL_79;
    }
    Swift::Int v35 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v37, (Swift::String::Index)v50);
    swift_bridgeObjectRelease(v46);
    BOOL v52 = __OFADD__(v24++, 1LL);
    if (!v52) {
      goto LABEL_35;
    }
    goto LABEL_71;
  }

  if ((a6 & 1) != 0)
  {
    if ((a3 & 1) != 0) {
      return 0LL;
    }
    goto LABEL_81;
  }

  if ((a3 & 1) != 0) {
    goto LABEL_81;
  }
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(a4, 1, a7);
  Swift::UInt64 v26 = rawBits + 16 * a4;
  unint64_t v27 = *(void *)(v26 + 40);
  uint64_t v94 = *(void *)(v26 + 32);
  unint64_t v95 = v27;
  swift_bridgeObjectRetain(v27, v28, v29, v30);
  a8(&v96, &v94);
  swift_bridgeObjectRelease(v27);
  unint64_t v32 = v96;
  unint64_t v31 = v97;
  uint64_t v33 = (v96 >> 59) & 1;
  if ((v97 & 0x1000000000000000LL) == 0) {
    LOBYTE(v33) = 1;
  }
  uint64_t v34 = 4LL << v33;
  if ((v13 & 0xC) == 4LL << v33) {
    Swift::UInt64 v13 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v13)._rawBits;
  }
  if ((v11 & 0xC) == v34)
  {
    Swift::UInt64 v11 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v11)._rawBits;
    if ((v31 & 0x1000000000000000LL) == 0) {
      goto LABEL_15;
    }
  }

  else if ((v31 & 0x1000000000000000LL) == 0)
  {
LABEL_15:
    swift_bridgeObjectRelease(v31);
    return (v11 >> 16) - (v13 >> 16);
  }

  unint64_t v76 = HIBYTE(v31) & 0xF;
  if ((v31 & 0x2000000000000000LL) == 0) {
    unint64_t v76 = v32 & 0xFFFFFFFFFFFFLL;
  }
  if (v76 < v13 >> 16 || v76 < v11 >> 16) {
    goto LABEL_79;
  }
  Swift::Int v77 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v13, (Swift::String::Index)v11);
  swift_bridgeObjectRelease(v31);
  return v77;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

          v81[0] = v65;
          char v66 = (uint64_t *)(v64 & 0xFFFFFFFFFFFFFFF0LL);
          if ((v64 & 8) != 0 && v66)
          {
            uint64_t v67 = *(void *)((v64 & 0xFFFFFFFFFFFFFFF0LL) + 0x18);
            unint64_t v63 = *(void *)((v64 & 0xFFFFFFFFFFFFFFF0LL) + 0x20);
          }

          else
          {
            uint64_t v67 = 0LL;
            if (v66 && (v64 & 8) == 0)
            {
              uint64_t v67 = *v66;
              unint64_t v63 = *(void *)((v64 & 0xFFFFFFFFFFFFFFF0LL) + 8);
            }
          }

          unint64_t v82 = v67;
          Swift::String::Index v83 = (void *)v63;
LABEL_123:
          Swift::String::Index v78 = v59;
LABEL_143:
          os_unfair_lock_unlock(v78);
          goto LABEL_144;
        }
      }
    }

    else if (v88[0])
    {
      if (v88[0] != 1) {
        goto LABEL_159;
      }
      if (v62 <= 2)
      {
        os_unfair_lock_lock(v59);
        uint64_t v64 = *v49;
        Swift::Int v65 = *v49 & 7;
        goto LABEL_72;
      }
    }

    else if (v62 <= 3)
    {
      os_unfair_lock_lock(v59);
      uint64_t v64 = *v49;
      Swift::Int v65 = *v49 & 7;
      goto LABEL_72;
    }

    v81[0] = v62;
    unint64_t v82 = 0LL;
    goto LABEL_144;
  }

  Swift::UInt64 v25 = HIWORD(v24) & 3;
  if (v25 == 1)
  {
    if (qword_18C476A78 != -1) {
    SingletonMetadataInitialization = (int *)swift::TargetTypeContextDescriptor<swift::InProcess>::getSingletonMetadataInitialization(v23);
    }
    unint64_t v51 = *SingletonMetadataInitialization;
    if ((_DWORD)v51) {
      BOOL v52 = (unint64_t *)((char *)SingletonMetadataInitialization + v51);
    }
    else {
      BOOL v52 = 0LL;
    }
    int64_t v53 = (unint64_t *)atomic_load(v52 + 1);
    uint64_t v54 = v88[0];
    unint64_t v55 = atomic_load(v53);
    Swift::UInt64 v13 = v55 & 7;
    if (v54 > 62)
    {
      if (v88[0] != 255)
      {
        if (v88[0] != 63) {
          goto LABEL_159;
        }
        if (v13 > 1) {
          goto LABEL_3;
        }
        os_unfair_lock_lock((os_unfair_lock_t)&SingletonMetadata);
        uint64_t v56 = *v53;
        uint64_t v57 = *v53 & 7;
        goto LABEL_108;
      }

      if (v13) {
        goto LABEL_3;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&SingletonMetadata);
      uint64_t v56 = *v53;
      uint64_t v57 = *v53 & 7;
      if ((*(_DWORD *)v53 & 7) == 0) {
        goto LABEL_108;
      }
    }

    else
    {
      if (v88[0])
      {
        if (v88[0] != 1) {
          goto LABEL_159;
        }
        if (v13 > 2) {
          goto LABEL_3;
        }
        os_unfair_lock_lock((os_unfair_lock_t)&SingletonMetadata);
        uint64_t v56 = *v53;
        uint64_t v57 = *v53 & 7;
LABEL_108:
        v81[0] = v57;
        uint64_t v74 = (uint64_t *)(v56 & 0xFFFFFFFFFFFFFFF0LL);
        if ((v56 & 8) != 0 && v74)
        {
          uint64_t v75 = *(void *)((v56 & 0xFFFFFFFFFFFFFFF0LL) + 0x18);
          uint64_t v74 = (uint64_t *)v74[4];
        }

        else
        {
          unint64_t v76 = v56 & 8;
          if (v74) {
            Swift::Int v77 = v76 == 0;
          }
          else {
            Swift::Int v77 = 0;
          }
          if (v77)
          {
            uint64_t v75 = *v74;
            uint64_t v74 = (uint64_t *)v74[1];
          }

          else
          {
            uint64_t v75 = 0LL;
          }
        }

        unint64_t v82 = v75;
        Swift::String::Index v83 = v74;
        goto LABEL_142;
      }

      if (v13 > 3) {
        goto LABEL_3;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&SingletonMetadata);
      uint64_t v56 = *v53;
      uint64_t v57 = *v53 & 7;
    }

          if (v8 > 62)
          {
            if (v8 == 63)
            {
              if (v32 > 1u) {
                goto LABEL_118;
              }
LABEL_80:
              if ((v68 & 0x100) != 0) {
                goto LABEL_118;
              }
              goto LABEL_81;
            }

            if (v8 == 255) {
              goto LABEL_118;
            }
            goto LABEL_127;
          }

          if (!v8) {
            goto LABEL_80;
          }
          if (v8 != 1) {
            goto LABEL_127;
          }
          if (v32 > 2u || (v68 & 0x100) != 0)
          {
            if (v32 > 2u) {
              unint64_t v32 = 3;
            }
LABEL_118:
            uint64_t v56 = v6;
            unint64_t v55 = *(void *)(v66 + 16);
            *(void *)(v66 + 16) = 0LL;
LABEL_119:
            uint64_t v57 = (unint64_t)operator new(0x20uLL);
            *(void *)uint64_t v57 = v11;
            *(void *)(v57 + 8) = v70;
            *(void *)(v57 + 16) = v55;
            goto LABEL_120;
          }

  uint64_t v19 = 0LL;
  Swift::UInt64 v41 = __p;
  if (!__p) {
    return v19;
  }
LABEL_70:
  operator delete(v41);
  return v19;
}

          uint64_t v46 = 0LL;
          goto LABEL_73;
        }

        goto LABEL_65;
      }

      unint64_t v45 = (uint64_t *)*a2;
    }

    char v36 = (swift::Demangle::__runtime::Node *)v45[1];
    goto LABEL_54;
  }

  return result;
}

unint64_t specialized FlattenSequence<>.distance(from:to:)( uint64_t a1, unint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6, int a7, void (*a8)(uint64_t *__return_ptr, int *), unint64_t *a9)
{
  char v12 = a3 & 1;
  char v13 = a6 & 1;
  char v14 = a6 & 1;
  if (a4 != a1)
  {
    if (specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, a6 & 1, a1, a2, v12))
    {
      BOOL v17 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a1, a2, v12, a4, a5, v14);
      unint64_t v37 = a2;
      char v21 = v12;
      unint64_t v22 = a5;
      uint64_t v23 = a4;
      uint64_t v24 = a1;
      if (v17) {
        goto LABEL_7;
      }
    }

    else
    {
      BOOL v26 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, v14, a1, a2, v12);
      unint64_t v37 = a5;
      char v21 = v13;
      unint64_t v22 = a2;
      char v13 = v12;
      uint64_t v23 = a1;
      uint64_t v24 = a4;
      if (v26) {
LABEL_7:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    if ((v13 & 1) != 0)
    {
      if (v23 >= v24)
      {
        unint64_t v15 = 0LL;
        if ((v21 & 1) != 0) {
          goto LABEL_38;
        }
        goto LABEL_36;
      }

      if (v23) {
        goto LABEL_41;
      }
      char v27 = v21;
      int v40 = a7;
      swift_retain(a9, v18, v19, v20);
      a8(&v41, &v40);
      swift_release((uint64_t)a9);
      uint64_t v28 = 2LL;
      uint64_t v29 = 3LL;
      unint64_t v30 = v41 >= 0x80 ? v28 : 1LL;
      unint64_t v31 = specialized RandomAccessCollection<>.distance(from:to:)(0LL, v30, v41);
      if (v24 > 1) {
        goto LABEL_41;
      }
    }

    else
    {
      if (v23) {
        goto LABEL_41;
      }
      char v27 = v21;
      int v40 = a7;
      swift_retain(a9, v18, v19, v20);
      a8(&v41, &v40);
      swift_release((uint64_t)a9);
      uint64_t v32 = 2LL;
      uint64_t v33 = 3LL;
      unint64_t v34 = v41 >= 0x80 ? v32 : 1LL;
      unint64_t v31 = specialized RandomAccessCollection<>.distance(from:to:)(v22, v34, v41);
      if (v24 >= 2) {
        goto LABEL_41;
      }
    }

    unint64_t v15 = v31;
    uint64_t v23 = 1LL;
    if ((v27 & 1) != 0) {
      goto LABEL_38;
    }
LABEL_36:
    if (v23) {
      goto LABEL_41;
    }
    int v40 = a7;
    swift_retain(a9, v18, v19, v20);
    a8(&v41, &v40);
    swift_release((uint64_t)a9);
    unint64_t v35 = specialized RandomAccessCollection<>.distance(from:to:)(0LL, v37, v41);
    BOOL v36 = __OFADD__(v15, v35);
    v15 += v35;
    if (v36)
    {
      __break(1u);
LABEL_43:
      __break(1u);
      goto LABEL_44;
    }

LABEL_44:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

  if ((a3 & 1) == 0) {
    goto LABEL_44;
  }
  return 0LL;
}

        *(_WORD *)(v2 + 1) = 0;
        goto LABEL_45;
    }
  }

  return v5 & 1;
}

    v129(v278, v85);
    char v162 = v127(v85, v16);
    v129(v131, v85);
    uint64_t v163 = *(_BYTE *)(v90 + 4);
    *(_DWORD *)v90 |= v162 << v163;
    unint64_t v164 = v271;
    uint64_t v165 = *(uint64_t (**)(uint64_t, unint64_t))(v271 + 56);
    *(_BYTE *)(v90 + 4) = v163 + v165(v85, v271);
    v269(&v281, 0LL);
    unint64_t v166 = v273;
    uint64_t v167 = v256;
    char v168 = v253;
    uint64_t v169 = (unint64_t)((uint64_t (*)(uint64_t, uint64_t))v253)(v273, v256) >> 32;
    uint64_t v170 = v165(v85, v164);
    if (!v170 || (v171 = v170, Swift::String::Index v78 = v167, v168(v166, v167), (v172 = v165(v85, v164)) == 0))
    {
      uint64_t v196 = 14377LL;
      goto LABEL_54;
    }

    uint64_t v173 = v169 / v171;
    Swift::String::Index v83 = v271;
    char v16 = v252;
    unint64_t v86 = v274;
    char v87 = v255;
    unint64_t v45 = v266;
    Swift::Int v85 = v268;
    if (v173 >= 32 / v172) {
      goto LABEL_49;
    }
  }

  (*(void (**)(char *, uint64_t))(v245 + 8))(v87, v246);
LABEL_49:
  uint64_t v175 = v272;
  unint64_t v174 = v273;
  __int128 v176 = v240;
  unint64_t v177 = *(void (**)(char *, uint64_t, uint64_t))(v240 + 16);
  uint64_t v178 = v241;
  v177(v241, v272, v273);
  uint64_t v179 = (*(uint64_t (**)(uint64_t, uint64_t))(v78 + 24))(v174, v78);
  unint64_t v180 = v179;
  unint64_t v278 = (char *)(v179 >> 8);
  unint64_t v181 = BYTE1(v179);
  char v182 = *(void (**)(char *, uint64_t))(v176 + 8);
  v182(v178, v174);
  v177(v178, v175, v174);
  __int128 v183 = *(void (**)(uint64_t, uint64_t, uint64_t))(v78 + 32);
  LODWORD(v277) = v181;
  v183(v181, v174, v78);
  v182(v178, v174);
  char v184 = (uint64_t (*)(uint64_t, uint64_t))v253;
  __int128 v185 = ((uint64_t (*)(uint64_t, uint64_t))v253)(v174, v78);
  LOBYTE(v181) = (_BYTE)v278;
  __int128 v186 = (unint64_t)v185 >> (char)v278;
  uint64_t v187 = *(uint64_t (**)(int *, uint64_t, uint64_t))(v78 + 56);
  id v188 = (void (*)(int *, void))v187(&v281, v174, v78);
  *uint64_t v189 = v186;
  v188(&v281, 0LL);
  LOBYTE(v181) = ((unint64_t)v184(v174, v78) >> 32) - v181;
  uint64_t v190 = (void (*)(int *, void))v187(&v281, v174, v78);
  *(_BYTE *)(v191 + 4) = v181;
  v190(&v281, 0LL);
  if ((v180 & 1) != 0)
  {
    unint64_t v192 = v248;
    unint64_t v193 = v247;
    (*(void (**)(void *, char *, unint64_t))(v242 + 32))(v248, v257, v247);
    uint64_t v61 = type metadata accessor for Unicode.ParseResult(0LL, v193, v194, v195);
    unint64_t v62 = v192;
    goto LABEL_51;
  }

  unint64_t v226 = v277;
  uint64_t v227 = v257;
  char v228 = (*(uint64_t (**)(uint64_t))(v271 + 56))(v85);
  uint64_t v229 = specialized numericCast<A, B>(_:)(v228);
  if (!v229)
  {
    uint64_t v196 = 480LL;
LABEL_54:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  v196,  0);
  }

  uint64_t v230 = v229;
  char v231 = v227;
  unint64_t v232 = v247;
  (*(void (**)(char *, unint64_t))(v242 + 8))(v231, v247);
  unint64_t v233 = v226 / v230;
  unint64_t v234 = v248;
  void *v248 = v233;
  uint64_t v61 = type metadata accessor for Unicode.ParseResult(0LL, v232, v235, v236);
  unint64_t v62 = v234;
  unint64_t v63 = 1;
LABEL_52:
  swift_storeEnumTagMultiPayload(v62, v61, v63);
}

        unint64_t v34 = v99 ^ v84 ^ 1;
        goto LABEL_11;
      }

      v140[0] = 0LL;
      int64_t v53 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
      uint64_t v54 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
      unint64_t v55 = v129;
      v53(v140, &type metadata for Int, v54, v12, v41);
      uint64_t v56 = v133;
      uint64_t v114 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v41 + 32) + 8LL)
                                                                           + 16LL))( v133,  v55,  v12);
      uint64_t v57 = *(void (**)(char *, unint64_t *))(v130 + 8);
      v57(v55, v12);
      uint64_t v58 = v56;
    }

    unint64_t v120 = v57;
    v57(v58, v12);
    goto LABEL_23;
  }

  unint64_t v34 = 1;
  return v34 & 1;
}

  uint64_t v18 = 1;
LABEL_47:
  uint64_t v19 = v9;
  char v20 = v10;
  result.partialValue.high = v20;
  result.partialValue.low = v19;
  result.overflow = v18;
  return result;
}

              uint64_t v10 = *(void (**)(uint64_t, int))v10;
LABEL_45:
              uint64_t v10 = (void (*)(uint64_t, int))((char *)v10 + 8);
              break;
            default:
              unint64_t v135 = 0;
              char v14 = 0LL;
              goto LABEL_478;
          }

          goto LABEL_50;
        }

        if (v17 == 5 && *((_DWORD *)v10 + 2))
        {
LABEL_49:
          uint64_t v10 = *(void (**)(uint64_t, int))v10;
LABEL_50:
          uint64_t v10 = *(void (**)(uint64_t, int))v10;
          goto LABEL_51;
        }

        uint64_t v10 = 0LL;
LABEL_51:
        if (++v9 == 1025) {
          goto LABEL_2;
        }
        continue;
      case 0xE2:
      case 0xE3:
      case 0xE4:
        *(void *)&v541 = &v542;
        *((void *)&v541 + 1) = 0x800000000LL;
        uint64_t v32 = *((unsigned __int8 *)v10 + 18);
        uint64_t v33 = (const char *)v10;
        if (v32 == 5)
        {
          unint64_t v34 = *(const char **)v10;
          uint64_t v33 = *(const char **)v10;
LABEL_204:
          uint64_t v94 = &v34[8 * *((unsigned int *)v10 + 2)];
          goto LABEL_247;
        }

        uint64_t v33 = 0LL;
LABEL_200:
        switch(v32)
        {
          case 1:
            uint64_t v94 = (char *)v10 + 8;
            break;
          case 2:
            uint64_t v94 = (char *)v10 + 16;
            break;
          case 5:
            unint64_t v34 = *(const char **)v10;
            goto LABEL_204;
          default:
            uint64_t v94 = 0LL;
            break;
        }

    if (v29 == v249)
    {
      char v272 = v271;
      (*(void (**)(void *, void *))(v249[0] + 24LL))(v249, v271);
    }

    else
    {
      char v272 = (void *)(*(uint64_t (**)(void *))(*v29 + 16LL))(v29);
    }

  *(_DWORD *)(a2 + 12736) = v25 + 1;
  v15[v25] = v26;
  swift::Demangle::__runtime::CharVector::append((char **)v14, __s2, __n, *(void **)(a2 + 12744));
  uint64_t result = 1LL;
  a1[1] = 1LL;
  return result;
}

    if (v15 == 2)
    {
LABEL_48:
      uint64_t v24 = (swift::Demangle::__runtime::Node *)*((void *)v5 + 1);
LABEL_50:
      return;
    }

    BOOL v17 = *((_DWORD *)v5 + 2);
    goto LABEL_46;
  }

Swift::UInt64 specialized FlattenSequence<>.distance(from:to:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, char a6, uint64_t a7, unint64_t a8, void (*a9)(unint64_t *__return_ptr, uint64_t *), unint64_t *a10)
{
  Swift::UInt64 rawBits = a8;
  uint64_t v11 = a7;
  unint64_t v12 = a5;
  Swift::UInt64 v14 = a2;
  unint64_t v15 = (unint64_t)a10;
  uint64_t v16 = a3 & 1;
  unint64_t v17 = a6 & 1;
  char v18 = a6 & 1;
  if (a4 != a1)
  {
    if (specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, a5, a6 & 1, a1, a2, a3 & 1))
    {
      BOOL v21 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a1, v14, v16, a4, v12, v18);
      to._Swift::UInt64 rawBits = v14;
      char v25 = v16;
      unint64_t v26 = v12;
      uint64_t v27 = a4;
      uint64_t v28 = a1;
      if (v21) {
        goto LABEL_7;
      }
    }

    else
    {
      BOOL v35 = specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, v12, v18, a1, v14, v16);
      to._Swift::UInt64 rawBits = v12;
      char v25 = v17;
      unint64_t v26 = v14;
      unint64_t v17 = v16;
      uint64_t v27 = a1;
      uint64_t v28 = a4;
      if (v35) {
LABEL_7:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    unint64_t v70 = v14;
    uint64_t v71 = v28;
    char v72 = v25;
    if ((v17 & 1) != 0)
    {
      Swift::Int v34 = 0LL;
      if (v27 < v28)
      {
LABEL_20:
        if (!v27)
        {
          uint64_t v73 = v11;
          Swift::UInt64 v74 = rawBits;
          swift_bridgeObjectRetain(rawBits, v22, v23, v24);
          swift_retain(a10, v36, v37, v38);
          a9(&v75, &v73);
          swift_release((uint64_t)a10);
          swift_bridgeObjectRelease(rawBits);
          unint64_t v39 = v75;
          unint64_t v15 = v76;
          if ((v76 & 0x1000000000000000LL) != 0)
          {
            unint64_t v17 = String.UTF8View._foreignCount()();
            swift_bridgeObjectRelease(v15);
          }

          else
          {
            swift_bridgeObjectRelease(v76);
            if ((v15 & 0x2000000000000000LL) != 0) {
              unint64_t v17 = HIBYTE(v15) & 0xF;
            }
            else {
              unint64_t v17 = v39 & 0xFFFFFFFFFFFFLL;
            }
          }

          BOOL v40 = __OFADD__(v34, v17);
          v34 += v17;
          if (v40)
          {
            __break(1u);
            goto LABEL_69;
          }

          if (v71 < 2 && (v72 & 1) != 0)
          {
            do
            {
              while (1)
              {
LABEL_53:
                if (!specialized static FlattenSequence<>.Index.< infix(_:_:)(a4, v12, v18, a1, v70, v16)) {
                  return v34;
                }
                BOOL v40 = __OFSUB__(0LL, v34);
                Swift::Int v34 = -v34;
                if (!v40) {
                  return v34;
                }
LABEL_69:
                __break(1u);
LABEL_70:
                Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
                if ((v15 & 0x1000000000000000LL) != 0) {
                  break;
                }
LABEL_52:
                swift_bridgeObjectRelease(v15);
                unint64_t v17 = rawBits >> 16;
                BOOL v40 = __OFADD__(v34, rawBits >> 16);
                v34 += rawBits >> 16;
                if (v40) {
                  goto LABEL_76;
                }
              }

LABEL_71:
              unint64_t v64 = v17 & 0xFFFFFFFFFFFFLL;
              if ((v15 & 0x2000000000000000LL) != 0) {
                unint64_t v64 = HIBYTE(v15) & 0xF;
              }
              if (v64 < rawBits >> 16) {
                goto LABEL_77;
              }
              unint64_t v17 = String.UTF8View._foreignDistance(from:to:)( (Swift::String::Index)15LL,  (Swift::String::Index)rawBits);
              swift_bridgeObjectRelease(v15);
              BOOL v40 = __OFADD__(v34, v17);
              v34 += v17;
            }

            while (!v40);
LABEL_76:
            __break(1u);
            goto LABEL_77;
          }
        }

uint64_t FlattenSequence<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = (const char *)a5;
  uint64_t v7 = a4;
  uint64_t v10 = *(void *)(a3 + 16);
  uint64_t v11 = type metadata accessor for FlattenSequence<>.Index(255LL, v10, a4, a5);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v11, v11, "lower upper ", 0LL);
  uint64_t v12 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  int64_t v202 = (char *)&v173 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  __int128 v185 = (char *)&v173 - v15;
  uint64_t v210 = *(void *)(v11 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v179 = (char *)&v173 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v178 = (char *)&v173 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v201 = (char *)&v173 - v21;
  MEMORY[0x1895F8858](v20);
  unint64_t v177 = (char *)&v173 - v22;
  uint64_t v195 = v11;
  uint64_t v189 = type metadata accessor for Range( 0LL,  v11,  (uint64_t)&protocol witness table for FlattenSequence<A><>.Index,  v23);
  uint64_t v188 = *(void *)(v189 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v189);
  __int128 v186 = (char *)&v173 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v24);
  unint64_t v192 = (char *)&v173 - v26;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v10,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v207 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v205 = (char *)&v173 - v29;
  uint64_t v206 = (char *)v28;
  unint64_t v30 = swift_getAssociatedTypeWitness( 255LL,  v6,  v28,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v197 = type metadata accessor for Optional(0LL, v30, v31, v32);
  uint64_t v191 = *(void *)(v197 - 8);
  uint64_t v33 = MEMORY[0x1895F8858](v197);
  unint64_t v181 = (char *)&v173 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  char v184 = (char *)&v173 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  __int128 v176 = (char *)&v173 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v211 = (char *)&v173 - v40;
  unint64_t v199 = v30;
  uint64_t v193 = *(void *)(v30 - 8);
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  unint64_t v180 = (char *)&v173 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  char v182 = (char *)&v173 - v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v175 = (char *)&v173 - v46;
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  unint64_t v174 = (char *)&v173 - v48;
  MEMORY[0x1895F8858](v47);
  __int128 v183 = (char *)&v173 - v49;
  uint64_t v50 = a2;
  unint64_t v51 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v198 = *(void *)(v51 - 8);
  uint64_t v52 = MEMORY[0x1895F8858](v51);
  uint64_t v54 = (char *)&v173 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v55 = MEMORY[0x1895F8858](v52);
  uint64_t v57 = (char *)&v173 - v56;
  uint64_t v58 = MEMORY[0x1895F8858](v55);
  uint64_t v190 = (char *)&v173 - v59;
  uint64_t v208 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v58);
  uint64_t v203 = (char *)&v173 - ((v60 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v196 = a1;
  uint64_t v213 = v10;
  char v61 = static FlattenSequence<>.Index.< infix(_:_:)(v50, a1, v10, v7, v6);
  uint64_t v194 = v50;
  unint64_t v209 = v6;
  if ((v61 & 1) != 0)
  {
    uint64_t v62 = v213;
    uint64_t v63 = v5;
    uint64_t v200 = v54;
    uint64_t v64 = v208;
    unint64_t v65 = v203;
    (*(void (**)(char *, uint64_t, uint64_t))(v208 + 16))(v203, v5, v213);
    unint64_t v66 = v190;
    (*(void (**)(uint64_t, uint64_t))(v7 + 72))(v62, v7);
    (*(void (**)(uint64_t, uint64_t))(v7 + 64))(v62, v7);
    (*(void (**)(char *, char *, uint64_t, uint64_t))(v7 + 152))(v66, v57, v62, v7);
    uint64_t v67 = *(void (**)(char *, unint64_t))(v198 + 8);
    v67(v57, v51);
    v67(v66, v51);
    uint64_t v50 = v194;
    Swift::UInt64 v68 = *(void (**)(char *, uint64_t))(v64 + 8);
    uint64_t v54 = v200;
    uint64_t v5 = v63;
    uint64_t v69 = v65;
    unint64_t v6 = v209;
    v68(v69, v62);
  }

  uint64_t v212 = v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v213,  v51,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v70 = v196;
  if (((*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                      + 8LL))( v196,  v50,  v51) & 1) != 0)
  {
    uint64_t v71 = v195;
    uint64_t v72 = v191;
    uint64_t v73 = *(void (**)(char *, uint64_t, uint64_t))(v191 + 16);
    Swift::UInt64 v74 = v211;
    uint64_t v75 = v197;
    v73(v211, v70 + *(int *)(v195 + 44), v197);
    uint64_t v76 = v193;
    Swift::Int v77 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v193 + 48);
    if (v77(v74, 1LL, v199) == 1)
    {
      (*(void (**)(char *, uint64_t))(v72 + 8))(v74, v75);
      return 0LL;
    }

    uint64_t v95 = v71;
    unint64_t v96 = *(const char **)(v76 + 32);
    unint64_t v97 = v183;
    unint64_t v98 = v199;
    ((void (*)(char *, char *, unint64_t))v96)(v183, v74, v199);
    uint64_t v99 = v197;
    uint64_t v100 = v194 + *(int *)(v95 + 44);
    unsigned int v101 = v176;
    v73(v176, v100, v197);
    if (v77(v101, 1LL, v98) == 1)
    {
      (*(void (**)(char *, unint64_t))(v76 + 8))(v97, v199);
      (*(void (**)(char *, uint64_t))(v191 + 8))(v101, v99);
      return 0LL;
    }

uint64_t FlattenSequence<>._advanceIndex(_:step:)( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v10 = type metadata accessor for FlattenSequence<>.Index(0LL, *(void *)(a3 + 16), a4, (uint64_t)a5);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v16 - v12;
  uint64_t v14 = (char *)&v16 - v12;
  if (a2 < 0) {
    FlattenSequence<>._index(before:)(a1, a3, a4, (uint64_t)a5, v14);
  }
  else {
    FlattenSequence<>._index(after:)(a1, a3, a4, a5, (uint64_t)v14);
  }
  (*(void (**)(char *, uint64_t))(v11 + 8))(a1, v10);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v11 + 32))(a1, v13, v10);
}

uint64_t static RangeExpression.~= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 32))(a2, a3, a4) & 1;
}

uint64_t FlattenSequence<>._ensureBidirectional(step:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v20 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  Swift::UInt64 v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v20 - v10;
  uint64_t v14 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v12, v13);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t result = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v20 - v17;
  uint64_t v21 = a1;
  if (a1 < 0)
  {
    (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v5, a3);
    (*(void (**)(uint64_t, uint64_t))(a3 + 64))(v5, a3);
    (*(void (**)(char *, uint64_t, char *, uint64_t, uint64_t))(a3 + 144))(v11, v21, v9, v5, a3);
    uint64_t v19 = *(void (**)(char *, unint64_t))(v20 + 8);
    v19(v9, AssociatedTypeWitness);
    v19(v11, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v18, v14);
  }

  return result;
}

uint64_t FlattenSequence<>.index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, char *a6@<X8>)
{
  uint64_t v34 = a1;
  uint64_t v11 = *(void *)(a3 + 16);
  uint64_t v12 = type metadata accessor for FlattenSequence<>.Index(0LL, v11, a4, (uint64_t)a5);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v28 - v14;
  uint64_t v37 = (void (*)(char *, uint64_t))v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v31 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v36 = (char *)&v28 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v35 = (char *)&v28 - v19;
  uint64_t v33 = v20;
  uint64_t v23 = type metadata accessor for Optional(0LL, v20, v21, v22);
  uint64_t v29 = *(void *)(v23 - 8);
  uint64_t v30 = v23;
  MEMORY[0x1895F8858](v23);
  uint64_t v32 = (char *)&v28 - v24;
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v13 + 16))(a6, v34, v12);
  unint64_t v26 = (a2 > 0) | (unint64_t)(a2 >> 63);
  if ((v26 & 0x8000000000000000LL) != 0)
  {
    (*(void (**)(void, uint64_t))(a4 + 72))(v37, a4);
    (*(void (**)(void, uint64_t))(a4 + 64))(v37, a4);
    (*(void (**)(char *, unint64_t, char *, void (*)(char *, uint64_t), uint64_t))(a4 + 144))( v35,  (a2 > 0) | (unint64_t)(a2 >> 63),  v36,  v37,  a4);
    uint64_t v37 = *(void (**)(char *, uint64_t))(v31 + 8);
    v37(v36, v33);
    v37(v35, v33);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v29 + 8))(v32, v30);
    if ((a2 & 0x8000000000000000LL) == 0)
    {
LABEL_3:
      if (!a2) {
        return result;
      }
      goto LABEL_11;
    }
  }

  else if ((a2 & 0x8000000000000000LL) == 0)
  {
    goto LABEL_3;
  }

  BOOL v27 = __OFSUB__(0LL, a2);
  a2 = -a2;
  if (v27)
  {
    __break(1u);
    return result;
  }

  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  do
  {
LABEL_11:
    if ((v26 & 0x8000000000000000LL) != 0) {
      FlattenSequence<>._index(before:)(a6, a3, a4, (uint64_t)a5, v15);
    }
    else {
      FlattenSequence<>._index(after:)(a6, a3, a4, a5, (uint64_t)v15);
    }
    (*(void (**)(char *, uint64_t))(v13 + 8))(a6, v12);
    uint64_t result = (*(uint64_t (**)(char *, char *, uint64_t))(v13 + 32))(a6, v15, v12);
    --a2;
  }

  while (a2);
  return result;
}

uint64_t FlattenSequence<>.formIndex(_:offsetBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v10 = type metadata accessor for FlattenSequence<>.Index(0LL, *(void *)(a3 + 16), a4, (uint64_t)a5);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v15 - v12;
  FlattenSequence<>.index(_:offsetBy:)(a1, a2, a3, a4, a5, (char *)&v15 - v12);
  (*(void (**)(uint64_t, uint64_t))(v11 + 8))(a1, v10);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v11 + 32))(a1, v13, v10);
}

uint64_t FlattenSequence<>.index(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, const char *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v98 = a3;
  uint64_t v79 = a7;
  uint64_t v11 = *(const char **)(a5 + 8);
  uint64_t v96 = a4;
  uint64_t v12 = *(void *)(a4 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  a6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v89 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v80 = (char *)&v79 - v14;
  uint64_t v86 = v15;
  uint64_t v18 = type metadata accessor for Optional(0LL, v15, v16, v17);
  uint64_t v88 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v83 = (char *)&v79 - v19;
  uint64_t v85 = v20;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v20, v20, 0LL, 0LL);
  uint64_t v84 = *(TupleTypeMetadata2 - 1);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v91 = (char *)&v79 - v21;
  unint64_t v22 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v95 = *(char **)(v22 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v79 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  BOOL v27 = (char *)&v79 - v26;
  uint64_t v103 = v28;
  uint64_t v31 = type metadata accessor for Optional(0LL, v28, v29, v30);
  uint64_t v93 = *(void *)(v31 - 8);
  uint64_t v94 = v31;
  MEMORY[0x1895F8858](v31);
  uint64_t v33 = (char *)&v79 - v32;
  uint64_t v102 = a5;
  uint64_t v104 = a6;
  uint64_t v34 = type metadata accessor for FlattenSequence<>.Index(0LL, v12, a5, (uint64_t)a6);
  uint64_t v35 = MEMORY[0x1895F8858](v34);
  uint64_t v37 = (char *)&v79 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = MEMORY[0x1895F8858](v35);
  unsigned int v101 = (char *)&v79 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  uint64_t v100 = (char *)&v79 - v41;
  MEMORY[0x1895F8858](v40);
  uint64_t v43 = (char *)&v79 - v42;
  uint64_t v87 = v44;
  unint64_t v97 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v44 + 16);
  uint64_t result = v97((char *)&v79 - v42, a1, v34);
  unint64_t v99 = (a2 > 0) | (unint64_t)(a2 >> 63);
  if ((v99 & 0x8000000000000000LL) != 0)
  {
    uint64_t v46 = v102;
    (*(void (**)(uint64_t, uint64_t))(v102 + 72))(v12, v102);
    (*(void (**)(uint64_t, uint64_t))(v46 + 64))(v12, v46);
    (*(void (**)(char *, unint64_t, char *, uint64_t, uint64_t))(v46 + 144))(v27, v99, v25, v12, v46);
    uint64_t v47 = (void (*)(char *, uint64_t))*((void *)v95 + 1);
    uint64_t v48 = v103;
    v47(v25, v103);
    v47(v27, v48);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v93 + 8))(v33, v94);
  }

  uint64_t v49 = v12;
  uint64_t v95 = v37;
  if (a2 < 0)
  {
    BOOL v56 = __OFSUB__(0LL, a2);
    a2 = -a2;
    uint64_t v50 = v85;
    uint64_t v51 = v87;
    uint64_t v53 = v100;
    uint64_t v52 = v101;
    if (v56)
    {
      __break(1u);
      return result;
    }

    if (a2 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  else
  {
    uint64_t v50 = v85;
    uint64_t v51 = v87;
    uint64_t v53 = v100;
    uint64_t v52 = v101;
    if (!a2)
    {
      uint64_t v54 = *(void (**)(uint64_t, char *, uint64_t))(v87 + 32);
LABEL_6:
      uint64_t v55 = v79;
      v54(v79, v43, v34);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v51 + 56))(v55, 0LL, 1LL, v34);
    }
  }

  uint64_t v94 = *(void *)(swift_getAssociatedConformanceWitness( v102,  v49,  v103,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v93 = *(void *)(v94 + 8);
  while (1)
  {
    uint64_t v57 = v98;
    char v58 = ((uint64_t (*)(char *, uint64_t))v93)(v43, v98);
    uint64_t v59 = (void (*)(char *, uint64_t, uint64_t))v97;
    v97(v53, (uint64_t)v43, v34);
    v59(v52, v57, v34);
    if ((v58 & 1) == 0)
    {
      uint64_t v72 = v53;
      Swift::UInt64 v68 = *(void (**)(char *, uint64_t))(v51 + 8);
      v68(v52, v34);
      v68(v72, v34);
      goto LABEL_21;
    }

    uint64_t v92 = a2;
    uint64_t v60 = *(int *)(v34 + 44);
    char v61 = &v52[v60];
    uint64_t v62 = &v91[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v63 = v52;
    uint64_t v64 = v51;
    unint64_t v65 = v91;
    unint64_t v66 = *(void (**)(char *, char *, uint64_t))(v88 + 16);
    v66(v91, &v53[v60], v50);
    uint64_t v67 = v53;
    Swift::UInt64 v68 = *(void (**)(char *, uint64_t))(v64 + 8);
    v68(v67, v34);
    v66(v62, v61, v50);
    v68(v63, v34);
    uint64_t v69 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v89 + 48);
    uint64_t v70 = v86;
    if (v69(v65, 1LL, v86) == 1) {
      break;
    }
    uint64_t v73 = v83;
    v66(v83, v65, v50);
    if (v69(v62, 1LL, v70) == 1)
    {
      (*(void (**)(char *, uint64_t))(v89 + 8))(v73, v70);
      a2 = v92;
      goto LABEL_19;
    }

    uint64_t v74 = v89;
    uint64_t v75 = v80;
    (*(void (**)(char *, char *, uint64_t))(v89 + 32))(v80, v62, v70);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v104,  AssociatedTypeWitness,  v70,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    int v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v73,  v75,  v70);
    Swift::Int v77 = *(void (**)(char *, uint64_t))(v74 + 8);
    v77(v75, v70);
    v77(v73, v70);
    (*(void (**)(char *, uint64_t))(v88 + 8))(v65, v50);
    uint64_t v51 = v87;
    a2 = v92;
    if ((v82 & 1) != 0) {
      goto LABEL_23;
    }
LABEL_21:
    char v78 = v95;
    if ((v99 & 0x8000000000000000LL) != 0) {
      FlattenSequence<>._index(before:)(v43, v96, v102, (uint64_t)v104, v95);
    }
    else {
      FlattenSequence<>._index(after:)(v43, v96, v102, v104, (uint64_t)v95);
    }
    v68(v43, v34);
    uint64_t v54 = *(void (**)(uint64_t, char *, uint64_t))(v51 + 32);
    v54((uint64_t)v43, v78, v34);
    --a2;
    uint64_t v53 = v100;
    uint64_t v52 = v101;
    if (!a2) {
      goto LABEL_6;
    }
  }

  unsigned int v71 = v69(v62, 1LL, v70);
  a2 = v92;
  if (v71 != 1)
  {
LABEL_19:
    (*(void (**)(char *, unint64_t *))(v84 + 8))(v91, TupleTypeMetadata2);
    uint64_t v50 = v85;
    uint64_t v51 = v87;
    goto LABEL_21;
  }

  (*(void (**)(char *, uint64_t))(v88 + 8))(v91, v85);
  uint64_t v51 = v87;
LABEL_23:
  v68(v43, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v51 + 56))(v79, 1LL, 1LL, v34);
}

BOOL FlattenSequence<>.formIndex(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6)
{
  uint64_t v12 = type metadata accessor for FlattenSequence<>.Index(255LL, *(void *)(a4 + 16), a5, (uint64_t)a6);
  uint64_t v15 = type metadata accessor for Optional(0LL, v12, v13, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v24 - v17;
  uint64_t v19 = a2;
  uint64_t v20 = a3;
  FlattenSequence<>.index(_:offsetBy:limitedBy:)(a1, v19, a3, a4, a5, a6, (uint64_t)&v24 - v17);
  uint64_t v21 = *(void *)(v12 - 8);
  (*(void (**)(uint64_t, uint64_t))(v21 + 8))(a1, v12);
  int v22 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v21 + 48))(v18, 1LL, v12);
  if (v22 == 1)
  {
    (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v15);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v21 + 16))(a1, v20, v12);
  }

  else
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v21 + 32))(a1, v18, v12);
  }

  return v22 != 1;
}

uint64_t FlattenSequence<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v31 = a5;
  uint64_t v8 = *(void *)(a2 + 16);
  Swift::UInt64 v9 = *(const char **)(a3 + 8);
  uint64_t v30 = associated type descriptor for Sequence.Element;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = type metadata accessor for Optional(0LL, v11, v12, v13);
  uint64_t v32 = *(void *)(v14 - 8);
  uint64_t v33 = v14;
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = (char *)&v29 - v15;
  uint64_t v17 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v18 = *(v17 - 1);
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v29 - v19;
  uint64_t v21 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(a3 + 80))( v35,  a1,  v8,  a3);
  uint64_t v34 = v18;
  (*(void (**)(char *))(v18 + 16))(v20);
  v21(v35, 0LL);
  uint64_t v22 = type metadata accessor for FlattenSequence<>.Index(0LL, v8, a3, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v32 + 16))(v16, a1 + *(int *)(v22 + 44), v33);
  uint64_t v23 = *(void *)(v11 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v23 + 48))(v16, 1LL, v11) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0x19BuLL,  0);
  }
  uint64_t v24 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, char *, unint64_t *, uint64_t))(a4 + 80))( v35,  v16,  v17,  a4);
  uint64_t v26 = v25;
  unint64_t v27 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  (uint64_t)v17,  (uint64_t)&protocol requirements base descriptor for Sequence,  v30);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v27 - 8) + 16LL))(v31, v26, v27);
  v24(v35, 0LL);
  (*(void (**)(char *, unint64_t *))(v34 + 8))(v20, v17);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v16, v11);
}

{
  return ClosedRange<>.subscript.getter( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t, void))type metadata accessor for FlattenSequence<>.Index,  (uint64_t)&protocol witness table for FlattenSequence<A><>.Index,  (uint64_t)&protocol conformance descriptor for <> FlattenSequence<A>,  a5);
}

uint64_t ClosedRange<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(uint64_t, void)@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v11 = v8;
  uint64_t v28 = a1;
  uint64_t v16 = a5(255LL, *(void *)(a2 + 16));
  uint64_t v18 = type metadata accessor for Range(0LL, v16, a6, v17);
  uint64_t v19 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v21 = (char *)&v27 - v20;
  v29[0] = a3;
  v29[1] = a4;
  uint64_t WitnessTable = swift_getWitnessTable(a7, a2, v29);
  uint64_t v24 = type metadata accessor for Slice(0LL, a2, WitnessTable, v23);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a8 + *(int *)(v24 + 40), v11, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v21, v28, v18);
  uint64_t v25 = *(void (**)(uint64_t, char *, uint64_t))(*(void *)(v16 - 8) + 32LL);
  v25(a8, v21, v16);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v25)(a8 + *(int *)(v24 + 36), &v21[*(int *)(v18 + 36)], v16);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  return FlattenSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), *(const char **)(a2 - 16), a3);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return FlattenSequence<>.endIndex.getter(a1, *(void *)(a2 - 8), *(const char **)(a2 - 16), a3);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> FlattenSequence<A>( unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = (unint64_t *)malloc(0x28uLL);
  *a1 = v8;
  v8[4] = (unint64_t)FlattenSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*FlattenSequence<>.subscript.read( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v10 = *(const char **)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a4 + 8),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  *a1 = v12;
  unint64_t v13 = *(void *)(v12 - 8);
  a1[1] = v13;
  uint64_t v14 = malloc(*(void *)(v13 + 64));
  a1[2] = (unint64_t)v14;
  FlattenSequence<>.subscript.getter(a2, a3, a4, a5, (uint64_t)v14);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return FlattenSequence<>.subscript.getter(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16), a4);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = type metadata accessor for FlattenSequence<>.Index( 255LL,  *(void *)(a1 + 16),  *(void *)(a2 - 8),  *(void *)(a2 - 16));
  uint64_t v7 = type metadata accessor for Optional(0LL, v4, v5, v6);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56LL))(a3, 1LL, 1LL, v7);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 - 8), *(const char **)(a4 - 16), a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:limitedBy:)( a1,  a2,  a3,  a4,  *(void *)(a5 - 8),  *(const char **)(a5 - 16),  a6);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> FlattenSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return FlattenSequence<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> FlattenSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return FlattenSequence<>.index(after:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> FlattenSequence<A>( char *a1, uint64_t a2, uint64_t a3)
{
  return FlattenSequence<>.formIndex(after:)(a1, a2, *(void *)(a3 - 8), *(const char **)(a3 - 16));
}

uint64_t FlattenSequence<>.index(before:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  return FlattenSequence<>._index(before:)(a1, a2, *(void *)(a3 + 8), *(void *)(a4 + 8), a5);
}

uint64_t FlattenSequence<>.formIndex(before:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t v7 = *(void *)(a4 + 8);
  uint64_t v8 = type metadata accessor for FlattenSequence<>.Index(0LL, *(void *)(a2 + 16), v6, v7);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v13 - v10;
  FlattenSequence<>._index(before:)(a1, a2, v6, v7, (char *)&v13 - v10);
  (*(void (**)(char *, uint64_t))(v9 + 8))(a1, v8);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v9 + 32))(a1, v11, v8);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> FlattenSequence<A>@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  return FlattenSequence<>.index(before:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> FlattenSequence<A>( char *a1, uint64_t a2, uint64_t a3)
{
  return FlattenSequence<>.formIndex(before:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:)( a1,  a2,  a3,  *(void *)(*(void *)(a4 - 8) + 8LL),  *(const char **)(*(void *)(a4 - 16) + 8LL),  a5);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance <> FlattenSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return FlattenSequence<>.index(_:offsetBy:limitedBy:)( a1,  a2,  a3,  a4,  *(void *)(*(void *)(a5 - 8) + 8LL),  *(const char **)(*(void *)(a5 - 16) + 8LL),  a6);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> FlattenSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return FlattenSequence<>.distance(from:to:)( a1,  a2,  a3,  *(void *)(*(void *)(a4 - 8) + 8LL),  *(void *)(*(void *)(a4 - 16) + 8LL));
}

uint64_t static FloatingPoint.ulpOfOne.getter(uint64_t a1, uint64_t a2)
{
  return static FloatingPoint.ulpOfOne.getter(a1, a2);
}

{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  char *v11;
  unint64_t AssociatedConformanceWitness;
  uint64_t v14;
  uint64_t v4 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(v7 + 16) + 8LL) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v14 - v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v11, a1, v8);
  (*(void (**)(uint64_t, uint64_t))(a2 + 136))(a1, a2);
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, a1);
}

uint64_t FloatingPoint.remainder(dividingBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, v7, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 216))(a1, a2, a3);
}

{
  uint64_t v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, v4, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 216))(a1, a2, a3);
}

uint64_t FloatingPoint.truncatingRemainder(dividingBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, v7, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 232))(a1, a2, a3);
}

{
  uint64_t v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, v4, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 232))(a1, a2, a3);
}

uint64_t FloatingPoint.squareRoot()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 248))(a1, a2);
}

{
  uint64_t v3;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a3, v3, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 248))(a1, a2);
}

uint64_t FloatingPoint.addingProduct(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 264))(a1, a2, a3, a4);
}

{
  uint64_t v5;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, v5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 264))(a1, a2, a3, a4);
}

uint64_t static FloatingPoint.minimum(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.minimum(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  char v17;
  uint64_t v19;
  uint64_t v8 = a1;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v14 + 24) + 8LL) + 24LL))(v11);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v16(v13, a2, a3);
  if ((v15 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
  }

  else
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
    if ((v17 & 1) == 0) {
      uint64_t v8 = a2;
    }
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v16)(a5, v8, a3);
}

uint64_t static FloatingPoint.maximum(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.maximum(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char v15;
  void (*v16)(char *, uint64_t, uint64_t);
  char v17;
  uint64_t v19;
  uint64_t v8 = a1;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v14 + 24) + 8LL) + 40LL))(v11);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v16(v13, a2, a3);
  if ((v15 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
  }

  else
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a3);
    if ((v17 & 1) == 0) {
      uint64_t v8 = a2;
    }
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v16)(a5, v8, a3);
}

uint64_t static FloatingPoint.minimumMagnitude(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.minimumMagnitude(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t);
  uint64_t v21;
  char v22;
  void (*v23)(char *, uint64_t);
  void (*v24)(char *, uint64_t, uint64_t);
  uint64_t v25;
  char v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v29 = a5;
  uint64_t v8 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v28 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v28 - v16;
  uint64_t v19 = *(void *)(*(void *)(v18 + 16) + 8LL);
  uint64_t v20 = *(void (**)(uint64_t, uint64_t))(v19 + 56);
  uint64_t v28 = v15;
  v20(v21, v19);
  v20(a3, v19);
  uint64_t v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 24) + 8LL) + 24LL))( v17,  v14,  a3);
  uint64_t v23 = *(void (**)(char *, uint64_t))(v8 + 8);
  v23(v14, a3);
  v23(v17, a3);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v24(v11, a2, a3);
  if ((v22 & 1) != 0)
  {
    v23(v11, a3);
    uint64_t v25 = v28;
  }

  else
  {
    uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    v23(v11, a3);
    uint64_t v25 = v28;
    if ((v26 & 1) == 0) {
      uint64_t v25 = a2;
    }
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v24)(v29, v25, a3);
}

uint64_t static FloatingPoint.maximumMagnitude(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FloatingPoint.maximumMagnitude(_:_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t);
  uint64_t v21;
  char v22;
  void (*v23)(char *, uint64_t);
  void (*v24)(char *, uint64_t, uint64_t);
  uint64_t v25;
  char v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v29 = a5;
  uint64_t v8 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v28 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v28 - v16;
  uint64_t v19 = *(void *)(*(void *)(v18 + 16) + 8LL);
  uint64_t v20 = *(void (**)(uint64_t, uint64_t))(v19 + 56);
  uint64_t v28 = v15;
  v20(v21, v19);
  v20(a3, v19);
  uint64_t v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 24) + 8LL) + 40LL))( v17,  v14,  a3);
  uint64_t v23 = *(void (**)(char *, uint64_t))(v8 + 8);
  v23(v14, a3);
  v23(v17, a3);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v24(v11, a2, a3);
  if ((v22 & 1) != 0)
  {
    v23(v11, a3);
    uint64_t v25 = v28;
  }

  else
  {
    uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 408))(a3, a4);
    v23(v11, a3);
    uint64_t v25 = v28;
    if ((v26 & 1) == 0) {
      uint64_t v25 = a2;
    }
  }

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v24)(v29, v25, a3);
}

uint64_t FloatingPoint.rounded(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, v7, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 312))(a1, a2, a3);
}

{
  uint64_t v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, v4, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 312))(a1, a2, a3);
}

uint64_t FloatingPoint.nextDown.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](v2);
  uint64_t v8 = (char *)&v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v6);
  uint64_t v11 = (char *)&v17 - v10;
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16);
  v14(v9, a1, v13);
  (*(void (**)(uint64_t, uint64_t))(a2 + 320))(a1, a2);
  uint64_t v15 = *(void (**)(char *, uint64_t))(v5 + 8);
  v15(v11, a1);
  v14((uint64_t)v8, a1, v13);
  return ((uint64_t (*)(char *, uint64_t))v15)(v8, a1);
}

{
  char *v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(char *, uint64_t, uint64_t);
  void (*v14)(char *, uint64_t);
  uint64_t v16;
  uint64_t v5 = *(void *)(a1 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v16 - v9;
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v13 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v13(v2, a1, v12);
  (*(void (**)(uint64_t, uint64_t))(a2 + 320))(a1, a2);
  uint64_t v14 = *(void (**)(char *, uint64_t))(v5 + 8);
  v14(v10, a1);
  v13(v8, a1, v12);
  return ((uint64_t (*)(char *, uint64_t))v14)(v8, a1);
}

uint64_t specialized FloatingPoint.floatingPointClass.getter(float a1)
{
  int v1 = (LODWORD(a1) >> 10) & 0x1F;
  if (SLOWORD(a1) < 0) {
    unsigned int v2 = 5;
  }
  else {
    unsigned int v2 = 6;
  }
  if (SLOWORD(a1) < 0) {
    int v3 = 4;
  }
  else {
    int v3 = 7;
  }
  if ((LOWORD(a1) & 0x3FF) != 0) {
    unsigned int v2 = v3;
  }
  if (SLOWORD(a1) < 0) {
    int v4 = 3;
  }
  else {
    int v4 = 8;
  }
  if (SLOWORD(a1) < 0) {
    int v5 = 2;
  }
  else {
    int v5 = 9;
  }
  if ((SLOWORD(a1) & 0x3FF) != 0) {
    unsigned int v6 = (SLOWORD(a1) >> 9) & 1;
  }
  else {
    unsigned int v6 = v5;
  }
  if (v1 != 31) {
    unsigned int v6 = v4;
  }
  if (v1) {
    return v6;
  }
  else {
    return v2;
  }
}

{
  unsigned int v1;
  int v2;
  int v3;
  int v4;
  unsigned int v5;
  if (a1 < 0.0) {
    int v1 = 5;
  }
  else {
    int v1 = 6;
  }
  if (a1 < 0.0) {
    unsigned int v2 = 4;
  }
  else {
    unsigned int v2 = 7;
  }
  if ((LODWORD(a1) & 0x7FFFFF) != 0) {
    int v1 = v2;
  }
  if (a1 < 0.0) {
    int v3 = 3;
  }
  else {
    int v3 = 8;
  }
  if (a1 < 0.0) {
    int v4 = 2;
  }
  else {
    int v4 = 9;
  }
  if ((LODWORD(a1) & 0x7FFFFF) != 0) {
    int v5 = (LODWORD(a1) >> 22) & 1;
  }
  else {
    int v5 = v4;
  }
  else {
    return v1;
  }
}

uint64_t specialized FloatingPoint.floatingPointClass.getter(double a1)
{
  uint64_t v1 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (a1 < 0.0) {
    unsigned int v2 = 5;
  }
  else {
    unsigned int v2 = 6;
  }
  if (a1 < 0.0) {
    int v3 = 4;
  }
  else {
    int v3 = 7;
  }
  if ((*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0) {
    unsigned int v2 = v3;
  }
  if (a1 < 0.0) {
    int v4 = 3;
  }
  else {
    int v4 = 8;
  }
  if (a1 < 0.0) {
    int v5 = 2;
  }
  else {
    int v5 = 9;
  }
  if ((*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0) {
    unsigned int v6 = (*(void *)&a1 >> 51) & 1;
  }
  else {
    unsigned int v6 = v5;
  }
  if (v1 != 2047) {
    unsigned int v6 = v4;
  }
  if (v1) {
    return v6;
  }
  else {
    return v2;
  }
}

uint64_t FloatingPoint.floatingPointClass.getter(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 400))(a1, a2) & 1) != 0)
  {
    else {
      return 9LL;
    }
  }

  else if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 368))(a1, a2) & 1) != 0)
  {
    else {
      return 8LL;
    }
  }

  else
  {
    char v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 392))(a1, a2);
    char v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a1, a2);
    if ((v6 & 1) != 0) {
      unsigned int v7 = 5;
    }
    else {
      unsigned int v7 = 6;
    }
    if ((v6 & 1) != 0) {
      unsigned int v8 = 4;
    }
    else {
      unsigned int v8 = 7;
    }
    if ((v5 & 1) != 0) {
      return v8;
    }
    else {
      return v7;
    }
  }

Swift::FloatingPointSign_optional __swiftcall FloatingPointSign.init(rawValue:)(Swift::Int rawValue)
{
  if (rawValue == 1) {
    v1.Swift::UInt32 value = Swift_FloatingPointSign_minus;
  }
  else {
    v1.Swift::UInt32 value = Swift_FloatingPointSign_unknownDefault;
  }
  if (rawValue) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t FloatingPointSign.rawValue.getter(char a1)
{
  return a1 & 1;
}

BOOL static FloatingPointSign.== infix(_:_:)(int a1, int a2)
{
  return ((a2 ^ a1) & 1) == 0;
}

uint64_t FloatingPointSign.hashValue.getter(char a1)
{
  return specialized static Hasher._hash(seed:_:)(0LL, a1 & 1);
}

uint64_t Int.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0LL, a1);
}

void FloatingPointSign.hash(into:)(uint64_t a1, char a2)
{
}

Swift::Int __swiftcall FloatingPointSign._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:_:)(seed, v1 & 1);
}

Swift::Int __swiftcall Int._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:_:)(seed, v1);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance FloatingPointSign()
{
  return specialized static Hasher._hash(seed:_:)(0LL, *v0);
}

void protocol witness for Hashable.hash(into:) in conformance FloatingPointSign()
{
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance FloatingPointSign(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(a1, *v1);
}

void *protocol witness for RawRepresentable.init(rawValue:) in conformance FloatingPointSign@<X0>( void *result@<X0>, char *a2@<X8>)
{
  if (*result == 1LL) {
    char v2 = 1;
  }
  else {
    char v2 = 2;
  }
  if (*result) {
    char v3 = v2;
  }
  else {
    char v3 = 0;
  }
  *a2 = v3;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance FloatingPointSign(void *a1@<X8>)
{
  *a1 = *v1;
}

BOOL static FloatingPointClassification.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

void FloatingPointClassification.hash(into:)(uint64_t a1, unsigned __int8 a2)
{
}

Swift::Int FloatingPointClassification.hashValue.getter(unsigned __int8 a1)
{
  return Hasher._finalize()();
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance FloatingPointClassification( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance FloatingPointClassification()
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance FloatingPointClassification()
{
  return Hasher._finalize()();
}

BOOL static FloatingPointRoundingRule.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void FloatingPointRoundingRule.hash(into:)()
{
}

uint64_t static FloatingPoint.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 336))(a2, a3, a4) & 1;
}

uint64_t static FloatingPoint.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 344))(a2, a3, a4) & 1;
}

uint64_t static FloatingPoint.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 352))(a2, a3, a4) & 1;
}

uint64_t static FloatingPoint.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 344))(a1, a3, a4) & 1;
}

uint64_t static FloatingPoint.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 352))(a1, a3, a4) & 1;
}

uint64_t specialized BinaryFloatingPoint.init<A>(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

double specialized BinaryFloatingPoint.init<A>(_:)(uint64_t a1, swift *a2, uint64_t a3)
{
  uint64_t v83 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v81 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v82 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v80 = (char *)&v75 - v6;
  unint64_t v7 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v78 = *(void *)(v7 - 8);
  unint64_t v79 = v7;
  uint64_t v8 = MEMORY[0x1895F8858](v7);
  Swift::Int v77 = (char *)&v75 - v9;
  uint64_t v10 = *((void *)a2 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v75 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (uint64_t *)((char *)&v75 - v15);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v76 = (char *)&v75 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (uint64_t *)((char *)&v75 - v20);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v75 - v23;
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (uint64_t *)((char *)&v75 - v25);
  uint64_t v27 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 96))(a2, a3);
  uint64_t v28 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 104))(a2, a3);
  if (v27 == 11)
  {
    if (v28 == 52)
    {
      uint64_t v32 = v83;
      (*(void (**)(uint64_t *, uint64_t, swift *))(v10 + 16))(v16, v83, a2);
      int v33 = swift_dynamicCast((char *)&v84, v16, a2, (const char *)&type metadata for Double, 6uLL);
      _D8 = v84;
      (*(void (**)(char *, uint64_t, swift *))(v10 + 32))(v13, v32, a2);
      if (v33)
      {
        (*(void (**)(char *, swift *))(v10 + 8))(v13, a2);
      }

      else
      {
        uint64_t v55 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
        BOOL v56 = v77;
        (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
        uint64_t v57 = v79;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        __int16 v59 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120LL))(v57);
        (*(void (**)(char *, uint64_t))(v78 + 8))(v56, v57);
        uint64_t v60 = v80;
        (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, swift *))(v10 + 8))(v13, a2);
        uint64_t v61 = (uint64_t)a2;
        uint64_t v62 = v82;
        unint64_t v63 = swift_getAssociatedConformanceWitness( a3,  v61,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)(v63 + 8) + 120LL))(v62);
        (*(void (**)(char *, uint64_t))(v81 + 8))(v60, v62);
        _D8 = (v55 << 63) | ((unint64_t)(v59 & 0x7FF) << 52) | v64 & 0xFFFFFFFFFFFFFLL;
      }

      return *(double *)&_D8;
    }

float specialized BinaryFloatingPoint.init<A>(_:)(const char *a1, swift *a2, uint64_t a3)
{
  uint64_t v83 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v81 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v82 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v80 = (char *)&v75 - v6;
  unint64_t v7 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v78 = *(void *)(v7 - 8);
  unint64_t v79 = v7;
  uint64_t v8 = MEMORY[0x1895F8858](v7);
  Swift::Int v77 = (char *)&v75 - v9;
  uint64_t v10 = *((void *)a2 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v75 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (uint64_t *)((char *)&v75 - v15);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v76 = (char *)&v75 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (uint64_t *)((char *)&v75 - v20);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v75 - v23;
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (uint64_t *)((char *)&v75 - v25);
  uint64_t v27 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 96))(a2, a3);
  uint64_t v28 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 104))(a2, a3);
  if (v27 == 11)
  {
    if (v28 == 52)
    {
      uint64_t v32 = v83;
      (*(void (**)(uint64_t *, const char *, swift *))(v10 + 16))(v16, v83, a2);
      int v33 = swift_dynamicCast((char *)&v84, v16, a2, (const char *)&type metadata for Double, 6uLL);
      double v34 = v84;
      (*(void (**)(char *, const char *, swift *))(v10 + 32))(v13, v32, a2);
      if (v33)
      {
        (*(void (**)(char *, swift *))(v10 + 8))(v13, a2);
        *(float *)&_S8 = v34;
      }

      else
      {
        uint64_t v55 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
        BOOL v56 = v77;
        (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
        uint64_t v57 = v79;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        __int16 v59 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120LL))(v57);
        (*(void (**)(char *, uint64_t))(v78 + 8))(v56, v57);
        uint64_t v60 = v80;
        (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, swift *))(v10 + 8))(v13, a2);
        uint64_t v61 = (uint64_t)a2;
        uint64_t v62 = v82;
        unint64_t v63 = swift_getAssociatedConformanceWitness( a3,  v61,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)(v63 + 8) + 120LL))(v62);
        (*(void (**)(char *, uint64_t))(v81 + 8))(v60, v62);
        *(float *)&_S8 = COERCE_DOUBLE((v55 << 63) | ((unint64_t)(v59 & 0x7FF) << 52) | v64 & 0xFFFFFFFFFFFFFLL);
      }

      return *(float *)&_S8;
    }

float specialized BinaryFloatingPoint.init<A>(_:)(uint64_t a1, swift *a2, uint64_t a3)
{
  uint64_t v83 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v81 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v82 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v80 = (char *)&v75 - v7;
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v78 = *(void *)(v8 - 8);
  unint64_t v79 = v8;
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  Swift::Int v77 = (char *)&v75 - v10;
  uint64_t v11 = *((void *)a2 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v75 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (uint64_t *)((char *)&v75 - v16);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v76 = (char *)&v75 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (uint64_t *)((char *)&v75 - v21);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v75 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v27 = (uint64_t *)((char *)&v75 - v26);
  uint64_t v28 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 96))(a2, a3);
  uint64_t v29 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 104))(a2, a3);
  if (v28 == 11)
  {
    if (v29 != 52) {
      goto LABEL_13;
    }
    uint64_t v32 = v83;
    (*(void (**)(uint64_t *, uint64_t, swift *))(v11 + 16))(v17, v83, a2);
    int v33 = swift_dynamicCast((char *)&v84, v17, a2, (const char *)&type metadata for Double, 6uLL);
    _D8 = v84;
    (*(void (**)(char *, uint64_t, swift *))(v11 + 32))(v14, v32, a2);
    if (v33)
    {
      (*(void (**)(char *, swift *))(v11 + 8))(v14, a2);
      __asm { FCVT            H8, D8 }
    }

    else
    {
      uint64_t v53 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
      uint64_t v54 = v77;
      (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
      uint64_t v55 = v79;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      __int16 v57 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120LL))(v55);
      (*(void (**)(char *, uint64_t))(v78 + 8))(v54, v55);
      char v58 = v80;
      (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
      (*(void (**)(char *, swift *))(v11 + 8))(v14, a2);
      uint64_t v59 = (uint64_t)a2;
      uint64_t v60 = v82;
      unint64_t v61 = swift_getAssociatedConformanceWitness( a3,  v59,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v62 = (*(uint64_t (**)(uint64_t))(*(void *)(v61 + 8) + 120LL))(v60);
      (*(void (**)(char *, uint64_t))(v81 + 8))(v58, v60);
      _D0 = (v53 << 63) | ((unint64_t)(v57 & 0x7FF) << 52) | v62 & 0xFFFFFFFFFFFFFLL;
      __asm { FCVT            H8, D0 }
    }
  }

  else
  {
    if (v28 != 8)
    {
      if (v28 == 5 && v29 == 10)
      {
        uint64_t v30 = v83;
        (*(void (**)(uint64_t *, uint64_t, swift *))(v11 + 16))(v27, v83, a2);
        int v31 = swift_dynamicCast((char *)&v84, v27, a2, (const char *)&type metadata for Float16, 6uLL);
        LOWORD(_D8) = v84;
        (*(void (**)(char *, uint64_t, swift *))(v11 + 32))(v25, v30, a2);
        if (v31)
        {
          (*(void (**)(char *, swift *))(v11 + 8))(v25, a2);
        }

        else
        {
          int v43 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
          unint64_t v44 = v77;
          (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
          uint64_t v45 = v79;
          unint64_t v46 = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
          char v47 = (*(uint64_t (**)(uint64_t))(*(void *)(v46 + 8) + 120LL))(v45);
          (*(void (**)(char *, uint64_t))(v78 + 8))(v44, v45);
          uint64_t v48 = v80;
          (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
          (*(void (**)(char *, swift *))(v11 + 8))(v25, a2);
          uint64_t v49 = (uint64_t)a2;
          uint64_t v50 = v82;
          unint64_t v51 = swift_getAssociatedConformanceWitness( a3,  v49,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
          __int16 v52 = (*(uint64_t (**)(uint64_t))(*(void *)(v51 + 8) + 120LL))(v50);
          (*(void (**)(char *, uint64_t))(v81 + 8))(v48, v50);
          LODWORD(_D8) = (v43 << 15) | ((v47 & 0x1F) << 10) | v52 & 0x3FF;
        }

        return *(float *)&_D8;
      }

uint64_t BinaryFloatingPoint.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, swift *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v111 = a4;
  uint64_t v112 = a6;
  uint64_t v108 = *(void *)(*(void *)(*(void *)(a4 + 16) + 16LL) + 8LL);
  uint64_t v109 = a1;
  uint64_t v107 = *(const char **)(v108 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v107,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v105 = (char *)&v95 - v11;
  uint64_t v113 = a2;
  uint64_t v106 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v104 = (char *)&v95 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v95 - v14;
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v102 = *(void *)(v16 - 8);
  unint64_t v103 = v16;
  MEMORY[0x1895F8858](v16);
  unsigned int v101 = (char *)&v95 - v17;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v99 = *(void *)(v18 - 8);
  unint64_t v100 = v18;
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v98 = (char *)&v95 - v20;
  uint64_t v110 = *((void *)a3 - 1);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v95 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (uint64_t *)((char *)&v95 - v25);
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  unint64_t v97 = (char *)&v95 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  int v31 = (uint64_t *)((char *)&v95 - v30);
  uint64_t v32 = MEMORY[0x1895F8858](v29);
  uint64_t v96 = (char *)&v95 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v35 = (uint64_t *)((char *)&v95 - v34);
  uint64_t v36 = (*(uint64_t (**)(swift *, uint64_t))(a5 + 96))(a3, a5);
  uint64_t v37 = (*(uint64_t (**)(swift *, uint64_t))(a5 + 104))(a3, a5);
  if (v36 == 11)
  {
    if (v37 != 52) {
      goto LABEL_13;
    }
    unint64_t v44 = v23;
    uint64_t v45 = v109;
    uint64_t v46 = v110;
    (*(void (**)(uint64_t *, uint64_t, swift *))(v110 + 16))(v26, v109, a3);
    int v47 = swift_dynamicCast((char *)v116, v26, a3, (const char *)&type metadata for Double, 6uLL);
    double v48 = v116[0];
    uint64_t v49 = v44;
    (*(void (**)(char *, uint64_t, swift *))(v46 + 32))(v44, v45, a3);
    if (v47)
    {
      (*(void (**)(char *, swift *))(v46 + 8))(v44, a3);
    }

    else
    {
      uint64_t v77 = (*(uint64_t (**)(swift *))(*(void *)(a5 + 16) + 168LL))(a3);
      uint64_t v78 = v98;
      (*(void (**)(swift *, uint64_t))(a5 + 112))(a3, a5);
      uint64_t v79 = v100;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  (uint64_t)a3,  v100,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      __int16 v81 = (*(uint64_t (**)(uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 120LL))(v79);
      (*(void (**)(char *, uint64_t))(v99 + 8))(v78, v79);
      unint64_t v82 = v101;
      (*(void (**)(swift *, uint64_t))(a5 + 120))(a3, a5);
      (*(void (**)(char *, swift *))(v46 + 8))(v49, a3);
      uint64_t v83 = v103;
      unint64_t v84 = swift_getAssociatedConformanceWitness( a5,  (uint64_t)a3,  v103,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v85 = (*(uint64_t (**)(uint64_t))(*(void *)(v84 + 8) + 120LL))(v83);
      (*(void (**)(char *, uint64_t))(v102 + 8))(v82, v83);
      *(void *)&double v48 = (v77 << 63) | ((unint64_t)(v81 & 0x7FF) << 52) | v85 & 0xFFFFFFFFFFFFFLL;
    }

    return (*(uint64_t (**)(double))(v111 + 72))(v48);
  }

  else
  {
    if (v36 != 8)
    {
      if (v36 == 5 && v37 == 10)
      {
        uint64_t v38 = v109;
        uint64_t v39 = v110;
        (*(void (**)(uint64_t *, uint64_t, swift *))(v110 + 16))(v35, v109, a3);
        int v40 = swift_dynamicCast((char *)&v114, v35, a3, (const char *)&type metadata for Float16, 6uLL);
        _H8 = v114;
        uint64_t v42 = v96;
        (*(void (**)(char *, uint64_t, swift *))(v39 + 32))(v96, v38, a3);
        if (v40)
        {
          (*(void (**)(char *, swift *))(v39 + 8))(v42, a3);
        }

        else
        {
          __int16 v64 = (*(uint64_t (**)(swift *))(*(void *)(a5 + 16) + 168LL))(a3);
          int v65 = v98;
          (*(void (**)(swift *, uint64_t))(a5 + 112))(a3, a5);
          uint64_t v66 = v100;
          unint64_t v67 = swift_getAssociatedConformanceWitness( a5,  (uint64_t)a3,  v100,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
          char v68 = (*(uint64_t (**)(uint64_t))(*(void *)(v67 + 8) + 120LL))(v66);
          (*(void (**)(char *, uint64_t))(v99 + 8))(v65, v66);
          unsigned __int8 v69 = v101;
          (*(void (**)(swift *, uint64_t))(a5 + 120))(a3, a5);
          (*(void (**)(char *, swift *))(v39 + 8))(v42, a3);
          uint64_t v70 = v103;
          unint64_t v71 = swift_getAssociatedConformanceWitness( a5,  (uint64_t)a3,  v103,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
          __int16 v72 = (*(uint64_t (**)(uint64_t))(*(void *)(v71 + 8) + 120LL))(v70);
          (*(void (**)(char *, uint64_t))(v102 + 8))(v69, v70);
          _H8 = (v64 << 15) | ((v68 & 0x1F) << 10) | v72 & 0x3FF;
        }

        __asm { FCVT            S0, H8 }

        return (*(uint64_t (**)(__n128))(v111 + 64))(_Q0);
      }

uint64_t BinaryFloatingPoint.init<A>(_:)@<X0>( uint64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return BinaryFloatingPoint.init<A>(_:)(a1, a4, a2, a5, a3, a6);
}

uint64_t BinaryFloatingPoint.init<A>(exactly:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return BinaryFloatingPoint.init<A>(exactly:)(a1, a4, a2, a5, a3, a6);
}

{
  const char *v10;
  unint64_t AssociatedTypeWitness;
  uint64_t v12;
  const char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t (*v68)(unint64_t *, uint64_t);
  uint64_t v69;
  uint64_t v70;
  void (*v71)(char *, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(void (*)(char *, uint64_t));
  void (*v83)(char *, uint64_t);
  uint64_t v84;
  unint64_t *v85;
  char *v86;
  uint64_t (*v87)(unint64_t *, uint64_t);
  uint64_t v88;
  uint64_t v89;
  char v90;
  void (*v91)(uint64_t, uint64_t);
  const char *v92;
  char v93;
  char *v94;
  const char *v95;
  char *v96;
  char *v97;
  void (*v98)(char *, uint64_t);
  uint64_t v99;
  uint64_t v100;
  uint64_t (*v101)(unint64_t *, uint64_t);
  char *v102;
  unint64_t *v103;
  int v104;
  char v105;
  char *v106;
  unint64_t *v107;
  uint64_t v108;
  char v109;
  uint64_t (*v110)(unint64_t *, uint64_t);
  uint64_t v111;
  uint64_t (*v112)(unint64_t *, uint64_t);
  uint64_t v113;
  char *v114;
  char *v115;
  char v116;
  uint64_t v118;
  char *v119;
  char *v120;
  char *v121;
  void (*v122)(char *, unint64_t *);
  char *v123;
  void (*v124)(char *, uint64_t);
  char *v125;
  char *v126;
  void (*v127)(char *, unint64_t *);
  char *v128;
  void (**v129)(char *, unint64_t *, const char *);
  char *v130;
  unint64_t v131;
  unint64_t AssociatedConformanceWitness;
  char *v133;
  char *v134;
  uint64_t v135;
  void (*v136)(char *, unint64_t *);
  char *v137;
  uint64_t v138;
  char *v139;
  const char *v140;
  void (**v141)(char *, unint64_t *, const char *);
  unint64_t v142;
  unint64_t v143;
  char *v144;
  char *v145;
  char *v146;
  uint64_t v147;
  void (*v148)(char *, unint64_t *);
  uint64_t v149;
  char *v150;
  char *v151;
  uint64_t v152;
  char *v153;
  char *v154;
  void (*v155)(char *, unint64_t *);
  const char *v156;
  char *v157;
  char *v158;
  uint64_t (*v159)(unint64_t *, uint64_t);
  char v160;
  unint64_t *v161;
  char v162;
  uint64_t v163;
  uint64_t v164;
  char *v165;
  char *v166;
  char v167;
  char *v168;
  uint64_t v169;
  char *v170;
  char *v171;
  char *v172;
  void (*v173)(char *, unint64_t *);
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  char *v177;
  char *v178;
  char *v179;
  char v180;
  void (*v181)(char *, unint64_t *);
  char *v182;
  char *v183;
  char v184;
  void (*v185)(char *, unint64_t *);
  const char *v186;
  char *v187;
  char *v188;
  uint64_t (*v189)(unint64_t *, uint64_t);
  char v190;
  unint64_t *v191;
  char v192;
  uint64_t v193;
  uint64_t v194;
  char *v195;
  unint64_t *v196;
  char *v197;
  char v198;
  uint64_t v199;
  uint64_t v200;
  char *v201;
  char *v202;
  char *v203;
  void (*v204)(char *, unint64_t *);
  char *v205;
  unint64_t *v206;
  uint64_t v207;
  char *v208;
  char *v209;
  uint64_t v210;
  char *v211;
  void (*v212)(uint64_t, uint64_t);
  uint64_t v213;
  const char *v214;
  unint64_t v215;
  unint64_t v216;
  char *v217;
  char *v218;
  char *v219;
  uint64_t v220;
  char *v221;
  uint64_t v222;
  char *v223;
  const char *v224;
  unint64_t v225;
  unint64_t v226;
  char *v227;
  char *v228;
  uint64_t v229;
  void (*v230)(char *, unint64_t *);
  char *v231;
  uint64_t v232;
  char *v233;
  char *v234;
  uint64_t v235;
  char *v236;
  char *v237;
  void (*v238)(char *, unint64_t *);
  void (**v239)(char *, uint64_t, const char *);
  uint64_t v240;
  unint64_t v241;
  unint64_t v242;
  char *v243;
  char *v244;
  uint64_t v245;
  char *v246;
  uint64_t v247;
  char *v248;
  unint64_t *v249;
  const char *v250;
  unint64_t *v251;
  unint64_t v252;
  unint64_t v253;
  char *v254;
  char *v255;
  uint64_t v256;
  char *v257;
  char *v258;
  uint64_t v259;
  uint64_t v260;
  char *v261;
  char *v262;
  uint64_t v263;
  void (*v264)(char *, char *, unint64_t *);
  char *v265;
  char *v266;
  char *v267;
  char v268;
  void (*v269)(char *, uint64_t);
  char *v270;
  void (*v271)(char *, unint64_t *);
  uint64_t v272;
  char *v273;
  char *v274;
  char *v275;
  uint64_t v276;
  const char *v277;
  char *v278;
  uint64_t v279;
  void (*v280)(char *, uint64_t);
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  char *v288;
  char *v289;
  void (*v290)(char *, unint64_t *);
  uint64_t v291;
  uint64_t v292;
  BOOL v293;
  uint64_t v294;
  void (*v295)(uint64_t, uint64_t);
  uint64_t (*v296)(unint64_t *, uint64_t);
  char *v297;
  char *v298;
  char *v299;
  uint64_t (*v300)(unint64_t *, uint64_t);
  uint64_t v301;
  char *v302;
  char *v303;
  char *v304;
  char *v305;
  char *v306;
  char *v307;
  char *v308;
  char *v309;
  char *v310;
  char *v311;
  char *v312;
  unint64_t v313;
  char *v314;
  char *v315;
  unint64_t v316;
  char *v317;
  char *v318;
  char *v319;
  char *v320;
  uint64_t v321;
  char *v322;
  char *v323;
  char *v324;
  char *v325;
  char *v326;
  uint64_t v327;
  char *v328;
  char *v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  unint64_t *v333;
  void (*v334)(char *, uint64_t);
  uint64_t v335;
  const char *v336;
  char *v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  const char *v345;
  uint64_t v346;
  v341 = a6;
  uint64_t v339 = a4;
  uint64_t v10 = *(const char **)(a4 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a2,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  v336 = v10;
  v331 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v10,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  v321 = *(void *)(v331 + 24);
  v318 = *(char **)(v321 + 16);
  v316 = swift_getAssociatedTypeWitness( 0LL,  v318,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v316);
  v317 = (char *)&v294 - v12;
  v340 = a5;
  uint64_t v13 = *(const char **)(a5 + 16);
  v345 = v13;
  uint64_t v343 = a3;
  uint64_t v14 = swift_getAssociatedTypeWitness( 255LL,  v13,  a3,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  v332 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v13,  a3,  v14,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  v315 = *(char **)(*(void *)(v332 + 24) + 16LL);
  v313 = swift_getAssociatedTypeWitness( 0LL,  v315,  v14,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v313);
  v314 = (char *)&v294 - v15;
  uint64_t v338 = (uint64_t)swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v330 = *(void *)(v338 - 8);
  unint64_t v16 = MEMORY[0x1895F8858](v338);
  v308 = (char *)&v294 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v18 = MEMORY[0x1895F8858](v16);
  v307 = (char *)&v294 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v325 = (char *)&v294 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v320 = (char *)&v294 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v319 = (char *)&v294 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v305 = (char *)&v294 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v306 = (char *)&v294 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v324 = (char *)&v294 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v311 = (char *)&v294 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v312 = (char *)&v294 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v329 = (char *)&v294 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  uint64_t v337 = (char *)&v294 - v39;
  uint64_t v344 = a2;
  uint64_t v342 = *(void *)(a2 - 8);
  int v40 = MEMORY[0x1895F8858](v38);
  v323 = (char *)&v294 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v326 = (char *)&v294 - v43;
  unint64_t v44 = MEMORY[0x1895F8858](v42);
  v322 = (char *)&v294 - v45;
  MEMORY[0x1895F8858](v44);
  v328 = (char *)&v294 - v46;
  uint64_t v333 = swift_checkMetadataState(0LL, v14);
  v335 = *(v333 - 1);
  int v47 = MEMORY[0x1895F8858](v333);
  v303 = (char *)&v294 - ((v48 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  v309 = (char *)&v294 - v50;
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  v304 = (char *)&v294 - v52;
  int v53 = MEMORY[0x1895F8858](v51);
  v302 = (char *)&v294 - v54;
  __n128 v55 = MEMORY[0x1895F8858](v53);
  v310 = (char *)&v294 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  unint64_t v59 = (char *)&v294 - v58;
  uint64_t v60 = MEMORY[0x1895F8858](v57);
  uint64_t v62 = (char *)&v294 - v61;
  MEMORY[0x1895F8858](v60);
  __int16 v64 = (char *)&v294 - v63;
  int v65 = *(void *)(v343 - 8);
  uint64_t v66 = MEMORY[0x1895F8858](v343);
  char v68 = (uint64_t (*)(unint64_t *, uint64_t))((char *)&v294 - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  unsigned __int8 v69 = MEMORY[0x1895F8858](v66);
  unint64_t v71 = (void (*)(char *, uint64_t))((char *)&v294 - v70);
  __int16 v72 = v69;
  if (((*((uint64_t (**)(void))v345 + 51))() & 1) == 0)
  {
    v334 = v71;
    v301 = v65;
    v300 = v68;
    uint64_t v297 = v59;
    v327 = a1;
    v299 = v64;
    v298 = v62;
    uint64_t v76 = v340;
    uint64_t v77 = v72;
    uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(v340 + 96))(v72, v340);
    uint64_t v79 = v339;
    uint64_t v80 = v344;
    if ((*(uint64_t (**)(uint64_t, uint64_t))(v339 + 96))(v344, v339) >= v78)
    {
      uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(v76 + 104))(v77, v76);
      unint64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t))(v79 + 104))(v80, v79);
      __int16 v81 = v301;
      unint64_t v82 = *(void (**)(void))(v301 + 16);
      unint64_t v84 = v327;
      v82(v334);
      if (v89 >= v88)
      {
        int v90 = 0;
        int v86 = v337;
        uint64_t v85 = (unint64_t *)v338;
        uint64_t v87 = v300;
        uint64_t v83 = v334;
LABEL_9:
        char v91 = *(void (**)(uint64_t, uint64_t))(v81 + 8);
        v91((uint64_t)v83, v77);
        ((void (*)(uint64_t (*)(unint64_t *, uint64_t), uint64_t, uint64_t))v82)(v87, v84, v77);
        if ((v90 & 1) == 0)
        {
          v91((uint64_t)v87, v77);
          int v74 = v344;
          goto LABEL_16;
        }

        uint64_t v92 = v345;
        unint64_t v93 = (*((uint64_t (**)(uint64_t, const char *))v345 + 48))(v77, v345);
        v91((uint64_t)v87, v77);
        int v74 = v344;
        if ((v93 & 1) != 0)
        {
LABEL_16:
          uint64_t v75 = v341;
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v339 + 80))(v84, v77, v340, v74);
          int v73 = 0LL;
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v342 + 56))(v75, v73, 1LL, v74);
        }

        uint64_t v295 = v91;
        int v94 = v299;
        (*((void (**)(uint64_t, const char *))v92 + 22))(v77, v92);
        uint64_t v95 = v336;
        uint64_t v96 = v328;
        (*((void (**)(uint64_t, const char *))v336 + 19))(v74, v336);
        unint64_t v97 = v86;
        v345 = (const char *)*((void *)v95 + 22);
        ((void (*)(uint64_t, const char *))v345)(v74, v95);
        uint64_t v98 = *(void (**)(char *, uint64_t))(v342 + 8);
        v98(v96, v74);
        unint64_t v100 = v331;
        uint64_t v99 = v332;
        unsigned int v101 = *(uint64_t (**)(unint64_t *, uint64_t))(v332 + 64);
        uint64_t v102 = v97;
        unint64_t v103 = v333;
        LODWORD(v95) = v101(v333, v332);
        v301 = *(void *)(v100 + 64);
        uint64_t v104 = ((uint64_t (*)(unint64_t *, uint64_t))v301)(v85, v100);
        v334 = v98;
        v328 = (char *)v101;
        if (((v95 ^ v104) & 1) != 0)
        {
          uint64_t v105 = v101(v103, v99);
          uint64_t v106 = v102;
          uint64_t v107 = v85;
          uint64_t v108 = v99;
          uint64_t v109 = v105;
          uint64_t v110 = *(uint64_t (**)(unint64_t *, uint64_t))(v99 + 128);
          uint64_t v111 = v110(v103, v108);
          uint64_t v112 = *(uint64_t (**)(unint64_t *, uint64_t))(v100 + 128);
          uint64_t v113 = v112(v107, v100);
          __int16 v114 = v94;
          v300 = v110;
          uint64_t v296 = v112;
          if ((v109 & 1) != 0)
          {
            if (v113 >= v111)
            {
              uint64_t v129 = (void (**)(char *, unint64_t *, const char *))v315;
              unint64_t v130 = v106;
              unint64_t v103 = v333;
              Swift::String v131 = v313;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v315,  (uint64_t)v333,  v313,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v133 = v314;
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                          + 8))( &unk_18180BE68,  256LL,  v131,  AssociatedConformanceWitness);
              unint64_t v134 = v298;
              v129[3](v133, v103, (const char *)v129);
              uint64_t v99 = v332;
              LOBYTE(v129) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v332 + 32) + 8LL)
                                                                                           + 16LL))( v94,  v134,  v103);
              unint64_t v135 = v335;
              char v136 = *(void (**)(char *, unint64_t *))(v335 + 8);
              v136(v134, v103);
              unint64_t v137 = v297;
              (*(void (**)(char *, char *, unint64_t *))(v135 + 16))(v297, v94, v103);
              unint64_t v138 = v330;
              unint64_t v139 = v312;
              uint64_t v85 = (unint64_t *)v338;
              (*(void (**)(char *, char *, uint64_t))(v330 + 32))(v312, v130, v338);
              if ((v129 & 1) != 0)
              {
                (*(void (**)(char *, unint64_t *))(v138 + 8))(v139, v85);
                v136(v137, v103);
                unint64_t v100 = v331;
                uint64_t v124 = v334;
                uint64_t v140 = v336;
                int v74 = v344;
                goto LABEL_29;
              }

              char v182 = v139;
              unint64_t v100 = v331;
              __int128 v183 = v329;
              (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v331 + 96))( v137,  v103,  v99,  v85,  v331);
              char v184 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v183,  v182,  v85);
              __int128 v185 = *(void (**)(char *, unint64_t *))(v138 + 8);
              v185(v183, v85);
              v185(v182, v85);
              uint64_t v124 = v334;
              uint64_t v140 = v336;
              int v74 = v344;
              if ((v184 & 1) != 0)
              {
LABEL_29:
                uint64_t v156 = v140;
                unint64_t v157 = v322;
                uint64_t v337 = (char *)*((void *)v140 + 20);
                ((void (*)(uint64_t, const char *))v337)(v74, v140);
                uint64_t v158 = v324;
                ((void (*)(uint64_t, const char *))v345)(v74, v156);
                v124(v157, v74);
                uint64_t v159 = (uint64_t (*)(unint64_t *, uint64_t))v328;
                LODWORD(v156) = ((uint64_t (*)(unint64_t *, uint64_t))v328)(v103, v99);
                if (((v156 ^ ((unsigned int (*)(unint64_t *, uint64_t))v301)(v85, v100)) & 1) != 0)
                {
                  uint64_t v160 = v159(v103, v99);
                  unint64_t v161 = v85;
                  char v162 = v160;
                  BOOL v163 = v300(v103, v99);
                  unint64_t v164 = v296(v161, v100);
                  if ((v162 & 1) != 0)
                  {
                    if (v164 < v163)
                    {
                      uint64_t v99 = v332;
                      unint64_t v103 = v333;
                      uint64_t v165 = v298;
                      uint64_t v85 = (unint64_t *)v338;
                      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, uint64_t))(v332 + 96))( v158,  v338,  v100,  v333,  v332);
                      unint64_t v166 = v299;
                      uint64_t v167 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v99 + 32) + 8LL)
                                                                                           + 16LL))( v299,  v165,  v103);
LABEL_39:
                      unint64_t v180 = v167;
                      unint64_t v174 = v335;
                      (*(void (**)(char *, unint64_t *))(v335 + 8))(v165, v103);
LABEL_40:
                      uint64_t v175 = v327;
                      __int128 v176 = v343;
                      if ((v180 & 1) == 0)
                      {
LABEL_71:
                        char v272 = v174;
                        uint64_t v338 = (*(uint64_t (**)(uint64_t))(v340 + 136))(v176);
                        uint64_t v273 = v298;
                        (*(void (**)(char *, char *, unint64_t *))(v272 + 32))(v298, v166, v103);
                        unint64_t v274 = v319;
                        (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v100 + 88))( v273,  v103,  v99,  v85,  v100);
                        uint64_t v275 = v326;
                        uint64_t v276 = (uint64_t)v85;
                        uint64_t v277 = v336;
                        ((void (*)(uint64_t, const char *))v337)(v74, v336);
                        unint64_t v278 = v320;
                        ((void (*)(uint64_t, const char *))v345)(v74, v277);
                        v334(v275, v74);
                        uint64_t v279 = (uint64_t)v329;
                        (*(void (**)(char *, char *, uint64_t))(*(void *)(v321 + 8) + 40LL))( v274,  v278,  v276);
                        uint64_t v280 = *(void (**)(char *, uint64_t))(v330 + 8);
                        v280(v278, v276);
                        uint64_t v281 = ((uint64_t (*)(char *, uint64_t))v280)(v274, v276);
                        uint64_t v284 = lazy protocol witness table accessor for type Int and conformance Int(v281, v282, v283);
                        lazy protocol witness table accessor for type Int and conformance Int(v284, v285, v286);
                        uint64_t v77 = v343;
                        SignedInteger<>.init<A>(_:)( v279,  (uint64_t)&type metadata for Int,  v276,  v284,  v100,  (uint64_t)&v346);
                        unint64_t v84 = v175;
                        if (v346 < v338)
                        {
                          v295(v175, v77);
                          goto LABEL_80;
                        }

                        goto LABEL_16;
                      }

uint64_t specialized BinaryFloatingPoint.init<A>(exactly:)(uint64_t a1, swift *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  uint64_t v291 = *(void *)(swift_getAssociatedConformanceWitness( v6,  (uint64_t)a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  uint64_t v269 = *(const char **)(*(void *)(v291 + 24) + 16LL);
  unint64_t v268 = swift_getAssociatedTypeWitness( 0LL,  v269,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v268);
  Swift::Int v267 = (char *)&v255 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v283 = *(void *)(v9 - 8);
  unint64_t v284 = v9;
  MEMORY[0x1895F8858](v9);
  unint64_t v282 = (char *)&v255 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v280 = *(void *)(v11 - 8);
  unint64_t v281 = v11;
  MEMORY[0x1895F8858](v11);
  uint64_t v279 = (char *)&v255 - v12;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v14 = *(v13 - 1);
  uint64_t v286 = v13;
  uint64_t v287 = v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v255 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  Swift::String::Index v265 = (char *)&v255 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  Swift::String::Index v266 = (char *)&v255 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::Int v262 = (char *)&v255 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::String::Index v263 = (char *)&v255 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  Swift::String::Index v261 = (char *)&v255 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  char v272 = (char *)&v255 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v270 = (char *)&v255 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  Swift::String::Index v264 = (char *)&v255 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  unint64_t v271 = (char *)&v255 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  uint64_t v285 = (char *)&v255 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  __int128 v288 = (char *)&v255 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  uint64_t v290 = (char *)&v255 - v41;
  uint64_t v42 = *((void *)a2 - 1);
  uint64_t v43 = MEMORY[0x1895F8858](v40);
  unint64_t v278 = (char *)&v255 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v275 = (uint64_t *)((char *)&v255 - v46);
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  uint64_t v277 = (char *)&v255 - v48;
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  unint64_t v274 = (uint64_t *)((char *)&v255 - v50);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  uint64_t v276 = (char *)&v255 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  uint64_t v273 = (uint64_t *)((char *)&v255 - v54);
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  uint64_t v57 = (char *)&v255 - v56;
  MEMORY[0x1895F8858](v55);
  unint64_t v59 = (char *)&v255 - v58;
  uint64_t v60 = v6;
  if (((*(uint64_t (**)(swift *, uint64_t))(v6 + 408))(a2, v6) & 1) == 0)
  {
    uint64_t v289 = v42;
    uint64_t v292 = a1;
    Swift::String::Index v260 = *(uint64_t (**)(swift *, uint64_t))(a3 + 96);
    uint64_t v63 = a3;
    if (v260(a2, a3) < 6)
    {
      uint64_t v67 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 104))(a2, a3);
      uint64_t v64 = v289;
      int v65 = *(void (**)(char *, uint64_t, swift *))(v289 + 16);
      v65(v59, v292, a2);
      uint64_t v66 = v60;
      if (v67 < 11)
      {
        char v69 = 0;
        uint64_t v68 = v291;
LABEL_9:
        uint64_t v70 = v59;
        unint64_t v71 = *(void (**)(char *, swift *))(v64 + 8);
        v71(v70, a2);
        uint64_t v72 = v292;
        v65(v57, v292, a2);
        if ((v69 & 1) == 0)
        {
          v71(v57, a2);
          goto LABEL_16;
        }

        char v73 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 384))(a2, v66);
        v71(v57, a2);
        if ((v73 & 1) != 0) {
          goto LABEL_16;
        }
        int v74 = *(void (**)(swift *))(v66 + 176);
        uint64_t v75 = v66;
        uint64_t v76 = v290;
        uint64_t v257 = v75;
        v74(a2);
        int64_t v294 = -14LL;
        uint64_t v77 = *(uint64_t (**)(unint64_t *, uint64_t))(v68 + 64);
        uint64_t v78 = (uint64_t)v286;
        char v79 = v77(v286, v68);
        Swift::String::Index v256 = v71;
        Swift::String::Index v258 = v77;
        if ((v79 & 1) != 0)
        {
          Swift::String::Index v259 = *(uint64_t (**)(uint64_t, uint64_t))(v68 + 128);
          uint64_t v80 = v259(v78, v68);
          if (v80 < 64)
          {
            uint64_t v84 = v287;
            uint64_t v83 = v288;
            (*(void (**)(char *, char *, uint64_t))(v287 + 16))(v288, v76, v78);
            uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
            uint64_t v291 = *(void *)(v84 + 8);
            ((void (*)(char *, uint64_t))v291)(v83, v78);
            if (v85 >= v294) {
              goto LABEL_51;
            }
            goto LABEL_48;
          }

          uint64_t v109 = v77;
          uint64_t v110 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
          unint64_t v111 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
          uint64_t v83 = v288;
          v110(&v294, &type metadata for Int, v111, v78, v68);
          uint64_t v77 = v109;
          char v112 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v76,  v83,  v78);
          uint64_t v84 = v287;
          uint64_t v291 = *(void *)(v287 + 8);
          ((void (*)(char *, uint64_t))v291)(v83, v78);
          if ((v112 & 1) != 0) {
            goto LABEL_48;
          }
        }

        else
        {
          char v102 = v77((unint64_t *)v78, v68);
          Swift::String::Index v259 = *(uint64_t (**)(uint64_t, uint64_t))(v68 + 128);
          uint64_t v103 = v259(v78, v68);
          if ((v102 & 1) != 0)
          {
            if (v103 <= 64)
            {
              uint64_t v159 = v269;
              unint64_t v160 = v268;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v269,  v78,  v268,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              char v162 = v267;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 8))( &qword_18180BE68,  256LL,  v160,  AssociatedConformanceWitness);
              uint64_t v83 = v288;
              (*((void (**)(char *, uint64_t, const char *))v159 + 3))(v162, v78, v159);
              BOOL v163 = v290;
              LOBYTE(v16specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL)
                                                                                + 16LL))( v290,  v83,  v78);
              uint64_t v84 = v287;
              uint64_t v291 = *(void *)(v287 + 8);
              ((void (*)(char *, uint64_t))v291)(v83, v78);
              unint64_t v164 = v265;
              (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v265, v163, v78);
              if ((v160 & 1) != 0)
              {
                ((void (*)(char *, uint64_t))v291)(v164, v78);
                uint64_t v77 = v258;
                goto LABEL_48;
              }

              int64_t v165 = v294;
              uint64_t v166 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
              ((void (*)(char *, uint64_t))v291)(v164, v78);
              BOOL v167 = v166 < v165;
              uint64_t v77 = v258;
              if (v167)
              {
LABEL_48:
                int64_t v294 = -24LL;
                if ((v77((unint64_t *)v78, v68) & 1) != 0)
                {
                  uint64_t v168 = v290;
                  uint64_t v169 = v259(v78, v68);
                  uint64_t v66 = v257;
                  if (v169 < 64)
                  {
                    (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v83, v168, v78);
LABEL_68:
                    uint64_t v196 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                    ((void (*)(char *, uint64_t))v291)(v83, v78);
                    if (v196 < v294) {
                      goto LABEL_85;
                    }
LABEL_73:
                    uint64_t v287 = (*(uint64_t (**)(swift *, uint64_t))(v63 + 136))(a2, v63);
                    uint64_t v204 = v168;
                    uint64_t v205 = v285;
                    (*(void (**)(char *, char *, uint64_t))(v84 + 32))(v285, v204, v78);
                    char v206 = v258((unint64_t *)v78, v68);
                    uint64_t v207 = v271;
                    uint64_t v290 = *(char **)(v84 + 16);
                    ((void (*)(char *, char *, uint64_t))v290)(v271, v205, v78);
                    if ((v206 & 1) == 0) {
                      goto LABEL_91;
                    }
                    uint64_t v208 = v259;
                    uint64_t v209 = v259(v78, v68);
                    ((void (*)(char *, uint64_t))v291)(v207, v78);
                    if (v209 <= 64) {
                      goto LABEL_92;
                    }
                    uint64_t v207 = v264;
                    ((void (*)(char *, char *, uint64_t))v290)(v264, v285, v78);
                    int64_t v294 = 0x8000000000000000LL;
                    uint64_t v210 = (uint64_t (*)(uint64_t, uint64_t))v258;
                    if ((v258((unint64_t *)v78, v68) & 1) != 0)
                    {
                      uint64_t v211 = v259(v78, v68);
                      if (v211 >= 64)
                      {
                        unint64_t v271 = (char *)v65;
                        unint64_t v214 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                        unint64_t v215 = lazy protocol witness table accessor for type Int and conformance Int(v211, v212, v213);
                        uint64_t v216 = v288;
                        v214(&v294, &type metadata for Int, v215, v78, v68);
                        int v65 = (void (*)(char *, uint64_t, swift *))v271;
                        char v217 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                              + 8LL)
                                                                                  + 16LL))( v207,  v216,  v78);
                        ((void (*)(char *, uint64_t))v291)(v216, v78);
                        if ((v217 & 1) != 0) {
                          goto LABEL_111;
                        }
                        goto LABEL_91;
                      }
                    }

                    else
                    {
                      unint64_t v271 = (char *)v65;
                      char v218 = v210(v78, v68);
                      uint64_t v219 = v259(v78, v68);
                      if ((v218 & 1) != 0)
                      {
                        if (v219 <= 64)
                        {
                          uint64_t v230 = v269;
                          unint64_t v231 = v268;
                          unint64_t v232 = swift_getAssociatedConformanceWitness( (uint64_t)v269,  v78,  v268,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          unint64_t v233 = v267;
                          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v232 + 8))( &qword_18180BE68,  256LL,  v231,  v232);
                          unint64_t v234 = v288;
                          (*((void (**)(char *, uint64_t, const char *))v230 + 3))(v233, v78, v230);
                          LOBYTE(v231) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL)
                                                                                            + 16LL))( v207,  v234,  v78);
                          ((void (*)(char *, uint64_t))v291)(v234, v78);
                          unint64_t v235 = v261;
                          ((void (*)(char *, char *, uint64_t))v290)(v261, v207, v78);
                          if ((v231 & 1) != 0)
                          {
LABEL_110:
                            ((void (*)(char *, uint64_t))v291)(v235, v78);
                            goto LABEL_111;
                          }

                          int64_t v236 = v294;
                          uint64_t v237 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                          ((void (*)(char *, uint64_t))v291)(v235, v78);
                          BOOL v167 = v237 < v236;
                          int v65 = (void (*)(char *, uint64_t, swift *))v271;
                          if (v167) {
                            goto LABEL_111;
                          }
                          goto LABEL_91;
                        }

                        unint64_t v222 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                        unint64_t v223 = lazy protocol witness table accessor for type Int and conformance Int(v219, v220, v221);
                        unint64_t v224 = v288;
                        v222(&v294, &type metadata for Int, v223, v78, v68);
                        char v225 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                              + 8LL)
                                                                                  + 16LL))( v207,  v224,  v78);
                        ((void (*)(char *, uint64_t))v291)(v224, v78);
                        int v65 = (void (*)(char *, uint64_t, swift *))v271;
                        if ((v225 & 1) != 0) {
LABEL_111:
                        }
                          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_91:
                        ((void (*)(char *, uint64_t))v291)(v207, v78);
                        uint64_t v208 = v259;
LABEL_92:
                        char v238 = v285;
                        uint64_t v239 = v208(v78, v68);
                        unint64_t v240 = v270;
                        ((void (*)(char *, char *, uint64_t))v290)(v270, v238, v78);
                        if (v239 < 65)
                        {
                          uint64_t v248 = v208(v78, v68);
                          ((void (*)(char *, uint64_t))v291)(v240, v78);
                        }

                        else
                        {
                          ((void (*)(char *, uint64_t))v291)(v240, v78);
                        }

                        unint64_t v271 = (char *)v65;
                        ((void (*)(char *, char *, uint64_t))v290)(v272, v285, v78);
                        int64_t v294 = 0x7FFFFFFFFFFFFFFFLL;
                        char v241 = v258((unint64_t *)v78, v68);
                        uint64_t v242 = v208(v78, v68);
                        if ((v241 & 1) != 0)
                        {
                          if (v242 > 64)
                          {
                            uint64_t v245 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                            unint64_t v246 = lazy protocol witness table accessor for type Int and conformance Int( v242,  v243,  v244);
                            unint64_t v247 = &v294;
                            goto LABEL_104;
                          }
                        }

                        else if (v242 >= 64)
                        {
                          uint64_t v293 = 0x7FFFFFFFFFFFFFFFLL;
                          uint64_t v245 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                          unint64_t v246 = lazy protocol witness table accessor for type Int and conformance Int(v242, v243, v244);
                          unint64_t v247 = &v293;
LABEL_104:
                          v252 = v288;
                          v245(v247, &type metadata for Int, v246, v78, v68);
                          unint64_t v250 = v272;
                          char v253 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                                + 8LL)
                                                                                    + 16LL))( v252,  v272,  v78);
                          ((void (*)(char *, uint64_t))v291)(v252, v78);
                          int v65 = (void (*)(char *, uint64_t, swift *))v271;
                          if ((v253 & 1) == 0) {
                            goto LABEL_105;
                          }
                          goto LABEL_103;
                        }

                        unint64_t v249 = v288;
                        unint64_t v250 = v272;
                        ((void (*)(char *, char *, uint64_t))v290)(v288, v272, v78);
                        uint64_t v251 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                        ((void (*)(char *, uint64_t))v291)(v249, v78);
                        int v65 = (void (*)(char *, uint64_t, swift *))v271;
                        if (v294 >= v251)
                        {
LABEL_105:
                          ((void (*)(char *, uint64_t))v291)(v250, v78);
LABEL_106:
                          unint64_t v235 = v285;
                          uint64_t v254 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                          ((void (*)(char *, uint64_t))v291)(v235, v78);
                          if (!__OFADD__(v254, 24LL))
                          {
                            uint64_t v72 = v292;
                            unint64_t v71 = v256;
                            if (v254 + 24 < v287)
                            {
LABEL_108:
                              v71((char *)v72, a2);
                              goto LABEL_3;
                            }

unint64_t specialized BinaryFloatingPoint.init<A>(exactly:)(const char *a1, swift *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  uint64_t v288 = *(void *)(swift_getAssociatedConformanceWitness( v6,  (uint64_t)a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  Swift::String::Index v266 = *(const char **)(*(void *)(v288 + 24) + 16LL);
  unint64_t v265 = swift_getAssociatedTypeWitness( 0LL,  v266,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v265);
  Swift::String::Index v264 = (char *)&v253 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v280 = *(void *)(v9 - 8);
  unint64_t v281 = v9;
  MEMORY[0x1895F8858](v9);
  uint64_t v279 = (char *)&v253 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v277 = *(void *)(v11 - 8);
  unint64_t v278 = v11;
  MEMORY[0x1895F8858](v11);
  uint64_t v276 = (char *)&v253 - v12;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v14 = *(v13 - 1);
  uint64_t v283 = v13;
  uint64_t v284 = v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v253 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  Swift::Int v262 = (char *)&v253 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  Swift::String::Index v263 = (char *)&v253 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::String::Index v259 = (char *)&v253 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::String::Index v260 = (char *)&v253 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  Swift::String::Index v258 = (char *)&v253 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v269 = (char *)&v253 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  Swift::Int v267 = (char *)&v253 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  Swift::String::Index v261 = (char *)&v253 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  unint64_t v268 = (char *)&v253 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v282 = (char *)&v253 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  uint64_t v285 = (char *)&v253 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  uint64_t v287 = (char *)&v253 - v41;
  uint64_t v42 = *((void *)a2 - 1);
  uint64_t v43 = MEMORY[0x1895F8858](v40);
  uint64_t v275 = (char *)&v253 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  char v272 = (uint64_t *)((char *)&v253 - v46);
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  unint64_t v274 = (char *)&v253 - v48;
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  unint64_t v271 = (uint64_t *)((char *)&v253 - v50);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  uint64_t v273 = (char *)&v253 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  uint64_t v270 = (uint64_t *)((char *)&v253 - v54);
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  uint64_t v57 = (char *)&v253 - v56;
  MEMORY[0x1895F8858](v55);
  unint64_t v59 = (char *)&v253 - v58;
  uint64_t v60 = v6;
  if (((*(uint64_t (**)(swift *, uint64_t))(v6 + 408))(a2, v6) & 1) == 0)
  {
    uint64_t v286 = v42;
    uint64_t v289 = a1;
    uint64_t v257 = *(uint64_t (**)(swift *, uint64_t))(a3 + 96);
    uint64_t v63 = a3;
    if (v257(a2, a3) < 9)
    {
      uint64_t v67 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 104))(a2, a3);
      uint64_t v64 = v286;
      int v65 = *(void (**)(char *, const char *, swift *))(v286 + 16);
      v65(v59, v289, a2);
      uint64_t v66 = v60;
      if (v67 < 24)
      {
        char v69 = 0;
        uint64_t v68 = v288;
LABEL_9:
        uint64_t v70 = v59;
        unint64_t v71 = *(void (**)(char *, swift *))(v64 + 8);
        v71(v70, a2);
        uint64_t v72 = v289;
        v65(v57, v289, a2);
        if ((v69 & 1) == 0)
        {
          v71(v57, a2);
          goto LABEL_16;
        }

        char v73 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 384))(a2, v66);
        v71(v57, a2);
        if ((v73 & 1) != 0) {
          goto LABEL_16;
        }
        int v74 = *(void (**)(swift *))(v66 + 176);
        uint64_t v75 = v66;
        uint64_t v76 = v287;
        uint64_t v254 = v75;
        v74(a2);
        int64_t v291 = -126LL;
        uint64_t v77 = *(uint64_t (**)(unint64_t *, uint64_t))(v68 + 64);
        uint64_t v78 = (uint64_t)v283;
        char v79 = v77(v283, v68);
        char v253 = v71;
        uint64_t v255 = v77;
        if ((v79 & 1) != 0)
        {
          Swift::String::Index v256 = *(uint64_t (**)(uint64_t, uint64_t))(v68 + 128);
          uint64_t v80 = v256(v78, v68);
          if (v80 < 64)
          {
            uint64_t v84 = v284;
            uint64_t v83 = v285;
            (*(void (**)(char *, char *, uint64_t))(v284 + 16))(v285, v76, v78);
            uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
            uint64_t v288 = *(void *)(v84 + 8);
            ((void (*)(char *, uint64_t))v288)(v83, v78);
            if (v85 >= v291) {
              goto LABEL_52;
            }
            goto LABEL_49;
          }

          uint64_t v105 = v77;
          uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
          unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
          uint64_t v83 = v285;
          v106(&v291, &type metadata for Int, v107, v78, v68);
          uint64_t v77 = v105;
          char v108 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v76,  v83,  v78);
          uint64_t v84 = v284;
          uint64_t v288 = *(void *)(v284 + 8);
          ((void (*)(char *, uint64_t))v288)(v83, v78);
          if ((v108 & 1) != 0) {
            goto LABEL_49;
          }
        }

        else
        {
          char v98 = v77((unint64_t *)v78, v68);
          Swift::String::Index v256 = *(uint64_t (**)(uint64_t, uint64_t))(v68 + 128);
          uint64_t v99 = v256(v78, v68);
          if ((v98 & 1) != 0)
          {
            if (v99 <= 64)
            {
              int v157 = v266;
              unint64_t v158 = v265;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v266,  v78,  v265,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              unint64_t v160 = v264;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 8))( &qword_18180BE68,  256LL,  v158,  AssociatedConformanceWitness);
              uint64_t v83 = v285;
              (*((void (**)(char *, uint64_t, const char *))v157 + 3))(v160, v78, v157);
              unint64_t v161 = v287;
              LOBYTE(v158) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL)
                                                                                + 16LL))( v287,  v83,  v78);
              uint64_t v84 = v284;
              uint64_t v288 = *(void *)(v284 + 8);
              ((void (*)(char *, uint64_t))v288)(v83, v78);
              char v162 = v262;
              (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v262, v161, v78);
              if ((v158 & 1) != 0)
              {
                ((void (*)(char *, uint64_t))v288)(v162, v78);
                uint64_t v77 = v255;
                goto LABEL_49;
              }

              int64_t v163 = v291;
              uint64_t v164 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
              ((void (*)(char *, uint64_t))v288)(v162, v78);
              BOOL v165 = v164 < v163;
              uint64_t v77 = v255;
              if (v165)
              {
LABEL_49:
                int64_t v291 = -149LL;
                if ((v77((unint64_t *)v78, v68) & 1) != 0)
                {
                  uint64_t v166 = v287;
                  uint64_t v167 = v256(v78, v68);
                  uint64_t v66 = v254;
                  if (v167 < 64)
                  {
                    (*(void (**)(char *, char *, uint64_t))(v84 + 16))(v83, v166, v78);
LABEL_69:
                    uint64_t v194 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                    ((void (*)(char *, uint64_t))v288)(v83, v78);
                    if (v194 < v291) {
                      goto LABEL_86;
                    }
LABEL_74:
                    uint64_t v284 = (*(uint64_t (**)(swift *, uint64_t))(v63 + 136))(a2, v63);
                    int64_t v202 = v166;
                    uint64_t v203 = v282;
                    (*(void (**)(char *, char *, uint64_t))(v84 + 32))(v282, v202, v78);
                    char v204 = v255((unint64_t *)v78, v68);
                    uint64_t v205 = v268;
                    uint64_t v287 = *(char **)(v84 + 16);
                    ((void (*)(char *, char *, uint64_t))v287)(v268, v203, v78);
                    if ((v204 & 1) == 0) {
                      goto LABEL_92;
                    }
                    char v206 = v256;
                    uint64_t v207 = v256(v78, v68);
                    ((void (*)(char *, uint64_t))v288)(v205, v78);
                    if (v207 <= 64) {
                      goto LABEL_93;
                    }
                    uint64_t v205 = v261;
                    ((void (*)(char *, char *, uint64_t))v287)(v261, v282, v78);
                    int64_t v291 = 0x8000000000000000LL;
                    uint64_t v208 = (uint64_t (*)(uint64_t, uint64_t))v255;
                    if ((v255((unint64_t *)v78, v68) & 1) != 0)
                    {
                      uint64_t v209 = v256(v78, v68);
                      if (v209 >= 64)
                      {
                        unint64_t v268 = (char *)v65;
                        uint64_t v212 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                        unint64_t v213 = lazy protocol witness table accessor for type Int and conformance Int(v209, v210, v211);
                        unint64_t v214 = v285;
                        v212(&v291, &type metadata for Int, v213, v78, v68);
                        int v65 = (void (*)(char *, const char *, swift *))v268;
                        char v215 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                              + 8LL)
                                                                                  + 16LL))( v205,  v214,  v78);
                        ((void (*)(char *, uint64_t))v288)(v214, v78);
                        if ((v215 & 1) != 0) {
                          goto LABEL_112;
                        }
                        goto LABEL_92;
                      }
                    }

                    else
                    {
                      unint64_t v268 = (char *)v65;
                      char v216 = v208(v78, v68);
                      uint64_t v217 = v256(v78, v68);
                      if ((v216 & 1) != 0)
                      {
                        if (v217 <= 64)
                        {
                          char v228 = v266;
                          unint64_t v229 = v265;
                          unint64_t v230 = swift_getAssociatedConformanceWitness( (uint64_t)v266,  v78,  v265,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          unint64_t v231 = v264;
                          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v230 + 8))( &qword_18180BE68,  256LL,  v229,  v230);
                          unint64_t v232 = v285;
                          (*((void (**)(char *, uint64_t, const char *))v228 + 3))(v231, v78, v228);
                          LOBYTE(v229) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL)
                                                                                            + 16LL))( v205,  v232,  v78);
                          ((void (*)(char *, uint64_t))v288)(v232, v78);
                          unint64_t v233 = v258;
                          ((void (*)(char *, char *, uint64_t))v287)(v258, v205, v78);
                          if ((v229 & 1) != 0)
                          {
LABEL_111:
                            ((void (*)(char *, uint64_t))v288)(v233, v78);
                            goto LABEL_112;
                          }

                          int64_t v234 = v291;
                          uint64_t v235 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                          ((void (*)(char *, uint64_t))v288)(v233, v78);
                          BOOL v165 = v235 < v234;
                          int v65 = (void (*)(char *, const char *, swift *))v268;
                          if (v165) {
                            goto LABEL_112;
                          }
                          goto LABEL_92;
                        }

                        uint64_t v220 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                        unint64_t v221 = lazy protocol witness table accessor for type Int and conformance Int(v217, v218, v219);
                        unint64_t v222 = v285;
                        v220(&v291, &type metadata for Int, v221, v78, v68);
                        char v223 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                              + 8LL)
                                                                                  + 16LL))( v205,  v222,  v78);
                        ((void (*)(char *, uint64_t))v288)(v222, v78);
                        int v65 = (void (*)(char *, const char *, swift *))v268;
                        if ((v223 & 1) != 0) {
LABEL_112:
                        }
                          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_92:
                        ((void (*)(char *, uint64_t))v288)(v205, v78);
                        char v206 = v256;
LABEL_93:
                        int64_t v236 = v282;
                        uint64_t v237 = v206(v78, v68);
                        char v238 = v267;
                        ((void (*)(char *, char *, uint64_t))v287)(v267, v236, v78);
                        if (v237 < 65)
                        {
                          uint64_t v246 = v206(v78, v68);
                          ((void (*)(char *, uint64_t))v288)(v238, v78);
                        }

                        else
                        {
                          ((void (*)(char *, uint64_t))v288)(v238, v78);
                        }

                        unint64_t v268 = (char *)v65;
                        ((void (*)(char *, char *, uint64_t))v287)(v269, v282, v78);
                        int64_t v291 = 0x7FFFFFFFFFFFFFFFLL;
                        char v239 = v255((unint64_t *)v78, v68);
                        uint64_t v240 = v206(v78, v68);
                        if ((v239 & 1) != 0)
                        {
                          if (v240 > 64)
                          {
                            uint64_t v243 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                            unint64_t v244 = lazy protocol witness table accessor for type Int and conformance Int( v240,  v241,  v242);
                            uint64_t v245 = &v291;
                            goto LABEL_105;
                          }
                        }

                        else if (v240 >= 64)
                        {
                          uint64_t v290 = 0x7FFFFFFFFFFFFFFFLL;
                          uint64_t v243 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                          unint64_t v244 = lazy protocol witness table accessor for type Int and conformance Int(v240, v241, v242);
                          uint64_t v245 = &v290;
LABEL_105:
                          unint64_t v250 = v285;
                          v243(v245, &type metadata for Int, v244, v78, v68);
                          uint64_t v248 = v269;
                          char v251 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32)
                                                                                                + 8LL)
                                                                                    + 16LL))( v250,  v269,  v78);
                          ((void (*)(char *, uint64_t))v288)(v250, v78);
                          int v65 = (void (*)(char *, const char *, swift *))v268;
                          if ((v251 & 1) == 0) {
                            goto LABEL_106;
                          }
                          goto LABEL_104;
                        }

                        unint64_t v247 = v285;
                        uint64_t v248 = v269;
                        ((void (*)(char *, char *, uint64_t))v287)(v285, v269, v78);
                        uint64_t v249 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                        ((void (*)(char *, uint64_t))v288)(v247, v78);
                        int v65 = (void (*)(char *, const char *, swift *))v268;
                        if (v291 >= v249)
                        {
LABEL_106:
                          ((void (*)(char *, uint64_t))v288)(v248, v78);
LABEL_107:
                          unint64_t v233 = v282;
                          uint64_t v252 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
                          ((void (*)(char *, uint64_t))v288)(v233, v78);
                          if (!__OFADD__(v252, 149LL))
                          {
                            uint64_t v72 = v289;
                            unint64_t v71 = v253;
                            if (v252 + 149 < v284)
                            {
LABEL_109:
                              v71((char *)v72, a2);
                              goto LABEL_3;
                            }

unint64_t specialized BinaryFloatingPoint.init<A>(exactly:)(uint64_t a1, swift *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  uint64_t v286 = *(void *)(swift_getAssociatedConformanceWitness( v6,  (uint64_t)a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  Swift::String::Index v264 = *(const char **)(*(void *)(v286 + 24) + 16LL);
  unint64_t v263 = swift_getAssociatedTypeWitness( 0LL,  v264,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v263);
  Swift::Int v262 = (char *)&v251 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v278 = *(void *)(v9 - 8);
  unint64_t v279 = v9;
  MEMORY[0x1895F8858](v9);
  uint64_t v277 = (char *)&v251 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v275 = *(void *)(v11 - 8);
  unint64_t v276 = v11;
  MEMORY[0x1895F8858](v11);
  unint64_t v274 = (char *)&v251 - v12;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v14 = *(v13 - 1);
  unint64_t v281 = v13;
  uint64_t v282 = v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v251 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  Swift::String::Index v260 = (char *)&v251 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  Swift::String::Index v261 = (char *)&v251 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v257 = (char *)&v251 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::String::Index v258 = (char *)&v251 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  Swift::String::Index v256 = (char *)&v251 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  Swift::Int v267 = (char *)&v251 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v265 = (char *)&v251 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  Swift::String::Index v259 = (char *)&v251 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  Swift::String::Index v266 = (char *)&v251 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  uint64_t v280 = (char *)&v251 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  uint64_t v283 = (char *)&v251 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  uint64_t v285 = (char *)&v251 - v41;
  uint64_t v42 = *((void *)a2 - 1);
  uint64_t v43 = MEMORY[0x1895F8858](v40);
  uint64_t v273 = (char *)&v251 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v270 = (uint64_t *)((char *)&v251 - v46);
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  char v272 = (char *)&v251 - v48;
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  uint64_t v269 = (uint64_t *)((char *)&v251 - v50);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  unint64_t v271 = (char *)&v251 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  unint64_t v268 = (uint64_t *)((char *)&v251 - v54);
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  uint64_t v57 = (char *)&v251 - v56;
  MEMORY[0x1895F8858](v55);
  unint64_t v59 = (char *)&v251 - v58;
  uint64_t v60 = v6;
  if (((*(uint64_t (**)(swift *, uint64_t))(v6 + 408))(a2, v6) & 1) != 0)
  {
    (*(void (**)(uint64_t, swift *))(v42 + 8))(a1, a2);
    return 0LL;
  }

  uint64_t v284 = v42;
  uint64_t v287 = a1;
  uint64_t v255 = *(uint64_t (**)(swift *, uint64_t))(a3 + 96);
  uint64_t v62 = a3;
  if (v255(a2, a3) >= 12)
  {
    uint64_t v63 = v284;
    uint64_t v64 = *(void (**)(char *, uint64_t, swift *))(v284 + 16);
    v64(v59, v287, a2);
    uint64_t v65 = v60;
LABEL_7:
    uint64_t v67 = v286;
    char v68 = (*(uint64_t (**)(swift *, uint64_t))(v65 + 376))(a2, v65);
    goto LABEL_9;
  }

  uint64_t v66 = (*(uint64_t (**)(swift *, uint64_t))(a3 + 104))(a2, a3);
  uint64_t v63 = v284;
  uint64_t v64 = *(void (**)(char *, uint64_t, swift *))(v284 + 16);
  v64(v59, v287, a2);
  uint64_t v65 = v60;
  if (v66 >= 53) {
    goto LABEL_7;
  }
  char v68 = 0;
  uint64_t v67 = v286;
LABEL_9:
  char v69 = v59;
  uint64_t v70 = *(void (**)(char *, swift *))(v63 + 8);
  v70(v69, a2);
  uint64_t v71 = v287;
  v64(v57, v287, a2);
  if ((v68 & 1) == 0)
  {
    v70(v57, a2);
    goto LABEL_16;
  }

  char v72 = (*(uint64_t (**)(swift *, uint64_t))(v65 + 384))(a2, v65);
  v70(v57, a2);
  if ((v72 & 1) != 0) {
    goto LABEL_16;
  }
  char v73 = *(void (**)(swift *))(v65 + 176);
  uint64_t v74 = v65;
  uint64_t v75 = v285;
  uint64_t v252 = v74;
  v73(a2);
  int64_t v289 = -1022LL;
  uint64_t v76 = *(uint64_t (**)(unint64_t *, uint64_t))(v67 + 64);
  uint64_t v77 = (uint64_t)v281;
  char v78 = v76(v281, v67);
  char v251 = v70;
  char v253 = v76;
  if ((v78 & 1) != 0)
  {
    uint64_t v254 = *(uint64_t (**)(uint64_t, uint64_t))(v67 + 128);
    uint64_t v79 = v254(v77, v67);
    if (v79 < 64)
    {
      uint64_t v83 = v282;
      uint64_t v82 = v283;
      (*(void (**)(char *, char *, uint64_t))(v282 + 16))(v283, v75, v77);
      int64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
      uint64_t v286 = *(void *)(v83 + 8);
      ((void (*)(char *, uint64_t))v286)(v82, v77);
      if (v84 >= v289) {
        goto LABEL_51;
      }
      goto LABEL_48;
    }

    unint64_t v103 = v76;
    char v104 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
    unint64_t v105 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
    uint64_t v82 = v283;
    v104(&v289, &type metadata for Int, v105, v77, v67);
    uint64_t v76 = v103;
    char v106 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v75,  v82,  v77);
    uint64_t v83 = v282;
    uint64_t v286 = *(void *)(v282 + 8);
    ((void (*)(char *, uint64_t))v286)(v82, v77);
    if ((v106 & 1) != 0) {
      goto LABEL_48;
    }
    goto LABEL_51;
  }

  char v96 = v76((unint64_t *)v77, v67);
  uint64_t v254 = *(uint64_t (**)(uint64_t, uint64_t))(v67 + 128);
  uint64_t v97 = v254(v77, v67);
  if ((v96 & 1) == 0)
  {
    uint64_t v83 = v282;
    unint64_t v107 = *(void (**)(char *, char *, uint64_t))(v282 + 16);
    if (v97 >= 64)
    {
      v107(v17, v285, v77);
      uint64_t v286 = *(void *)(v83 + 8);
      ((void (*)(char *, uint64_t))v286)(v17, v77);
      uint64_t v82 = v283;
      uint64_t v76 = v253;
      goto LABEL_51;
    }

    uint64_t v82 = v283;
    v107(v283, v285, v77);
    int64_t v108 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
    uint64_t v286 = *(void *)(v83 + 8);
    ((void (*)(char *, uint64_t))v286)(v82, v77);
    uint64_t v76 = v253;
    if (v108 < v289) {
      goto LABEL_48;
    }
    goto LABEL_51;
  }

  if (v97 > 64)
  {
    uint64_t v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
    unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
    uint64_t v82 = v283;
    v100(&v289, &type metadata for Int, v101, v77, v67);
    char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v285,  v82,  v77);
    uint64_t v83 = v282;
    uint64_t v286 = *(void *)(v282 + 8);
    ((void (*)(char *, uint64_t))v286)(v82, v77);
    uint64_t v76 = v253;
    if ((v102 & 1) != 0) {
      goto LABEL_48;
    }
    goto LABEL_51;
  }

  unint64_t v155 = v264;
  unint64_t v156 = v263;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v264,  v77,  v263,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v158 = v262;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v156,  AssociatedConformanceWitness);
  uint64_t v82 = v283;
  (*((void (**)(char *, uint64_t, const char *))v155 + 3))(v158, v77, v155);
  uint64_t v159 = v285;
  LOBYTE(v156) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v285,  v82,  v77);
  uint64_t v83 = v282;
  uint64_t v286 = *(void *)(v282 + 8);
  ((void (*)(char *, uint64_t))v286)(v82, v77);
  unint64_t v160 = v260;
  (*(void (**)(char *, char *, uint64_t))(v83 + 16))(v260, v159, v77);
  if ((v156 & 1) != 0)
  {
    ((void (*)(char *, uint64_t))v286)(v160, v77);
    uint64_t v76 = v253;
    goto LABEL_48;
  }

  int64_t v161 = v289;
  uint64_t v162 = (*(uint64_t (**)(uint64_t, uint64_t))(v67 + 120))(v77, v67);
  ((void (*)(char *, uint64_t))v286)(v160, v77);
  BOOL v163 = v162 < v161;
  uint64_t v76 = v253;
  if (!v163)
  {
LABEL_51:
    int64_t v289 = 1023LL;
    char v168 = v76((unint64_t *)v77, v67);
    uint64_t v169 = v254(v77, v67);
    if ((v168 & 1) != 0)
    {
      uint64_t v65 = v252;
      if (v169 > 64)
      {
        uint64_t v172 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
        unint64_t v173 = lazy protocol witness table accessor for type Int and conformance Int(v169, v170, v171);
        v172(&v289, &type metadata for Int, v173, v77, v67);
        uint64_t v174 = v285;
        char v175 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v82,  v285,  v77);
        __int128 v176 = (void (*)(char *, uint64_t))v286;
        ((void (*)(char *, uint64_t))v286)(v82, v77);
        char v177 = v174;
        goto LABEL_61;
      }
    }

    else
    {
      uint64_t v65 = v252;
      if (v169 > 63)
      {
        uint64_t v288 = 1023LL;
        uint64_t v180 = *(uint64_t (**)(char *, char *, uint64_t))(v83 + 32);
        char v181 = v261;
        uint64_t v182 = v180(v261, v285, v77);
        char v183 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v67 + 96);
        unint64_t v186 = lazy protocol witness table accessor for type Int and conformance Int(v182, v184, v185);
        v183(&v288, &type metadata for Int, v186, v77, v67);
        char v175 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v82,  v181,  v77);
        __int128 v176 = (void (*)(char *, uint64_t))v286;
        ((void (*)(char *, uint64_t))v286)(v82, v77);
        char v177 = v181;
LABEL_61:
        v176(v177, v77);
        if ((v175 & 1) == 0)
        {
LABEL_62:
          uint64_t v71 = v287;
          uint64_t v187 = (*(uint64_t (**)(swift *, uint64_t))(v62 + 136))(a2, v62);
          uint64_t v70 = v251;
          if (v187 >= 53) {
            goto LABEL_108;
          }
          goto LABEL_16;
        }

LABEL_69:
                      v295(v175, v176);
                      (*(void (**)(char *, unint64_t *))(v174 + 8))(v166, v103);
LABEL_80:
                      char v73 = 1LL;
                      uint64_t v75 = v341;
                      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v342 + 56))( v75,  v73,  1LL,  v74);
                    }

                    char v214 = v315;
                    unint64_t v103 = v333;
                    uint64_t v215 = v313;
                    uint64_t v216 = swift_getAssociatedConformanceWitness( (uint64_t)v315,  (uint64_t)v333,  v313,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    uint64_t v217 = v314;
                    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v216 + 8))( &unk_18180BE68,  256LL,  v215,  v216);
                    uint64_t v218 = v298;
                    (*((void (**)(char *, unint64_t *, const char *))v214 + 3))(v217, v103, v214);
                    uint64_t v99 = v332;
                    unint64_t v219 = v299;
                    LOBYTE(v215) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v332 + 32) + 8LL)
                                                                                                 + 16LL))( v299,  v218,  v103);
                    uint64_t v220 = v335;
                    v331 = *(void *)(v335 + 8);
                    ((void (*)(char *, unint64_t *))v331)(v218, v103);
                    char v221 = v302;
                    (*(void (**)(char *, char *, unint64_t *))(v220 + 16))(v302, v219, v103);
                    int64_t v222 = v330;
                    uint64_t v223 = v306;
                    uint64_t v85 = (unint64_t *)v338;
                    (*(void (**)(char *, char *, uint64_t))(v330 + 32))(v306, v158, v338);
                    if ((v215 & 1) != 0)
                    {
                      (*(void (**)(char *, unint64_t *))(v222 + 8))(v223, v85);
                      ((void (*)(char *, unint64_t *))v331)(v221, v103);
                      __int128 v176 = v343;
                      uint64_t v174 = v335;
                      uint64_t v166 = v299;
                      char v175 = v327;
                      goto LABEL_69;
                    }

                    uint64_t v270 = v329;
                    (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v100 + 96))( v221,  v103,  v99,  v85,  v100);
                    LODWORD(v331) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32) + 8LL)
                                                                                                  + 16LL))( v270,  v223,  v85);
                    unint64_t v271 = *(void (**)(char *, unint64_t *))(v222 + 8);
                    v271(v270, v85);
                    v271(v223, v85);
                    __int128 v176 = v343;
                    uint64_t v174 = v335;
                  }

                  else
                  {
                    if (v163 < v164)
                    {
                      char v177 = v158;
                      int64_t v178 = v298;
                      uint64_t v166 = v299;
                      unint64_t v103 = v333;
                      (*(void (**)(char *, char *, unint64_t *))(v335 + 16))(v298, v299, v333);
                      char v179 = v329;
                      uint64_t v99 = v332;
                      uint64_t v85 = (unint64_t *)v338;
                      (*(void (**)(char *, unint64_t *, uint64_t, uint64_t, uint64_t))(v100 + 96))( v178,  v103,  v332,  v338,  v100);
                      uint64_t v180 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32) + 8LL)
                                                                                           + 16LL))( v179,  v177,  v85);
                      char v181 = *(void (**)(char *, unint64_t *))(v330 + 8);
                      v181(v179, v85);
                      v181(v177, v85);
                      uint64_t v174 = v335;
                      goto LABEL_40;
                    }

                    int64_t v224 = v318;
                    uint64_t v85 = (unint64_t *)v338;
                    int64_t v225 = v316;
                    int64_t v226 = swift_getAssociatedConformanceWitness( (uint64_t)v318,  v338,  v316,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    unint64_t v227 = v317;
                    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v226 + 8))( &unk_18180BE68,  256LL,  v225,  v226);
                    unint64_t v228 = v329;
                    (*((void (**)(char *, unint64_t *, const char *))v224 + 3))(v227, v85, v224);
                    LODWORD(v331) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32) + 8LL)
                                                                                                  + 40LL))( v158,  v228,  v85);
                    unint64_t v229 = v330;
                    unint64_t v230 = *(void (**)(char *, unint64_t *))(v330 + 8);
                    v230(v228, v85);
                    unint64_t v231 = v158;
                    int64_t v232 = v335;
                    uint64_t v233 = v304;
                    unint64_t v103 = v333;
                    (*(void (**)(char *, char *, unint64_t *))(v335 + 16))(v304, v299, v333);
                    int64_t v234 = v305;
                    (*(void (**)(char *, char *, unint64_t *))(v229 + 32))(v305, v231, v85);
                    __int128 v176 = v343;
                    if ((v331 & 1) == 0)
                    {
                      v230(v234, v85);
                      (*(void (**)(char *, unint64_t *))(v232 + 8))(v233, v103);
                      uint64_t v174 = v232;
                      uint64_t v99 = v332;
                      uint64_t v166 = v299;
                      char v175 = v327;
                      goto LABEL_71;
                    }

                    uint64_t v235 = v232;
                    int64_t v236 = v234;
                    uint64_t v99 = v332;
                    char v237 = v298;
                    (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v332 + 96))( v236,  v85,  v100,  v103,  v332);
                    LODWORD(v331) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v99 + 32) + 8LL)
                                                                                                  + 16LL))( v233,  v237,  v103);
                    uint64_t v238 = *(void (**)(char *, unint64_t *))(v235 + 8);
                    v238(v237, v103);
                    v238(v233, v103);
                    uint64_t v174 = v235;
                  }

                  uint64_t v166 = v299;
                  char v175 = v327;
                  if ((v331 & 1) == 0) {
                    goto LABEL_71;
                  }
                  goto LABEL_69;
                }

                char v168 = v299;
                uint64_t v169 = v300(v103, v99);
                if (v169 < v296(v85, v100))
                {
                  uint64_t v170 = v298;
                  (*(void (**)(char *, char *, unint64_t *))(v335 + 16))(v298, v168, v103);
                  uint64_t v171 = v158;
                  uint64_t v166 = v168;
                  uint64_t v172 = v329;
                  (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v100 + 96))( v170,  v103,  v99,  v85,  v100);
                  LODWORD(v338) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32) + 8LL)
                                                                                                + 16LL))( v172,  v171,  v85);
                  unint64_t v173 = *(void (**)(char *, unint64_t *))(v330 + 8);
                  v173(v172, v85);
                  v173(v171, v85);
                  uint64_t v174 = v335;
                  char v175 = v327;
                  __int128 v176 = v343;
                  if ((v338 & 1) == 0) {
                    goto LABEL_71;
                  }
                  goto LABEL_69;
                }

                uint64_t v165 = v298;
                (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v99 + 96))( v158,  v85,  v100,  v103,  v99);
                uint64_t v166 = v168;
                uint64_t v167 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v99 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v168,  v165,  v103);
                goto LABEL_39;
              }

    if (v17 < v18 || v17 >= v16 >> 14)
    {
LABEL_84:
      uint64_t v56 = 0;
      goto LABEL_85;
    }
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  char v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    uint64_t v76 = v70;
    if (v75 < v124) {
      goto LABEL_69;
    }
    goto LABEL_33;
  }

  uint64_t v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  uint64_t v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  uint64_t v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v70,  v29,  a3);
LABEL_55:
  uint64_t v100 = v97;
  v62(v29, a3);
  uint64_t v76 = v70;
  if ((v100 & 1) != 0) {
    goto LABEL_69;
  }
LABEL_33:
  v62(v76, a3);
LABEL_34:
  char v78 = v122;
  uint64_t v79 = v122(a3, a4);
  v66(v68, v69, a3);
  if (v79 >= 65)
  {
    v62(v68, a3);
    goto LABEL_36;
  }

  uint64_t v88 = v78(a3, a4);
  v62(v68, a3);
  if (v88 == 64 && (v121(a3, a4) & 1) == 0)
  {
LABEL_36:
    uint64_t v80 = v116;
    v66(v116, v69, a3);
    __int16 v124 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v81 = v121(a3, a4);
    uint64_t v82 = v122(a3, a4);
    if ((v81 & 1) != 0)
    {
      if (v82 > 64)
      {
        uint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
        uint64_t v87 = &v124;
        goto LABEL_45;
      }
    }

    else if (v82 > 63)
    {
      unint64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      uint64_t v87 = &v123;
LABEL_45:
      v85(v87, &type metadata for Int, v86, a3, a4);
      unint64_t v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v80,  a3);
      v62(v29, a3);
      if ((v89 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_46;
    }

    v66(v29, v80, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
LABEL_46:
    v62(v80, a3);
  }

  int v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v62(v69, a3);
  if ((v90 & 0x8000000000000000LL) != 0)
  {
    uint64_t v54 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFC0LL) {
      uint64_t v55 = v119 >> 63;
    }
    else {
      uint64_t v55 = v119 >> -(char)v90;
    }
  }

  else
  {
    uint64_t v54 = v120;
    uint64_t v55 = v119 << v90;
    if (v90 >= 0x40) {
      uint64_t v55 = 0LL;
    }
  }

    char v3 = *(void *)v6 + 4LL;
    atomic_store(v3, v2);
  }

  return v3;
}

uint64_t FloatingPoint.rounded()(uint64_t a1, uint64_t a2)
{
  char v3 = 0;
  return (*(uint64_t (**)(char *, uint64_t))(a2 + 304))(&v3, a1);
}

Swift::Void __swiftcall FloatingPoint.round()()
{
  char v1 = 0;
  (*(void (**)(char *))(v0 + 312))(&v1);
}

uint64_t static BinaryFloatingPoint.radix.getter()
{
  return 2LL;
}

uint64_t BinaryFloatingPoint.init(signOf:magnitudeOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v17 - v9;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  MEMORY[0x1895F8858](v11);
  uint64_t v13 = (char *)&v17 - v12;
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)(a4 + 16) + 168LL))(a3) & 1;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL);
  v15(a1, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 112))(a3, a4);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v15(a2, a3);
  return (*(uint64_t (**)(uint64_t, char *, char *, uint64_t, uint64_t))(a4 + 56))(v14, v13, v10, a3, a4);
}

uint64_t specialized static BinaryFloatingPoint._convert<A>(from:)( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v606 = a1;
  uint64_t v617 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  v619 = (char *)&v556 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  v559 = (char *)&v556 - v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  v12,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v613 = *(char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)
                  + 8);
  uint64_t v594 = *((void *)v613 + 3);
  v614 = *(char **)(v594 + 16);
  unint64_t v612 = swift_getAssociatedTypeWitness( 0LL,  v614,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v612);
  v608 = (char *)&v556 - v15;
  v603 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  double v607 = *((double *)v603 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v603);
  v558 = (char *)&v556 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v557 = (char *)&v556 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v616 = (char *)&v556 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v566 = (char *)&v556 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v582 = (char *)&v556 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v580 = (char *)&v556 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v590 = (char *)&v556 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v562 = (char *)&v556 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v576 = (char *)&v556 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v571 = (char *)&v556 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v597 = (char *)&v556 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v596 = (char *)&v556 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v595 = (char *)&v556 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v602 = (char *)&v556 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  v600 = (char *)&v556 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  v604 = (char *)&v556 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  v564 = (char *)&v556 - v49;
  uint64_t v50 = MEMORY[0x1895F8858](v48);
  v581 = (char *)&v556 - v51;
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  v578 = (char *)&v556 - v53;
  uint64_t v54 = MEMORY[0x1895F8858](v52);
  v598 = (char *)&v556 - v55;
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  v561 = (char *)&v556 - v57;
  uint64_t v58 = MEMORY[0x1895F8858](v56);
  v573 = (char *)&v556 - v59;
  uint64_t v60 = MEMORY[0x1895F8858](v58);
  v570 = (char *)&v556 - v61;
  uint64_t v62 = MEMORY[0x1895F8858](v60);
  v599 = (char *)&v556 - v63;
  MEMORY[0x1895F8858](v62);
  v615 = (char *)&v556 - v64;
  uint64_t v618 = a4;
  uint64_t v65 = *(void *)(a4 + 16);
  unint64_t v66 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v65,  a3,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v65,  a3,  v66,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  unint64_t v67 = *(void *)(AssociatedConformanceWitness + 8);
  v601 = *(void (**)(char *, char *, unint64_t *, uint64_t))(v67 + 24);
  v611 = (const char *)*((void *)v601 + 2);
  v609 = (void (*)(void, void, void))swift_getAssociatedTypeWitness( 0LL,  v611,  v66,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v609);
  v610 = (uint64_t (*)(void))((char *)&v556 - v68);
  char v69 = swift_checkMetadataState(0LL, v66);
  unint64_t v620 = *(v69 - 1);
  uint64_t v70 = MEMORY[0x1895F8858](v69);
  char v72 = (char *)&v556 - ((v71 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v73 = MEMORY[0x1895F8858](v70);
  uint64_t v75 = (char *)&v556 - v74;
  uint64_t v76 = MEMORY[0x1895F8858](v73);
  v586 = (char *)&v556 - v77;
  uint64_t v78 = MEMORY[0x1895F8858](v76);
  v569 = (char *)&v556 - v79;
  uint64_t v80 = MEMORY[0x1895F8858](v78);
  v565 = (char *)&v556 - v81;
  uint64_t v82 = MEMORY[0x1895F8858](v80);
  v588 = (char *)&v556 - v83;
  uint64_t v84 = MEMORY[0x1895F8858](v82);
  v579 = (char *)&v556 - v85;
  uint64_t v86 = MEMORY[0x1895F8858](v84);
  v589 = (void (*)(char *, unint64_t *))((char *)&v556 - v87);
  uint64_t v88 = MEMORY[0x1895F8858](v86);
  v563 = (char *)&v556 - v89;
  uint64_t v90 = MEMORY[0x1895F8858](v88);
  v583 = (char *)&v556 - v91;
  uint64_t v92 = MEMORY[0x1895F8858](v90);
  v572 = (char *)&v556 - v93;
  uint64_t v94 = MEMORY[0x1895F8858](v92);
  v585 = (char *)&v556 - v95;
  uint64_t v96 = MEMORY[0x1895F8858](v94);
  v574 = (char *)&v556 - v97;
  uint64_t v98 = MEMORY[0x1895F8858](v96);
  v575 = (char *)&v556 - v99;
  uint64_t v100 = MEMORY[0x1895F8858](v98);
  v567 = (char *)&v556 - v101;
  uint64_t v102 = MEMORY[0x1895F8858](v100);
  v568 = (char *)&v556 - v103;
  uint64_t v104 = MEMORY[0x1895F8858](v102);
  v560 = (char *)&v556 - v105;
  uint64_t v106 = MEMORY[0x1895F8858](v104);
  v587 = (char *)&v556 - v107;
  uint64_t v108 = MEMORY[0x1895F8858](v106);
  v591 = (void (*)(char *, unint64_t *))((char *)&v556 - v109);
  uint64_t v110 = MEMORY[0x1895F8858](v108);
  v577 = (char *)&v556 - v111;
  uint64_t v112 = MEMORY[0x1895F8858](v110);
  v592 = (char *)&v556 - v113;
  uint64_t v114 = MEMORY[0x1895F8858](v112);
  v605 = (uint64_t *)((char *)&v556 - v115);
  uint64_t v116 = MEMORY[0x1895F8858](v114);
  v593 = (char *)&v556 - v117;
  uint64_t v118 = MEMORY[0x1895F8858](v116);
  uint64_t v120 = (char *)&v556 - v119;
  uint64_t v121 = MEMORY[0x1895F8858](v118);
  unint64_t v123 = (char *)&v556 - v122;
  MEMORY[0x1895F8858](v121);
  uint64_t v125 = (char *)&v556 - v124;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 384))(a3, v65) & 1) != 0)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(a3, v65) & 1) == 0)
    {
      unint64_t *v606 = 0LL;
      return 1LL;
    }

    unint64_t v536 = 0x8000000000000000LL;
    v512 = v606;
    goto LABEL_269;
  }

  char v126 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 376))(a3, v65);
  uint64_t v622 = a2;
  if ((v126 & 1) == 0)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 400))(a3, v65) & 1) == 0)
    {
      uint64_t v537 = v618;
      v538 = *(void (**)(uint64_t, uint64_t))(v618 + 120);
      v538(a3, v618);
      v539 = v559;
      (*(void (**)(uint64_t, uint64_t))(v65 + 96))(a3, v65);
      v540 = v557;
      v538(a3, v537);
      v541 = *(void (**)(char *, uint64_t))(v617 + 8);
      v541(v539, a3);
      v542 = v619;
      (*(void (**)(uint64_t, uint64_t))(v65 + 104))(a3, v65);
      v543 = v558;
      v538(a3, v537);
      v541(v542, a3);
      v544 = v613;
      v545 = v595;
      v546 = v603;
      (*((void (**)(char *, char *, unint64_t *, char *))v613 + 26))(v540, v543, v603, v613);
      v547 = *(void (**)(char *, unint64_t *))(*(void *)&v607 + 8LL);
      v547(v543, v546);
      v547(v540, v546);
      v548 = v602;
      (*((void (**)(char *, unint64_t *, char *))v544 + 23))(v545, v546, v544);
      v547(v545, v546);
      v549 = v615;
      v550 = v616;
      (*((void (**)(char *, char *, unint64_t *, char *))v544 + 24))(v615, v548, v546, v544);
      v547(v548, v546);
      v547(v549, v546);
      uint64_t v551 = (*((uint64_t (**)(unint64_t *, char *))v544 + 15))(v546, v544);
      v547(v550, v546);
      uint64_t v552 = v551 & 0x3FFFFFFFFFFFFLL;
      LOBYTE(v551) = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 416))(a3, v65);
      uint64_t v553 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(a3, v65);
      uint64_t result = 0LL;
      uint64_t v554 = v552 | (v553 << 63);
      uint64_t v555 = 0x7FF8000000000000LL;
      if ((v551 & 1) != 0) {
        uint64_t v555 = 0x7FF4000000000000LL;
      }
      unint64_t v182 = v554 | v555;
      goto LABEL_79;
    }

    char v535 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(a3, v65);
    v512 = v606;
    if ((v535 & 1) != 0)
    {
LABEL_268:
      unint64_t v536 = 0xFFF0000000000000LL;
      goto LABEL_269;
    }

    unint64_t v536 = 0x7FF0000000000000LL;
LABEL_269:
    unint64_t *v512 = v536;
    return 1LL;
  }

  uint64_t v127 = *(void (**)(uint64_t, uint64_t))(v65 + 176);
  v616 = (char *)v65;
  v127(a3, v65);
  unint64_t v624 = -1022LL;
  __int16 v128 = *(uint64_t (**)(unint64_t *, unint64_t))(v67 + 64);
  char v129 = v128(v69, v67);
  uint64_t v621 = a3;
  uint64_t v617 = (uint64_t)v128;
  if ((v129 & 1) == 0)
  {
    char v137 = v128(v69, v67);
    v619 = *(char **)(v67 + 128);
    uint64_t v138 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
    if ((v137 & 1) != 0)
    {
      if (v138 > 64)
      {
        int v141 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
        unint64_t v142 = lazy protocol witness table accessor for type Int and conformance Int(v138, v139, v140);
        v141(&v624, &type metadata for Int, v142, v69, v67);
        LOBYTE(v141) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v125,  v123,  v69);
        unint64_t v136 = *(void (**)(char *, unint64_t *))(v620 + 8);
        v136(v123, v69);
        unint64_t v130 = v619;
        goto LABEL_25;
      }

      unsigned __int8 v149 = v611;
      unint64_t v150 = v609;
      unint64_t v151 = swift_getAssociatedConformanceWitness( (uint64_t)v611,  (uint64_t)v69,  (uint64_t)v609,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v152 = v610;
      (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v151 + 8))( &qword_18180BE68,  256LL,  v150,  v151);
      (*((void (**)(uint64_t (*)(void), unint64_t *, const char *))v149 + 3))( v152,  v69,  v149);
      LOBYTE(v149) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v125,  v123,  v69);
      unint64_t v153 = v620;
      unint64_t v136 = *(void (**)(char *, unint64_t *))(v620 + 8);
      v136(v123, v69);
      (*(void (**)(char *, char *, unint64_t *))(v153 + 16))(v75, v125, v69);
      if ((v149 & 1) != 0)
      {
        v136(v75, v69);
        unint64_t v130 = v619;
        goto LABEL_21;
      }

      int64_t v154 = v624;
      uint64_t v155 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
      v136(v75, v69);
      BOOL v148 = v155 < v154;
    }

    else
    {
      unint64_t v145 = v620;
      int v146 = *(void (**)(char *, char *, unint64_t *))(v620 + 16);
      if (v138 >= 64)
      {
        v146(v72, v125, v69);
        unint64_t v136 = *(void (**)(char *, unint64_t *))(v145 + 8);
        v136(v72, v69);
        unint64_t v130 = v619;
        goto LABEL_25;
      }

      v146(v123, v125, v69);
      uint64_t v147 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
      unint64_t v136 = *(void (**)(char *, unint64_t *))(v145 + 8);
      v136(v123, v69);
      BOOL v148 = v147 < (uint64_t)v624;
    }

    unint64_t v130 = v619;
    if (v148) {
      goto LABEL_21;
    }
LABEL_25:
    unint64_t v624 = 1023LL;
    uint64_t v171 = (char *)v617;
    char v172 = ((uint64_t (*)(unint64_t *, unint64_t))v617)(v69, v67);
    uint64_t v173 = ((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67);
    if ((v172 & 1) != 0)
    {
      if (v173 > 64)
      {
        __int128 v176 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
        unint64_t v177 = lazy protocol witness table accessor for type Int and conformance Int(v173, v174, v175);
        v176(&v624, &type metadata for Int, v177, v69, v67);
        char v178 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                             + 16LL))( v123,  v125,  v69);
        char v179 = v123;
        goto LABEL_37;
      }
    }

    else if (v173 > 63)
    {
      uint64_t v623 = 1023LL;
      unint64_t v186 = *(uint64_t (**)(char *, char *, unint64_t *))(v620 + 16);
      v619 = v130;
      uint64_t v187 = v586;
      uint64_t v188 = v186(v586, v125, v69);
      unint64_t v189 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
      unint64_t v192 = lazy protocol witness table accessor for type Int and conformance Int(v188, v190, v191);
      v189(&v623, &type metadata for Int, v192, v69, v67);
      char v178 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                           + 16LL))( v123,  v187,  v69);
      v136(v123, v69);
      char v179 = v187;
      unint64_t v130 = v619;
LABEL_37:
      v136(v179, v69);
      if ((v178 & 1) == 0)
      {
LABEL_38:
        if ((((uint64_t (*)(unint64_t *, unint64_t))v171)(v69, v67) & 1) != 0)
        {
          uint64_t v193 = ((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67);
          if (v193 < 64) {
            goto LABEL_50;
          }
        }

        else
        {
          char v196 = ((uint64_t (*)(unint64_t *, unint64_t))v171)(v69, v67);
          uint64_t v193 = ((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67);
          if ((v196 & 1) == 0)
          {
            if (v193 >= 64) {
              goto LABEL_51;
            }
LABEL_50:
            (*(void (**)(char *, char *, unint64_t *))(v620 + 16))(v123, v125, v69);
            uint64_t v201 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
            v136(v123, v69);
            if ((v201 & 0x8000000000000000LL) == 0) {
              goto LABEL_51;
            }
            goto LABEL_107;
          }

          if (v193 <= 64)
          {
            int64_t v225 = v611;
            int64_t v226 = v609;
            unint64_t v227 = swift_getAssociatedConformanceWitness( (uint64_t)v611,  (uint64_t)v69,  (uint64_t)v609,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            unint64_t v228 = v610;
            (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v227 + 8))( &qword_18180BE68,  256LL,  v226,  v227);
            (*((void (**)(uint64_t (*)(void), unint64_t *, const char *))v225 + 3))( v228,  v69,  v225);
            LOBYTE(v225) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                         + 16LL))( v125,  v123,  v69);
            v136(v123, v69);
            unint64_t v229 = v569;
            (*(void (**)(char *, char *, unint64_t *))(v620 + 16))(v569, v125, v69);
            if ((v225 & 1) != 0)
            {
              v136(v229, v69);
              uint64_t v171 = (char *)v617;
            }

            else
            {
              uint64_t v264 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
              v136(v229, v69);
              uint64_t v171 = (char *)v617;
              if ((v264 & 0x8000000000000000LL) == 0)
              {
LABEL_51:
                char v202 = v589;
                (*(void (**)(void))(v620 + 32))();
                if ((((uint64_t (*)(unint64_t *, unint64_t))v171)(v69, v67) & 1) != 0)
                {
                  uint64_t v203 = v579;
                  (*(void (**)(char *, void (*)(char *, unint64_t *), unint64_t *))(v620 + 16))( v579,  v202,  v69);
                  char v204 = v611;
                  uint64_t v205 = v609;
                  unint64_t v206 = swift_getAssociatedConformanceWitness( (uint64_t)v611,  (uint64_t)v69,  (uint64_t)v609,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  uint64_t v207 = v610;
                  (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v206 + 8))( &qword_18180BE68,  256LL,  v205,  v206);
                  (*((void (**)(uint64_t (*)(void), unint64_t *, const char *))v204 + 3))( v207,  v69,  v204);
                  LOBYTE(v204) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                               + 32LL))( v203,  v123,  v69);
                  v136(v123, v69);
                  v136(v203, v69);
                  uint64_t v171 = (char *)v617;
                }

                if (((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67) < 64)
                {
LABEL_125:
                  uint64_t v236 = (uint64_t)v603;
                  unint64_t v290 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
                  v136((char *)v202, v69);
                  int64_t v291 = (uint64_t (*)(void))(v290 + 1023);
                  if (v290 >= 0xFFFFFFFFFFFFFC01LL)
                  {
                    __break(1u);
                    goto LABEL_127;
                  }

                  goto LABEL_196;
                }

                uint64_t v208 = v171;
                uint64_t v209 = *(void (**)(char *, void (*)(void, void), unint64_t *))(v620 + 16);
                uint64_t v171 = v588;
                v209(v588, (void (*)(void, void))v202, v69);
                unint64_t v624 = -1LL;
                LOBYTE(v208) = ((uint64_t (*)(unint64_t *, unint64_t))v208)(v69, v67);
                uint64_t v210 = ((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67);
                if ((v208 & 1) != 0)
                {
                  if (v210 <= 64)
                  {
                    char v213 = v611;
                    char v214 = v609;
                    unint64_t v215 = swift_getAssociatedConformanceWitness( (uint64_t)v611,  (uint64_t)v69,  (uint64_t)v609,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    uint64_t v216 = v610;
                    (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v215 + 8))( &qword_18180BE68,  256LL,  v214,  v215);
                    (*((void (**)(uint64_t (*)(void), unint64_t *, const char *))v213 + 3))( v216,  v69,  v213);
                    unint64_t v130 = v588;
                    LOBYTE(v213) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                                 + 40LL))( v588,  v123,  v69);
                    v136(v123, v69);
                    unint64_t v217 = v624;
                    uint64_t v218 = v565;
                    v209(v565, (void (*)(void, void))v130, v69);
                    if ((v213 & 1) != 0)
                    {
                      unint64_t v219 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
                      v136(v218, v69);
                      BOOL v453 = v217 >= v219;
                      char v202 = v589;
                      if (!v453) {
                        goto LABEL_228;
                      }
                    }

                    else
                    {
                      v136(v218, v69);
                      char v202 = v589;
                    }

                    goto LABEL_124;
                  }
                }

                else if (v210 <= 64)
                {
                  unint64_t v130 = v588;
                  v209(v123, (void (*)(void, void))v588, v69);
                  unint64_t v263 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
                  v136(v123, v69);
                  if (v624 < v263) {
                    goto LABEL_228;
                  }
LABEL_124:
                  v136(v130, v69);
                  goto LABEL_125;
                }

                uint64_t v223 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
                unint64_t v224 = lazy protocol witness table accessor for type UInt and conformance UInt(v210, v211, v212);
                v223(&v624, &type metadata for UInt, v224, v69, v67);
                unint64_t v130 = v588;
                LOBYTE(v223) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                             + 16LL))( v123,  v588,  v69);
                v136(v123, v69);
                goto LABEL_124;
              }
            }

LABEL_107:
            unint64_t v265 = v585;
            (*(void (**)(char *, unint64_t *))(*(void *)(AssociatedConformanceWitness + 16) + 16LL))( v125,  v69);
            Swift::String::Index v266 = v125;
            Swift::Int v267 = v265;
            v136(v266, v69);
            if ((((uint64_t (*)(unint64_t *, unint64_t))v171)(v69, v67) & 1) != 0)
            {
              unint64_t v268 = v572;
              (*(void (**)(char *, char *, unint64_t *))(v620 + 16))(v572, v265, v69);
              uint64_t v269 = v611;
              uint64_t v270 = v609;
              unint64_t v271 = swift_getAssociatedConformanceWitness( (uint64_t)v611,  (uint64_t)v69,  (uint64_t)v609,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              char v272 = v610;
              (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v271 + 8))( &qword_18180BE68,  256LL,  v270,  v271);
              (*((void (**)(uint64_t (*)(void), unint64_t *, const char *))v269 + 3))( v272,  v69,  v269);
              LOBYTE(v269) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                           + 32LL))( v268,  v123,  v69);
              v136(v123, v69);
              v136(v268, v69);
              uint64_t v171 = (char *)v617;
            }

            if (((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67) < 64)
            {
LABEL_195:
              uint64_t v236 = (uint64_t)v603;
              unint64_t v401 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
              v136(v267, v69);
              int64_t v291 = (uint64_t (*)(void))(1023 - v401);
              if (v401 > 0x3FF)
              {
                __break(1u);
                goto LABEL_276;
              }

                          __break(1u);
LABEL_108:
                          __break(1u);
LABEL_109:
                          __break(1u);
LABEL_110:
                          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
                        }

                        uint64_t v78 = v126 + 3;
                      }
                    }

  uint64_t v49 = __OFADD__(v30, v110);
  v30 += v110;
  if (v49) {
    goto LABEL_321;
  }
LABEL_108:
  if ((v10 & ~v7 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v30 >= 16)
    {
      v304 = v48;
      uint64_t v111 = v310;
      uint64_t v7 = v311;
      goto LABEL_117;
    }

    uint64_t v10 = v311;
    if ((v311 & 0x2000000000000000LL) == 0)
    {
      uint64_t v7 = v311;
LABEL_140:
      unint64_t v123 = 1;
      goto LABEL_159;
    }

    unint64_t v123 = 0;
    uint64_t v7 = v311;
    goto LABEL_159;
  }

  v304 = v48;
  uint64_t v111 = v310;
  uint64_t v7 = v311;
  uint64_t v112 = _StringGuts.nativeUnusedCapacity.getter(v310, v311);
  if ((v113 & 1) != 0)
  {
LABEL_336:
    uint64_t v293 = 258LL;
    goto LABEL_337;
  }

  if (v30 < 16)
  {
    if ((v7 & 0x2000000000000000LL) == 0)
    {
      uint64_t v10 = v7;
      if (v112 < v110) {
        goto LABEL_140;
      }
      goto LABEL_117;
    }

    unint64_t v123 = 0;
    uint64_t v10 = v7;
LABEL_159:
    swift_bridgeObjectRelease_n(v19, 5LL);
    uint64_t v110 = v310;
    uint64_t v22 = v303;
    if (v123) {
      goto LABEL_322;
    }
    goto LABEL_160;
  }

      _StringGuts._foreignAppendInPlace(_:)(a1, a2, 0LL, v105);
      a1 = v110;
      a2 = v111;
      double v4 = v107;
      goto LABEL_108;
    }

    uint64_t v89 = _StringGuts.nativeUnusedCapacity.getter(v7, v13);
    uint64_t v91 = (v90 & 1) != 0 || v89 < (uint64_t)v17;
    uint64_t v92 = !v91;
    if ((v86 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v12 = v85;
      double v5 = v197;
      if (v92) {
        goto LABEL_145;
      }
    }

    else
    {
      uint64_t v12 = v85;
      double v5 = v197;
      if (v92) {
        goto LABEL_144;
      }
    }

    uint64_t v120 = _StringGuts.nativeCapacity.getter(v7, v13);
    uint64_t v122 = (v121 & 1) != 0 ? 0LL : v120;
    if (v122 + 0x4000000000000000LL >= 0) {
      break;
    }
    __break(1u);
  }

  unint64_t v123 = 2 * v122;
  if (v123 > v84) {
    uint64_t v84 = v123;
  }
LABEL_144:
  _StringGuts.grow(_:)(v84);
LABEL_145:
  swift_bridgeObjectRelease_n(v4, 4LL);
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v4);
    _StringGuts._foreignAppendInPlace(_:)(v5, v4, 0LL, v12);
  }

  else
  {
    if (v15)
    {
      swift_bridgeObjectRelease_n(v4, 2LL);
      *(void *)&unint64_t v198 = v5;
      *((void *)&v198 + 1) = v4 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v124 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v4) & 0xF,  (uint64_t)&v198,  HIBYTE(v4) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v124, v125, (v4 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v4);
      goto LABEL_171;
    }

    if ((v5 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v4);
      uint64_t v140 = (id)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      int v141 = v196;
      unint64_t v142 = v196;
    }

    else
    {
      uint64_t v140 = _StringObject.sharedUTF8.getter(v5, v4);
      unint64_t v142 = v189;
      swift_bridgeObjectRelease(v4);
      if (v142 < v196) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }
      int v141 = v196;
      double v5 = v197;
    }

    int v143 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v141, (uint64_t)v140, v142);
    _StringGuts.appendInPlace(_:isASCII:)(v143, v144, v5 < 0);
  }

  swift_bridgeObjectRelease_n(v4, 2LL);
  while (1)
  {
LABEL_171:
    uint64_t v13 = v199;
    double v4 = v200;
    double v5 = HIBYTE(v200) & 0xF;
    if ((v200 & 0x2000000000000000LL) != 0) {
      int v146 = HIBYTE(v200) & 0xF;
    }
    else {
      int v146 = v199 & 0xFFFFFFFFFFFFLL;
    }
    if (!v146 && (v199 & ~v200 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v200);
      return 41LL;
    }

    if ((v200 & 0x2000000000000000LL) != 0 && v5 != 15) {
      break;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v116, v117);
    if ((v4 & 0x1000000000000000LL) != 0)
    {
LABEL_214:
      unint64_t v182 = String.UTF8View._foreignCount()();
      uint64_t v7 = v182 + 1;
      if (!__OFADD__(v182, 1LL))
      {
LABEL_183:
        if ((v13 & ~v4 & 0x2000000000000000LL) == 0
          || !swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v7 <= 15) {
            goto LABEL_194;
          }
          goto LABEL_199;
        }

        uint64_t v147 = _StringGuts.nativeUnusedCapacity.getter(v13, v4);
        if ((v148 & 1) == 0)
        {
          unint64_t v150 = (v4 & 0x2000000000000000LL) == 0 && v147 > 0;
          if (v7 <= 15 && !v150)
          {
LABEL_194:
            swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
            swift_bridgeObjectRetain(v4, v151, v152, v153);
            int64_t v154 = _StringGuts._convertedToSmall()(v13, v4);
            unint64_t v156 = v155;
            swift_bridgeObjectRelease(v4);
            v157._Swift::UInt64 rawBits = 1LL;
            v158._Swift::UInt64 rawBits = 65537LL;
            v159._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v157, v158, 0x29uLL, 0xE100000000000000LL);
            if (v159._rawBits < 0x10000) {
              v159._rawBits |= 3;
            }
            uint64_t v161 = specialized String.init(_:)(v159, v160, 0x29uLL, 0xE100000000000000LL);
            BOOL v163 = v162;
            swift_bridgeObjectRelease(0xE100000000000000LL);
            uint64_t v164 = _StringGuts._convertedToSmall()(v161, v163);
            char v166 = v165;
            swift_bridgeObjectRelease(v163);
            uint64_t v167 = specialized _SmallString.init(_:appending:)(v154, v156, v164, v166);
            if ((v168 & 1) == 0)
            {
              uint64_t v13 = v167;
              swift_bridgeObjectRelease(v4);
              swift_bridgeObjectRelease(0xE100000000000000LL);
              return v13;
            }

      uint64_t v122 = v76 - 8;
      unint64_t v123 = 8LL;
      if (v76 < 8) {
        unint64_t v123 = v76;
      }
      if ((v123 & 0x8000000000000000LL) == 0)
      {
        if (v123 >= 8)
        {
          if (v123 >= 0x10)
          {
            uint64_t v124 = v123 & 0xFFFFFFFFFFFFFFF0LL;
            unsigned __int8 v149 = vmovl_high_u8(*TypeName);
            unint64_t v150 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v149.i8);
            unint64_t v151 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            uint64_t v152 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v151.i8);
            unint64_t v153 = (int8x16_t)vmovl_high_u16(v149);
            int64_t v154 = (int8x8_t)vextq_s8(v153, v153, 8uLL).u64[0];
            uint64_t v155 = (int8x16_t)vmovl_high_u16(v151);
            unint64_t v156 = (int8x8_t)vextq_s8(v155, v155, 8uLL).u64[0];
            *(int8x8_t *)v155.i8 = vorr_s8(*(int8x8_t *)v155.i8, *(int8x8_t *)v153.i8);
            v157.i64[0] = v155.u32[0];
            v157.i64[1] = v155.u32[1];
            unint64_t v158 = (int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1817FFCE0);
            *(int8x8_t *)v153.i8 = vorr_s8(*(int8x8_t *)v152.i8, *(int8x8_t *)v150.i8);
            v157.i64[0] = v153.u32[0];
            v157.i64[1] = v153.u32[1];
            uint64_t v159 = vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1817FFCD0), v158);
            *(int8x8_t *)v153.i8 = vorr_s8(v156, v154);
            v157.i64[0] = v153.u32[0];
            v157.i64[1] = v153.u32[1];
            unint64_t v160 = (int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1817FFCC0);
            *(int8x8_t *)v150.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v152, v152, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v150, v150, 8uLL));
            v157.i64[0] = v150.u32[0];
            v157.i64[1] = v150.u32[1];
            uint64_t v161 = vorrq_s8(v159, vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1817FFCB0), v160));
            uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v161.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v161, v161, 8uLL));
            if (v123 == (v123 & 0xFFFFFFFFFFFFFFF0LL)) {
              goto LABEL_124;
            }
            uint64_t v125 = 8 * v124;
            if ((v123 & 8) == 0) {
              goto LABEL_122;
            }
          }

          else
          {
            uint64_t countAndFlagsBits = 0LL;
            uint64_t v125 = 0LL;
            uint64_t v124 = 0LL;
          }

          char v126 = v124;
          uint64_t v127 = vdupq_n_s64(v125);
          uint64_t v124 = v123 & 0xFFFFFFFFFFFFFFF8LL;
          uint64_t v125 = 8 * (v123 & 0xFFFFFFFFFFFFFFF8LL);
          __int16 v128 = 0uLL;
          char v129 = (int8x16_t)(unint64_t)countAndFlagsBits;
          unint64_t v130 = vaddq_s64(v127, (int64x2_t)xmmword_1817FFCC0);
          uint64_t v131 = vaddq_s64(v127, (int64x2_t)xmmword_1817FFCE0);
          uint64_t v132 = vaddq_s64(v127, (int64x2_t)xmmword_1817FFCB0);
          uint64_t v133 = vaddq_s64(v127, (int64x2_t)xmmword_1817FFCD0);
          unint64_t v134 = (uint8x8_t *)&TypeName->i8[v126];
          uint64_t v135 = (int8x16_t)vdupq_n_s64(0x38uLL);
          unint64_t v136 = v126 - (v123 & 0xFFFFFFFFFFFFFFF8LL);
          char v137 = vdupq_n_s64(0x40uLL);
          uint64_t v138 = 0uLL;
          uint64_t v139 = 0uLL;
          do
          {
            uint64_t v140 = *v134++;
            int v141 = vmovl_u8(v140);
            unint64_t v142 = vmovl_high_u16(v141);
            v143.i64[0] = v142.u32[2];
            v143.i64[1] = v142.u32[3];
            unint64_t v144 = v143;
            v143.i64[0] = v142.u32[0];
            v143.i64[1] = v142.u32[1];
            unint64_t v145 = v143;
            int v146 = vmovl_u16(*(uint16x4_t *)v141.i8);
            v143.i64[0] = v146.u32[2];
            v143.i64[1] = v146.u32[3];
            uint64_t v147 = v143;
            v143.i64[0] = v146.u32[0];
            v143.i64[1] = v146.u32[1];
            uint64_t v139 = vorrq_s8((int8x16_t)vshlq_u64(v144, (uint64x2_t)vandq_s8((int8x16_t)v130, v135)), v139);
            uint64_t v138 = vorrq_s8((int8x16_t)vshlq_u64(v145, (uint64x2_t)vandq_s8((int8x16_t)v131, v135)), v138);
            __int16 v128 = vorrq_s8((int8x16_t)vshlq_u64(v147, (uint64x2_t)vandq_s8((int8x16_t)v132, v135)), v128);
            char v129 = vorrq_s8((int8x16_t)vshlq_u64(v143, (uint64x2_t)vandq_s8((int8x16_t)v133, v135)), v129);
            uint64_t v131 = vaddq_s64(v131, v137);
            uint64_t v132 = vaddq_s64(v132, v137);
            uint64_t v133 = vaddq_s64(v133, v137);
            unint64_t v130 = vaddq_s64(v130, v137);
            v136 += 8LL;
          }

          while (v136);
          BOOL v148 = vorrq_s8(vorrq_s8(v129, v138), vorrq_s8(v128, v139));
          uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v148.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v148, v148, 8uLL));
          if (v123 == v124)
          {
LABEL_124:
            if (v76 < 9)
            {
              char v166 = 0LL;
LABEL_140:
              unint64_t v230 = 0xA000000000000000LL;
              if (((*(void *)&v166 | countAndFlagsBits) & 0x8080808080808080LL) == 0) {
                unint64_t v230 = 0xE000000000000000LL;
              }
              unint64_t object = v230 | (v76 << 56) | *(void *)&v166;
              goto LABEL_143;
            }

            if (v122 < 8)
            {
              uint64_t v165 = 0LL;
              char v166 = 0LL;
              uint64_t v167 = 0LL;
LABEL_138:
              unint64_t v227 = v76 - v165 - 8;
              unint64_t v228 = &TypeName->u8[v165 + 8];
              do
              {
                unint64_t v229 = *v228++;
                *(void *)&v166 |= (unint64_t)v229 << (v167 & 0x38);
                v167 += 8LL;
                --v227;
              }

              while (v227);
              goto LABEL_140;
            }

            if (v122 >= 0x10)
            {
              uint64_t v191 = (uint8x16_t *)&TypeName->u64[1];
              uint64_t v165 = v122 & 0xFFFFFFFFFFFFFFF0LL;
              unint64_t v192 = (int64x2_t)xmmword_1817FFD60;
              uint64_t v193 = (int64x2_t)xmmword_1817FFD70;
              uint64_t v194 = (int64x2_t)xmmword_1817FFD80;
              uint64_t v195 = (int64x2_t)xmmword_1817FFD90;
              char v196 = (int64x2_t)xmmword_1817FFCC0;
              unint64_t v197 = (int64x2_t)xmmword_1817FFCE0;
              unint64_t v198 = (int8x16_t)vdupq_n_s64(0x38uLL);
              uint64_t v199 = vdupq_n_s64(0x80uLL);
              uint64_t v200 = (int64x2_t)xmmword_1817FFCB0;
              uint64_t v167 = 8 * (v122 & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v201 = 0uLL;
              char v202 = 0uLL;
              uint64_t v203 = (int64x2_t)xmmword_1817FFCD0;
              char v204 = v122 & 0xFFFFFFFFFFFFFFF0LL;
              uint64_t v205 = 0uLL;
              unint64_t v206 = 0uLL;
              uint64_t v207 = 0uLL;
              uint64_t v208 = 0uLL;
              uint64_t v209 = 0uLL;
              uint64_t v210 = 0uLL;
              do
              {
                uint64_t v211 = *v191++;
                uint64_t v212 = vmovl_u8(*(uint8x8_t *)v211.i8);
                char v213 = vmovl_high_u16(v212);
                v214.i64[0] = v213.u32[2];
                v214.i64[1] = v213.u32[3];
                unint64_t v215 = v214;
                uint64_t v216 = vmovl_high_u8(v211);
                unint64_t v217 = vmovl_u16(*(uint16x4_t *)v216.i8);
                v214.i64[0] = v217.u32[2];
                v214.i64[1] = v217.u32[3];
                uint64_t v218 = v214;
                v214.i64[0] = v217.u32[0];
                v214.i64[1] = v217.u32[1];
                unint64_t v219 = v214;
                v214.i64[0] = v213.u32[0];
                v214.i64[1] = v213.u32[1];
                uint64_t v220 = v214;
                char v221 = vmovl_u16(*(uint16x4_t *)v212.i8);
                v214.i64[0] = v221.u32[2];
                v214.i64[1] = v221.u32[3];
                int64_t v222 = v214;
                uint64_t v223 = vmovl_high_u16(v216);
                v214.i64[0] = v223.u32[0];
                v214.i64[1] = v223.u32[1];
                unint64_t v224 = v214;
                v214.i64[0] = v221.u32[0];
                v214.i64[1] = v221.u32[1];
                int64_t v225 = v214;
                v214.i64[0] = v223.u32[2];
                v214.i64[1] = v223.u32[3];
                unint64_t v206 = vorrq_s8((int8x16_t)vshlq_u64(v215, (uint64x2_t)vandq_s8((int8x16_t)v196, v198)), v206);
                uint64_t v208 = vorrq_s8((int8x16_t)vshlq_u64(v218, (uint64x2_t)vandq_s8((int8x16_t)v194, v198)), v208);
                uint64_t v207 = vorrq_s8((int8x16_t)vshlq_u64(v219, (uint64x2_t)vandq_s8((int8x16_t)v195, v198)), v207);
                uint64_t v205 = vorrq_s8((int8x16_t)vshlq_u64(v220, (uint64x2_t)vandq_s8((int8x16_t)v197, v198)), v205);
                char v202 = vorrq_s8((int8x16_t)vshlq_u64(v222, (uint64x2_t)vandq_s8((int8x16_t)v200, v198)), v202);
                uint64_t v209 = vorrq_s8((int8x16_t)vshlq_u64(v224, (uint64x2_t)vandq_s8((int8x16_t)v193, v198)), v209);
                uint64_t v201 = vorrq_s8((int8x16_t)vshlq_u64(v225, (uint64x2_t)vandq_s8((int8x16_t)v203, v198)), v201);
                uint64_t v210 = vorrq_s8((int8x16_t)vshlq_u64(v214, (uint64x2_t)vandq_s8((int8x16_t)v192, v198)), v210);
                unint64_t v197 = vaddq_s64(v197, v199);
                uint64_t v200 = vaddq_s64(v200, v199);
                uint64_t v203 = vaddq_s64(v203, v199);
                char v196 = vaddq_s64(v196, v199);
                uint64_t v195 = vaddq_s64(v195, v199);
                uint64_t v194 = vaddq_s64(v194, v199);
                uint64_t v193 = vaddq_s64(v193, v199);
                unint64_t v192 = vaddq_s64(v192, v199);
                v204 -= 16LL;
              }

              while (v204);
              int64_t v226 = vorrq_s8( vorrq_s8(vorrq_s8(v201, v207), vorrq_s8(v205, v209)),  vorrq_s8(vorrq_s8(v202, v208), vorrq_s8(v206, v210)));
              char v166 = vorr_s8(*(int8x8_t *)v226.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v226, v226, 8uLL));
              if (v122 == v165) {
                goto LABEL_140;
              }
              if ((v122 & 8) == 0) {
                goto LABEL_138;
              }
            }

            else
            {
              char v166 = 0LL;
              uint64_t v167 = 0LL;
              uint64_t v165 = 0LL;
            }

            uint64_t v168 = v165;
            uint64_t v165 = v122 & 0xFFFFFFFFFFFFFFF8LL;
            uint64_t v169 = vdupq_n_s64(v167);
            uint64_t v167 = 8 * (v122 & 0xFFFFFFFFFFFFFFF8LL);
            uint64_t v170 = (int8x16_t)(unint64_t)v166;
            uint64_t v171 = 0uLL;
            char v172 = vaddq_s64(v169, (int64x2_t)xmmword_1817FFCC0);
            uint64_t v173 = vaddq_s64(v169, (int64x2_t)xmmword_1817FFCE0);
            uint64_t v174 = vaddq_s64(v169, (int64x2_t)xmmword_1817FFCB0);
            uint64_t v175 = vaddq_s64(v169, (int64x2_t)xmmword_1817FFCD0);
            __int128 v176 = (uint8x8_t *)((char *)&TypeName->u64[1] + v168);
            unint64_t v177 = (int8x16_t)vdupq_n_s64(0x38uLL);
            char v178 = v168 - (v122 & 0xFFFFFFFFFFFFFFF8LL);
            char v179 = vdupq_n_s64(0x40uLL);
            uint64_t v180 = 0uLL;
            char v181 = 0uLL;
            do
            {
              unint64_t v182 = *v176++;
              char v183 = vmovl_u8(v182);
              uint64_t v184 = vmovl_high_u16(v183);
              v185.i64[0] = v184.u32[2];
              v185.i64[1] = v184.u32[3];
              unint64_t v186 = v185;
              v185.i64[0] = v184.u32[0];
              v185.i64[1] = v184.u32[1];
              uint64_t v187 = v185;
              uint64_t v188 = vmovl_u16(*(uint16x4_t *)v183.i8);
              v185.i64[0] = v188.u32[2];
              v185.i64[1] = v188.u32[3];
              unint64_t v189 = v185;
              v185.i64[0] = v188.u32[0];
              v185.i64[1] = v188.u32[1];
              char v181 = vorrq_s8((int8x16_t)vshlq_u64(v186, (uint64x2_t)vandq_s8((int8x16_t)v172, v177)), v181);
              uint64_t v180 = vorrq_s8((int8x16_t)vshlq_u64(v187, (uint64x2_t)vandq_s8((int8x16_t)v173, v177)), v180);
              uint64_t v171 = vorrq_s8((int8x16_t)vshlq_u64(v189, (uint64x2_t)vandq_s8((int8x16_t)v174, v177)), v171);
              uint64_t v170 = vorrq_s8((int8x16_t)vshlq_u64(v185, (uint64x2_t)vandq_s8((int8x16_t)v175, v177)), v170);
              uint64_t v173 = vaddq_s64(v173, v179);
              uint64_t v174 = vaddq_s64(v174, v179);
              uint64_t v175 = vaddq_s64(v175, v179);
              char v172 = vaddq_s64(v172, v179);
              v178 += 8LL;
            }

            while (v178);
            uint64_t v190 = vorrq_s8(vorrq_s8(v170, v180), vorrq_s8(v171, v181));
            char v166 = vorr_s8(*(int8x8_t *)v190.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v190, v190, 8uLL));
            if (v122 == v165) {
              goto LABEL_140;
            }
            goto LABEL_138;
          }
        }

        else
        {
          uint64_t v124 = 0LL;
          uint64_t countAndFlagsBits = 0LL;
          uint64_t v125 = 0LL;
        }

        uint64_t v64 = 16LL;
        if (a7)
        {
          uint64_t v64 = 32LL;
          uint64_t v50 = 2LL;
        }

        else
        {
          uint64_t v50 = 1LL;
        }

        (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(a4 - 8) + v64))(a1, a3, a4);
        break;
    }
  }

  if (v74 != v76) {
    free(v74);
  }
  if (v77 != v79) {
    free(v77);
  }
  return v50;
}

LABEL_276:
              __break(1u);
              goto LABEL_277;
            }

            uint64_t v273 = v171;
            uint64_t v171 = *(char **)(v620 + 16);
            ((void (*)(char *, char *, unint64_t *))v171)(v583, v267, v69);
            unint64_t v624 = -1LL;
            LOBYTE(v273) = ((uint64_t (*)(unint64_t *, unint64_t))v273)(v69, v67);
            uint64_t v274 = ((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67);
            if ((v273 & 1) != 0)
            {
              if (v274 <= 64)
              {
                uint64_t v277 = v611;
                uint64_t v278 = v609;
                unint64_t v279 = swift_getAssociatedConformanceWitness( (uint64_t)v611,  (uint64_t)v69,  (uint64_t)v609,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                uint64_t v280 = v610;
                (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v279 + 8))( &qword_18180BE68,  256LL,  v278,  v279);
                (*((void (**)(uint64_t (*)(void), unint64_t *, const char *))v277 + 3))( v280,  v69,  v277);
                unint64_t v281 = v583;
                LOBYTE(v277) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                             + 40LL))( v583,  v123,  v69);
                v136(v123, v69);
                unint64_t v282 = v624;
                uint64_t v283 = v563;
                ((void (*)(char *, char *, unint64_t *))v171)(v563, v281, v69);
                if ((v277 & 1) != 0)
                {
                  unint64_t v284 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
                  v136(v283, v69);
                  BOOL v453 = v282 >= v284;
                  Swift::Int v267 = v585;
                  if (!v453) {
                    goto LABEL_228;
                  }
                }

                else
                {
                  v136(v283, v69);
                  Swift::Int v267 = v585;
                }

                goto LABEL_194;
              }
            }

            else if (v274 <= 64)
            {
              unint64_t v281 = v583;
              ((void (*)(char *, char *, unint64_t *))v171)(v123, v583, v69);
              unint64_t v289 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
              v136(v123, v69);
              if (v624 < v289) {
                goto LABEL_228;
              }
LABEL_194:
              v136(v281, v69);
              goto LABEL_195;
            }

            uint64_t v285 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
            unint64_t v286 = lazy protocol witness table accessor for type UInt and conformance UInt(v274, v275, v276);
            v285(&v624, &type metadata for UInt, v286, v69, v67);
            unint64_t v281 = v583;
            LOBYTE(v285) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                         + 16LL))( v123,  v583,  v69);
            v136(v123, v69);
            goto LABEL_194;
          }
        }

        unint64_t v624 = 0LL;
        unint64_t v197 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
        unint64_t v198 = lazy protocol witness table accessor for type Int and conformance Int(v193, v194, v195);
        v197(&v624, &type metadata for Int, v198, v69, v67);
        LOBYTE(v197) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v125,  v123,  v69);
        v136(v123, v69);
        goto LABEL_107;
      }

      goto LABEL_30;
    }

    (*(void (**)(char *, char *, unint64_t *))(v620 + 16))(v123, v125, v69);
    uint64_t v180 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
    v136(v123, v69);
LABEL_30:
    v136(v125, v69);
    if (((*((uint64_t (**)(uint64_t))v616 + 21))(v621) & 1) != 0)
    {
      uint64_t result = 0LL;
      unint64_t v182 = 0xFFF0000000000000LL;
    }

    else
    {
      uint64_t result = 0LL;
      unint64_t v182 = 0x7FF0000000000000LL;
    }

LABEL_142:
    unint64_t v307 = 3687LL;
    goto LABEL_229;
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  uint64_t v27 = HIBYTE(a2) & 0xF;
  v99[0] = a1;
  v99[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v27) {
    goto LABEL_142;
  }
  if (a1 == 43)
  {
    uint64_t v8 = 1;
    uint64_t v70 = specialized Collection.subscript.getter(1LL, (uint64_t)v99, v27);
    uint64_t v74 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v70, v71, v72, v73);
    if (!v75) {
      goto LABEL_144;
    }
    uint64_t v76 = a3 + 55;
    uint64_t v77 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v78 = 58;
    }

    else
    {
      uint64_t v77 = 97;
      uint64_t v76 = 65;
      uint64_t v78 = a3 + 48;
    }

    if (v74)
    {
      uint64_t v79 = 0;
      do
      {
        uint64_t v80 = *v74;
        if (v80 < 0x30 || v80 >= v78)
        {
          if (v80 < 0x41 || v80 >= v76)
          {
            uint64_t v21 = 0;
            uint64_t v8 = 1;
            if (v80 < 0x61 || v80 >= v77) {
              goto LABEL_118;
            }
            uint64_t v81 = -87;
          }

          else
          {
            uint64_t v81 = -55;
          }
        }

        else
        {
          uint64_t v81 = -48;
        }

        uint64_t v21 = 0;
        uint64_t v82 = v80 + v81;
        uint64_t v83 = v79 * (unint64_t)a3;
        uint64_t v84 = (v83 & 0xFFFFFFFF00000000LL) != 0;
        uint64_t v25 = __CFADD__((_DWORD)v83, v82);
        uint64_t v79 = v83 + v82;
        uint64_t v85 = v25;
        uint64_t v8 = 1;
        if (v84) {
          break;
        }
        if ((v85 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v74;
        uint64_t v21 = v79;
        --v75;
      }

      while (v75);
      goto LABEL_118;
    }
  }

  else
  {
    if (a1 != 45)
    {
      uint64_t v87 = 0;
      uint64_t v88 = a3 + 55;
      uint64_t v89 = a3 + 87;
      if (a3 > 10)
      {
        uint64_t v90 = 58;
      }

      else
      {
        uint64_t v89 = 97;
        uint64_t v88 = 65;
        uint64_t v90 = a3 + 48;
      }

      uint64_t v91 = (unsigned __int8 *)v99;
      do
      {
        uint64_t v92 = *v91;
        if (v92 < 0x30 || v92 >= v90)
        {
          if (v92 < 0x41 || v92 >= v88)
          {
            uint64_t v21 = 0;
            uint64_t v8 = 1;
            if (v92 < 0x61 || v92 >= v89) {
              goto LABEL_118;
            }
            uint64_t v93 = -87;
          }

          else
          {
            uint64_t v93 = -55;
          }
        }

        else
        {
          uint64_t v93 = -48;
        }

        uint64_t v21 = 0;
        uint64_t v94 = v92 + v93;
        uint64_t v95 = v87 * (unint64_t)a3;
        uint64_t v96 = (v95 & 0xFFFFFFFF00000000LL) != 0;
        uint64_t v25 = __CFADD__((_DWORD)v95, v94);
        uint64_t v87 = v95 + v94;
        uint64_t v97 = v25;
        uint64_t v8 = 1;
        if (v96) {
          break;
        }
        if ((v97 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v91;
        uint64_t v21 = v87;
        --v27;
      }

      while (v27);
      goto LABEL_118;
    }

    uint64_t v8 = 1;
    uint64_t v28 = specialized Collection.subscript.getter(1LL, (uint64_t)v99, v27);
    uint64_t v32 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v28, v29, v30, v31);
    if (!v33) {
      goto LABEL_143;
    }
    uint64_t v34 = a3 + 55;
    uint64_t v35 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v36 = 58;
    }

    else
    {
      uint64_t v35 = 97;
      uint64_t v34 = 65;
      uint64_t v36 = a3 + 48;
    }

    if (v32)
    {
      uint64_t v37 = 0;
      do
      {
        uint64_t v38 = *v32;
        if (v38 < 0x30 || v38 >= v36)
        {
          if (v38 < 0x41 || v38 >= v34)
          {
            uint64_t v21 = 0;
            uint64_t v8 = 1;
            if (v38 < 0x61 || v38 >= v35) {
              goto LABEL_118;
            }
            uint64_t v39 = -87;
          }

          else
          {
            uint64_t v39 = -55;
          }
        }

        else
        {
          uint64_t v39 = -48;
        }

        uint64_t v21 = 0;
        uint64_t v40 = v38 + v39;
        uint64_t v41 = v37 * (unint64_t)a3;
        uint64_t v42 = (v41 & 0xFFFFFFFF00000000LL) != 0;
        uint64_t v25 = v41 >= v40;
        uint64_t v37 = v41 - v40;
        uint64_t v43 = !v25;
        uint64_t v8 = 1;
        if (v42) {
          break;
        }
        if ((v43 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v32;
        uint64_t v21 = v37;
        --v33;
      }

      while (v33);
      goto LABEL_118;
    }
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  uint64_t v27 = HIBYTE(a2) & 0xF;
  v99[0] = a1;
  v99[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v27) {
    goto LABEL_142;
  }
  if (a1 == 43)
  {
    uint64_t v8 = 1;
    uint64_t v70 = specialized Collection.subscript.getter(1LL, (uint64_t)v99, v27);
    uint64_t v74 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v70, v71, v72, v73);
    if (!v75) {
      goto LABEL_144;
    }
    uint64_t v76 = a3 + 55;
    uint64_t v77 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v78 = 58;
    }

    else
    {
      uint64_t v77 = 97;
      uint64_t v76 = 65;
      uint64_t v78 = a3 + 48;
    }

    if (v74)
    {
      uint64_t v79 = 0;
      do
      {
        uint64_t v80 = *v74;
        if (v80 < 0x30 || v80 >= v78)
        {
          if (v80 < 0x41 || v80 >= v76)
          {
            uint64_t v21 = 0;
            uint64_t v8 = 1;
            if (v80 < 0x61 || v80 >= v77) {
              goto LABEL_118;
            }
            uint64_t v81 = -87;
          }

          else
          {
            uint64_t v81 = -55;
          }
        }

        else
        {
          uint64_t v81 = -48;
        }

        uint64_t v21 = 0;
        uint64_t v82 = v80 + v81;
        uint64_t v83 = (int)v79 * (uint64_t)(int)a3;
        uint64_t v84 = v83 != (int)v83;
        uint64_t v25 = __OFADD__((_DWORD)v83, v82);
        uint64_t v79 = v83 + v82;
        uint64_t v85 = v25;
        uint64_t v8 = 1;
        if (v84) {
          break;
        }
        if ((v85 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v74;
        uint64_t v21 = v79;
        --v75;
      }

      while (v75);
      goto LABEL_118;
    }
  }

  else
  {
    if (a1 != 45)
    {
      uint64_t v87 = 0;
      uint64_t v88 = a3 + 55;
      uint64_t v89 = a3 + 87;
      if (a3 > 10)
      {
        uint64_t v90 = 58;
      }

      else
      {
        uint64_t v89 = 97;
        uint64_t v88 = 65;
        uint64_t v90 = a3 + 48;
      }

      uint64_t v91 = (unsigned __int8 *)v99;
      do
      {
        uint64_t v92 = *v91;
        if (v92 < 0x30 || v92 >= v90)
        {
          if (v92 < 0x41 || v92 >= v88)
          {
            uint64_t v21 = 0;
            uint64_t v8 = 1;
            if (v92 < 0x61 || v92 >= v89) {
              goto LABEL_118;
            }
            uint64_t v93 = -87;
          }

          else
          {
            uint64_t v93 = -55;
          }
        }

        else
        {
          uint64_t v93 = -48;
        }

        uint64_t v21 = 0;
        uint64_t v94 = v92 + v93;
        uint64_t v95 = (int)v87 * (uint64_t)(int)a3;
        uint64_t v96 = v95 != (int)v95;
        uint64_t v25 = __OFADD__((_DWORD)v95, v94);
        uint64_t v87 = v95 + v94;
        uint64_t v97 = v25;
        uint64_t v8 = 1;
        if (v96) {
          break;
        }
        if ((v97 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v91;
        uint64_t v21 = v87;
        --v27;
      }

      while (v27);
      goto LABEL_118;
    }

    uint64_t v8 = 1;
    uint64_t v28 = specialized Collection.subscript.getter(1LL, (uint64_t)v99, v27);
    uint64_t v32 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v28, v29, v30, v31);
    if (!v33) {
      goto LABEL_143;
    }
    uint64_t v34 = a3 + 55;
    uint64_t v35 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v36 = 58;
    }

    else
    {
      uint64_t v35 = 97;
      uint64_t v34 = 65;
      uint64_t v36 = a3 + 48;
    }

    if (v32)
    {
      uint64_t v37 = 0;
      do
      {
        uint64_t v38 = *v32;
        if (v38 < 0x30 || v38 >= v36)
        {
          if (v38 < 0x41 || v38 >= v34)
          {
            uint64_t v21 = 0;
            uint64_t v8 = 1;
            if (v38 < 0x61 || v38 >= v35) {
              goto LABEL_118;
            }
            uint64_t v39 = -87;
          }

          else
          {
            uint64_t v39 = -55;
          }
        }

        else
        {
          uint64_t v39 = -48;
        }

        uint64_t v21 = 0;
        uint64_t v40 = v38 + v39;
        uint64_t v41 = (int)v37 * (uint64_t)(int)a3;
        uint64_t v42 = v41 != (int)v41;
        uint64_t v25 = __OFSUB__((_DWORD)v41, v40);
        uint64_t v37 = v41 - v40;
        uint64_t v43 = v25;
        uint64_t v8 = 1;
        if (v42) {
          break;
        }
        if ((v43 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v32;
        uint64_t v21 = v37;
        --v33;
      }

      while (v33);
      goto LABEL_118;
    }
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  uint64_t v28 = HIBYTE(a2) & 0xF;
  v102[0] = a1;
  v102[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v28) {
    goto LABEL_142;
  }
  if (a1 == 43)
  {
    uint64_t v8 = 1;
    uint64_t v73 = specialized Collection.subscript.getter(1LL, (uint64_t)v102, v28);
    uint64_t v77 = specialized UnsafeBufferPointer.init(rebasing:)(v73, v74, v75, v76);
    if (!v78) {
      goto LABEL_144;
    }
    uint64_t v79 = (unsigned __int8 *)v77;
    uint64_t v80 = a3 + 48;
    uint64_t v81 = a3 + 55;
    uint64_t v82 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v80 = 58;
    }

    else
    {
      uint64_t v82 = 97;
      uint64_t v81 = 65;
    }

    if (v77)
    {
      uint64_t v83 = 0LL;
      do
      {
        uint64_t v84 = *v79;
        if (v84 < 0x30 || v84 >= v80)
        {
          if (v84 < 0x41 || v84 >= v81)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v84 < 0x61 || v84 >= v82) {
              goto LABEL_118;
            }
            uint64_t v85 = -87;
          }

          else
          {
            uint64_t v85 = -55;
          }
        }

        else
        {
          uint64_t v85 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v86 = v84 + v85;
        uint64_t v87 = !is_mul_ok(v83, a3);
        uint64_t v88 = v83 * a3;
        uint64_t v26 = __CFADD__(v88, v86);
        uint64_t v83 = v88 + v86;
        uint64_t v89 = v26;
        uint64_t v8 = 1;
        if (v87) {
          break;
        }
        if ((v89 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v79;
        uint64_t result = v83;
        --v78;
      }

      while (v78);
      goto LABEL_118;
    }
  }

  else
  {
    if (a1 != 45)
    {
      uint64_t v90 = 0LL;
      uint64_t v91 = a3 + 48;
      uint64_t v92 = a3 + 55;
      uint64_t v93 = a3 + 87;
      if (a3 > 10)
      {
        uint64_t v91 = 58;
      }

      else
      {
        uint64_t v93 = 97;
        uint64_t v92 = 65;
      }

      uint64_t v94 = (unsigned __int8 *)v102;
      do
      {
        uint64_t v95 = *v94;
        if (v95 < 0x30 || v95 >= v91)
        {
          if (v95 < 0x41 || v95 >= v92)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v95 < 0x61 || v95 >= v93) {
              goto LABEL_118;
            }
            uint64_t v96 = -87;
          }

          else
          {
            uint64_t v96 = -55;
          }
        }

        else
        {
          uint64_t v96 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v97 = v95 + v96;
        uint64_t v98 = !is_mul_ok(v90, a3);
        uint64_t v99 = v90 * a3;
        uint64_t v26 = __CFADD__(v99, v97);
        uint64_t v90 = v99 + v97;
        uint64_t v100 = v26;
        uint64_t v8 = 1;
        if (v98) {
          break;
        }
        if ((v100 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v94;
        uint64_t result = v90;
        --v28;
      }

      while (v28);
      goto LABEL_118;
    }

    uint64_t v8 = 1;
    uint64_t v29 = specialized Collection.subscript.getter(1LL, (uint64_t)v102, v28);
    uint64_t v33 = specialized UnsafeBufferPointer.init(rebasing:)(v29, v30, v31, v32);
    if (!v34) {
      goto LABEL_143;
    }
    uint64_t v35 = (unsigned __int8 *)v33;
    uint64_t v36 = a3 + 48;
    uint64_t v37 = a3 + 55;
    uint64_t v38 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v36 = 58;
    }

    else
    {
      uint64_t v38 = 97;
      uint64_t v37 = 65;
    }

    if (v33)
    {
      uint64_t v39 = 0LL;
      do
      {
        uint64_t v40 = *v35;
        if (v40 < 0x30 || v40 >= v36)
        {
          if (v40 < 0x41 || v40 >= v37)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v40 < 0x61 || v40 >= v38) {
              goto LABEL_118;
            }
            uint64_t v41 = -87;
          }

          else
          {
            uint64_t v41 = -55;
          }
        }

        else
        {
          uint64_t v41 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v42 = v40 + v41;
        uint64_t v43 = !is_mul_ok(v39, a3);
        uint64_t v44 = v39 * a3;
        uint64_t v26 = v44 >= v42;
        uint64_t v39 = v44 - v42;
        uint64_t v45 = !v26;
        uint64_t v8 = 1;
        if (v43) {
          break;
        }
        if ((v45 & 1) != 0) {
          break;
        }
        uint64_t v8 = 0;
        ++v35;
        uint64_t result = v39;
        --v34;
      }

      while (v34);
      goto LABEL_118;
    }
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  uint64_t v27 = HIBYTE(a2) & 0xF;
  v101[0] = a1;
  v101[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v27) {
    goto LABEL_142;
  }
  if (a1 == 43)
  {
    uint64_t v8 = 1;
    char v72 = specialized Collection.subscript.getter(1LL, (uint64_t)v101, v27);
    uint64_t v76 = specialized UnsafeBufferPointer.init(rebasing:)(v72, v73, v74, v75);
    if (!v77) {
      goto LABEL_144;
    }
    uint64_t v78 = (unsigned __int8 *)v76;
    uint64_t v79 = a3 + 48;
    uint64_t v80 = a3 + 55;
    uint64_t v81 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v79 = 58;
    }

    else
    {
      uint64_t v81 = 97;
      uint64_t v80 = 65;
    }

    if (v76)
    {
      uint64_t v82 = 0LL;
      do
      {
        uint64_t v83 = *v78;
        if (v83 < 0x30 || v83 >= v79)
        {
          if (v83 < 0x41 || v83 >= v80)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v83 < 0x61 || v83 >= v81) {
              goto LABEL_118;
            }
            uint64_t v84 = -87;
          }

          else
          {
            uint64_t v84 = -55;
          }
        }

        else
        {
          uint64_t v84 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v85 = v83 + v84;
        uint64_t v86 = v82 * a3;
        uint64_t v87 = (unsigned __int128)(v82 * (__int128)a3) >> 64 != (v82 * a3) >> 63;
        uint64_t v82 = v82 * a3 + v85;
        uint64_t v88 = __OFADD__(v86, v85);
        uint64_t v8 = 1;
        if (v87) {
          break;
        }
        if (v88) {
          break;
        }
        uint64_t v8 = 0;
        ++v78;
        uint64_t result = v82;
        --v77;
      }

      while (v77);
      goto LABEL_118;
    }
  }

  else
  {
    if (a1 != 45)
    {
      uint64_t v89 = 0LL;
      uint64_t v90 = a3 + 48;
      uint64_t v91 = a3 + 55;
      uint64_t v92 = a3 + 87;
      if (a3 > 10)
      {
        uint64_t v90 = 58;
      }

      else
      {
        uint64_t v92 = 97;
        uint64_t v91 = 65;
      }

      uint64_t v93 = (unsigned __int8 *)v101;
      do
      {
        uint64_t v94 = *v93;
        if (v94 < 0x30 || v94 >= v90)
        {
          if (v94 < 0x41 || v94 >= v91)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v94 < 0x61 || v94 >= v92) {
              goto LABEL_118;
            }
            uint64_t v95 = -87;
          }

          else
          {
            uint64_t v95 = -55;
          }
        }

        else
        {
          uint64_t v95 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v96 = v94 + v95;
        uint64_t v97 = v89 * a3;
        uint64_t v98 = (unsigned __int128)(v89 * (__int128)a3) >> 64 != (v89 * a3) >> 63;
        uint64_t v89 = v89 * a3 + v96;
        uint64_t v99 = __OFADD__(v97, v96);
        uint64_t v8 = 1;
        if (v98) {
          break;
        }
        if (v99) {
          break;
        }
        uint64_t v8 = 0;
        ++v93;
        uint64_t result = v89;
        --v27;
      }

      while (v27);
      goto LABEL_118;
    }

    uint64_t v8 = 1;
    uint64_t v28 = specialized Collection.subscript.getter(1LL, (uint64_t)v101, v27);
    uint64_t v32 = specialized UnsafeBufferPointer.init(rebasing:)(v28, v29, v30, v31);
    if (!v33) {
      goto LABEL_143;
    }
    uint64_t v34 = (unsigned __int8 *)v32;
    uint64_t v35 = a3 + 48;
    uint64_t v36 = a3 + 55;
    uint64_t v37 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v35 = 58;
    }

    else
    {
      uint64_t v37 = 97;
      uint64_t v36 = 65;
    }

    if (v32)
    {
      uint64_t v38 = 0LL;
      do
      {
        uint64_t v39 = *v34;
        if (v39 < 0x30 || v39 >= v35)
        {
          if (v39 < 0x41 || v39 >= v36)
          {
            uint64_t result = 0LL;
            uint64_t v8 = 1;
            if (v39 < 0x61 || v39 >= v37) {
              goto LABEL_118;
            }
            uint64_t v40 = -87;
          }

          else
          {
            uint64_t v40 = -55;
          }
        }

        else
        {
          uint64_t v40 = -48;
        }

        uint64_t result = 0LL;
        uint64_t v41 = v39 + v40;
        uint64_t v42 = v38 * a3;
        uint64_t v43 = (unsigned __int128)(v38 * (__int128)a3) >> 64 != (v38 * a3) >> 63;
        uint64_t v38 = v38 * a3 - v41;
        uint64_t v44 = __OFSUB__(v42, v41);
        uint64_t v8 = 1;
        if (v43) {
          break;
        }
        if (v44) {
          break;
        }
        uint64_t v8 = 0;
        ++v34;
        uint64_t result = v38;
        --v33;
      }

      while (v33);
      goto LABEL_118;
    }
  }

            if (!_swift_stdlib_isLinkingConsonant(v55)) {
              return v6 - v19;
            }
          }

          else
          {
LABEL_153:
            uint64_t v74 = _swift_stdlib_isLinkingConsonant(v55);
            if (v60 != 12)
            {
              if (v60 != 2) {
                return v6 - v19;
              }
              uint64_t v75 = v13 > 0x2FF && v74;
              if (!v75
                || !(_swift_stdlib_getNormData(v13) >> 3)
                || (specialized _StringGuts.checkIfInIndicSequence(at:with:)(v19, a2, (uint64_t)v7) & 1) == 0)
              {
                return v6 - v19;
              }

              break;
            }

            if (!v74) {
              return v6 - v19;
            }
          }

          uint64_t v76 = specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( v19,  a2,  (uint64_t)v7);
          if ((v78 & 1) != 0) {
            return v6 - v19;
          }
          uint64_t v79 = v77;
          uint64_t v89 = v6;
          HIDWORD(v8specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v76 - 2381;
          LODWORD(v8specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v76 - 2381;
          uint64_t v88 = ((v80 >> 7) < 9) & (0x15Bu >> (v80 >> 7));
          while (1)
          {
            uint64_t v81 = specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( v79,  a2,  (uint64_t)v7);
            if ((v83 & 1) != 0) {
              goto LABEL_18;
            }
            uint64_t v84 = v81;
            uint64_t v79 = v82;
            uint64_t v85 = Unicode._GraphemeBreakProperty.init(from:)(v81);
            if (_swift_stdlib_isLinkingConsonant(v84)) {
              break;
            }
            if (v85 != 12)
            {
              if (v85 != 2) {
                goto LABEL_18;
              }
              uint64_t v6 = v89;
              if (v84 < 0x300) {
                return v6 - v19;
              }
              HIDWORD(v87) = v84 - 2381;
              LODWORD(v87) = v84 - 2381;
              uint64_t v86 = v87 >> 7;
              if (v86 <= 8) {
                v88 |= 0x15Bu >> v86;
              }
            }
          }

          uint64_t v6 = v89;
          if ((v88 & 1) == 0) {
            return v6 - v19;
          }
        }

        break;
    }

LABEL_145:
  v309 = v605;
  uint64_t v310 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
  uint64_t result = ((uint64_t (*)(uint64_t *, unint64_t *))v202)(v309, v69);
  uint64_t v311 = v310 + 1074;
  if (!__OFADD__(v310, 1074LL))
  {
    uint64_t v312 = v618;
    uint64_t v313 = v621;
    v611 = *(const char **)(v618 + 136);
    uint64_t v314 = ((uint64_t (*)(uint64_t, uint64_t))v611)(v621, v618);
    unint64_t v123 = v615;
    v619 = *(char **)(v312 + 120);
    ((void (*)(uint64_t, uint64_t))v619)(v313, v312);
    char v69 = (unint64_t *)v613;
    uint64_t v315 = (*((uint64_t (**)(uint64_t, char *))v613 + 18))(v236, v613);
    unint64_t v620 = *(void *)(*(void *)&v607 + 8LL);
    ((void (*)(char *, uint64_t))v620)(v123, v236);
    unint64_t v67 = v311 - (v314 + v315);
    char v316 = (*((uint64_t (**)(uint64_t))v616 + 46))(v313);
    uint64_t v617 = v67;
    v610 = (uint64_t (*)(void))v311;
    if ((v316 & 1) != 0)
    {
      BOOL v148 = v311 < -64;
      uint64_t v317 = v311;
      uint64_t v171 = v599;
      v318 = (void (*)(uint64_t, uint64_t))v619;
      if (v148 || v317 > 64) {
        goto LABEL_149;
      }
      if (v317 < 0) {
        goto LABEL_278;
      }
      uint64_t v319 = 1LL << v317;
    }

    else
    {
      uint64_t v319 = 0LL;
      uint64_t v171 = v599;
      v318 = (void (*)(uint64_t, uint64_t))v619;
    }

      uint64_t v76 = (unsigned __int8 *)v73 + ((unsigned __int16)v72 & 0xFFF8);
      uint64_t v94 = 0uLL;
      uint64_t v95 = (int32x4_t)v75;
      uint64_t v96 = (uint8x8_t *)((char *)v69 + v77 + 12);
      uint64_t v97 = v77 - ((unsigned __int16)v72 & 0xFFF8);
      do
      {
        uint64_t v98 = *v96++;
        uint64_t v99 = vmovl_u8(vshr_n_u8(v98, 7uLL));
        uint64_t v94 = (int32x4_t)vaddw_high_u16((uint32x4_t)v94, v99);
        uint64_t v95 = (int32x4_t)vaddw_u16((uint32x4_t)v95, *(uint16x4_t *)v99.i8);
        v97 += 8LL;
      }

      while (v97);
      uint64_t v75 = vaddvq_s32(vaddq_s32(v95, v94));
      a2 = v108;
      if ((v72 & 0xFFF8) == v72) {
        goto LABEL_150;
      }
      goto LABEL_148;
    }

    a2 = v108;
  }

  else
  {
    uint64_t v75 = 0;
    a2 = v108;
    uint64_t v74 = v107;
  }

LABEL_159:
    if ((v67 & 0x8000000000000000LL) == 0)
    {
LABEL_160:
      uint64_t v348 = v598;
      v318(v621, v618);
      v349 = (uint64_t (*)(uint64_t, unint64_t *))v69[8];
      if ((v349(v236, v69) & 1) == 0) {
        goto LABEL_163;
      }
      v609 = (void (*)(void, void, void))v319;
      v350 = v578;
      (*(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL))(v578, v348, v236);
      v351 = (void (**)(char *, uint64_t, const char *))v614;
      unint64_t v352 = v612;
      unint64_t v353 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v354 = v608;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v353 + 8))( &qword_18180BE68,  256LL,  v352,  v353);
      v351[3](v354, v236, (const char *)v351);
      LOBYTE(v351) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69[4] + 8) + 32LL))( v350,  v123,  v236);
      v355 = (void (*)(char *, uint64_t))v620;
      ((void (*)(char *, uint64_t))v620)(v123, v236);
      if ((v351 & 1) != 0)
      {
        v355(v350, v236);
        uint64_t v348 = v598;
        unint64_t v67 = v617;
        uint64_t v319 = (uint64_t)v609;
LABEL_163:
        v356 = (uint64_t (*)(uint64_t, unint64_t *))v69[16];
        if (v356(v236, v69) < 64) {
          goto LABEL_190;
        }
        v357 = v348;
        v358 = v69;
        v359 = *(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL);
        v360 = v581;
        v359(v581, v357, v236);
        unint64_t v624 = -1LL;
        char v361 = v349(v236, v358);
        v362 = v360;
        LOBYTE(v36specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v361;
        uint64_t v363 = v356(v236, v358);
        if ((v360 & 1) != 0)
        {
          v366 = v615;
          if (v363 > 64)
          {
            char v69 = (unint64_t *)v613;
            v367 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t *))*((void *)v613 + 12);
            unint64_t v368 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v363, v364, v365);
            v367(&v624, &type metadata for UInt64, v368, v236, v69);
            char v369 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69[4] + 8) + 16LL))( v366,  v362,  v236);
            v370 = v366;
            goto LABEL_169;
          }

          v379 = (void (**)(char *, uint64_t, const char *))v614;
          unint64_t v380 = v612;
          unint64_t v381 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v382 = v608;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v381 + 8))( &qword_18180BE68,  256LL,  v380,  v381);
          v379[3](v382, v236, (const char *)v379);
          v383 = v613;
          LOBYTE(v379) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v613 + 4) + 8LL)
                                                                            + 40LL))( v362,  v366,  v236);
          v374 = (void (*)(char *, uint64_t))v620;
          ((void (*)(char *, uint64_t))v620)(v366, v236);
          v384 = v362;
          unint64_t v385 = v624;
          v386 = v564;
          v359(v564, v384, v236);
          if ((v379 & 1) != 0)
          {
            unint64_t v387 = (*((uint64_t (**)(uint64_t, char *))v383 + 15))(v236, v383);
            v374(v386, v236);
            BOOL v453 = v385 >= v387;
            char v69 = (unint64_t *)v383;
            v362 = v581;
            if (!v453) {
              goto LABEL_228;
            }
          }

          else
          {
            v374(v386, v236);
            char v69 = (unint64_t *)v383;
            v362 = v581;
          }
        }

        else
        {
          v371 = v615;
          if (v363 > 64)
          {
            char v69 = (unint64_t *)v613;
            v372 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t *))*((void *)v613 + 12);
            unint64_t v373 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v363, v364, v365);
            v372(&v624, &type metadata for UInt64, v373, v236, v69);
            char v369 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69[4] + 8) + 16LL))( v371,  v362,  v236);
            v370 = v371;
LABEL_169:
            v374 = (void (*)(char *, uint64_t))v620;
            ((void (*)(char *, uint64_t))v620)(v370, v236);
            if ((v369 & 1) != 0) {
              goto LABEL_228;
            }
            goto LABEL_189;
          }

          v359(v615, v362, v236);
          char v69 = (unint64_t *)v613;
          unint64_t v388 = (*((uint64_t (**)(uint64_t, char *))v613 + 15))(v236, v613);
          v374 = (void (*)(char *, uint64_t))v620;
          ((void (*)(char *, uint64_t))v620)(v371, v236);
          if (v624 < v388) {
            goto LABEL_228;
          }
        }

          uint64_t v86 = 14LL;
          if (v22 < 0xE) {
            uint64_t v86 = v22;
          }
          uint64_t v78 = (char *)v23 + v86;
          uint64_t v79 = v22 - v86;
          uint64_t v80 = v6;
          uint64_t v81 = 102;
        }

        uint64_t v87 = swift::Demangle::__runtime::RemanglerBuffer::operator<<(v80, v81);
        uint64_t v6 = v87;
        uint64_t v88 = v87[2];
        uint64_t v89 = v78;
        uint64_t v90 = v79;
LABEL_213:
        swift::Demangle::__runtime::CharVector::append(v87, v89, v90, v88);
        uint64_t v25 = v6;
        uint64_t v26 = 95;
LABEL_214:
        this = (uint64_t)swift::Demangle::__runtime::RemanglerBuffer::operator<<(v25, v26);
        goto LABEL_215;
      }

      uint64_t v104 = *(_DWORD *)(v4 + 12736);
      uint64_t v105 = *(unsigned int *)(v4 + 12740);
      uint64_t v106 = *(char **)(v4 + 12728);
      uint64_t v107 = *(void **)(v4 + 12744);
      uint64_t v108 = (char *)v107[1];
      if (&v106[v105] == v108)
      {
        __int16 v128 = (unint64_t)&v106[v105 + 1];
        uint64_t v109 = v107[2];
        if (v128 <= v109)
        {
          v107[1] = v128;
          LODWORD(v13specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = 1;
LABEL_267:
          *(_DWORD *)(v4 + 1274specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v105 + v130;
LABEL_268:
          *(_DWORD *)(v4 + 12736) = v104 + 1;
          v106[v104] = 112;
          goto LABEL_215;
        }
      }

      else
      {
        uint64_t v109 = v107[2];
      }

      char v129 = v4;
      else {
        unint64_t v130 = (2 * v105);
      }
      uint64_t v131 = v130 + v105;
      if (!v108 || (unint64_t)&v108[v131] > v109)
      {
        uint64_t v132 = 2LL * v107[4];
        if (v132 <= v131 + 1) {
          uint64_t v132 = v131 + 1;
        }
        v107[4] = v132;
        uint64_t v133 = v132 + 8;
        this = (uint64_t)malloc(v132 + 8);
        *(void *)this = v107[3];
        uint64_t v108 = (char *)(this + 8);
        v107[2] = this + v133;
        v107[3] = this;
      }

      v107[1] = &v108[v131];
      double v4 = v129;
      if ((_DWORD)v105)
      {
        this = (uint64_t)memcpy(v108, *(const void **)(v129 + 12728), v105);
        LODWORD(v105) = *(_DWORD *)(v129 + 12740);
        uint64_t v104 = *(_DWORD *)(v129 + 12736);
      }

      *uint64_t v6 = v108;
      uint64_t v106 = v108;
      goto LABEL_267;
    case 0x14uLL:
      if (*v23 == 0x2E6E69746C697542LL && v23[1] == 0x624F656764697242LL && *((_DWORD *)v23 + 4) == 1952671082)
      {
        uint64_t v110 = *(_DWORD *)(v4 + 12736);
        uint64_t v111 = *(unsigned int *)(v4 + 12740);
        uint64_t v112 = *(char **)(v4 + 12728);
        if (v110 < v111)
        {
LABEL_271:
          *(_DWORD *)(v4 + 12736) = v110 + 1;
          v112[v110] = 98;
          goto LABEL_215;
        }

        uint64_t v113 = *(void **)(v4 + 12744);
        uint64_t v114 = (char *)v113[1];
        if (&v112[v111] == v114)
        {
          unint64_t v134 = (unint64_t)&v112[v111 + 1];
          uint64_t v115 = v113[2];
          if (v134 <= v115)
          {
            v113[1] = v134;
            LODWORD(v136) = 1;
LABEL_270:
            *(_DWORD *)(v4 + 1274specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v111 + v136;
            goto LABEL_271;
          }
        }

        else
        {
          uint64_t v115 = v113[2];
        }

        uint64_t v135 = v4;
        else {
          unint64_t v136 = (2 * v111);
        }
        char v137 = v136 + v111;
        if (!v114 || (unint64_t)&v114[v137] > v115)
        {
          uint64_t v138 = 2LL * v113[4];
          if (v138 <= v137 + 1) {
            uint64_t v138 = v137 + 1;
          }
          v113[4] = v138;
          uint64_t v139 = v138 + 8;
          this = (uint64_t)malloc(v138 + 8);
          *(void *)this = v113[3];
          uint64_t v114 = (char *)(this + 8);
          v113[2] = this + v139;
          v113[3] = this;
        }

        v113[1] = &v114[v137];
        double v4 = v135;
        if ((_DWORD)v111)
        {
          this = (uint64_t)memcpy(v114, *(const void **)(v135 + 12728), v111);
          LODWORD(v111) = *(_DWORD *)(v135 + 12740);
          uint64_t v110 = *(_DWORD *)(v135 + 12736);
        }

        *uint64_t v6 = v114;
        uint64_t v112 = v114;
        goto LABEL_270;
      }

      if (*v23 != 0x2E6E69746C697542LL || v23[1] != 0x624F65766974614ELL || *((_DWORD *)v23 + 4) != 1952671082LL) {
        goto LABEL_154;
      }
      uint64_t v39 = *(_DWORD *)(v4 + 12736);
      uint64_t v40 = *(unsigned int *)(v4 + 12740);
      uint64_t v41 = *(char **)(v4 + 12728);
      if (v39 >= v40)
      {
        uint64_t v42 = *(void **)(v4 + 12744);
        uint64_t v43 = (char *)v42[1];
        if (&v41[v40] == v43)
        {
          uint64_t v140 = (unint64_t)&v41[v40 + 1];
          uint64_t v44 = v42[2];
          if (v140 <= v44)
          {
            v42[1] = v140;
            LODWORD(v142) = 1;
LABEL_289:
            *(_DWORD *)(v4 + 1274specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v40 + v142;
            goto LABEL_290;
          }
        }

        else
        {
          uint64_t v44 = v42[2];
        }

        int v141 = v4;
        else {
          unint64_t v142 = (2 * v40);
        }
        int v143 = v142 + v40;
        if (!v43 || (unint64_t)&v43[v143] > v44)
        {
          unint64_t v144 = 2LL * v42[4];
          if (v144 <= v143 + 1) {
            unint64_t v144 = v143 + 1;
          }
          v42[4] = v144;
          unint64_t v145 = v144 + 8;
          this = (uint64_t)malloc(v144 + 8);
          *(void *)this = v42[3];
          uint64_t v43 = (char *)(this + 8);
          v42[2] = this + v145;
          v42[3] = this;
        }

        v42[1] = &v43[v143];
        double v4 = v141;
        if ((_DWORD)v40)
        {
          this = (uint64_t)memcpy(v43, *(const void **)(v141 + 12728), v40);
          LODWORD(v4specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = *(_DWORD *)(v141 + 12740);
          uint64_t v39 = *(_DWORD *)(v141 + 12736);
        }

        *uint64_t v6 = v43;
        uint64_t v41 = v43;
        goto LABEL_289;
      }

LABEL_189:
        v374(v362, v236);
        uint64_t v348 = v598;
LABEL_190:
        uint64_t v399 = ((uint64_t (*)(uint64_t, unint64_t *))v69[15])(v236, v69);
        ((void (*)(char *, uint64_t))v620)(v348, v236);
        if (v67 >= 0x40) {
          uint64_t v400 = 0LL;
        }
        else {
          uint64_t v400 = v399 << v67;
        }
        goto LABEL_242;
      }

            char v204 = String.UTF8View._foreignCount()();
            uint64_t v88 = v204 + v87;
            if (!__OFADD__(v204, v87))
            {
LABEL_80:
              if ((v7 & ~v22 & 0x2000000000000000LL) != 0
                && swift_isUniquelyReferenced_nonNull_native(v22 & 0xFFFFFFFFFFFFFFFLL))
              {
                uint64_t v90 = (char *)v214;
                uint64_t v89 = v215;
                uint64_t v91 = _StringGuts.nativeUnusedCapacity.getter(v214, v215);
                if ((v84 & 1) != 0) {
                  goto LABEL_160;
                }
                if (v88 <= 15 && ((v89 & 0x2000000000000000LL) != 0 || v91 < v87))
                {
LABEL_94:
                  swift_bridgeObjectRetain(v89, v84, v85, v86);
                  uint64_t v97 = _StringGuts._convertedToSmall()((unint64_t)v90, v89);
                  uint64_t v99 = v98;
                  swift_bridgeObjectRelease(v89);
                  v100._Swift::UInt64 rawBits = (v13 << 16) | 1;
                  v101._Swift::UInt64 rawBits = 1LL;
                  v102._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v101, v100, v6, a1);
                  if (v102._rawBits < 0x10000) {
                    v102._rawBits |= 3;
                  }
                  uint64_t v104 = specialized String.init(_:)(v102, v103, v6, a1);
                  uint64_t v106 = v105;
                  swift_bridgeObjectRelease(a1);
                  uint64_t v107 = _StringGuts._convertedToSmall()(v104, v106);
                  uint64_t v109 = v108;
                  swift_bridgeObjectRelease(v106);
                  uint64_t v110 = HIBYTE(v99) & 0xF;
                  uint64_t v111 = HIBYTE(v109) & 0xF;
                  uint64_t v112 = v111 + v110;
                  if ((unint64_t)(v111 + v110) <= 0xF)
                  {
                    if (v111)
                    {
                      uint64_t v113 = 0;
                      uint64_t v114 = 0LL;
                      do
                      {
                        uint64_t v115 = v110 + v114;
                        uint64_t v116 = v114 + 1;
                        if (v114 >= 8) {
                          uint64_t v117 = v109;
                        }
                        else {
                          uint64_t v117 = v107;
                        }
                        uint64_t v118 = v117 >> (v113 & 0x38);
                        uint64_t v119 = (8 * v110 + v113) & 0x38;
                        uint64_t v120 = (-255LL << v119) - 1;
                        uint64_t v121 = (unint64_t)v118 << v119;
                        uint64_t v122 = v121 | v120 & v99;
                        unint64_t v123 = v121 | v120 & v97;
                        if (v115 < 8) {
                          uint64_t v97 = v123;
                        }
                        else {
                          uint64_t v99 = v122;
                        }
                        v113 += 8;
                        uint64_t v114 = v116;
                      }

                      while (v111 != v116);
                    }

                    swift_bridgeObjectRelease(v89);
                    swift_bridgeObjectRelease(a1);
                    uint64_t v124 = 0xA000000000000000LL;
                    if (!(v97 & 0x8080808080808080LL | v99 & 0x80808080808080LL)) {
                      uint64_t v124 = 0xE000000000000000LL;
                    }
                    char v214 = v97;
                    unint64_t v215 = v124 & 0xFF00000000000000LL | (v112 << 56) | v99 & 0xFFFFFFFFFFFFFFLL;
                    goto LABEL_126;
                  }

                  goto LABEL_152;
                }
              }

              else if (v88 <= 15)
              {
                uint64_t v90 = (char *)v214;
                uint64_t v89 = v215;
                goto LABEL_94;
              }

              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v88, v87);
              if ((a1 & 0x1000000000000000LL) != 0)
              {
                _StringGuts._foreignAppendInPlace(_:)(v6, a1, 0LL, v13);
                goto LABEL_110;
              }

              swift_bridgeObjectRelease_n(a1, 4LL);
              if (!v20)
              {
                if ((v6 & 0x1000000000000000LL) == 0) {
                  goto LABEL_198;
                }
                swift_bridgeObjectRelease(a1);
                uint64_t v92 = (id)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v93 = v211;
                uint64_t v94 = v211;
                goto LABEL_92;
              }

              swift_bridgeObjectRelease_n(a1, 2LL);
              uint64_t v212 = v6;
              char v213 = a1 & 0xFFFFFFFFFFFFFFLL;
              __int16 v128 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v14, (uint64_t)&v212, v14);
              _StringGuts.appendInPlace(_:isASCII:)(v128, v129, (a1 & 0x4000000000000000LL) != 0);
              swift_bridgeObjectRelease(a1);
              while (1)
              {
LABEL_126:
                uint64_t v7 = v214;
                a1 = v215;
                unint64_t v142 = HIBYTE(v215) & 0xF;
                if ((v215 & 0x2000000000000000LL) != 0) {
                  uint64_t v14 = HIBYTE(v215) & 0xF;
                }
                else {
                  uint64_t v14 = v214 & 0xFFFFFFFFFFFFLL;
                }
                if (!v14 && (v214 & ~v215 & 0x2000000000000000LL) == 0)
                {
                  swift_bridgeObjectRelease(v215);
                  int v143 = 0x80000001818B6E20LL | 0x8000000000000000LL;
                  char v214 = 0xD0000000000000AALL;
                  goto LABEL_176;
                }

                uint64_t v88 = (int64_t)"' were found in a Dictionary.\n"
                                      "This usually means either that the type violates Hashable's requirements, or\n"
                                      "that members of such a dictionary were mutated after insertion.";
                if ((v215 & 0x2000000000000000LL) != 0 && (0x80000001818B6E20LL & 0x2000000000000000LL) != 0)
                {
                  unint64_t v144 = v142 + ((0x80000001818B6E20LL >> 56) & 0xF);
                  if (v144 <= 0xF)
                  {
                    char v178 = (0x80000001818B6E20LL >> 56) & 0xF;
                    if (v178)
                    {
                      char v181 = 0;
                      unint64_t v182 = 0LL;
                      char v179 = v215;
                      do
                      {
                        char v183 = v142 + v182;
                        uint64_t v184 = v182 + 1;
                        unint64_t v185 = 0xD0000000000000AALL;
                        if (v182 >= 8) {
                          unint64_t v185 = 0x80000001818B6E20LL | 0x8000000000000000LL;
                        }
                        unint64_t v186 = v185 >> (v181 & 0x38);
                        uint64_t v187 = (8 * v142 + v181) & 0x38;
                        uint64_t v188 = (-255LL << v187) - 1;
                        unint64_t v189 = (unint64_t)v186 << v187;
                        uint64_t v190 = v189 | v188 & v179;
                        uint64_t v191 = v189 | v188 & v7;
                        if (v183 < 8) {
                          uint64_t v7 = v191;
                        }
                        else {
                          char v179 = v190;
                        }
                        v181 += 8;
                        unint64_t v182 = v184;
                      }

                      while (v178 != v184);
                    }

                    else
                    {
                      char v179 = v215;
                    }

                    swift_bridgeObjectRelease(v215);
                    swift_bridgeObjectRelease(0x80000001818B6E20LL | 0x8000000000000000LL);
                    unint64_t v192 = 0xA000000000000000LL;
                    if (!(v7 & 0x8080808080808080LL | v179 & 0x80808080808080LL)) {
                      unint64_t v192 = 0xE000000000000000LL;
                    }
                    int v143 = v192 & 0xFF00000000000000LL | (v144 << 56) | v179 & 0xFFFFFFFFFFFFFFLL;
                    char v214 = v7;
LABEL_176:
                    unint64_t v215 = v143;
                    goto LABEL_177;
                  }
                }

                uint64_t v20 = 0x80000001818B6E20LL | 0x8000000000000000LL;
                if ((0x80000001818B6E20LL & 0x2000000000000000LL) != 0) {
                  uint64_t v6 = (0x80000001818B6E20LL >> 56) & 0xF;
                }
                else {
                  uint64_t v6 = 170LL;
                }
                swift_bridgeObjectRetain_n(0x80000001818B6E20LL | 0x8000000000000000LL, 2LL, v81, v82);
                if ((0x80000001818B6E20LL & 0x1000000000000000LL) != 0)
                {
LABEL_192:
                  swift_bridgeObjectRetain_n(v20, 5LL, v85, v86);
                  v205._Swift::UInt64 rawBits = 1LL;
                  v206._Swift::UInt64 rawBits = (v6 << 16) | 1;
                  v207._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v205, v206, 0xD0000000000000AALL, v20);
                  if (v207._rawBits < 0x10000) {
                    v207._rawBits |= 3;
                  }
                  BOOL v148 = specialized Collection.count.getter(v207, v208, 0xD0000000000000AALL, v20);
                  swift_bridgeObjectRelease(v20);
                  if ((a1 & 0x1000000000000000LL) == 0)
                  {
LABEL_140:
                    uint64_t v21 = __OFADD__(v14, v148);
                    unsigned __int8 v149 = v14 + v148;
                    if (!v21) {
                      goto LABEL_141;
                    }
                    goto LABEL_197;
                  }
                }

                else
                {
                  swift_bridgeObjectRetain_n(0x80000001818B6E20LL | 0x8000000000000000LL, 4LL, v85, v86);
                  BOOL v148 = v6;
                  if ((a1 & 0x1000000000000000LL) == 0) {
                    goto LABEL_140;
                  }
                }

                uint64_t v209 = String.UTF8View._foreignCount()();
                unsigned __int8 v149 = v209 + v148;
                if (!__OFADD__(v209, v148))
                {
LABEL_141:
                  if ((v7 & ~a1 & 0x2000000000000000LL) == 0
                    || !swift_isUniquelyReferenced_nonNull_native(a1 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if (v149 <= 15) {
                      goto LABEL_148;
                    }
                    goto LABEL_154;
                  }

                  unint64_t v150 = _StringGuts.nativeUnusedCapacity.getter(v7, a1);
                  if ((v145 & 1) == 0)
                  {
                    unint64_t v151 = (a1 >> 61) & 1;
                    if (v150 < v148) {
                      LODWORD(v151) = 1;
                    }
                    if (v149 <= 15 && (_DWORD)v151)
                    {
LABEL_148:
                      swift_bridgeObjectRetain(a1, v145, v146, v147);
                      uint64_t v152 = _StringGuts._convertedToSmall()(v7, a1);
                      int64_t v154 = v153;
                      swift_bridgeObjectRelease(a1);
                      v155._Swift::UInt64 rawBits = (v6 << 16) | 1;
                      v156._Swift::UInt64 rawBits = 1LL;
                      v157._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v156,  v155,  0xD0000000000000AALL,  (v88 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
                      if (v157._rawBits < 0x10000) {
                        v157._rawBits |= 3;
                      }
                      uint64_t v159 = specialized String.init(_:)( v157,  v158,  0xD0000000000000AALL,  (v88 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
                      uint64_t v161 = v160;
                      swift_bridgeObjectRelease((v88 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
                      uint64_t v162 = _StringGuts._convertedToSmall()(v159, v161);
                      uint64_t v164 = v163;
                      swift_bridgeObjectRelease(v161);
                      uint64_t v165 = specialized _SmallString.init(_:appending:)(v152, v154, v162, v164);
                      if ((v167 & 1) == 0)
                      {
                        uint64_t v168 = (char *)v165;
                        uint64_t v169 = v166;
                        swift_bridgeObjectRelease(a1);
                        swift_bridgeObjectRelease((v88 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
                        char v214 = (uint64_t)v168;
                        unint64_t v215 = v169;
                        goto LABEL_177;
                      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  a4 = v37;
LABEL_80:
  if (a4 < v32) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }
  if (__OFADD__(a4, 1LL))
  {
    __break(1u);
    goto LABEL_196;
  }

  uint64_t v44 = specialized Slice.subscript.getter(v32, a4 + 1, v32, v33);
  uint64_t v48 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v44, v45, v46, v47);
  unint64_t v186 = 0LL;
  uint64_t v187 = 0xE000000000000000LL;
  uint64_t v50 = v10 + 15;
  if (__OFADD__(v10, 15LL))
  {
LABEL_196:
    __break(1u);
    return;
  }

  uint64_t v51 = v48;
  uint64_t v52 = v49;
  if (v50 >= 16)
  {
    uint64_t v53 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v54 & 1) != 0 || v53 < v50) {
      _StringGuts.grow(_:)(v10 + 15);
    }
  }

  a5 = v185;
  while (2)
  {
    if (v51 < 0) {
      goto LABEL_189;
    }
    uint64_t v61 = v10;
    if (v10 < v51)
    {
      char v183 = 1861LL;
      goto LABEL_187;
    }

    uint64_t v62 = v187;
    uint64_t v63 = *(void *)&v186 & 0xFFFFFFFFFFFFLL;
    if ((v187 & 0x2000000000000000LL) != 0) {
      uint64_t v63 = HIBYTE(v187) & 0xF;
    }
    uint64_t v39 = __OFADD__(v63, v10);
    uint64_t v64 = v63 + v10;
    if (v39)
    {
      __break(1u);
      goto LABEL_192;
    }

    uint64_t v65 = v64 + 3;
    if (__OFADD__(v64, 3LL))
    {
LABEL_192:
      __break(1u);
LABEL_193:
      char v183 = 1860LL;
LABEL_187:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v183,  0);
    }

    if (v65 >= 16)
    {
      unint64_t v66 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v67 & 1) != 0 || v66 < v65)
      {
        _StringGuts.grow(_:)(v65);
        uint64_t v62 = v187;
      }
    }

    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v62 & 0xFFFFFFFFFFFFFFFLL, v11->i8, v51, 0);
    unint64_t v186 = *(int8x8_t *)(v62 + 24);
    uint64_t v188 = 3LL;
    unint64_t v189 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v189, &v188, &v186);
    if (v61 < v52) {
      goto LABEL_189;
    }
    if (v52 < 0) {
      goto LABEL_193;
    }
    uint64_t v10 = v61 - v52;
    if (v61 - v52 < 0) {
      goto LABEL_188;
    }
    uint64_t v68 = (uint64_t)v11->i64 + v52;
    if (_allASCII(_:)((uint64_t *)((char *)v11->i64 + v52), v61 - v52))
    {
LABEL_155:
      _StringGuts.appendInPlace(_:isASCII:)(&v11->i8[v52], v61 - v52, 0);
      break;
    }

    char v69 = 0LL;
    uint64_t v70 = &v11->u8[v61];
    if (!v11) {
      uint64_t v70 = 0LL;
    }
    for (uint64_t i = &v11->u8[v52]; ; ++i)
    {
      while (1)
      {
LABEL_107:
        if (!i || i == v70) {
          goto LABEL_155;
        }
        uint64_t v73 = *i++;
        char v72 = v73;
        if ((v72 & 0x80) != 0) {
          break;
        }
        ++v69;
      }

      if (v72 > 0xDF) {
        break;
      }
      if (!i || i == v70 || (*i & 0xC0) != 0x80) {
        goto LABEL_88;
      }
      v69 += 2LL;
    }

    if (v72 == 224)
    {
      if (!i) {
        goto LABEL_88;
      }
      if (i == v70) {
        goto LABEL_88;
      }
      uint64_t v74 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_88;
      }
      goto LABEL_134;
    }

    if (v72 <= 0xEC) {
      goto LABEL_130;
    }
    if (v72 == 237)
    {
      if (!i) {
        goto LABEL_88;
      }
      if (i == v70) {
        goto LABEL_88;
      }
      uint64_t v74 = i + 1;
      uint64_t v75 = *i;
      if (v75 > 0x9F) {
        goto LABEL_88;
      }
      goto LABEL_133;
    }

    if (v72 <= 0xEF)
    {
LABEL_130:
      if (!i || i == v70) {
        goto LABEL_88;
      }
      uint64_t v74 = i + 1;
      LOBYTE(v75) = *i;
LABEL_133:
      if ((v75 & 0xC0) != 0x80) {
        goto LABEL_88;
      }
LABEL_134:
      if (v74 == v70 || (*v74 & 0xC0) != 0x80) {
        goto LABEL_88;
      }
      i += 2;
      v69 += 3LL;
      goto LABEL_107;
    }

    if (v72 == 240)
    {
      if (!i) {
        goto LABEL_88;
      }
      if (i == v70) {
        goto LABEL_88;
      }
      uint64_t v76 = i + 1;
      goto LABEL_150;
    }

    if ((v72 + 15) <= 2u)
    {
      if (!i || i == v70) {
        goto LABEL_88;
      }
      uint64_t v76 = i + 1;
      LOBYTE(v77) = *i;
      goto LABEL_149;
    }

    if (i)
    {
      if (i != v70)
      {
        uint64_t v76 = i + 1;
        uint64_t v77 = *i;
        if (v77 <= 0x8F)
        {
LABEL_149:
          if ((v77 & 0xC0) != 0x80) {
            goto LABEL_88;
          }
LABEL_150:
          if (v76 == v70 || (i[1] & 0xC0) != 0x80 || i + 2 == v70 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_88;
          }
          i += 3;
          v69 += 4LL;
          goto LABEL_107;
        }
      }
    }

    uint64_t countAndFlagsBits = v315._countAndFlagsBits;
    unint64_t object = (unint64_t)v315._object;
    unint64_t v224 = ((unint64_t)v315._object >> 56) & 0xF;
    int64_t v225 = ((uint64_t)v315._object & 0x2000000000000000LL) != 0
         ? ((unint64_t)v315._object >> 56) & 0xF
         : v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v315._object & 0x2000000000000000LL) != 0 && v224 != 15)
    {
      int64_t v226 = 8 * (((unint64_t)v315._object >> 56) & 7);
      unint64_t v227 = (-255LL << v226) - 1;
      unint64_t v228 = 46LL << v226;
      unint64_t v229 = v228 | v227 & (uint64_t)v315._object;
      unint64_t v230 = v228 | v227 & v315._countAndFlagsBits;
      if (v224 < 8) {
        uint64_t countAndFlagsBits = v230;
      }
      else {
        unint64_t object = v229;
      }
      swift_bridgeObjectRelease(0xE100000000000000LL);
      unint64_t v231 = 0xA000000000000000LL;
      if (!(countAndFlagsBits & 0x8080808080808080LL | object & 0x80808080808080LL)) {
        unint64_t v231 = 0xE000000000000000LL;
      }
      int64_t v232 = (void *)((v231 & 0xFF00000000000000LL | (v224 << 56) | object & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL);
      swift_bridgeObjectRelease((uint64_t)v315._object);
      v315._uint64_t countAndFlagsBits = countAndFlagsBits;
      v315._unint64_t object = v232;
      goto LABEL_218;
    }

    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v205, v206);
    if ((object & 0x1000000000000000LL) != 0) {
      goto LABEL_268;
    }
    char v129 = __OFADD__(v225, 1LL);
    uint64_t v233 = v225 + 1;
    if (!v129) {
      goto LABEL_204;
    }
LABEL_270:
    __break(1u);
LABEL_271:
    uint64_t v20 = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, object);
    uint64_t v21 = v304;
LABEL_17:
    v22._Swift::UInt64 rawBits = 1LL;
    v23._Swift::UInt64 rawBits = 1LL;
    v24._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v22, v23, 0LL, 0xE000000000000000LL);
    if (v24._rawBits < 0x10000) {
      v24._rawBits |= 3;
    }
    uint64_t v26 = specialized String.init(_:)(v24, v25, 0LL, 0xE000000000000000LL);
    uint64_t v28 = v27;
    swift_bridgeObjectRelease(0xE000000000000000LL);
    if ((v28 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v28);
    }

    else
    {
      uint64_t v305 = v20;
      if ((v28 & 0x1000000000000000LL) != 0)
      {
        uint64_t v26 = _StringGuts._foreignConvertedToSmall()(v26, v28);
        uint64_t v312 = v311;
        swift_bridgeObjectRelease(v28);
        uint64_t v28 = v312;
      }

      else
      {
        if ((v26 & 0x1000000000000000LL) != 0)
        {
          uint64_t v306 = (unsigned __int8 *)((v28 & 0xFFFFFFFFFFFFFFFLL) + 32);
          unint64_t v307 = v26 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v306 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v26, v28);
        }

        closure #1 in _StringGuts._convertedToSmall()(v306, v307, &v314);
        swift_bridgeObjectRelease(v28);
        uint64_t v28 = *((void *)&v314 + 1);
        uint64_t v26 = v314;
      }

      uint64_t v20 = v305;
      a1 = v313;
    }

    uint64_t v29 = HIBYTE(v21) & 0xF;
    uint64_t v30 = HIBYTE(v28) & 0xF;
    uint64_t v31 = v30 + v29;
    if (v30)
    {
      uint64_t v32 = 0;
      uint64_t v33 = 0LL;
      do
      {
        uint64_t v34 = v29 + v33;
        uint64_t v35 = v33 + 1;
        if (v33 >= 8) {
          uint64_t v36 = v28;
        }
        else {
          uint64_t v36 = v26;
        }
        uint64_t v37 = v36 >> (v32 & 0x38);
        uint64_t v38 = (8 * v29 + v32) & 0x38;
        uint64_t v39 = (-255LL << v38) - 1;
        uint64_t v40 = (unint64_t)v37 << v38;
        uint64_t v41 = v40 | v39 & v21;
        uint64_t v42 = v40 | v39 & v20;
        if (v34 < 8) {
          uint64_t v20 = v42;
        }
        else {
          uint64_t v21 = v41;
        }
        v32 += 8;
        uint64_t v33 = v35;
      }

      while (v30 != v35);
    }

    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v43 = 0xA000000000000000LL;
    if (!(v20 & 0x8080808080808080LL | v21 & 0x80808080808080LL)) {
      uint64_t v43 = 0xE000000000000000LL;
    }
    uint64_t v44 = (uint64_t)v315._object;
    v315._uint64_t countAndFlagsBits = v20;
    v315._unint64_t object = (void *)(v43 & 0xFF00000000000000LL | (v31 << 56) | v21 & 0xFFFFFFFFFFFFFFLL);
LABEL_59:
    swift_bridgeObjectRelease(v44);
LABEL_60:
    uint64_t v58 = _uint64ToString(_:radix:uppercase:)(HIWORD(a1), 10LL, 0);
    uint64_t v49 = v58._countAndFlagsBits;
    uint64_t countAndFlagsBits = (unint64_t)v58._object;
    uint64_t v59 = v315._countAndFlagsBits;
    uint64_t v60 = (unint64_t)v315._object;
    uint64_t v61 = ((unint64_t)v315._object >> 56) & 0xF;
    uint64_t v62 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (v62 || (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000LL) != 0)
    {
      uint64_t v63 = (uint64_t)v58._object & 0x2000000000000000LL;
      uint64_t v64 = ((unint64_t)v58._object >> 56) & 0xF;
      uint64_t v65 = v61 + v64;
      if (v61 + v64 <= 0xF)
      {
        if (v64)
        {
          uint64_t v103 = 0;
          uint64_t v104 = 0LL;
          do
          {
            uint64_t v105 = v61 + v104;
            uint64_t v106 = v104 + 1;
            if (v104 >= 8) {
              uint64_t v107 = (unint64_t)v58._object;
            }
            else {
              uint64_t v107 = v58._countAndFlagsBits;
            }
            uint64_t v108 = v107 >> (v103 & 0x38);
            uint64_t v109 = (8 * v61 + v103) & 0x38;
            uint64_t v110 = (-255LL << v109) - 1;
            uint64_t v111 = (unint64_t)v108 << v109;
            uint64_t v112 = v111 | v110 & v60;
            uint64_t v113 = v111 | v110 & v59;
            if (v105 < 8) {
              uint64_t v59 = v113;
            }
            else {
              uint64_t v60 = v112;
            }
            v103 += 8;
            uint64_t v104 = v106;
          }

          while (v64 != v106);
        }

        swift_bridgeObjectRelease((uint64_t)v58._object);
        uint64_t v114 = 0xA000000000000000LL;
        if (!(v59 & 0x8080808080808080LL | v60 & 0x80808080808080LL)) {
          uint64_t v114 = 0xE000000000000000LL;
        }
        uint64_t v115 = (void *)(v114 & 0xFF00000000000000LL | (v65 << 56) | v60 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v315._object);
        v315._uint64_t countAndFlagsBits = v59;
        v315._unint64_t object = v115;
      }

      else
      {
        uint64_t v63 = 1LL;
LABEL_68:
        char v1 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (v63) {
          unint64_t v66 = ((unint64_t)v58._object >> 56) & 0xF;
        }
        else {
          unint64_t v66 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n((uint64_t)v58._object, 2LL, v56, v57);
        if (((uint64_t)v58._object & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRetain_n((uint64_t)v58._object, 5LL, v67, v68);
          v292._Swift::UInt64 rawBits = 1LL;
          v293._Swift::UInt64 rawBits = (v66 << 16) | 1;
          v294._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v292,  v293,  v58._countAndFlagsBits,  (unint64_t)v58._object);
          if (v294._rawBits < 0x10000) {
            v294._rawBits |= 3;
          }
          char v69 = specialized Collection.count.getter(v294, v295, v58._countAndFlagsBits, (unint64_t)v58._object);
          swift_bridgeObjectRelease((uint64_t)v58._object);
          uint64_t v59 = v315._countAndFlagsBits;
          uint64_t v60 = (unint64_t)v315._object;
          if (((uint64_t)v315._object & 0x1000000000000000LL) != 0)
          {
LABEL_256:
            uint64_t v296 = String.UTF8View._foreignCount()();
            uint64_t v70 = v296 + v69;
            if (!__OFADD__(v296, v69)) {
              goto LABEL_78;
            }
            goto LABEL_76;
          }
        }

        else
        {
          swift_bridgeObjectRetain_n((uint64_t)v58._object, 4LL, v67, v68);
          char v69 = v66;
          if ((v60 & 0x1000000000000000LL) != 0) {
            goto LABEL_256;
          }
        }

        if ((v60 & 0x2000000000000000LL) == 0)
        {
          uint64_t v70 = (v59 & 0xFFFFFFFFFFFFLL) + v69;
          if (!__OFADD__(v59 & 0xFFFFFFFFFFFFLL, v69)) {
            goto LABEL_78;
          }
          goto LABEL_76;
        }

        while (1)
        {
          uint64_t v71 = HIBYTE(v60) & 0xF;
          uint64_t v70 = v71 + v69;
          if (!__OFADD__(v71, v69)) {
            break;
          }
LABEL_76:
          __break(1u);
        }

LABEL_266:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }

    while (1)
    {
      uint64_t v320 = ((uint64_t (*)(uint64_t, uint64_t))v318)(v621, v618);
      if (!__OFSUB__(0LL, v67)) {
        break;
      }
LABEL_277:
      __break(1u);
LABEL_278:
      if ((unint64_t)v317 > 0xFFFFFFFFFFFFFFC0LL)
      {
        uint64_t v319 = 0LL;
        goto LABEL_159;
      }

  uint64_t result = 0LL;
LABEL_261:
  BOOL v163 = v10;
LABEL_262:
  LOBYTE(v162[0]) = (a2 & 0x1000000000000000LL) != 0;
  return result;
}

        swift::getTypePackByMangledName((uint64_t)v83, v85, &v256, &v268, (uint64_t)&v264);
        unint64_t v145 = v270;
        if (v270 == (uint64_t *)&v268)
        {
          unint64_t v145 = (uint64_t *)&v268;
          int v146 = 4LL;
          uint64_t v12 = a5;
        }

        else
        {
          uint64_t v12 = a5;
          if (!v270) {
            goto LABEL_271;
          }
          int v146 = 5LL;
        }

        (*(void (**)(void))(*v145 + 8 * v146))();
LABEL_271:
        uint64_t v147 = v259;
        if (v259 == &v256)
        {
          uint64_t v147 = &v256;
          BOOL v148 = 4LL;
        }

        else
        {
          if (!v259) {
            goto LABEL_276;
          }
          BOOL v148 = 5LL;
        }

        (*((void (**)(void))*v147 + v148))();
LABEL_276:
        if (v266 != 1)
        {
          unsigned __int8 v149 = v264;
          if (v266) {
            unsigned __int8 v149 = 0LL;
          }
          if ((v51 & 1) != 0 && (v149 & 1) != 0)
          {
            unint64_t v150 = v51 & 0xFFFFFFFFFFFFFFFELL;
            unint64_t v151 = *(void *)((v51 & 0xFFFFFFFFFFFFFFFELL) - 8);
            uint64_t v152 = v149 & 0xFFFFFFFFFFFFFFFELL;
            if (v151 == *(void *)((v149 & 0xFFFFFFFFFFFFFFFELL) - 8))
            {
              if (!v151)
              {
LABEL_286:
                int64_t v154 = 0;
                *(_BYTE *)a9 = 0;
                goto LABEL_374;
              }

              unint64_t v153 = 0LL;
              while (*(void *)(v150 + 8 * v153) == *(void *)(v152 + 8 * v153))
              {
                if (v151 == ++v153) {
                  goto LABEL_286;
                }
              }

              swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v25 + *v25, a2);
              uint64_t v210 = (int)v209;
              uint64_t v211 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v25 + *v25, v209);
              swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v238 + *v238, v212);
              char v214 = (int)v213;
              unint64_t v215 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v238 + *v238, v213);
              unint64_t v160 = operator new(0x30uLL);
              *(void *)unint64_t v160 = "subject type %.*s does not match %.*s at pack index %zu";
              v160[2] = v210;
              *((void *)v160 + 2) = v211;
              v160[6] = v214;
              *((void *)v160 + 4) = v215;
              *((void *)v160 + 5) = v153;
              uint64_t v12 = a5;
              int64_t v154 = 1;
              uint64_t v161 = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*,unsigned long>(char const*,int,char const*,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*,unsigned long>(char const*,int,char const*,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
            }

            else
            {
              swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v25 + *v25, a2);
              unint64_t v156 = (int)v155;
              int v157 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v25 + *v25, v155);
              unint64_t v158 = *(void *)(v150 - 8);
              uint64_t v159 = *(void *)(v152 - 8);
              unint64_t v160 = operator new(0x28uLL);
              *(void *)unint64_t v160 = "mismatched pack lengths in same-type pack requirement %.*s: %zu vs %zu";
              v160[2] = v156;
              *((void *)v160 + 2) = v157;
              *((void *)v160 + 3) = v158;
              *((void *)v160 + 4) = v159;
              int64_t v154 = 1;
              uint64_t v161 = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,unsigned long,unsigned long>(char const*,int,char const*,unsigned long,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,unsigned long,unsigned long>(char const*,int,char const*,unsigned long,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
            }

            *(void *)a9 = v160;
            *(void *)(a9 + 8) = v161;
LABEL_374:
            *(_BYTE *)(a9 + 16) = v154;
            if (v266 == 1) {
              v265(v264, 3LL, 0LL);
            }
            goto LABEL_381;
          }

LABEL_149:
      uint64_t v319 = 0LL;
      if ((v67 & 0x8000000000000000LL) == 0) {
        goto LABEL_160;
      }
    }

    unint64_t v624 = -(uint64_t)v67;
    v323 = (void (*)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t *))v69[30];
    unint64_t v324 = lazy protocol witness table accessor for type Int and conformance Int(v320, v321, v322);
    v323(v123, &v624, &type metadata for Int, v324, v236, v69);
    ((void (*)(char *, uint64_t))v620)(v123, v236);
    v325 = (uint64_t (*)(uint64_t, unint64_t *))v69[8];
    if ((v325(v236, v69) & 1) != 0)
    {
      uint64_t v326 = v319;
      v327 = v570;
      (*(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL))(v570, v171, v236);
      v328 = (void (**)(char *, uint64_t, const char *))v614;
      unint64_t v329 = v612;
      unint64_t v330 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v331 = v608;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v330 + 8))( &qword_18180BE68,  256LL,  v329,  v330);
      v328[3](v331, v236, (const char *)v328);
      LOBYTE(v328) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69[4] + 8) + 32LL))( v327,  v123,  v236);
      v332 = (void (*)(char *, uint64_t))v620;
      ((void (*)(char *, uint64_t))v620)(v123, v236);
      v332(v327, v236);
      uint64_t v171 = v599;
      uint64_t v319 = v326;
    }

    uint64_t v333 = (uint64_t (*)(uint64_t, unint64_t *))v69[16];
    if (v333(v236, v69) < 64)
    {
LABEL_241:
      uint64_t v400 = ((uint64_t (*)(uint64_t, unint64_t *))v69[15])(v236, v69);
      ((void (*)(char *, uint64_t))v620)(v171, v236);
LABEL_242:
      uint64_t v496 = v236;
      __int16 v501 = 0;
      uint64_t v497 = v319 | v400;
      v500 = v611;
      uint64_t v499 = v612;
      unint64_t v123 = v615;
      uint64_t v498 = (uint64_t)v610;
      goto LABEL_243;
    }

    v334 = v171;
    v335 = v69;
    v336 = *(void (**)(char *, char *, uint64_t))(*(void *)&v607 + 16LL);
    uint64_t v337 = v573;
    v336(v573, v334, v236);
    unint64_t v624 = -1LL;
    char v338 = v325(v236, v335);
    uint64_t v339 = v337;
    LOBYTE(v337) = v338;
    uint64_t v340 = v333(v236, v335);
    if ((v337 & 1) != 0)
    {
      uint64_t v343 = v615;
      if (v340 > 64)
      {
        char v69 = (unint64_t *)v613;
        uint64_t v344 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t *))*((void *)v613 + 12);
        unint64_t v345 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v340, v341, v342);
        v344(&v624, &type metadata for UInt64, v345, v236, v69);
        char v346 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69[4] + 8) + 16LL))(v343, v339, v236);
        uint64_t v347 = v343;
        goto LABEL_176;
      }

      v389 = (void (**)(char *, uint64_t, const char *))v614;
      unint64_t v390 = v612;
      unint64_t v391 = swift_getAssociatedConformanceWitness( (uint64_t)v614,  v236,  v612,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v392 = v608;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v391 + 8))( &qword_18180BE68,  256LL,  v390,  v391);
      v389[3](v392, v236, (const char *)v389);
      v393 = v613;
      LOBYTE(v389) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v613 + 4) + 8LL) + 40LL))( v339,  v343,  v236);
      v378 = (void (*)(char *, uint64_t))v620;
      ((void (*)(char *, uint64_t))v620)(v343, v236);
      v394 = v339;
      unint64_t v395 = v624;
      v396 = v561;
      v336(v561, v394, v236);
      if ((v389 & 1) != 0)
      {
        unint64_t v397 = (*((uint64_t (**)(uint64_t, char *))v393 + 15))(v236, v393);
        v378(v396, v236);
        BOOL v453 = v395 >= v397;
        char v69 = (unint64_t *)v393;
        uint64_t v339 = v573;
        if (!v453) {
          goto LABEL_228;
        }
      }

      else
      {
        v378(v396, v236);
        char v69 = (unint64_t *)v393;
        uint64_t v339 = v573;
      }
    }

    else
    {
      v375 = v615;
      if (v340 > 64)
      {
        char v69 = (unint64_t *)v613;
        v376 = (void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t *))*((void *)v613 + 12);
        unint64_t v377 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v340, v341, v342);
        v376(&v624, &type metadata for UInt64, v377, v236, v69);
        char v346 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69[4] + 8) + 16LL))(v375, v339, v236);
        uint64_t v347 = v375;
LABEL_176:
        v378 = (void (*)(char *, uint64_t))v620;
        ((void (*)(char *, uint64_t))v620)(v347, v236);
        if ((v346 & 1) != 0) {
          goto LABEL_228;
        }
        goto LABEL_240;
      }

      v336(v615, v339, v236);
      char v69 = (unint64_t *)v613;
      unint64_t v398 = (*((uint64_t (**)(uint64_t, char *))v613 + 15))(v236, v613);
      v378 = (void (*)(char *, uint64_t))v620;
      ((void (*)(char *, uint64_t))v620)(v375, v236);
      if (v624 < v398) {
        goto LABEL_228;
      }
    }

      unint64_t v324 = 3687LL;
      goto LABEL_233;
    }

    goto LABEL_86;
  }

  unint64_t v263 = ((uint64_t (*)(unint64_t *, char *))v258)(v69, v67);
  uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v634;
  uint64_t v259 = ((uint64_t (*)(unint64_t *, char *))v634)(v69, v67);
  unint64_t v262 = v628;
  if ((v263 & 1) == 0)
  {
    if (v259 < 64) {
      goto LABEL_92;
    }
    uint64_t v274 = v599;
    (*(void (**)(char *, char *, unint64_t *))(v655 + 32))(v599, v257, v69);
LABEL_110:
    ((void (*)(char *, unint64_t *))v149)(v274, v69);
    goto LABEL_111;
  }

  if (v259 > 64)
  {
LABEL_86:
    v660 = -149LL;
    uint64_t v264 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
    unint64_t v265 = lazy protocol witness table accessor for type Int and conformance Int(v259, v260, v261);
    v264(&v660, &type metadata for Int, v265, v69, v67);
    LOBYTE(v264) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 2)
                                                                                              + 8LL)
                                                                                  + 8LL))( v257,  v169,  v69);
    ((void (*)(float *, unint64_t *))v149)(v169, v69);
    ((void (*)(char *, unint64_t *))v149)(v257, v69);
    goto LABEL_96;
  }

  Swift::Int v267 = v647;
  v632(&qword_18180BE68, 256LL);
  ((void (*)(unsigned int (*)(void), unint64_t *, const char *))v625)(v267, v69, v648);
  LOBYTE(v267) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                + 32LL))( v257,  v169,  v69);
  ((void (*)(float *, unint64_t *))v149)(v169, v69);
  uint64_t v274 = v600;
  (*(void (**)(char *, char *, unint64_t *))(v655 + 32))(v600, v257, v69);
  if ((v267 & 1) == 0)
  {
    uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v634;
    goto LABEL_110;
  }

  unint64_t v268 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
  ((void (*)(char *, unint64_t *))v149)(v274, v69);
  uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v634;
  if (v268 != -149) {
    goto LABEL_111;
  }
LABEL_96:
  ((void (*)(char *, unint64_t *))v149)(v639, v69);
  uint64_t v269 = v654;
  uint64_t v270 = (*(uint64_t (**)(uint64_t))(v652 + 136))(v654);
  unint64_t v271 = (*(uint64_t (**)(uint64_t))(v651 + 168))(v269);
  uint64_t result = 0LL;
  char v272 = -0.0;
  if ((v271 & 1) == 0) {
    char v272 = 0.0;
  }
  LODWORD(v273) = -2147483647;
  if ((v271 & 1) == 0) {
    uint64_t v273 = COERCE_FLOAT(1);
  }
  if (v270) {
    char v272 = v273;
  }
  *(float *)v643 = v272;
  return result;
}

          unint64_t v182 = 258LL;
LABEL_150:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v182,  0);
        }

        __break(1u);
LABEL_114:
        unint64_t v189 = a3;
        uint64_t v191 = a5;
        uint64_t v200 = a3;
        uint64_t v201 = a4;
        char v202 = a5;
        uint64_t v203 = a6;
        char v204 = closure #3 in _StringGuts.replaceSubrange<A>(_:with:);
        uint64_t v205 = 0LL;
        uint64_t v193 = a6;
        swift_bridgeObjectRetain(a6, v17, v18, v19);
        unint64_t v156 = specialized FlattenSequence<>.startIndex.getter();
        unint64_t v158 = a4;
        unint64_t v160 = specialized FlattenSequence<>.distance(from:to:)(v156, v159, v157 & 1, a4, 0LL, 1);
        uint64_t v161 = (a1 >> 16) + v160;
        if (__OFADD__(a1 >> 16, v160))
        {
          __break(1u);
        }

        else
        {
          a6 = a1 >> 16;
          a2 >>= 16;
          uint64_t v162 = v14 & 0xFFFFFFFFFFFFLL;
          if ((v15 & 0x2000000000000000LL) != 0) {
            uint64_t v162 = HIBYTE(v15) & 0xF;
          }
          BOOL v163 = v162 - a2;
          a3 = v161 + v163;
          if (!__OFADD__(v161, v163))
          {
            a4 = v160;
            if (a3 < 16) {
              goto LABEL_147;
            }
            uint64_t v164 = _StringGuts.uniqueNativeCapacity.getter();
            if ((v165 & 1) == 0 && v164 >= a3) {
              goto LABEL_147;
            }
            a1 = v7;
            char v166 = _StringGuts.uniqueNativeCapacity.getter();
            if ((v167 & 1) != 0)
            {
              char v172 = *(void *)(v7 + 8);
              if ((v172 & 0x1000000000000000LL) != 0)
              {
                uint64_t v168 = String.UTF8View._foreignCount()();
              }

              else if ((v172 & 0x2000000000000000LL) != 0)
              {
                uint64_t v168 = HIBYTE(v172) & 0xF;
              }

              else
              {
                uint64_t v168 = *(void *)v7 & 0xFFFFFFFFFFFFLL;
              }
            }

            else
            {
              uint64_t v168 = 2 * v166;
            }

            if (v168 > a3) {
              a3 = v168;
            }
            uint64_t v173 = *(void *)(v7 + 8);
            if ((v173 & 0x1000000000000000LL) == 0)
            {
              uint64_t v174 = *(void *)v7;
              if ((v173 & 0x2000000000000000LL) != 0)
              {
                unint64_t v177 = (v173 >> 62) & 1;
                uint64_t v194 = *(void *)v7;
                uint64_t v195 = v173 & 0xFFFFFFFFFFFFFFLL;
                uint64_t v175 = (char *)&v194;
                __int128 v176 = HIBYTE(v173) & 0xF;
              }

              else
              {
                if ((v174 & 0x1000000000000000LL) != 0)
                {
                  uint64_t v175 = (char *)((v173 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  __int128 v176 = v174 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  uint64_t v175 = (char *)_StringObject.sharedUTF8.getter(*(void *)v7, v173);
                }

                unint64_t v177 = v174 >> 63;
              }

              char v178 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v175,  v176,  a3,  v177);
              char v179 = *(void *)(v178 + 24);
              swift_bridgeObjectRelease(*(void *)(v7 + 8));
              *(void *)uint64_t v7 = v179;
              *(void *)(v7 + 8) = v178;
              goto LABEL_147;
            }

        if (v97 == v249)
        {
          uint64_t v270 = (uint64_t *)&v268;
          (*(void (**)(void *, uint64_t **))(v249[0] + 24LL))(v249, &v268);
        }

        else
        {
          uint64_t v270 = (uint64_t *)(*(uint64_t (**)(void *))(*v97 + 16LL))(v97);
        }

LABEL_240:
    v378(v339, v236);
    uint64_t v171 = v599;
    goto LABEL_241;
  }

  __break(1u);
LABEL_271:
  else {
    double v249 = v4;
  }
LABEL_274:
  *(double *)v606 = v249;
  return result;
}

uint64_t specialized static BinaryFloatingPoint._convert<A>(from:)( int *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  v643 = a1;
  uint64_t v651 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  v656 = (char *)&v592 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  v639 = (char *)&v592 - v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  v12,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v657 = *(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)
                   + 8);
  uint64_t v630 = *(void *)(v657 + 24);
  v645 = *(char **)(v630 + 16);
  unint64_t v642 = swift_getAssociatedTypeWitness( 0LL,  v645,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v642);
  v641 = (char *)&v592 - v15;
  v649 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v644 = *(v649 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v649);
  v634 = (char *)&v592 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v616 = (char *)&v592 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v650 = (char *)&v592 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v598 = (char *)&v592 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v609 = (char *)&v592 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v610 = (char *)&v592 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v625 = (char *)&v592 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v594 = (char *)&v592 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v602 = (char *)&v592 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v603 = (char *)&v592 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  uint64_t v618 = (char *)&v592 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v632 = (void (*)(uint64_t *, uint64_t))((char *)&v592 - v39);
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v631 = (char *)&v592 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v638 = (unint64_t *)((char *)&v592 - v43);
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  v635 = (char *)&v592 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  v640 = (char *)&v592 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  v596 = (char *)&v592 - v49;
  uint64_t v50 = MEMORY[0x1895F8858](v48);
  v619 = (char *)&v592 - v51;
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  double v607 = (char *)&v592 - v53;
  uint64_t v54 = MEMORY[0x1895F8858](v52);
  uint64_t v623 = (char *)&v592 - v55;
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  v593 = (char *)&v592 - v57;
  uint64_t v58 = MEMORY[0x1895F8858](v56);
  v611 = (char *)&v592 - v59;
  uint64_t v60 = MEMORY[0x1895F8858](v58);
  uint64_t v617 = (char *)&v592 - v61;
  uint64_t v62 = MEMORY[0x1895F8858](v60);
  uint64_t v621 = (char *)&v592 - v63;
  MEMORY[0x1895F8858](v62);
  v658 = (char *)&v592 - v64;
  uint64_t v652 = a4;
  uint64_t v65 = *(void *)(a4 + 16);
  unint64_t v66 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v65,  a3,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v65,  a3,  v66,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  unint64_t v67 = *(char **)(AssociatedConformanceWitness + 8);
  uint64_t v636 = *((void *)v67 + 3);
  v648 = *(const char **)(v636 + 16);
  v646 = (void (*)(void, void, void))swift_getAssociatedTypeWitness( 0LL,  v648,  v66,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v646);
  v647 = (unsigned int (*)(void))((char *)&v592 - v68);
  char v69 = swift_checkMetadataState(0LL, v66);
  uint64_t v655 = *(v69 - 1);
  uint64_t v70 = MEMORY[0x1895F8858](v69);
  char v72 = (char *)&v592 - ((v71 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v73 = MEMORY[0x1895F8858](v70);
  v615 = (char *)&v592 - v74;
  uint64_t v75 = MEMORY[0x1895F8858](v73);
  uint64_t v77 = (char *)&v592 - v76;
  uint64_t v78 = MEMORY[0x1895F8858](v75);
  v601 = (char *)&v592 - v79;
  uint64_t v80 = MEMORY[0x1895F8858](v78);
  v597 = (char *)&v592 - v81;
  uint64_t v82 = MEMORY[0x1895F8858](v80);
  unint64_t v620 = (char *)&v592 - v83;
  uint64_t v84 = MEMORY[0x1895F8858](v82);
  v608 = (char *)&v592 - v85;
  uint64_t v86 = MEMORY[0x1895F8858](v84);
  v633 = (char *)&v592 - v87;
  uint64_t v88 = MEMORY[0x1895F8858](v86);
  v595 = (char *)&v592 - v89;
  uint64_t v90 = MEMORY[0x1895F8858](v88);
  v613 = (char *)&v592 - v91;
  uint64_t v92 = MEMORY[0x1895F8858](v90);
  v604 = (char *)&v592 - v93;
  uint64_t v94 = MEMORY[0x1895F8858](v92);
  uint64_t v622 = (char *)&v592 - v95;
  uint64_t v96 = MEMORY[0x1895F8858](v94);
  v605 = (char *)&v592 - v97;
  uint64_t v98 = MEMORY[0x1895F8858](v96);
  v606 = (char *)&v592 - v99;
  uint64_t v100 = MEMORY[0x1895F8858](v98);
  v599 = (char *)&v592 - v101;
  uint64_t v102 = MEMORY[0x1895F8858](v100);
  v600 = (char *)&v592 - v103;
  uint64_t v104 = MEMORY[0x1895F8858](v102);
  v592 = (char *)&v592 - v105;
  uint64_t v106 = MEMORY[0x1895F8858](v104);
  v627 = (char *)&v592 - v107;
  uint64_t v108 = MEMORY[0x1895F8858](v106);
  v626 = (char *)&v592 - v109;
  uint64_t v110 = MEMORY[0x1895F8858](v108);
  unint64_t v612 = (char *)&v592 - v111;
  uint64_t v112 = MEMORY[0x1895F8858](v110);
  v628 = (char *)&v592 - v113;
  uint64_t v114 = MEMORY[0x1895F8858](v112);
  v629 = (char *)&v592 - v115;
  uint64_t v116 = MEMORY[0x1895F8858](v114);
  uint64_t v118 = (char *)&v592 - v117;
  uint64_t v119 = MEMORY[0x1895F8858](v116);
  v637 = (char *)&v592 - v120;
  uint64_t v121 = MEMORY[0x1895F8858](v119);
  unint64_t v123 = (char *)&v592 - v122;
  MEMORY[0x1895F8858](v121);
  uint64_t v125 = (char *)&v592 - v124;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 384))(a3, v65) & 1) != 0)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(a3, v65) & 1) == 0)
    {
      int *v643 = 0;
      return 1LL;
    }

    unsigned int v573 = 0x80000000;
    v548 = (unsigned int *)v643;
    goto LABEL_275;
  }

  char v126 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 376))(a3, v65);
  v653 = a2;
  if ((v126 & 1) == 0)
  {
    uint64_t v571 = v65;
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 400))(a3, v65) & 1) == 0)
    {
      uint64_t v574 = v652;
      v575 = *(void (**)(uint64_t, uint64_t))(v652 + 120);
      v575(a3, v652);
      v576 = v639;
      (*(void (**)(uint64_t, uint64_t))(v65 + 96))(a3, v65);
      v577 = v616;
      v575(a3, v574);
      v578 = *(void (**)(char *, uint64_t))(v651 + 8);
      v578(v576, a3);
      v579 = (char *)v656;
      (*(void (**)(uint64_t, uint64_t))(v571 + 104))(a3, v571);
      v580 = v634;
      v575(a3, v574);
      v578(v579, a3);
      uint64_t v581 = v657;
      v582 = v631;
      v583 = v649;
      (*(void (**)(char *, char *, unint64_t *, uint64_t))(v657 + 208))(v577, v580, v649, v657);
      v584 = *(void (**)(char *, unint64_t *))(v644 + 8);
      v584(v580, v583);
      v584(v577, v583);
      v585 = v638;
      (*(void (**)(char *, unint64_t *, uint64_t))(v581 + 184))(v582, v583, v581);
      v584(v582, v583);
      v586 = v650;
      v587 = v658;
      (*(void (**)(char *, unint64_t *, unint64_t *, uint64_t))(v581 + 192))( v658,  v585,  v583,  v581);
      v584((char *)v585, v583);
      v584(v587, v583);
      LODWORD(v581) = (*(uint64_t (**)(unint64_t *, uint64_t))(v581 + 120))(v583, v581);
      v584(v586, v583);
      LODWORD(v584) = v581 & 0x1FFFFF;
      LOBYTE(v581) = (*(uint64_t (**)(uint64_t, uint64_t))(v571 + 416))(a3, v571);
      int v588 = (*(uint64_t (**)(uint64_t, uint64_t))(v571 + 168))(a3, v571);
      uint64_t result = 0LL;
      unsigned int v589 = v584 | (v588 << 31);
      if ((v581 & 1) != 0) {
        int v590 = 2141192192;
      }
      else {
        int v590 = 2143289344;
      }
      int v190 = v589 | v590;
      goto LABEL_89;
    }

    char v572 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(a3, v65);
    v548 = (unsigned int *)v643;
    if ((v572 & 1) != 0)
    {
LABEL_274:
      unsigned int v573 = -8388608;
      goto LABEL_275;
    }

    unsigned int v573 = 2139095040;
LABEL_275:
    unsigned int *v548 = v573;
    return 1LL;
  }

  v616 = v77;
  uint64_t v127 = *(void (**)(uint64_t, uint64_t))(v65 + 176);
  uint64_t v654 = a3;
  uint64_t v651 = v65;
  v127(a3, v65);
  int64_t v660 = -126LL;
  __int16 v128 = (uint64_t (*)(unint64_t *, char *))*((void *)v67 + 8);
  char v129 = v128(v69, v67);
  v656 = (const char *)v128;
  uint64_t v130 = (uint64_t)v125;
  v650 = v123;
  unint64_t v624 = v118;
  if ((v129 & 1) != 0)
  {
    uint64_t v131 = (uint64_t (*)(unint64_t *, char *))*((void *)v67 + 16);
    uint64_t v132 = v131(v69, v67);
    if (v132 < 64)
    {
      uint64_t v135 = v655;
      unint64_t v136 = v650;
      (*(void (**)(char *, char *, unint64_t *))(v655 + 16))(v650, v125, v69);
      goto LABEL_14;
    }

    int v146 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
    unint64_t v147 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
    unint64_t v142 = v650;
    v146(&v660, &type metadata for Int, v147, v69, v67);
    char v145 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL) + 16LL))( v125,  v142,  v69);
LABEL_10:
    char v148 = v145;
    unsigned __int8 v149 = *(const char **)(v655 + 8);
    ((void (*)(char *, unint64_t *))v149)(v142, v69);
    if ((v148 & 1) == 0) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }

  char v137 = v128(v69, v67);
  uint64_t v138 = (uint64_t (*)(unint64_t *, char *))*((void *)v67 + 16);
  v639 = v125;
  uint64_t v139 = v138(v69, v67);
  if ((v137 & 1) == 0)
  {
    uint64_t v131 = v138;
    uint64_t v135 = v655;
    unint64_t v150 = *(void (**)(char *, char *, unint64_t *))(v655 + 16);
    if (v139 >= 64)
    {
      uint64_t v130 = (uint64_t)v639;
      v150(v72, v639, v69);
      unsigned __int8 v149 = *(const char **)(v135 + 8);
      ((void (*)(char *, unint64_t *))v149)(v72, v69);
      goto LABEL_25;
    }

    unint64_t v136 = v650;
    uint64_t v130 = (uint64_t)v639;
    v150(v650, v639, v69);
LABEL_14:
    uint64_t v151 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
    unsigned __int8 v149 = *(const char **)(v135 + 8);
    ((void (*)(char *, unint64_t *))v149)(v136, v69);
    if (v151 >= v660) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }

  if (v139 > 64)
  {
    unint64_t v142 = v123;
    uint64_t v131 = v138;
    int v143 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
    unint64_t v144 = lazy protocol witness table accessor for type Int and conformance Int(v139, v140, v141);
    v143(&v660, &type metadata for Int, v144, v69, v67);
    uint64_t v130 = (uint64_t)v639;
    char v145 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL) + 16LL))( v639,  v142,  v69);
    goto LABEL_10;
  }

  uint64_t v152 = v648;
  unint64_t v153 = v646;
  unint64_t v154 = swift_getAssociatedConformanceWitness( (uint64_t)v648,  (uint64_t)v69,  (uint64_t)v646,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v155 = v647;
  (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v154 + 8))( &qword_18180BE68,  256LL,  v153,  v154);
  (*((void (**)(unsigned int (*)(void), unint64_t *, const char *))v152 + 3))( v155,  v69,  v152);
  unint64_t v156 = v639;
  LOBYTE(v152) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                               + 16LL))( v639,  v123,  v69);
  uint64_t v157 = v655;
  unsigned __int8 v149 = *(const char **)(v655 + 8);
  ((void (*)(char *, unint64_t *))v149)(v123, v69);
  unint64_t v158 = *(void (**)(char *, char *, unint64_t *))(v157 + 16);
  uint64_t v159 = v615;
  v158(v615, v156, v69);
  if ((v152 & 1) != 0)
  {
    uint64_t v131 = v138;
    ((void (*)(char *, unint64_t *))v149)(v159, v69);
    uint64_t v130 = (uint64_t)v639;
  }

  else
  {
    v634 = (char *)v138;
    unint64_t v160 = v149;
    int64_t v161 = v660;
    uint64_t v162 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
    ((void (*)(char *, unint64_t *))v160)(v159, v69);
    BOOL v163 = v162 < v161;
    unsigned __int8 v149 = v160;
    uint64_t v131 = (uint64_t (*)(unint64_t *, char *))v634;
    uint64_t v130 = (uint64_t)v639;
    if (!v163)
    {
LABEL_25:
      int64_t v660 = 127LL;
      char v178 = ((uint64_t (*)(unint64_t *, char *))v656)(v69, v67);
      uint64_t v179 = v130;
      uint64_t v180 = v131;
      uint64_t v181 = v131(v69, v67);
      if ((v178 & 1) != 0)
      {
        uint64_t v169 = (float *)v650;
        if (v181 > 64)
        {
          uint64_t v184 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
          unint64_t v185 = lazy protocol witness table accessor for type Int and conformance Int(v181, v182, v183);
          v184(&v660, &type metadata for Int, v185, v69, v67);
          char v186 = (*(uint64_t (**)(float *, uint64_t, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                 + 16LL))( v169,  v130,  v69);
          uint64_t v187 = (uint64_t)v169;
          goto LABEL_37;
        }
      }

      else
      {
        uint64_t v169 = (float *)v650;
        if (v181 > 63)
        {
          uint64_t v659 = 127LL;
          uint64_t v130 = (uint64_t)v616;
          uint64_t v194 = (*(uint64_t (**)(char *, uint64_t, unint64_t *))(v655 + 16))(v616, v179, v69);
          uint64_t v195 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
          unint64_t v198 = lazy protocol witness table accessor for type Int and conformance Int(v194, v196, v197);
          v195(&v659, &type metadata for Int, v198, v69, v67);
          char v186 = (*(uint64_t (**)(float *, uint64_t, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                 + 16LL))( v169,  v130,  v69);
          ((void (*)(float *, unint64_t *))v149)(v169, v69);
          uint64_t v187 = v130;
LABEL_37:
          ((void (*)(uint64_t, unint64_t *))v149)(v187, v69);
          if ((v186 & 1) == 0)
          {
LABEL_38:
            uint64_t v199 = v656;
            if ((((uint64_t (*)(unint64_t *, char *))v656)(v69, v67) & 1) != 0)
            {
              uint64_t v200 = v180(v69, v67);
              unint64_t v203 = v655;
              if (v200 < 64)
              {
LABEL_50:
                (*(void (**)(float *, uint64_t, unint64_t *))(v203 + 16))(v169, v179, v69);
                uint64_t v209 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                uint64_t v210 = v169;
LABEL_51:
                ((void (*)(float *, unint64_t *))v149)(v210, v69);
                if ((v209 & 0x8000000000000000LL) == 0)
                {
LABEL_52:
                  uint64_t v211 = v633;
                  (*(void (**)(char *, uint64_t, unint64_t *))(v203 + 32))(v633, v179, v69);
                  if ((((uint64_t (*)(unint64_t *, char *))v656)(v69, v67) & 1) != 0)
                  {
                    uint64_t v212 = v608;
                    (*(void (**)(char *, char *, unint64_t *))(v203 + 16))(v608, v211, v69);
                    char v213 = v648;
                    char v214 = v646;
                    unint64_t v215 = swift_getAssociatedConformanceWitness( (uint64_t)v648,  (uint64_t)v69,  (uint64_t)v646,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    uint64_t v216 = v647;
                    (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v215 + 8))( &qword_18180BE68,  256LL,  v214,  v215);
                    (*((void (**)(unsigned int (*)(void), unint64_t *, const char *))v213
                     + 3))( v216,  v69,  v213);
                    LOBYTE(v213) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                                  + 32LL))( v212,  v169,  v69);
                    ((void (*)(float *, unint64_t *))v149)(v169, v69);
                    ((void (*)(char *, unint64_t *))v149)(v212, v69);
                    unint64_t v203 = v655;
                    uint64_t v211 = v633;
                  }

                  if (v180(v69, v67) < 64)
                  {
LABEL_132:
                    v302 = v658;
                    uint64_t v303 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                    v304 = v211;
                    unint64_t v305 = v303;
                    ((void (*)(char *, unint64_t *))v149)(v304, v69);
                    uint64_t v306 = (unsigned int (*)(void))(v305 + 127);
                    if (v305 >= 0xFFFFFFFFFFFFFF81LL)
                    {
                      __break(1u);
LABEL_134:
                      unint64_t v307 = v647;
                      v632(&qword_18180BE68, 256LL);
                      ((void (*)(unsigned int (*)(void), unint64_t *, const char *))v625)( v307,  v69,  v648);
                      char v308 = v612;
                      LOBYTE(v307) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL) + 16LL))( v612,  v169,  v69);
                      ((void (*)(float *, unint64_t *))v149)(v169, v69);
                      v309 = v592;
                      ((void (*)(char *, char *, unint64_t *))v203)(v592, v308, v69);
                      if ((v307 & 1) != 0)
                      {
                        ((void (*)(char *, unint64_t *))v149)(v309, v69);
                      }

                      else
                      {
                        int64_t v310 = v660;
                        uint64_t v311 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                        ((void (*)(char *, unint64_t *))v149)(v309, v69);
                        BOOL v163 = v311 < v310;
                        unint64_t v279 = v629;
                        int64_t v288 = v612;
                        if (!v163) {
                          goto LABEL_136;
                        }
                      }

LABEL_201:
                  v647 = v306;
                  unsigned __int8 v149 = v653;
                  uint64_t v430 = v654;
                  uint64_t v431 = v652;
                  unint64_t v432 = *(const char **)(v652 + 136);
                  uint64_t v433 = ((uint64_t (*)(uint64_t, uint64_t))v432)(v654, v652);
                  v434 = *(void (**)(uint64_t, uint64_t))(v431 + 120);
                  v435 = v302;
                  v434(v430, v431);
                  uint64_t v436 = v657;
                  v437 = v649;
                  v639 = *(char **)(v657 + 144);
                  uint64_t v438 = ((uint64_t (*)(unint64_t *, uint64_t))v639)(v649, v657);
                  v656 = *(const char **)(v644 + 8);
                  ((void (*)(const char *, unint64_t *))v656)(v435, v437);
                  uint64_t v655 = 23 - v433 - v438;
                  LOBYTE(v433) = (*(uint64_t (**)(uint64_t))(v651 + 392))(v430);
                  char v439 = v645;
                  unint64_t v203 = v642;
                  unint64_t v440 = swift_getAssociatedConformanceWitness( (uint64_t)v645,  (uint64_t)v437,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  uint64_t v441 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v440 + 8);
                  v650 = (char *)v434;
                  v648 = v432;
                  if ((v433 & 1) != 0)
                  {
                    uint64_t v442 = v641;
                    v441(&qword_18180BE70, 512LL, v203, v440);
                    v646 = (void (*)(void, void, void))*((void *)v439 + 3);
                    v646(v442, v437, v439);
                    uint64_t v443 = v652;
                    uint64_t v444 = ((uint64_t (*)(uint64_t, uint64_t))v432)(v430, v652);
                    unint64_t v445 = v638;
                    v434(v430, v443);
                    uint64_t v446 = ((uint64_t (*)(unint64_t *, uint64_t))v639)(v437, v436);
                    unint64_t v203 = v642;
                    unsigned __int8 v149 = v656;
                    uint64_t v447 = ((uint64_t (*)(unint64_t *, unint64_t *))v656)(v445, v437);
                    int64_t v660 = v446 + v444;
                    v448 = *(void (**)(char *, int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v436 + 256);
                    unint64_t v451 = lazy protocol witness table accessor for type Int and conformance Int(v447, v449, v450);
                    uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v632;
                    v448(v658, &v660, &type metadata for Int, v451, v437, v436);
                    ((void (*)(char *, unint64_t *))v149)(v658, v437);
                    v302 = v149;
                    uint64_t v130 = v655;
                    if ((v655 & 0x8000000000000000LL) == 0) {
                      goto LABEL_203;
                    }
                  }

                  else
                  {
                    v485 = v641;
                    v441(&qword_18180BE68, 256LL, v203, v440);
                    uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v632;
                    v646 = (void (*)(void, void, void))*((void *)v439 + 3);
                    v646(v485, v437, v439);
                    v302 = v656;
                    uint64_t v130 = v655;
                    if ((v655 & 0x8000000000000000LL) == 0)
                    {
LABEL_203:
                      unint64_t v452 = v658;
                      ((void (*)(uint64_t, uint64_t))v650)(v654, v652);
                      uint64_t v453 = v657;
                      v454 = v625;
                      (*(void (**)(uint64_t (*)(unint64_t *, char *), char *, unint64_t *, uint64_t))(v657 + 224))( v180,  v452,  v437,  v657);
                      ((void (*)(char *, unint64_t *))v302)(v452, v437);
                      ((void (*)(uint64_t (*)(unint64_t *, char *), unint64_t *))v302)( v180,  v437);
                      v356 = v437;
                      v455 = v454;
                      v456 = *(uint64_t (**)(unint64_t *, uint64_t))(v453 + 64);
                      if ((v456(v356, v453) & 1) != 0)
                      {
                        uint64_t v457 = v302;
                        uint64_t v458 = v610;
                        (*(void (**)(char *, char *, unint64_t *))(v644 + 16))(v610, v455, v356);
                        unint64_t v459 = swift_getAssociatedConformanceWitness( (uint64_t)v439,  (uint64_t)v356,  v203,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                        v460 = v641;
                        unint64_t v461 = v203;
                        v462 = v458;
                        v302 = v457;
                        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v459 + 8))( &qword_18180BE68,  256LL,  v461,  v459);
                        char v463 = v658;
                        v646(v460, v356, v439);
                        char v464 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v453 + 32) + 8LL)
                                                                                             + 32LL))( v462,  v463,  v356);
                        ((void (*)(char *, unint64_t *))v302)(v463, v356);
                        if ((v464 & 1) == 0) {
                          goto LABEL_272;
                        }
                        ((void (*)(char *, unint64_t *))v302)(v462, v356);
                        uint64_t v453 = v657;
                        uint64_t v130 = v655;
                      }

                      v465 = *(uint64_t (**)(unint64_t *, uint64_t))(v453 + 128);
                      if (v465(v356, v453) < 32) {
                        goto LABEL_236;
                      }
                      unint64_t v466 = v455;
                      unint64_t v467 = *(void (**)(char *, char *, unint64_t *))(v644 + 16);
                      v468 = v609;
                      v467(v609, v466, v356);
                      LODWORD(v66specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = -1;
                      char v469 = v456(v356, v453);
                      uint64_t v470 = v453;
                      char v471 = v469;
                      uint64_t v472 = v465(v356, v470);
                      if ((v471 & 1) != 0)
                      {
                        if (v472 <= 32)
                        {
                          unint64_t v475 = v642;
                          unint64_t v476 = swift_getAssociatedConformanceWitness( (uint64_t)v439,  (uint64_t)v356,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          uint64_t v477 = v641;
                          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v476 + 8))( &qword_18180BE68,  256LL,  v475,  v476);
                          uint64_t v478 = v658;
                          v646(v477, v356, v439);
                          uint64_t v479 = v657;
                          LOBYTE(v477) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v657 + 32) + 8LL) + 40LL))( v468,  v478,  v356);
                          v480 = v656;
                          ((void (*)(char *, unint64_t *))v656)(v478, v356);
                          unsigned int v481 = v660;
                          unint64_t v482 = v598;
                          v467(v598, v468, v356);
                          if ((v477 & 1) == 0)
                          {
                            ((void (*)(char *, unint64_t *))v480)(v482, v356);
                            char v439 = v645;
                            v455 = v625;
LABEL_235:
                            ((void (*)(char *, unint64_t *))v480)(v468, v356);
                            uint64_t v453 = v657;
                            v302 = v480;
LABEL_236:
                            int v534 = (*(uint64_t (**)(unint64_t *, uint64_t))(v453 + 120))(v356, v453);
                            ((void (*)(char *, unint64_t *))v302)(v455, v356);
                            else {
                              uint64_t v535 = 0LL;
                            }
                            uint64_t v130 = 23LL;
                            uint64_t v492 = v657;
                            goto LABEL_243;
                          }

                          unsigned int v483 = (*(uint64_t (**)(unint64_t *, uint64_t))(v479 + 120))(v356, v479);
                          ((void (*)(char *, unint64_t *))v480)(v482, v356);
                          BOOL v484 = v481 >= v483;
                          char v439 = v645;
LABEL_228:
                          v455 = v625;
                          if (!v484) {
                            goto LABEL_232;
                          }
                          goto LABEL_235;
                        }
                      }

                      else if (v472 <= 32)
                      {
                        v530 = v658;
                        v467(v658, v468, v356);
                        unsigned int v531 = (*(uint64_t (**)(unint64_t *))(v657 + 120))(v356);
                        v480 = v656;
                        ((void (*)(char *, unint64_t *))v656)(v530, v356);
                        BOOL v484 = v660 >= v531;
                        goto LABEL_228;
                      }

                      uint64_t v521 = v657;
                      v522 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v657 + 96);
                      unint64_t v523 = lazy protocol witness table accessor for type UInt32 and conformance UInt32( v472,  v473,  v474);
                      v524 = v658;
                      v522(&v660, &type metadata for UInt32, v523, v356, v521);
                      LOBYTE(v522) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v521 + 32) + 8LL) + 16LL))( v524,  v468,  v356);
                      uint64_t v525 = v524;
                      v480 = v656;
                      ((void (*)(char *, unint64_t *))v656)(v525, v356);
                      v455 = v625;
                      goto LABEL_235;
                    }
                  }

                  v336 = v638;
                  ((void (*)(uint64_t, uint64_t))v650)(v654, v652);
                  unint64_t v67 = v658;
                  (*(void (**)(uint64_t (*)(unint64_t *, char *), unint64_t *, unint64_t *))(v657 + 224))( v180,  v336,  v437);
                  ((void (*)(unint64_t *, unint64_t *))v302)(v336, v437);
                  uint64_t v486 = ((uint64_t (*)(void, unint64_t *))v302)(v180, v437);
                  if (!__OFSUB__(0LL, v130))
                  {
                    int64_t v660 = -v130;
                    v489 = *(void (**)(char *, int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v657 + 240);
                    unint64_t v490 = lazy protocol witness table accessor for type Int and conformance Int(v486, v487, v488);
                    v491 = v618;
                    v489(v67, &v660, &type metadata for Int, v490, v437, v657);
                    uint64_t v492 = v657;
                    ((void (*)(char *, unint64_t *))v302)(v67, v437);
                    v356 = v437;
                    unint64_t v493 = v491;
                    unint64_t v494 = *(uint64_t (**)(unint64_t *, uint64_t))(v492 + 64);
                    if ((v494(v356, v492) & 1) != 0)
                    {
                      uint64_t v495 = v603;
                      (*(void (**)(char *, char *, unint64_t *))(v644 + 16))(v603, v493, v356);
                      unint64_t v496 = swift_getAssociatedConformanceWitness( (uint64_t)v439,  (uint64_t)v356,  v203,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                      uint64_t v497 = v641;
                      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v496 + 8))( &qword_18180BE68,  256LL,  v203,  v496);
                      uint64_t v498 = v658;
                      v646(v497, v356, v439);
                      char v499 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v492 + 32) + 8LL)
                                                                                           + 32LL))( v495,  v498,  v356);
                      v500 = v656;
                      ((void (*)(char *, unint64_t *))v656)(v498, v356);
                      if ((v499 & 1) == 0) {
                        goto LABEL_272;
                      }
                      ((void (*)(char *, unint64_t *))v500)(v495, v356);
                      uint64_t v492 = v657;
                    }

                    __int16 v501 = *(uint64_t (**)(unint64_t *, uint64_t))(v492 + 128);
                    if (v501(v356, v492) < 32) {
                      goto LABEL_242;
                    }
                    uint64_t v502 = v493;
                    unint64_t v503 = *(void (**)(char *, char *, unint64_t *))(v644 + 16);
                    v504 = v602;
                    v503(v602, v502, v356);
                    LODWORD(v66specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = -1;
                    char v505 = v494(v356, v492);
                    uint64_t v506 = v492;
                    char v507 = v505;
                    uint64_t v508 = v501(v356, v506);
                    if ((v507 & 1) != 0)
                    {
                      uint64_t v511 = v656;
                      if (v508 <= 32)
                      {
                        unint64_t v512 = v642;
                        unint64_t v513 = swift_getAssociatedConformanceWitness( (uint64_t)v439,  (uint64_t)v356,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                        v514 = v641;
                        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v513 + 8))( &qword_18180BE68,  256LL,  v512,  v513);
                        v515 = v658;
                        v646(v514, v356, v439);
                        uint64_t v516 = v657;
                        LOBYTE(v514) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v657 + 32) + 8LL) + 40LL))( v504,  v515,  v356);
                        ((void (*)(char *, unint64_t *))v511)(v515, v356);
                        unsigned int v517 = v660;
                        uint64_t v518 = v594;
                        v503(v594, v504, v356);
                        if ((v514 & 1) != 0)
                        {
                          unsigned int v519 = (*(uint64_t (**)(unint64_t *, uint64_t))(v516 + 120))(v356, v516);
                          ((void (*)(char *, unint64_t *))v511)(v518, v356);
                          BOOL v520 = v517 >= v519;
                          char v439 = v645;
                          goto LABEL_231;
                        }

                        ((void (*)(char *, unint64_t *))v511)(v518, v356);
                        char v439 = v645;
                        unint64_t v493 = v618;
LABEL_241:
                        ((void (*)(char *, unint64_t *))v511)(v504, v356);
                        uint64_t v492 = v657;
LABEL_242:
                        uint64_t v535 = (*(uint64_t (**)(unint64_t *, uint64_t))(v492 + 120))(v356, v492);
                        v302 = v656;
                        ((void (*)(char *, unint64_t *))v656)(v493, v356);
                        uint64_t v130 = 23LL;
LABEL_243:
                        unsigned __int8 v537 = v647;
                        unint64_t v536 = v648;
LABEL_248:
                        uint64_t v538 = v654;
                        v647 = *(unsigned int (**)(void))(v651 + 168);
                        int v539 = (v537 << 23) | (v647(v654) << 31) | v535 & 0x7FFFFF;
                        if (v130 < ((uint64_t (*)(uint64_t, uint64_t))v536)(v538, v652))
                        {
                          uint64_t v644 = v535;
                          v540 = v439;
                          unint64_t v541 = v642;
                          unint64_t v542 = swift_getAssociatedConformanceWitness( (uint64_t)v439,  (uint64_t)v356,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          v543 = v641;
                          v648 = *(const char **)(v542 + 8);
                          ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v648)( &qword_18180BE70,  512LL,  v541,  v542);
                          v544 = (uint64_t (*)(char *, unint64_t *, const char *))*((void *)v540 + 3);
                          uint64_t v545 = v544(v543, v356, v540);
                          if (!__OFSUB__(0LL, v655))
                          {
                            LODWORD(v646) = v539;
                            int64_t v660 = -v655;
                            uint64_t v655 = (uint64_t)v544;
                            v549 = *(void (**)(char *, int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v492 + 256);
                            unint64_t v550 = lazy protocol witness table accessor for type Int and conformance Int( v545,  v546,  v547);
                            v549(v658, &v660, &type metadata for Int, v550, v356, v492);
                            ((void (*)(char *, unint64_t *))v302)(v658, v356);
                            uint64_t v551 = v356;
                            ((void (*)(uint64_t, uint64_t))v650)(v654, v652);
                            ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v648)( &qword_18180BE70,  512LL,  v541,  v542);
                            uint64_t v552 = v631;
                            ((void (*)(char *, unint64_t *, const char *))v655)(v543, v551, v540);
                            unint64_t v553 = v542;
                            uint64_t v554 = v638;
                            uint64_t v555 = v640;
                            (*(void (**)(char *, char *, unint64_t *))(*(void *)(v630 + 8) + 40LL))( v640,  v552,  v551);
                            ((void (*)(char *, unint64_t *))v302)(v552, v551);
                            uint64_t v556 = v635;
                            (*(void (**)(char *, unint64_t *, unint64_t *, uint64_t))(v492 + 192))( v658,  v554,  v551,  v492);
                            ((void (*)(unint64_t *, unint64_t *))v302)(v554, v551);
                            ((void (*)(char *, unint64_t *))v302)(v658, v551);
                            unint64_t v557 = v541;
                            uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v658;
                            uint64_t v652 = v553;
                            unint64_t v558 = v553;
                            unint64_t v203 = (unint64_t)v648;
                            ((void (*)(void *, uint64_t, unint64_t, unint64_t))v648)( &unk_18180BE80,  768LL,  v557,  v558);
                            ((void (*)(char *, unint64_t *, char *))v655)(v543, v551, v645);
                            v559 = v555;
                            v560 = v555;
                            v561 = *(void (**)(char *, unint64_t *, unint64_t *, uint64_t))(v492 + 152);
                            v561(v560, v554, v551, v492);
                            v562 = v554;
                            v563 = v556;
                            ((void (*)(unint64_t *, unint64_t *))v302)(v562, v551);
                            unint64_t v67 = *(char **)(*(void *)(v492 + 32) + 8LL);
                            char v564 = (*((uint64_t (**)(char *, uint64_t (*)(unint64_t *, char *), unint64_t *, char *))v67
                                    + 2))( v563,  v180,  v551,  v67);
                            ((void (*)(uint64_t (*)(unint64_t *, char *), unint64_t *))v302)( v180,  v551);
                            if ((v564 & 1) != 0)
                            {
                              ((void (*)(char *, unint64_t *))v302)(v563, v551);
                              ((void (*)(char *, unint64_t *))v302)(v559, v551);
                              uint64_t result = 0LL;
                              int *v643 = (int)v646;
                              return result;
                            }

                            v656 = v302;
                            float v4 = *(float *)&v646;
                            if ((((uint64_t (*)(uint64_t, uint64_t))v647)(v654, v651) & 1) != 0)
                            {
                              float v565 = 0.0 - v4;
                              v336 = v649;
                              unsigned __int8 v149 = v645;
                              v302 = v640;
                              uint64_t v130 = (uint64_t)v561;
                              uint64_t v169 = (float *)v643;
                              float v5 = -v565;
LABEL_260:
                              v566 = v641;
                              ((void (*)(void *, uint64_t))v203)(&unk_18180BE80, 768LL);
                              v567 = v638;
                              ((void (*)(char *, unint64_t *, const char *))v655)(v566, v336, v149);
                              ((void (*)(const char *, unint64_t *, unint64_t *, uint64_t))v130)( v302,  v567,  v336,  v657);
                              v568 = v656;
                              ((void (*)(unint64_t *, unint64_t *))v656)(v567, v336);
                              ((void (*)(const char *, unint64_t *))v568)(v302, v336);
                              v569 = v635;
                              char v570 = (*((uint64_t (**)(char *, uint64_t (*)(unint64_t *, char *), unint64_t *, char *))v67
                                      + 5))( v635,  v180,  v336,  v67);
                              ((void (*)(uint64_t (*)(unint64_t *, char *), unint64_t *))v568)( v180,  v336);
                              ((void (*)(char *, unint64_t *))v568)(v569, v336);
                              uint64_t result = 0LL;
                              if ((v570 & 1) != 0)
                              {
                                *uint64_t v169 = v5;
                                return result;
                              }

                              goto LABEL_277;
                            }

                            float v5 = v4 + 0.0;
                            v336 = v649;
                            unsigned __int8 v149 = v645;
                            v302 = v640;
                            uint64_t v130 = (uint64_t)v561;
                            if ((float)(v4 + 0.0) < INFINITY)
                            {
                              LODWORD(v5) += (SLODWORD(v5) >> 31) | 1;
                              uint64_t v169 = (float *)v643;
                              goto LABEL_260;
                            }

              uint64_t v209 = 258LL;
              goto LABEL_202;
            }

                uint64_t v164 = startingAta << 16;
                BOOL v163 = 1LL;
              }

        ++v86;
        v85 += 24LL;
        if (v64 == v86) {
          goto LABEL_175;
        }
      }

      if ((_DWORD)v88 != 2) {
        goto LABEL_211;
      }
      uint64_t v88 = 2LL;
LABEL_206:
      if (v88 <= v86) {
        goto LABEL_211;
      }
      goto LABEL_207;
    case 5:
      uint64_t v64 = *((unsigned int *)v63 + 2);
      if ((_DWORD)v64) {
        goto LABEL_200;
      }
      break;
    case 2:
      uint64_t v64 = 2LL;
      goto LABEL_200;
  }

  swift::Demangle::__runtime::keyPathSourceString(char const*,unsigned long)::$_0::operator()( (uint64_t **)&v153,  0LL,  &v151);
  std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&v151, (uint64_t)&v159, &__p);
  size = __p.__r_.__value_.__s.__size_;
  uint64_t v71 = __p.__r_.__value_.__l.__size_;
  char v72 = (__p.__r_.__value_.__s.__size_ & 0x80u) != 0;
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
LABEL_168:
  if (v72) {
    uint64_t v74 = v71;
  }
  else {
    uint64_t v74 = size;
  }
  std::string::append(&v157, (const std::string::value_type *)p_p, v74);
LABEL_175:
  uint64_t v75 = (char)v157.__r_.__value_.__s.__size_;
  if ((v157.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v76 = v157.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v76 = v157.__r_.__value_.__l.__size_;
  }
  uint64_t v77 = v76 + 1;
  if (v76 + 1 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_352:
  }
    abort();
  if (v77 >= 0x17)
  {
    uint64_t v78 = (v77 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v77 | 7) != 0x17) {
      uint64_t v78 = v77 | 7;
    }
    uint64_t v79 = v78 + 1;
    uint64_t v80 = (char *)operator new(v78 + 1);
    *((void *)a3 + 1) = v77;
    *((void *)a3 + 2) = v79 | 0x8000000000000000LL;
    *(void *)a3 = v80;
    a3 = v80;
    goto LABEL_185;
  }

  *((void *)a3 + 1) = 0LL;
  *((void *)a3 + 2) = 0LL;
  *(void *)a3 = 0LL;
  a3[23] = v77;
  if (v76)
  {
LABEL_185:
    if (v75 >= 0) {
      uint64_t v81 = &v157;
    }
    else {
      uint64_t v81 = (std::string *)v157.__r_.__value_.__r.__words[0];
    }
    memmove(a3, v81, v76);
  }

  *(_WORD *)&a3[v76] = 41;
  uint64_t v82 = (char *)v154;
  if (v154)
  {
    uint64_t v83 = v155;
    uint64_t v84 = v154;
    if (v155 != v154)
    {
      do
      {
        if (*(v83 - 1) < 0) {
          operator delete(*((void **)v83 - 3));
        }
        v83 -= 24;
      }

      while (v83 != v82);
      uint64_t v84 = v154;
    }

    uint64_t v155 = v82;
    operator delete(v84);
    LOBYTE(v75) = v157.__r_.__value_.__s.__size_;
  }

  if ((v75 & 0x80) != 0) {
    operator delete(v157.__r_.__value_.__l.__data_);
  }
LABEL_34:
  swift::Demangle::__runtime::Context::~Context((swift::Demangle::__runtime::Context *)v158);
  if (v161 < 0) {
    operator delete(v159);
  }
}

LABEL_284:
                            uint64_t v169 = (float *)v643;
                            goto LABEL_260;
                          }

                          __break(1u);
                          goto LABEL_274;
                        }

                        int *v643 = v539;
                        return 1LL;
                      }
                    }

                    else
                    {
                      uint64_t v511 = v656;
                      if (v508 <= 32)
                      {
                        v532 = v658;
                        v503(v658, v504, v356);
                        unsigned int v533 = (*(uint64_t (**)(unint64_t *))(v657 + 120))(v356);
                        ((void (*)(char *, unint64_t *))v511)(v532, v356);
                        BOOL v520 = v660 >= v533;
LABEL_231:
                        unint64_t v493 = v618;
                        if (!v520)
                        {
LABEL_232:
                          unint64_t v324 = 3455LL;
LABEL_233:
                          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  v324,  0);
                        }

                        goto LABEL_241;
                      }
                    }

                    uint64_t v526 = v657;
                    v527 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v657 + 96);
                    unint64_t v528 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v508, v509, v510);
                    double v529 = v658;
                    v527(&v660, &type metadata for UInt32, v528, v356, v526);
                    LOBYTE(v527) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v526 + 32) + 8LL)
                                                                                                 + 16LL))( v529,  v504,  v356);
                    ((void (*)(char *, unint64_t *))v511)(v529, v356);
                    unint64_t v493 = v618;
                    goto LABEL_241;
                  }

        int64_t v310 = 258LL;
      }

      else
      {
        if (v233 > 15)
        {
LABEL_210:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v233, 1LL);
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          uint64_t v314 = xmmword_1817FFFB0;
          unint64_t v237 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v314, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v237, v238, 1);
          uint64_t v239 = 0xE100000000000000LL;
          goto LABEL_217;
        }

LABEL_282:
                  __break(1u);
                  goto LABEL_283;
                }

                unint64_t v203 = *(void *)(v203 + 16);
                ((void (*)(char *, char *, unint64_t *))v203)(v613, v239, v69);
                int64_t v660 = -1LL;
                char v245 = ((uint64_t (*)(unint64_t *, char *))v656)(v69, v67);
                uint64_t v246 = v180(v69, v67);
                if ((v245 & 1) != 0)
                {
                  if (v246 <= 64)
                  {
                    double v249 = v648;
                    double v250 = v646;
                    unint64_t v251 = swift_getAssociatedConformanceWitness( (uint64_t)v648,  (uint64_t)v69,  (uint64_t)v646,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    uint64_t v252 = v647;
                    (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v251 + 8))( &qword_18180BE68,  256LL,  v250,  v251);
                    (*((void (**)(unsigned int (*)(void), unint64_t *, const char *))v249
                     + 3))( v252,  v69,  v249);
                    uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v613;
                    LOBYTE(v249) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                                  + 40LL))( v613,  v169,  v69);
                    ((void (*)(float *, unint64_t *))v149)(v169, v69);
                    unint64_t v253 = v660;
                    uint64_t v254 = v595;
                    ((void (*)(char *, uint64_t (*)(unint64_t *, char *), unint64_t *))v203)( v595,  v180,  v69);
                    if ((v249 & 1) != 0)
                    {
                      unint64_t v255 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                      ((void (*)(char *, unint64_t *))v149)(v254, v69);
                      if (v253 < v255) {
                        goto LABEL_232;
                      }
                    }

                    else
                    {
                      ((void (*)(char *, unint64_t *))v149)(v254, v69);
                    }

                    goto LABEL_199;
                  }
                }

                else if (v246 <= 64)
                {
                  uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v613;
                  ((void (*)(float *, char *, unint64_t *))v203)(v169, v613, v69);
                  unint64_t v301 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                  ((void (*)(float *, unint64_t *))v149)(v169, v69);
                  if (v660 < v301) {
                    goto LABEL_232;
                  }
LABEL_199:
                  ((void (*)(uint64_t (*)(unint64_t *, char *), unint64_t *))v149)( v180,  v69);
                  uint64_t v239 = v622;
                  goto LABEL_200;
                }

                uint64_t v275 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
                unint64_t v276 = lazy protocol witness table accessor for type UInt and conformance UInt(v246, v247, v248);
                v275(&v660, &type metadata for UInt, v276, v69, v67);
                uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v613;
                LOBYTE(v275) = (*(uint64_t (**)(float *, char *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                              + 16LL))( v169,  v613,  v69);
                ((void (*)(float *, unint64_t *))v149)(v169, v69);
                goto LABEL_199;
              }
            }

            else
            {
              char v204 = ((uint64_t (*)(unint64_t *, char *))v199)(v69, v67);
              uint64_t v200 = v180(v69, v67);
              unint64_t v203 = v655;
              if ((v204 & 1) == 0)
              {
                if (v200 >= 64) {
                  goto LABEL_52;
                }
                goto LABEL_50;
              }

              if (v200 <= 64)
              {
                uint64_t v233 = v648;
                uint64_t v234 = v646;
                unint64_t v235 = swift_getAssociatedConformanceWitness( (uint64_t)v648,  (uint64_t)v69,  (uint64_t)v646,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                uint64_t v236 = v647;
                (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v235 + 8))( &qword_18180BE68,  256LL,  v234,  v235);
                unint64_t v237 = v236;
                unint64_t v203 = v655;
                (*((void (**)(unsigned int (*)(void), unint64_t *, const char *))v233 + 3))( v237,  v69,  v233);
                LOBYTE(v233) = (*(uint64_t (**)(uint64_t, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                               + 16LL))( v179,  v169,  v69);
                ((void (*)(float *, unint64_t *))v149)(v169, v69);
                char v238 = (float *)v601;
                (*(void (**)(char *, uint64_t, unint64_t *))(v203 + 16))(v601, v179, v69);
                if ((v233 & 1) != 0)
                {
                  ((void (*)(float *, unint64_t *))v149)(v238, v69);
                  goto LABEL_68;
                }

                uint64_t v209 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
                uint64_t v210 = v238;
                goto LABEL_51;
              }
            }

            int64_t v660 = 0LL;
            uint64_t v205 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
            unint64_t v206 = lazy protocol witness table accessor for type Int and conformance Int(v200, v201, v202);
            v205(&v660, &type metadata for Int, v206, v69, v67);
            LOBYTE(v205) = (*(uint64_t (**)(uint64_t, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                           + 16LL))( v179,  v169,  v69);
            ((void (*)(float *, unint64_t *))v149)(v169, v69);
            goto LABEL_68;
          }

          goto LABEL_30;
        }
      }

      (*(void (**)(float *, uint64_t, unint64_t *))(v655 + 16))(v169, v130, v69);
      uint64_t v188 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
      ((void (*)(float *, unint64_t *))v149)(v169, v69);
      if (v660 >= v188) {
        goto LABEL_38;
      }
LABEL_30:
      ((void (*)(uint64_t, unint64_t *))v149)(v179, v69);
      if (((*(uint64_t (**)(uint64_t))(v651 + 168))(v654) & 1) != 0)
      {
        uint64_t result = 0LL;
        int v190 = -8388608;
      }

      else
      {
        uint64_t result = 0LL;
        int v190 = 2139095040;
      }

      uint64_t v327 = 266LL;
LABEL_284:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v327,  0);
    }

    break;
  }

  swift_bridgeObjectRetain_n(v3, 5LL, v219, v220);
  v317._Swift::UInt64 rawBits = 1LL;
  v318._Swift::UInt64 rawBits = (v218 << 16) | 1;
  v319._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v317, v318, v4, v3);
  if (v319._rawBits < 0x10000) {
    v319._rawBits |= 3;
  }
  uint64_t v11 = specialized Collection.count.getter(v319, v320, v4, v3);
  swift_bridgeObjectRelease(v3);
  if ((v12 & 0x1000000000000000LL) != 0) {
    goto LABEL_266;
  }
LABEL_183:
  uint64_t v90 = __OFADD__(v216, v11);
  char v221 = v216 + v11;
  if (v90) {
    goto LABEL_268;
  }
LABEL_184:
  if ((v214 & ~v12 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v221 <= 15) {
      goto LABEL_191;
    }
LABEL_197:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v221, v11);
    swift_bridgeObjectRelease_n(v3, 4LL);
    if ((v3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v3);
      _StringGuts._foreignAppendInPlace(_:)(v4, v3, 0LL, v218);
      swift_bridgeObjectRelease_n(v3, 2LL);
      float v4 = v335;
      a2 = v336;
      a1 = v337;
      goto LABEL_221;
    }

    if (a1)
    {
      swift_bridgeObjectRelease_n(v3, 2LL);
      *(void *)&uint64_t v338 = v4;
      *((void *)&v338 + 1) = v3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v248 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v3) & 0xF,  (uint64_t)&v338,  HIBYTE(v3) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v248, v249, (v3 & 0x4000000000000000LL) != 0);
      a1 = v337;
      swift_bridgeObjectRelease(v3);
LABEL_220:
      float v4 = v335;
      a2 = v336;
      goto LABEL_221;
    }

    if ((v4 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v3);
      unint64_t v262 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      char v263 = v334;
      uint64_t v264 = (uint64_t *)v334;
      a2 = v336;
      a1 = v337;
      goto LABEL_214;
    }

LABEL_89:
      int *v643 = v190;
      return result;
    }
  }

                unint64_t v237 = v646;
                char v238 = v623;
                (*(void (**)(void))(v646 + 32))();
                uint64_t v239 = v220(v69, v67);
                uint64_t v159 = *(void *)(v237 + 16);
                unint64_t v240 = v621;
                ((void (*)(char *, char *, unint64_t *))v159)(v621, v238, v69);
                if ((v239 & 1) == 0)
                {
                  v153(v240, v69);
                  __int16 v128 = (uint64_t)v620;
                  uint64_t v164 = v648;
                  double v249 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
                  goto LABEL_132;
                }

                uint64_t v164 = v648;
                uint64_t v241 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
                v153(v240, v69);
                __int16 v128 = (uint64_t)v620;
                if (v241 <= 64)
                {
LABEL_131:
                  double v249 = ((uint64_t (*)(unint64_t *, uint64_t))v164)(v69, v67);
LABEL_132:
                  int64_t v294 = v249;
                  unint64_t v295 = v619;
                  ((void (*)(char *, char *, unint64_t *))v159)(v619, v238, v69);
                  if (v294 < 65)
                  {
                    uint64_t v303 = ((uint64_t (*)(unint64_t *, uint64_t))v164)(v69, v67);
                    v136(v295, v69);
                    if (v303 != 64 || (((uint64_t (*)(unint64_t *, uint64_t))v645)(v69, v67) & 1) != 0)
                    {
LABEL_146:
                      unint64_t v307 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                      uint64_t result = ((uint64_t (*)(char *, unint64_t *))v136)(v238, v69);
                      uint64_t v159 = v307 + 24;
                      if (__OFADD__(v307, 24LL))
                      {
                        __break(1u);
LABEL_272:
                        if (__clz(__rbit32(LOWORD(_S9) & 0x3FF | 0x10000)) >= __clz(__rbit32(v636 | 0x10000))) {
                          uint64_t v233 = _S9;
                        }
                        else {
                          uint64_t v233 = _S8;
                        }
LABEL_275:
                        char *v635 = LOWORD(v233);
                        return result;
                      }

                      char v69 = v644;
                      char v308 = v634;
                      v309 = v649;
                      v640 = (char *)v644[17];
                      int64_t v310 = ((uint64_t (*)(uint64_t, unint64_t *))v640)(v649, v644);
                      unint64_t v265 = v642;
                      v646 = v69[15];
                      ((void (*)(uint64_t, unint64_t *))v646)(v309, v69);
                      uint64_t v311 = (*(uint64_t (**)(unint64_t *))(v651 + 144))(v308);
                      uint64_t v312 = v308;
                      uint64_t v313 = *(void (**)(const char *, unint64_t *))(v636 + 8);
                      v313(v265, v308);
                      uint64_t v314 = v159 - (v310 + v311);
                      char v315 = v643[46](v309);
                      v645 = v314;
                      v639 = (char *)v159;
                      if ((v315 & 1) == 0)
                      {
                        LODWORD(v638) = 0;
                        uint64_t v316 = v651;
                        uint64_t v164 = (char *)v313;
                        __int16 v128 = (uint64_t)v312;
                        uint64_t v317 = (void (*)(uint64_t, unint64_t *))v646;
                        if ((v314 & 0x8000000000000000LL) != 0) {
                          goto LABEL_150;
                        }
                        goto LABEL_167;
                      }

                      uint64_t v287 = v159 - (v310 + v311);
                      uint64_t v316 = v651;
                      uint64_t v164 = (char *)v313;
                      __int16 v128 = (uint64_t)v312;
                      if (v159 < -16)
                      {
LABEL_149:
                        LODWORD(v638) = 0;
                        uint64_t v314 = v287;
                        uint64_t v317 = (void (*)(uint64_t, unint64_t *))v646;
                        if ((v287 & 0x8000000000000000LL) != 0) {
                          goto LABEL_150;
                        }
                        goto LABEL_167;
                      }

                      if (v159 <= 16)
                      {
                        if (v159 < 0) {
                          goto LABEL_279;
                        }
                        if ((unint64_t)v159 <= 0xF)
                        {
                          LODWORD(v638) = 1 << v159;
                          uint64_t v317 = (void (*)(uint64_t, unint64_t *))v646;
                          if ((v314 & 0x8000000000000000LL) != 0) {
                            goto LABEL_150;
                          }
                          goto LABEL_167;
                        }
                      }

                      LODWORD(v638) = 0;
                      uint64_t v317 = (void (*)(uint64_t, unint64_t *))v646;
                      if ((v314 & 0x8000000000000000LL) == 0)
                      {
LABEL_167:
                        v358 = v628;
                        v317(v649, v69);
                        v359 = *(uint64_t (**)(uint64_t, unint64_t))(v316 + 64);
                        if ((v359(v128, v316) & 1) == 0) {
                          goto LABEL_170;
                        }
                        char v360 = v605;
                        (*(void (**)(char *, char *, uint64_t))(v636 + 16))(v605, v358, v128);
                        uint64_t v361 = v637;
                        char v362 = v641;
                        uint64_t v363 = swift_getAssociatedConformanceWitness( (uint64_t)v637,  v128,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                        uint64_t v364 = v647;
                        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v363 + 8))( &qword_18180BE68,  256LL,  v362,  v363);
                        uint64_t v365 = v364;
                        uint64_t v366 = v642;
                        (*((void (**)(unint64_t *, uint64_t, const char *))v361 + 3))(v365, v128, v361);
                        v367 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v316 + 32)
                                                                                              + 8LL)
                                                                                  + 32LL))( v360,  v366,  v128);
                        ((void (*)(char *, uint64_t))v164)(v366, v128);
                        if ((v367 & 1) != 0)
                        {
                          ((void (*)(char *, uint64_t))v164)(v360, v128);
                          uint64_t v316 = v651;
                          v358 = v628;
LABEL_170:
                          unint64_t v368 = *(uint64_t (**)(uint64_t, unint64_t))(v316 + 128);
                          if (v368(v128, v316) < 16)
                          {
LABEL_189:
                            uint64_t v395 = (*(uint64_t (**)(uint64_t, unint64_t))(v316 + 120))(v128, v316);
                            ((void (*)(char *, uint64_t))v164)(v358, v128);
                            v396 = v643;
                            uint64_t v329 = v641;
                            if (v314 < 0x10) {
                              unint64_t v397 = v395 << v314;
                            }
                            else {
                              unint64_t v397 = 0;
                            }
                            unsigned int v398 = v637;
                            goto LABEL_242;
                          }

                          char v369 = *(void (**)(char *, char *, uint64_t))(v636 + 16);
                          v369(v615, v358, v128);
                          LOWORD(v653) = -1;
                          v370 = v359(v128, v316);
                          v371 = v316;
                          v372 = v370;
                          unint64_t v373 = v368(v128, v371);
                          if ((v372 & 1) != 0)
                          {
                            v376 = v642;
                            if (v373 <= 16)
                            {
                              unint64_t v377 = (void (**)(unint64_t *, uint64_t, const char *))v637;
                              unint64_t v378 = v641;
                              v379 = swift_getAssociatedConformanceWitness( (uint64_t)v637,  v128,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                              char v380 = v369;
                              unint64_t v381 = v647;
                              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v379 + 8))( &qword_18180BE68,  256LL,  v378,  v379);
                              v377[3](v381, v128, (const char *)v377);
                              v382 = v651;
                              v383 = v615;
                              LOBYTE(v377) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v651 + 32) + 8LL)
                                                                                                + 40LL))( v615,  v376,  v128);
                              ((void (*)(char *, uint64_t))v164)(v376, v128);
                              char v384 = (unsigned __int16)v653;
                              unint64_t v385 = v593;
                              v380(v593, v383, v128);
                              uint64_t v314 = v645;
                              if ((v377 & 1) != 0)
                              {
                                char v386 = (*(uint64_t (**)(uint64_t, unint64_t))(v382 + 120))(v128, v382);
                                ((void (*)(char *, uint64_t))v164)(v385, v128);
                                v358 = v628;
                                if (v384 < v386) {
                                  goto LABEL_228;
                                }
                              }

                              else
                              {
                                ((void (*)(char *, uint64_t))v164)(v385, v128);
                                v358 = v628;
                              }

                              goto LABEL_188;
                            }
                          }

                          else
                          {
                            v376 = v642;
                            if (v373 <= 16)
                            {
                              v383 = v615;
                              v369(v642, v615, v128);
                              v393 = (*(uint64_t (**)(uint64_t))(v651 + 120))(v128);
                              ((void (*)(char *, uint64_t))v164)(v376, v128);
                              v358 = v628;
                              uint64_t v314 = v645;
LABEL_188:
                              ((void (*)(char *, uint64_t))v164)(v383, v128);
                              uint64_t v316 = v651;
                              goto LABEL_189;
                            }
                          }

                          uint64_t v387 = v651;
                          uint64_t v388 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))(v651 + 96);
                          uint64_t v389 = lazy protocol witness table accessor for type UInt16 and conformance UInt16( v373,  v374,  v375);
                          v388(&v653, &type metadata for UInt16, v389, v128, v387);
                          v383 = v615;
                          LOBYTE(v388) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v387 + 32) + 8LL)
                                                                                            + 16LL))( v376,  v615,  v128);
                          ((void (*)(char *, uint64_t))v164)(v376, v128);
                          v358 = v628;
                          uint64_t v314 = v645;
                          goto LABEL_188;
                        }

              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
            }

            __break(1u);
LABEL_91:
            __break(1u);
            JUMPOUT(0x1815E8B64LL);
          }
        }

        else
        {
          uint64_t v13 = 1LL;
          LOWORD(a4) = v55;
          do
          {
LABEL_9:
            a2 = *(unsigned __int8 *)(v10 + v11);
            if (*(char *)(v10 + v11) < 0) {
              __asm { BR              X9 }
            }

            if (v13 >= v8) {
              goto LABEL_89;
            }
            v9->i16[v13++] = *(unsigned __int8 *)(v10 + v11++);
          }

          while (v11 < v12);
          if ((a4 & 0xC000) == 0x4000) {
            goto LABEL_44;
          }
        }
      }

      else
      {
        if (v12 > (unint64_t)v11)
        {
          uint64_t v13 = 0LL;
          goto LABEL_9;
        }

        if ((a4 & 0xC000) == 0x4000)
        {
          uint64_t v13 = 0LL;
          goto LABEL_44;
        }
      }

      return result;
    }

    uint64_t v25 = v12 - v11;
    if (v25 < 8 || v10 + v12 > (unint64_t)v9 && v10 + v11 < (unint64_t)v9 + 2 * v25)
    {
      uint64_t v26 = 0LL;
      uint64_t v27 = a3 >> 16;
      goto LABEL_37;
    }

    if (v25 >= 0x20)
    {
      uint64_t v26 = v25 & 0xFFFFFFFFFFFFFFE0LL;
      uint64_t v43 = v9 + 2;
      uint64_t v44 = (uint8x8_t *)(v11 + v10 + 16);
      uint64_t v45 = v25 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        uint64_t v46 = *(uint8x16_t *)v44[-2].i8;
        uint64_t v47 = vmovl_u8(*v44);
        uint64_t v48 = vmovl_high_u8(*(uint8x16_t *)v44->i8);
        v43[-2] = vmovl_u8(*(uint8x8_t *)v46.i8);
        v43[-1] = vmovl_high_u8(v46);
        *uint64_t v43 = v47;
        v43[1] = v48;
        v43 += 4;
        v44 += 4;
        v45 -= 32LL;
      }

      while (v45);
      if (v25 == v26) {
        return result;
      }
      if ((v25 & 0x18) == 0)
      {
        uint64_t v27 = v11 + v26;
        goto LABEL_37;
      }
    }

    else
    {
      uint64_t v26 = 0LL;
    }

    uint64_t v49 = v26;
    uint64_t v26 = v25 & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v27 = v11 + (v25 & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v50 = (uint16x8_t *)((char *)v9 + 2 * v49);
    uint64_t v51 = v49 - (v25 & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v52 = (uint8x8_t *)(v10 + v49 + v11);
    do
    {
      uint64_t v53 = *v52++;
      *v50++ = vmovl_u8(v53);
      v51 += 8LL;
    }

    while (v51);
    if (v25 == v26) {
      return result;
    }
LABEL_37:
    uint64_t v28 = (unsigned __int8 *)(v10 + v27);
    uint64_t v29 = v26 + v11 - v12;
    uint64_t v30 = &v9->i16[v26];
    do
    {
      uint64_t v31 = *v28++;
      *v30++ = v31;
      uint64_t v24 = __CFADD__(v29++, 1LL);
    }

    while (!v24);
    return result;
  }

  v63[0] = a5;
  v63[1] = a6 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v14 = a3 >> 16;
  uint64_t v15 = a4 >> 16;
  if ((a6 & 0x4000000000000000LL) != 0)
  {
    uint64_t v17 = v15 - v14;
    if (v17 < 8 || (unint64_t)v63 + v15 > result && (unint64_t)v63 + v14 < result + 2 * v17)
    {
      uint64_t v18 = 0LL;
      uint64_t v19 = a3 >> 16;
      goto LABEL_28;
    }

    if (v17 >= 0x20)
    {
      uint64_t v18 = v17 & 0xFFFFFFFFFFFFFFE0LL;
      uint64_t v32 = (uint16x8_t *)(result + 32);
      uint64_t v33 = (uint8x8_t *)((char *)&v63[2] + v14);
      uint64_t v34 = v17 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        uint64_t v35 = *(uint8x16_t *)v33[-2].i8;
        uint64_t v36 = vmovl_u8(*v33);
        uint64_t v37 = vmovl_high_u8(*(uint8x16_t *)v33->i8);
        v32[-2] = vmovl_u8(*(uint8x8_t *)v35.i8);
        v32[-1] = vmovl_high_u8(v35);
        *uint64_t v32 = v36;
        v32[1] = v37;
        v32 += 4;
        v33 += 4;
        v34 -= 32LL;
      }

      while (v34);
      if (v17 == v18) {
        return result;
      }
      if ((v17 & 0x18) == 0)
      {
        uint64_t v19 = v14 + v18;
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    uint64_t v38 = v18;
    uint64_t v18 = v17 & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v19 = v14 + (v17 & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v39 = (uint16x8_t *)(result + 2 * v38);
    uint64_t v40 = v38 - (v17 & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v41 = (uint8x8_t *)((char *)v63 + v38 + v14);
    do
    {
      uint64_t v42 = *v41++;
      *v39++ = vmovl_u8(v42);
      v40 += 8LL;
    }

    while (v40);
    if (v17 == v18) {
      return result;
    }
LABEL_28:
    uint64_t v20 = (unsigned __int8 *)v63 + v19;
    uint64_t v21 = v18 + v14 - v15;
    uint64_t v22 = (_WORD *)(result + 2 * v18);
    do
    {
      uint64_t v23 = *v20++;
      *v22++ = v23;
      uint64_t v24 = __CFADD__(v21++, 1LL);
    }

    while (!v24);
    return result;
  }

  if ((a3 & 0xC000) != 0)
  {
    uint64_t v59 = a4;
    uint64_t v60 = _decodeScalar(_:startingAt:)((uint64_t)v63, a2, a3 >> 16);
    uint64_t v62 = v61;
    uint64_t result = Unicode.Scalar.UTF16View.subscript.getter(1LL, v60);
    if (v8 <= 0) {
      goto LABEL_89;
    }
    v9->i16[0] = result;
    v14 += v62;
    if (v14 >= v15)
    {
      if ((v59 & 0xC000) != 0x4000LL) {
        return result;
      }
      uint64_t v16 = 1LL;
    }

    else
    {
      uint64_t v16 = 1LL;
      LOWORD(a4) = v59;
      do
      {
LABEL_18:
        a2 = *((unsigned __int8 *)v63 + v14);
        if (*((char *)v63 + v14) < 0) {
          __asm { BR              X9 }
        }

        if (v16 >= v8) {
          goto LABEL_89;
        }
        v9->i16[v16++] = *((unsigned __int8 *)v63 + v14++);
      }

      while (v14 < v15);
      if ((a4 & 0xC000) != 0x4000) {
        return result;
      }
    }
  }

  else
  {
    if (v15 > (unint64_t)v14)
    {
      uint64_t v16 = 0LL;
      goto LABEL_18;
    }

    if ((a4 & 0xC000) != 0x4000) {
      return result;
    }
    uint64_t v16 = 0LL;
  }

  uint64_t result = _decodeScalar(_:startingAt:)((uint64_t)v63, a2, v14);
  if (result >= 0x10000)
  {
    uint64_t result = (unsigned __int16)((result + 67043328) >> 10) + 55296;
    if ((result & 0x10000) != 0) {
      goto LABEL_91;
    }
  }

  if (v16 >= v8) {
    goto LABEL_89;
  }
  v9->i16[v16] = result;
  return result;
}

LABEL_137:
      ((void (*)(char *, unint64_t *))v149)(v289, v69);
LABEL_138:
      uint64_t v312 = v180(v69, v67);
      uint64_t v313 = v626;
      ((void (*)(char *, char *, unint64_t *))v203)(v626, v279, v69);
      uint64_t v314 = v627;
      if (v312 < 65)
      {
        uint64_t v322 = v180(v69, v67);
        ((void (*)(char *, unint64_t *))v149)(v313, v69);
        if (v322 != 64 || (((uint64_t (*)(unint64_t *, char *))v656)(v69, v67) & 1) != 0)
        {
LABEL_152:
          uint64_t v326 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
          uint64_t result = ((uint64_t (*)(char *, unint64_t *))v149)(v279, v69);
          uint64_t v327 = v326 + 149;
          if (__OFADD__(v326, 149LL))
          {
            __break(1u);
LABEL_277:
            if (__clz(__rbit32(LODWORD(v5) & 0x7FFFFF)) >= __clz(__rbit32(v644))) {
              float v591 = v5;
            }
            else {
              float v591 = v4;
            }
            *uint64_t v169 = v591;
            return result;
          }

          unint64_t v67 = (char *)v652;
          uint64_t v180 = (uint64_t (*)(unint64_t *, char *))v653;
          uint64_t v328 = v654;
          v648 = *(const char **)(v652 + 136);
          uint64_t v329 = ((uint64_t (*)(uint64_t, uint64_t))v648)(v654, v652);
          unsigned __int8 v149 = (const char *)*((void *)v67 + 15);
          unint64_t v330 = v658;
          ((void (*)(uint64_t, char *))v149)(v328, v67);
          v331 = v649;
          uint64_t v332 = (*(uint64_t (**)(unint64_t *))(v657 + 144))(v649);
          v302 = *(const char **)(v644 + 8);
          uint64_t v333 = v331;
          uint64_t v334 = v328;
          uint64_t v130 = v327;
          ((void (*)(char *, unint64_t *))v302)(v330, v333);
          unint64_t v203 = v327 - (v329 + v332);
          char v335 = (*(uint64_t (**)(uint64_t))(v651 + 368))(v334);
          uint64_t v655 = v203;
          v656 = v302;
          v650 = (char *)v149;
          v646 = (void (*)(void, void, void))v130;
          if ((v335 & 1) != 0)
          {
            v336 = (unint64_t *)v657;
            if (v130 < -32 || v130 > 32)
            {
LABEL_156:
              LODWORD(v647) = 0;
              if ((v203 & 0x8000000000000000LL) != 0) {
                goto LABEL_157;
              }
              goto LABEL_168;
            }

            if (v130 < 0)
            {
              LODWORD(v647) = 0;
            }

            else
            {
              LODWORD(v647) = 1 << v130;
            }
          }

          else
          {
            LODWORD(v647) = 0;
            v336 = (unint64_t *)v657;
          }

          if ((v203 & 0x8000000000000000LL) != 0)
          {
LABEL_157:
            uint64_t v337 = v658;
            uint64_t v338 = ((uint64_t (*)(uint64_t, char *))v149)(v334, v67);
            if (!__OFSUB__(0LL, v203))
            {
              int64_t v660 = -(uint64_t)v203;
              uint64_t v341 = *(void (**)(char *, int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v657 + 240);
              unint64_t v342 = lazy protocol witness table accessor for type Int and conformance Int(v338, v339, v340);
              uint64_t v343 = v621;
              uint64_t v344 = v649;
              v341(v337, &v660, &type metadata for Int, v342, v649, v657);
              uint64_t v345 = v657;
              ((void (*)(char *, unint64_t *))v302)(v337, v344);
              char v346 = *(uint64_t (**)(unint64_t *, uint64_t))(v345 + 64);
              if ((v346(v344, v345) & 1) == 0)
              {
LABEL_161:
                v356 = v344;
                v357 = v343;
                v358 = *(uint64_t (**)(unint64_t *, uint64_t))(v345 + 128);
                if (v358(v356, v345) >= 32)
                {
                  v359 = *(void (**)(char *, char *, unint64_t *))(v644 + 16);
                  v359(v611, v357, v356);
                  LODWORD(v66specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = -1;
                  char v360 = v346(v356, v345);
                  uint64_t v361 = v345;
                  char v362 = v360;
                  uint64_t v363 = v358(v356, v361);
                  if ((v362 & 1) != 0)
                  {
                    v302 = v656;
                    if (v363 <= 32)
                    {
                      v414 = (void (**)(char *, unint64_t *, const char *))v645;
                      v356 = v649;
                      unint64_t v415 = v642;
                      unint64_t v416 = swift_getAssociatedConformanceWitness( (uint64_t)v645,  (uint64_t)v649,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                      uint64_t v417 = v641;
                      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v416 + 8))( &qword_18180BE68,  256LL,  v415,  v416);
                      v418 = v658;
                      v414[3](v417, v356, (const char *)v414);
                      uint64_t v419 = v657;
                      v370 = v611;
                      LOBYTE(v414) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v657 + 32) + 8LL) + 40LL))( v611,  v418,  v356);
                      ((void (*)(char *, unint64_t *))v302)(v418, v356);
                      unsigned int v420 = v660;
                      unint64_t v421 = v593;
                      v359(v593, v370, v356);
                      if ((v414 & 1) != 0)
                      {
                        unsigned int v422 = (*(uint64_t (**)(unint64_t *, uint64_t))(v419 + 120))(v356, v419);
                        ((void (*)(char *, unint64_t *))v302)(v421, v356);
                        BOOL v401 = v420 >= v422;
                        uint64_t v130 = (uint64_t)v646;
                        if (!v401) {
                          goto LABEL_232;
                        }
                      }

                      else
                      {
                        ((void (*)(char *, unint64_t *))v302)(v421, v356);
                        uint64_t v130 = (uint64_t)v646;
                      }
                    }

                    else
                    {
                      uint64_t v366 = v657;
                      v367 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v657 + 96);
                      unint64_t v368 = lazy protocol witness table accessor for type UInt32 and conformance UInt32( v363,  v364,  v365);
                      char v369 = v658;
                      v356 = v649;
                      v367(&v660, &type metadata for UInt32, v368, v649, v366);
                      v370 = v611;
                      LOBYTE(v367) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v366 + 32) + 8LL) + 16LL))( v369,  v611,  v356);
                      ((void (*)(char *, unint64_t *))v302)(v369, v356);
                      uint64_t v130 = (uint64_t)v646;
                    }
                  }

                  else
                  {
                    v302 = v656;
                    if (v363 <= 32)
                    {
                      v423 = v658;
                      v370 = v611;
                      v356 = v649;
                      v359(v658, v611, v649);
                      unsigned int v424 = (*(uint64_t (**)(unint64_t *))(v657 + 120))(v356);
                      ((void (*)(char *, unint64_t *))v302)(v423, v356);
                    }

                    else
                    {
                      uint64_t v406 = v657;
                      uint64_t v407 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v657 + 96);
                      unint64_t v408 = lazy protocol witness table accessor for type UInt32 and conformance UInt32( v363,  v364,  v365);
                      uint64_t v409 = v130;
                      unint64_t v410 = v658;
                      v356 = v649;
                      v407(&v660, &type metadata for UInt32, v408, v649, v406);
                      v370 = v611;
                      LOBYTE(v407) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v406 + 32) + 8LL) + 16LL))( v410,  v611,  v356);
                      v411 = v410;
                      uint64_t v130 = v409;
                      ((void (*)(char *, unint64_t *))v302)(v411, v356);
                    }
                  }

                  ((void (*)(char *, unint64_t *))v302)(v370, v356);
                  uint64_t v345 = v657;
                  v357 = v621;
                }

                int v427 = (*(uint64_t (**)(unint64_t *, uint64_t))(v345 + 120))(v356, v345);
                ((void (*)(char *, unint64_t *))v302)(v357, v356);
                goto LABEL_247;
              }

              (*(void (**)(char *, char *, unint64_t *))(v644 + 16))(v617, v343, v344);
              uint64_t v347 = v641;
              uint64_t v348 = v645;
              unint64_t v349 = v642;
              unint64_t v350 = swift_getAssociatedConformanceWitness( (uint64_t)v645,  (uint64_t)v649,  v642,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v350 + 8))( &qword_18180BE68,  256LL,  v349,  v350);
              v351 = (void (*)(char *, unint64_t *, const char *))*((void *)v348 + 3);
              unint64_t v352 = v658;
              unint64_t v353 = v617;
              uint64_t v344 = v649;
              v354 = v348;
              v302 = v656;
              v351(v347, v649, v354);
              char v355 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v345 + 32)
                                                                                               + 8LL)
                                                                                   + 32LL))( v353,  v352,  v344);
              ((void (*)(char *, unint64_t *))v302)(v352, v344);
              if ((v355 & 1) != 0)
              {
                ((void (*)(char *, unint64_t *))v302)(v353, v344);
                uint64_t v345 = v657;
                uint64_t v343 = v621;
                uint64_t v130 = (uint64_t)v646;
                goto LABEL_161;
              }

          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v173,  0);
        }

        goto LABEL_55;
      }

      if (v13 <= 0xECu) {
        goto LABEL_51;
      }
      if (v13 == 237)
      {
        if (v12 == v9) {
          goto LABEL_69;
        }
        uint64_t v18 = v11[1];
        if (v18 > 0x9F) {
          goto LABEL_69;
        }
LABEL_53:
        if ((v18 & 0xC0) != 0x80) {
          goto LABEL_69;
        }
        uint64_t v16 = v11 + 2;
        if (v11 + 2 == v9) {
          goto LABEL_69;
        }
LABEL_55:
        if ((*v16 & 0xC0) != 0x80) {
          goto LABEL_69;
        }
        uint64_t v10 = 0;
        uint64_t v12 = v11 + 3;
        uint64_t v15 = 3LL;
        goto LABEL_26;
      }

      if ((v13 + 16) >= 0xFEu)
      {
LABEL_51:
        if (v12 == v9) {
          goto LABEL_69;
        }
        LOBYTE(v18) = v11[1];
        goto LABEL_53;
      }

      if (v13 == 240)
      {
      }

      else
      {
        if ((v13 + 12) >= 0xFDu)
        {
          if (v12 == v9) {
            goto LABEL_69;
          }
          LOBYTE(v19) = v11[1];
        }

        else
        {
          if (v12 == v9) {
            goto LABEL_69;
          }
          uint64_t v19 = v11[1];
          if (v19 > 0x8F) {
            goto LABEL_69;
          }
        }

        if ((v19 & 0xC0) != 0x80) {
          goto LABEL_69;
        }
      }

      if (v11 + 2 == v9 || (v11[2] & 0xC0) != 0x80 || v11 + 3 == v9 || (v11[3] & 0xC0) != 0x80) {
        goto LABEL_69;
      }
      uint64_t v10 = 0;
      uint64_t v12 = v11 + 4;
      uint64_t v15 = 4LL;
    }

LABEL_272:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
            }

LABEL_283:
            __break(1u);
            goto LABEL_284;
          }

                            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
                          }

                          goto LABEL_196;
                        }

                        uint64_t v196 = v189;
                        uint64_t v197 = (uint64_t (*)(unint64_t *, uint64_t))v159;
                        uint64_t v159 = *((void *)v164 + 2);
                        uint64_t v164 = v606;
                        ((void (*)(char *, char *, unint64_t *))v159)(v606, v196, v69);
                        v653 = -1LL;
                        LOBYTE(v197) = v197(v69, v67);
                        unint64_t v198 = v195(v69, v67);
                        if ((v197 & 1) != 0)
                        {
                          if (v198 <= 64)
                          {
                            uint64_t v201 = (void (**)(char *, unint64_t *, const char *))v640;
                            uint64_t v202 = v638;
                            unint64_t v203 = swift_getAssociatedConformanceWitness( (uint64_t)v640,  (uint64_t)v69,  (uint64_t)v638,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                            char v204 = v639;
                            (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v203 + 8))( &qword_18180BE68,  256LL,  v202,  v203);
                            v201[3](v204, v69, (const char *)v201);
                            LOBYTE(v201) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL) + 40LL))( v164,  v123,  v69);
                            v136(v123, v69);
                            uint64_t v205 = v653;
                            unint64_t v206 = v594;
                            ((void (*)(char *, char *, unint64_t *))v159)(v594, v164, v69);
                            if ((v201 & 1) != 0)
                            {
                              uint64_t v207 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                              v136(v206, v69);
                              if (v205 < v207) {
                                goto LABEL_228;
                              }
                            }

                            else
                            {
                              v136(v206, v69);
                            }

                            goto LABEL_124;
                          }
                        }

                        else if (v198 <= 64)
                        {
                          ((void (*)(char *, char *, unint64_t *))v159)(v123, v164, v69);
                          uint64_t v257 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                          v136(v123, v69);
                          if (v653 < v257) {
                            goto LABEL_228;
                          }
LABEL_124:
                          v136(v164, v69);
                          unint64_t v189 = v629;
                          goto LABEL_125;
                        }

                        uint64_t v211 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
                        uint64_t v212 = lazy protocol witness table accessor for type UInt and conformance UInt(v198, v199, v200);
                        v211(&v653, &type metadata for UInt, v212, v69, v67);
                        LOBYTE(v211) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v123,  v164,  v69);
                        v136(v123, v69);
                        goto LABEL_124;
                      }
                    }

        int64_t v310 = 266LL;
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v310,  0);
    }

    uint64_t v122 = 8 * (((unint64_t)v315._object >> 56) & 7);
    unint64_t v123 = (-255LL << v122) - 1;
    uint64_t v124 = 46LL << v122;
    uint64_t v125 = v124 | v123 & (uint64_t)v315._object;
    char v126 = v124 | v123 & v315._countAndFlagsBits;
    if (v120 < 8) {
      uint64_t countAndFlagsBits = v126;
    }
    else {
      unint64_t object = v125;
    }
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v127 = 0xA000000000000000LL;
    if (!(countAndFlagsBits & 0x8080808080808080LL | object & 0x80808080808080LL)) {
      uint64_t v127 = 0xE000000000000000LL;
    }
    __int16 v128 = (void *)((v127 & 0xFF00000000000000LL | (v120 << 56) | object & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL);
    swift_bridgeObjectRelease((uint64_t)v315._object);
    v315._uint64_t countAndFlagsBits = countAndFlagsBits;
    v315._unint64_t object = v128;
LABEL_139:
    uint64_t v162 = _uint64ToString(_:radix:uppercase:)(BYTE1(a1), 10LL, 0);
    BOOL v163 = v315._countAndFlagsBits;
    uint64_t v164 = (unint64_t)v315._object;
    uint64_t v165 = ((unint64_t)v315._object >> 56) & 0xF;
    unint64_t v166 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v166 && (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000LL) == 0)
    {
      char v315 = v162;
      swift_bridgeObjectRelease(v164);
      goto LABEL_189;
    }

    uint64_t v167 = (uint64_t)v162._object & 0x2000000000000000LL;
    uint64_t v168 = ((unint64_t)v162._object >> 56) & 0xF;
    if (((uint64_t)v315._object & 0x2000000000000000LL) != 0 && v167)
    {
      uint64_t v169 = v165 + v168;
      if (v165 + v168 <= 0xF)
      {
        if (v168)
        {
          uint64_t v207 = 0;
          uint64_t v208 = 0LL;
          do
          {
            uint64_t v209 = v165 + v208;
            uint64_t v210 = v208 + 1;
            if (v208 >= 8) {
              uint64_t v211 = (unint64_t)v162._object;
            }
            else {
              uint64_t v211 = v162._countAndFlagsBits;
            }
            uint64_t v212 = v211 >> (v207 & 0x38);
            char v213 = (8 * v165 + v207) & 0x38;
            char v214 = (-255LL << v213) - 1;
            unint64_t v215 = (unint64_t)v212 << v213;
            uint64_t v216 = v215 | v214 & v164;
            char v217 = v215 | v214 & v163;
            if (v209 < 8) {
              BOOL v163 = v217;
            }
            else {
              uint64_t v164 = v216;
            }
            v207 += 8;
            uint64_t v208 = v210;
          }

          while (v168 != v210);
        }

        swift_bridgeObjectRelease((uint64_t)v162._object);
        uint64_t v218 = 0xA000000000000000LL;
        if (!(v163 & 0x8080808080808080LL | v164 & 0x80808080808080LL)) {
          uint64_t v218 = 0xE000000000000000LL;
        }
        uint64_t v219 = (void *)(v218 & 0xFF00000000000000LL | (v169 << 56) | v164 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v315._object);
        v315._uint64_t countAndFlagsBits = v163;
        v315._unint64_t object = v219;
        goto LABEL_189;
      }

      uint64_t v167 = 1LL;
    }

    uint64_t v170 = v167 ? ((unint64_t)v162._object >> 56) & 0xF : v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v162._object, 2LL, v160, v161);
    if (((uint64_t)v162._object & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v162._object, 5LL, v171, v172);
      v297._Swift::UInt64 rawBits = 1LL;
      v298._Swift::UInt64 rawBits = (v170 << 16) | 1;
      v299._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v297,  v298,  v162._countAndFlagsBits,  (unint64_t)v162._object);
      if (v299._rawBits < 0x10000) {
        v299._rawBits |= 3;
      }
      uint64_t v173 = specialized Collection.count.getter(v299, v300, v162._countAndFlagsBits, (unint64_t)v162._object);
      swift_bridgeObjectRelease((uint64_t)v162._object);
      BOOL v163 = v315._countAndFlagsBits;
      uint64_t v164 = (unint64_t)v315._object;
      if (((uint64_t)v315._object & 0x1000000000000000LL) != 0)
      {
LABEL_262:
        unint64_t v301 = String.UTF8View._foreignCount()();
        uint64_t v174 = v301 + v173;
        if (__OFADD__(v301, v173)) {
          goto LABEL_155;
        }
        goto LABEL_157;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v162._object, 4LL, v171, v172);
      uint64_t v173 = v170;
      if ((v164 & 0x1000000000000000LL) != 0) {
        goto LABEL_262;
      }
    }

    if ((v164 & 0x2000000000000000LL) != 0) {
      goto LABEL_156;
    }
    uint64_t v174 = (v163 & 0xFFFFFFFFFFFFLL) + v173;
    if (__OFADD__(v163 & 0xFFFFFFFFFFFFLL, v173))
    {
      do
      {
LABEL_155:
        __break(1u);
LABEL_156:
        uint64_t v175 = HIBYTE(v164) & 0xF;
        uint64_t v174 = v175 + v173;
      }

      while (__OFADD__(v175, v173));
    }

    uint64_t v327 = 258LL;
    goto LABEL_284;
  }

  if (v278 > 15) {
    goto LABEL_254;
  }
LABEL_249:
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
  swift_bridgeObjectRetain(v12, v283, v284, v285);
  uint64_t v286 = _StringGuts._convertedToSmall()(v11, v12);
  int64_t v288 = v287;
  swift_bridgeObjectRelease(v12);
  v289._Swift::UInt64 rawBits = 1LL;
  v290._Swift::UInt64 rawBits = 65537LL;
  v291._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v289, v290, 0x28uLL, 0xE100000000000000LL);
  if (v291._rawBits < 0x10000) {
    v291._rawBits |= 3;
  }
  uint64_t v293 = specialized String.init(_:)(v291, v292, 0x28uLL, 0xE100000000000000LL);
  unint64_t v295 = v294;
  swift_bridgeObjectRelease(0xE100000000000000LL);
  char v296 = _StringGuts._convertedToSmall()(v293, v295);
  unint64_t v298 = v297;
  swift_bridgeObjectRelease(v295);
  char v299 = specialized _SmallString.init(_:appending:)(v286, v288, v296, v298);
  if ((v301 & 1) != 0) {
    goto LABEL_282;
  }
  uint64_t v11 = v299;
  unint64_t v277 = v300;
  swift_bridgeObjectRelease(v12);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  uint64_t v339 = v11;
LABEL_256:
  v304 = (*(uint64_t (**)(unint64_t))(*(void *)(a2 + 48) + 40LL))(a1);
  if (v304 < 0) {
    goto LABEL_260;
  }
  MEMORY[0x1895F8858](v304);
  v331 = a1;
  uint64_t v332 = a2;
  uint64_t v333 = v4;
  uint64_t v306 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg5( (void (*)(void *__return_ptr, uint64_t *))partial apply for closure #1 in SIMD.description.getter,  (uint64_t)&v330,  0LL,  v305);
  unint64_t v307 = specialized BidirectionalCollection<>.joined(separator:)(8236LL, 0xE200000000000000LL, v306);
  v309 = v308;
  swift_bridgeObjectRelease((uint64_t)v306);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int64_t v310 = specialized static String.+ infix(_:_:)(v11, v277, v307, v309);
  uint64_t v312 = v311;
  swift_bridgeObjectRelease(v277);
  swift_bridgeObjectRelease(v309);
  uint64_t v313 = specialized static String.+ infix(_:_:)(v310, v312, 41LL, 0xE100000000000000LL);
  swift_bridgeObjectRelease(v312);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v313;
}

uint64_t specialized static BinaryFloatingPoint._convert<A>(from:)( __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v635 = a1;
  uint64_t v645 = *(void *)(a3 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  v648 = (char *)&v585 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  int v588 = (char *)&v585 - v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  v12,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  unint64_t v651 = *(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)
                   + 8);
  uint64_t v624 = *(void *)(v651 + 24);
  v637 = *(char **)(v624 + 16);
  unint64_t v641 = swift_getAssociatedTypeWitness( 0LL,  v637,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v641);
  v647 = (unint64_t *)((char *)&v585 - v15);
  v634 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v636 = *(v634 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v634);
  v587 = (char *)&v585 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v586 = (char *)&v585 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v643 = (uint64_t (**)(void))((char *)&v585 - v21);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v595 = (char *)&v585 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v608 = (char *)&v585 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v609 = (char *)&v585 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v618 = (char *)&v585 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  float v591 = (char *)&v585 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v600 = (char *)&v585 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v627 = (void (*)(char *, unint64_t *, char *))((char *)&v585 - v35);
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v614 = (char *)&v585 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v632 = (char *)&v585 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v626 = (char *)&v585 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v633 = (char *)&v585 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  v625 = (char *)&v585 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  uint64_t v630 = (char *)&v585 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  v593 = (char *)&v585 - v49;
  uint64_t v50 = MEMORY[0x1895F8858](v48);
  v615 = (char *)&v585 - v51;
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  v605 = (char *)&v585 - v53;
  uint64_t v54 = MEMORY[0x1895F8858](v52);
  v628 = (char *)&v585 - v55;
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  int v590 = (char *)&v585 - v57;
  uint64_t v58 = MEMORY[0x1895F8858](v56);
  v610 = (char *)&v585 - v59;
  uint64_t v60 = MEMORY[0x1895F8858](v58);
  v599 = (char *)&v585 - v61;
  uint64_t v62 = MEMORY[0x1895F8858](v60);
  v616 = (char *)&v585 - v63;
  MEMORY[0x1895F8858](v62);
  unint64_t v642 = (char *)&v585 - v64;
  uint64_t v644 = (unint64_t *)a4;
  uint64_t v65 = *(void *)(a4 + 16);
  unint64_t v66 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v65,  a3,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v65,  a3,  v66,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  uint64_t v67 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v631 = *(void *)(v67 + 24);
  v640 = *(char **)(v631 + 16);
  v638 = (void (*)(void, void, void))swift_getAssociatedTypeWitness( 0LL,  v640,  v66,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v638);
  v639 = (char *)&v585 - v68;
  char v69 = swift_checkMetadataState(0LL, v66);
  unint64_t v646 = *(v69 - 1);
  uint64_t v70 = MEMORY[0x1895F8858](v69);
  char v72 = (char *)&v585 - ((v71 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v73 = MEMORY[0x1895F8858](v70);
  uint64_t v75 = (char *)&v585 - v74;
  uint64_t v76 = MEMORY[0x1895F8858](v73);
  v613 = (char *)&v585 - v77;
  uint64_t v78 = MEMORY[0x1895F8858](v76);
  v598 = (char *)&v585 - v79;
  uint64_t v80 = MEMORY[0x1895F8858](v78);
  uint64_t v594 = (char *)&v585 - v81;
  uint64_t v82 = MEMORY[0x1895F8858](v80);
  v606 = (char *)&v585 - v83;
  uint64_t v84 = MEMORY[0x1895F8858](v82);
  double v607 = (char *)&v585 - v85;
  uint64_t v86 = MEMORY[0x1895F8858](v84);
  v629 = (char *)&v585 - v87;
  uint64_t v88 = MEMORY[0x1895F8858](v86);
  v592 = (char *)&v585 - v89;
  uint64_t v90 = MEMORY[0x1895F8858](v88);
  v601 = (char *)&v585 - v91;
  uint64_t v92 = MEMORY[0x1895F8858](v90);
  v602 = (char *)&v585 - v93;
  uint64_t v94 = MEMORY[0x1895F8858](v92);
  uint64_t v617 = (char *)&v585 - v95;
  uint64_t v96 = MEMORY[0x1895F8858](v94);
  v603 = (char *)&v585 - v97;
  uint64_t v98 = MEMORY[0x1895F8858](v96);
  v604 = (char *)&v585 - v99;
  uint64_t v100 = MEMORY[0x1895F8858](v98);
  v596 = (char *)&v585 - v101;
  uint64_t v102 = MEMORY[0x1895F8858](v100);
  v597 = (char *)&v585 - v103;
  uint64_t v104 = MEMORY[0x1895F8858](v102);
  unsigned int v589 = (char *)&v585 - v105;
  uint64_t v106 = MEMORY[0x1895F8858](v104);
  unint64_t v620 = (char *)&v585 - v107;
  uint64_t v108 = MEMORY[0x1895F8858](v106);
  v619 = (char *)&v585 - v109;
  uint64_t v110 = MEMORY[0x1895F8858](v108);
  v611 = (char *)&v585 - v111;
  uint64_t v112 = MEMORY[0x1895F8858](v110);
  uint64_t v621 = (char *)&v585 - v113;
  uint64_t v114 = MEMORY[0x1895F8858](v112);
  uint64_t v623 = (char *)&v585 - v115;
  uint64_t v116 = MEMORY[0x1895F8858](v114);
  uint64_t v622 = (char *)&v585 - v117;
  uint64_t v118 = MEMORY[0x1895F8858](v116);
  uint64_t v120 = (char *)&v585 - v119;
  uint64_t v121 = MEMORY[0x1895F8858](v118);
  unint64_t v123 = (char *)&v585 - v122;
  MEMORY[0x1895F8858](v121);
  uint64_t v125 = (char *)&v585 - v124;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 384))(a3, v65) & 1) != 0)
  {
    else {
      __int16 v565 = 0;
    }
    __int16 *v635 = v565;
    return 1LL;
  }

  char v126 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 376))(a3, v65);
  uint64_t v650 = a2;
  if ((v126 & 1) != 0)
  {
    uint64_t v127 = *(void (**)(uint64_t, uint64_t))(v65 + 176);
    uint64_t v649 = a3;
    v643 = (uint64_t (**)(void))v65;
    v127(a3, v65);
    int64_t v653 = -14LL;
    uint64_t v128 = *(void *)(v67 + 64);
    char v129 = ((uint64_t (*)(unint64_t *, uint64_t))v128)(v69, v67);
    uint64_t v645 = v128;
    if ((v129 & 1) != 0)
    {
      v648 = *(char **)(v67 + 128);
      uint64_t v130 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
      if (v130 < 64)
      {
        unint64_t v133 = v646;
        (*(void (**)(char *, char *, unint64_t *))(v646 + 16))(v123, v125, v69);
        goto LABEL_12;
      }
    }

    else
    {
      uint64_t v128 = ((uint64_t (*)(unint64_t *, uint64_t))v128)(v69, v67);
      v648 = *(char **)(v67 + 128);
      uint64_t v130 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
      if ((v128 & 1) == 0)
      {
        unint64_t v133 = v646;
        char v137 = *(void (**)(char *, char *, unint64_t *))(v646 + 16);
        if (v130 >= 64)
        {
          v137(v72, v125, v69);
          unint64_t v136 = *(void (**)(char *, unint64_t *))(v133 + 8);
          v136(v72, v69);
          goto LABEL_22;
        }

        v137(v123, v125, v69);
LABEL_12:
        uint64_t v138 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
        unint64_t v136 = *(void (**)(char *, unint64_t *))(v133 + 8);
        v136(v123, v69);
        if (v138 >= v653)
        {
LABEL_22:
          int64_t v653 = 15LL;
          uint64_t v159 = v645;
          char v160 = ((uint64_t (*)(unint64_t *, uint64_t))v645)(v69, v67);
          uint64_t v161 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
          if ((v160 & 1) != 0)
          {
            uint64_t v164 = (char *)v646;
            if (v161 > 64)
            {
              uint64_t v165 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
              unint64_t v166 = lazy protocol witness table accessor for type Int and conformance Int(v161, v162, v163);
              v165(&v653, &type metadata for Int, v166, v69, v67);
              char v167 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v123,  v125,  v69);
              uint64_t v168 = v123;
              goto LABEL_34;
            }
          }

          else
          {
            uint64_t v164 = (char *)v646;
            if (v161 > 63)
            {
              uint64_t v652 = 15LL;
              uint64_t v128 = (uint64_t)v613;
              uint64_t v175 = (*(uint64_t (**)(char *, char *, unint64_t *))(v646 + 16))(v613, v125, v69);
              uint64_t v176 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
              unint64_t v179 = lazy protocol witness table accessor for type Int and conformance Int(v175, v177, v178);
              v176(&v652, &type metadata for Int, v179, v69, v67);
              char v167 = (*(uint64_t (**)(char *, uint64_t, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                                + 8LL)
                                                                                    + 16LL))( v123,  v128,  v69);
              v136(v123, v69);
              uint64_t v168 = (char *)v128;
LABEL_34:
              v136(v168, v69);
              if ((v167 & 1) == 0)
              {
LABEL_35:
                if ((((uint64_t (*)(unint64_t *, uint64_t))v159)(v69, v67) & 1) != 0)
                {
                  uint64_t v180 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
                  if (v180 < 64) {
                    goto LABEL_47;
                  }
                }

                else
                {
                  char v183 = ((uint64_t (*)(unint64_t *, uint64_t))v159)(v69, v67);
                  uint64_t v180 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
                  if ((v183 & 1) == 0)
                  {
                    if (v180 >= 64) {
                      goto LABEL_48;
                    }
LABEL_47:
                    (*((void (**)(char *, char *, unint64_t *))v164 + 2))(v123, v125, v69);
                    uint64_t v188 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                    v136(v123, v69);
                    if ((v188 & 0x8000000000000000LL) == 0) {
                      goto LABEL_48;
                    }
                    goto LABEL_103;
                  }

                  if (v180 <= 64)
                  {
                    char v213 = (void (**)(char *, unint64_t *, const char *))v640;
                    char v214 = v638;
                    unint64_t v215 = swift_getAssociatedConformanceWitness( (uint64_t)v640,  (uint64_t)v69,  (uint64_t)v638,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    uint64_t v216 = v639;
                    (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v215 + 8))( &qword_18180BE68,  256LL,  v214,  v215);
                    v213[3](v216, v69, (const char *)v213);
                    LOBYTE(v213) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                                 + 16LL))( v125,  v123,  v69);
                    v136(v123, v69);
                    char v217 = v598;
                    (*((void (**)(char *, char *, unint64_t *))v164 + 2))(v598, v125, v69);
                    if ((v213 & 1) != 0)
                    {
                      v136(v217, v69);
                      uint64_t v159 = v645;
                    }

                    else
                    {
                      uint64_t v258 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                      v136(v217, v69);
                      uint64_t v159 = v645;
                      if ((v258 & 0x8000000000000000LL) == 0)
                      {
LABEL_48:
                        unint64_t v189 = v629;
                        (*((void (**)(char *, char *, unint64_t *))v164 + 4))(v629, v125, v69);
                        if ((((uint64_t (*)(unint64_t *, uint64_t))v159)(v69, v67) & 1) != 0)
                        {
                          int v190 = v607;
                          (*((void (**)(char *, char *, unint64_t *))v164 + 2))(v607, v189, v69);
                          char v191 = (void (**)(char *, unint64_t *, const char *))v640;
                          unint64_t v192 = v638;
                          unint64_t v193 = swift_getAssociatedConformanceWitness( (uint64_t)v640,  (uint64_t)v69,  (uint64_t)v638,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          uint64_t v194 = v639;
                          (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v193 + 8))( &qword_18180BE68,  256LL,  v192,  v193);
                          v191[3](v194, v69, (const char *)v191);
                          LOBYTE(v191) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL) + 32LL))( v190,  v123,  v69);
                          v136(v123, v69);
                          v136(v190, v69);
                          uint64_t v159 = v645;
                          unint64_t v189 = v629;
                        }

                        uint64_t v195 = (uint64_t (*)(unint64_t *, uint64_t))v648;
                        if (((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67) < 64)
                        {
LABEL_125:
                          uint64_t v284 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                          uint64_t v285 = v189;
                          unint64_t v286 = v284;
                          v136(v285, v69);
                          unint64_t v287 = v286 + 15;
                          if (v286 >= 0xFFFFFFFFFFFFFFF1LL)
                          {
                            __break(1u);
LABEL_127:
                            int64_t v288 = v639;
                            ((void (*)(uint64_t *, uint64_t))v629)(&qword_18180BE68, 256LL);
                            v627(v288, v69, v640);
                            unint64_t v289 = v611;
                            LOBYTE(v288) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL) + 16LL))( v611,  v123,  v69);
                            v136(v123, v69);
                            char v290 = v589;
                            ((void (*)(char *, char *, unint64_t *))v159)(v589, v289, v69);
                            if ((v288 & 1) != 0)
                            {
                              v136(v290, v69);
                            }

                            else
                            {
                              int64_t v291 = v653;
                              uint64_t v292 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                              v136(v290, v69);
                              BOOL v293 = v292 < v291;
                              char v238 = v623;
                              uint64_t v247 = v611;
                              if (!v293) {
                                goto LABEL_129;
                              }
                            }

LABEL_277:
                      __break(1u);
                      goto LABEL_278;
                    }

                    uint64_t v266 = v259;
                    Swift::Int v267 = (uint64_t (*)(unint64_t *, uint64_t))v159;
                    uint64_t v159 = *((void *)v164 + 2);
                    uint64_t v164 = v601;
                    ((void (*)(char *, char *, unint64_t *))v159)(v601, v266, v69);
                    int64_t v653 = -1LL;
                    LOBYTE(v267) = v267(v69, v67);
                    uint64_t v268 = ((uint64_t (*)(unint64_t *, uint64_t))v265)(v69, v67);
                    if ((v267 & 1) != 0)
                    {
                      if (v268 <= 64)
                      {
                        char v271 = (void (**)(char *, unint64_t *, const char *))v640;
                        float v272 = v638;
                        unint64_t v273 = swift_getAssociatedConformanceWitness( (uint64_t)v640,  (uint64_t)v69,  (uint64_t)v638,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                        uint64_t v274 = v639;
                        (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v273 + 8))( &qword_18180BE68,  256LL,  v272,  v273);
                        v271[3](v274, v69, (const char *)v271);
                        LOBYTE(v271) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL) + 40LL))( v164,  v123,  v69);
                        v136(v123, v69);
                        unint64_t v265 = (const char *)v653;
                        uint64_t v275 = v592;
                        ((void (*)(char *, char *, unint64_t *))v159)(v592, v164, v69);
                        if ((v271 & 1) != 0)
                        {
                          unint64_t v276 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                          v136(v275, v69);
                        }

                        else
                        {
                          v136(v275, v69);
                        }

                        goto LABEL_194;
                      }
                    }

                    else if (v268 <= 64)
                    {
                      ((void (*)(char *, char *, unint64_t *))v159)(v123, v164, v69);
                      unint64_t v283 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                      v136(v123, v69);
                      if (v653 < v283) {
                        goto LABEL_228;
                      }
LABEL_194:
                      v136(v164, v69);
                      uint64_t v259 = v617;
                      goto LABEL_195;
                    }

                    unint64_t v277 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
                    unint64_t v278 = lazy protocol witness table accessor for type UInt and conformance UInt(v268, v269, v270);
                    v277(&v653, &type metadata for UInt, v278, v69, v67);
                    LOBYTE(v277) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                                 + 16LL))( v123,  v164,  v69);
                    v136(v123, v69);
                    goto LABEL_194;
                  }
                }

                int64_t v653 = 0LL;
                uint64_t v184 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
                unint64_t v185 = lazy protocol witness table accessor for type Int and conformance Int(v180, v181, v182);
                v184(&v653, &type metadata for Int, v185, v69, v67);
                LOBYTE(v184) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                             + 16LL))( v125,  v123,  v69);
                v136(v123, v69);
                goto LABEL_103;
              }

              goto LABEL_27;
            }
          }

          (*((void (**)(char *, char *, unint64_t *))v164 + 2))(v123, v125, v69);
          uint64_t v169 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
          v136(v123, v69);
          if (v653 >= v169) {
            goto LABEL_35;
          }
LABEL_27:
          v136(v125, v69);
          if ((v643[21](v649) & 1) != 0)
          {
            uint64_t result = 0LL;
            __int16 v171 = -1024;
          }

          else
          {
            uint64_t result = 0LL;
            __int16 v171 = 31744;
          }

  swift_bridgeObjectRetain_n(v0, 5LL, v19, v20);
  v314._Swift::UInt64 rawBits = 1LL;
  v315._Swift::UInt64 rawBits = (v14 << 16) | 1;
  v316._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v314, v315, countAndFlagsBits, v0);
  if (v316._rawBits < 0x10000) {
    v316._rawBits |= 3;
  }
  unint64_t v240 = specialized Collection.count.getter(v316, v317, countAndFlagsBits, v0);
  swift_bridgeObjectRelease(v0);
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_280;
  }
LABEL_213:
  uint64_t v21 = __OFADD__(v12, v240);
  uint64_t v241 = v12 + v240;
  if (v21) {
    goto LABEL_282;
  }
LABEL_214:
  if ((v3 & ~v5 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v241 > 15) {
      goto LABEL_226;
    }
LABEL_221:
    swift_bridgeObjectRelease_n(v0, 5LL);
    swift_bridgeObjectRetain(v5, v245, v246, v247);
    uint64_t v248 = _StringGuts._convertedToSmall()(v3, v5);
    char v250 = v249;
    swift_bridgeObjectRelease(v5);
    v251._Swift::UInt64 rawBits = (v14 << 16) | 1;
    v252._Swift::UInt64 rawBits = 1LL;
    v253._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v252, v251, countAndFlagsBits, v0);
    if (v253._rawBits < 0x10000) {
      v253._rawBits |= 3;
    }
    unint64_t v255 = specialized String.init(_:)(v253, v254, countAndFlagsBits, v0);
    unint64_t v257 = v256;
    swift_bridgeObjectRelease(v0);
    uint64_t v258 = _StringGuts._convertedToSmall()(v255, v257);
    uint64_t v260 = v259;
    swift_bridgeObjectRelease(v257);
    uint64_t v261 = specialized _SmallString.init(_:appending:)(v248, v250, v258, v260);
    if ((v263 & 1) == 0)
    {
      uint64_t v264 = v261;
      unint64_t v265 = v262;
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease(v0);
      v334._uint64_t countAndFlagsBits = v264;
      v334._unint64_t object = v265;
      goto LABEL_250;
    }

    goto LABEL_301;
  }

  uint64_t v242 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  if ((v243 & 1) != 0)
  {
LABEL_302:
    uint64_t v327 = 258LL;
LABEL_303:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v327,  0);
  }

  uint64_t v244 = (v5 >> 61) & 1;
  if (v242 < v240) {
    LODWORD(v244) = 1;
  }
  if (v241 <= 15 && (_DWORD)v244) {
    goto LABEL_221;
  }
LABEL_226:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v241, v240);
  swift_bridgeObjectRelease_n(v0, 4LL);
  if ((v0 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v0);
    _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, v0, 0LL, v14);
    goto LABEL_245;
  }

  if (!v16)
  {
    if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v0);
      uint64_t v270 = (Swift::String *)((v0 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v284 = v331;
      uint64_t v268 = v331;
      goto LABEL_244;
    }

    uint64_t v270 = (Swift::String *)_StringObject.sharedUTF8.getter(countAndFlagsBits, v0);
    uint64_t v268 = v326;
    swift_bridgeObjectRelease(v0);
    if (v268 >= v331) {
      goto LABEL_308;
    }
LABEL_300:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  swift_bridgeObjectRelease_n(v0, 2LL);
  uint64_t v268 = (v0 >> 62) & 1;
  uint64_t v332 = countAndFlagsBits;
  unint64_t v333 = v0 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v269 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v15, (uint64_t)&v332, v15);
  uint64_t v270 = &v334;
  _StringGuts.appendInPlace(_:isASCII:)(v269, v271, (v0 & 0x4000000000000000LL) != 0);
  if (object) {
    goto LABEL_306;
  }
  swift_bridgeObjectRelease(v0);
  while (1)
  {
LABEL_250:
    float v5 = v334._countAndFlagsBits;
    uint64_t v0 = (unint64_t)v334._object;
    uint64_t countAndFlagsBits = ((unint64_t)v334._object >> 56) & 0xF;
    uint64_t v268 = v334._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    else {
      int64_t v288 = v334._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v288 && (v334._countAndFlagsBits & ~(uint64_t)v334._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v334._object);
      return 0LL;
    }

    if (((uint64_t)v334._object & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v334._object);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      return v5;
    }

    swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v266, v267);
    if ((v0 & 0x1000000000000000LL) == 0) {
      break;
    }
LABEL_283:
    uint64_t v268 = String.UTF8View._foreignCount()();
    if ((v5 & ~v0 & 0x2000000000000000LL) != 0) {
      goto LABEL_258;
    }
LABEL_284:
    if (v268 <= 15) {
      goto LABEL_262;
    }
LABEL_285:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v268, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    uint64_t v332 = 0LL;
    unint64_t v333 = 0LL;
    uint64_t v319 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v332, 0LL);
    uint64_t v270 = &v334;
    _StringGuts.appendInPlace(_:isASCII:)(v319, v320, 1);
    if (!object)
    {
      swift_bridgeObjectRelease(0xE000000000000000LL);
      return v334._countAndFlagsBits;
    }

LABEL_150:
                      while (1)
                      {
                        uint64_t v318 = ((uint64_t (*)(uint64_t, unint64_t *))v317)(v649, v69);
                        unint64_t v287 = -(uint64_t)v314;
                        if (!__OFSUB__(0LL, v314)) {
                          break;
                        }
LABEL_278:
                        __break(1u);
LABEL_279:
                        LODWORD(v638) = 0;
                        unint64_t v314 = v287;
                        uint64_t v317 = (void (*)(uint64_t, unint64_t *))v646;
                        if ((v287 & 0x8000000000000000LL) == 0) {
                          goto LABEL_167;
                        }
                      }

                      int64_t v653 = -(uint64_t)v314;
                      uint64_t v321 = *(void (**)(const char *, int64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))(v651 + 240);
                      unint64_t v322 = lazy protocol witness table accessor for type Int and conformance Int(v318, v319, v320);
                      uint64_t v323 = v616;
                      v321(v265, &v653, &type metadata for Int, v322, v128, v651);
                      unint64_t v324 = v651;
                      char v325 = v265;
                      uint64_t v326 = v323;
                      ((void (*)(const char *, uint64_t))v164)(v325, v128);
                      uint64_t v327 = *(uint64_t (**)(uint64_t, unint64_t))(v324 + 64);
                      char v328 = v327(v128, v324);
                      uint64_t v329 = v641;
                      if ((v328 & 1) != 0)
                      {
                        uint64_t v330 = v641;
                        v331 = v599;
                        (*(void (**)(char *, char *, uint64_t))(v636 + 16))(v599, v326, v128);
                        uint64_t v332 = v637;
                        unint64_t v333 = swift_getAssociatedConformanceWitness( (uint64_t)v637,  v128,  v330,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                        uint64_t v334 = v647;
                        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v333 + 8))( &qword_18180BE68,  256LL,  v330,  v333);
                        char v335 = v334;
                        v336 = v642;
                        (*((void (**)(unint64_t *, uint64_t, const char *))v332 + 3))(v335, v128, v332);
                        char v337 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v324 + 32)
                                                                                              + 8LL)
                                                                                  + 32LL))( v331,  v336,  v128);
                        ((void (*)(char *, uint64_t))v164)(v336, v128);
                        if ((v337 & 1) == 0) {
                          goto LABEL_268;
                        }
                        ((void (*)(char *, uint64_t))v164)(v331, v128);
                        unint64_t v324 = v651;
                        uint64_t v326 = v616;
                        uint64_t v329 = v641;
                      }

                      uint64_t v338 = *(uint64_t (**)(uint64_t, unint64_t))(v324 + 128);
                      if (v338(v128, v324) < 16)
                      {
LABEL_241:
                        int v397 = (*(uint64_t (**)(uint64_t, unint64_t))(v324 + 120))(v128, v324);
                        ((void (*)(char *, uint64_t))v164)(v326, v128);
                        unsigned int v398 = v637;
                        v396 = v643;
LABEL_242:
                        uint64_t v511 = v644;
                        v648 = v164;
                        char v474 = 0;
                        uint64_t v509 = v638 | v397;
                        unint64_t v468 = v651;
                        uint64_t v510 = (uint64_t)v639;
                        goto LABEL_243;
                      }

                      uint64_t v339 = *(void (**)(char *, char *, uint64_t))(v636 + 16);
                      v339(v610, v326, v128);
                      LOWORD(v653) = -1;
                      char v340 = v327(v128, v324);
                      unint64_t v341 = v324;
                      char v342 = v340;
                      uint64_t v343 = v338(v128, v341);
                      if ((v342 & 1) != 0)
                      {
                        char v346 = v642;
                        if (v343 <= 16)
                        {
                          uint64_t v347 = (void (**)(unint64_t *, uint64_t, const char *))v637;
                          unint64_t v348 = v641;
                          unint64_t v349 = swift_getAssociatedConformanceWitness( (uint64_t)v637,  v128,  v641,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                          unint64_t v350 = v339;
                          v351 = v647;
                          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v349 + 8))( &qword_18180BE68,  256LL,  v348,  v349);
                          v347[3](v351, v128, (const char *)v347);
                          unint64_t v352 = v651;
                          unint64_t v353 = v610;
                          LOBYTE(v347) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v651 + 32) + 8LL)
                                                                                            + 40LL))( v610,  v346,  v128);
                          ((void (*)(char *, uint64_t))v164)(v346, v128);
                          unsigned int v354 = (unsigned __int16)v653;
                          char v355 = v590;
                          v350(v590, v353, v128);
                          if ((v347 & 1) == 0)
                          {
                            ((void (*)(char *, uint64_t))v164)(v355, v128);
                            uint64_t v326 = v616;
                            uint64_t v329 = v641;
LABEL_240:
                            ((void (*)(char *, uint64_t))v164)(v353, v128);
                            unint64_t v324 = v651;
                            goto LABEL_241;
                          }

                          unsigned __int16 v356 = (*(uint64_t (**)(uint64_t, unint64_t))(v352 + 120))(v128, v352);
                          ((void (*)(char *, uint64_t))v164)(v355, v128);
                          _CF = v354 >= v356;
LABEL_185:
                          uint64_t v326 = v616;
                          uint64_t v329 = v641;
                          if (!_CF) {
                            goto LABEL_228;
                          }
                          goto LABEL_240;
                        }
                      }

                      else
                      {
                        char v346 = v642;
                        if (v343 <= 16)
                        {
                          unint64_t v353 = v610;
                          v339(v642, v610, v128);
                          unsigned __int16 v394 = (*(uint64_t (**)(uint64_t))(v651 + 120))(v128);
                          ((void (*)(char *, uint64_t))v164)(v346, v128);
                          _CF = (unsigned __int16)v653 >= v394;
                          goto LABEL_185;
                        }
                      }

                      unint64_t v390 = v651;
                      unint64_t v391 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, unint64_t))(v651 + 96);
                      unint64_t v392 = lazy protocol witness table accessor for type UInt16 and conformance UInt16( v343,  v344,  v345);
                      v391(&v653, &type metadata for UInt16, v392, v128, v390);
                      unint64_t v353 = v610;
                      LOBYTE(v391) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v390 + 32) + 8LL)
                                                                                        + 16LL))( v346,  v610,  v128);
                      ((void (*)(char *, uint64_t))v164)(v346, v128);
                      uint64_t v326 = v616;
                      uint64_t v329 = v641;
                      goto LABEL_240;
                    }
                  }

                  else
                  {
                    v136(v295, v69);
                  }

                  ((void (*)(uint64_t, char *, unint64_t *))v159)(v128, v238, v69);
                  int64_t v653 = 0x7FFFFFFFFFFFFFFFLL;
                  char v296 = ((uint64_t (*)(unint64_t *, uint64_t))v645)(v69, v67);
                  uint64_t v297 = ((uint64_t (*)(unint64_t *, uint64_t))v164)(v69, v67);
                  if ((v296 & 1) != 0)
                  {
                    if (v297 > 64)
                    {
                      int64_t v300 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
                      unint64_t v301 = lazy protocol witness table accessor for type Int and conformance Int(v297, v298, v299);
                      v302 = &v653;
                      goto LABEL_144;
                    }
                  }

                  else if (v297 >= 64)
                  {
                    uint64_t v652 = 0x7FFFFFFFFFFFFFFFLL;
                    int64_t v300 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
                    unint64_t v301 = lazy protocol witness table accessor for type Int and conformance Int(v297, v298, v299);
                    v302 = &v652;
LABEL_144:
                    v300(v302, &type metadata for Int, v301, v69, v67);
                    char v306 = (*(uint64_t (**)(char *, uint64_t, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                          + 16LL))( v123,  v128,  v69);
                    v136(v123, v69);
                    if ((v306 & 1) == 0) {
                      goto LABEL_145;
                    }
                    goto LABEL_143;
                  }

                  ((void (*)(char *, uint64_t, unint64_t *))v159)(v123, v128, v69);
                  uint64_t v304 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                  v136(v123, v69);
                  if (v653 >= v304)
                  {
LABEL_145:
                    v136((char *)v128, v69);
                    goto LABEL_146;
                  }

    swift_bridgeObjectRetain_n(v8, 3LL, v42, (char *)v43);
    v142._Swift::UInt64 rawBits = v6 & 0xFFFFFFFFFFFF0000LL | 1;
    v143._Swift::UInt64 rawBits = v5 & 0xFFFFFFFFFFFF0000LL | 1;
    v144._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v142, v143, startingAt, v8);
    if (v144._rawBits < 0x10000) {
      v144._rawBits |= 3;
    }
    v4._Swift::UInt64 rawBits = specialized Collection.count.getter(v144, v145, startingAt, v8);
    swift_bridgeObjectRelease(v12);
    uint64_t v80 = v8;
LABEL_75:
    swift_bridgeObjectRelease(v12);
    swift_bridgeObjectRelease(v80);
    if ((v12 & 0x1000000000000000LL) != 0) {
      uint64_t v40 = String.UTF8View._foreignCount()();
    }
    swift_bridgeObjectRelease(v12);
    uint64_t v81 = __OFADD__(v40, v4._rawBits);
    uint64_t v82 = v40 + v4._rawBits;
    if (!v81) {
      break;
    }
    __break(1u);
LABEL_154:
    a2._Swift::UInt64 rawBits = a2._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a2)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((v4._rawBits & 1) != 0) {
      goto LABEL_18;
    }
LABEL_155:
    int v146 = a2._rawBits;
    v147._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v4)._rawBits;
    a2._Swift::UInt64 rawBits = v146;
    v4._Swift::UInt64 rawBits = v4._rawBits & 0xC | v147._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if (!(_DWORD)v12) {
      goto LABEL_156;
    }
  }

  if ((v10 & ~v12 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v83 = v180;
    uint64_t v84 = _StringGuts.nativeUnusedCapacity.getter(v179, v180);
    if ((v85 & 1) != 0)
    {
LABEL_208:
      uint64_t v169 = 258LL;
      goto LABEL_209;
    }

    if (v82 < 16 && ((v83 & 0x2000000000000000LL) != 0 || v84 < (uint64_t)v4._rawBits))
    {
LABEL_93:
      swift_bridgeObjectRelease(v8);
      uint64_t v90 = v179;
      swift_bridgeObjectRetain(v83, v91, v92, v93);
      uint64_t v94 = _StringGuts._convertedToSmall()(v90, v83);
      uint64_t v96 = v95;
      swift_bridgeObjectRelease(v83);
      v97._Swift::UInt64 rawBits = v6 & 0xFFFFFFFFFFFF0000LL | 1;
      v98._Swift::UInt64 rawBits = v5 & 0xFFFFFFFFFFFF0000LL | 1;
      v99._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v97, v98, startingAt, v8);
      if (v99._rawBits < 0x10000) {
        v99._rawBits |= 3;
      }
      uint64_t v101 = specialized String.init(_:)(v99, v100, startingAt, v8);
      uint64_t v103 = v102;
      swift_bridgeObjectRelease(v8);
      uint64_t v104 = _StringGuts._convertedToSmall()(v101, v103);
      uint64_t v106 = v105;
      swift_bridgeObjectRelease(v103);
      uint64_t v107 = specialized _SmallString.init(_:appending:)(v94, v96, v104, v106);
      uint64_t v17 = v171;
      uint64_t v16 = v172;
      if ((v109 & 1) == 0)
      {
        uint64_t v110 = v107;
        uint64_t v111 = v108;
        swift_bridgeObjectRelease(v83);
        unint64_t v179 = v110;
        uint64_t v180 = v111;
        goto LABEL_100;
      }

  if (!swift::_gatherWrittenGenericParameters(v74, v71, v75, &v119, a7))
  {
    if (a3 < 0) {
      goto LABEL_162;
    }
    uint64_t v43 = operator new(0x20uLL);
    *uint64_t v43 = a1;
    v43[1] = a2;
    v43[2] = a3;
    v43[3] = a4;
    uint64_t v44 = swift::TypeLookupError::TypeLookupError<_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_1>(_gatherGenericParameters(swift::TargetContextDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::ArrayRef<swift::MetadataOrPack>,swift::TargetMetadata<swift::InProcess> const*,__swift::__runtime::llvm::SmallVectorImpl<unsigned int> &,__swift::__runtime::llvm::SmallVectorImpl<void const*> &,swift::Demangle::__runtime::Demangler &)::$_1 const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
LABEL_154:
    *(void *)a8 = v43;
    *(void *)(a8 + 8) = v44;
    uint64_t v65 = 1;
    *(_BYTE *)(a8 + 16) = 1;
    goto LABEL_155;
  }

  uint64_t v30 = v119;
  LODWORD(v25) = v120;
LABEL_48:
  __swift::__runtime::llvm::SmallVectorImpl<swift::MetadataOrPack>::insert<swift::MetadataOrPack const*,void>( (uint64_t)&v119,  (uint64_t)&v30[8 * v25],  a2,  &a2[8 * a3]);
  if ((v22[5] & 1) != 0)
  {
    uint64_t v31 = *(unsigned int *)((((unint64_t)v22 + v22[2] + 15) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v22[3]);
    if (v31 >= 0x10000)
    {
      uint64_t v32 = v31 >> 16;
      uint64_t v33 = *(_DWORD *)(a6 + 8);
      if (v33 > v32)
      {
LABEL_51:
        *(_DWORD *)(a6 + 8) = v32;
        goto LABEL_64;
      }

      if (v33 < v32)
      {
        if (*(_DWORD *)(a6 + 12) < v32)
        {
          __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a6, (const void *)(a6 + 16), v32, 8LL);
          uint64_t v33 = *(_DWORD *)(a6 + 8);
        }

        if (v33 != (_DWORD)v32) {
          bzero((void *)(*(void *)a6 + 8LL * v33), 8 * (v32 - v33));
        }
        goto LABEL_51;
      }
    }
  }

              uint64_t v79 = 0LL;
LABEL_151:
              LODWORD(v7) = v7 + 3;
              std::string::append(this, "'", 1uLL);
              goto LABEL_9;
            }

LABEL_143:
                  unint64_t v305 = 3687LL;
                  goto LABEL_229;
                }

                uint64_t v242 = v611;
                ((void (*)(char *, char *, unint64_t *))v159)(v611, v238, v69);
                int64_t v653 = 0x8000000000000000LL;
                unint64_t v243 = (uint64_t (*)(unint64_t *, uint64_t))v645;
                if ((((uint64_t (*)(unint64_t *, uint64_t))v645)(v69, v67) & 1) != 0)
                {
                  uint64_t v244 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
                  if (v244 >= 64)
                  {
                    uint64_t v247 = v242;
                    unint64_t v279 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
                    unint64_t v280 = lazy protocol witness table accessor for type Int and conformance Int(v244, v245, v246);
                    v279(&v653, &type metadata for Int, v280, v69, v67);
                    char v281 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                         + 16LL))( v247,  v123,  v69);
                    v136(v123, v69);
                    uint64_t v164 = v648;
                    if ((v281 & 1) != 0) {
                      goto LABEL_283;
                    }
                  }

                  else
                  {
                    ((void (*)(char *, char *, unint64_t *))v159)(v123, v242, v69);
                    uint64_t v247 = v242;
                    uint64_t v248 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                    v136(v123, v69);
                    uint64_t v164 = v648;
                    if (v248 < v653) {
                      goto LABEL_283;
                    }
                  }
                }

                else
                {
                  char v250 = v243(v69, v67);
                  uint64_t v164 = v648;
                  uint64_t v251 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
                  if ((v250 & 1) != 0)
                  {
                    if (v251 <= 64) {
                      goto LABEL_127;
                    }
                    uint64_t v254 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
                    unint64_t v255 = lazy protocol witness table accessor for type Int and conformance Int(v251, v252, v253);
                    v254(&v653, &type metadata for Int, v255, v69, v67);
                    uint64_t v247 = v611;
                    char v256 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                         + 16LL))( v611,  v123,  v69);
                    v136(v123, v69);
                    if ((v256 & 1) != 0) {
                      goto LABEL_283;
                    }
                  }

                  else
                  {
                    if (v251 >= 64)
                    {
                      uint64_t v399 = v611;
LABEL_130:
                      v136(v399, v69);
                      goto LABEL_131;
                    }

                    uint64_t v247 = v611;
                    ((void (*)(char *, char *, unint64_t *))v159)(v123, v611, v69);
                    uint64_t v282 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                    v136(v123, v69);
                    if (v282 < v653) {
                      goto LABEL_283;
                    }
                  }
                }

              uint64_t v8 = HIBYTE(v84) & 0xF;
            }

            else
            {
              if ((v84 & 0x2000000000000000LL) != 0) {
                goto LABEL_143;
              }
LABEL_4:
              uint64_t v8 = v83 & 0xFFFFFFFFFFFFLL;
            }

            _StringGuts.append(_:)(v83, v84, 0LL, v8);
            goto LABEL_6;
          }

          swift_keyPath_freeSymbolName(v35);
        }

        uint64_t v73 = specialized static String._createEmpty(withInitialCapacity:)(18LL);
        uint64_t v75 = (unint64_t)v74;
        __s._uint64_t countAndFlagsBits = v73;
        __s._unint64_t object = v74;
        uint64_t v76 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("<computed ", 0xAuLL, 1);
        uint64_t v77 = HIBYTE(v75) & 0xF;
        if ((v75 & 0x2000000000000000LL) == 0) {
          uint64_t v77 = v73 & 0xFFFFFFFFFFFFLL;
        }
        if (!v77 && (v73 & ~v75 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v75);
          __s = v76;
          goto LABEL_100;
        }

        if ((v75 & 0x2000000000000000LL) != 0)
        {
          if (((uint64_t)v76._object & 0x2000000000000000LL) != 0)
          {
            uint64_t v91 = specialized _SmallString.init(_:appending:)( v73,  v75,  v76._countAndFlagsBits,  (unint64_t)v76._object);
            if ((v93 & 1) != 0) {
              goto LABEL_98;
            }
            uint64_t v94 = v91;
            uint64_t v95 = v92;
            swift_bridgeObjectRelease(v75);
            swift_bridgeObjectRelease((uint64_t)v76._object);
            __s._uint64_t countAndFlagsBits = v94;
            __s._unint64_t object = v95;
            goto LABEL_100;
          }
        }

        else if (((uint64_t)v76._object & 0x2000000000000000LL) != 0)
        {
LABEL_98:
          uint64_t v78 = ((unint64_t)v76._object >> 56) & 0xF;
LABEL_99:
          _StringGuts.append(_:)(v76._countAndFlagsBits, (unint64_t)v76._object, 0LL, v78);
          swift_bridgeObjectRelease((uint64_t)v76._object);
LABEL_100:
          uint64_t v201 = v33;
          _print_unlocked<A, B>(_:_:)( (uint64_t)&v201,  (uint64_t)&__s,  (swift *)&type metadata for UnsafeRawPointer,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
          unint64_t object = __s._object;
          uint64_t v97 = ((unint64_t)__s._object >> 56) & 0xF;
          if (v97 || (__s._countAndFlagsBits & ~(uint64_t)__s._object & 0x2000000000000000LL) != 0)
          {
            if (((uint64_t)__s._object & 0x2000000000000000LL) == 0
              || (uint64_t v98 = specialized _SmallString.init(_:appending:)( __s._countAndFlagsBits,  (unint64_t)__s._object,  0x2820uLL,  0xE200000000000000LL),  (v100 & 1) != 0))
            {
              _StringGuts.append(_:)(10272LL, 0xE200000000000000LL, 0LL, 2LL);
              swift_bridgeObjectRelease(0xE200000000000000LL);
            }

            else
            {
              uint64_t v101 = v98;
              uint64_t v102 = v99;
              swift_bridgeObjectRelease((uint64_t)object);
              swift_bridgeObjectRelease(0xE200000000000000LL);
              __s._uint64_t countAndFlagsBits = v101;
              __s._unint64_t object = v102;
            }
          }

          else
          {
            swift_bridgeObjectRelease((uint64_t)__s._object);
            __s._uint64_t countAndFlagsBits = 10272LL;
            __s._unint64_t object = (void *)0xE200000000000000LL;
          }

          TypeName = (uint64_t *)swift_getTypeName(v7, 0);
          if (v104 < 0) {
            goto LABEL_203;
          }
          uint64_t v105 = (uint8x16_t *)TypeName;
          uint64_t v106 = v104;
          uint64_t v107 = validateUTF8(_:)(TypeName, v104);
          if ((v109 & 1) != 0) {
            uint64_t v110 = repairUTF8(_:firstKnownBrokenRange:)(v105->i8, v106, v107, v108);
          }
          else {
            uint64_t v110 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v105, v106, v107 & 1);
          }
          uint64_t countAndFlagsBits = v110;
          uint64_t v113 = v111;
          uint64_t v114 = __s._object;
          uint64_t v115 = ((unint64_t)__s._object >> 56) & 0xF;
          if (!v115 && (__s._countAndFlagsBits & ~(uint64_t)__s._object & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease((uint64_t)__s._object);
            __s._uint64_t countAndFlagsBits = countAndFlagsBits;
            __s._unint64_t object = (void *)v113;
            goto LABEL_125;
          }

          if (((uint64_t)__s._object & 0x2000000000000000LL) != 0)
          {
            if ((v111 & 0x2000000000000000LL) != 0)
            {
              uint64_t v117 = specialized _SmallString.init(_:appending:)( __s._countAndFlagsBits,  (unint64_t)__s._object,  v110,  v111);
              if ((v119 & 1) != 0) {
                goto LABEL_123;
              }
              uint64_t v120 = v117;
              uint64_t v121 = v118;
              swift_bridgeObjectRelease((uint64_t)v114);
              swift_bridgeObjectRelease(v113);
              __s._uint64_t countAndFlagsBits = v120;
              __s._unint64_t object = v121;
              uint64_t v113 = (unint64_t)v121;
              uint64_t countAndFlagsBits = v120;
              goto LABEL_125;
            }
          }

          else if ((v111 & 0x2000000000000000LL) != 0)
          {
LABEL_123:
            uint64_t v116 = HIBYTE(v113) & 0xF;
LABEL_124:
            _StringGuts.append(_:)(countAndFlagsBits, v113, 0LL, v116);
            swift_bridgeObjectRelease(v113);
            uint64_t countAndFlagsBits = __s._countAndFlagsBits;
            uint64_t v113 = (unint64_t)__s._object;
LABEL_125:
            uint64_t v122 = HIBYTE(v113) & 0xF;
            if ((v113 & 0x2000000000000000LL) == 0) {
              uint64_t v122 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            if (v122 || (countAndFlagsBits & ~v113 & 0x2000000000000000LL) != 0)
            {
              if ((v113 & 0x2000000000000000LL) == 0
                || (unint64_t v123 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v113,  0x3E29uLL,  0xE200000000000000LL),  (v125 & 1) != 0))
              {
                _StringGuts.append(_:)(15913LL, 0xE200000000000000LL, 0LL, 2LL);
                swift_bridgeObjectRelease(0xE200000000000000LL);
                uint64_t v83 = __s._countAndFlagsBits;
                uint64_t v84 = (unint64_t)__s._object;
              }

              else
              {
                uint64_t v83 = v123;
                uint64_t v84 = v124;
                swift_bridgeObjectRelease(v113);
                swift_bridgeObjectRelease(0xE200000000000000LL);
              }
            }

            else
            {
              swift_bridgeObjectRelease(v113);
              uint64_t v84 = 0xE200000000000000LL;
              uint64_t v83 = 15913LL;
            }

            goto LABEL_133;
          }

          uint64_t v116 = v110 & 0xFFFFFFFFFFFFLL;
          goto LABEL_124;
        }

        uint64_t v78 = v76._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        goto LABEL_99;
      }

      uint64_t v45 = v187;
      if ((v188 >> 61) >= 2)
      {
        uint64_t v64 = v190 | v189;
        uint64_t v65 = v192 | v191;
        if ((v188 != 0xA000000000000000LL || v65 | v187 | v193 | v64)
          && v188 == 0xA000000000000000LL
          && v187 == 1
          && !(v65 | v64 | v193))
        {
          uint64_t v85 = *a2;
          uint64_t v67 = a2[1];
          uint64_t v86 = HIBYTE(v67) & 0xF;
          if ((v67 & 0x2000000000000000LL) == 0) {
            uint64_t v86 = *a2 & 0xFFFFFFFFFFFFLL;
          }
          if (v86 || (v85 & ~v67 & 0x2000000000000000LL) != 0)
          {
            if ((v67 & 0x2000000000000000LL) != 0)
            {
              char v69 = specialized _SmallString.init(_:appending:)(v85, v67, 0x21uLL, 0xE100000000000000LL);
              if ((v87 & 1) == 0) {
                goto LABEL_92;
              }
            }

            char v72 = 33LL;
            goto LABEL_188;
          }

          uint64_t v169 = 33LL;
        }

        else
        {
          unint64_t v66 = *a2;
          uint64_t v67 = a2[1];
          uint64_t v68 = HIBYTE(v67) & 0xF;
          if ((v67 & 0x2000000000000000LL) == 0) {
            uint64_t v68 = *a2 & 0xFFFFFFFFFFFFLL;
          }
          if (v68 || (v66 & ~v67 & 0x2000000000000000LL) != 0)
          {
            if ((v67 & 0x2000000000000000LL) != 0)
            {
              char v69 = specialized _SmallString.init(_:appending:)(v66, v67, 0x3FuLL, 0xE100000000000000LL);
              if ((v71 & 1) == 0)
              {
LABEL_92:
                uint64_t v88 = v69;
                uint64_t v89 = v70;
                swift_bridgeObjectRelease(0xE100000000000000LL);
                swift_bridgeObjectRelease(a2[1]);
                *a2 = v88;
                a2[1] = v89;
                goto LABEL_8;
              }
            }

            char v72 = 63LL;
LABEL_188:
            _StringGuts.append(_:)(v72, 0xE100000000000000LL, 0LL, 1LL);
            uint64_t v9 = 0xE100000000000000LL;
            goto LABEL_7;
          }

          uint64_t v169 = 63LL;
        }

        *a2 = v169;
        a2[1] = 0xE100000000000000LL;
LABEL_197:
        uint64_t v9 = v67;
        goto LABEL_7;
      }

      v188 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v46 = swift_reflectionMirror_recursiveCount(v13);
      if (v46 < 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }
      uint64_t v47 = v46;
      uint64_t v48 = 0LL;
      do
      {
        if (v47 == v48)
        {
          uint64_t v55 = specialized static String._createEmpty(withInitialCapacity:)(16LL);
          uint64_t v57 = v56;
          __s._uint64_t countAndFlagsBits = v55;
          __s._unint64_t object = (void *)v56;
          uint64_t v58 = HIBYTE(v56) & 0xF;
          if ((v56 & 0x2000000000000000LL) == 0) {
            uint64_t v58 = v55 & 0xFFFFFFFFFFFFLL;
          }
          if (v58 || (v55 & ~v56 & 0x2000000000000000LL) != 0)
          {
            if ((v56 & 0x2000000000000000LL) == 0
              || (uint64_t v59 = specialized _SmallString.init(_:appending:)( v55,  v56,  0x2074657366666F3CuLL,  0xE800000000000000LL),  (v61 & 1) != 0))
            {
              _StringGuts.append(_:)(0x2074657366666F3CLL, 0xE800000000000000LL, 0LL, 8LL);
              swift_bridgeObjectRelease(0xE800000000000000LL);
              uint64_t v62 = __s._countAndFlagsBits;
              uint64_t v63 = (unint64_t)__s._object;
            }

            else
            {
              uint64_t v62 = v59;
              uint64_t v63 = v60;
              swift_bridgeObjectRelease(0xE800000000000000LL);
              swift_bridgeObjectRelease(v57);
              __s._uint64_t countAndFlagsBits = v62;
              __s._unint64_t object = (void *)v63;
            }
          }

          else
          {
            swift_bridgeObjectRelease(v56);
            uint64_t v63 = 0xE800000000000000LL;
            __s._uint64_t countAndFlagsBits = 0x2074657366666F3CLL;
            __s._unint64_t object = (void *)0xE800000000000000LL;
            uint64_t v62 = 0x2074657366666F3CLL;
          }

          uint64_t v80 = _int64ToString(_:radix:uppercase:)( v45,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
          uint64_t v81 = v79;
          uint64_t v82 = HIBYTE(v63) & 0xF;
          if ((v63 & 0x2000000000000000LL) == 0) {
            uint64_t v82 = v62 & 0xFFFFFFFFFFFFLL;
          }
          if (!v82 && (v62 & ~v63 & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease(v63);
            __s._uint64_t countAndFlagsBits = v80;
            __s._unint64_t object = (void *)v81;
            goto LABEL_153;
          }

          if ((v63 & 0x2000000000000000LL) != 0)
          {
            if ((v79 & 0x2000000000000000LL) != 0)
            {
              unint64_t v133 = specialized _SmallString.init(_:appending:)(v62, v63, v80, v79);
              if ((v135 & 1) != 0) {
                goto LABEL_151;
              }
              unint64_t v136 = v133;
              char v137 = v134;
              swift_bridgeObjectRelease(v81);
              swift_bridgeObjectRelease(v63);
              __s._uint64_t countAndFlagsBits = v136;
              __s._unint64_t object = v137;
              uint64_t v81 = (unint64_t)v137;
              uint64_t v80 = v136;
              goto LABEL_153;
            }
          }

          else if ((v79 & 0x2000000000000000LL) != 0)
          {
LABEL_151:
            uint64_t v90 = HIBYTE(v81) & 0xF;
LABEL_152:
            _StringGuts.append(_:)(v80, v81, 0LL, v90);
            swift_bridgeObjectRelease(v81);
            uint64_t v80 = __s._countAndFlagsBits;
            uint64_t v81 = (unint64_t)__s._object;
LABEL_153:
            uint64_t v138 = HIBYTE(v81) & 0xF;
            if ((v81 & 0x2000000000000000LL) == 0) {
              uint64_t v138 = v80 & 0xFFFFFFFFFFFFLL;
            }
            if (v138 || (v80 & ~v81 & 0x2000000000000000LL) != 0)
            {
              if ((v81 & 0x2000000000000000LL) == 0
                || (uint64_t v139 = specialized _SmallString.init(_:appending:)(v80, v81, 0x2820uLL, 0xE200000000000000LL),
                    (v141 & 1) != 0))
              {
                _StringGuts.append(_:)(10272LL, 0xE200000000000000LL, 0LL, 2LL);
                swift_bridgeObjectRelease(0xE200000000000000LL);
              }

              else
              {
                unint64_t v142 = v139;
                unint64_t v143 = v140;
                swift_bridgeObjectRelease(0xE200000000000000LL);
                swift_bridgeObjectRelease(v81);
                __s._uint64_t countAndFlagsBits = v142;
                __s._unint64_t object = v143;
              }
            }

            else
            {
              swift_bridgeObjectRelease(v81);
              __s._uint64_t countAndFlagsBits = 10272LL;
              __s._unint64_t object = (void *)0xE200000000000000LL;
            }

            uint64_t v144 = (uint64_t *)swift_getTypeName(v7, 0);
            if ((v145 & 0x8000000000000000LL) == 0)
            {
              int v146 = (uint8x16_t *)v144;
              unint64_t v147 = v145;
              char v148 = validateUTF8(_:)(v144, v145);
              if ((v150 & 1) != 0) {
                uint64_t v151 = repairUTF8(_:firstKnownBrokenRange:)(v146->i8, v147, v148, v149);
              }
              else {
                uint64_t v151 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v146, v147, v148 & 1);
              }
              unint64_t v153 = v151;
              unint64_t v154 = v152;
              uint64_t v155 = __s._object;
              uint64_t v156 = ((unint64_t)__s._object >> 56) & 0xF;
              if (!v156 && (__s._countAndFlagsBits & ~(uint64_t)__s._object & 0x2000000000000000LL) == 0)
              {
                swift_bridgeObjectRelease((uint64_t)__s._object);
                __s._uint64_t countAndFlagsBits = v153;
                __s._unint64_t object = (void *)v154;
                goto LABEL_178;
              }

              if (((uint64_t)__s._object & 0x2000000000000000LL) != 0)
              {
                if ((v152 & 0x2000000000000000LL) != 0)
                {
                  uint64_t v158 = specialized _SmallString.init(_:appending:)( __s._countAndFlagsBits,  (unint64_t)__s._object,  v151,  v152);
                  if ((v160 & 1) != 0) {
                    goto LABEL_176;
                  }
                  uint64_t v161 = v158;
                  uint64_t v162 = v159;
                  swift_bridgeObjectRelease(v154);
                  swift_bridgeObjectRelease((uint64_t)v155);
                  __s._uint64_t countAndFlagsBits = v161;
                  __s._unint64_t object = v162;
                  unint64_t v154 = (unint64_t)v162;
                  unint64_t v153 = v161;
                  goto LABEL_178;
                }
              }

              else if ((v152 & 0x2000000000000000LL) != 0)
              {
LABEL_176:
                uint64_t v157 = HIBYTE(v154) & 0xF;
LABEL_177:
                _StringGuts.append(_:)(v153, v154, 0LL, v157);
                swift_bridgeObjectRelease(v154);
                unint64_t v153 = __s._countAndFlagsBits;
                unint64_t v154 = (unint64_t)__s._object;
LABEL_178:
                uint64_t v163 = HIBYTE(v154) & 0xF;
                if ((v154 & 0x2000000000000000LL) == 0) {
                  uint64_t v163 = v153 & 0xFFFFFFFFFFFFLL;
                }
                if (v163 || (v153 & ~v154 & 0x2000000000000000LL) != 0)
                {
                  if ((v154 & 0x2000000000000000LL) == 0
                    || (uint64_t v164 = specialized _SmallString.init(_:appending:)(v153, v154, 0x3E29uLL, 0xE200000000000000LL),
                        (v166 & 1) != 0))
                  {
                    _StringGuts.append(_:)(15913LL, 0xE200000000000000LL, 0LL, 2LL);
                    swift_bridgeObjectRelease(0xE200000000000000LL);
                    char v167 = __s._countAndFlagsBits;
                    uint64_t v84 = (unint64_t)__s._object;
                  }

                  else
                  {
                    char v167 = v164;
                    uint64_t v84 = v165;
                    swift_bridgeObjectRelease(0xE200000000000000LL);
                    swift_bridgeObjectRelease(v154);
                  }
                }

                else
                {
                  swift_bridgeObjectRelease(v154);
                  uint64_t v84 = 0xE200000000000000LL;
                  char v167 = 15913LL;
                }

                v168._uint64_t countAndFlagsBits = v167;
                v168._unint64_t object = (void *)v84;
                String.append(_:)(v168);
LABEL_6:
                uint64_t v9 = v84;
LABEL_7:
                swift_bridgeObjectRelease(v9);
                goto LABEL_8;
              }

              uint64_t v157 = v151 & 0xFFFFFFFFFFFFLL;
              goto LABEL_177;
            }

          uint64_t v21 = 0;
          goto LABEL_118;
        }

        uint64_t v8 = 1;
        uint64_t v44 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
        uint64_t v48 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v44, v45, v46, v47);
        if (v49)
        {
          uint64_t v50 = a3 + 55;
          uint64_t v51 = a3 + 87;
          if (a3 > 10)
          {
            uint64_t v52 = 58;
          }

          else
          {
            uint64_t v51 = 97;
            uint64_t v50 = 65;
            uint64_t v52 = a3 + 48;
          }

          if (v48)
          {
            uint64_t v53 = 0;
            do
            {
              uint64_t v54 = *v48;
              if (v54 < 0x30 || v54 >= v52)
              {
                if (v54 < 0x41 || v54 >= v50)
                {
                  uint64_t v21 = 0;
                  uint64_t v8 = 1;
                  if (v54 < 0x61 || v54 >= v51) {
                    goto LABEL_118;
                  }
                  uint64_t v55 = -87;
                }

                else
                {
                  uint64_t v55 = -55;
                }
              }

              else
              {
                uint64_t v55 = -48;
              }

              uint64_t v21 = 0;
              uint64_t v56 = v54 + v55;
              uint64_t v57 = v53 * (unint64_t)a3;
              uint64_t v58 = (v57 & 0xFFFFFFFF00000000LL) != 0;
              uint64_t v25 = __CFADD__((_DWORD)v57, v56);
              uint64_t v53 = v57 + v56;
              uint64_t v59 = v25;
              uint64_t v8 = 1;
              if (v58) {
                break;
              }
              if ((v59 & 1) != 0) {
                break;
              }
              uint64_t v8 = 0;
              ++v48;
              uint64_t v21 = v53;
              --v49;
            }

            while (v49);
            goto LABEL_118;
          }

          goto LABEL_117;
        }

          uint64_t v21 = 0;
          goto LABEL_118;
        }

        uint64_t v8 = 1;
        uint64_t v44 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
        uint64_t v48 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v44, v45, v46, v47);
        if (v49)
        {
          uint64_t v50 = a3 + 55;
          uint64_t v51 = a3 + 87;
          if (a3 > 10)
          {
            uint64_t v52 = 58;
          }

          else
          {
            uint64_t v51 = 97;
            uint64_t v50 = 65;
            uint64_t v52 = a3 + 48;
          }

          if (v48)
          {
            uint64_t v53 = 0;
            do
            {
              uint64_t v54 = *v48;
              if (v54 < 0x30 || v54 >= v52)
              {
                if (v54 < 0x41 || v54 >= v50)
                {
                  uint64_t v21 = 0;
                  uint64_t v8 = 1;
                  if (v54 < 0x61 || v54 >= v51) {
                    goto LABEL_118;
                  }
                  uint64_t v55 = -87;
                }

                else
                {
                  uint64_t v55 = -55;
                }
              }

              else
              {
                uint64_t v55 = -48;
              }

              uint64_t v21 = 0;
              uint64_t v56 = v54 + v55;
              uint64_t v57 = (int)v53 * (uint64_t)(int)a3;
              uint64_t v58 = v57 != (int)v57;
              uint64_t v25 = __OFADD__((_DWORD)v57, v56);
              uint64_t v53 = v57 + v56;
              uint64_t v59 = v25;
              uint64_t v8 = 1;
              if (v58) {
                break;
              }
              if ((v59 & 1) != 0) {
                break;
              }
              uint64_t v8 = 0;
              ++v48;
              uint64_t v21 = v53;
              --v49;
            }

            while (v49);
            goto LABEL_118;
          }

          goto LABEL_117;
        }

          uint64_t result = 0LL;
          goto LABEL_118;
        }

        uint64_t v8 = 1;
        uint64_t v46 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
        uint64_t v50 = specialized UnsafeBufferPointer.init(rebasing:)(v46, v47, v48, v49);
        if (v51)
        {
          uint64_t v52 = (unsigned __int8 *)v50;
          uint64_t v53 = a3 + 48;
          uint64_t v54 = a3 + 55;
          uint64_t v55 = a3 + 87;
          if (a3 > 10)
          {
            uint64_t v53 = 58;
          }

          else
          {
            uint64_t v55 = 97;
            uint64_t v54 = 65;
          }

          if (v50)
          {
            uint64_t v56 = 0LL;
            do
            {
              uint64_t v57 = *v52;
              if (v57 < 0x30 || v57 >= v53)
              {
                if (v57 < 0x41 || v57 >= v54)
                {
                  uint64_t result = 0LL;
                  uint64_t v8 = 1;
                  if (v57 < 0x61 || v57 >= v55) {
                    goto LABEL_118;
                  }
                  uint64_t v58 = -87;
                }

                else
                {
                  uint64_t v58 = -55;
                }
              }

              else
              {
                uint64_t v58 = -48;
              }

              uint64_t result = 0LL;
              uint64_t v59 = v57 + v58;
              uint64_t v60 = !is_mul_ok(v56, a3);
              uint64_t v61 = v56 * a3;
              uint64_t v26 = __CFADD__(v61, v59);
              uint64_t v56 = v61 + v59;
              uint64_t v62 = v26;
              uint64_t v8 = 1;
              if (v60) {
                break;
              }
              if ((v62 & 1) != 0) {
                break;
              }
              uint64_t v8 = 0;
              ++v52;
              uint64_t result = v56;
              --v51;
            }

            while (v51);
            goto LABEL_118;
          }

          goto LABEL_117;
        }

          uint64_t result = 0LL;
          goto LABEL_118;
        }

        uint64_t v8 = 1;
        uint64_t v45 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
        uint64_t v49 = specialized UnsafeBufferPointer.init(rebasing:)(v45, v46, v47, v48);
        if (v50)
        {
          uint64_t v51 = (unsigned __int8 *)v49;
          uint64_t v52 = a3 + 48;
          uint64_t v53 = a3 + 55;
          uint64_t v54 = a3 + 87;
          if (a3 > 10)
          {
            uint64_t v52 = 58;
          }

          else
          {
            uint64_t v54 = 97;
            uint64_t v53 = 65;
          }

          if (v49)
          {
            uint64_t v55 = 0LL;
            do
            {
              uint64_t v56 = *v51;
              if (v56 < 0x30 || v56 >= v52)
              {
                if (v56 < 0x41 || v56 >= v53)
                {
                  uint64_t result = 0LL;
                  uint64_t v8 = 1;
                  if (v56 < 0x61 || v56 >= v54) {
                    goto LABEL_118;
                  }
                  uint64_t v57 = -87;
                }

                else
                {
                  uint64_t v57 = -55;
                }
              }

              else
              {
                uint64_t v57 = -48;
              }

              uint64_t result = 0LL;
              uint64_t v58 = v56 + v57;
              uint64_t v59 = v55 * a3;
              uint64_t v60 = (unsigned __int128)(v55 * (__int128)a3) >> 64 != (v55 * a3) >> 63;
              uint64_t v55 = v55 * a3 + v58;
              uint64_t v61 = __OFADD__(v59, v58);
              uint64_t v8 = 1;
              if (v60) {
                break;
              }
              if (v61) {
                break;
              }
              uint64_t v8 = 0;
              ++v51;
              uint64_t result = v55;
              --v50;
            }

            while (v50);
            goto LABEL_118;
          }

          goto LABEL_117;
        }

    uint64_t v116 = *(void *)(a1 + 32) & 0x7FFFFFFFF8LL;
    uint64_t v117 = *(void *)(a1 + 8);
    if (!v117 || v117 == swift::getRootSuperclass(result))
    {
      uint64_t v120 = 16;
      uint64_t v121 = 7LL;
      uint64_t v118 = a4;
    }

    else
    {
      uint64_t v118 = a4;
      uint64_t v119 = *v171;
      if ((*((_BYTE *)*v171 + 32) & 2) != 0)
      {
        uint64_t v120 = *((_DWORD *)v119 + 12);
        uint64_t v121 = *((unsigned __int16 *)v119 + 26);
      }

      else
      {
        uint64_t v120 = *(_DWORD *)(v116 + 4);
        uint64_t v121 = 15LL;
      }
    }

    uint64_t v122 = *(_DWORD *)(v116 + 4);
    if (v120 > v122)
    {
      *(_DWORD *)(v116 + 4) = v120;
      uint64_t v122 = v120;
    }

    unint64_t v123 = v122;
    if (a3)
    {
      uint64_t v124 = 0LL;
      do
      {
        uint64_t v127 = *(void *)(v118 + 8 * v124);
        if (*(void *)(a5 + 8 * v124) || *(void *)v127)
        {
          uint64_t v125 = *(unsigned __int8 *)(v127 + 16);
          char v126 = (v123 + v125) & ~v125;
          *(void *)(a5 + 8 * v124) = v126;
          unint64_t v123 = v126 + *(void *)v127;
          if (v121 <= v125) {
            uint64_t v121 = v125;
          }
        }

        ++v124;
      }

      while (a3 != v124);
    }

    *(_DWORD *)(a1 + 48) = v123;
    *(_WORD *)(a1 + 52) = v121;
    if (v123 != *(_DWORD *)(v116 + 8)) {
      *(_DWORD *)(v116 + 8) = v123;
    }
    uint64_t v128 = *(unsigned __int16 **)(a1 + 64);
    char v129 = *(_DWORD *)v128;
    if ((*(_DWORD *)v128 & 0x80) == 0)
    {
      if (a3)
      {
        uint64_t v130 = *(void *)(a1 + 32) & 0x7FFFFFFFF8LL;
        uint64_t v131 = *(swift::MetadataAllocator **)(v130 + 0x30);
        if (v131)
        {
          char v172 = *(unsigned __int16 **)(a1 + 64);
          uint64_t v132 = 0LL;
          unint64_t v133 = 0;
          uint64_t v134 = 0;
          do
          {
            unint64_t v135 = *(uint64_t **)(v118 + 8 * v132);
            unint64_t v136 = (uint64_t)v131 + 32 * v132 + 8;
            char v137 = *(void **)v136;
            if (*(void *)v136)
            {
              uint64_t v138 = *(void *)(a5 + 8 * v132);
              if (*v137 != v138) {
                char *v137 = v138;
              }
            }

            uint64_t v139 = *v135;
            if (*v135 != *(_DWORD *)(v136 + 28))
            {
              if ((v134 & 1) == 0)
              {
                uint64_t v131 = swift::MetadataAllocator::Allocate( (swift::MetadataAllocator *)&getResilientMetadataAllocator(void)::allocator,  (32 * a3) | 8,  (const char *)4,  v15);
                memcpy(v131, *(const void **)(v130 + 48), (32 * a3) | 8);
                *(void *)(v130 + 48) = v131;
                unint64_t v136 = (uint64_t)v131 + 32 * v132 + 8;
                uint64_t v139 = *v135;
              }

              *(_DWORD *)(v136 + 28) = v139;
              *(void *)(v136 + 16) = 0LL;
              uint64_t v140 = -1;
              do
                ++v140;
              while (*((unsigned __int8 *)v135 + 16) + 1 != 1 << v140);
              *(_DWORD *)(v136 + 24) = v140;
              uint64_t v134 = 1;
            }

            uint64_t v118 = a4;
            uint64_t v132 = ++v133;
          }

          while (v133 != a3);
          uint64_t v128 = v172;
          char v129 = *(_DWORD *)v172;
        }
      }

      if ((v129 & 0x20000000) != 0 && (v128[14] & 1) != 0)
      {
        TrailingObjectsImpl = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v128);
        uint64_t v162 = *(unsigned int *)v128;
        uint64_t v163 = (v162 & 0x40000000) != 0
        unint64_t v166 = (int *)(TrailingObjectsImpl + 4 * ((v162 >> 30) & 1) + 12LL * v163);
        char v167 = *v166;
        uint64_t v168 = (char *)v166 + v167;
        if ((_DWORD)v167 && v168 != 0LL)
        {
          _objc_realizeClassFromSwift((Class)a1, v168);
          return 0LL;
        }
      }

    operator delete(v39);
    goto LABEL_144;
  }

      if (v81 == v83) {
        goto LABEL_26;
      }
      while (1)
      {
        if (*(_DWORD *)a6) {
          return this;
        }
        uint64_t v8 = 0;
        uint64_t v7 = 0LL;
        uint64_t v14 = 0;
        if (++v81 == v83) {
          goto LABEL_75;
        }
      }

    case 0x13:
      uint64_t v36 = *((unsigned __int8 *)a2 + 18);
      uint64_t v37 = a2;
      if (v36 == 5 && *((_DWORD *)a2 + 2))
      {
        uint64_t v37 = *(swift::Demangle::__runtime::Node **)a2;
LABEL_52:
        uint64_t v38 = *(swift::Demangle::__runtime::Node **)v37;
      }

      else
      {
        uint64_t v38 = 0LL;
      }

      uint64_t v64 = *((unsigned __int16 *)v38 + 8);
      if (v64 != 76 && v64 != 29)
      {
        uint64_t v14 = 682;
LABEL_35:
        uint64_t v8 = 1;
        uint64_t v7 = a2;
        goto LABEL_75;
      }

      unint64_t v66 = *((unsigned __int8 *)v38 + 18);
      if (v66 == 5 && *((_DWORD *)v38 + 2))
      {
        uint64_t v38 = *(swift::Demangle::__runtime::Node **)v38;
LABEL_104:
        uint64_t v67 = *(swift::Demangle::__runtime::Node **)v38;
      }

      else
      {
        uint64_t v67 = 0LL;
      }

      uint64_t v68 = a4 + 1;
      if (*(_DWORD *)a6) {
        return this;
      }
      swift::Demangle::__runtime::RemanglerBuffer::operator<<((char **)(v13 + 12728), *a3);
      *a3 = 95;
      char v69 = *((unsigned __int8 *)v12 + 18);
      if (v69 == 2) {
        goto LABEL_111;
      }
      if (v69 == 5 && *((_DWORD *)v12 + 2) >= 2u)
      {
        uint64_t v12 = *(swift::Demangle::__runtime::Node **)v12;
LABEL_111:
        uint64_t v70 = (swift::Demangle::__runtime::Node **)*((void *)v12 + 1);
      }

      else
      {
        uint64_t v70 = 0LL;
      }

LABEL_91:
      if (*(_DWORD *)a6) {
        return this;
      }
      goto LABEL_26;
    case 0x18:
    case 0x3D:
    case 0xB4:
    case 0xDB:
    case 0xEA:
      if (v9 == 234) {
        LOBYTE(a5) = 1;
      }
      uint64_t v22 = *((unsigned __int8 *)a2 + 18);
      if (v22 == 5 && *((_DWORD *)a2 + 2))
      {
        uint64_t v12 = *(swift::Demangle::__runtime::Node **)a2;
LABEL_22:
        uint64_t v23 = *(swift::Demangle::__runtime::Node **)v12;
      }

      else
      {
        uint64_t v23 = 0LL;
      }

      if (*(_DWORD *)a6) {
        return this;
      }
LABEL_38:
      uint64_t v27 = *a3;
      uint64_t v28 = *(_DWORD *)(v13 + 12736);
      uint64_t v29 = *(unsigned int *)(v13 + 12740);
      uint64_t v30 = *(char **)(v13 + 12728);
      uint64_t v31 = *(void **)(v13 + 12744);
      uint64_t v32 = (char *)v31[1];
      if (&v30[v29] == v32)
      {
        uint64_t v48 = (unint64_t)&v30[v29 + 1];
        uint64_t v33 = v31[2];
        if (v48 <= v33)
        {
          v31[1] = v48;
          LODWORD(v49) = 1;
          goto LABEL_73;
        }
      }

      else
      {
        uint64_t v33 = v31[2];
      }

      uint64_t v101 = *a3;
      else {
        uint64_t v49 = (2 * v29);
      }
      uint64_t v50 = v49 + v29;
      if (!v32 || (unint64_t)&v32[v50] > v33)
      {
        uint64_t v51 = 2LL * v31[4];
        if (v51 <= v50 + 1) {
          uint64_t v51 = v50 + 1;
        }
        v31[4] = v51;
        uint64_t v52 = v51 + 8;
        this = (unsigned int *)malloc(v51 + 8);
        uint64_t v53 = (char *)this + v52;
        *(void *)this = v31[3];
        uint64_t v32 = (char *)(this + 2);
        v31[2] = v53;
        uint64_t v31[3] = this;
      }

      v31[1] = &v32[v50];
      if ((_DWORD)v29)
      {
        this = (unsigned int *)memcpy(v32, *(const void **)(v13 + 12728), v29);
        LODWORD(v29) = *(_DWORD *)(v13 + 12740);
        uint64_t v28 = *(_DWORD *)(v13 + 12736);
      }

      uint64_t v27 = v101;
      *(void *)(v13 + 12728) = v32;
      uint64_t v30 = v32;
LABEL_73:
      *(_DWORD *)(v13 + 1274specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v29 + v49;
LABEL_74:
      uint64_t v8 = 0;
      uint64_t v7 = 0LL;
      uint64_t v14 = 0;
      *(_DWORD *)(v13 + 12736) = v28 + 1;
      v30[v28] = v27;
      *a3 = 95;
      goto LABEL_75;
    case 0x47:
      uint64_t v39 = *((unsigned __int8 *)a2 + 18);
      if (v39 == 2) {
        goto LABEL_57;
      }
      if (v39 == 5 && *((_DWORD *)a2 + 2) >= 2u)
      {
        uint64_t v12 = *(swift::Demangle::__runtime::Node **)a2;
LABEL_57:
        uint64_t v40 = (swift::Demangle::__runtime::Node *)*((void *)v12 + 1);
      }

      else
      {
        uint64_t v40 = 0LL;
      }

      goto LABEL_91;
    case 0x53:
      uint64_t v41 = *a3;
      uint64_t v42 = this[3184];
      uint64_t v43 = this[3185];
      uint64_t v44 = (char *)*((void *)this + 1591);
      uint64_t v45 = (void *)*((void *)this + 1593);
      uint64_t v46 = (char *)v45[1];
      if (&v44[v43] == v46)
      {
        uint64_t v84 = (unint64_t)&v44[v43 + 1];
        uint64_t v47 = v45[2];
        if (v84 <= v47)
        {
          v45[1] = v84;
          uint64_t v92 = 1;
          goto LABEL_162;
        }
      }

      else
      {
        uint64_t v47 = v45[2];
      }

      uint64_t v103 = *a3;
      LODWORD(v85) = 2 * v43;
      else {
        uint64_t v85 = v85;
      }
      uint64_t v100 = v85;
      uint64_t v86 = v85 + v43;
      uint64_t v87 = (unint64_t)&v46[v85 + v43];
      if (v46) {
        uint64_t v88 = v87 > v47;
      }
      else {
        uint64_t v88 = 1;
      }
      uint64_t v44 = (char *)v45[1];
      if (v88)
      {
        uint64_t v89 = 2LL * v45[4];
        if (v89 <= v86 + 1) {
          uint64_t v89 = v86 + 1;
        }
        v45[4] = v89;
        uint64_t v90 = v89 + 8;
        this = (unsigned int *)malloc(v89 + 8);
        uint64_t v91 = (char *)this + v90;
        *(void *)this = v45[3];
        uint64_t v44 = (char *)(this + 2);
        v45[2] = v91;
        v45[3] = this;
      }

      v45[1] = &v44[v86];
      if ((_DWORD)v43)
      {
        this = (unsigned int *)memcpy(v44, *(const void **)(v13 + 12728), v43);
        LODWORD(v43) = *(_DWORD *)(v13 + 12740);
        uint64_t v42 = *(_DWORD *)(v13 + 12736);
      }

      uint64_t v41 = v103;
      uint64_t v92 = v100;
      *(void *)(v13 + 12728) = v44;
LABEL_162:
      *(_DWORD *)(v13 + 1274specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = v43 + v92;
LABEL_163:
      *(_DWORD *)(v13 + 12736) = v42 + 1;
      v44[v42] = v41;
      *a3 = 95;
      uint64_t v93 = *((unsigned __int8 *)v12 + 18);
      if (v93 == 2) {
        goto LABEL_167;
      }
      if (v93 == 5 && *((_DWORD *)v12 + 2) >= 2u)
      {
        uint64_t v12 = *(swift::Demangle::__runtime::Node **)v12;
LABEL_167:
        uint64_t v94 = *((void *)v12 + 1);
      }

      else
      {
        uint64_t v94 = 0LL;
      }

      uint64_t v95 = *(unsigned __int8 *)(v94 + 18);
      uint64_t v96 = (swift::Demangle::__runtime::Node **)v94;
      if (v95 == 5)
      {
        uint64_t v97 = *(swift::Demangle::__runtime::Node **)v94;
        uint64_t v96 = *(swift::Demangle::__runtime::Node ***)v94;
LABEL_177:
        uint64_t v98 = (swift::Demangle::__runtime::Node **)((char *)v97 + 8 * *(unsigned int *)(v94 + 8));
        goto LABEL_181;
      }

      uint64_t v96 = 0LL;
LABEL_173:
      switch(v95)
      {
        case 1:
          uint64_t v98 = (swift::Demangle::__runtime::Node **)(v94 + 8);
          break;
        case 2:
          uint64_t v98 = (swift::Demangle::__runtime::Node **)(v94 + 16);
          break;
        case 5:
          uint64_t v97 = *(swift::Demangle::__runtime::Node **)v94;
          goto LABEL_177;
        default:
          uint64_t v98 = 0LL;
          break;
      }

LABEL_129:
                uint64_t v399 = v247;
                goto LABEL_130;
              }
            }

            else
            {
              if (v221 < 64)
              {
LABEL_79:
                uint64_t v227 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                unint64_t v228 = v219;
                goto LABEL_80;
              }

              uint64_t v236 = v596;
              (*(void (**)(char *, char *, unint64_t *))(v646 + 32))(v596, v219, v69);
            }

            v153(v236, v69);
            goto LABEL_89;
          }

              swift_bridgeObjectRelease_n(v14, 5LL);
              uint64_t v20 = v233;
              if (!v63) {
                goto LABEL_130;
              }
              goto LABEL_216;
            }

      if ((v105 & ~v104 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v104 & 0xFFFFFFFFFFFFFFFLL))
      {
        uint64_t v119 = v259;
        uint64_t v120 = _StringGuts.nativeUnusedCapacity.getter(v258, v259);
        uint64_t v27 = a1;
        if ((v121 & 1) != 0) {
          goto LABEL_286;
        }
        x1_0 = v251;
        if (v118 > 15 || (v119 & 0x2000000000000000LL) == 0 && v120 >= v114)
        {
LABEL_137:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v118, v114);
          swift_bridgeObjectRelease_n(v84, 4LL);
          if ((v84 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v84);
            _StringGuts._foreignAppendInPlace(_:)(v110, v84, 0LL, v253);
          }

          else
          {
            if (v111)
            {
              swift_bridgeObjectRelease_n(v84, 2LL);
              *(void *)&unint64_t v257 = v110;
              *((void *)&v257 + 1) = v84 & 0xFFFFFFFFFFFFFFLL;
              uint64_t v122 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v112, (uint64_t)&v257, v112);
              _StringGuts.appendInPlace(_:isASCII:)(v122, v123, (v84 & 0x4000000000000000LL) != 0);
              goto LABEL_181;
            }

            if ((v110 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v84);
              unint64_t v166 = (id)((v84 & 0xFFFFFFFFFFFFFFFLL) + 32);
              char v167 = v250;
              uint64_t v168 = v250;
            }

            else
            {
              unint64_t v166 = _StringObject.sharedUTF8.getter(v110, v84);
              uint64_t v168 = v179;
              swift_bridgeObjectRelease(v84);
              char v167 = v250;
              if (v168 < v250) {
                goto LABEL_192;
              }
            }

            uint64_t v169 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v167, (uint64_t)v166, v168);
            _StringGuts.appendInPlace(_:isASCII:)(v169, v170, (v110 & 0x8000000000000000LL) != 0LL);
          }

          swift_bridgeObjectRelease(v84);
          goto LABEL_181;
        }
      }

      else
      {
        x1_0 = v251;
        uint64_t v27 = a1;
        if (v118 > 15) {
          goto LABEL_137;
        }
        uint64_t v119 = v259;
      }

      swift_bridgeObjectRelease_n(v84, 5LL);
      uint64_t v130 = v258;
      swift_bridgeObjectRetain(v119, v131, v132, v133);
      uint64_t v134 = _StringGuts._convertedToSmall()(v130, v119);
      unint64_t v136 = v135;
      swift_bridgeObjectRelease(v119);
      v137._Swift::UInt64 rawBits = (v253 << 16) | 1;
      v138._Swift::UInt64 rawBits = 1LL;
      v139._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v138, v137, v110, v84);
      if (v139._rawBits < 0x10000) {
        v139._rawBits |= 3;
      }
      unint64_t v141 = specialized String.init(_:)(v139, v140, v110, v84);
      unint64_t v143 = v142;
      swift_bridgeObjectRelease(v84);
      uint64_t v144 = _StringGuts._convertedToSmall()(v141, v143);
      int v146 = v145;
      swift_bridgeObjectRelease(v143);
      unint64_t v147 = specialized _SmallString.init(_:appending:)(v134, v136, v144, v146);
      if ((v149 & 1) != 0) {
        goto LABEL_285;
      }
      uint64_t v150 = v147;
      uint64_t v151 = v148;
      swift_bridgeObjectRelease(v119);
      uint64_t v258 = v150;
      uint64_t v259 = v151;
LABEL_181:
      uint64_t v84 = v258;
      uint64_t v110 = v259;
      swift_bridgeObjectRelease(*((uint64_t *)&v260 + 1));
      uint64_t v88 = 0;
      *(void *)&uint64_t v260 = v84;
      *((void *)&v260 + 1) = v110;
      if (v87 >= v255) {
        goto LABEL_194;
      }
    }

    uint64_t v127 = Unicode.Scalar._escaped(asASCII:)(1);
    uint64_t v124 = (unint64_t)v127.value._object;
    if (v127.value._object) {
      uint64_t countAndFlagsBits = v127.value._countAndFlagsBits;
    }
    else {
      uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v94);
    }
    char v129 = v124;
    uint64_t v164 = HIBYTE(v104) & 0xF;
    if ((v104 & 0x2000000000000000LL) == 0) {
      uint64_t v164 = v105 & 0xFFFFFFFFFFFFLL;
    }
    if (v164 || (v105 & ~v104 & 0x2000000000000000LL) != 0)
    {
      if ((v104 & 0x2000000000000000LL) == 0)
      {
        if ((v124 & 0x2000000000000000LL) != 0) {
LABEL_175:
        }
          uint64_t v165 = HIBYTE(v129) & 0xF;
        else {
LABEL_168:
        }
          uint64_t v165 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        uint64_t v27 = a1;
        swift_bridgeObjectRetain(v129, v124, v125, v126);
        _StringGuts.append(_:)(countAndFlagsBits, v129, 0LL, v165);
        swift_bridgeObjectRelease_n(v129, 2LL);
        x1_0 = v251;
        goto LABEL_97;
      }

      if ((v124 & 0x2000000000000000LL) == 0) {
        goto LABEL_168;
      }
      __int16 v171 = specialized _SmallString.init(_:appending:)(v105, v104, countAndFlagsBits, v124);
      if ((v125 & 1) != 0) {
        goto LABEL_175;
      }
      char v172 = v171;
      uint64_t v173 = v124;
      swift_bridgeObjectRelease(v104);
      swift_bridgeObjectRelease(v129);
      *(void *)&uint64_t v260 = v172;
      *((void *)&v260 + 1) = v173;
    }

    else
    {
      swift_bridgeObjectRelease(v104);
      *(void *)&uint64_t v260 = countAndFlagsBits;
      *((void *)&v260 + 1) = v129;
    }

    x1_0 = v251;
    uint64_t v27 = a1;
LABEL_97:
    uint64_t v88 = 1;
  }

  while (v87 < v255);
  uint64_t v84 = v260;
  uint64_t v110 = *((void *)&v260 + 1);
LABEL_194:
  uint64_t v85 = 0xE100000000000000LL;
LABEL_195:
  uint64_t v258 = 34LL;
  uint64_t v259 = 0xE100000000000000LL;
  uint64_t v180 = HIBYTE(v110) & 0xF;
  if ((v110 & 0x2000000000000000LL) == 0) {
    uint64_t v180 = v84 & 0xFFFFFFFFFFFFLL;
  }
  if (!v180) {
    goto LABEL_249;
  }
  while (2)
  {
    uint64_t v186 = v258;
    uint64_t v187 = v259;
    swift_bridgeObjectRetain(v259, v34, v35, v36);
    uint64_t v188 = specialized Collection.first.getter(v186, v187);
    swift_bridgeObjectRelease(v187);
    if ((v188 & 0x100000000LL) != 0)
    {
      unint64_t v240 = 839LL;
      goto LABEL_280;
    }

    *(void *)&unint64_t v257 = v84;
    *((void *)&v257 + 1) = v110;
    *(void *)&uint64_t v260 = 0LL;
    *((void *)&v260 + 1) = 0xE000000000000000LL;
    unint64_t v189 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v188);
    char v191 = v190;
    _StringGuts.append(_:)(v189, v190);
    swift_bridgeObjectRelease(v191);
    unint64_t v193 = *((void *)&v257 + 1);
    unint64_t v192 = v257;
    swift_bridgeObjectRetain(*((unint64_t *)&v257 + 1), v194, v195, v196);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v260 = __PAIR128__(v193, v192);
    uint64_t v200 = HIBYTE(v193) & 0xF;
    if ((v193 & 0x2000000000000000LL) == 0) {
      uint64_t v200 = v192;
    }
    uint64_t v201 = 7LL;
    if (((v193 >> 60) & ((v192 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v201 = 11LL;
    }
    v202._Swift::UInt64 rawBits = v201 | (v200 << 16);
    swift_bridgeObjectRetain(v193, v197, v198, v199);
    v203._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(v202)._rawBits;
    Swift::UInt64 rawBits = v203._rawBits;
    if (!(v203._rawBits >> 14))
    {
      if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
      }
      unint64_t v205 = 0LL;
      goto LABEL_222;
    }

    unint64_t v205 = v203._rawBits >> 16;
    if (v203._rawBits < 0x20000)
    {
LABEL_226:
      if (v205 <= 63) {
        uint64_t v210 = v205 << 8;
      }
      else {
        uint64_t v210 = 63LL;
      }
    }

    else
    {
      if ((v193 & 0x1000000000000000LL) != 0) {
        goto LABEL_225;
      }
      if ((v193 & 0x2000000000000000LL) != 0)
      {
        *(void *)&unint64_t v257 = v192;
        *((void *)&v257 + 1) = v193 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v207 = (char *)&v257 + v205;
      }

      else
      {
        if ((v192 & 0x1000000000000000LL) != 0)
        {
          unint64_t v206 = (char *)((v193 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          unint64_t v206 = (char *)_StringObject.sharedUTF8.getter(v192, v193);
          if (!v206) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
          }
        }

        unint64_t v207 = &v206[v205];
      }

      uint64_t v208 = *((unsigned __int16 *)v207 - 1);
      if (v208 == 2573 || (v208 & 0x80808080) != 0)
      {
LABEL_225:
        unint64_t v205 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
        goto LABEL_226;
      }

      unint64_t v205 = 1LL;
LABEL_222:
      uint64_t v210 = v205 << 8;
    }

    v211._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v202)._rawBits;
    if (!(v211._rawBits >> 14)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
    }
    unint64_t v212 = v211._rawBits;
    swift_bridgeObjectRelease(v193);
    if ((v193 & 0x1000000000000000LL) != 0)
    {
      char v217 = String.UnicodeScalarView._foreignIndex(before:)((Swift::String::Index)v212)._rawBits;
      swift_bridgeObjectRelease(v193);
    }

    else
    {
      if ((v193 & 0x2000000000000000LL) != 0)
      {
        char v214 = 0LL;
        *(void *)&unint64_t v257 = v192;
        *((void *)&v257 + 1) = v193 & 0xFFFFFFFFFFFFFFLL;
        do
          uint64_t v216 = *(&v256 + (v212 >> 16) + v214--) & 0xC0;
        while (v216 == 128);
      }

      else
      {
        if ((v192 & 0x1000000000000000LL) != 0) {
          char v213 = (char *)((v193 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          char v213 = (char *)_StringObject.sharedUTF8.getter(v192, v193);
        }
        char v214 = 0LL;
        do
          unint64_t v215 = v213[(v212 >> 16) - 1 + v214--] & 0xC0;
        while (v215 == 128);
      }

      swift_bridgeObjectRelease(v193);
      char v217 = (v212 - -65536 * v214) & 0xFFFFFFFFFFFF0000LL | 5;
    }

    if (((rawBits - (v205 << 16)) & 0xFFFFFFFFFFFF0000LL | v210) >> 14 >= v217 >> 14)
    {
      v221._Swift::UInt64 rawBits = specialized Collection.dropFirst(_:)(1LL, v258, v259);
      uint64_t v223 = v222;
      *(void *)&unint64_t v257 = v192;
      *((void *)&v257 + 1) = v193;
      *(void *)&uint64_t v260 = 0LL;
      *((void *)&v260 + 1) = 0xE000000000000000LL;
      specialized String.UnicodeScalarView.append<A>(contentsOf:)(v221, v262, v224, v222);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      swift_bridgeObjectRelease(v223);
      uint64_t v110 = *((void *)&v257 + 1);
      uint64_t v84 = v257;
      goto LABEL_250;
    }

    *(void *)&unint64_t v257 = v192;
    *((void *)&v257 + 1) = v193;
    specialized RangeReplaceableCollection<>.removeLast()();
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v218 = specialized RangeReplaceableCollection<>.removeLast()();
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v260 = v257;
    uint64_t v219 = Unicode.Scalar._escaped(asASCII:)(1);
    uint64_t v181 = v219.value._object;
    if (v219.value._object) {
      uint64_t v182 = v219.value._countAndFlagsBits;
    }
    else {
      uint64_t v182 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v218);
    }
    uint64_t v220 = (unint64_t)v181;
    v183._Swift::UInt64 rawBits = 15LL;
    v184._Swift::UInt64 rawBits = 15LL;
    specialized String.UnicodeScalarView.replaceSubrange<A>(_:with:)(v183, v184, v182, v220);
    swift_bridgeObjectRelease(v220);
    uint64_t v84 = v260;
    uint64_t v110 = *((void *)&v260 + 1);
    unint64_t v185 = HIBYTE(*((void *)&v260 + 1)) & 0xFLL;
    if ((*((void *)&v260 + 1) & 0x2000000000000000LL) == 0) {
      unint64_t v185 = v260 & 0xFFFFFFFFFFFFLL;
    }
    if (v185) {
      continue;
    }
    break;
  }

  uint64_t v85 = v259;
LABEL_249:
  swift_bridgeObjectRelease(v85);
LABEL_250:
  uint64_t v117 = v261._countAndFlagsBits;
  uint64_t v114 = (int64_t)v261._object;
  unint64_t v228 = ((unint64_t)v261._object >> 56) & 0xF;
  if (!v228 && (v261._countAndFlagsBits & ~(uint64_t)v261._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v261._object);
    v261._uint64_t countAndFlagsBits = v84;
    v261._unint64_t object = (void *)v110;
    goto LABEL_264;
  }

  if (((uint64_t)v261._object & 0x2000000000000000LL) != 0)
  {
    if ((v110 & 0x2000000000000000LL) != 0)
    {
LABEL_260:
      uint64_t v230 = specialized _SmallString.init(_:appending:)(v117, v114, v84, v110);
      if ((v226 & 1) != 0) {
        goto LABEL_262;
      }
      char v231 = v230;
      unint64_t v232 = (void *)v225;
      swift_bridgeObjectRelease(v114);
      swift_bridgeObjectRelease(v110);
      v261._uint64_t countAndFlagsBits = v231;
      v261._unint64_t object = v232;
      uint64_t v110 = (unint64_t)v232;
      uint64_t v84 = v231;
      goto LABEL_264;
    }

      if ((v105 & ~v104 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v104 & 0xFFFFFFFFFFFFFFFLL))
      {
        uint64_t v119 = v259;
        uint64_t v120 = _StringGuts.nativeUnusedCapacity.getter(v258, v259);
        uint64_t v27 = a1;
        if ((v121 & 1) != 0) {
          goto LABEL_286;
        }
        x1_0 = v251;
        if (v118 > 15 || (v119 & 0x2000000000000000LL) == 0 && v120 >= v114)
        {
LABEL_137:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v118, v114);
          swift_bridgeObjectRelease_n(v84, 4LL);
          if ((v84 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v84);
            _StringGuts._foreignAppendInPlace(_:)(v110, v84, 0LL, v253);
          }

          else
          {
            if (v111)
            {
              swift_bridgeObjectRelease_n(v84, 2LL);
              *(void *)&unint64_t v257 = v110;
              *((void *)&v257 + 1) = v84 & 0xFFFFFFFFFFFFFFLL;
              uint64_t v122 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v112, (uint64_t)&v257, v112);
              _StringGuts.appendInPlace(_:isASCII:)(v122, v123, (v84 & 0x4000000000000000LL) != 0);
              goto LABEL_181;
            }

            if ((v110 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v84);
              unint64_t v166 = (id)((v84 & 0xFFFFFFFFFFFFFFFLL) + 32);
              char v167 = v250;
              uint64_t v168 = v250;
            }

            else
            {
              unint64_t v166 = _StringObject.sharedUTF8.getter(v110, v84);
              uint64_t v168 = v179;
              swift_bridgeObjectRelease(v84);
              char v167 = v250;
              if (v168 < v250) {
                goto LABEL_192;
              }
            }

            uint64_t v169 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v167, (uint64_t)v166, v168);
            _StringGuts.appendInPlace(_:isASCII:)(v169, v170, (v110 & 0x8000000000000000LL) != 0LL);
          }

          swift_bridgeObjectRelease(v84);
          goto LABEL_181;
        }
      }

      else
      {
        x1_0 = v251;
        uint64_t v27 = a1;
        if (v118 > 15) {
          goto LABEL_137;
        }
        uint64_t v119 = v259;
      }

      swift_bridgeObjectRelease_n(v84, 5LL);
      uint64_t v130 = v258;
      swift_bridgeObjectRetain(v119, v131, v132, v133);
      uint64_t v134 = _StringGuts._convertedToSmall()(v130, v119);
      unint64_t v136 = v135;
      swift_bridgeObjectRelease(v119);
      v137._Swift::UInt64 rawBits = (v253 << 16) | 1;
      v138._Swift::UInt64 rawBits = 1LL;
      v139._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v138, v137, v110, v84);
      if (v139._rawBits < 0x10000) {
        v139._rawBits |= 3;
      }
      unint64_t v141 = specialized String.init(_:)(v139, v140, v110, v84);
      unint64_t v143 = v142;
      swift_bridgeObjectRelease(v84);
      uint64_t v144 = _StringGuts._convertedToSmall()(v141, v143);
      int v146 = v145;
      swift_bridgeObjectRelease(v143);
      unint64_t v147 = specialized _SmallString.init(_:appending:)(v134, v136, v144, v146);
      if ((v149 & 1) != 0) {
        goto LABEL_285;
      }
      uint64_t v150 = v147;
      uint64_t v151 = v148;
      swift_bridgeObjectRelease(v119);
      uint64_t v258 = v150;
      uint64_t v259 = v151;
LABEL_181:
      uint64_t v84 = v258;
      uint64_t v110 = v259;
      swift_bridgeObjectRelease(*((uint64_t *)&v260 + 1));
      uint64_t v88 = 0;
      *(void *)&uint64_t v260 = v84;
      *((void *)&v260 + 1) = v110;
      if (v87 >= v255) {
        goto LABEL_194;
      }
    }

    uint64_t v127 = Unicode.Scalar._escaped(asASCII:)(1);
    uint64_t v124 = (unint64_t)v127.value._object;
    if (v127.value._object) {
      uint64_t countAndFlagsBits = v127.value._countAndFlagsBits;
    }
    else {
      uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v94);
    }
    char v129 = v124;
    uint64_t v164 = HIBYTE(v104) & 0xF;
    if ((v104 & 0x2000000000000000LL) == 0) {
      uint64_t v164 = v105 & 0xFFFFFFFFFFFFLL;
    }
    if (v164 || (v105 & ~v104 & 0x2000000000000000LL) != 0)
    {
      if ((v104 & 0x2000000000000000LL) == 0)
      {
        if ((v124 & 0x2000000000000000LL) != 0) {
LABEL_175:
        }
          uint64_t v165 = HIBYTE(v129) & 0xF;
        else {
LABEL_168:
        }
          uint64_t v165 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        uint64_t v27 = a1;
        swift_bridgeObjectRetain(v129, v124, v125, v126);
        _StringGuts.append(_:)(countAndFlagsBits, v129, 0LL, v165);
        swift_bridgeObjectRelease_n(v129, 2LL);
        x1_0 = v251;
        goto LABEL_97;
      }

      if ((v124 & 0x2000000000000000LL) == 0) {
        goto LABEL_168;
      }
      __int16 v171 = specialized _SmallString.init(_:appending:)(v105, v104, countAndFlagsBits, v124);
      if ((v125 & 1) != 0) {
        goto LABEL_175;
      }
      char v172 = v171;
      uint64_t v173 = v124;
      swift_bridgeObjectRelease(v104);
      swift_bridgeObjectRelease(v129);
      *(void *)&uint64_t v260 = v172;
      *((void *)&v260 + 1) = v173;
    }

    else
    {
      swift_bridgeObjectRelease(v104);
      *(void *)&uint64_t v260 = countAndFlagsBits;
      *((void *)&v260 + 1) = v129;
    }

    x1_0 = v251;
    uint64_t v27 = a1;
LABEL_97:
    uint64_t v88 = 1;
  }

  while (v87 < v255);
  uint64_t v84 = v260;
  uint64_t v110 = *((void *)&v260 + 1);
LABEL_194:
  uint64_t v85 = 0xE100000000000000LL;
LABEL_195:
  uint64_t v258 = 34LL;
  uint64_t v259 = 0xE100000000000000LL;
  uint64_t v180 = HIBYTE(v110) & 0xF;
  if ((v110 & 0x2000000000000000LL) == 0) {
    uint64_t v180 = v84 & 0xFFFFFFFFFFFFLL;
  }
  if (!v180) {
    goto LABEL_249;
  }
  while (2)
  {
    uint64_t v186 = v258;
    uint64_t v187 = v259;
    swift_bridgeObjectRetain(v259, v34, v35, v36);
    uint64_t v188 = specialized Collection.first.getter(v186, v187);
    swift_bridgeObjectRelease(v187);
    if ((v188 & 0x100000000LL) != 0)
    {
      unint64_t v240 = 839LL;
      goto LABEL_280;
    }

    *(void *)&unint64_t v257 = v84;
    *((void *)&v257 + 1) = v110;
    *(void *)&uint64_t v260 = 0LL;
    *((void *)&v260 + 1) = 0xE000000000000000LL;
    unint64_t v189 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v188);
    char v191 = v190;
    _StringGuts.append(_:)(v189, v190);
    swift_bridgeObjectRelease(v191);
    unint64_t v193 = *((void *)&v257 + 1);
    unint64_t v192 = v257;
    swift_bridgeObjectRetain(*((unint64_t *)&v257 + 1), v194, v195, v196);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v260 = __PAIR128__(v193, v192);
    uint64_t v200 = HIBYTE(v193) & 0xF;
    if ((v193 & 0x2000000000000000LL) == 0) {
      uint64_t v200 = v192;
    }
    uint64_t v201 = 7LL;
    if (((v193 >> 60) & ((v192 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v201 = 11LL;
    }
    v202._Swift::UInt64 rawBits = v201 | (v200 << 16);
    swift_bridgeObjectRetain(v193, v197, v198, v199);
    v203._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(v202)._rawBits;
    Swift::UInt64 rawBits = v203._rawBits;
    if (!(v203._rawBits >> 14))
    {
      if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
      }
      unint64_t v205 = 0LL;
      goto LABEL_222;
    }

    unint64_t v205 = v203._rawBits >> 16;
    if (v203._rawBits < 0x20000)
    {
LABEL_226:
      if (v205 <= 63) {
        uint64_t v210 = v205 << 8;
      }
      else {
        uint64_t v210 = 63LL;
      }
    }

    else
    {
      if ((v193 & 0x1000000000000000LL) != 0) {
        goto LABEL_225;
      }
      if ((v193 & 0x2000000000000000LL) != 0)
      {
        *(void *)&unint64_t v257 = v192;
        *((void *)&v257 + 1) = v193 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v207 = (char *)&v257 + v205;
      }

      else
      {
        if ((v192 & 0x1000000000000000LL) != 0)
        {
          unint64_t v206 = (char *)((v193 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          unint64_t v206 = (char *)_StringObject.sharedUTF8.getter(v192, v193);
          if (!v206) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
          }
        }

        unint64_t v207 = &v206[v205];
      }

      uint64_t v208 = *((unsigned __int16 *)v207 - 1);
      if (v208 == 2573 || (v208 & 0x80808080) != 0)
      {
LABEL_225:
        unint64_t v205 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
        goto LABEL_226;
      }

      unint64_t v205 = 1LL;
LABEL_222:
      uint64_t v210 = v205 << 8;
    }

    v211._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v202)._rawBits;
    if (!(v211._rawBits >> 14)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
    }
    unint64_t v212 = v211._rawBits;
    swift_bridgeObjectRelease(v193);
    if ((v193 & 0x1000000000000000LL) != 0)
    {
      char v217 = String.UnicodeScalarView._foreignIndex(before:)((Swift::String::Index)v212)._rawBits;
      swift_bridgeObjectRelease(v193);
    }

    else
    {
      if ((v193 & 0x2000000000000000LL) != 0)
      {
        char v214 = 0LL;
        *(void *)&unint64_t v257 = v192;
        *((void *)&v257 + 1) = v193 & 0xFFFFFFFFFFFFFFLL;
        do
          uint64_t v216 = *(&v256 + (v212 >> 16) + v214--) & 0xC0;
        while (v216 == 128);
      }

      else
      {
        if ((v192 & 0x1000000000000000LL) != 0) {
          char v213 = (char *)((v193 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          char v213 = (char *)_StringObject.sharedUTF8.getter(v192, v193);
        }
        char v214 = 0LL;
        do
          unint64_t v215 = v213[(v212 >> 16) - 1 + v214--] & 0xC0;
        while (v215 == 128);
      }

      swift_bridgeObjectRelease(v193);
      char v217 = (v212 - -65536 * v214) & 0xFFFFFFFFFFFF0000LL | 5;
    }

    if (((rawBits - (v205 << 16)) & 0xFFFFFFFFFFFF0000LL | v210) >> 14 >= v217 >> 14)
    {
      v221._Swift::UInt64 rawBits = specialized Collection.dropFirst(_:)(1LL, v258, v259);
      uint64_t v223 = v222;
      *(void *)&unint64_t v257 = v192;
      *((void *)&v257 + 1) = v193;
      *(void *)&uint64_t v260 = 0LL;
      *((void *)&v260 + 1) = 0xE000000000000000LL;
      specialized String.UnicodeScalarView.append<A>(contentsOf:)(v221, v262, v224, v222);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      swift_bridgeObjectRelease(v223);
      uint64_t v110 = *((void *)&v257 + 1);
      uint64_t v84 = v257;
      goto LABEL_250;
    }

    *(void *)&unint64_t v257 = v192;
    *((void *)&v257 + 1) = v193;
    specialized RangeReplaceableCollection<>.removeLast()();
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v218 = specialized RangeReplaceableCollection<>.removeLast()();
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v260 = v257;
    uint64_t v219 = Unicode.Scalar._escaped(asASCII:)(1);
    uint64_t v181 = v219.value._object;
    if (v219.value._object) {
      uint64_t v182 = v219.value._countAndFlagsBits;
    }
    else {
      uint64_t v182 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v218);
    }
    uint64_t v220 = (unint64_t)v181;
    v183._Swift::UInt64 rawBits = 15LL;
    v184._Swift::UInt64 rawBits = 15LL;
    specialized String.UnicodeScalarView.replaceSubrange<A>(_:with:)(v183, v184, v182, v220);
    swift_bridgeObjectRelease(v220);
    uint64_t v84 = v260;
    uint64_t v110 = *((void *)&v260 + 1);
    unint64_t v185 = HIBYTE(*((void *)&v260 + 1)) & 0xFLL;
    if ((*((void *)&v260 + 1) & 0x2000000000000000LL) == 0) {
      unint64_t v185 = v260 & 0xFFFFFFFFFFFFLL;
    }
    if (v185) {
      continue;
    }
    break;
  }

  uint64_t v85 = v259;
LABEL_249:
  swift_bridgeObjectRelease(v85);
LABEL_250:
  uint64_t v117 = v261._countAndFlagsBits;
  uint64_t v114 = (int64_t)v261._object;
  unint64_t v228 = ((unint64_t)v261._object >> 56) & 0xF;
  if (!v228 && (v261._countAndFlagsBits & ~(uint64_t)v261._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v261._object);
    v261._uint64_t countAndFlagsBits = v84;
    v261._unint64_t object = (void *)v110;
    goto LABEL_264;
  }

  if (((uint64_t)v261._object & 0x2000000000000000LL) != 0)
  {
    if ((v110 & 0x2000000000000000LL) != 0)
    {
LABEL_260:
      uint64_t v230 = specialized _SmallString.init(_:appending:)(v117, v114, v84, v110);
      if ((v226 & 1) != 0) {
        goto LABEL_262;
      }
      char v231 = v230;
      unint64_t v232 = (void *)v225;
      swift_bridgeObjectRelease(v114);
      swift_bridgeObjectRelease(v110);
      v261._uint64_t countAndFlagsBits = v231;
      v261._unint64_t object = v232;
      uint64_t v110 = (unint64_t)v232;
      uint64_t v84 = v231;
      goto LABEL_264;
    }

LABEL_66:
          v153(v125, v69);
          if ((v643[21](v649) & 1) != 0)
          {
            uint64_t result = 0LL;
            __int16 v171 = 0x8000;
          }

          else
          {
            uint64_t result = 0LL;
            __int16 v171 = 0;
          }

          goto LABEL_76;
        }

        char v172 = v154(v69, v67);
        uint64_t v155 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
        if ((v172 & 1) != 0)
        {
          if (v155 > 64) {
            goto LABEL_31;
          }
          uint64_t v208 = v639;
          ((void (*)(uint64_t *, uint64_t))v629)(&qword_18180BE68, 256LL);
          v627(v208, v69, v640);
          LOBYTE(v208) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                       + 16LL))( v120,  v123,  v69);
          v153(v123, v69);
          uint64_t v209 = v604;
          (*(void (**)(char *, char *, unint64_t *))(v646 + 32))(v604, v120, v69);
          if ((v208 & 1) != 0)
          {
            v153(v209, v69);
            goto LABEL_66;
          }

          uint64_t v186 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
          uint64_t v187 = v209;
        }

        else
        {
          if (v155 >= 64)
          {
            uint64_t v210 = v603;
            (*(void (**)(char *, char *, unint64_t *))(v646 + 32))(v603, v120, v69);
            v153(v210, v69);
            goto LABEL_68;
          }

          uint64_t v186 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
          uint64_t v187 = v120;
        }

        v153(v187, v69);
        if (v186 >= -24) {
          goto LABEL_68;
        }
        goto LABEL_66;
      }

      if (v130 <= 64)
      {
        uint64_t v139 = (void (**)(char *, unint64_t *, const char *))v640;
        uint64_t v140 = v638;
        unint64_t v141 = swift_getAssociatedConformanceWitness( (uint64_t)v640,  (uint64_t)v69,  (uint64_t)v638,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v142 = v639;
        (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void), unint64_t))(v141 + 8))( &qword_18180BE68,  256LL,  v140,  v141);
        v139[3](v142, v69, (const char *)v139);
        LOBYTE(v139) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v125,  v123,  v69);
        unint64_t v143 = v646;
        unint64_t v136 = *(void (**)(char *, unint64_t *))(v646 + 8);
        v136(v123, v69);
        (*(void (**)(char *, char *, unint64_t *))(v143 + 16))(v75, v125, v69);
        if ((v139 & 1) != 0)
        {
          v136(v75, v69);
        }

        else
        {
          uint64_t v128 = v653;
          uint64_t v144 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
          v136(v75, v69);
          if (v144 >= v128) {
            goto LABEL_22;
          }
        }

        goto LABEL_18;
      }
    }

    uint64_t v134 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
    unint64_t v135 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
    v134(&v653, &type metadata for Int, v135, v69, v67);
    LOBYTE(v134) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v125,  v123,  v69);
    unint64_t v136 = *(void (**)(char *, unint64_t *))(v646 + 8);
    v136(v123, v69);
    goto LABEL_18;
  }

  uint64_t v566 = v65;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v65 + 400))(a3, v65) & 1) != 0)
  {
    char v567 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 168))(a3, v65);
    unint64_t v523 = v635;
    if ((v567 & 1) != 0)
    {
LABEL_270:
      __int16 *v523 = -1024;
      return 1LL;
    }

    __int16 *v635 = 31744;
    return 1LL;
  }

  v568 = v644;
  v569 = (void (*)(uint64_t, unint64_t *))v644[15];
  v569(a3, v644);
  char v570 = v588;
  (*(void (**)(uint64_t, uint64_t))(v65 + 96))(a3, v65);
  uint64_t v571 = v586;
  v569(a3, v568);
  char v572 = *(void (**)(char *, uint64_t))(v645 + 8);
  v572(v570, a3);
  unsigned int v573 = v648;
  (*(void (**)(uint64_t, uint64_t))(v566 + 104))(a3, v566);
  uint64_t v574 = v587;
  v569(a3, v568);
  v572(v573, a3);
  unint64_t v575 = v651;
  v576 = v626;
  v577 = v634;
  (*(void (**)(char *, char *, unint64_t *, unint64_t))(v651 + 208))(v571, v574, v634, v651);
  v578 = *(void (**)(char *, unint64_t *))(v636 + 8);
  v578(v574, v577);
  v578(v571, v577);
  v579 = v633;
  (*(void (**)(char *, unint64_t *, unint64_t))(v575 + 184))(v576, v577, v575);
  v578(v576, v577);
  v580 = v642;
  uint64_t v581 = (char *)v643;
  (*(void (**)(char *, char *, unint64_t *, unint64_t))(v575 + 192))(v642, v579, v577, v575);
  v578(v579, v577);
  v578(v580, v577);
  LOBYTE(v575) = (*(uint64_t (**)(unint64_t *, unint64_t))(v575 + 120))(v577, v575);
  v578(v581, v577);
  LOWORD(v578) = v575;
  LOBYTE(v575) = (*(uint64_t (**)(uint64_t, uint64_t))(v566 + 416))(a3, v566);
  __int16 v582 = (*(uint64_t (**)(uint64_t, uint64_t))(v566 + 168))(a3, v566);
  uint64_t result = 0LL;
  __int16 v583 = (unsigned __int16)v578 | (v582 << 15);
  if ((v575 & 1) != 0) {
    __int16 v584 = 32000;
  }
  else {
    __int16 v584 = 32256;
  }
  __int16 *v635 = v583 | v584;
  return result;
}

  unint64_t v363 = (uint64_t)v242;
  uint64_t v364 = v756;
  ((void (*)(uint64_t *, uint64_t))v730)(&qword_18180BE70, 512LL);
  uint64_t v365 = v776;
  ((void (*)(char *, unint64_t *, char *))v721)(v364, v245, v757);
  uint64_t v366 = v726;
  v719(v781, v365, v245, v720);
  ((void (*)(char *, unint64_t *))v241)(v365, v245);
  LODWORD(v365) = ((uint64_t (*)(unint64_t *, uint64_t))v246)(v245, v244);
  if (((v365 ^ ((unsigned int (*)(uint64_t, uint64_t))v762)(v237, v363)) & 1) == 0)
  {
    unint64_t v382 = v243;
    v383 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v245, v244);
    unsigned int v384 = v366;
    unint64_t v385 = v768;
    if (v383 >= ((uint64_t (*)(uint64_t, uint64_t))v761)(v237, v363))
    {
      unint64_t v390 = v770;
      (*(void (**)(char *, char *, uint64_t))(v382 + 16))(v770, v385, v237);
      v376 = v776;
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, uint64_t))(v244 + 96))( v390,  v237,  v363,  v245,  v244);
      unint64_t v391 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v244 + 16) + 8LL)
                                                                           + 8LL))( v384,  v376,  v245);
      unint64_t v392 = v766;
      ((void (*)(char *, unint64_t *))v766)(v376, v245);
      ((void (*)(char *, unint64_t *))v392)(v384, v245);
      uint64_t v388 = v782;
      unint64_t v377 = v363;
      uint64_t v373 = (uint64_t)v390;
      unint64_t v381 = (char **)v759;
      if ((v391 & 1) != 0) {
        goto LABEL_100;
      }
      goto LABEL_117;
    }

    unsigned __int16 v386 = v770;
    (*(void (**)(char *, unint64_t *, uint64_t, uint64_t, uint64_t))(v363 + 96))( v384,  v245,  v244,  v237,  v363);
    unint64_t v387 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v363 + 16) + 8LL) + 8LL))( v386,  v385,  v237);
    (*(void (**)(char *, uint64_t))(v382 + 8))(v386, v237);
    uint64_t v388 = v782;
    unint64_t v377 = v363;
    uint64_t v373 = (uint64_t)v386;
    goto LABEL_74;
  }

  char v367 = ((uint64_t (*)(unint64_t *, uint64_t))v246)(v245, v244);
  v733 = v245;
  unint64_t v368 = v245;
  char v369 = v244;
  char v370 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v368, v244);
  unint64_t v371 = v768;
  v758 = v237;
  char v372 = ((uint64_t (*)(uint64_t, uint64_t))v761)(v237, v363);
  if ((v367 & 1) == 0)
  {
    uint64_t v388 = v782;
    unint64_t v389 = v770;
    if (v370 >= v372)
    {
      char v433 = (void (**)(char *, uint64_t, const char *))v724;
      v434 = v758;
      v435 = v722;
      unint64_t v436 = swift_getAssociatedConformanceWitness( (uint64_t)v724,  v758,  v722,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v437 = v723;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v436 + 8))( &unk_18180BE68,  256LL,  v435,  v436);
      v433[3](v437, v434, (const char *)v433);
      LOBYTE(v433) = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v774[4] + 1) + 32LL))( v371,  v389,  v434);
      uint64_t v438 = v772;
      char v439 = *(void (**)(char *, uint64_t))(v772 + 8);
      v439(v389, v434);
      unint64_t v440 = v686;
      uint64_t v441 = v733;
      (*(void (**)(char *, char *, unint64_t *))(v777 + 32))(v686, v726, v733);
      uint64_t v442 = *(void (**)(char *, char *, uint64_t))(v438 + 16);
      uint64_t v443 = v687;
      v442(v687, v371, v434);
      if ((v433 & 1) != 0)
      {
        unint64_t v237 = v434;
        v376 = v776;
        char v444 = v434;
        unint64_t v445 = (uint64_t)v774;
        (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v369 + 96))( v443,  v444,  v774,  v441,  v369);
        char v446 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v369 + 16) + 8LL)
                                                                             + 8LL))( v440,  v376,  v441);
        uint64_t v447 = v766;
        ((void (*)(char *, unint64_t *))v766)(v376, v441);
        ((void (*)(char *, unint64_t *))v447)(v440, v441);
        unint64_t v377 = v445;
        uint64_t v373 = (uint64_t)v389;
        unint64_t v381 = (char **)v759;
        uint64_t v245 = v441;
        if ((v446 & 1) != 0) {
          goto LABEL_100;
        }
        goto LABEL_117;
      }

      v439(v443, v434);
      v429 = v440;
      uint64_t v245 = v441;
      goto LABEL_116;
    }

    unint64_t v377 = (uint64_t)v774;
    uint64_t v245 = v733;
    unint64_t v237 = v758;
    ((void (*)(char *))v774[12])(v726);
    unint64_t v387 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v377 + 16) + 8LL) + 8LL))( v389,  v371,  v237);
    (*(void (**)(char *, uint64_t))(v772 + 8))(v389, v237);
    uint64_t v373 = (uint64_t)v389;
LABEL_74:
    unint64_t v381 = (char **)v759;
    v376 = v776;
    if ((v387 & 1) != 0) {
      goto LABEL_100;
    }
    goto LABEL_117;
  }

  if (v372 < v370)
  {
    uint64_t v373 = (uint64_t)v770;
    unint64_t v237 = v758;
    (*(void (**)(char *, char *, uint64_t))(v772 + 16))(v770, v371, v758);
    uint64_t v374 = v369;
    uint64_t v375 = *(void (**)(uint64_t, uint64_t, char **, unint64_t *, uint64_t))(v369 + 96);
    v376 = v776;
    unint64_t v377 = (uint64_t)v774;
    uint64_t v245 = v733;
    v375(v373, v237, v774, v733, v374);
    unint64_t v378 = v726;
    unint64_t v379 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v374 + 16) + 8LL)
                                                                         + 8LL))( v726,  v376,  v245);
    char v380 = v766;
    ((void (*)(char *, unint64_t *))v766)(v376, v245);
    ((void (*)(char *, unint64_t *))v380)(v378, v245);
    unint64_t v381 = (char **)v759;
    goto LABEL_96;
  }

  unint64_t v425 = v756;
  ((void (*)(void *, uint64_t))v730)(&unk_18180BE68, 256LL);
  unint64_t v426 = v776;
  int v427 = v733;
  ((void (*)(char *, unint64_t *, char *))v721)(v425, v733, v757);
  uint64_t v245 = v427;
  uint64_t v428 = v726;
  LOBYTE(v425) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v244 + 32) + 8LL)
                                                                               + 32LL))( v726,  v426,  v427);
  ((void (*)(char *, unint64_t *))v766)(v426, v427);
  v429 = v684;
  (*(void (**)(char *, char *, unint64_t *))(v777 + 32))(v684, v428, v427);
  uint64_t v430 = v688;
  unint64_t v237 = v758;
  (*(void (**)(char *, char *, uint64_t))(v772 + 16))(v688, v371, v758);
  if ((v425 & 1) == 0)
  {
    (*(void (**)(char *, uint64_t))(v772 + 8))(v430, v237);
LABEL_116:
    ((void (*)(char *, unint64_t *))v766)(v429, v245);
    unint64_t v381 = (char **)v759;
    v376 = v776;
    unint64_t v377 = (uint64_t)v774;
    uint64_t v388 = v782;
    uint64_t v373 = (uint64_t)v770;
    unint64_t v237 = v758;
    goto LABEL_117;
  }

  unint64_t v377 = (uint64_t)v774;
  uint64_t v431 = v770;
  ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v774[12])(v429, v427, v244, v237, v774);
  unint64_t v379 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v377 + 16) + 8LL) + 8LL))( v431,  v430,  v237);
  unint64_t v432 = *(void (**)(char *, uint64_t))(v772 + 8);
  v432(v431, v237);
  v432(v430, v237);
  uint64_t v373 = (uint64_t)v431;
  unint64_t v381 = (char **)v759;
  v376 = v776;
LABEL_96:
  uint64_t v388 = v782;
  if ((v379 & 1) == 0)
  {
LABEL_117:
    ((void (*)(char **, char **))v381)(v778, v388);
    v769 = (char *)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral;
    uint64_t v513 = v713;
    int v514 = v752;
    v515 = v712;
    unint64_t v516 = swift_getAssociatedConformanceWitness( (uint64_t)v713,  (uint64_t)v752,  v712,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    unsigned int v517 = v711;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v516 + 8))( &unk_18180BE68,  256LL,  v515,  v516);
    (*((void (**)(char *, unint64_t *, const char *))v513 + 3))(v517, v514, v513);
    (*(void (**)(char *, unint64_t, unint64_t *))(v777 + 32))(v376, v781, v245);
    uint64_t v518 = v706;
    (*(void (**)(char *, unint64_t *, uint64_t, uint64_t, uint64_t))(v377 + 88))( v376,  v245,  v773,  v237,  v377);
    unsigned int v519 = v768;
    (*(void (**)(char *, char *, uint64_t))(*((void *)v710 + 1) + 40LL))(v518, v768, v237);
    uint64_t v520 = *(void (**)(char *, uint64_t))(v772 + 8);
    v520(v518, v237);
    uint64_t v521 = ((uint64_t (*)(char *, uint64_t))v520)(v519, v237);
    int64_t v524 = lazy protocol witness table accessor for type Int and conformance Int(v521, v522, v523);
    lazy protocol witness table accessor for type Int and conformance Int(v524, v525, v526);
    SignedInteger<>.init<A>(_:)(v373, (uint64_t)&type metadata for Int, v237, v524, v377, (uint64_t)&v783);
    v527 = (char *)v783;
    uint64_t v528 = v771;
    unint64_t v529 = v779;
    v777 = *(void *)(v771 + 136);
    v530 = ((uint64_t (*)(uint64_t, uint64_t))v777)(v779, v771);
    unint64_t v531 = v763;
    v778 = *(char ***)(v528 + 120);
    ((void (*)(uint64_t, uint64_t))v778)(v529, v528);
    v532 = v743;
    unsigned int v533 = (*(uint64_t (**)(unint64_t *))(v753 + 144))(v743);
    unint64_t v381 = *(char ***)(v734 + 8);
    ((void (*)(char *, unint64_t *))v381)(v531, v532);
    v781 = (unint64_t)&v527[-v530 - v533];
    unint64_t v512 = v764;
    LOBYTE(v53specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = (*(uint64_t (**)(uint64_t, uint64_t))(v764 + 368))(v529, v764);
    int v534 = v715;
    char v484 = v746;
    uint64_t v535 = v714;
    unint64_t v536 = swift_getAssociatedConformanceWitness( (uint64_t)v715,  (uint64_t)v746,  v714,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)v769);
    unsigned __int8 v537 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v536 + 8);
    v776 = v527;
    if ((v530 & 1) != 0)
    {
      uint64_t v538 = v709;
      v537(&qword_18180BE70, 512LL, v535, v536);
      int v539 = v749;
      v540 = (*((uint64_t (**)(char *, unint64_t *, const char *))v534 + 3))(v538, v484, v534);
      v783 = (uint64_t)v527;
      unint64_t v541 = v735;
      unint64_t v542 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, void *))v735[32];
      char v545 = lazy protocol witness table accessor for type Int and conformance Int(v540, v543, v544);
      v542(v539, &v783, &type metadata for Int, v545, v484, v541);
      (*(void (**)(char *, unint64_t *))(v748 + 8))(v539, v484);
    }

    else
    {
      uint64_t v546 = v709;
      v537((uint64_t *)&unk_18180BE68, 256LL, v535, v536);
      (*((void (**)(char *, unint64_t *, const char *))v534 + 3))(v546, v484, v534);
      unint64_t v541 = v735;
    }

    uint64_t v388 = v708;
    uint64_t v547 = v753;
    uint64_t v473 = (uint64_t)v743;
    uint64_t v448 = v781;
    v774 = v381;
    if ((v781 & 0x8000000000000000LL) == 0)
    {
      v548 = v763;
      ((void (*)(uint64_t, uint64_t))v778)(v779, v771);
      v549 = v749;
      unint64_t v550 = ((uint64_t (*)(char *, uint64_t, uint64_t, unint64_t *, void *))v541[11])( v548,  v473,  v547,  v484,  v541);
      v783 = v448;
      uint64_t v551 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, void *))v541[32];
      uint64_t v554 = lazy protocol witness table accessor for type Int and conformance Int(v550, v552, v553);
      v551(v549, &v783, &type metadata for Int, v554, v484, v541);
      uint64_t v555 = v748;
      (*(void (**)(char *, unint64_t *))(v748 + 8))(v549, v484);
LABEL_124:
      uint64_t v511 = v740;
      v563 = v732;
      ((void (*)(char *, char **, unint64_t *, void *))v541[26])(v732, v388, v484, v541);
      char v564 = *(void (**)(char **, unint64_t *))(v555 + 8);
      v564(v388, v484);
      v564((char **)v563, v484);
      v504 = v555;
      goto LABEL_125;
    }

    uint64_t v556 = v736;
    unint64_t v557 = ((uint64_t (*)(uint64_t, uint64_t))v778)(v779, v771);
    if (!__OFSUB__(0LL, v448))
    {
      v783 = -v448;
      v560 = *(void (**)(char *, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v547 + 240);
      v561 = lazy protocol witness table accessor for type Int and conformance Int(v557, v558, v559);
      v562 = v763;
      v560(v556, &v783, &type metadata for Int, v561, v473, v547);
      ((void (*)(char *, uint64_t))v381)(v556, v473);
      char v484 = v746;
      ((void (*)(char *, uint64_t, uint64_t, unint64_t *, void *))v541[11])( v562,  v473,  v547,  v746,  v541);
      uint64_t v555 = v748;
      goto LABEL_124;
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  return v56;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  (*(void (**)(uint64_t, unint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v16 + 32))(a6, v15, a2);
}

              uint64_t v31 = 16388LL;
              return (Swift::String::Index)(v31 | (v19 << 16));
            }

            uint64_t v28 = 4LL;
          }

          else if (++v26 >= v16)
          {
            goto LABEL_60;
          }
        }

        else
        {
          if (++v26 >= v16)
          {
            if (v16 >= v26)
            {
              uint64_t v28 = 1LL;
              goto LABEL_61;
            }

            goto LABEL_66;
          }

          uint64_t v28 = 1LL;
        }

        v19 += v28;
        if (v19 >= v25) {
          goto LABEL_63;
        }
      }
    }

    goto LABEL_63;
  }

  if ((v5 & 0x1000000000000000LL) != 0)
  {
    uint64_t v17 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v18 = v5 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v33 = v5;
    uint64_t v34 = *(void *)(v15 + 8 * v14 + 32);
    uint64_t v17 = (char *)_StringObject.sharedUTF8.getter(v33, v4);
    v7._Swift::UInt64 rawBits = v34;
  }

  uint64_t v19 = v7._rawBits >> 16;
  if ((uint64_t)(v7._rawBits >> 16) >= v18)
  {
LABEL_63:
    uint64_t v32 = 928LL;
    goto LABEL_65;
  }

  if ((v7._rawBits & 0xC000) != 0) {
    uint64_t v20 = -1LL;
  }
  else {
    uint64_t v20 = 0LL;
  }
  while (1)
  {
    uint64_t v21 = v17[v19];
    if (v21 < 0) {
      break;
    }
    if (++v20 >= v16)
    {
      if (v16 < v20) {
        goto LABEL_66;
      }
      uint64_t v22 = 1LL;
      return (Swift::String::Index)(((v22 + v19) << 16) | 5);
    }

    uint64_t v22 = 1LL;
LABEL_33:
    v19 += v22;
    if (v19 >= v18) {
      goto LABEL_63;
    }
  }

  uint64_t v23 = __clz(~(_BYTE)v21);
  uint64_t v24 = v23 - 24;
  uint64_t v22 = (v23 - 24);
  if (v24 != 4)
  {
    if (++v20 >= v16) {
      goto LABEL_58;
    }
    goto LABEL_33;
  }

  v20 += 2LL;
  if (v20 < v16)
  {
    uint64_t v22 = 4LL;
    goto LABEL_33;
  }

    if (((1LL << v19) & 0x20048) == 0) {
LABEL_67:
    }
      uint64_t v14 = v20;
LABEL_8:
    v11 += v18;
  }

  while (v11 < a5);
LABEL_258:
  if ((v15 & 1) != 0) {
    return v11;
  }
  return v13;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  return *(void *)&v59;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  return *(void *)&v59;
}

  uint64_t v6 = 1LL;
LABEL_68:
  if (v56 != v58) {
    free(v56);
  }
  return v6;
}

      *((void *)v7 + 1) = Type + 24;
      uint64_t v17 = 232;
LABEL_67:
      *(_WORD *)(Type + 16) = v17;
      *(_BYTE *)(Type + 18) = 0;
      uint64_t v61 = (unsigned int *)Type;
      uint64_t v62 = (swift::Demangle::__runtime::Node *)v12;
      goto LABEL_68;
    case 'S':
      return swift::Demangle::__runtime::Demangler::popSILPack(this, a2, a3, a4, a5);
    case 'X':
      uint64_t v30 = (swift::Demangle::__runtime::Node **)swift::Demangle::__runtime::Demangler::demangleAssociatedTypeCompound( this,  0LL,  a3,  a4,  a5);
      goto LABEL_74;
    case 'Y':
      DependentGenericParamType = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleGenericParamIndex( this,  a2,  a3,  a4,  a5);
      goto LABEL_31;
    case 'Z':
      DependentGenericParamType = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::getDependentGenericParamType( this,  0,  0,  a4,  a5);
LABEL_31:
      uint64_t v30 = (swift::Demangle::__runtime::Node **)swift::Demangle::__runtime::Demangler::demangleAssociatedTypeCompound( v7,  DependentGenericParamType,  v32,  v33,  v34);
      goto LABEL_74;
    case 'a':
      uint64_t v35 = *((_DWORD *)this + 24);
      if (!v35) {
        return 0LL;
      }
      uint64_t v36 = v35 - 1;
      uint64_t v37 = *((void *)this + 11);
      uint64_t v38 = *(swift::Demangle::__runtime::Node **)(v37 + 8LL * (v35 - 1));
      if (*((_WORD *)v38 + 8) == 101)
      {
        *((_DWORD *)this + 24) = v36;
        if (v35 == 1) {
          return 0LL;
        }
      }

      else
      {
        uint64_t v38 = 0LL;
        uint64_t v36 = *((_DWORD *)this + 24);
      }

      uint64_t v83 = v36 - 1;
      uint64_t v84 = *(swift::Demangle::__runtime::Node **)(v37 + 8LL * v83);
      if (*((_WORD *)v84 + 8) != 232) {
        return 0LL;
      }
      *((_DWORD *)this + 24) = v83;
      uint64_t v85 = *((unsigned __int8 *)v84 + 18);
      if (v85 == 1) {
        goto LABEL_99;
      }
      if (v85 != 5 || *((_DWORD *)v84 + 2) != 1) {
        return 0LL;
      }
      uint64_t v84 = *(swift::Demangle::__runtime::Node **)v84;
LABEL_99:
      if (!v38) {
        return 0LL;
      }
      uint64_t v86 = *(swift::Demangle::__runtime::Node **)v84;
      if (!*(void *)v84) {
        return 0LL;
      }
      uint64_t v87 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v87 || v87 + 24 > *((void *)this + 2))
      {
        uint64_t v88 = 2LL * *((void *)this + 4);
        if (v88 <= 0x20) {
          uint64_t v88 = 32LL;
        }
        *((void *)this + 4) = v88;
        uint64_t v89 = v88 + 8;
        uint64_t v90 = malloc(v88 + 8);
        uint64_t v91 = (char *)v90 + v89;
        *uint64_t v90 = *((void *)v7 + 3);
        uint64_t v87 = ((unint64_t)v90 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v91;
        *((void *)v7 + 3) = v90;
      }

      *((void *)v7 + 1) = v87 + 24;
      *(_WORD *)(v87 + 16) = 5;
      *(_BYTE *)(v87 + 18) = 0;
      swift::Demangle::__runtime::Node::addChild((unsigned int *)v87, v86, v7, a4, a5);
      swift::Demangle::__runtime::Node::addChild((unsigned int *)v87, v38, v7, v92, v93);
      Type = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!Type || Type + 24 > *((void *)v7 + 2))
      {
        uint64_t v96 = 2LL * *((void *)v7 + 4);
        if (v96 <= 0x20) {
          uint64_t v96 = 32LL;
        }
        *((void *)v7 + 4) = v96;
        uint64_t v97 = v96 + 8;
        uint64_t v98 = malloc(v96 + 8);
        uint64_t v99 = (char *)v98 + v97;
        uint64_t *v98 = *((void *)v7 + 3);
        Type = ((unint64_t)v98 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v99;
        *((void *)v7 + 3) = v98;
      }

      *((void *)v7 + 1) = Type + 24;
      *(_WORD *)(Type + 16) = 232;
      *(_BYTE *)(Type + 18) = 0;
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)Type,  (swift::Demangle::__runtime::Node *)v87,  v7,  v94,  v95);
      uint64_t v134 = (swift::Demangle::__runtime::Node **)Type;
LABEL_75:
      uint64_t v65 = (const void **)((char *)v7 + 104);
      unint64_t v66 = (uint64_t *)&v134;
      goto LABEL_76;
    case 'e':
      uint64_t v39 = *((_DWORD *)this + 24);
      if (!v39) {
        goto LABEL_77;
      }
      uint64_t v40 = v39 - 1;
      uint64_t v41 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * (v39 - 1));
      if (*((_WORD *)v41 + 8) != 232) {
        goto LABEL_77;
      }
      *((_DWORD *)this + 24) = v40;
      uint64_t v42 = *((unsigned __int8 *)v41 + 18);
      if (v42 == 1) {
        goto LABEL_42;
      }
      if (v42 == 5 && *((_DWORD *)v41 + 2) == 1)
      {
        uint64_t v41 = *(swift::Demangle::__runtime::Node **)v41;
LABEL_42:
        uint64_t v43 = *(swift::Demangle::__runtime::Node **)v41;
      }

      else
      {
LABEL_77:
        uint64_t v43 = 0LL;
      }

      if (v9 >= v5) {
        return 0LL;
      }
      uint64_t v67 = *(unsigned __int8 *)(v10 + v9);
      if (v67 == 95)
      {
        uint64_t v68 = 0LL;
        *((void *)this + 9) = v6 + 2;
      }

      else
      {
        uint64_t v119 = 0;
        while (1)
        {
          uint64_t v120 = *(unsigned __int8 *)(v10 + v9);
          uint64_t v121 = v120 + 10 * v119 - 48;
          if (v121 < v119) {
            return 0LL;
          }
          Type = 0LL;
          *((void *)this + 9) = ++v9;
          uint64_t v119 = v121;
          if (v5 == v9) {
            return Type;
          }
        }

        Type = 0LL;
        if (v119 < 0 || v9 >= v5 || v120 != 95) {
          return Type;
        }
        *((void *)this + 9) = v9 + 1;
        uint64_t v68 = (v119 + 1);
      }

      char v69 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v69 || v69 + 24 > *((void *)this + 2))
      {
        uint64_t v70 = 2LL * *((void *)this + 4);
        if (v70 <= 0x20) {
          uint64_t v70 = 32LL;
        }
        *((void *)this + 4) = v70;
        uint64_t v71 = v70 + 8;
        char v72 = malloc(v70 + 8);
        uint64_t v73 = (char *)v72 + v71;
        *char v72 = *((void *)v7 + 3);
        char v69 = ((unint64_t)v72 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = v73;
        *((void *)v7 + 3) = v72;
      }

      *((void *)v7 + 1) = v69 + 24;
      *(_WORD *)(v69 + 16) = 231;
      *(_BYTE *)(v69 + 18) = 4;
      *(void *)char v69 = v68;
      if (v43)
      {
        uint64_t v74 = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v74 || v74 + 24 > *((void *)v7 + 2))
        {
          uint64_t v75 = 2LL * *((void *)v7 + 4);
          if (v75 <= 0x20) {
            uint64_t v75 = 32LL;
          }
          *((void *)v7 + 4) = v75;
          uint64_t v76 = v75 + 8;
          uint64_t v77 = malloc(v75 + 8);
          uint64_t v78 = (char *)v77 + v76;
          char *v77 = *((void *)v7 + 3);
          uint64_t v74 = ((unint64_t)v77 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)v7 + 2) = v78;
          *((void *)v7 + 3) = v77;
        }

        *((void *)v7 + 1) = v74 + 24;
        *(_WORD *)(v74 + 16) = 230;
        *(_BYTE *)(v74 + 18) = 0;
        swift::Demangle::__runtime::Node::addChild((unsigned int *)v74, v43, v7, a4, a5);
        uint64_t v81 = (unsigned int *)v74;
        uint64_t v82 = (swift::Demangle::__runtime::Node *)v69;
        goto LABEL_156;
      }

      return 0LL;
    case 'o':
      if (v9 >= v5) {
        goto LABEL_124;
      }
      uint64_t v44 = *(unsigned __int8 *)(v10 + v9);
      if (v44 == 95)
      {
        uint64_t v45 = 0LL;
        *((void *)this + 9) = v6 + 2;
        goto LABEL_125;
      }

      uint64_t v103 = 0;
      break;
    case 'p':
      uint64_t v46 = *((_DWORD *)this + 24);
      if (!v46) {
        return 0LL;
      }
      uint64_t v47 = v46 - 1;
      uint64_t v48 = *((void *)this + 11);
      uint64_t v49 = *(swift::Demangle::__runtime::Node **)(v48 + 8LL * (v46 - 1));
      if (*((_WORD *)v49 + 8) != 232)
      {
        uint64_t v51 = 0LL;
        uint64_t v47 = *((_DWORD *)this + 24);
        goto LABEL_143;
      }

      *((_DWORD *)this + 24) = v47;
      uint64_t v50 = *((unsigned __int8 *)v49 + 18);
      if (v50 == 1) {
        goto LABEL_52;
      }
      if (v50 == 5 && *((_DWORD *)v49 + 2) == 1)
      {
        uint64_t v49 = *(swift::Demangle::__runtime::Node **)v49;
LABEL_52:
        uint64_t v51 = *(swift::Demangle::__runtime::Node **)v49;
      }

      else
      {
        uint64_t v51 = 0LL;
      }

      if (!v47) {
        return 0LL;
      }
LABEL_143:
      uint64_t v122 = v47 - 1;
      unint64_t v123 = *(swift::Demangle::__runtime::Node **)(v48 + 8LL * v122);
      if (*((_WORD *)v123 + 8) != 232) {
        return 0LL;
      }
      *((_DWORD *)this + 24) = v122;
      uint64_t v124 = *((unsigned __int8 *)v123 + 18);
      if (v124 == 1) {
        goto LABEL_148;
      }
      if (v124 != 5 || *((_DWORD *)v123 + 2) != 1) {
        return 0LL;
      }
      unint64_t v123 = *(swift::Demangle::__runtime::Node **)v123;
LABEL_148:
      Type = 0LL;
      if (v51)
      {
        uint64_t v125 = *(swift::Demangle::__runtime::Node **)v123;
        if (*(void *)v123)
        {
          uint64_t v74 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
          if (!v74 || v74 + 24 > *((void *)this + 2))
          {
            char v126 = 2LL * *((void *)this + 4);
            if (v126 <= 0x20) {
              char v126 = 32LL;
            }
            *((void *)this + 4) = v126;
            uint64_t v127 = v126 + 8;
            uint64_t v128 = malloc(v126 + 8);
            char *v128 = *((void *)v7 + 3);
            uint64_t v74 = ((unint64_t)v128 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *((void *)v7 + 2) = (char *)v128 + v127;
            *((void *)v7 + 3) = v128;
          }

          *((void *)v7 + 1) = v74 + 24;
          *(_WORD *)(v74 + 16) = 229;
          *(_BYTE *)(v74 + 18) = 0;
          swift::Demangle::__runtime::Node::addChild((unsigned int *)v74, v125, v7, a4, a5);
          uint64_t v81 = (unsigned int *)v74;
          uint64_t v82 = v51;
LABEL_156:
          swift::Demangle::__runtime::Node::addChild(v81, v82, v7, v79, v80);
          Type = (*((void *)v7 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
          if (!Type || Type + 24 > *((void *)v7 + 2))
          {
            char v129 = 2LL * *((void *)v7 + 4);
            if (v129 <= 0x20) {
              char v129 = 32LL;
            }
            *((void *)v7 + 4) = v129;
            uint64_t v130 = v129 + 8;
            uint64_t v131 = malloc(v129 + 8);
            uint64_t v132 = (char *)v131 + v130;
            char *v131 = *((void *)v7 + 3);
            Type = ((unint64_t)v131 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *((void *)v7 + 2) = v132;
            *((void *)v7 + 3) = v131;
          }

          *((void *)v7 + 1) = Type + 24;
          *(_WORD *)(Type + 16) = 232;
          *(_BYTE *)(Type + 18) = 0;
          uint64_t v61 = (unsigned int *)Type;
          uint64_t v62 = (swift::Demangle::__runtime::Node *)v74;
LABEL_68:
          swift::Demangle::__runtime::Node::addChild(v61, v62, v7, a4, a5);
        }
      }

      return Type;
    case 'r':
      uint64_t v12 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v12 || (uint64_t v52 = *((void *)this + 2), v12 + 24 > v52))
      {
        uint64_t v53 = 2LL * *((void *)this + 4);
        if (v53 <= 0x20) {
          uint64_t v53 = 32LL;
        }
        *((void *)this + 4) = v53;
        uint64_t v54 = v53 + 8;
        uint64_t v55 = malloc(v53 + 8);
        uint64_t v52 = (unint64_t)v55 + v54;
        char *v55 = *((void *)v7 + 3);
        uint64_t v12 = ((unint64_t)v55 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)v7 + 2) = (char *)v55 + v54;
        *((void *)v7 + 3) = v55;
      }

      *(_WORD *)(v12 + 16) = 308;
      *(_BYTE *)(v12 + 18) = 0;
      Type = (v12 + 31) & 0xFFFFFFFFFFFFFFF8LL;
      if (Type) {
        uint64_t v56 = Type + 24 > v52;
      }
      else {
        uint64_t v56 = 1;
      }
      if (!v56) {
        goto LABEL_66;
      }
      goto LABEL_63;
    case 'x':
      uint64_t v63 = 0LL;
      goto LABEL_73;
    case 'y':
      uint64_t v64 = swift::Demangle::__runtime::Demangler::demangleGenericParamIndex(this, a2, a3, a4, a5);
      goto LABEL_72;
    case 'z':
      uint64_t v64 = swift::Demangle::__runtime::Demangler::getDependentGenericParamType(this, 0, 0, a4, a5);
LABEL_72:
      uint64_t v63 = (swift::Demangle::__runtime::Node *)v64;
      this = v7;
LABEL_73:
      uint64_t v30 = (swift::Demangle::__runtime::Node **)swift::Demangle::__runtime::Demangler::demangleAssociatedTypeSimple( this,  v63,  a3,  a4,  a5);
LABEL_74:
      Type = (unint64_t)v30;
      uint64_t v134 = v30;
      if (v30) {
        goto LABEL_75;
      }
      return Type;
    default:
      return Type;
  }

  while (1)
  {
    uint64_t v104 = *(unsigned __int8 *)(v10 + v9);
    uint64_t v105 = v104 + 10 * v103 - 48;
    if (v105 >= v103)
    {
      *((void *)this + 9) = ++v9;
      uint64_t v103 = v105;
      if (v5 != v9) {
        continue;
      }
    }

uint64_t static BinaryFloatingPoint._convert<A>(from:)( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v780 = a2;
  v754 = a1;
  uint64_t v10 = *(void *)(a4 - 8);
  uint64_t v779 = a4;
  uint64_t v759 = v10;
  uint64_t v11 = MEMORY[0x1895F8858]((char *)a1);
  v761 = (char *)&v677 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  v750 = (char *)&v677 - v13;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v15,  v14,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v753 = *(void *)(swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)
                   + 8);
  uint64_t v707 = *(void *)(v753 + 24);
  v760 = *(const char **)(v707 + 16);
  unint64_t v738 = swift_getAssociatedTypeWitness( 0LL,  v760,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v738);
  v737 = (char *)&v677 - v17;
  unint64_t v18 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  unint64_t v781 = v18;
  v735 = *(void **)(swift_getAssociatedConformanceWitness( a5,  a3,  v18,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)
                    + 8);
  v715 = *(const char **)(v735[3] + 16LL);
  unint64_t v714 = swift_getAssociatedTypeWitness( 0LL,  v715,  v18,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v714);
  v709 = (char *)&v677 - v19;
  v743 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v734 = *(v743 - 1);
  uint64_t v20 = MEMORY[0x1895F8858](v743);
  v706 = (char *)&v677 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v684 = (char *)&v677 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v769 = (char *)&v677 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v731 = (char *)&v677 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v739 = (char *)&v677 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v725 = (char *)&v677 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v721 = (char *)&v677 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v736 = (char *)&v677 - v35;
  MEMORY[0x1895F8858](v34);
  v763 = (char *)&v677 - v36;
  uint64_t v37 = (char **)swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  v778 = v37;
  v719 = *(void (**)(unint64_t, char *, unint64_t *, unint64_t))(swift_getAssociatedConformanceWitness( a5,  a3,  (uint64_t)v37,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)
                                                                                               + 8);
  unint64_t v720 = *((void *)v719 + 3);
  v713 = *(const char **)(v720 + 16);
  unint64_t v712 = swift_getAssociatedTypeWitness( 0LL,  v713,  (uint64_t)v37,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v712);
  v711 = (char *)&v677 - v38;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  uint64_t v40 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  v677 = (char *)&v677 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v40);
  v678 = (char *)&v677 - v42;
  uint64_t v43 = *(void *)(a5 + 16);
  uint64_t v702 = *(void *)(v43 + 16);
  v729 = *(const char **)(*(void *)(v702 + 8) + 16LL);
  unint64_t v727 = swift_getAssociatedTypeWitness( 0LL,  v729,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v727);
  v728 = (char *)&v677 - v44;
  uint64_t v745 = a5;
  v705 = *(const char **)(a5 + 8);
  unint64_t v703 = swift_getAssociatedTypeWitness( 0LL,  v705,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  MEMORY[0x1895F8858](v703);
  v704 = (char *)&v677 - v45;
  unint64_t v46 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v43,  a3,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  uint64_t v775 = v43;
  v774 = *(char ***)(swift_getAssociatedConformanceWitness( v43,  a3,  v46,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  v710 = v774[3];
  v724 = (char *)*((void *)v710 + 2);
  unint64_t v722 = swift_getAssociatedTypeWitness( 0LL,  v724,  v46,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v722);
  v723 = (char *)&v677 - v47;
  uint64_t v771 = a6;
  uint64_t v48 = *(void *)(a6 + 16);
  uint64_t v49 = v779;
  unint64_t v50 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v48,  v779,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v48,  v49,  v50,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger);
  uint64_t v773 = *(void *)(AssociatedConformanceWitness + 8);
  v733 = *(unint64_t **)(v773 + 24);
  v757 = (char *)v733[2];
  unint64_t v755 = swift_getAssociatedTypeWitness( 0LL,  v757,  v50,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v755);
  v756 = (char *)&v677 - v51;
  uint64_t v52 = swift_checkMetadataState(0LL, v46);
  uint64_t v772 = *(v52 - 1);
  uint64_t v53 = MEMORY[0x1895F8858](v52);
  v696 = (char *)&v677 - ((v54 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  v693 = (char *)&v677 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  uint64_t v758 = (uint64_t)&v677 - v58;
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  uint64_t v61 = (char *)&v677 - v60;
  uint64_t v62 = MEMORY[0x1895F8858](v59);
  v687 = (char *)&v677 - v63;
  uint64_t v64 = MEMORY[0x1895F8858](v62);
  v688 = (char *)&v677 - v65;
  uint64_t v66 = MEMORY[0x1895F8858](v64);
  v694 = (char *)&v677 - v67;
  uint64_t v68 = MEMORY[0x1895F8858](v66);
  v695 = (char *)&v677 - v69;
  uint64_t v70 = MEMORY[0x1895F8858](v68);
  v768 = (char *)&v677 - v71;
  uint64_t v72 = MEMORY[0x1895F8858](v70);
  v700 = (char *)&v677 - v73;
  uint64_t v74 = MEMORY[0x1895F8858](v72);
  v701 = (char *)&v677 - v75;
  uint64_t v76 = MEMORY[0x1895F8858](v74);
  v770 = (char *)&v677 - v77;
  MEMORY[0x1895F8858](v76);
  v766 = (char *)&v677 - v78;
  v746 = swift_checkMetadataState(0LL, v781);
  uint64_t v748 = *(v746 - 1);
  uint64_t v79 = MEMORY[0x1895F8858](v746);
  uint64_t v81 = (char *)&v677 - ((v80 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v82 = MEMORY[0x1895F8858](v79);
  v680 = (char *)&v677 - v83;
  uint64_t v84 = MEMORY[0x1895F8858](v82);
  v679 = (char *)&v677 - v85;
  uint64_t v86 = MEMORY[0x1895F8858](v84);
  v681 = (char *)&v677 - v87;
  uint64_t v88 = MEMORY[0x1895F8858](v86);
  v765 = (char *)&v677 - v89;
  uint64_t v90 = MEMORY[0x1895F8858](v88);
  v682 = (char *)&v677 - v91;
  uint64_t v92 = MEMORY[0x1895F8858](v90);
  v716 = (char *)&v677 - v93;
  uint64_t v94 = MEMORY[0x1895F8858](v92);
  v708 = (char **)((char *)&v677 - v95);
  uint64_t v96 = MEMORY[0x1895F8858](v94);
  v749 = (char *)&v677 - v97;
  uint64_t v98 = MEMORY[0x1895F8858](v96);
  v732 = (char *)&v677 - v99;
  MEMORY[0x1895F8858](v98);
  v740 = (char *)&v677 - v100;
  v752 = swift_checkMetadataState(0LL, (uint64_t)v778);
  uint64_t v741 = *(v752 - 1);
  uint64_t v101 = MEMORY[0x1895F8858](v752);
  v718 = (char *)&v677 - ((v102 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v103 = MEMORY[0x1895F8858](v101);
  v744 = (char *)&v677 - v104;
  uint64_t v105 = MEMORY[0x1895F8858](v103);
  v717 = (char *)&v677 - v106;
  uint64_t v107 = MEMORY[0x1895F8858](v105);
  v751 = (char *)&v677 - v108;
  v782 = (char **)a3;
  uint64_t v109 = *(void *)(a3 - 8);
  uint64_t v110 = v49;
  uint64_t v767 = v109;
  uint64_t v111 = MEMORY[0x1895F8858](v107);
  v683 = (char *)&v677 - ((v112 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v113 = MEMORY[0x1895F8858](v111);
  uint64_t v115 = (char *)&v677 - v114;
  uint64_t v116 = MEMORY[0x1895F8858](v113);
  v762 = (char *)&v677 - v117;
  uint64_t v118 = MEMORY[0x1895F8858](v116);
  v698 = (char *)&v677 - v119;
  uint64_t v120 = MEMORY[0x1895F8858](v118);
  v747 = (char *)&v677 - v121;
  uint64_t v122 = MEMORY[0x1895F8858](v120);
  v730 = (char *)&v677 - v123;
  MEMORY[0x1895F8858](v122);
  v778 = (char **)((char *)&v677 - v124);
  uint64_t v125 = swift_checkMetadataState(0LL, v50);
  uint64_t v777 = *(v125 - 1);
  uint64_t v126 = MEMORY[0x1895F8858](v125);
  v685 = (char *)&v677 - ((v127 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v128 = MEMORY[0x1895F8858](v126);
  v689 = (char *)&v677 - v129;
  uint64_t v130 = MEMORY[0x1895F8858](v128);
  v691 = (char *)&v677 - v131;
  uint64_t v132 = MEMORY[0x1895F8858](v130);
  v686 = (char *)&v677 - v133;
  uint64_t v134 = MEMORY[0x1895F8858](v132);
  unint64_t v136 = (char *)&v677 - v135;
  uint64_t v137 = MEMORY[0x1895F8858](v134);
  v726 = (char *)&v677 - v138;
  uint64_t v139 = MEMORY[0x1895F8858](v137);
  v692 = (char *)&v677 - v140;
  uint64_t v141 = MEMORY[0x1895F8858](v139);
  v690 = (char *)&v677 - v142;
  uint64_t v143 = MEMORY[0x1895F8858](v141);
  v742 = (char *)&v677 - v144;
  uint64_t v145 = MEMORY[0x1895F8858](v143);
  v699 = (char *)&v677 - v146;
  uint64_t v147 = MEMORY[0x1895F8858](v145);
  unsigned __int8 v149 = (char *)&v677 - v148;
  uint64_t v150 = MEMORY[0x1895F8858](v147);
  v776 = (char *)&v677 - v151;
  MEMORY[0x1895F8858](v150);
  unint64_t v781 = (unint64_t)&v677 - v152;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v48 + 384))(v110, v48) & 1) != 0)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v48 + 168))(v110, v48) & 1) != 0)
    {
      v602 = v705;
      uint64_t v603 = (uint64_t)v782;
      unint64_t v608 = v703;
      unint64_t v609 = swift_getAssociatedConformanceWitness( (uint64_t)v705,  (uint64_t)v782,  v703,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
      v606 = v704;
      (*(void (**)(unint64_t, unint64_t, double))(v609 + 8))(v608, v609, -0.0);
    }

    else
    {
      v602 = v729;
      uint64_t v603 = (uint64_t)v782;
      unint64_t v604 = v727;
      unint64_t v605 = swift_getAssociatedConformanceWitness( (uint64_t)v729,  (uint64_t)v782,  v727,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v606 = v728;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v605 + 8))( &unk_18180BE68,  256LL,  v604,  v605);
    }

    (*((void (**)(char *, uint64_t, const char *))v602 + 3))(v606, v603, v602);
    return 1LL;
  }

  char v153 = (*(uint64_t (**)(uint64_t, uint64_t))(v48 + 376))(v110, v48);
  uint64_t v764 = v48;
  if ((v153 & 1) == 0)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v48 + 400))(v110, v48) & 1) == 0)
    {
      uint64_t v610 = v771;
      v611 = *(void (**)(uint64_t, uint64_t))(v771 + 120);
      unint64_t v781 = (unint64_t)v81;
      v611(v110, v771);
      unint64_t v612 = v750;
      (*(void (**)(uint64_t, uint64_t))(v48 + 96))(v110, v48);
      v613 = v684;
      v611(v110, v610);
      uint64_t v614 = v110;
      v615 = *(void (**)(char *, uint64_t))(v759 + 8);
      v615(v612, v614);
      v616 = v761;
      (*(void (**)(uint64_t, uint64_t))(v48 + 104))(v614, v48);
      uint64_t v617 = v706;
      v611(v614, v610);
      v615(v616, v614);
      uint64_t v618 = v753;
      v619 = v725;
      unint64_t v620 = v743;
      (*(void (**)(char *, char *, unint64_t *, uint64_t))(v753 + 208))(v613, v617, v743, v753);
      uint64_t v621 = *(void (**)(char *, unint64_t *))(v734 + 8);
      v621(v617, v620);
      v621(v613, v620);
      uint64_t v622 = v736;
      (*(void (**)(char *, unint64_t *, uint64_t))(v618 + 184))(v619, v620, v618);
      v621(v619, v620);
      uint64_t v623 = v618;
      uint64_t v624 = *(void (**)(char *, char *, unint64_t *, uint64_t))(v618 + 192);
      v625 = v763;
      v624(v763, v622, v620, v623);
      v621(v622, v620);
      v621(v625, v620);
      uint64_t v626 = v775;
      v627 = v730;
      uint64_t v628 = (uint64_t)v782;
      (*(void (**)(char **, uint64_t))(v775 + 120))(v782, v775);
      uint64_t v629 = v745;
      v778 = *(char ***)(v745 + 120);
      ((void (*)(uint64_t, uint64_t))v778)(v628, v745);
      uint64_t v630 = *(void (**)(char *, uint64_t))(v767 + 8);
      v630(v627, v628);
      uint64_t v631 = v630;
      v776 = *(char **)(v626 + 96);
      v632 = v762;
      ((void (*)(uint64_t, uint64_t))v776)(v628, v626);
      v633 = v679;
      v634 = v778;
      ((void (*)(uint64_t, uint64_t))v778)(v628, v629);
      v631(v632, v628);
      uint64_t v773 = *(void *)(v626 + 104);
      v774 = (char **)v631;
      ((void (*)(uint64_t, uint64_t))v773)(v628, v626);
      v635 = v680;
      ((void (*)(uint64_t, uint64_t))v634)(v628, v745);
      v631(v115, v628);
      uint64_t v636 = v735;
      uint64_t v777 = v735[26];
      v637 = v681;
      v638 = v746;
      ((void (*)(char *, char *, unint64_t *, void *))v777)(v633, v635, v746, v735);
      v639 = *(void (**)(char *, unint64_t *))(v748 + 8);
      v639(v635, v638);
      v639(v633, v638);
      v640 = v765;
      ((void (*)(char *, unint64_t *, void *))v636[23])(v637, v638, v636);
      v639(v637, v638);
      unint64_t v641 = (void (*)(char *, char *, unint64_t *, void *))v636[24];
      unint64_t v642 = v682;
      v643 = v749;
      v641(v749, v640, v638, v636);
      v639(v640, v638);
      v639(v643, v638);
      ((void (*)(char *, unint64_t *, uint64_t, unint64_t *, void *))v636[12])( v769,  v620,  v753,  v638,  v636);
      v641(v643, v642, v638, v636);
      v639(v643, v638);
      v639(v642, v638);
      uint64_t v644 = v764;
      uint64_t v645 = v779;
      LOBYTE(v641) = (*(uint64_t (**)(uint64_t, uint64_t))(v764 + 416))(v779, v764);
      LODWORD(v78specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 1LL, 0) = (*(uint64_t (**)(uint64_t, uint64_t))(v644 + 168))(v645, v644) & 1;
      uint64_t v646 = v775;
      else {
        v647 = v776;
      }
      v648 = v730;
      ((void (*)(uint64_t, uint64_t))v647)(v628, v775);
      uint64_t v649 = v745;
      (*(void (**)(uint64_t, uint64_t))(v745 + 112))(v628, v745);
      uint64_t v650 = v648;
      unint64_t v651 = v774;
      ((void (*)(char *, uint64_t))v774)(v650, v628);
      uint64_t v652 = v762;
      ((void (*)(uint64_t, uint64_t))v647)(v628, v646);
      int64_t v653 = v765;
      ((void (*)(uint64_t, uint64_t))v778)(v628, v649);
      ((void (*)(char *, uint64_t))v651)(v652, v628);
      uint64_t v654 = v749;
      uint64_t v655 = v781;
      ((void (*)(unint64_t, char *, unint64_t *, void *))v777)(v781, v653, v638, v636);
      v639(v653, v638);
      v639((char *)v655, v638);
      v656 = v683;
      (*(void (**)(void, char *, char *, uint64_t, uint64_t))(v649 + 56))( v780,  v744,  v654,  v628,  v649);
      (*(void (**)(char *, char *, uint64_t))(v767 + 32))((char *)v754, v656, v628);
      return 0LL;
    }

    char v607 = (*(uint64_t (**)(uint64_t, uint64_t))(v48 + 168))(v110, v48);
    __int16 v582 = *(void (**)(char **))(v775 + 112);
    uint64_t v578 = (uint64_t)v782;
    if ((v607 & 1) != 0) {
      goto LABEL_149;
    }
    v582(v782);
    return 1LL;
  }

  v684 = v136;
  v706 = v61;
  uint64_t v154 = v781;
  (*(void (**)(uint64_t, uint64_t))(v48 + 176))(v110, v48);
  uint64_t v155 = v775;
  uint64_t v156 = v778;
  uint64_t v157 = (uint64_t)v782;
  (*(void (**)(char **, uint64_t))(v775 + 152))(v782, v775);
  uint64_t v158 = v766;
  v750 = *(char **)(v155 + 176);
  ((void (*)(uint64_t, uint64_t))v750)(v157, v155);
  uint64_t v759 = *(void *)(v767 + 8);
  ((void (*)(char **, uint64_t))v759)(v156, v157);
  uint64_t v159 = v773;
  char v160 = *(uint64_t (**)(unint64_t *, uint64_t))(v773 + 64);
  LODWORD(v155) = v160(v125, v773);
  uint64_t v161 = v774;
  v762 = v774[8];
  int v162 = ((uint64_t (*)(unint64_t *, char **))v762)(v52, v774);
  v769 = (char *)v160;
  if (((v155 ^ v162) & 1) != 0)
  {
    char v163 = v160(v125, v159);
    v765 = *(char **)(v159 + 128);
    uint64_t v164 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v159);
    v761 = v161[16];
    uint64_t v165 = ((uint64_t (*)(unint64_t *, char **))v761)(v52, v161);
    unint64_t v166 = v161;
    if ((v163 & 1) == 0)
    {
      BOOL v173 = v164 < v165;
      uint64_t v176 = v777;
      if (v173)
      {
        uint64_t v167 = (uint64_t)v52;
        uint64_t v169 = v776;
        uint64_t v170 = v781;
        (*(void (**)(char *, unint64_t, unint64_t *))(v777 + 16))(v776, v781, v125);
        uint64_t v177 = v770;
        uint64_t v168 = v773;
        ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v161[12])( v169,  v125,  v773,  v167,  v161);
        uint64_t v178 = v766;
        LODWORD(v701) = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v161[4] + 1) + 16LL))( v177,  v766,  v167);
        unint64_t v179 = *(void (**)(char *, uint64_t))(v772 + 8);
        v179(v177, v167);
        v179(v178, v167);
        uint64_t v180 = (uint64_t)v782;
        uint64_t v181 = v758;
      }

      else
      {
        unint64_t v193 = v724;
        unint64_t v194 = v722;
        unint64_t v195 = swift_getAssociatedConformanceWitness( (uint64_t)v724,  (uint64_t)v52,  v722,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v167 = (uint64_t)v52;
        uint64_t v196 = v176;
        uint64_t v197 = v723;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v195 + 8))( &unk_18180BE68,  256LL,  v194,  v195);
        uint64_t v198 = v770;
        (*((void (**)(char *, uint64_t, const char *))v193 + 3))(v197, v167, v193);
        uint64_t v199 = v766;
        char v200 = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v161[4] + 1) + 40LL))(v766, v198, v167);
        uint64_t v201 = v772;
        uint64_t v202 = *(void (**)(char *, uint64_t))(v772 + 8);
        v202(v198, v167);
        unint64_t v203 = v699;
        (*(void (**)(char *, unint64_t, unint64_t *))(v196 + 16))(v699, v781, v125);
        char v204 = *(void (**)(char *, char *, uint64_t))(v201 + 32);
        unint64_t v205 = v700;
        v204(v700, v199, v167);
        uint64_t v168 = v773;
        uint64_t v169 = v776;
        if ((v200 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v773 + 96))( v205,  v167,  v166,  v125,  v773);
          char v171 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v168 + 32) + 8LL)
                                                                               + 16LL))( v203,  v169,  v125);
          unint64_t v206 = *(void (**)(char *, unint64_t *))(v777 + 8);
          v206(v169, v125);
          v206(v203, v125);
          uint64_t v170 = v781;
          goto LABEL_19;
        }

        v202(v205, v167);
        (*(void (**)(char *, unint64_t *))(v777 + 8))(v203, v125);
        uint64_t v180 = (uint64_t)v782;
        uint64_t v181 = v758;
      }

LABEL_83:
      uint64_t v400 = v769;
      if ((((uint64_t (*)(unint64_t *, uint64_t))v769)(v125, v267) & 1) != 0)
      {
        uint64_t v401 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v267);
        unint64_t v404 = v776;
        if (v401 < 64) {
          goto LABEL_91;
        }
      }

      else
      {
        char v405 = ((uint64_t (*)(unint64_t *, uint64_t))v400)(v125, v267);
        uint64_t v401 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v267);
        unint64_t v404 = v776;
        if ((v405 & 1) == 0)
        {
          if (v401 < 64)
          {
LABEL_91:
            (*(void (**)(char *, uint64_t, unint64_t *))(v272 + 16))(v404, v282, v125);
            uint64_t v409 = (*(uint64_t (**)(unint64_t *, uint64_t))(v267 + 120))(v125, v267);
            uint64_t v408 = *(void (**)(char *, unint64_t *))(v272 + 8);
            unint64_t v410 = v404;
            goto LABEL_92;
          }

    uint64_t v47 = v20;
    uint64_t v51 = v18;
    uint64_t v37 = v19;
    uint64_t v22 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v23);
    uint64_t v20 = v47;
    unint64_t v18 = v51;
    uint64_t v19 = v37;
    goto LABEL_59;
  }

  if (v13 >= rawBits >> 14) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  a2._Swift::UInt64 rawBits = v7 >> 16;
  uint64_t v39 = 4LL;
  if (((v9 >> 60) & ((v8 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v39 = 8LL;
  }
  uint64_t v12 = v7 & 2 | v39;
  do
  {
    if (__OFSUB__(v6--, 1LL)) {
      goto LABEL_97;
    }
    if ((rawBits ^ v7) >= 0x4000)
    {
      uint64_t v40 = _StringGuts._opaqueCharacterStride(endingAt:in:)(rawBits >> 16, v7 >> 16, a3, v8, v9);
      rawBits -= v40 << 16;
      uint64_t v41 = v40 << 8;
      if (v40 > 63) {
        uint64_t v41 = 0LL;
      }
    }

    else
    {
      uint64_t v41 = 0LL;
    }

    uint64_t v42 = rawBits & 0xFFFFFFFFFFFF0000LL | v41;
    Swift::UInt64 rawBits = v12 | v42 | 1;
  }

  while (v13 < v42 >> 14);
  return v6;
}

  uint64_t v16 = 0LL;
  uint64_t v56 = 1;
LABEL_85:
  uint64_t v57 = v16;
  result.value._Swift::UInt64 rawBits = v57;
  result.is_nil = v56;
  return result;
}

            if ((v12 - 165) < 2)
            {
              uint64_t v42 = 0x10000LL;
            }

            else if (v12 == 22)
            {
              uint64_t v42 = 196608LL;
            }

            else if (v12 == 222)
            {
              uint64_t v42 = 0x20000LL;
            }

            else
            {
              uint64_t v42 = 0LL;
            }

            if (v24 == 5)
            {
              uint64_t v131 = *(const char **)v10;
              if (*((_DWORD *)v10 + 2)) {
                uint64_t v132 = *(void *)v131 + 16LL;
              }
              else {
                uint64_t v132 = 16LL;
              }
              uint64_t v133 = *(unsigned __int16 *)v132 == 23;
              if (*(_WORD *)(*(void *)&v131[8 * v133] + 16LL) == 67) {
                goto LABEL_352;
              }
            }

            else
            {
              uint64_t v131 = *(const char **)v10;
              uint64_t v133 = *(unsigned __int16 *)(*(void *)v10 + 16LL) == 23;
              if (*(_WORD *)(*((void *)v10 + v133) + 16LL) == 67)
              {
LABEL_352:
                uint64_t v137 = v10;
                if (v24 == 2
                  || v24 == 5
                  && (uint64_t v137 = (void (*)(uint64_t, int))v131, *((_DWORD *)v10 + 2) > v133))
                {
                  uint64_t v138 = (const char **)*((void *)v137 + v133);
                }

                else
                {
                  uint64_t v138 = 0LL;
                }

                uint64_t v144 = *((unsigned __int8 *)v138 + 18);
                if (v144 == 5)
                {
                  if (*((_DWORD *)v138 + 2))
                  {
                    uint64_t v138 = (const char **)*v138;
LABEL_369:
                    uint64_t v510 = a1;
                    uint64_t v145 = *((unsigned __int16 *)v6 + 8);
                    if (v6 && v145 == 1) {
                      return;
                    }
                    if (*((_WORD *)v6 + 8))
                    {
                      if (v133) {
                        uint64_t v141 = 2;
                      }
                      else {
                        uint64_t v141 = 1;
                      }
                      if (v145 == 1) {
                        ((void (*)(unint64_t, uint64_t, void))v6[1])(*v6, 3LL, 0LL);
                      }
                      uint64_t v139 = 0LL;
                      uint64_t v140 = 0;
                    }

                    else
                    {
                      uint64_t v140 = 0;
                      uint64_t v139 = *v6;
                      if (v133) {
                        uint64_t v141 = 2;
                      }
                      else {
                        uint64_t v141 = 1;
                      }
                    }

LABEL_161:
  (*(void (**)(char *, char *, char **))(v767 + 32))((char *)v754, v449, v388);
  return 0LL;
}

uint64_t static BinaryInteger.> infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v104 = a2;
  uint64_t v105 = a1;
  uint64_t v99 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v99,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v96 = (char *)&v87 - v10;
  uint64_t v95 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t v94 = swift_getAssociatedTypeWitness( 0LL,  v95,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v94);
  uint64_t v93 = (char *)&v87 - v12;
  uint64_t v103 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v98 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v87 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v101 = (char *)&v87 - v19;
  uint64_t v102 = *(void *)(a4 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v87 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v100 = (char *)&v87 - v26;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  int v28 = v27(a4, a6);
  if (((v28 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a5 + 64))(a3, a5)) & 1) != 0)
  {
    uint64_t v87 = v25;
    uint64_t v88 = v22;
    uint64_t v29 = v99;
    uint64_t v89 = v17;
    char v30 = v27(a4, a6);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    uint64_t v91 = a6;
    uint64_t v32 = v31(a4, a6);
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v92 = a3;
    uint64_t v90 = a5;
    uint64_t v34 = v33(a3, a5);
    uint64_t v35 = a4;
    if ((v30 & 1) != 0)
    {
      if (v34 >= v32)
      {
        unint64_t v54 = v94;
        uint64_t v55 = v95;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v95,  a4,  v94,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v57 = v93;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v54,  AssociatedConformanceWitness);
        uint64_t v58 = v100;
        (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a4, v55);
        uint64_t v59 = v91;
        uint64_t v60 = v104;
        LOBYTE(v54) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v91 + 32) + 8LL)
                                                                          + 16LL))( v104,  v58,  a4);
        uint64_t v61 = v102;
        uint64_t v62 = *(void (**)(char *, uint64_t))(v102 + 8);
        v62(v58, v35);
        uint64_t v63 = v87;
        (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v87, v60, v35);
        uint64_t v64 = v103;
        uint64_t v65 = v89;
        uint64_t v66 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v89, v105, v92);
        if ((v54 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t))(v64 + 8))(v65, v66);
          v62(v63, v35);
          char v40 = 1;
        }

        else
        {
          uint64_t v84 = v90;
          uint64_t v85 = v101;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v63, v35, v59, v66, v90);
          char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v84 + 32) + 8LL) + 16LL))( v85,  v65,  v66);
          uint64_t v86 = *(void (**)(char *, uint64_t))(v64 + 8);
          v86(v85, v66);
          v86(v65, v66);
        }
      }

      else
      {
        uint64_t v36 = v101;
        uint64_t v37 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v105, v92);
        uint64_t v38 = v91;
        uint64_t v39 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v36, v37, v90, a4, v91);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v38 + 32) + 8LL) + 16LL))( v104,  v39,  a4);
        (*(void (**)(char *, uint64_t))(v102 + 8))(v39, a4);
      }
    }

    else if (v32 >= v34)
    {
      uint64_t v67 = v92;
      unint64_t v68 = AssociatedTypeWitness;
      unint64_t v69 = swift_getAssociatedConformanceWitness( (uint64_t)v29,  v92,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v70 = v96;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v69 + 8))( &unk_18180BE68,  256LL,  v68,  v69);
      uint64_t v71 = v101;
      (*((void (**)(char *, uint64_t, const char *))v29 + 3))(v70, v67, v29);
      uint64_t v72 = v90;
      uint64_t v73 = v105;
      LOBYTE(v68) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8LL) + 40LL))( v105,  v71,  v67);
      uint64_t v74 = v103;
      uint64_t v75 = *(void (**)(char *, uint64_t))(v103 + 8);
      v75(v71, v67);
      uint64_t v76 = v102;
      uint64_t v77 = v88;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v88, v104, v35);
      uint64_t v78 = *(void (**)(char *, uint64_t, uint64_t))(v74 + 16);
      uint64_t v79 = v98;
      v78(v98, v73, v67);
      if ((v68 & 1) != 0)
      {
        uint64_t v80 = v72;
        uint64_t v81 = v91;
        uint64_t v82 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v79, v67, v80, v35, v91);
        char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v81 + 32) + 8LL) + 16LL))( v77,  v82,  v35);
        uint64_t v83 = *(void (**)(char *, uint64_t))(v76 + 8);
        v83(v82, v35);
        v83(v77, v35);
      }

      else
      {
        v75(v79, v67);
        (*(void (**)(char *, uint64_t))(v76 + 8))(v77, v35);
        char v40 = 0;
      }
    }

    else
    {
      unint64_t v46 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v104, a4);
      uint64_t v47 = v90;
      uint64_t v48 = v101;
      uint64_t v49 = v46;
      uint64_t v50 = v92;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v49, a4, v91, v92, v90);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v47 + 32) + 8LL) + 16LL))( v48,  v105,  v50);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v48, v50);
    }
  }

  else
  {
    uint64_t v41 = v104;
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
    uint64_t v43 = v105;
    if (v42 >= (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5))
    {
      uint64_t v51 = v101;
      (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v43, a3);
      uint64_t v52 = v100;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v51, a3, a5, a4, a6);
      char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v41,  v52,  a4);
      (*(void (**)(char *, uint64_t))(v102 + 8))(v52, a4);
    }

    else
    {
      uint64_t v44 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v41, a4);
      uint64_t v45 = v101;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v44, a4, a6, a3, a5);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v45,  v43,  a3);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v45, a3);
    }
  }

  return v40 & 1;
}