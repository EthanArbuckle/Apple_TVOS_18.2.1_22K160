unint64_t _sSRyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1)
{
  uint64_t *v1;
  return UnsafeBufferPointer.debugDescription.getter(*v1, v1[1], *(void *)(a1 + 16));
}

uint64_t UnsafeMutableRawBufferPointer._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

char *UnsafeMutableRawBufferPointer._copyContents(initializing:)( void *a1, int64_t a2, char *__src, unint64_t a4)
{
  v4 = __src;
  if (__src && a4 && (unint64_t)__src < a4 && a2)
  {
    else {
      size_t v5 = a4 - (void)__src;
    }
    if ((v5 & 0x8000000000000000LL) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
    }
    memmove(a1, __src, v5);
    v4 += v5;
  }

  return v4;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableRawBufferPointer()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)( *v0,  v0[1],  (void (*)(__objc2_class **, uint64_t, uint64_t, uint64_t))UnsafeMutableRawBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, void, void))UnsafeMutableRawBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeMutableRawBufferPointer@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeMutableRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeMutableRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a2)
  {
    uint64_t v9 = a3 - a2;
    if (a3 - a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
    uint64_t v10 = a2;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v9 = 0LL;
  }

  uint64_t result = a1(v10, v9);
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))(a5, 0LL, 1LL, a4);
  }
  return result;
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, 0xBBuLL, 0xBCuLL);
}

uint64_t key path getter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = UnsafeMutableRawBufferPointer.subscript.getter(*a2, *a1, a1[1]);
  *a3 = result;
  return result;
}

uint64_t key path setter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer( unsigned __int8 *a1, uint64_t *a2, uint64_t *a3)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, *a3, *a2, a2[1]);
}

uint64_t (*UnsafeMutableRawBufferPointer.subscript.modify( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t a1)
{
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)a1 = a2;
  *(_BYTE *)(a1 + 24) = UnsafeMutableRawBufferPointer.subscript.getter(a2, a3, a4);
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

uint64_t UnsafeMutableRawBufferPointer.subscript.modify(uint64_t a1)
{
  return UnsafeMutableRawBufferPointer.subscript.setter( *(unsigned __int8 *)(a1 + 24),  *(void *)a1,  *(void *)(a1 + 8),  *(void *)(a1 + 16));
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, a4, 0xCFuLL, 0xD0uLL);
}

uint64_t *key path getter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer@<X0>( uint64_t *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if ((*a2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xCFuLL,  0);
  }
  uint64_t v3 = *result;
  uint64_t v4 = result[1];
  uint64_t v5 = a2[1];
  if (!*result)
  {
    if (v5 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xD0uLL,  0);
  }

  if (v4 - v3 < v5) {
    goto LABEL_6;
  }
LABEL_4:
  *a3 = *a2;
  a3[1] = v5;
  a3[2] = v3;
  a3[3] = v4;
  return result;
}

void *key path setter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer( uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a3, a3[1], *a2, a2[1]);
}

void *UnsafeMutableRawBufferPointer.subscript.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xD5uLL,  0);
  }
  if (a7)
  {
    if (a8 - a7 >= a6) {
      goto LABEL_4;
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xD6uLL,  0);
  }

  if (a6 >= 1) {
    goto LABEL_12;
  }
LABEL_4:
  v14 = (void *)(a6 - a5);
  if (__OFSUB__(a6, a5))
  {
    __break(1u);
LABEL_15:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xD7uLL,  0);
  }

  uint64_t result = (void *)specialized RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, a4);
  if (v14 != result) {
    goto LABEL_15;
  }
  if (a1 == a2) {
    return result;
  }
  if (!a7)
  {
    unint64_t v17 = 218LL;
    goto LABEL_19;
  }

  if (!a3)
  {
    unint64_t v17 = 219LL;
LABEL_19:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  v17,  0);
  }

  size_t v16 = specialized RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, a4);
  if ((v16 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
  }
  return memmove((void *)(a7 + a5), (const void *)(a3 + a1), v16);
}

void (*UnsafeMutableRawBufferPointer.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t **a1)
{
  uint64_t v10 = malloc(0x40uLL);
  *a1 = v10;
  v10[6] = a4;
  v10[7] = a5;
  v10[4] = a2;
  v10[5] = a3;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xCFuLL,  0);
  }
  if (!a4)
  {
    if (a3 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xD0uLL,  0);
  }

  if (a5 - a4 < a3) {
    goto LABEL_6;
  }
LABEL_4:
  *uint64_t v10 = a2;
  v10[1] = a3;
  v10[2] = a4;
  v10[3] = a5;
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

void UnsafeMutableRawBufferPointer.subscript.modify(uint64_t **a1)
{
  v1 = *a1;
  UnsafeMutableRawBufferPointer.subscript.setter(**a1, v1[1], v1[2], v1[3], (*a1)[4], (*a1)[5], (*a1)[6], (*a1)[7]);
  free(v1);
}

Swift::Void __swiftcall UnsafeMutableRawBufferPointer.swapAt(_:_:)(Swift::Int a1, Swift::Int a2)
{
  if (a1 != a2)
  {
    if ((a2 | a1) < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xF0uLL,  0);
    }
    if (!v2 || v3 - v2 <= a1 || v3 - v2 <= a2) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xF1uLL,  0);
    }
    char v4 = *(_BYTE *)(v2 + a1);
    *(_BYTE *)(v2 + a1) = *(_BYTE *)(v2 + a2);
    *(_BYTE *)(v2 + a2) = v4;
  }

uint64_t protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableRawBufferPointer( unsigned __int8 *a1, uint64_t *a2)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, *a2, *v2, v2[1]);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableRawBufferPointer( uint64_t a1, uint64_t *a2))(uint64_t a1)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *v2;
  uint64_t v6 = v2[1];
  *(void *)a1 = v4;
  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = v6;
  *(_BYTE *)(a1 + 24) = UnsafeMutableRawBufferPointer.subscript.getter(v4, v5, v6);
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

void *protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableRawBufferPointer( uint64_t *a1, uint64_t *a2)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a2, a2[1], *v2, v2[1]);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableRawBufferPointer( void *a1, uint64_t *a2))(uint64_t **a1)
{
  uint64_t v5 = malloc(0x40uLL);
  *a1 = v5;
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  v5[4] = *a2;
  v5[5] = v7;
  uint64_t v8 = *v2;
  uint64_t v9 = v2[1];
  v5[6] = *v2;
  v5[7] = v9;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xCFuLL,  0);
  }
  if (!v8)
  {
    if (v7 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xD0uLL,  0);
  }

  if (v9 - v8 < v7) {
    goto LABEL_6;
  }
LABEL_4:
  *uint64_t v5 = v6;
  v5[1] = v7;
  v5[2] = v8;
  v5[3] = v9;
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

uint64_t protocol witness for MutableCollection.partition(by:) in conformance UnsafeMutableRawBufferPointer@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v6 = *v2;
  uint64_t v7 = v2[1];
  uint64_t result = (uint64_t)_sSw17withMemoryRebound2to_q0_xm_q0_SryxGq_YKXEtq_YKs5ErrorR_Ri_zRi_0_r1_lFACq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys5UInt8VsAD_pq0_Isgyrzr_Swq0_sAD_pAFRszsAD_pRs_Ri_0_r1_lIetMgyrzo_Tpq5SiSg_Tgq5055_sSw39withContiguousMutableStorageIfAvailableyxSgxSrys5F25VGzKXEKlFAbEKXEfU_Si_TGq5SryAFGxsAD_pRi_zRi0_zlySiIsglrzo_Tf1cn_n( *v2,  v7,  (void *(*)(uint64_t *__return_ptr, uint64_t *))partial apply for specialized closure #1 in MutableCollection<>.partition(by:));
  if (!v3)
  {
    if ((v9 & 1) != 0) {
      uint64_t result = specialized MutableCollection<>._partitionImpl(by:)(a1);
    }
    else {
      uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(0LL, result, v6, v7);
    }
    *a2 = result;
  }

  return result;
}

void protocol witness for MutableCollection.swapAt(_:_:) in conformance UnsafeMutableRawBufferPointer( Swift::Int *a1, Swift::Int *a2)
{
}

uint64_t protocol witness for MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:) in conformance UnsafeMutableRawBufferPointer@<X0>( uint64_t (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a2)
  {
    uint64_t v6 = a3 - a2;
    if (a3 - a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
    uint64_t v7 = a2;
  }

  else
  {
    uint64_t v7 = 0LL;
    uint64_t v6 = 0LL;
  }

  return closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)( v7,  v6,  a1,  a4,  &v9,  a5);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeMutableRawBufferPointer( _BYTE *a1, uint64_t *a2))()
{
  *a1 = UnsafeMutableRawBufferPointer.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer@<X0>( void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer( a1,  0xCFuLL,  0xD0uLL,  a2);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeRawBufferPointer@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *v4;
  uint64_t v9 = v4[1];
  uint64_t v10 = specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a3, *v4, v9);
  if (a2 < 1)
  {
    if (v10 <= 0 && v10 > a2) {
      goto LABEL_4;
    }
LABEL_10:
    uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(v7, a2, v8, v9);
    char v12 = 0;
    goto LABEL_11;
  }

void *UnsafeMutableRawBufferPointer.storeBytes<A>(of:toByteOffset:as:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes with negative offset",  61LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1CCuLL,  0);
  }
  uint64_t v6 = *(void *)(*(void *)(a6 - 8) + 64LL);
  BOOL v7 = __OFADD__(a2, v6);
  uint64_t v8 = a2 + v6;
  if (v7)
  {
    __break(1u);
LABEL_8:
    if (v8 < 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1D0uLL,  0);
    }
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes out of bounds",  54LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1CDuLL,  0);
  }

  if (!a4) {
    goto LABEL_8;
  }
  if (a5 - a4 < v8) {
    goto LABEL_10;
  }
  return UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(a1, a2, a6, a4, a6);
}

void *closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)( const void *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  v22 = a6;
  uint64_t v14 = *(void *)(a7 - 8);
  MEMORY[0x1895F8858](a1);
  size_t v16 = (char *)&v21 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v16, v17, v18);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(a8 + 112))(a7, a8);
  if (a4)
  {
    if (a5 - a4 >= v19) {
      goto LABEL_3;
    }
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.copyBytes source has too many elements",  68LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x205uLL,  0);
  }

  if (v19 >= 1) {
    goto LABEL_8;
  }
LABEL_3:
  uint64_t result = (void *)(*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, a7);
  if (a1)
  {
    if ((a2 & 0x8000000000000000LL) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
    }
    return memmove(v22, a1, a2);
  }

  return result;
}

void *specialized closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)( uint64_t a1, uint64_t a2, void *(*a3)(uint64_t *__return_ptr, uint64_t *))
{
  uint64_t v7 = a1;
  uint64_t v8 = a2;
  uint64_t result = a3(&v9, &v7);
  if (v3)
  {
    if (a1)
    {
      if (!v7 || a1 != v7) {
        goto LABEL_17;
      }
    }

    else if (v7)
    {
      goto LABEL_17;
    }

    if (v8 != a2) {
      goto LABEL_17;
    }
  }

  else
  {
    if (a1)
    {
      if (!v7 || a1 != v7) {
LABEL_17:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed",  106LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x401uLL,  0);
    }

    else if (v7)
    {
      goto LABEL_17;
    }

    if (v8 != a2) {
      goto LABEL_17;
    }
    return (void *)v9;
  }

  return result;
}

uint64_t closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(uint64_t *)@<X2>, uint64_t a4@<X4>, void *a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v14 = a2;
  uint64_t v13 = a1;
  uint64_t result = a3(&v13);
  if (v6)
  {
    if (a1)
    {
      if (!v13 || a1 != v13) {
        goto LABEL_15;
      }
    }

    else if (v13)
    {
      goto LABEL_15;
    }

    if (v14 != a2) {
      goto LABEL_15;
    }
    *a5 = v6;
  }

  else
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))( a6,  0LL,  1LL,  a4);
    if (a1)
    {
      if (!v13 || a1 != v13) {
LABEL_15:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed",  106LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x401uLL,  0);
    }

    else if (v13)
    {
      goto LABEL_15;
    }

    if (v14 != a2) {
      goto LABEL_15;
    }
  }

  return result;
}

unint64_t UnsafeMutableRawBufferPointer.debugDescription.getter( int64_t a1, unint64_t object)
{
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(22LL);
  unint64_t v9 = v5;
  uint64_t countAndFlagsBits = v6;
  v254._uint64_t countAndFlagsBits = v5;
  v254._object = (void *)v6;
  unint64_t v11 = HIBYTE(v6) & 0xF;
  uint64_t v12 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000LL) != 0) {
    uint64_t v13 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v13 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v13 && (v5 & ~v6 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v6);
    v254._uint64_t countAndFlagsBits = 0x203A747261747328LL;
    v254._object = (void *)0xE800000000000000LL;
    unint64_t v251 = object;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }

  if ((v6 & 0x2000000000000000LL) == 0 || v11 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000LL, 6LL, v7, v8);
    if ((countAndFlagsBits & 0x1000000000000000LL) == 0)
    {
      Swift::Int v24 = v13 + 8;
      if (!__OFADD__(v13, 8LL)) {
        goto LABEL_13;
      }
      goto LABEL_281;
    }

    goto LABEL_279;
  }

  uint64_t v14 = 8 * HIBYTE(v6);
  uint64_t v15 = (40LL << (v14 & 0x38)) | ((-255LL << (v14 & 0x38)) - 1) & v5;
  char v16 = (v14 + 8) & 0x38;
  uint64_t v17 = (-255LL << v16) - 1;
  uint64_t v18 = 115LL << v16;
  if (v11 >= 7)
  {
    unint64_t v20 = v18 | v17 & v6;
    char v19 = 8;
    goto LABEL_32;
  }

  uint64_t v15 = v18 | v17 & v15;
  if (v11 == 6)
  {
    char v19 = 0;
    unint64_t v20 = v6;
LABEL_32:
    uint64_t v32 = (116LL << v19) | ((-255LL << v19) - 1) & v20;
    char v33 = v11 + 3;
LABEL_33:
    uint64_t v34 = (97LL << (8 * (v33 & 7u))) | ((-255LL << (8 * (v33 & 7u))) - 1) & v32;
    char v35 = v11 + 4;
LABEL_34:
    uint64_t v36 = (114LL << (8 * (v35 & 7u))) | ((-255LL << (8 * (v35 & 7u))) - 1) & v34;
    char v37 = v11 + 5;
LABEL_35:
    uint64_t v38 = (116LL << (8 * (v37 & 7u))) | ((-255LL << (8 * (v37 & 7u))) - 1) & v36;
    char v39 = v11 + 6;
LABEL_36:
    uint64_t v40 = (58LL << (8 * (v39 & 7u))) | ((-255LL << (8 * (v39 & 7u))) - 1) & v38;
    char v41 = v11 + 7;
    goto LABEL_37;
  }

  uint64_t v15 = (116LL << ((v14 + 16) & 0x38)) | ((-255LL << ((v14 + 16) & 0x38)) - 1) & v15;
  if (v11 >= 5)
  {
    char v33 = 8;
    uint64_t v32 = v6;
    goto LABEL_33;
  }

  uint64_t v15 = (97LL << ((v14 + 24) & 0x38)) | ((-255LL << ((v14 + 24) & 0x38)) - 1) & v15;
  if (v11 == 4)
  {
    char v35 = 8;
    uint64_t v34 = v6;
    goto LABEL_34;
  }

  uint64_t v15 = (114LL << ((v14 + 32) & 0x38)) | ((-255LL << ((v14 + 32) & 0x38)) - 1) & v15;
  if (v11 >= 3)
  {
    char v37 = 8;
    uint64_t v36 = v6;
    goto LABEL_35;
  }

  uint64_t v15 = (116LL << ((v14 + 40) & 0x38)) | ((-255LL << ((v14 + 40) & 0x38)) - 1) & v15;
  if (v11 == 2)
  {
    char v39 = 8;
    uint64_t v38 = v6;
    goto LABEL_36;
  }

  uint64_t v15 = (58LL << ((v14 + 48) & 0x38)) | ((-255LL << ((v14 + 48) & 0x38)) - 1) & v15;
  if (!v11)
  {
    uint64_t v15 = (32LL << ((v14 + 56) & 0x38)) | ((-255LL << ((v14 + 56) & 0x38)) - 1) & v15;
    uint64_t v42 = v6;
    goto LABEL_38;
  }

  char v41 = 8;
  uint64_t v40 = v6;
LABEL_37:
  uint64_t v42 = (32LL << (8 * (v41 & 7u))) | ((-255LL << (8 * (v41 & 7u))) - 1) & v40;
LABEL_38:
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  unint64_t v45 = 0xA000000000000000LL;
  if (!(v15 & 0x8080808080808080LL | v42 & 0x80808080808080LL)) {
    unint64_t v45 = 0xE000000000000000LL;
  }
  v254._uint64_t countAndFlagsBits = v15;
  v254._object = (void *)((v45 & 0xFF00000000000000LL | (v11 << 56) | v42 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000LL);
  unint64_t v251 = object;
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  unint64_t v9 = 0xE300000000000000LL;
  uint64_t v12 = 7104878LL;
  while (1)
  {
    uint64_t countAndFlagsBits = v254._countAndFlagsBits;
    object = (unint64_t)v254._object;
    unint64_t v78 = ((unint64_t)v254._object >> 56) & 0xF;
    else {
      unint64_t v79 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    int64_t v252 = a1;
    if (!v79 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254._uint64_t countAndFlagsBits = v12;
      v254._object = (void *)v9;
      goto LABEL_170;
    }

    uint64_t v80 = v9 & 0x2000000000000000LL;
    unint64_t v2 = HIBYTE(v9) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000LL) != 0 && v80)
    {
      unint64_t v81 = v78 + v2;
      if (v78 + v2 <= 0xF)
      {
        if (v2)
        {
          char v102 = 0;
          unint64_t v103 = 0LL;
          unint64_t v104 = (unint64_t)v254._object;
          do
          {
            unint64_t v105 = v78 + v103;
            unint64_t v106 = v103 + 1;
            if (v103 >= 8) {
              unint64_t v107 = v9;
            }
            else {
              unint64_t v107 = v12;
            }
            unint64_t v108 = v107 >> (v102 & 0x38);
            char v109 = (8 * v78 + v102) & 0x38;
            uint64_t v110 = (-255LL << v109) - 1;
            unint64_t v111 = (unint64_t)v108 << v109;
            unint64_t v112 = v111 | v110 & v104;
            unint64_t v113 = v111 | v110 & countAndFlagsBits;
            if (v105 < 8) {
              uint64_t countAndFlagsBits = v113;
            }
            else {
              unint64_t v104 = v112;
            }
            v102 += 8;
            unint64_t v103 = v106;
          }

          while (v2 != v106);
        }

        else
        {
          unint64_t v104 = (unint64_t)v254._object;
        }

        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease(v9);
        unint64_t v140 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | v104 & 0x80808080808080LL)) {
          unint64_t v140 = 0xE000000000000000LL;
        }
        v254._uint64_t countAndFlagsBits = countAndFlagsBits;
        v254._object = (void *)(v140 & 0xFF00000000000000LL | (v81 << 56) | v104 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }

      uint64_t v80 = 1LL;
    }

    a1 = v12 & 0xFFFFFFFFFFFFLL;
    uint64_t v82 = v80 ? HIBYTE(v9) & 0xF : v12 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v9, 2LL, v43, v44);
    uint64_t v250 = v82;
    if ((v9 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v9, 4LL, v83, v84);
    if ((object & 0x1000000000000000LL) != 0) {
      goto LABEL_270;
    }
LABEL_95:
    BOOL v87 = __OFADD__(v79, v82);
    Swift::Int v88 = v79 + v82;
    if (v87) {
      goto LABEL_272;
    }
LABEL_96:
    if ((countAndFlagsBits & ~object & 0x2000000000000000LL) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v88 >= 16)
      {
        uint64_t v89 = v254._countAndFlagsBits;
        uint64_t countAndFlagsBits = (uint64_t)v254._object;
        goto LABEL_105;
      }

      object = (unint64_t)v254._object;
      if (((uint64_t)v254._object & 0x2000000000000000LL) != 0)
      {
        int v101 = 0;
        uint64_t countAndFlagsBits = (uint64_t)v254._object;
      }

      else
      {
        uint64_t countAndFlagsBits = (uint64_t)v254._object;
LABEL_128:
        int v101 = 1;
      }

LABEL_291:
    if ((v61 & 0x1000000000000000LL) != 0)
    {
      unint64_t v2 = _StringGuts._foreignConvertedToSmall()(v2, v61);
      unint64_t v249 = v248;
      swift_bridgeObjectRelease(v61);
      unint64_t v61 = v249;
    }

    else
    {
      if ((v2 & 0x1000000000000000LL) != 0)
      {
        v239 = (unsigned __int8 *)((v61 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v240 = v2 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        v239 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, v61);
      }

      closure #1 in _StringGuts._convertedToSmall()(v239, v240, &v253);
      swift_bridgeObjectRelease(v61);
      unint64_t v61 = *((void *)&v253 + 1);
      unint64_t v2 = v253;
    }

    if ((v61 & 0x1000000000000000LL) != 0)
    {
      unint64_t v2 = _StringGuts._foreignConvertedToSmall()(v2, v61);
      unint64_t v249 = v248;
      swift_bridgeObjectRelease(v61);
      unint64_t v61 = v249;
    }

    else
    {
      if ((v2 & 0x1000000000000000LL) != 0)
      {
        v239 = (unsigned __int8 *)((v61 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v240 = v2 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        v239 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, v61);
      }

      closure #1 in _StringGuts._convertedToSmall()(v239, v240, &v253);
      swift_bridgeObjectRelease(v61);
      unint64_t v61 = *((void *)&v253 + 1);
      unint64_t v2 = v253;
    }

        swift_getTypeByMangledName(&v256, 255LL, v89, v91, v92, &v268, &v264);
        Swift::String::Index v162 = v267;
        if (v267 == &v264)
        {
          Swift::String::Index v162 = &v264;
          unint64_t v163 = 4LL;
          uint64_t v12 = a5;
        }

        else
        {
          uint64_t v12 = a5;
          if (!v267) {
            goto LABEL_296;
          }
          unint64_t v163 = 5LL;
        }

        (*(void (**)(void))(*v162 + 8 * v163))();
LABEL_296:
        unint64_t v164 = v270;
        if (v270 == (uint64_t *)&v268)
        {
          unint64_t v164 = (uint64_t *)&v268;
          unint64_t v165 = 4LL;
        }

        else
        {
          if (!v270) {
            goto LABEL_301;
          }
          unint64_t v165 = 5LL;
        }

        (*(void (**)(void))(*v164 + 8 * v165))();
LABEL_301:
        if ((_WORD)v259)
        {
          if ((unsigned __int16)v259 == 1)
          {
            unint64_t v166 = v256;
            unint64_t v167 = (uint64_t (*)(void *, uint64_t, void))v257;
            *(void *)(a9 + 8) = v257;
            *(void *)a9 = v167(v166, 2LL, 0LL);
            unint64_t v168 = 1;
            goto LABEL_361;
          }

          unint64_t v169 = 0LL;
        }

        else
        {
          unint64_t v169 = (uint64_t *)v256;
        }

        if ((v51 & 1) == 0) {
          goto LABEL_430;
        }
        v170 = v51 & 0xFFFFFFFFFFFFFFFELL;
        int64_t v171 = *(void *)((v51 & 0xFFFFFFFFFFFFFFFELL) - 8);
        if (v171)
        {
          char v172 = 0LL;
          while (1)
          {
            uint64_t v173 = *(void *)(v170 + 8 * v172);
            if (*(void *)v173 == 771LL)
            {
              v174 = (*(_BYTE *)(v173 + 11) & 0x40) != 0 ? *(void *)(v173 + 16) : 0LL;
              if (v174) {
                uint64_t v173 = v174;
              }
            }

            if ((isSubclass(v173, v169) & 1) == 0) {
              break;
            }
            if (v171 == ++v172) {
              goto LABEL_317;
            }
          }

          swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v25 + *v25, a2);
          unint64_t v196 = (int)v195;
          unint64_t v197 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v25 + *v25, v195);
          swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v239 + *v239, v198);
          char v200 = (int)v199;
          uint64_t v201 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v239 + *v239, v199);
          unint64_t v202 = operator new(0x30uLL);
          *(void *)unint64_t v202 = "%.*s is not subclass of %.*s at pack index %zu";
          v202[2] = v196;
          *((void *)v202 + 2) = v197;
          v202[6] = v200;
          *((void *)v202 + 4) = v201;
          *((void *)v202 + 5) = v172;
          unint64_t v168 = 1;
          *(void *)a9 = v202;
          *(void *)(a9 + 8) = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*,unsigned long>(char const*,int,char const*,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*,unsigned long>(char const*,int,char const*,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
        }

        else
        {
LABEL_317:
          unint64_t v168 = 0;
          *(_BYTE *)a9 = 0;
        }

        uint64_t v12 = a5;
LABEL_361:
        *(_BYTE *)(a9 + 16) = v168;
        goto LABEL_381;
      case 3:
        goto LABEL_339;
      case 4:
        v94 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)(*(int *)(v13 + 8) + v13 + 8), a2);
        char v96 = v95;
        if (v252)
        {
          if (v252 != v251)
          {
            v259 = (void **)(*(uint64_t (**)(void))(*v252 + 16LL))();
            uint64_t v97 = v250;
            if (v250) {
              goto LABEL_149;
            }
LABEL_188:
            v270 = 0LL;
            goto LABEL_321;
          }

          v259 = &v256;
          (*(void (**)(void *, void **))(v251[0] + 24LL))(v251, &v256);
          uint64_t v97 = v250;
          if (!v250) {
            goto LABEL_188;
          }
        }

        else
        {
          v259 = 0LL;
          uint64_t v97 = v250;
          if (!v250) {
            goto LABEL_188;
          }
        }

LABEL_302:
      unint64_t v244 = 266LL;
LABEL_304:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v244,  0);
    }
  }

  else if (v146 <= 15)
  {
    unint64_t v147 = (unint64_t)v254._object;
    goto LABEL_197;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v146, v11);
  swift_bridgeObjectRelease_n(v9, 4LL);
  if ((v9 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v9);
    _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0LL, object);
    swift_bridgeObjectRelease_n(v9, 2LL);
    goto LABEL_203;
  }

  if (a1)
  {
    swift_bridgeObjectRelease_n(v9, 2LL);
    *(void *)&__int128 v253 = v12;
    *((void *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
    v150 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v82, (uint64_t)&v253, v82);
    _StringGuts.appendInPlace(_:isASCII:)(v150, v151, (v9 & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease(v9);
    goto LABEL_203;
  }

  if ((v12 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v9);
    id v217 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v218 = v250;
    uint64_t v219 = v250;
    int64_t v171 = v252;
  }

  else
  {
    id v217 = _StringObject.sharedUTF8.getter(v12, v9);
    uint64_t v219 = v242;
    swift_bridgeObjectRelease(v9);
    if (v219 < v250) {
LABEL_301:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    int64_t v171 = v252;
    uint64_t v218 = v250;
  }

  v220 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v218, (uint64_t)v217, v219);
  _StringGuts.appendInPlace(_:isASCII:)(v220, v221, v12 < 0);
  swift_bridgeObjectRelease_n(v9, 2LL);
LABEL_204:
  if (v171) {
    uint64_t v175 = v251 - v171;
  }
  else {
    uint64_t v175 = 0LL;
  }
  unint64_t v177 = _int64ToString(_:radix:uppercase:)( v175,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v178 = v176;
  uint64_t v179 = v254._countAndFlagsBits;
  unint64_t v180 = ((unint64_t)v254._object >> 56) & 0xF;
  unint64_t v181 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v181 || (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v254._object & 0x2000000000000000LL) == 0)
    {
      if ((v176 & 0x2000000000000000LL) != 0)
      {
        uint64_t v182 = HIBYTE(v176) & 0xF;
        goto LABEL_216;
      }

      unint64_t v244 = 266LL;
LABEL_304:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v244,  0);
    }
  }

  else if (v146 <= 15)
  {
    unint64_t v147 = (unint64_t)v254._object;
    goto LABEL_197;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v146, v11);
  swift_bridgeObjectRelease_n(v9, 4LL);
  if ((v9 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v9);
    _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0LL, object);
    swift_bridgeObjectRelease_n(v9, 2LL);
    goto LABEL_203;
  }

  if (a1)
  {
    swift_bridgeObjectRelease_n(v9, 2LL);
    *(void *)&__int128 v253 = v12;
    *((void *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
    v150 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v82, (uint64_t)&v253, v82);
    _StringGuts.appendInPlace(_:isASCII:)(v150, v151, (v9 & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease(v9);
    goto LABEL_203;
  }

  if ((v12 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v9);
    id v217 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v218 = v250;
    uint64_t v219 = v250;
    int64_t v171 = v252;
  }

  else
  {
    id v217 = _StringObject.sharedUTF8.getter(v12, v9);
    uint64_t v219 = v242;
    swift_bridgeObjectRelease(v9);
    if (v219 < v250) {
LABEL_301:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    int64_t v171 = v252;
    uint64_t v218 = v250;
  }

  v220 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v218, (uint64_t)v217, v219);
  _StringGuts.appendInPlace(_:isASCII:)(v220, v221, v12 < 0);
  swift_bridgeObjectRelease_n(v9, 2LL);
LABEL_204:
  if (v171) {
    uint64_t v175 = v251 - v171;
  }
  else {
    uint64_t v175 = 0LL;
  }
  unint64_t v177 = _int64ToString(_:radix:uppercase:)( v175,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v178 = v176;
  uint64_t v179 = v254._countAndFlagsBits;
  unint64_t v180 = ((unint64_t)v254._object >> 56) & 0xF;
  unint64_t v181 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v181 || (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v254._object & 0x2000000000000000LL) == 0)
    {
      if ((v176 & 0x2000000000000000LL) != 0)
      {
        uint64_t v182 = HIBYTE(v176) & 0xF;
        goto LABEL_216;
      }

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeMutableRawBufferPointer()
{
  return UnsafeMutableRawBufferPointer.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t (*UnsafeMutableRawBufferPointer.subscript.modify(void *a1))()
{
  *a1 = 0LL;
  a1[1] = 0LL;
  return EnumeratedSequence._base.modify;
}

{
  *a1 = 0LL;
  a1[1] = 0LL;
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawBufferPointer._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeRawBufferPointer.Iterator._position.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*UnsafeRawBufferPointer.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawBufferPointer.Iterator._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeRawBufferPointer.Iterator._end.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*UnsafeRawBufferPointer.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt8_optional __swiftcall UnsafeRawBufferPointer.Iterator.next()()
{
  unint64_t v2 = *v0;
  uint64_t v1 = v0[1];
  if (!*v0)
  {
    if (v1) {
LABEL_13:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x4BAuLL,  0);
LABEL_10:
    __int16 v5 = 0;
    __int16 v4 = 1;
    return (Swift::UInt8_optional)(v5 | (v4 << 8));
  }

  if (v1) {
    BOOL v3 = v2 == v1;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3) {
    goto LABEL_10;
  }
  if (!v1) {
    goto LABEL_13;
  }
  if (v2 >= v1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x4BAuLL,  0);
  }
  __int16 v4 = 0;
  __int16 v5 = *v2;
  uint64_t *v0 = v2 + 1;
  return (Swift::UInt8_optional)(v5 | (v4 << 8));
}

Swift::UInt8_optional protocol witness for IteratorProtocol.next() in conformance UnsafeRawBufferPointer.Iterator@<W0>( Swift::UInt8 *a1@<X8>)
{
  Swift::UInt8_optional result = UnsafeRawBufferPointer.Iterator.next()();
  *a1 = result.value;
  a1[1] = result.is_nil;
  return result;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeRawBufferPointer.Iterator()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeRawBufferPointer.Iterator( char **a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeRawBufferPointer()
{
  if (*v0) {
    return v0[1] - *v0;
  }
  else {
    return 0LL;
  }
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, void, void))
{
  *a1 = a6(a2, a3, *v6, v6[1]);
  a1[1] = v8;
  return v9;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeRawBufferPointer@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a2)
  {
    uint64_t v9 = a3 - a2;
    if (a3 - a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    uint64_t v10 = a2;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v9 = 0LL;
  }

  uint64_t result = a1(v10, v9);
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))(a5, 0LL, 1LL, a4);
  }
  return result;
}

uint64_t UnsafeRawBufferPointer.startIndex.getter()
{
  return 0LL;
}

uint64_t UnsafeRawBufferPointer.endIndex.getter(uint64_t a1, uint64_t a2)
{
  if (a1) {
    return a2 - a1;
  }
  else {
    return 0LL;
  }
}

uint64_t UnsafeRawBufferPointer.indices.getter()
{
  return 0LL;
}

uint64_t UnsafeRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, 0x505uLL, 0x506uLL);
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  a4,  0);
  }
  if (!a2 || a3 - a2 <= a1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  a5,  0);
  }
  return *(unsigned __int8 *)(a2 + a1);
}

uint64_t UnsafeRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, a4, 0x513uLL, 0x514uLL);
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  if (result < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  a5,  0);
  }
  if (a3)
  {
    if (a4 - a3 >= a2) {
      return result;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  a6,  0);
  }

  if (a2 >= 1) {
    goto LABEL_6;
  }
  return result;
}

void protocol witness for Collection.endIndex.getter in conformance UnsafeRawBufferPointer(void *a1@<X8>)
{
  uint64_t v2 = *v1;
  if (*v1) {
    uint64_t v2 = v1[1] - v2;
  }
  *a1 = v2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeRawBufferPointer( _BYTE *a1, uint64_t *a2))()
{
  *a1 = UnsafeRawBufferPointer.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UnsafeRawBufferPointer@<X0>( void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer( a1,  0x513uLL,  0x514uLL,  a2);
}

void *protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer@<X0>( void *result@<X0>, unint64_t a2@<X3>, unint64_t a3@<X4>, void *a4@<X8>)
{
  if ((*result & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  a2,  0);
  }
  uint64_t v5 = result[1];
  uint64_t v6 = *v4;
  uint64_t v7 = v4[1];
  if (!*v4)
  {
    if (v5 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  a3,  0);
  }

  if (v7 - v6 < v5) {
    goto LABEL_6;
  }
LABEL_4:
  *a4 = *result;
  a4[1] = v5;
  a4[2] = v6;
  a4[3] = v7;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance UnsafeRawBufferPointer@<X0>( void *a1@<X8>)
{
  uint64_t result = UnsafeRawBufferPointer.indices.getter();
  *a1 = 0LL;
  a1[1] = v3;
  return result;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance UnsafeRawBufferPointer()
{
  return !*v0 || v0[1] == *v0;
}

uint64_t protocol witness for Collection.index(after:) in conformance UnsafeRawBufferPointer@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2, v2[1]);
  *a2 = result;
  return result;
}

uint64_t *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableRawBufferPointer( uint64_t *result)
{
  if (!*v1 || (uint64_t v2 = *result, *result < 0) || v2 >= v1[1] - *v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  *uint64_t result = v2 + 1;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeRawBufferPointer@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2, v2[1]);
  *a2 = result;
  return result;
}

uint64_t *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableRawBufferPointer( uint64_t *result)
{
  uint64_t v2 = *result - 1;
  if (__OFSUB__(*result, 1LL))
  {
    __break(1u);
  }

  else
  {
    if (!*v1 || v2 < 0 || v2 >= v1[1] - *v1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
    }
    *uint64_t result = v2;
  }

  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance UnsafeRawBufferPointer@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3, v3[1]);
  *a3 = result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance UnsafeRawBufferPointer( uint64_t *a1, uint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2, v2[1]);
}

Swift::Void __swiftcall UnsafeRawBufferPointer.deallocate()()
{
  if (v0) {
    swift_slowDealloc(v0);
  }
}

  ;
}

uint64_t UnsafeRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    uint64_t result = a3 + a1;
  }
  else {
    uint64_t result = 0LL;
  }
  uint64_t v5 = a2 - a1;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  if (v5)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  return result;
}

unint64_t UnsafeRawBufferPointer.debugDescription.getter(uint64_t a1, unint64_t object)
{
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(22LL);
  unint64_t v9 = v5;
  uint64_t countAndFlagsBits = v6;
  v254._uint64_t countAndFlagsBits = v5;
  v254._object = (void *)v6;
  unint64_t v11 = HIBYTE(v6) & 0xF;
  uint64_t v12 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000LL) != 0) {
    uint64_t v13 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v13 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v13 && (v5 & ~v6 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v6);
    v254._uint64_t countAndFlagsBits = 0x203A747261747328LL;
    v254._object = (void *)0xE800000000000000LL;
    unint64_t v251 = object;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }

  if ((v6 & 0x2000000000000000LL) == 0 || v11 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000LL, 6LL, v7, v8);
    if ((countAndFlagsBits & 0x1000000000000000LL) == 0)
    {
      Swift::Int v24 = v13 + 8;
      if (!__OFADD__(v13, 8LL)) {
        goto LABEL_13;
      }
      goto LABEL_281;
    }

    goto LABEL_279;
  }

  uint64_t v14 = 8 * HIBYTE(v6);
  uint64_t v15 = (40LL << (v14 & 0x38)) | ((-255LL << (v14 & 0x38)) - 1) & v5;
  char v16 = (v14 + 8) & 0x38;
  uint64_t v17 = (-255LL << v16) - 1;
  uint64_t v18 = 115LL << v16;
  if (v11 >= 7)
  {
    unint64_t v20 = v18 | v17 & v6;
    char v19 = 8;
    goto LABEL_32;
  }

  uint64_t v15 = v18 | v17 & v15;
  if (v11 == 6)
  {
    char v19 = 0;
    unint64_t v20 = v6;
LABEL_32:
    uint64_t v32 = (116LL << v19) | ((-255LL << v19) - 1) & v20;
    char v33 = v11 + 3;
LABEL_33:
    uint64_t v34 = (97LL << (8 * (v33 & 7u))) | ((-255LL << (8 * (v33 & 7u))) - 1) & v32;
    char v35 = v11 + 4;
LABEL_34:
    uint64_t v36 = (114LL << (8 * (v35 & 7u))) | ((-255LL << (8 * (v35 & 7u))) - 1) & v34;
    char v37 = v11 + 5;
LABEL_35:
    uint64_t v38 = (116LL << (8 * (v37 & 7u))) | ((-255LL << (8 * (v37 & 7u))) - 1) & v36;
    char v39 = v11 + 6;
LABEL_36:
    uint64_t v40 = (58LL << (8 * (v39 & 7u))) | ((-255LL << (8 * (v39 & 7u))) - 1) & v38;
    char v41 = v11 + 7;
    goto LABEL_37;
  }

  uint64_t v15 = (116LL << ((v14 + 16) & 0x38)) | ((-255LL << ((v14 + 16) & 0x38)) - 1) & v15;
  if (v11 >= 5)
  {
    char v33 = 8;
    uint64_t v32 = v6;
    goto LABEL_33;
  }

  uint64_t v15 = (97LL << ((v14 + 24) & 0x38)) | ((-255LL << ((v14 + 24) & 0x38)) - 1) & v15;
  if (v11 == 4)
  {
    char v35 = 8;
    uint64_t v34 = v6;
    goto LABEL_34;
  }

  uint64_t v15 = (114LL << ((v14 + 32) & 0x38)) | ((-255LL << ((v14 + 32) & 0x38)) - 1) & v15;
  if (v11 >= 3)
  {
    char v37 = 8;
    uint64_t v36 = v6;
    goto LABEL_35;
  }

  uint64_t v15 = (116LL << ((v14 + 40) & 0x38)) | ((-255LL << ((v14 + 40) & 0x38)) - 1) & v15;
  if (v11 == 2)
  {
    char v39 = 8;
    uint64_t v38 = v6;
    goto LABEL_36;
  }

  uint64_t v15 = (58LL << ((v14 + 48) & 0x38)) | ((-255LL << ((v14 + 48) & 0x38)) - 1) & v15;
  if (!v11)
  {
    uint64_t v15 = (32LL << ((v14 + 56) & 0x38)) | ((-255LL << ((v14 + 56) & 0x38)) - 1) & v15;
    uint64_t v42 = v6;
    goto LABEL_38;
  }

  char v41 = 8;
  uint64_t v40 = v6;
LABEL_37:
  uint64_t v42 = (32LL << (8 * (v41 & 7u))) | ((-255LL << (8 * (v41 & 7u))) - 1) & v40;
LABEL_38:
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  unint64_t v45 = 0xA000000000000000LL;
  if (!(v15 & 0x8080808080808080LL | v42 & 0x80808080808080LL)) {
    unint64_t v45 = 0xE000000000000000LL;
  }
  v254._uint64_t countAndFlagsBits = v15;
  v254._object = (void *)((v45 & 0xFF00000000000000LL | (v11 << 56) | v42 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000LL);
  unint64_t v251 = object;
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  unint64_t v9 = 0xE300000000000000LL;
  uint64_t v12 = 7104878LL;
  while (1)
  {
    uint64_t countAndFlagsBits = v254._countAndFlagsBits;
    object = (unint64_t)v254._object;
    unint64_t v78 = ((unint64_t)v254._object >> 56) & 0xF;
    else {
      unint64_t v79 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v252 = a1;
    if (!v79 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254._uint64_t countAndFlagsBits = v12;
      v254._object = (void *)v9;
      goto LABEL_170;
    }

    uint64_t v80 = v9 & 0x2000000000000000LL;
    unint64_t v2 = HIBYTE(v9) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000LL) != 0 && v80)
    {
      unint64_t v81 = v78 + v2;
      if (v78 + v2 <= 0xF)
      {
        if (v2)
        {
          char v102 = 0;
          unint64_t v103 = 0LL;
          unint64_t v104 = (unint64_t)v254._object;
          do
          {
            unint64_t v105 = v78 + v103;
            unint64_t v106 = v103 + 1;
            if (v103 >= 8) {
              unint64_t v107 = v9;
            }
            else {
              unint64_t v107 = v12;
            }
            unint64_t v108 = v107 >> (v102 & 0x38);
            char v109 = (8 * v78 + v102) & 0x38;
            uint64_t v110 = (-255LL << v109) - 1;
            unint64_t v111 = (unint64_t)v108 << v109;
            unint64_t v112 = v111 | v110 & v104;
            unint64_t v113 = v111 | v110 & countAndFlagsBits;
            if (v105 < 8) {
              uint64_t countAndFlagsBits = v113;
            }
            else {
              unint64_t v104 = v112;
            }
            v102 += 8;
            unint64_t v103 = v106;
          }

          while (v2 != v106);
        }

        else
        {
          unint64_t v104 = (unint64_t)v254._object;
        }

        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease(v9);
        unint64_t v140 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | v104 & 0x80808080808080LL)) {
          unint64_t v140 = 0xE000000000000000LL;
        }
        v254._uint64_t countAndFlagsBits = countAndFlagsBits;
        v254._object = (void *)(v140 & 0xFF00000000000000LL | (v81 << 56) | v104 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }

      uint64_t v80 = 1LL;
    }

    a1 = v12 & 0xFFFFFFFFFFFFLL;
    uint64_t v82 = v80 ? HIBYTE(v9) & 0xF : v12 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v9, 2LL, v43, v44);
    uint64_t v250 = v82;
    if ((v9 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v9, 4LL, v83, v84);
    if ((object & 0x1000000000000000LL) != 0) {
      goto LABEL_270;
    }
LABEL_95:
    BOOL v87 = __OFADD__(v79, v82);
    Swift::Int v88 = v79 + v82;
    if (v87) {
      goto LABEL_272;
    }
LABEL_96:
    if ((countAndFlagsBits & ~object & 0x2000000000000000LL) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v88 >= 16)
      {
        uint64_t v89 = v254._countAndFlagsBits;
        uint64_t countAndFlagsBits = (uint64_t)v254._object;
        goto LABEL_105;
      }

      object = (unint64_t)v254._object;
      if (((uint64_t)v254._object & 0x2000000000000000LL) != 0)
      {
        int v101 = 0;
        uint64_t countAndFlagsBits = (uint64_t)v254._object;
      }

      else
      {
        uint64_t countAndFlagsBits = (uint64_t)v254._object;
LABEL_128:
        int v101 = 1;
      }

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeRawBufferPointer()
{
  return UnsafeRawBufferPointer.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t UnsafeRawBufferPointer.subscript.getter()
{
  return 0LL;
}

uint64_t withUnsafeMutableBytes<A, B>(of:_:)( uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  return withUnsafeMutableBytes<A, B>(of:_:)( a1,  a2,  a3,  a4,  a5,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  0x68uLL);
}

uint64_t withUnsafeBytes<A, B>(of:_:)( uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  return withUnsafeMutableBytes<A, B>(of:_:)( a1,  a2,  a3,  a4,  a5,  "UnsafeRawBufferPointer with negative count",  42LL,  0x485uLL);
}

uint64_t withUnsafeMutableBytes<A, B>(of:_:)( uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, unint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a4 - 8) + 64LL);
  if (v8 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a6,  a7,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  a8,  0);
  }
  return a2(a1, a1 + v8);
}

uint64_t withUnsafeBytes<A, B>(of:_:)( uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a4 - 8) + 64LL);
  if (v4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  return a2(a1, a1 + v4);
}

uint64_t == infix(_:_:)()
{
  return 1LL;
}

uint64_t != infix(_:_:)()
{
  return 0LL;
}

uint64_t < infix(_:_:)()
{
  return 0LL;
}

uint64_t <= infix(_:_:)()
{
  return 1LL;
}

uint64_t > infix(_:_:)()
{
  return 0LL;
}

uint64_t >= infix(_:_:)()
{
  return 1LL;
}

uint64_t != infix<A, B>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a8;
  uint64_t v27 = a3;
  uint64_t v28 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, a6, 0LL, 0LL);
  uint64_t v29 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v16 = (char *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v26 - v17;
  char v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL);
  v19((char *)&v26 - v17, a1, a5);
  unint64_t v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16LL);
  v21(v20, a2, a6);
  v19(v16, v27, a5);
  uint64_t v22 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v22, v28, a6);
  else {
    char v23 = 1;
  }
  Swift::Int v24 = *(void (**)(char *, unint64_t *))(v29 + 8);
  v24(v16, TupleTypeMetadata2);
  v24(v18, TupleTypeMetadata2);
  return v23 & 1;
}

uint64_t <= infix<A, B>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = a8;
  uint64_t v30 = a3;
  uint64_t v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, a6, 0LL, 0LL);
  uint64_t v32 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  char v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL);
  v19((char *)&v29 - v17, a1, a5);
  unint64_t v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16LL);
  uint64_t v22 = a2;
  uint64_t v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  Swift::Int v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  else {
    char v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 24))(v18, v16, a5);
  }
  char v26 = v25;
  uint64_t v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

uint64_t == infix<A, B, C>(_:_:)( uint64_t a1, uint64_t a2, char *a3, char *a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v49 = a5;
  uint64_t v50 = a6;
  char v47 = a3;
  uint64_t v48 = a4;
  uint64_t v46 = a10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a8, a9, 0LL, 0LL);
  uint64_t v42 = *(TupleTypeMetadata2 - 1);
  uint64_t v43 = TupleTypeMetadata2;
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v41 = (char *)&v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  unint64_t v45 = (char *)&v39 - v18;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0LL, a7, a8, a9, 0LL, 0LL);
  uint64_t v44 = *(TupleTypeMetadata3 - 1);
  uint64_t v20 = MEMORY[0x1895F8858](TupleTypeMetadata3);
  uint64_t v22 = (char *)&v39 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  Swift::Int v24 = (char *)&v39 - v23;
  char v25 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL);
  v25((char *)&v39 - v23, a1, a7);
  char v26 = *(void (**)(void))(*(void *)(a8 - 8) + 16LL);
  uint64_t v40 = &v24[*((int *)TupleTypeMetadata3 + 12)];
  v26();
  uint64_t v27 = *(void (**)(void))(*(void *)(a9 - 8) + 16LL);
  v27();
  v25(v22, (uint64_t)v48, a7);
  uint64_t v28 = &v22[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(char *, char *, uint64_t))v26)(v28, v49, a8);
  uint64_t v49 = &v22[*((int *)TupleTypeMetadata3 + 16)];
  v27();
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v46 + 8))(v24, v22, a7) & 1) != 0)
  {
    uint64_t v50 = a11;
    uint64_t v29 = v45;
    ((void (*)(char *, char *, uint64_t))v26)(v45, v40, a8);
    uint64_t v48 = v28;
    uint64_t v30 = v43;
    char v47 = &v29[*((int *)v43 + 12)];
    v27();
    uint64_t v31 = v41;
    ((void (*)(char *, char *, uint64_t))v26)(v41, v48, a8);
    uint64_t v32 = &v31[*((int *)v30 + 12)];
    ((void (*)(char *, char *, uint64_t))v27)(v32, v49, a9);
    char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(v50 + 8))(v29, v31, a8);
    uint64_t v34 = v42;
    if ((v33 & 1) != 0) {
      char v35 = (*(uint64_t (**)(char *, char *, uint64_t))(a12 + 8))(v47, v32, a9);
    }
    else {
      char v35 = 0;
    }
    uint64_t v36 = *(void (**)(char *, unint64_t *))(v34 + 8);
    v36(v31, v30);
    v36(v45, v30);
  }

  else
  {
    char v35 = 0;
  }

  char v37 = *(void (**)(char *, unint64_t *))(v44 + 8);
  v37(v22, TupleTypeMetadata3);
  v37(v24, TupleTypeMetadata3);
  return v35 & 1;
}

uint64_t != infix<A, B, C>(_:_:)( uint64_t a1, uint64_t a2, char *a3, char *a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v49 = a5;
  uint64_t v50 = a6;
  char v47 = a3;
  uint64_t v48 = a4;
  uint64_t v46 = a10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a8, a9, 0LL, 0LL);
  uint64_t v42 = *(TupleTypeMetadata2 - 1);
  uint64_t v43 = TupleTypeMetadata2;
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v41 = (char *)&v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  unint64_t v45 = (char *)&v39 - v18;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0LL, a7, a8, a9, 0LL, 0LL);
  uint64_t v44 = *(TupleTypeMetadata3 - 1);
  uint64_t v20 = MEMORY[0x1895F8858](TupleTypeMetadata3);
  uint64_t v22 = (char *)&v39 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  Swift::Int v24 = (char *)&v39 - v23;
  char v25 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL);
  v25((char *)&v39 - v23, a1, a7);
  char v26 = *(void (**)(void))(*(void *)(a8 - 8) + 16LL);
  uint64_t v40 = &v24[*((int *)TupleTypeMetadata3 + 12)];
  v26();
  uint64_t v27 = *(void (**)(void))(*(void *)(a9 - 8) + 16LL);
  v27();
  v25(v22, (uint64_t)v48, a7);
  uint64_t v28 = &v22[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(char *, char *, uint64_t))v26)(v28, v49, a8);
  uint64_t v49 = &v22[*((int *)TupleTypeMetadata3 + 16)];
  v27();
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v46 + 8))(v24, v22, a7) & 1) != 0)
  {
    uint64_t v50 = a11;
    uint64_t v29 = v45;
    ((void (*)(char *, char *, uint64_t))v26)(v45, v40, a8);
    uint64_t v48 = v28;
    uint64_t v30 = v43;
    char v47 = &v29[*((int *)v43 + 12)];
    v27();
    uint64_t v31 = v41;
    ((void (*)(char *, char *, uint64_t))v26)(v41, v48, a8);
    uint64_t v32 = &v31[*((int *)v30 + 12)];
    ((void (*)(char *, char *, uint64_t))v27)(v32, v49, a9);
    char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(v50 + 8))(v29, v31, a8);
    uint64_t v34 = v42;
    if ((v33 & 1) != 0) {
      char v35 = (*(uint64_t (**)(char *, char *, uint64_t))(a12 + 8))(v47, v32, a9) ^ 1;
    }
    else {
      char v35 = 1;
    }
    uint64_t v36 = *(void (**)(char *, unint64_t *))(v34 + 8);
    v36(v31, v30);
    v36(v45, v30);
  }

  else
  {
    char v35 = 1;
  }

  char v37 = *(void (**)(char *, unint64_t *))(v44 + 8);
  v37(v22, TupleTypeMetadata3);
  v37(v24, TupleTypeMetadata3);
  return v35 & 1;
}

uint64_t <= infix<A, B, C>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v35 = a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0LL, a7, a8, a9, 0LL, 0LL);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata3);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v32 - v19;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL);
  v21((char *)&v32 - v19, a1, a7);
  uint64_t v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16LL);
  char v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  uint64_t v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  Swift::Int v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  uint64_t v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  uint64_t v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  uint64_t v27 = v37;
  else {
    char v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 24))(v20, v18, a7, v27);
  }
  char v29 = v28;
  uint64_t v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t > infix<A, B, C>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v35 = a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0LL, a7, a8, a9, 0LL, 0LL);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata3);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v32 - v19;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL);
  v21((char *)&v32 - v19, a1, a7);
  uint64_t v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16LL);
  char v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  uint64_t v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  Swift::Int v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  uint64_t v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  uint64_t v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  uint64_t v27 = v37;
  else {
    char v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 40))(v20, v18, a7, v27);
  }
  char v29 = v28;
  uint64_t v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t >= infix<A, B, C>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v35 = a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0LL, a7, a8, a9, 0LL, 0LL);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata3);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v32 - v19;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL);
  v21((char *)&v32 - v19, a1, a7);
  uint64_t v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16LL);
  char v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  uint64_t v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  Swift::Int v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  uint64_t v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  uint64_t v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  uint64_t v27 = v37;
  else {
    char v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 32))(v20, v18, a7, v27);
  }
  char v29 = v28;
  uint64_t v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t == infix<A, B, C, D>(_:_:)( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v41 = a6;
  uint64_t v42 = a7;
  uint64_t v39 = a4;
  uint64_t v40 = a5;
  uint64_t v38 = a3;
  uint64_t v43 = a13;
  uint64_t v44 = a8;
  v46[0] = a9;
  v46[1] = a10;
  v46[2] = a11;
  v46[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 4, (uint64_t)v46, 0LL, 0LL);
  uint64_t v45 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v20 = (char *)&v35 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v35 - v21;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v23((char *)&v35 - v21, a1, a9);
  Swift::Int v24 = *(void (**)(void))(*(void *)(a10 - 8) + 16LL);
  uint64_t v36 = &v22[TupleTypeMetadata[12]];
  v24();
  uint64_t v25 = *(void (**)(void))(*(void *)(a11 - 8) + 16LL);
  uint64_t v35 = &v22[TupleTypeMetadata[16]];
  v25();
  uint64_t v26 = &v22[TupleTypeMetadata[20]];
  uint64_t v37 = a12;
  uint64_t v38 = v26;
  uint64_t v27 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  v27();
  v23(v20, (uint64_t)v40, a9);
  uint64_t v40 = &v20[TupleTypeMetadata[12]];
  uint64_t v41 = a10;
  v24();
  char v28 = &v20[TupleTypeMetadata[16]];
  uint64_t v29 = v42;
  uint64_t v42 = a11;
  uint64_t v30 = v37;
  ((void (*)(char *, uint64_t, uint64_t))v25)(v28, v29, a11);
  uint64_t v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v44, v30);
  else {
    char v32 = 0;
  }
  char v33 = *(void (**)(char *, int *))(v45 + 8);
  v33(v20, TupleTypeMetadata);
  v33(v22, TupleTypeMetadata);
  return v32 & 1;
}

uint64_t != infix<A, B, C, D>(_:_:)( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v41 = a6;
  uint64_t v42 = a7;
  uint64_t v39 = a4;
  uint64_t v40 = a5;
  uint64_t v38 = a3;
  uint64_t v43 = a13;
  uint64_t v44 = a8;
  v46[0] = a9;
  v46[1] = a10;
  v46[2] = a11;
  v46[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 4, (uint64_t)v46, 0LL, 0LL);
  uint64_t v45 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v20 = (char *)&v35 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v35 - v21;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v23((char *)&v35 - v21, a1, a9);
  Swift::Int v24 = *(void (**)(void))(*(void *)(a10 - 8) + 16LL);
  uint64_t v36 = &v22[TupleTypeMetadata[12]];
  v24();
  uint64_t v25 = *(void (**)(void))(*(void *)(a11 - 8) + 16LL);
  uint64_t v35 = &v22[TupleTypeMetadata[16]];
  v25();
  uint64_t v26 = &v22[TupleTypeMetadata[20]];
  uint64_t v37 = a12;
  uint64_t v38 = v26;
  uint64_t v27 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  v27();
  v23(v20, (uint64_t)v40, a9);
  uint64_t v40 = &v20[TupleTypeMetadata[12]];
  uint64_t v41 = a10;
  v24();
  char v28 = &v20[TupleTypeMetadata[16]];
  uint64_t v29 = v42;
  uint64_t v42 = a11;
  uint64_t v30 = v37;
  ((void (*)(char *, uint64_t, uint64_t))v25)(v28, v29, a11);
  uint64_t v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v44, v30);
  else {
    char v32 = 1;
  }
  char v33 = *(void (**)(char *, int *))(v45 + 8);
  v33(v20, TupleTypeMetadata);
  v33(v22, TupleTypeMetadata);
  return v32 & 1;
}

uint64_t < infix<A, B, C, D>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v43 = a6;
  uint64_t v44 = a7;
  uint64_t v41 = a4;
  uint64_t v42 = (char *)a5;
  uint64_t v39 = (char *)a2;
  uint64_t v40 = a3;
  uint64_t v45 = a13;
  uint64_t v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 4, (uint64_t)v48, 0LL, 0LL);
  uint64_t v47 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v37 - v21;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v23((char *)&v37 - v21, a1, a9);
  Swift::Int v24 = *(void (**)(void))(*(void *)(a10 - 8) + 16LL);
  uint64_t v37 = &v22[TupleTypeMetadata[12]];
  v24();
  uint64_t v25 = *(void (**)(void))(*(void *)(a11 - 8) + 16LL);
  uint64_t v39 = &v22[TupleTypeMetadata[16]];
  v25();
  uint64_t v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v38 = a12;
  uint64_t v27 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  uint64_t v42 = &v20[TupleTypeMetadata[12]];
  uint64_t v43 = a10;
  v24();
  uint64_t v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v29 = v44;
  uint64_t v44 = a11;
  uint64_t v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  uint64_t v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  uint64_t v32 = v45;
  else {
    char v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 16))(v22, v20, a9, v32);
  }
  char v34 = v33;
  uint64_t v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t <= infix<A, B, C, D>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v43 = a6;
  uint64_t v44 = a7;
  uint64_t v41 = a4;
  uint64_t v42 = (char *)a5;
  uint64_t v39 = (char *)a2;
  uint64_t v40 = a3;
  uint64_t v45 = a13;
  uint64_t v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 4, (uint64_t)v48, 0LL, 0LL);
  uint64_t v47 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v37 - v21;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v23((char *)&v37 - v21, a1, a9);
  Swift::Int v24 = *(void (**)(void))(*(void *)(a10 - 8) + 16LL);
  uint64_t v37 = &v22[TupleTypeMetadata[12]];
  v24();
  uint64_t v25 = *(void (**)(void))(*(void *)(a11 - 8) + 16LL);
  uint64_t v39 = &v22[TupleTypeMetadata[16]];
  v25();
  uint64_t v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v38 = a12;
  uint64_t v27 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  uint64_t v42 = &v20[TupleTypeMetadata[12]];
  uint64_t v43 = a10;
  v24();
  uint64_t v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v29 = v44;
  uint64_t v44 = a11;
  uint64_t v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  uint64_t v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  uint64_t v32 = v45;
  else {
    char v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 24))(v22, v20, a9, v32);
  }
  char v34 = v33;
  uint64_t v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t > infix<A, B, C, D>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v43 = a6;
  uint64_t v44 = a7;
  uint64_t v41 = a4;
  uint64_t v42 = (char *)a5;
  uint64_t v39 = (char *)a2;
  uint64_t v40 = a3;
  uint64_t v45 = a13;
  uint64_t v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 4, (uint64_t)v48, 0LL, 0LL);
  uint64_t v47 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v37 - v21;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v23((char *)&v37 - v21, a1, a9);
  Swift::Int v24 = *(void (**)(void))(*(void *)(a10 - 8) + 16LL);
  uint64_t v37 = &v22[TupleTypeMetadata[12]];
  v24();
  uint64_t v25 = *(void (**)(void))(*(void *)(a11 - 8) + 16LL);
  uint64_t v39 = &v22[TupleTypeMetadata[16]];
  v25();
  uint64_t v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v38 = a12;
  uint64_t v27 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  uint64_t v42 = &v20[TupleTypeMetadata[12]];
  uint64_t v43 = a10;
  v24();
  uint64_t v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v29 = v44;
  uint64_t v44 = a11;
  uint64_t v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  uint64_t v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  uint64_t v32 = v45;
  else {
    char v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 40))(v22, v20, a9, v32);
  }
  char v34 = v33;
  uint64_t v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t >= infix<A, B, C, D>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v43 = a6;
  uint64_t v44 = a7;
  uint64_t v41 = a4;
  uint64_t v42 = (char *)a5;
  uint64_t v39 = (char *)a2;
  uint64_t v40 = a3;
  uint64_t v45 = a13;
  uint64_t v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 4, (uint64_t)v48, 0LL, 0LL);
  uint64_t v47 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v37 - v21;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v23((char *)&v37 - v21, a1, a9);
  Swift::Int v24 = *(void (**)(void))(*(void *)(a10 - 8) + 16LL);
  uint64_t v37 = &v22[TupleTypeMetadata[12]];
  v24();
  uint64_t v25 = *(void (**)(void))(*(void *)(a11 - 8) + 16LL);
  uint64_t v39 = &v22[TupleTypeMetadata[16]];
  v25();
  uint64_t v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v38 = a12;
  uint64_t v27 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  uint64_t v42 = &v20[TupleTypeMetadata[12]];
  uint64_t v43 = a10;
  v24();
  uint64_t v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v29 = v44;
  uint64_t v44 = a11;
  uint64_t v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  uint64_t v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  uint64_t v32 = v45;
  else {
    char v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 32))(v22, v20, a9, v32);
  }
  char v34 = v33;
  uint64_t v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t == infix<A, B, C, D, E>(_:_:)( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v47 = a6;
  uint64_t v48 = a7;
  uint64_t v45 = a3;
  uint64_t v46 = (char *)a5;
  uint64_t v43 = (char *)a4;
  uint64_t v44 = (char *)a2;
  uint64_t v52 = a16;
  uint64_t v50 = a8;
  uint64_t v51 = a10;
  uint64_t v49 = a9;
  v54[0] = a11;
  v54[1] = a12;
  v54[2] = a13;
  v54[3] = a14;
  v54[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 5, (uint64_t)v54, 0LL, 0LL);
  uint64_t v53 = *((void *)TupleTypeMetadata - 1);
  uint64_t v22 = MEMORY[0x1895F8858](TupleTypeMetadata);
  Swift::Int v24 = (char *)&v38 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v38 - v25;
  uint64_t v42 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a11 - 8) + 16LL);
  v42((char *)&v38 - v25, a1, a11);
  uint64_t v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  uint64_t v41 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v39 = v27;
  v41();
  uint64_t v28 = *(void (**)(void))(*(void *)(a13 - 8) + 16LL);
  uint64_t v44 = &v26[TupleTypeMetadata[16]];
  v28();
  uint64_t v29 = &v26[TupleTypeMetadata[20]];
  uint64_t v40 = a14;
  uint64_t v30 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v45 = v29;
  v30();
  uint64_t v31 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v43 = &v26[TupleTypeMetadata[24]];
  v31();
  v42(v24, (uint64_t)v47, a11);
  uint64_t v47 = &v24[TupleTypeMetadata[12]];
  uint64_t v48 = a12;
  v41();
  uint64_t v46 = &v24[TupleTypeMetadata[16]];
  uint64_t v50 = a13;
  v28();
  uint64_t v32 = v40;
  uint64_t v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v49, v40);
  uint64_t v34 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v34, v51, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v52 + 8))(v26, v24, a11) & 1) != 0) {
    char v35 = == infix<A, B, C, D>(_:_:)( v39,  (uint64_t)v44,  v45,  (uint64_t)v43,  v47,  (uint64_t)v46,  v33,  v34,  v48,  v50,  v32,  a15,  a17,  a18,  a19,  a20);
  }
  else {
    char v35 = 0;
  }
  uint64_t v36 = *(void (**)(char *, int *))(v53 + 8);
  v36(v24, TupleTypeMetadata);
  v36(v26, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t != infix<A, B, C, D, E>(_:_:)( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v47 = a6;
  uint64_t v48 = a7;
  uint64_t v45 = a3;
  uint64_t v46 = (char *)a5;
  uint64_t v43 = (char *)a4;
  uint64_t v44 = (char *)a2;
  uint64_t v52 = a16;
  uint64_t v50 = a8;
  uint64_t v51 = a10;
  uint64_t v49 = a9;
  v54[0] = a11;
  v54[1] = a12;
  v54[2] = a13;
  v54[3] = a14;
  v54[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 5, (uint64_t)v54, 0LL, 0LL);
  uint64_t v53 = *((void *)TupleTypeMetadata - 1);
  uint64_t v22 = MEMORY[0x1895F8858](TupleTypeMetadata);
  Swift::Int v24 = (char *)&v38 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v38 - v25;
  uint64_t v42 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a11 - 8) + 16LL);
  v42((char *)&v38 - v25, a1, a11);
  uint64_t v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  uint64_t v41 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v39 = v27;
  v41();
  uint64_t v28 = *(void (**)(void))(*(void *)(a13 - 8) + 16LL);
  uint64_t v44 = &v26[TupleTypeMetadata[16]];
  v28();
  uint64_t v29 = &v26[TupleTypeMetadata[20]];
  uint64_t v40 = a14;
  uint64_t v30 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v45 = v29;
  v30();
  uint64_t v31 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v43 = &v26[TupleTypeMetadata[24]];
  v31();
  v42(v24, (uint64_t)v47, a11);
  uint64_t v47 = &v24[TupleTypeMetadata[12]];
  uint64_t v48 = a12;
  v41();
  uint64_t v46 = &v24[TupleTypeMetadata[16]];
  uint64_t v50 = a13;
  v28();
  uint64_t v32 = v40;
  uint64_t v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v49, v40);
  uint64_t v34 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v34, v51, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v52 + 8))(v26, v24, a11) & 1) != 0) {
    char v35 = != infix<A, B, C, D>(_:_:)( v39,  (uint64_t)v44,  v45,  (uint64_t)v43,  v47,  (uint64_t)v46,  v33,  v34,  v48,  v50,  v32,  a15,  a17,  a18,  a19,  a20);
  }
  else {
    char v35 = 1;
  }
  uint64_t v36 = *(void (**)(char *, int *))(v53 + 8);
  v36(v24, TupleTypeMetadata);
  v36(v26, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t < infix<A, B, C, D, E>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v49 = (char *)a6;
  uint64_t v50 = a7;
  uint64_t v47 = (char *)a4;
  uint64_t v48 = (char *)a5;
  uint64_t v45 = (char *)a2;
  uint64_t v46 = a3;
  uint64_t v54 = a16;
  uint64_t v52 = a8;
  uint64_t v53 = a10;
  uint64_t v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 5, (uint64_t)v56, 0LL, 0LL);
  uint64_t v55 = *((void *)TupleTypeMetadata - 1);
  uint64_t v22 = MEMORY[0x1895F8858](TupleTypeMetadata);
  Swift::Int v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v40 - v25;
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a11 - 8) + 16LL);
  v44((char *)&v40 - v25, a1, a11);
  uint64_t v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  uint64_t v43 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v41 = v27;
  v43();
  uint64_t v28 = *(void (**)(void))(*(void *)(a13 - 8) + 16LL);
  uint64_t v45 = &v26[TupleTypeMetadata[16]];
  v28();
  uint64_t v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  uint64_t v42 = a14;
  uint64_t v30 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v46 = v29;
  v30();
  uint64_t v31 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  uint64_t v49 = &v24[TupleTypeMetadata[12]];
  uint64_t v50 = a12;
  v43();
  uint64_t v48 = &v24[TupleTypeMetadata[16]];
  uint64_t v52 = a13;
  v28();
  uint64_t v32 = v42;
  uint64_t v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  uint64_t v34 = v54;
  uint64_t v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v34 + 8) + 8LL))(v26, v24, a11) & 1) != 0) {
    char v36 = < infix<A, B, C, D>(_:_:)( v41,  (uint64_t)v45,  v46,  (uint64_t)v47,  (uint64_t)v49,  (uint64_t)v48,  v33,  v35,  v50,  v52,  v32,  a15,  a17,  a18,  a19,  a20);
  }
  else {
    char v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 16))(v26, v24, a11, v34);
  }
  char v37 = v36;
  uint64_t v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t <= infix<A, B, C, D, E>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v49 = (char *)a6;
  uint64_t v50 = a7;
  uint64_t v47 = (char *)a4;
  uint64_t v48 = (char *)a5;
  uint64_t v45 = (char *)a2;
  uint64_t v46 = a3;
  uint64_t v54 = a16;
  uint64_t v52 = a8;
  uint64_t v53 = a10;
  uint64_t v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 5, (uint64_t)v56, 0LL, 0LL);
  uint64_t v55 = *((void *)TupleTypeMetadata - 1);
  uint64_t v22 = MEMORY[0x1895F8858](TupleTypeMetadata);
  Swift::Int v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v40 - v25;
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a11 - 8) + 16LL);
  v44((char *)&v40 - v25, a1, a11);
  uint64_t v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  uint64_t v43 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v41 = v27;
  v43();
  uint64_t v28 = *(void (**)(void))(*(void *)(a13 - 8) + 16LL);
  uint64_t v45 = &v26[TupleTypeMetadata[16]];
  v28();
  uint64_t v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  uint64_t v42 = a14;
  uint64_t v30 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v46 = v29;
  v30();
  uint64_t v31 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  uint64_t v49 = &v24[TupleTypeMetadata[12]];
  uint64_t v50 = a12;
  v43();
  uint64_t v48 = &v24[TupleTypeMetadata[16]];
  uint64_t v52 = a13;
  v28();
  uint64_t v32 = v42;
  uint64_t v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  uint64_t v34 = v54;
  uint64_t v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v34 + 8) + 8LL))(v26, v24, a11) & 1) != 0) {
    char v36 = <= infix<A, B, C, D>(_:_:)( v41,  (uint64_t)v45,  v46,  (uint64_t)v47,  (uint64_t)v49,  (uint64_t)v48,  v33,  v35,  v50,  v52,  v32,  a15,  a17,  a18,  a19,  a20);
  }
  else {
    char v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 24))(v26, v24, a11, v34);
  }
  char v37 = v36;
  uint64_t v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t > infix<A, B, C, D, E>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v49 = (char *)a6;
  uint64_t v50 = a7;
  uint64_t v47 = (char *)a4;
  uint64_t v48 = (char *)a5;
  uint64_t v45 = (char *)a2;
  uint64_t v46 = a3;
  uint64_t v54 = a16;
  uint64_t v52 = a8;
  uint64_t v53 = a10;
  uint64_t v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 5, (uint64_t)v56, 0LL, 0LL);
  uint64_t v55 = *((void *)TupleTypeMetadata - 1);
  uint64_t v22 = MEMORY[0x1895F8858](TupleTypeMetadata);
  Swift::Int v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v40 - v25;
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a11 - 8) + 16LL);
  v44((char *)&v40 - v25, a1, a11);
  uint64_t v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  uint64_t v43 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v41 = v27;
  v43();
  uint64_t v28 = *(void (**)(void))(*(void *)(a13 - 8) + 16LL);
  uint64_t v45 = &v26[TupleTypeMetadata[16]];
  v28();
  uint64_t v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  uint64_t v42 = a14;
  uint64_t v30 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v46 = v29;
  v30();
  uint64_t v31 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  uint64_t v49 = &v24[TupleTypeMetadata[12]];
  uint64_t v50 = a12;
  v43();
  uint64_t v48 = &v24[TupleTypeMetadata[16]];
  uint64_t v52 = a13;
  v28();
  uint64_t v32 = v42;
  uint64_t v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  uint64_t v34 = v54;
  uint64_t v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v34 + 8) + 8LL))(v26, v24, a11) & 1) != 0) {
    char v36 = > infix<A, B, C, D>(_:_:)( v41,  (uint64_t)v45,  v46,  (uint64_t)v47,  (uint64_t)v49,  (uint64_t)v48,  v33,  v35,  v50,  v52,  v32,  a15,  a17,  a18,  a19,  a20);
  }
  else {
    char v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 40))(v26, v24, a11, v34);
  }
  char v37 = v36;
  uint64_t v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t >= infix<A, B, C, D, E>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v49 = (char *)a6;
  uint64_t v50 = a7;
  uint64_t v47 = (char *)a4;
  uint64_t v48 = (char *)a5;
  uint64_t v45 = (char *)a2;
  uint64_t v46 = a3;
  uint64_t v54 = a16;
  uint64_t v52 = a8;
  uint64_t v53 = a10;
  uint64_t v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 5, (uint64_t)v56, 0LL, 0LL);
  uint64_t v55 = *((void *)TupleTypeMetadata - 1);
  uint64_t v22 = MEMORY[0x1895F8858](TupleTypeMetadata);
  Swift::Int v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v40 - v25;
  uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a11 - 8) + 16LL);
  v44((char *)&v40 - v25, a1, a11);
  uint64_t v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  uint64_t v43 = *(void (**)(void))(*(void *)(a12 - 8) + 16LL);
  uint64_t v41 = v27;
  v43();
  uint64_t v28 = *(void (**)(void))(*(void *)(a13 - 8) + 16LL);
  uint64_t v45 = &v26[TupleTypeMetadata[16]];
  v28();
  uint64_t v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  uint64_t v42 = a14;
  uint64_t v30 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v46 = v29;
  v30();
  uint64_t v31 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  uint64_t v49 = &v24[TupleTypeMetadata[12]];
  uint64_t v50 = a12;
  v43();
  uint64_t v48 = &v24[TupleTypeMetadata[16]];
  uint64_t v52 = a13;
  v28();
  uint64_t v32 = v42;
  uint64_t v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  uint64_t v34 = v54;
  uint64_t v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v34 + 8) + 8LL))(v26, v24, a11) & 1) != 0) {
    char v36 = >= infix<A, B, C, D>(_:_:)( v41,  (uint64_t)v45,  v46,  (uint64_t)v47,  (uint64_t)v49,  (uint64_t)v48,  v33,  v35,  v50,  v52,  v32,  a15,  a17,  a18,  a19,  a20);
  }
  else {
    char v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 32))(v26, v24, a11, v34);
  }
  char v37 = v36;
  uint64_t v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t == infix<A, B, C, D, E, F>(_:_:)( uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  Swift::String::Index v56 = (char *)a5;
  uint64_t v57 = a6;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  uint64_t v52 = a18;
  uint64_t v53 = a2;
  uint64_t v63 = a12;
  uint64_t v64 = a19;
  uint64_t v61 = a8;
  uint64_t v62 = a11;
  uint64_t v59 = a7;
  uint64_t v60 = a10;
  Swift::String::Index v58 = (char *)a9;
  v66[0] = a13;
  v66[1] = a14;
  v66[2] = a15;
  v66[3] = a16;
  v66[4] = a17;
  v66[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 6, (uint64_t)v66, 0LL, 0LL);
  uint64_t v65 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v28 = (char *)&v45 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v45 - v29;
  uint64_t v51 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a13 - 8) + 16LL);
  v51((char *)&v45 - v29, a1, a13);
  uint64_t v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v50 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v48 = v31;
  v50();
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v53 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v47 = v32;
  v53();
  uint64_t v33 = &v30[TupleTypeMetadata[20]];
  uint64_t v54 = *(void (**)(void))(*(void *)(a16 - 8) + 16LL);
  uint64_t v46 = v33;
  v54();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v49 = a17;
  uint64_t v35 = *(void (**)(void))(*(void *)(a17 - 8) + 16LL);
  uint64_t v55 = v34;
  v35();
  uint64_t v36 = v52;
  char v37 = *(void (**)(void))(*(void *)(v52 - 8) + 16LL);
  Swift::String::Index v56 = &v30[TupleTypeMetadata[28]];
  v37();
  v51(v28, v59, a13);
  uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))&v28[TupleTypeMetadata[12]];
  uint64_t v57 = a14;
  v50();
  uint64_t v50 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  uint64_t v59 = a15;
  v53();
  uint64_t v38 = v36;
  Swift::String::Index v58 = &v28[TupleTypeMetadata[20]];
  uint64_t v61 = a16;
  v54();
  uint64_t v39 = v49;
  uint64_t v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v62, v49);
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v41, v63, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v64 + 8))(v30, v28, a13) & 1) != 0) {
    char v42 = == infix<A, B, C, D, E>(_:_:)( v48,  v47,  v46,  v55,  (uint64_t)v56,  (char *)v51,  (uint64_t)v50,  (uint64_t)v58,  v40,  v41,  v57,  v59,  v61,  v39,  v38,  a20,  a21,  a22,  a23,  a24);
  }
  else {
    char v42 = 0;
  }
  uint64_t v43 = *(void (**)(char *, int *))(v65 + 8);
  v43(v28, TupleTypeMetadata);
  v43(v30, TupleTypeMetadata);
  return v42 & 1;
}

uint64_t != infix<A, B, C, D, E, F>(_:_:)( uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  Swift::String::Index v56 = (char *)a5;
  uint64_t v57 = a6;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  uint64_t v52 = a18;
  uint64_t v53 = a2;
  uint64_t v63 = a12;
  uint64_t v64 = a19;
  uint64_t v61 = a8;
  uint64_t v62 = a11;
  uint64_t v59 = a7;
  uint64_t v60 = a10;
  Swift::String::Index v58 = (char *)a9;
  v66[0] = a13;
  v66[1] = a14;
  v66[2] = a15;
  v66[3] = a16;
  v66[4] = a17;
  v66[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 6, (uint64_t)v66, 0LL, 0LL);
  uint64_t v65 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v28 = (char *)&v45 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v45 - v29;
  uint64_t v51 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a13 - 8) + 16LL);
  v51((char *)&v45 - v29, a1, a13);
  uint64_t v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v50 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v48 = v31;
  v50();
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v53 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v47 = v32;
  v53();
  uint64_t v33 = &v30[TupleTypeMetadata[20]];
  uint64_t v54 = *(void (**)(void))(*(void *)(a16 - 8) + 16LL);
  uint64_t v46 = v33;
  v54();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v49 = a17;
  uint64_t v35 = *(void (**)(void))(*(void *)(a17 - 8) + 16LL);
  uint64_t v55 = v34;
  v35();
  uint64_t v36 = v52;
  char v37 = *(void (**)(void))(*(void *)(v52 - 8) + 16LL);
  Swift::String::Index v56 = &v30[TupleTypeMetadata[28]];
  v37();
  v51(v28, v59, a13);
  uint64_t v51 = (void (*)(char *, uint64_t, uint64_t))&v28[TupleTypeMetadata[12]];
  uint64_t v57 = a14;
  v50();
  uint64_t v50 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  uint64_t v59 = a15;
  v53();
  uint64_t v38 = v36;
  Swift::String::Index v58 = &v28[TupleTypeMetadata[20]];
  uint64_t v61 = a16;
  v54();
  uint64_t v39 = v49;
  uint64_t v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v62, v49);
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v41, v63, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v64 + 8))(v30, v28, a13) & 1) != 0) {
    char v42 = != infix<A, B, C, D, E>(_:_:)( v48,  v47,  v46,  v55,  (uint64_t)v56,  (char *)v51,  (uint64_t)v50,  (uint64_t)v58,  v40,  v41,  v57,  v59,  v61,  v39,  v38,  a20,  a21,  a22,  a23,  a24);
  }
  else {
    char v42 = 1;
  }
  uint64_t v43 = *(void (**)(char *, int *))(v65 + 8);
  v43(v28, TupleTypeMetadata);
  v43(v30, TupleTypeMetadata);
  return v42 & 1;
}

uint64_t < infix<A, B, C, D, E, F>(_:_:)( uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  uint64_t v61 = a7;
  Swift::String::Index v58 = (char *)a5;
  uint64_t v59 = a6;
  Swift::String::Index v56 = a3;
  uint64_t v57 = a4;
  uint64_t v54 = a18;
  uint64_t v55 = a2;
  uint64_t v65 = a12;
  uint64_t v66 = a19;
  uint64_t v63 = a8;
  uint64_t v64 = a11;
  uint64_t v62 = a10;
  uint64_t v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 6, (uint64_t)v68, 0LL, 0LL);
  uint64_t v67 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v47 - v29;
  uint64_t v53 = *(char **)(*(void *)(a13 - 8) + 16LL);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  uint64_t v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v52 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v50 = v31;
  v52();
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v55 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v49 = v32;
  v55();
  uint64_t v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  Swift::String::Index v56 = *(void (**)(void))(*(void *)(a16 - 8) + 16LL);
  uint64_t v48 = v33;
  v56();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v51 = a17;
  uint64_t v35 = *(void (**)(void))(*(void *)(a17 - 8) + 16LL);
  uint64_t v57 = v34;
  v35();
  uint64_t v36 = v54;
  char v37 = *(void (**)(void))(*(void *)(v54 - 8) + 16LL);
  Swift::String::Index v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  uint64_t v53 = &v28[TupleTypeMetadata[12]];
  uint64_t v59 = a14;
  v52();
  uint64_t v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  uint64_t v61 = a15;
  v55();
  uint64_t v38 = v36;
  uint64_t v60 = &v28[TupleTypeMetadata[20]];
  uint64_t v63 = a16;
  v56();
  uint64_t v39 = v51;
  uint64_t v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  uint64_t v41 = v66;
  uint64_t v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v41 + 8) + 8LL))(v30, v28, a13) & 1) != 0) {
    char v43 = < infix<A, B, C, D, E>(_:_:)( v50,  v49,  v48,  v57,  (uint64_t)v58,  (uint64_t)v53,  (uint64_t)v52,  (uint64_t)v60,  v40,  v42,  v59,  v61,  v63,  v39,  v38,  a20,  a21,  a22,  a23,  a24);
  }
  else {
    char v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 16))(v30, v28, a13, v41);
  }
  char v44 = v43;
  uint64_t v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t <= infix<A, B, C, D, E, F>(_:_:)( uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  uint64_t v61 = a7;
  Swift::String::Index v58 = (char *)a5;
  uint64_t v59 = a6;
  Swift::String::Index v56 = a3;
  uint64_t v57 = a4;
  uint64_t v54 = a18;
  uint64_t v55 = a2;
  uint64_t v65 = a12;
  uint64_t v66 = a19;
  uint64_t v63 = a8;
  uint64_t v64 = a11;
  uint64_t v62 = a10;
  uint64_t v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 6, (uint64_t)v68, 0LL, 0LL);
  uint64_t v67 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v47 - v29;
  uint64_t v53 = *(char **)(*(void *)(a13 - 8) + 16LL);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  uint64_t v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v52 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v50 = v31;
  v52();
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v55 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v49 = v32;
  v55();
  uint64_t v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  Swift::String::Index v56 = *(void (**)(void))(*(void *)(a16 - 8) + 16LL);
  uint64_t v48 = v33;
  v56();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v51 = a17;
  uint64_t v35 = *(void (**)(void))(*(void *)(a17 - 8) + 16LL);
  uint64_t v57 = v34;
  v35();
  uint64_t v36 = v54;
  char v37 = *(void (**)(void))(*(void *)(v54 - 8) + 16LL);
  Swift::String::Index v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  uint64_t v53 = &v28[TupleTypeMetadata[12]];
  uint64_t v59 = a14;
  v52();
  uint64_t v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  uint64_t v61 = a15;
  v55();
  uint64_t v38 = v36;
  uint64_t v60 = &v28[TupleTypeMetadata[20]];
  uint64_t v63 = a16;
  v56();
  uint64_t v39 = v51;
  uint64_t v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  uint64_t v41 = v66;
  uint64_t v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v41 + 8) + 8LL))(v30, v28, a13) & 1) != 0) {
    char v43 = <= infix<A, B, C, D, E>(_:_:)( v50,  v49,  v48,  v57,  (uint64_t)v58,  (uint64_t)v53,  (uint64_t)v52,  (uint64_t)v60,  v40,  v42,  v59,  v61,  v63,  v39,  v38,  a20,  a21,  a22,  a23,  a24);
  }
  else {
    char v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 24))(v30, v28, a13, v41);
  }
  char v44 = v43;
  uint64_t v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t > infix<A, B, C, D, E, F>(_:_:)( uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  uint64_t v61 = a7;
  Swift::String::Index v58 = (char *)a5;
  uint64_t v59 = a6;
  Swift::String::Index v56 = a3;
  uint64_t v57 = a4;
  uint64_t v54 = a18;
  uint64_t v55 = a2;
  uint64_t v65 = a12;
  uint64_t v66 = a19;
  uint64_t v63 = a8;
  uint64_t v64 = a11;
  uint64_t v62 = a10;
  uint64_t v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 6, (uint64_t)v68, 0LL, 0LL);
  uint64_t v67 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v47 - v29;
  uint64_t v53 = *(char **)(*(void *)(a13 - 8) + 16LL);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  uint64_t v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v52 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v50 = v31;
  v52();
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v55 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v49 = v32;
  v55();
  uint64_t v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  Swift::String::Index v56 = *(void (**)(void))(*(void *)(a16 - 8) + 16LL);
  uint64_t v48 = v33;
  v56();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v51 = a17;
  uint64_t v35 = *(void (**)(void))(*(void *)(a17 - 8) + 16LL);
  uint64_t v57 = v34;
  v35();
  uint64_t v36 = v54;
  char v37 = *(void (**)(void))(*(void *)(v54 - 8) + 16LL);
  Swift::String::Index v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  uint64_t v53 = &v28[TupleTypeMetadata[12]];
  uint64_t v59 = a14;
  v52();
  uint64_t v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  uint64_t v61 = a15;
  v55();
  uint64_t v38 = v36;
  uint64_t v60 = &v28[TupleTypeMetadata[20]];
  uint64_t v63 = a16;
  v56();
  uint64_t v39 = v51;
  uint64_t v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  uint64_t v41 = v66;
  uint64_t v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v41 + 8) + 8LL))(v30, v28, a13) & 1) != 0) {
    char v43 = > infix<A, B, C, D, E>(_:_:)( v50,  v49,  v48,  v57,  (uint64_t)v58,  (uint64_t)v53,  (uint64_t)v52,  (uint64_t)v60,  v40,  v42,  v59,  v61,  v63,  v39,  v38,  a20,  a21,  a22,  a23,  a24);
  }
  else {
    char v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 40))(v30, v28, a13, v41);
  }
  char v44 = v43;
  uint64_t v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t >= infix<A, B, C, D, E, F>(_:_:)( uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  uint64_t v61 = a7;
  Swift::String::Index v58 = (char *)a5;
  uint64_t v59 = a6;
  Swift::String::Index v56 = a3;
  uint64_t v57 = a4;
  uint64_t v54 = a18;
  uint64_t v55 = a2;
  uint64_t v65 = a12;
  uint64_t v66 = a19;
  uint64_t v63 = a8;
  uint64_t v64 = a11;
  uint64_t v62 = a10;
  uint64_t v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0LL, 6, (uint64_t)v68, 0LL, 0LL);
  uint64_t v67 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1895F8858](TupleTypeMetadata);
  uint64_t v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v47 - v29;
  uint64_t v53 = *(char **)(*(void *)(a13 - 8) + 16LL);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  uint64_t v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v52 = *(void (**)(void))(*(void *)(a14 - 8) + 16LL);
  uint64_t v50 = v31;
  v52();
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v55 = *(void (**)(void))(*(void *)(a15 - 8) + 16LL);
  uint64_t v49 = v32;
  v55();
  uint64_t v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  Swift::String::Index v56 = *(void (**)(void))(*(void *)(a16 - 8) + 16LL);
  uint64_t v48 = v33;
  v56();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v51 = a17;
  uint64_t v35 = *(void (**)(void))(*(void *)(a17 - 8) + 16LL);
  uint64_t v57 = v34;
  v35();
  uint64_t v36 = v54;
  char v37 = *(void (**)(void))(*(void *)(v54 - 8) + 16LL);
  Swift::String::Index v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  uint64_t v53 = &v28[TupleTypeMetadata[12]];
  uint64_t v59 = a14;
  v52();
  uint64_t v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  uint64_t v61 = a15;
  v55();
  uint64_t v38 = v36;
  uint64_t v60 = &v28[TupleTypeMetadata[20]];
  uint64_t v63 = a16;
  v56();
  uint64_t v39 = v51;
  uint64_t v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  uint64_t v41 = v66;
  uint64_t v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v41 + 8) + 8LL))(v30, v28, a13) & 1) != 0) {
    char v43 = >= infix<A, B, C, D, E>(_:_:)( v50,  v49,  v48,  v57,  (uint64_t)v58,  (uint64_t)v53,  (uint64_t)v52,  (uint64_t)v60,  v40,  v42,  v59,  v61,  v63,  v39,  v38,  a20,  a21,  a22,  a23,  a24);
  }
  else {
    char v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 32))(v30, v28, a13, v41);
  }
  char v44 = v43;
  uint64_t v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t SIMD2._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage,  a2);
}

uint64_t SIMD2._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t (*SIMD2._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD2.scalarCount.getter()
{
  return 2LL;
}

uint64_t key path getter for SIMD2.subscript(_:) : <A>SIMD2<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x28uLL,  0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(const char **)((char *)a2 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  unint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD2.subscript(_:) : <A>SIMD2<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x2CuLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD2.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x28uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD2.init(_:_:)(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  size_t v8 = *(void *)(*(void *)(a3 - 8) + 64LL);
  MEMORY[0x1895F8858](a1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v10,  v9,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  memcpy((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, v8);
  uint64_t v13 = *(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v13((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), a2, v8);
  return v13( (char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL),  1LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD2.x.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  0LL);
}

uint64_t key path getter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  0LL);
}

uint64_t key path setter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  a4,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  0LL);
}

uint64_t SIMD2.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  0LL);
}

void (*SIMD2.x.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  size_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(void, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(0LL, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

void SIMD2.x.modify(uint64_t a1, uint64_t a2)
{
}

uint64_t SIMD2.y.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  1LL);
}

uint64_t key path getter for SIMD2.y : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  1LL);
}

uint64_t key path setter for SIMD2.y : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  a4,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  1LL);
}

uint64_t SIMD2.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage,  1LL);
}

void (*SIMD2.y.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  size_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(1LL, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

void SIMD2.y.modify(uint64_t a1, uint64_t a2)
{
}

Swift::Int SIMD2.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD2<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD2<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>( a1,  a2,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD2<A>( unint64_t a1, uint64_t a2)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x28uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  size_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD2<A>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x2CuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  size_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD2<A>( void *a1, unint64_t a2, uint64_t a3))()
{
  size_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *size_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x28uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD2<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD2<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD2<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD2<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD2<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v44 = a2;
  uint64_t v4 = a1;
  uint64_t v39 = *(void *)(a3 + 16);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  char v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v42 = (char *)&v37 - v8;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  size_t v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v37 - v13;
  uint64_t v15 = 0LL;
  char v16 = 1;
  uint64_t v18 = v17;
  uint64_t v19 = *(void (**)(void, void, void))(v17 + 16);
  uint64_t v40 = v12;
  uint64_t v41 = v20;
  char v37 = v19;
  uint64_t v38 = v17;
  uint64_t v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      uint64_t v23 = *(const char **)(v3 + 24);
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
      uint64_t v25 = v11;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
      uint64_t v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v28 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      uint64_t v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      uint64_t v30 = v28;
      uint64_t v19 = v37;
      unint64_t v31 = AssociatedConformanceWitness;
      size_t v11 = v25;
      uint64_t v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v33 = (uint64_t)v23;
      uint64_t v4 = v40;
      unint64_t v34 = swift_getAssociatedConformanceWitness( v33,  v21,  v32,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      unint64_t v35 = swift_getAssociatedConformanceWitness( v34,  v32,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v18 = v38;
      char v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35 + 8) + 8LL))(v42, v43, v21);
    }

    else
    {
      uint64_t v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      char v16 = 0;
    }

    if (++v15 == 2) {
      break;
    }
    v19(v14, v4, v3);
  }

  return v16 & 1;
}

uint64_t SIMD2<>.init<A>(truncatingIfNeeded:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v47 = a6;
  uint64_t v48 = a1;
  uint64_t v42 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v44 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v43 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v15,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v18 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v41 = AssociatedTypeWitness;
  unint64_t v19 = AssociatedConformanceWitness;
  v18(AssociatedTypeWitness);
  uint64_t v45 = a7;
  unint64_t v20 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v39 = a3;
  unint64_t v21 = swift_getAssociatedConformanceWitness( (uint64_t)a7,  a3,  v20,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v40 = *(void (**)(void, unint64_t *, unint64_t))(v21 + 56);
  uint64_t v22 = v40;
  uint64_t v23 = swift_checkMetadataState(0LL, v20);
  Swift::Int v24 = v44;
  v22(0LL, v23, v21);
  uint64_t v25 = *(void *)(v46 + 8);
  uint64_t v26 = *(void *)(v47 + 8);
  uint64_t v46 = *(void *)(v25 + 96);
  uint64_t v47 = v26;
  uint64_t v27 = v43;
  ((void (*)(char *, uint64_t))v46)(v24, a3);
  unint64_t v28 = v19;
  unint64_t v38 = v19;
  uint64_t v29 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(v19 + 64);
  unint64_t v30 = v41;
  v29(v27, 0LL, v41, v28);
  unint64_t v31 = swift_checkMetadataState(0LL, v20);
  uint64_t v32 = v48;
  v40(1LL, v31, v21);
  uint64_t v33 = v39;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v46)(v24, v39, v47, a2, v25);
  v29(v27, 1LL, v30, v38);
  uint64_t v35 = type metadata accessor for SIMD2(0LL, v33, (uint64_t)v45, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v35 - 8) + 8LL))(v32, v35);
}

uint64_t SIMD2<>.init<A>(clamping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v47 = a6;
  uint64_t v48 = a1;
  uint64_t v42 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v44 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v43 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v15,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v18 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v41 = AssociatedTypeWitness;
  unint64_t v19 = AssociatedConformanceWitness;
  v18(AssociatedTypeWitness);
  uint64_t v45 = a7;
  unint64_t v20 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v39 = a3;
  unint64_t v21 = swift_getAssociatedConformanceWitness( (uint64_t)a7,  a3,  v20,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v40 = *(void (**)(void, unint64_t *, unint64_t))(v21 + 56);
  uint64_t v22 = v40;
  uint64_t v23 = swift_checkMetadataState(0LL, v20);
  Swift::Int v24 = v44;
  v22(0LL, v23, v21);
  uint64_t v25 = *(void *)(v46 + 8);
  uint64_t v26 = *(void *)(v47 + 8);
  uint64_t v46 = *(void *)(v25 + 104);
  uint64_t v47 = v26;
  uint64_t v27 = v43;
  ((void (*)(char *, uint64_t))v46)(v24, a3);
  unint64_t v28 = v19;
  unint64_t v38 = v19;
  uint64_t v29 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(v19 + 64);
  unint64_t v30 = v41;
  v29(v27, 0LL, v41, v28);
  unint64_t v31 = swift_checkMetadataState(0LL, v20);
  uint64_t v32 = v48;
  v40(1LL, v31, v21);
  uint64_t v33 = v39;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v46)(v24, v39, v47, a2, v25);
  v29(v27, 1LL, v30, v38);
  uint64_t v35 = type metadata accessor for SIMD2(0LL, v33, (uint64_t)v45, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v35 - 8) + 8LL))(v32, v35);
}

uint64_t SIMD2<>.init<A>(_:rounding:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v48 = a7;
  uint64_t v43 = a5;
  uint64_t v44 = a3;
  uint64_t v50 = a2;
  uint64_t v38 = a1;
  uint64_t v40 = a9;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v46 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v47 = (char *)&v37 - v16;
  MEMORY[0x1895F8858](v15);
  unint64_t v41 = (char *)&v37 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v19,  v18,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  unint64_t v21 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v49 = AssociatedTypeWitness;
  v21(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v42 = a8;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  a8,  a4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)a8,  a4,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v39 = *(void (**)(void, unint64_t *, unint64_t))(v23 + 56);
  Swift::Int v24 = v39;
  uint64_t v25 = swift_checkMetadataState(0LL, v22);
  v24(0LL, v25, v23);
  uint64_t v26 = v47;
  uint64_t v27 = v48;
  uint64_t v28 = *(void *)(v48 + 16);
  uint64_t v37 = *(void (**)(uint64_t, uint64_t, uint64_t))(v28 + 304);
  v37(v50, a4, v28);
  uint64_t v43 = *(void *)(*(void *)(v43 + 8) + 80LL);
  uint64_t v29 = v41;
  ((void (*)(char *, uint64_t, uint64_t))v43)(v26, a4, v27);
  unint64_t v30 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v30)(v29, 0LL, v49);
  unint64_t v31 = swift_checkMetadataState(0LL, v22);
  uint64_t v32 = v38;
  v39(1LL, v31, v23);
  uint64_t v33 = v47;
  v37(v50, a4, v28);
  ((void (*)(char *, uint64_t, uint64_t))v43)(v33, a4, v48);
  v30(v29, 1LL, v49, AssociatedConformanceWitness);
  uint64_t v35 = type metadata accessor for SIMD2(0LL, a4, (uint64_t)v42, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v35 - 8) + 8LL))(v32, v35);
}

uint64_t SIMD2.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(swift **)(a1 + 16);
  size_t v3 = *(void *)(*((void *)v2 - 1) + 64LL);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  v340 = (uint64_t *)((char *)&v336 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v5 = MEMORY[0x1895F8858](v4);
  v342 = (uint64_t *)((char *)&v336 - v6);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  v344 = (uint64_t *)((char *)&v336 - v8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  v346 = (uint64_t *)((char *)&v336 - v10);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v336 - v12;
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  v339 = (uint64_t *)((char *)&v336 - v15);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  v341 = (uint64_t *)((char *)&v336 - v17);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v343 = (uint64_t *)((char *)&v336 - v19);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v345 = (uint64_t *)((char *)&v336 - v21);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v347 = (uint64_t *)((char *)&v336 - v23);
  MEMORY[0x1895F8858](v22);
  v349 = (char *)&v336 - v24;
  uint64_t v25 = specialized static String._createEmpty(withInitialCapacity:)(17LL);
  uint64_t v29 = v25;
  unint64_t v30 = v26;
  unint64_t v356 = v25;
  unint64_t v357 = v26;
  unint64_t v31 = HIBYTE(v26) & 0xF;
  if ((v26 & 0x2000000000000000LL) != 0) {
    uint64_t v32 = HIBYTE(v26) & 0xF;
  }
  else {
    uint64_t v32 = v25 & 0xFFFFFFFFFFFFLL;
  }
  v348 = v13;
  if (!v32 && (v25 & ~v26 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v26);
    unint64_t v356 = 0x3C32444D4953LL;
    unint64_t v357 = 0xE600000000000000LL;
    goto LABEL_40;
  }

  if ((v26 & 0x2000000000000000LL) == 0 || v31 > 9)
  {
    swift_bridgeObjectRetain_n(0xE600000000000000LL, 6LL, v27, v28);
    if ((v30 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v334 = String.UTF8View._foreignCount()();
      int64_t v40 = v334 + 6;
      if (!__OFADD__(v334, 6LL))
      {
LABEL_13:
        if ((v29 & ~v30 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v30 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v41 = _StringGuts.nativeUnusedCapacity.getter(v29, v30);
          if ((v42 & 1) != 0)
          {
            unint64_t v335 = 258LL;
            goto LABEL_257;
          }

          BOOL v44 = (v30 & 0x2000000000000000LL) == 0 && v41 > 5;
          if (v40 <= 15 && !v44)
          {
LABEL_24:
            uint64_t v45 = v1;
            swift_bridgeObjectRelease_n(0xE600000000000000LL, 5LL);
            swift_bridgeObjectRetain(v30, v46, v47, v48);
            unint64_t v49 = _StringGuts._convertedToSmall()(v29, v30);
            unint64_t v51 = v50;
            swift_bridgeObjectRelease(v30);
            v52._rawBits = 1LL;
            v53._rawBits = 393217LL;
            v54._rawBits = _StringGuts.validateScalarRange(_:)(v52, v53, 0x3C32444D4953uLL, 0xE600000000000000LL);
            if (v54._rawBits < 0x10000) {
              v54._rawBits |= 3;
            }
            unint64_t v56 = specialized String.init(_:)(v54, v55, 0x3C32444D4953uLL, 0xE600000000000000LL);
            unint64_t v58 = v57;
            swift_bridgeObjectRelease(0xE600000000000000LL);
            unint64_t v59 = _StringGuts._convertedToSmall()(v56, v58);
            unint64_t v61 = v60;
            swift_bridgeObjectRelease(v58);
            unint64_t v62 = specialized _SmallString.init(_:appending:)(v49, v51, v59, v61);
            if ((v64 & 1) == 0)
            {
              unint64_t v65 = v62;
              unint64_t v66 = v63;
              swift_bridgeObjectRelease(v30);
              swift_bridgeObjectRelease(0xE600000000000000LL);
              unint64_t v356 = v65;
              unint64_t v357 = v66;
              uint64_t v37 = v349;
              uint64_t v1 = v45;
              goto LABEL_41;
            }

            unint64_t v335 = 266LL;
LABEL_257:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v335,  0);
          }
        }

        else if (v40 <= 15)
        {
          goto LABEL_24;
        }

        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v40, 6LL);
        swift_bridgeObjectRelease_n(0xE600000000000000LL, 6LL);
        Swift::String v350 = (Swift::String)xmmword_181800010;
        uint64_t v67 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 6LL, (uint64_t)&v350, 6LL);
        _StringGuts.appendInPlace(_:isASCII:)(v67, v68, 1);
        swift_bridgeObjectRelease(0xE600000000000000LL);
LABEL_40:
        uint64_t v37 = v349;
        goto LABEL_41;
      }
    }

    else
    {
      BOOL v39 = __OFADD__(v32, 6LL);
      int64_t v40 = v32 + 6;
      if (!v39) {
        goto LABEL_13;
      }
    }

    __break(1u);
    goto LABEL_253;
  }

  uint64_t v33 = 8 * HIBYTE(v26);
  uint64_t v34 = (-255LL << (v33 & 0x38)) - 1;
  uint64_t v35 = 83LL << (v33 & 0x38);
  char v36 = v31 + 1;
  if (v31 >= 8)
  {
    unint64_t v38 = v35 | v34 & v26;
    uint64_t v37 = v349;
    goto LABEL_31;
  }

  uint64_t v29 = v35 | v34 & v25;
  uint64_t v37 = v349;
  if (v31 == 7)
  {
    char v36 = 8;
    unint64_t v38 = v26;
LABEL_31:
    uint64_t v69 = (73LL << (8 * (v36 & 7u))) | ((-255LL << (8 * (v36 & 7u))) - 1) & v38;
    char v70 = v31 + 2;
LABEL_32:
    uint64_t v71 = (77LL << (8 * (v70 & 7u))) | ((-255LL << (8 * (v70 & 7u))) - 1) & v69;
    char v72 = v31 + 3;
LABEL_33:
    uint64_t v73 = (68LL << (8 * (v72 & 7u))) | ((-255LL << (8 * (v72 & 7u))) - 1) & v71;
    char v74 = v31 + 4;
LABEL_34:
    size_t v75 = v3;
    uint64_t v76 = (50LL << (8 * (v74 & 7u))) | ((-255LL << (8 * (v74 & 7u))) - 1) & v73;
    char v77 = v31 + 5;
    goto LABEL_35;
  }

  uint64_t v29 = (73LL << (8 * (v36 & 7u))) | ((-255LL << (8 * (v36 & 7u))) - 1) & v29;
  if (v31 >= 6)
  {
    char v70 = 8;
    uint64_t v69 = v26;
    goto LABEL_32;
  }

  uint64_t v29 = (77LL << ((v33 + 16) & 0x38)) | ((-255LL << ((v33 + 16) & 0x38)) - 1) & v29;
  if (v31 == 5)
  {
    char v72 = 8;
    uint64_t v71 = v26;
    goto LABEL_33;
  }

  uint64_t v29 = (68LL << ((v33 + 24) & 0x38)) | ((-255LL << ((v33 + 24) & 0x38)) - 1) & v29;
  if (v31 >= 4)
  {
    char v74 = 8;
    uint64_t v73 = v26;
    goto LABEL_34;
  }

  uint64_t v29 = (50LL << ((v33 + 32) & 0x38)) | ((-255LL << ((v33 + 32) & 0x38)) - 1) & v29;
  size_t v75 = v3;
  if (v31 != 3)
  {
    uint64_t v29 = (60LL << ((v33 + 40) & 0x38)) | ((-255LL << ((v33 + 40) & 0x38)) - 1) & v29;
    uint64_t v78 = v26;
    goto LABEL_36;
  }

  char v77 = 8;
  uint64_t v76 = v26;
LABEL_35:
  uint64_t v78 = (60LL << (8 * (v77 & 7u))) | ((-255LL << (8 * (v77 & 7u))) - 1) & v76;
LABEL_36:
  swift_bridgeObjectRelease(v26);
  swift_bridgeObjectRelease(0xE600000000000000LL);
  unint64_t v79 = 0xA000000000000000LL;
  if (!(v29 & 0x8080808080808080LL | v78 & 0x80808080808080LL)) {
    unint64_t v79 = 0xE000000000000000LL;
  }
  unint64_t v356 = v29;
  unint64_t v357 = (v79 & 0xFF00000000000000LL | (v31 << 56) | v78 & 0xFFFFFFFFFFFFFFLL) + 0x600000000000000LL;
  size_t v3 = v75;
LABEL_41:
  TypeName = (uint8x16_t *)swift_getTypeName((unint64_t)v2, 0);
  if (v81 < 0) {
    goto LABEL_249;
  }
  size_t v84 = v81;
  if (!v81)
  {
    uint64_t countAndFlagsBits = 0LL;
    unint64_t object = 0xE000000000000000LL;
    goto LABEL_157;
  }

  uint64_t v85 = (uint64_t *)TypeName;
  v86 = TypeName;
  if ((v81 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080LL) != 0) {
      goto LABEL_63;
    }
    v86 = TypeName + 1;
    while (v86 < (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFF0LL])
    {
      uint64_t v87 = v86->i64[0];
      uint64_t v88 = v86->i64[1];
      ++v86;
      if (((v88 | v87) & 0x8080808080808080LL) != 0) {
        goto LABEL_63;
      }
    }
  }

  if (v86 < (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFF8LL])
  {
    if ((v86->i64[0] & 0x8080808080808080LL) != 0) {
      goto LABEL_63;
    }
    v86 = (uint8x16_t *)((char *)v86 + 8);
  }

  if (v86 < (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v86->i32[0] & 0x80808080) != 0) {
      goto LABEL_63;
    }
    v86 = (uint8x16_t *)((char *)v86 + 4);
  }

  if (v86 >= (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_59:
    if (v86 >= (uint8x16_t *)&TypeName->i8[v81] || (v86->i8[0] & 0x80000000) == 0)
    {
      if (v81 > 15)
      {
        char v91 = 1;
LABEL_104:
        unint64_t object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( TypeName->i8,  v81,  v81,  v91 & 1);
        uint64_t countAndFlagsBits = *(void *)(object + 24);
        goto LABEL_157;
      }

uint64_t SIMD2<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v47 = a6;
  uint64_t v48 = a1;
  uint64_t v42 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  BOOL v44 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v43 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v15,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v18 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v41 = AssociatedTypeWitness;
  unint64_t v19 = AssociatedConformanceWitness;
  v18(AssociatedTypeWitness);
  uint64_t v45 = a7;
  unint64_t v20 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v39 = a3;
  unint64_t v21 = swift_getAssociatedConformanceWitness( (uint64_t)a7,  a3,  v20,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  int64_t v40 = *(void (**)(void, unint64_t *, unint64_t))(v21 + 56);
  uint64_t v22 = v40;
  uint64_t v23 = swift_checkMetadataState(0LL, v20);
  uint64_t v24 = v44;
  v22(0LL, v23, v21);
  uint64_t v25 = *(void *)(v46 + 16);
  uint64_t v26 = *(void *)(v47 + 8);
  uint64_t v46 = *(void *)(v25 + 72);
  uint64_t v47 = v26;
  uint64_t v27 = v43;
  ((void (*)(char *, uint64_t))v46)(v24, a3);
  unint64_t v28 = v19;
  unint64_t v38 = v19;
  uint64_t v29 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(v19 + 64);
  unint64_t v30 = v41;
  v29(v27, 0LL, v41, v28);
  unint64_t v31 = swift_checkMetadataState(0LL, v20);
  uint64_t v32 = v48;
  v40(1LL, v31, v21);
  uint64_t v33 = v39;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v46)(v24, v39, v47, a2, v25);
  v29(v27, 1LL, v30, v38);
  uint64_t v35 = type metadata accessor for SIMD2(0LL, v33, (uint64_t)v45, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v35 - 8) + 8LL))(v32, v35);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v18)(unint64_t, unint64_t);
  unint64_t v19;
  unint64_t v20;
  void (*v21)(void, unint64_t *, unint64_t);
  unint64_t *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(char *, uint64_t, uint64_t, uint64_t);
  uint64_t v37;
  void (*v38)(void, unint64_t *, unint64_t);
  uint64_t v39;
  char *v40;
  char *v41;
  const char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v43 = a6;
  uint64_t v45 = a4;
  uint64_t v37 = a1;
  uint64_t v39 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  unint64_t v41 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  int64_t v40 = (char *)&v34 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v15,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  BOOL v44 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v42 = a7;
  unint64_t v19 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v35 = a3;
  unint64_t v20 = swift_getAssociatedConformanceWitness( (uint64_t)a7,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  unint64_t v38 = *(void (**)(void, unint64_t *, unint64_t))(v20 + 56);
  unint64_t v21 = v38;
  uint64_t v22 = swift_checkMetadataState(0LL, v19);
  uint64_t v23 = v41;
  v21(0LL, v22, v20);
  char v36 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 80);
  uint64_t v24 = v40;
  uint64_t v25 = a3;
  uint64_t v26 = v43;
  v36(v23, v25, v43, a2);
  uint64_t v27 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v27(v24, 0LL, v44, AssociatedConformanceWitness);
  unint64_t v28 = swift_checkMetadataState(0LL, v19);
  uint64_t v29 = v37;
  v38(1LL, v28, v20);
  unint64_t v30 = v35;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v36)(v23, v35, v26, a2, v45);
  v27(v24, 1LL, v44, AssociatedConformanceWitness);
  uint64_t v32 = type metadata accessor for SIMD2(0LL, v30, (uint64_t)v42, v31);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v32 - 8) + 8LL))(v29, v32);
}

uint64_t SIMD4._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage,  a2);
}

uint64_t SIMD4._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t (*SIMD4._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD4.scalarCount.getter()
{
  return 4LL;
}

uint64_t key path getter for SIMD4.subscript(_:) : <A>SIMD4<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC5uLL,  0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(const char **)((char *)a2 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD4.subscript(_:) : <A>SIMD4<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC9uLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD4.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC5uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD4.init(_:_:_:_:)( const void *a1, const void *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v18 = a4;
  size_t v11 = *(void *)(*(void *)(a5 - 8) + 64LL);
  MEMORY[0x1895F8858](a1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v12,  a5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, v11);
  uint64_t v15 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL), 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL), a2, v11);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL), 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL), a3, v11);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL), 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL), v18, v11);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v15)( (char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL),  3LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD4.x.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  0LL);
}

uint64_t key path getter for SIMD4.x : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  0LL);
}

uint64_t key path setter for SIMD4.x : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  a4,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  0LL);
}

uint64_t SIMD4.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  0LL);
}

void (*SIMD4.x.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(void, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(0LL, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

uint64_t SIMD4.y.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  1LL);
}

uint64_t key path getter for SIMD4.y : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  1LL);
}

uint64_t key path setter for SIMD4.y : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  a4,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  1LL);
}

uint64_t SIMD4.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  1LL);
}

void (*SIMD4.y.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(1LL, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

uint64_t SIMD4.z.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  2LL);
}

uint64_t key path getter for SIMD4.z : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  2LL);
}

uint64_t key path setter for SIMD4.z : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  a4,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  2LL);
}

uint64_t SIMD4.z.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  2LL);
}

void (*SIMD4.z.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(2LL, v12, AssociatedConformanceWitness);
  return SIMD4.z.modify;
}

void SIMD4.z.modify(uint64_t a1, uint64_t a2)
{
}

uint64_t SIMD4.w.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  3LL);
}

uint64_t key path getter for SIMD4.w : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  3LL);
}

uint64_t key path setter for SIMD4.w : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>( a1,  a2,  a3,  a4,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  3LL);
}

uint64_t SIMD4.w.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  3LL);
}

void (*SIMD4.w.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(3LL, v12, AssociatedConformanceWitness);
  return SIMD4.w.modify;
}

void SIMD4.w.modify(uint64_t a1, uint64_t a2)
{
}

uint64_t SIMD4.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v11 = type metadata accessor for SIMD4(0LL, a3, (uint64_t)a4, v10);
  specialized SIMD4.lowHalf.setter(a1, v11, 0LL, 1LL);
  uint64_t v13 = type metadata accessor for SIMD2(0LL, a3, (uint64_t)a4, v12);
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8LL);
  v15(a1, v13);
  specialized SIMD4.lowHalf.setter(a2, v11, 2LL, 3LL);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 0LL, 1LL);
}

uint64_t SIMD4.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 2LL, 3LL);
}

uint64_t SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for SIMD2(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8LL))(a1, v7);
}

uint64_t SIMD4.lowHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 0LL, 1LL);
}

uint64_t key path getter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD4,  SIMD4.lowHalf.getter);
}

uint64_t key path setter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 0LL, 1LL);
}

void (*SIMD4.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD2(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.lowHalf.getter(a2);
  return SIMD4.lowHalf.modify;
}

void SIMD4.lowHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD4.highHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 2LL, 3LL);
}

uint64_t key path getter for SIMD4.highHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD4,  SIMD4.highHalf.getter);
}

uint64_t key path getter for SIMD4.lowHalf : <A>SIMD4<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void, void), uint64_t (*a5)(uint64_t))
{
  uint64_t v6 = a4(0LL, *(void *)(a3 + a2 - 16), *(void *)(a3 + a2 - 8));
  return a5(v6);
}

uint64_t key path setter for SIMD4.highHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 2LL, 3LL);
}

uint64_t key path setter for SIMD4.lowHalf : <A>SIMD4<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = type metadata accessor for SIMD4(0LL, *(void *)(a4 + a3 - 16), *(void *)(a4 + a3 - 8), a4);
  return specialized SIMD4.lowHalf.setter(a1, v9, a5, a6);
}

void (*SIMD4.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD2(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.highHalf.getter(a2);
  return SIMD4.highHalf.modify;
}

void SIMD4.highHalf.modify(uint64_t **a1, char a2)
{
}

void SIMD4.lowHalf.modify(uint64_t **a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *a1;
  uint64_t v7 = (void *)(*a1)[4];
  uint64_t v8 = (void *)(*a1)[5];
  uint64_t v9 = (*a1)[2];
  uint64_t v10 = (*a1)[3];
  uint64_t v11 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v10 + 16))((*a1)[4], v8, v9);
    specialized SIMD4.lowHalf.setter((uint64_t)v7, v11, a3, a4);
    uint64_t v12 = *(void (**)(void *, uint64_t))(v10 + 8);
    v12(v7, v9);
  }

  else
  {
    specialized SIMD4.lowHalf.setter((*a1)[5], v11, a3, a4);
    uint64_t v12 = *(void (**)(void *, uint64_t))(v10 + 8);
  }

  v12(v8, v9);
  free(v8);
  free(v7);
  free(v6);
}

uint64_t SIMD4.evenHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 0LL, 2LL);
}

uint64_t key path getter for SIMD4.evenHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD4,  SIMD4.evenHalf.getter);
}

uint64_t key path setter for SIMD4.evenHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 0LL, 2LL);
}

uint64_t SIMD4.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 0LL, 2LL);
}

void (*SIMD4.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD2(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.evenHalf.getter(a2);
  return SIMD4.evenHalf.modify;
}

void SIMD4.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD4.oddHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 1LL, 3LL);
}

uint64_t SIMD4.lowHalf.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = a2;
  uint64_t v18 = a3;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(const char **)(v4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v11 = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  v10,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v12 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v11 + 56);
  uint64_t v13 = swift_checkMetadataState(0LL, v10);
  v12(v17, v13, v11);
  uint64_t v14 = *(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v14(v6, 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v15 = swift_checkMetadataState(0LL, v10);
  v12(v18, v15, v11);
  return v14(v6, 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD4.oddHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD4,  SIMD4.oddHalf.getter);
}

uint64_t key path setter for SIMD4.oddHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 1LL, 3LL);
}

uint64_t SIMD4.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 1LL, 3LL);
}

void (*SIMD4.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD2(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.oddHalf.getter(a2);
  return SIMD4.oddHalf.modify;
}

void SIMD4.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD4.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD4<A>, a3);
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMD4<A>()
{
  return 4LL;
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD4<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD4<A>( unint64_t a1, uint64_t a2)
{
  if (a1 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC5uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD4<A>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC9uLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  size_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD4<A>( void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC5uLL,  0);
  }
  unint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD4<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD4<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD4<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD4<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD4<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD4<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD4<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD4<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v44 = a2;
  uint64_t v4 = a1;
  uint64_t v39 = *(void *)(a3 + 16);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v42 = (char *)&v37 - v8;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  unint64_t v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v37 - v13;
  uint64_t v15 = 0LL;
  char v16 = 1;
  uint64_t v18 = v17;
  unint64_t v19 = *(void (**)(void, void, void))(v17 + 16);
  uint64_t v40 = v12;
  uint64_t v41 = v20;
  uint64_t v37 = v19;
  uint64_t v38 = v17;
  uint64_t v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      uint64_t v23 = *(const char **)(v3 + 24);
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
      uint64_t v25 = v11;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
      uint64_t v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      unint64_t v28 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      uint64_t v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      unint64_t v30 = v28;
      unint64_t v19 = v37;
      unint64_t v31 = AssociatedConformanceWitness;
      unint64_t v11 = v25;
      uint64_t v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v33 = (uint64_t)v23;
      uint64_t v4 = v40;
      unint64_t v34 = swift_getAssociatedConformanceWitness( v33,  v21,  v32,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      unint64_t v35 = swift_getAssociatedConformanceWitness( v34,  v32,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v18 = v38;
      char v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35 + 8) + 8LL))(v42, v43, v21);
    }

    else
    {
      uint64_t v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      char v16 = 0;
    }

    if (++v15 == 4) {
      break;
    }
    v19(v14, v4, v3);
  }

  return v16 & 1;
}

uint64_t SIMD4<>.init<A>(truncatingIfNeeded:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v60 = a7;
  uint64_t v55 = a4;
  uint64_t v57 = a3;
  uint64_t v58 = a8;
  uint64_t v62 = a1;
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v50 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v63 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v19 = v60;
  uint64_t v20 = v57;
  unint64_t v21 = swift_getAssociatedTypeWitness( 255LL,  v60,  v57,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v22 = swift_getAssociatedConformanceWitness( (uint64_t)v19,  v20,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v56 = *(void (**)(void, unint64_t *, unint64_t))(v22 + 56);
  uint64_t v23 = v56;
  unint64_t v52 = v22;
  unint64_t v59 = v21;
  uint64_t v24 = swift_checkMetadataState(0LL, v21);
  v23(0LL, v24, v22);
  uint64_t v25 = *(void *)(v55 + 8);
  uint64_t v55 = *(void *)(v25 + 96);
  uint64_t v26 = *(void *)(a6 + 8);
  uint64_t v53 = v25;
  uint64_t v54 = v26;
  uint64_t v27 = v13;
  unint64_t v28 = v13;
  uint64_t v29 = a2;
  ((void (*)(char *, uint64_t))v55)(v27, v20);
  unint64_t v51 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v51)(v15, 0LL, v63);
  unint64_t v30 = swift_checkMetadataState(0LL, v21);
  unint64_t v31 = v52;
  unint64_t v32 = v56;
  v56(1LL, v30, v52);
  uint64_t v34 = v54;
  uint64_t v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55;
  uint64_t v50 = v29;
  uint64_t v35 = v29;
  uint64_t v36 = v53;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v20, v54, v35, v53);
  unint64_t v37 = v63;
  uint64_t v38 = v51;
  v51(v15, 1LL, v63, AssociatedConformanceWitness);
  uint64_t v39 = swift_checkMetadataState(0LL, v59);
  v32(2LL, v39, v31);
  uint64_t v40 = v57;
  uint64_t v41 = v34;
  uint64_t v42 = v50;
  v33(v28, v57, v41, v50, v36);
  unint64_t v43 = v37;
  unint64_t v44 = AssociatedConformanceWitness;
  v38(v15, 2LL, v43, AssociatedConformanceWitness);
  uint64_t v45 = swift_checkMetadataState(0LL, v59);
  uint64_t v46 = v62;
  v56(3LL, v45, v31);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v40, v54, v42, v53);
  v38(v15, 3LL, v63, v44);
  uint64_t v48 = type metadata accessor for SIMD4(0LL, v40, (uint64_t)v60, v47);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v48 - 8) + 8LL))(v46, v48);
}

uint64_t SIMD4<>.init<A>(clamping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v60 = a7;
  uint64_t v55 = a4;
  uint64_t v57 = a3;
  uint64_t v58 = a8;
  uint64_t v62 = a1;
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v50 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v63 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v19 = v60;
  uint64_t v20 = v57;
  unint64_t v21 = swift_getAssociatedTypeWitness( 255LL,  v60,  v57,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v22 = swift_getAssociatedConformanceWitness( (uint64_t)v19,  v20,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v56 = *(void (**)(void, unint64_t *, unint64_t))(v22 + 56);
  uint64_t v23 = v56;
  unint64_t v52 = v22;
  unint64_t v59 = v21;
  uint64_t v24 = swift_checkMetadataState(0LL, v21);
  v23(0LL, v24, v22);
  uint64_t v25 = *(void *)(v55 + 8);
  uint64_t v55 = *(void *)(v25 + 104);
  uint64_t v26 = *(void *)(a6 + 8);
  uint64_t v53 = v25;
  uint64_t v54 = v26;
  uint64_t v27 = v13;
  unint64_t v28 = v13;
  uint64_t v29 = a2;
  ((void (*)(char *, uint64_t))v55)(v27, v20);
  unint64_t v51 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v51)(v15, 0LL, v63);
  unint64_t v30 = swift_checkMetadataState(0LL, v21);
  unint64_t v31 = v52;
  unint64_t v32 = v56;
  v56(1LL, v30, v52);
  uint64_t v34 = v54;
  uint64_t v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55;
  uint64_t v50 = v29;
  uint64_t v35 = v29;
  uint64_t v36 = v53;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v20, v54, v35, v53);
  unint64_t v37 = v63;
  uint64_t v38 = v51;
  v51(v15, 1LL, v63, AssociatedConformanceWitness);
  uint64_t v39 = swift_checkMetadataState(0LL, v59);
  v32(2LL, v39, v31);
  uint64_t v40 = v57;
  uint64_t v41 = v34;
  uint64_t v42 = v50;
  v33(v28, v57, v41, v50, v36);
  unint64_t v43 = v37;
  unint64_t v44 = AssociatedConformanceWitness;
  v38(v15, 2LL, v43, AssociatedConformanceWitness);
  uint64_t v45 = swift_checkMetadataState(0LL, v59);
  uint64_t v46 = v62;
  v56(3LL, v45, v31);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v40, v54, v42, v53);
  v38(v15, 3LL, v63, v44);
  uint64_t v48 = type metadata accessor for SIMD4(0LL, v40, (uint64_t)v60, v47);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v48 - 8) + 8LL))(v46, v48);
}

uint64_t SIMD4<>.init<A>(_:rounding:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v69 = a7;
  uint64_t v70 = a1;
  uint64_t v64 = a5;
  uint64_t v71 = a9;
  uint64_t v72 = a2;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v54 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v62 = (char *)&v54 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v55 = (char *)&v54 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v20,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v66 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v56 = a8;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  a8,  a4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v61 = v22;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)a8,  a4,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v24 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  unint64_t v68 = v23;
  uint64_t v25 = swift_checkMetadataState(0LL, v22);
  uint64_t v54 = v15;
  v24(0LL, v25, v23);
  uint64_t v58 = v24;
  uint64_t v26 = v69;
  uint64_t v67 = *(void *)(v69 + 16);
  unint64_t v60 = *(void (**)(uint64_t, uint64_t))(v67 + 304);
  uint64_t v27 = v62;
  v60(v72, a4);
  uint64_t v59 = *(void *)(v64 + 8);
  uint64_t v64 = *(void *)(v59 + 80);
  unint64_t v28 = v55;
  uint64_t v29 = v27;
  unint64_t v30 = v27;
  uint64_t v31 = a4;
  uint64_t v57 = a3;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t))v64)(v29, a4, v26, a3);
  unint64_t v32 = v66;
  unint64_t v63 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v63)(v28, 0LL, v66);
  uint64_t v33 = v61;
  uint64_t v34 = swift_checkMetadataState(0LL, v61);
  v24(1LL, v34, v68);
  uint64_t v35 = v72;
  uint64_t v36 = (void (*)(uint64_t, uint64_t, uint64_t))v60;
  ((void (*)(uint64_t, uint64_t, uint64_t))v60)(v72, v31, v67);
  unint64_t v37 = v30;
  uint64_t v38 = v59;
  ((void (*)(char *, uint64_t, uint64_t))v64)(v37, v31, v69);
  unint64_t v39 = v32;
  unint64_t v40 = AssociatedConformanceWitness;
  v63(v28, 1LL, v39, AssociatedConformanceWitness);
  uint64_t v41 = swift_checkMetadataState(0LL, v33);
  v58(2LL, v41, v68);
  uint64_t v42 = v62;
  v36(v35, v31, v67);
  uint64_t v43 = v69;
  uint64_t v44 = v57;
  uint64_t v45 = v38;
  uint64_t v46 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v64;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v64)(v42, v31, v69, v57, v45);
  unint64_t v47 = v40;
  uint64_t v48 = v63;
  v63(v28, 2LL, v66, v47);
  unint64_t v49 = swift_checkMetadataState(0LL, v61);
  uint64_t v50 = v70;
  v58(3LL, v49, v68);
  ((void (*)(uint64_t, uint64_t, uint64_t))v60)(v72, v31, v67);
  v46(v42, v31, v43, v44, v59);
  v48(v28, 3LL, v66, AssociatedConformanceWitness);
  uint64_t v52 = type metadata accessor for SIMD4(0LL, v31, (uint64_t)v56, v51);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v52 - 8) + 8LL))(v50, v52);
}

uint64_t SIMD4.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(swift **)(a1 + 16);
  size_t v3 = *(void *)(*((void *)v2 - 1) + 64LL);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v5 = MEMORY[0x1895F8858](v4);
  v256 = (uint64_t *)((char *)&v247 - v6);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v259 = (uint64_t *)((char *)&v247 - v8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v263 = (uint64_t *)((char *)&v247 - v10);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  unint64_t v264 = (char *)&v247 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v251 = (uint64_t *)((char *)&v247 - v14);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  v255 = (uint64_t *)((char *)&v247 - v16);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  v258 = (uint64_t *)((char *)&v247 - v18);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v262 = (uint64_t *)((char *)&v247 - v20);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v265 = (char *)&v247 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v250 = (uint64_t *)((char *)&v247 - v24);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  Swift::String v254 = (uint64_t *)((char *)&v247 - v26);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  v257 = (uint64_t *)((char *)&v247 - v28);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v261 = (uint64_t *)((char *)&v247 - v30);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v247 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  unint64_t v249 = (uint64_t *)((char *)&v247 - v35);
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  __int128 v253 = (uint64_t *)((char *)&v247 - v37);
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  unint64_t v40 = (char *)&v247 - v39;
  uint64_t v41 = MEMORY[0x1895F8858](v38);
  uint64_t v260 = (uint64_t *)((char *)&v247 - v42);
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  uint64_t v266 = (uint64_t *)((char *)&v247 - v44);
  MEMORY[0x1895F8858](v43);
  uint64_t v46 = (char *)&v247 - v45;
  unint64_t v47 = specialized static String._createEmpty(withInitialCapacity:)(25LL);
  uint64_t v51 = v48;
  unint64_t v273 = v47;
  unint64_t v274 = v48;
  uint64_t v52 = HIBYTE(v48) & 0xF;
  if ((v48 & 0x2000000000000000LL) == 0) {
    uint64_t v52 = v47 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v252 = (uint64_t *)((char *)&v247 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  if (v52 || (v47 & ~v48 & 0x2000000000000000LL) != 0)
  {
    if ((v48 & 0x2000000000000000LL) == 0
      || (unint64_t v53 = specialized _SmallString.init(_:appending:)(v47, v48, 0x3C34444D4953uLL, 0xE600000000000000LL),
          (v49 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE600000000000000LL, v48, v49, v50);
      _StringGuts.append(_:)(0x3C34444D4953LL, 0xE600000000000000LL, 0LL, 6LL);
      swift_bridgeObjectRelease_n(0xE600000000000000LL, 2LL);
    }

    else
    {
      unint64_t v54 = v53;
      unint64_t v55 = v48;
      swift_bridgeObjectRelease(v51);
      swift_bridgeObjectRelease(0xE600000000000000LL);
      unint64_t v273 = v54;
      unint64_t v274 = v55;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v48);
    unint64_t v273 = 0x3C34444D4953LL;
    unint64_t v274 = 0xE600000000000000LL;
  }

  TypeName = (uint64_t *)swift_getTypeName((unint64_t)v2, 0);
  if (v57 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v58 = (uint8x16_t *)TypeName;
  uint64_t v59 = v57;
  if (!_allASCII(_:)(TypeName, v57))
  {
    uint64_t v65 = 0LL;
    unint64_t v66 = &v58->u8[v59];
    if (!v58) {
      unint64_t v66 = 0LL;
    }
    char v60 = 1;
    for (i = v58; ; i = (uint8x16_t *)((char *)i + 3))
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            unsigned int v69 = i->u8[0];
            i = (uint8x16_t *)((char *)i + 1);
            unsigned int v68 = v69;
            if ((v68 & 0x80) != 0) {
              break;
            }
            ++v65;
          }

          if (v68 > 0xDF) {
            break;
          }
          char v60 = 0;
          i = (uint8x16_t *)((char *)i + 1);
          v65 += 2LL;
        }

        if (v68 != 224) {
          break;
        }
        if (!i) {
          goto LABEL_64;
        }
        uint64_t v70 = &i->u8[1];
        if ((i->i8[0] & 0xE0) != 0xA0) {
          goto LABEL_64;
        }
LABEL_42:
        if (v70 == v66 || (*v70 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
        char v60 = 0;
        i = (uint8x16_t *)((char *)i + 2);
        v65 += 3LL;
      }

      if (v68 <= 0xEC) {
        break;
      }
      if (v68 == 237)
      {
        if (!i) {
          goto LABEL_64;
        }
        uint64_t v70 = &i->u8[1];
        unsigned int v71 = i->u8[0];
        if (v71 > 0x9F) {
          goto LABEL_64;
        }
        goto LABEL_41;
      }

      if (v68 <= 0xEF) {
        break;
      }
      if (v68 == 240)
      {
        if (!i) {
          goto LABEL_64;
        }
        uint64_t v72 = &i->u8[1];
      }

      else
      {
        if ((v68 + 15) > 2u)
        {
          if (!i || i == (uint8x16_t *)v66 || (uint64_t v72 = &i->u8[1], v73 = i->u8[0], v73 > 0x8F))
          {
LABEL_64:
            char v74 = v46;
            size_t v75 = v2;
            uint64_t v76 = v40;
            char v77 = v33;
            uint64_t v78 = v1;
            unint64_t v79 = swift_allocError( (uint64_t)&unk_189B86A70,  (uint64_t)&protocol witness table for UTF8ValidationError,  0LL,  0);
            unint64_t v248 = (swift *)v3;
            swift_willThrow();
            uint64_t v80 = v79;
            uint64_t v1 = v78;
            uint64_t v33 = v77;
            unint64_t v40 = v76;
            uint64_t v2 = v75;
            uint64_t v46 = v74;
            swift_errorRelease(v80);
            uint64_t v81 = specialized Collection.subscript.getter(v65, (uint64_t)v58, v59);
            int64_t v85 = findInvalidRange #1 (_:) in validateUTF8(_:)(v81, v82, v83, v84);
            size_t v3 = (size_t)v248;
            unint64_t v61 = repairUTF8(_:firstKnownBrokenRange:)(v58->i8, v59, v85, v86);
            goto LABEL_65;
          }
        }

        else
        {
          uint64_t v72 = &i->u8[1];
          LOBYTE(v73) = i->i8[0];
        }

        if ((v73 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
      }

      char v60 = 0;
      v65 += 4LL;
    }

    uint64_t v70 = &i->u8[1];
    LOBYTE(v71) = i->i8[0];
LABEL_41:
    if ((v71 & 0xC0) != 0x80) {
      goto LABEL_64;
    }
    goto LABEL_42;
  }

  char v60 = 1;
LABEL_12:
  unint64_t v61 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v58, v59, v60 & 1);
LABEL_65:
  unint64_t v87 = v61;
  unint64_t v88 = v62;
  uint64_t v89 = v274;
  unint64_t v90 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000LL) == 0) {
    unint64_t v90 = v273 & 0xFFFFFFFFFFFFLL;
  }
  if (v90 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
  {
    if ((v274 & 0x2000000000000000LL) == 0)
    {
      if ((v62 & 0x2000000000000000LL) != 0)
      {
        uint64_t v91 = HIBYTE(v62) & 0xF;
LABEL_74:
        swift_bridgeObjectRetain(v88, v62, v63, v64);
        _StringGuts.append(_:)(v87, v88, 0LL, v91);
        swift_bridgeObjectRelease_n(v88, 2LL);
        unint64_t v87 = v273;
        unint64_t v88 = v274;
        goto LABEL_75;
      }

uint64_t SIMD4<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  char v60 = a7;
  uint64_t v55 = a4;
  uint64_t v57 = a3;
  uint64_t v58 = a8;
  uint64_t v62 = a1;
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v50 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v63 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v19 = v60;
  uint64_t v20 = v57;
  unint64_t v21 = swift_getAssociatedTypeWitness( 255LL,  v60,  v57,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v22 = swift_getAssociatedConformanceWitness( (uint64_t)v19,  v20,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v56 = *(void (**)(void, unint64_t *, unint64_t))(v22 + 56);
  uint64_t v23 = v56;
  unint64_t v52 = v22;
  unint64_t v59 = v21;
  uint64_t v24 = swift_checkMetadataState(0LL, v21);
  v23(0LL, v24, v22);
  uint64_t v25 = *(void *)(v55 + 16);
  uint64_t v55 = *(void *)(v25 + 72);
  uint64_t v26 = *(void *)(a6 + 8);
  uint64_t v53 = v25;
  uint64_t v54 = v26;
  uint64_t v27 = v13;
  uint64_t v28 = v13;
  uint64_t v29 = a2;
  ((void (*)(char *, uint64_t))v55)(v27, v20);
  uint64_t v51 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v51)(v15, 0LL, v63);
  uint64_t v30 = swift_checkMetadataState(0LL, v21);
  unint64_t v31 = v52;
  uint64_t v32 = v56;
  v56(1LL, v30, v52);
  uint64_t v34 = v54;
  uint64_t v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55;
  uint64_t v50 = v29;
  uint64_t v35 = v29;
  uint64_t v36 = v53;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v20, v54, v35, v53);
  unint64_t v37 = v63;
  uint64_t v38 = v51;
  v51(v15, 1LL, v63, AssociatedConformanceWitness);
  uint64_t v39 = swift_checkMetadataState(0LL, v59);
  v32(2LL, v39, v31);
  uint64_t v40 = v57;
  uint64_t v41 = v34;
  uint64_t v42 = v50;
  v33(v28, v57, v41, v50, v36);
  unint64_t v43 = v37;
  unint64_t v44 = AssociatedConformanceWitness;
  v38(v15, 2LL, v43, AssociatedConformanceWitness);
  uint64_t v45 = swift_checkMetadataState(0LL, v59);
  uint64_t v46 = v62;
  v56(3LL, v45, v31);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v40, v54, v42, v53);
  v38(v15, 3LL, v63, v44);
  uint64_t v48 = type metadata accessor for SIMD4(0LL, v40, (uint64_t)v60, v47);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v48 - 8) + 8LL))(v46, v48);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  void (*v22)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v23;
  char *v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  unint64_t v34;
  unint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  void (*v41)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(uint64_t, unint64_t *, unint64_t);
  uint64_t v49;
  char *v50;
  const char *v51;
  void (*v52)(char *, uint64_t, uint64_t, uint64_t);
  unint64_t v53;
  uint64_t v54;
  void (*v55)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t AssociatedConformanceWitness;
  unint64_t v60;
  uint64_t v61;
  unint64_t v61 = a6;
  uint64_t v57 = a1;
  uint64_t v58 = a4;
  uint64_t v54 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v50 = (char *)&v46 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v46 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  char v60 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v18 = (uint64_t)a7;
  uint64_t v51 = a7;
  uint64_t v19 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v20 = a3;
  uint64_t v49 = a3;
  unint64_t v21 = swift_getAssociatedConformanceWitness( v18,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v22 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v21 + 56);
  uint64_t v53 = v21;
  unint64_t v56 = v19;
  uint64_t v23 = swift_checkMetadataState(0LL, v19);
  uint64_t v24 = v50;
  v22(0LL, v23, v21);
  uint64_t v25 = v22;
  unint64_t v52 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v58 + 80);
  uint64_t v26 = v20;
  uint64_t v27 = v61;
  uint64_t v28 = v58;
  v52(v24, v26, v61, a2);
  uint64_t v55 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v55)(v15, 0LL, v60);
  uint64_t v29 = swift_checkMetadataState(0LL, v19);
  uint64_t v30 = v53;
  uint64_t v48 = v22;
  v22(1LL, v29, v53);
  unint64_t v31 = v49;
  uint64_t v47 = a2;
  uint64_t v32 = a2;
  uint64_t v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v52;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v52)(v24, v49, v27, v32, v28);
  uint64_t v34 = v60;
  v55(v15, 1LL, v60, AssociatedConformanceWitness);
  uint64_t v35 = swift_checkMetadataState(0LL, v56);
  uint64_t v36 = v57;
  v25(2LL, v35, v30);
  unint64_t v37 = v31;
  uint64_t v38 = v47;
  v33(v24, v31, v61, v47, v28);
  uint64_t v39 = v34;
  uint64_t v40 = AssociatedConformanceWitness;
  uint64_t v41 = v55;
  v55(v15, 2LL, v39, AssociatedConformanceWitness);
  uint64_t v42 = swift_checkMetadataState(0LL, v56);
  v48(3LL, v42, v53);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v52)(v24, v37, v61, v38, v58);
  v41(v15, 3LL, v60, v40);
  unint64_t v44 = type metadata accessor for SIMD4(0LL, v37, (uint64_t)v51, v43);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v44 - 8) + 8LL))(v36, v44);
}

uint64_t SIMD8._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage,  a2);
}

uint64_t SIMD8._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t (*SIMD8._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD8.scalarCount.getter()
{
  return 8LL;
}

uint64_t key path getter for SIMD8.subscript(_:) : <A>SIMD8<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1B7uLL,  0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(const char **)((char *)a2 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD8.subscript(_:) : <A>SIMD8<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1BBuLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD8.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1B7uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD8.init(_:_:_:_:_:_:_:_:)( const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, uint64_t a9, const char *a10)
{
  unint64_t v22 = a7;
  uint64_t v23 = a8;
  uint64_t v20 = a5;
  unint64_t v21 = a6;
  uint64_t v19 = a4;
  size_t v13 = *(void *)(*(void *)(a9 - 8) + 64LL);
  MEMORY[0x1895F8858](a1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a10,  a9,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a10,  a9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, v13);
  uint64_t v16 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), a2, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), a3, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), v19, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), 3LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), v20, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), 4LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), v21, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), 5LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), v22, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), 6LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), v23, v13);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v16)( (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL),  7LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD8.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v11 = type metadata accessor for SIMD8(0LL, a3, (uint64_t)a4, v10);
  specialized SIMD8.lowHalf.setter(a1, v11, 0LL, 1LL, 2LL, 3LL);
  uint64_t v13 = type metadata accessor for SIMD4(0LL, a3, (uint64_t)a4, v12);
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8LL);
  v15(a1, v13);
  specialized SIMD8.lowHalf.setter(a2, v11, 4LL, 5LL, 6LL, 7LL);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD8.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 0LL, 1LL, 2LL, 3LL);
}

uint64_t SIMD8.oddHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = type metadata accessor for SIMD4(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v9 - 8) + 8LL))(a1, v9);
}

uint64_t SIMD8.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 4LL, 5LL, 6LL, 7LL);
}

uint64_t SIMD8.lowHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 0LL, 1LL, 2LL, 3LL);
}

uint64_t key path getter for SIMD8.lowHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8,  SIMD8.lowHalf.getter);
}

uint64_t key path setter for SIMD8.lowHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 0LL, 1LL, 2LL, 3LL);
}

uint64_t key path setter for SIMD8.oddHalf : <A>SIMD8<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = type metadata accessor for SIMD8(0LL, *(void *)(a4 + a3 - 16), *(void *)(a4 + a3 - 8), a4);
  return specialized SIMD8.lowHalf.setter(a1, v13, a5, a6, a7, a8);
}

void (*SIMD8.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.lowHalf.getter(a2);
  return SIMD8.lowHalf.modify;
}

void SIMD8.lowHalf.modify(uint64_t **a1, char a2)
{
}

void SIMD8.oddHalf.modify(uint64_t **a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  size_t v9 = *a1;
  uint64_t v10 = (void *)(*a1)[4];
  uint64_t v11 = (void *)(*a1)[5];
  uint64_t v12 = (*a1)[2];
  uint64_t v13 = (*a1)[3];
  uint64_t v14 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v13 + 16))((*a1)[4], v11, v12);
    specialized SIMD8.lowHalf.setter((uint64_t)v10, v14, a3, a4, a5, a6);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v13 + 8);
    v15(v10, v12);
  }

  else
  {
    specialized SIMD8.lowHalf.setter((*a1)[5], v14, a3, a4, a5, a6);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v13 + 8);
  }

  v15(v11, v12);
  free(v11);
  free(v10);
  free(v9);
}

uint64_t SIMD8.highHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 4LL, 5LL, 6LL, 7LL);
}

uint64_t key path getter for SIMD8.highHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8,  SIMD8.highHalf.getter);
}

uint64_t key path setter for SIMD8.highHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 4LL, 5LL, 6LL, 7LL);
}

void (*SIMD8.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.highHalf.getter(a2);
  return SIMD8.highHalf.modify;
}

void SIMD8.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD8.evenHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 0LL, 2LL, 4LL, 6LL);
}

uint64_t key path getter for SIMD8.evenHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8,  SIMD8.evenHalf.getter);
}

uint64_t key path setter for SIMD8.evenHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 0LL, 2LL, 4LL, 6LL);
}

uint64_t SIMD8.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 0LL, 2LL, 4LL, 6LL);
}

void (*SIMD8.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.evenHalf.getter(a2);
  return SIMD8.evenHalf.modify;
}

void SIMD8.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD8.oddHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 1LL, 3LL, 5LL, 7LL);
}

uint64_t SIMD8.lowHalf.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = a4;
  uint64_t v24 = a5;
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  size_t v9 = *(const char **)(v6 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v9,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t v13 = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v5,  v12,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v13 + 56);
  uint64_t v15 = swift_checkMetadataState(0LL, v12);
  v14(v21, v15, v13);
  uint64_t v16 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v16(v8, 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_checkMetadataState(0LL, v12);
  v14(v22, v17, v13);
  v16(v8, 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = swift_checkMetadataState(0LL, v12);
  v14(v23, v18, v13);
  v16(v8, 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v19 = swift_checkMetadataState(0LL, v12);
  v14(v24, v19, v13);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v16)( v8,  3LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8,  SIMD8.oddHalf.getter);
}

uint64_t key path setter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 1LL, 3LL, 5LL, 7LL);
}

uint64_t SIMD8.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 1LL, 3LL, 5LL, 7LL);
}

void (*SIMD8.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.oddHalf.getter(a2);
  return SIMD8.oddHalf.modify;
}

void SIMD8.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD8.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD8<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD8<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>( a1,  a2,  associated type descriptor for SIMDScalar.SIMD8Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD8<A>( unint64_t a1, uint64_t a2)
{
  if (a1 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1B7uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD8<A>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1BBuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  size_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD8<A>( void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1B7uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  unint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD8<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD8<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD8<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD8<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD8<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD8<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD8<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD8<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v44 = a2;
  uint64_t v4 = a1;
  uint64_t v39 = *(void *)(a3 + 16);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  unint64_t v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v42 = (char *)&v37 - v8;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v37 - v13;
  uint64_t v15 = 0LL;
  char v16 = 1;
  uint64_t v18 = v17;
  uint64_t v19 = *(void (**)(void, void, void))(v17 + 16);
  uint64_t v40 = v12;
  uint64_t v41 = v20;
  unint64_t v37 = v19;
  uint64_t v38 = v17;
  uint64_t v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      uint64_t v23 = *(const char **)(v3 + 24);
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
      uint64_t v25 = v11;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
      uint64_t v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v28 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      uint64_t v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      uint64_t v30 = v28;
      uint64_t v19 = v37;
      unint64_t v31 = AssociatedConformanceWitness;
      uint64_t v11 = v25;
      uint64_t v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v33 = (uint64_t)v23;
      uint64_t v4 = v40;
      unint64_t v34 = swift_getAssociatedConformanceWitness( v33,  v21,  v32,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      unint64_t v35 = swift_getAssociatedConformanceWitness( v34,  v32,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v18 = v38;
      char v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35 + 8) + 8LL))(v42, v43, v21);
    }

    else
    {
      uint64_t v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      char v16 = 0;
    }

    if (++v15 == 8) {
      break;
    }
    v19(v14, v4, v3);
  }

  return v16 & 1;
}

uint64_t SIMD8<>.init<A>(truncatingIfNeeded:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 96LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 8);
  uint64_t v28 = type metadata accessor for SIMD8(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD8<>.init<A>(clamping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 104LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 8);
  uint64_t v28 = type metadata accessor for SIMD8(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD8<>.init<A>(_:rounding:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v40 = a5;
  uint64_t v41 = a7;
  uint64_t v38 = a2;
  uint64_t v44 = a1;
  uint64_t v42 = a9;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  char v16 = (char *)&v33 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v43 = associated type descriptor for SIMDScalar.SIMD8Storage;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v20,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v39 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  unint64_t v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v24 = swift_getAssociatedTypeWitness( 255LL,  a8,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  v43);
  uint64_t v34 = a8;
  unint64_t v43 = a4;
  unint64_t v36 = v24;
  unint64_t v25 = swift_getAssociatedConformanceWitness( (uint64_t)a8,  (uint64_t)a4,  v24,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v26 = 0LL;
  uint64_t v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  uint64_t v27 = v41;
  uint64_t v28 = v43;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0LL, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(void *)(v27 + 16) + 304LL))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(void *)(v40 + 8) + 80LL))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v18,  v26++,  v37,  AssociatedConformanceWitness);
  }

  while (v26 != 8);
  uint64_t v31 = type metadata accessor for SIMD8(0LL, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v31 - 8) + 8LL))(v44, v31);
}

uint64_t SIMD8.debugDescription.getter(uint64_t a1)
{
  uint64_t v437 = a1;
  uint64_t v1 = *(swift **)(a1 + 16);
  size_t v2 = *(void *)(*((void *)v1 - 1) + 64LL);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  v411 = (uint64_t *)((char *)&v403 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v4 = MEMORY[0x1895F8858](v3);
  v419 = (uint64_t *)((char *)&v403 - v5);
  uint64_t v6 = MEMORY[0x1895F8858](v4);
  v427 = (uint64_t *)((char *)&v403 - v7);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  v434 = (uint64_t *)((char *)&v403 - v9);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  v442 = (char *)&v403 - v11;
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (uint64_t *)((char *)&v403 - v13);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (uint64_t *)((char *)&v403 - v16);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  v426 = (uint64_t *)((char *)&v403 - v19);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v433 = (uint64_t *)((char *)&v403 - v21);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v441 = (char *)&v403 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v409 = (uint64_t *)((char *)&v403 - v25);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v417 = (uint64_t *)((char *)&v403 - v27);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v425 = (uint64_t *)((char *)&v403 - v29);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v432 = (uint64_t *)((char *)&v403 - v31);
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v440 = (char *)&v403 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v408 = (uint64_t *)((char *)&v403 - v35);
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v416 = (uint64_t *)((char *)&v403 - v37);
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v424 = (uint64_t *)((char *)&v403 - v39);
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v431 = (uint64_t *)((char *)&v403 - v41);
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  uint64_t v44 = (char *)&v403 - v43;
  uint64_t v45 = MEMORY[0x1895F8858](v42);
  v407 = (uint64_t *)((char *)&v403 - v46);
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  v415 = (uint64_t *)((char *)&v403 - v48);
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  v423 = (uint64_t *)((char *)&v403 - v50);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  v430 = (uint64_t *)((char *)&v403 - v52);
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  v439 = (char *)&v403 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  v406 = (uint64_t *)((char *)&v403 - v56);
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  v414 = (uint64_t *)((char *)&v403 - v58);
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  v422 = (uint64_t *)((char *)&v403 - v60);
  uint64_t v61 = MEMORY[0x1895F8858](v59);
  v429 = (uint64_t *)((char *)&v403 - v62);
  uint64_t v63 = MEMORY[0x1895F8858](v61);
  v438 = (char *)&v403 - v64;
  uint64_t v65 = MEMORY[0x1895F8858](v63);
  v405 = (uint64_t *)((char *)&v403 - v66);
  uint64_t v67 = MEMORY[0x1895F8858](v65);
  v413 = (uint64_t *)((char *)&v403 - v68);
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  v421 = (uint64_t *)((char *)&v403 - v70);
  uint64_t v71 = MEMORY[0x1895F8858](v69);
  v428 = (uint64_t *)((char *)&v403 - v72);
  uint64_t v73 = MEMORY[0x1895F8858](v71);
  v436 = (char *)&v403 - v74;
  uint64_t v75 = MEMORY[0x1895F8858](v73);
  v404 = (uint64_t *)((char *)&v403 - v76);
  uint64_t v77 = MEMORY[0x1895F8858](v75);
  v412 = (uint64_t *)((char *)&v403 - v78);
  uint64_t v79 = MEMORY[0x1895F8858](v77);
  v420 = (uint64_t *)((char *)&v403 - v80);
  uint64_t v81 = MEMORY[0x1895F8858](v79);
  uint64_t v83 = (char *)&v403 - v82;
  uint64_t v84 = MEMORY[0x1895F8858](v81);
  v443 = (uint64_t *)((char *)&v403 - v85);
  MEMORY[0x1895F8858](v84);
  unint64_t v87 = (char *)&v403 - v86;
  unint64_t v88 = specialized static String._createEmpty(withInitialCapacity:)(41LL);
  uint64_t v92 = v89;
  unint64_t v450 = v88;
  unint64_t v451 = v89;
  uint64_t v93 = HIBYTE(v89) & 0xF;
  if ((v89 & 0x2000000000000000LL) == 0) {
    uint64_t v93 = v88 & 0xFFFFFFFFFFFFLL;
  }
  v410 = v14;
  v418 = v17;
  if (v93 || (v88 & ~v89 & 0x2000000000000000LL) != 0)
  {
    if ((v89 & 0x2000000000000000LL) == 0
      || (unint64_t v94 = specialized _SmallString.init(_:appending:)(v88, v89, 0x3C38444D4953uLL, 0xE600000000000000LL),
          (v90 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE600000000000000LL, v89, v90, v91);
      _StringGuts.append(_:)(0x3C38444D4953LL, 0xE600000000000000LL, 0LL, 6LL);
      swift_bridgeObjectRelease_n(0xE600000000000000LL, 2LL);
    }

    else
    {
      unint64_t v95 = v94;
      unint64_t v96 = v89;
      swift_bridgeObjectRelease(v92);
      swift_bridgeObjectRelease(0xE600000000000000LL);
      unint64_t v450 = v95;
      unint64_t v451 = v96;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v89);
    unint64_t v450 = 0x3C38444D4953LL;
    unint64_t v451 = 0xE600000000000000LL;
  }

  TypeName = (uint64_t *)swift_getTypeName((unint64_t)v1, 0);
  if (v98 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  unsigned int v99 = (uint8x16_t *)TypeName;
  uint64_t v100 = v98;
  if (!_allASCII(_:)(TypeName, v98) && v100)
  {
    uint64_t v101 = 0LL;
    uint64_t v102 = (uint8x16_t *)((char *)v99 + v100);
    char v103 = 1;
    uint64_t v104 = v99;
    uint64_t v105 = v99;
    while (1)
    {
      int v107 = v105->i8[0];
      uint64_t v105 = (uint8x16_t *)((char *)v105 + 1);
      unsigned __int8 v106 = v107;
      if ((v107 & 0x80000000) == 0)
      {
        uint64_t v108 = 1LL;
        goto LABEL_15;
      }

      if (v106 <= 0xDFu)
      {
        if (v105 == v102 || (v105->i8[0] & 0xC0) != 0x80) {
          goto LABEL_59;
        }
        char v103 = 0;
        uint64_t v105 = (uint8x16_t *)&v104->i16[1];
        uint64_t v108 = 2LL;
      }

      else
      {
        if (v106 == 224)
        {
          if (v105 == v102
            || ((uint64_t v109 = (uint8x16_t *)&v104->i16[1], (v104->i8[1] + 64) >= 0xE0u)
              ? (BOOL v110 = v109 == v102)
              : (BOOL v110 = 1),
                v110))
          {
LABEL_59:
            uint64_t v117 = swift_allocError( (uint64_t)&unk_189B86A70,  (uint64_t)&protocol witness table for UTF8ValidationError,  0LL,  0);
            swift_willThrow();
            swift_errorRelease(v117);
            uint64_t v118 = specialized Collection.subscript.getter(v101, (uint64_t)v99, v100);
            int64_t v122 = findInvalidRange #1 (_:) in validateUTF8(_:)(v118, v119, v120, v121);
            unint64_t v113 = repairUTF8(_:firstKnownBrokenRange:)(v99->i8, v100, v122, v123);
            goto LABEL_60;
          }

          goto LABEL_40;
        }

        if (v106 <= 0xECu) {
          goto LABEL_36;
        }
        if (v106 == 237)
        {
          if (v105 == v102) {
            goto LABEL_59;
          }
          unsigned int v111 = v104->u8[1];
          if (v111 > 0x9F) {
            goto LABEL_59;
          }
LABEL_38:
          if ((v111 & 0xC0) != 0x80) {
            goto LABEL_59;
          }
          uint64_t v109 = (uint8x16_t *)&v104->i16[1];
LABEL_40:
          if ((v109->i8[0] & 0xC0) != 0x80) {
            goto LABEL_59;
          }
          char v103 = 0;
          uint64_t v105 = (uint8x16_t *)((char *)v104->i32 + 3);
          uint64_t v108 = 3LL;
          goto LABEL_15;
        }

        if (v106 <= 0xEFu)
        {
LABEL_36:
          if (v105 == v102) {
            goto LABEL_59;
          }
          LOBYTE(v111) = v104->i8[1];
          goto LABEL_38;
        }

        if (v106 == 240)
        {
        }

        else
        {
          if ((v106 + 15) > 2u)
          {
            if (v105 == v102) {
              goto LABEL_59;
            }
            unsigned int v112 = v104->u8[1];
            if (v112 > 0x8F) {
              goto LABEL_59;
            }
          }

          else
          {
            if (v105 == v102) {
              goto LABEL_59;
            }
            LOBYTE(v112) = v104->i8[1];
          }

          if ((v112 & 0xC0) != 0x80) {
            goto LABEL_59;
          }
        }

        if (&v104->i16[1] == (__int16 *)v102
          || (v104->i8[2] & 0xC0) != 0x80
          || (uint8x16_t *)((char *)v104->i32 + 3) == v102
          || (v104->i8[3] & 0xC0) != 0x80)
        {
          goto LABEL_59;
        }

        char v103 = 0;
        uint64_t v105 = (uint8x16_t *)((char *)v104->i64 + 4);
        uint64_t v108 = 4LL;
      }

uint64_t SIMD8<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 16) + 72LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 8);
  uint64_t v28 = type metadata accessor for SIMD8(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v31 = a7;
  uint64_t v34 = a6;
  uint64_t v35 = a8;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v36 = a3;
  unint64_t v32 = v22;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v33,  AssociatedConformanceWitness);
  }

  while (v24 != 8);
  uint64_t v28 = type metadata accessor for SIMD8(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD16._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage,  a2);
}

uint64_t SIMD16._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t (*SIMD16._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD16.scalarCount.getter()
{
  return 16LL;
}

uint64_t key path getter for SIMD16.subscript(_:) : <A>SIMD16<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x27FuLL,  0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(const char **)((char *)a2 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD16.subscript(_:) : <A>SIMD16<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x283uLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD16.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x27FuLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD16.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)( const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, uint64_t a17, const char *a18)
{
  uint64_t v31 = a8;
  uint64_t v28 = a6;
  uint64_t v29 = a7;
  uint64_t v26 = a4;
  uint64_t v27 = a5;
  uint64_t v37 = a15;
  uint64_t v38 = a16;
  uint64_t v35 = a13;
  uint64_t v36 = a14;
  uint64_t v33 = a11;
  uint64_t v34 = a12;
  unint64_t v32 = a10;
  uint64_t v30 = a9;
  size_t v21 = *(void *)(*(void *)(a17 - 8) + 64LL);
  MEMORY[0x1895F8858](a1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a18,  a17,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a18,  a17,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, v21);
  uint64_t v24 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), a2, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), a3, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v26, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 3LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v27, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 4LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v28, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 5LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v29, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 6LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v31, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 7LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v30, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 8LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v32, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 9LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v33, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 10LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v34, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 11LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v35, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 12LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v36, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 13LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v37, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), 14LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL), v38, v21);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v24)( (char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL),  15LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD16.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v11 = type metadata accessor for SIMD16(0LL, a3, (uint64_t)a4, v10);
  specialized SIMD16.lowHalf.setter(a1, v11);
  uint64_t v13 = type metadata accessor for SIMD8(0LL, a3, (uint64_t)a4, v12);
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8LL);
  v15(a1, v13);
  specialized SIMD16.highHalf.setter(a2, v11);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD16.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD16.lowHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

uint64_t SIMD64.oddHalf.setter( uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t (*a4)(void, void, void))
{
  uint64_t v7 = a4(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8LL))(a1, v7);
}

uint64_t SIMD16.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD16.highHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

uint64_t SIMD16.lowHalf.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v21 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = *(const char **)(v2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t v9 = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  uint64_t v11 = swift_checkMetadataState(0LL, v8);
  v10(0LL, v11, v9);
  uint64_t v12 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v12(v4, 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v13 = swift_checkMetadataState(0LL, v8);
  v10(1LL, v13, v9);
  v12(v4, 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v14 = swift_checkMetadataState(0LL, v8);
  v10(2LL, v14, v9);
  v12(v4, 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v15 = swift_checkMetadataState(0LL, v8);
  v10(3LL, v15, v9);
  v12(v4, 3LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v16 = swift_checkMetadataState(0LL, v8);
  v10(4LL, v16, v9);
  v12(v4, 4LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_checkMetadataState(0LL, v8);
  v10(5LL, v17, v9);
  v12(v4, 5LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = swift_checkMetadataState(0LL, v8);
  v10(6LL, v18, v9);
  v12(v4, 6LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v19 = swift_checkMetadataState(0LL, v8);
  v10(7LL, v19, v9);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v12)( v4,  7LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD16.lowHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  SIMD16.lowHalf.getter);
}

uint64_t key path setter for SIMD16.lowHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  specialized SIMD16.lowHalf.setter);
}

uint64_t key path setter for SIMD64.oddHalf : <A>SIMD64<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void), uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v8 = a5(0LL, *(void *)(a4 + a3 - 16), *(void *)(a4 + a3 - 8));
  return a6(a1, v8);
}

void (*SIMD16.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD16.lowHalf.getter(a2);
  return SIMD16.lowHalf.modify;
}

void SIMD16.lowHalf.modify(uint64_t **a1, char a2)
{
}

void SIMD64.oddHalf.modify(uint64_t **a1, char a2, void (*a3)(void *, uint64_t))
{
  uint64_t v4 = *a1;
  uint64_t v5 = (void *)(*a1)[4];
  uint64_t v6 = (void *)(*a1)[5];
  uint64_t v7 = (*a1)[2];
  uint64_t v8 = (*a1)[3];
  uint64_t v9 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[4], v6, v7);
    a3(v5, v9);
    uint64_t v10 = *(void (**)(void *, uint64_t))(v8 + 8);
    v10(v5, v7);
  }

  else
  {
    a3((void *)(*a1)[5], v9);
    uint64_t v10 = *(void (**)(void *, uint64_t))(v8 + 8);
  }

  v10(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

uint64_t SIMD16.highHalf.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v21 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = *(const char **)(v2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t v9 = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  uint64_t v11 = swift_checkMetadataState(0LL, v8);
  v10(8LL, v11, v9);
  uint64_t v12 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v12(v4, 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v13 = swift_checkMetadataState(0LL, v8);
  v10(9LL, v13, v9);
  v12(v4, 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v14 = swift_checkMetadataState(0LL, v8);
  v10(10LL, v14, v9);
  v12(v4, 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v15 = swift_checkMetadataState(0LL, v8);
  v10(11LL, v15, v9);
  v12(v4, 3LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v16 = swift_checkMetadataState(0LL, v8);
  v10(12LL, v16, v9);
  v12(v4, 4LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_checkMetadataState(0LL, v8);
  v10(13LL, v17, v9);
  v12(v4, 5LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = swift_checkMetadataState(0LL, v8);
  v10(14LL, v18, v9);
  v12(v4, 6LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v19 = swift_checkMetadataState(0LL, v8);
  v10(15LL, v19, v9);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v12)( v4,  7LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD16.highHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  SIMD16.highHalf.getter);
}

uint64_t key path setter for SIMD16.highHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  specialized SIMD16.highHalf.setter);
}

void (*SIMD16.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD16.highHalf.getter(a2);
  return SIMD16.highHalf.modify;
}

void SIMD16.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD16.evenHalf.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v21 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = *(const char **)(v2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t v9 = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  uint64_t v11 = swift_checkMetadataState(0LL, v8);
  v10(0LL, v11, v9);
  uint64_t v12 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v12(v4, 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v13 = swift_checkMetadataState(0LL, v8);
  v10(2LL, v13, v9);
  v12(v4, 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v14 = swift_checkMetadataState(0LL, v8);
  v10(4LL, v14, v9);
  v12(v4, 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v15 = swift_checkMetadataState(0LL, v8);
  v10(6LL, v15, v9);
  v12(v4, 3LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v16 = swift_checkMetadataState(0LL, v8);
  v10(8LL, v16, v9);
  v12(v4, 4LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_checkMetadataState(0LL, v8);
  v10(10LL, v17, v9);
  v12(v4, 5LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = swift_checkMetadataState(0LL, v8);
  v10(12LL, v18, v9);
  v12(v4, 6LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v19 = swift_checkMetadataState(0LL, v8);
  v10(14LL, v19, v9);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v12)( v4,  7LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD16.evenHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  SIMD16.evenHalf.getter);
}

uint64_t key path setter for SIMD16.evenHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  specialized SIMD16.evenHalf.setter);
}

uint64_t SIMD16.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD16.evenHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

void (*SIMD16.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD16.evenHalf.getter(a2);
  return SIMD16.evenHalf.modify;
}

void SIMD16.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD16.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(const char **)(v4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v13 = 0LL;
  uint64_t v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  uint64_t v15 = 1LL;
  do
  {
    uint64_t v16 = swift_checkMetadataState(0LL, v11);
    v14(v15, v16, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v6,  v13,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    v15 += 2LL;
    ++v13;
  }

  while (v13 != 8);
  return result;
}

uint64_t key path getter for SIMD16.oddHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  (uint64_t (*)(uint64_t))SIMD16.oddHalf.getter);
}

uint64_t key path setter for SIMD16.oddHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16,  specialized SIMD16.oddHalf.setter);
}

uint64_t SIMD16.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD16.oddHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

void (*SIMD16.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD16.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD16.oddHalf.modify;
}

void SIMD16.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD16.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD16<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD16<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>( a1,  a2,  associated type descriptor for SIMDScalar.SIMD16Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD16<A>( unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x27FuLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD16<A>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x283uLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  unint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  size_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD16<A>( void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x27FuLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD16<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD16<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD16<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD16<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD16<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v41 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v40 = (char *)&v36 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v45 = (char *)&v36 - v9;
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v12 = (char *)&v36 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v36 - v14;
  uint64_t v16 = 0LL;
  char v17 = 1;
  uint64_t v42 = v18;
  uint64_t v43 = v19;
  uint64_t v20 = *(void (**)(void, void, void))(v19 + 16);
  uint64_t v38 = (char *)&v36 - v14;
  uint64_t v39 = v13;
  uint64_t v44 = v12;
  uint64_t v37 = v20;
  uint64_t v21 = v41;
  v20((char *)&v36 - v14, v5, v3);
  while (1)
  {
    v20(v12, a2, v3);
    if ((v17 & 1) != 0)
    {
      unint64_t v23 = *(const char **)(v3 + 24);
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v26 = v3;
      uint64_t v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v28 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v27(v16, v28, AssociatedConformanceWitness);
      uint64_t v29 = *(void (**)(char *, uint64_t))(v43 + 8);
      v29(v15, v26);
      uint64_t v30 = v40;
      v27(v16, v28, AssociatedConformanceWitness);
      uint64_t v3 = v26;
      unint64_t v12 = v44;
      v29(v44, v3);
      uint64_t v20 = v37;
      uint64_t v31 = AssociatedConformanceWitness;
      uint64_t v5 = v39;
      uint64_t v32 = (uint64_t)v28;
      a2 = v42;
      unint64_t v33 = swift_getAssociatedConformanceWitness( v31,  v32,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v34 = v30;
      uint64_t v15 = v38;
      char v17 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33 + 8) + 8LL))(v45, v34, v21);
    }

    else
    {
      unint64_t v22 = *(void (**)(char *, uint64_t))(v43 + 8);
      v22(v12, v3);
      v22(v15, v3);
      char v17 = 0;
    }

    if (++v16 == 16) {
      break;
    }
    v20(v15, v5, v3);
  }

  return v17 & 1;
}

uint64_t SIMD16<>.init<A>(truncatingIfNeeded:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 96LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 16);
  uint64_t v28 = type metadata accessor for SIMD16(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD16<>.init<A>(clamping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 104LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 16);
  uint64_t v28 = type metadata accessor for SIMD16(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD16<>.init<A>(_:rounding:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v40 = a5;
  uint64_t v41 = a7;
  uint64_t v38 = a2;
  uint64_t v44 = a1;
  uint64_t v42 = a9;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v33 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v43 = associated type descriptor for SIMDScalar.SIMD16Storage;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v20,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v39 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  unint64_t v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v24 = swift_getAssociatedTypeWitness( 255LL,  a8,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  v43);
  uint64_t v34 = a8;
  uint64_t v43 = a4;
  unint64_t v36 = v24;
  unint64_t v25 = swift_getAssociatedConformanceWitness( (uint64_t)a8,  (uint64_t)a4,  v24,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v26 = 0LL;
  uint64_t v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  uint64_t v27 = v41;
  uint64_t v28 = v43;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0LL, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(void *)(v27 + 16) + 304LL))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(void *)(v40 + 8) + 80LL))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v18,  v26++,  v37,  AssociatedConformanceWitness);
  }

  while (v26 != 16);
  uint64_t v31 = type metadata accessor for SIMD16(0LL, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v31 - 8) + 8LL))(v44, v31);
}

unint64_t SIMD16.debugDescription.getter(uint64_t a1)
{
  v558 = (unint64_t *)a1;
  uint64_t v1 = *(swift **)(a1 + 16);
  size_t v2 = *(void *)(*((void *)v1 - 1) + 64LL);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = MEMORY[0x1895F8858](v3);
  uint64_t v6 = (uint64_t *)((char *)&v511 - v5);
  uint64_t v7 = MEMORY[0x1895F8858](v4);
  v539 = (uint64_t *)((char *)&v511 - v8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  v548 = (uint64_t *)((char *)&v511 - v10);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  v557 = (char *)&v511 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  v520 = (uint64_t *)((char *)&v511 - v14);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  v530 = (uint64_t *)((char *)&v511 - v16);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  v538 = (uint64_t *)((char *)&v511 - v18);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  v547 = (uint64_t *)((char *)&v511 - v20);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  v556 = (char *)&v511 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  v519 = (uint64_t *)((char *)&v511 - v24);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  v529 = (uint64_t *)((char *)&v511 - v26);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  v537 = (uint64_t *)((char *)&v511 - v28);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  v546 = (uint64_t *)((char *)&v511 - v30);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  v555 = (char *)&v511 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  v518 = (uint64_t *)((char *)&v511 - v34);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  v528 = (uint64_t *)((char *)&v511 - v36);
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  v536 = (uint64_t *)((char *)&v511 - v38);
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  v545 = (uint64_t *)((char *)&v511 - v40);
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  v554 = (char *)&v511 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  v517 = (uint64_t *)((char *)&v511 - v44);
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  v527 = (uint64_t *)((char *)&v511 - v46);
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  v535 = (uint64_t *)((char *)&v511 - v48);
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  v544 = (uint64_t *)((char *)&v511 - v50);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  v553 = (char *)&v511 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  v516 = (uint64_t *)((char *)&v511 - v54);
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  v526 = (uint64_t *)((char *)&v511 - v56);
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  v534 = (uint64_t *)((char *)&v511 - v58);
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  v543 = (uint64_t *)((char *)&v511 - v60);
  uint64_t v61 = MEMORY[0x1895F8858](v59);
  v552 = (char *)&v511 - v62;
  uint64_t v63 = MEMORY[0x1895F8858](v61);
  v515 = (uint64_t *)((char *)&v511 - v64);
  uint64_t v65 = MEMORY[0x1895F8858](v63);
  v525 = (uint64_t *)((char *)&v511 - v66);
  uint64_t v67 = MEMORY[0x1895F8858](v65);
  v533 = (uint64_t *)((char *)&v511 - v68);
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  v542 = (uint64_t *)((char *)&v511 - v70);
  uint64_t v71 = MEMORY[0x1895F8858](v69);
  v551 = (char *)&v511 - v72;
  uint64_t v73 = MEMORY[0x1895F8858](v71);
  v514 = (uint64_t *)((char *)&v511 - v74);
  uint64_t v75 = MEMORY[0x1895F8858](v73);
  v524 = (uint64_t *)((char *)&v511 - v76);
  uint64_t v77 = MEMORY[0x1895F8858](v75);
  v532 = (uint64_t *)((char *)&v511 - v78);
  uint64_t v79 = MEMORY[0x1895F8858](v77);
  v541 = (uint64_t *)((char *)&v511 - v80);
  uint64_t v81 = MEMORY[0x1895F8858](v79);
  v550 = (char *)&v511 - v82;
  uint64_t v83 = MEMORY[0x1895F8858](v81);
  v513 = (uint64_t *)((char *)&v511 - v84);
  uint64_t v85 = MEMORY[0x1895F8858](v83);
  v523 = (uint64_t *)((char *)&v511 - v86);
  uint64_t v87 = MEMORY[0x1895F8858](v85);
  v531 = (uint64_t *)((char *)&v511 - v88);
  uint64_t v89 = MEMORY[0x1895F8858](v87);
  v540 = (uint64_t *)((char *)&v511 - v90);
  uint64_t v91 = MEMORY[0x1895F8858](v89);
  v549 = (char *)&v511 - v92;
  uint64_t v93 = MEMORY[0x1895F8858](v91);
  v512 = (uint64_t *)((char *)&v511 - v94);
  uint64_t v95 = MEMORY[0x1895F8858](v93);
  v522 = (uint64_t *)((char *)&v511 - v96);
  uint64_t v97 = MEMORY[0x1895F8858](v95);
  unsigned int v99 = (char *)&v511 - v98;
  uint64_t v100 = MEMORY[0x1895F8858](v97);
  uint64_t v102 = (char *)&v511 - v101;
  uint64_t v103 = MEMORY[0x1895F8858](v100);
  v559 = (uint64_t *)((char *)&v511 - v104);
  MEMORY[0x1895F8858](v103);
  unsigned __int8 v106 = (char *)&v511 - v105;
  unint64_t v107 = specialized static String._createEmpty(withInitialCapacity:)(74LL);
  uint64_t v109 = v108;
  unint64_t v566 = v107;
  unint64_t v567 = v108;
  uint64_t v110 = HIBYTE(v108) & 0xF;
  if ((v108 & 0x2000000000000000LL) == 0) {
    uint64_t v110 = v107 & 0xFFFFFFFFFFFFLL;
  }
  if (v110 || (v107 & ~v108 & 0x2000000000000000LL) != 0)
  {
    if ((v108 & 0x2000000000000000LL) == 0
      || (unint64_t v111 = specialized _SmallString.init(_:appending:)(v107, v108, 0x3C3631444D4953uLL, 0xE700000000000000LL),
          (v113 & 1) != 0))
    {
      _StringGuts.append(_:)(0x3C3631444D4953LL, 0xE700000000000000LL, 0LL, 7LL);
    }

    else
    {
      unint64_t v114 = v111;
      unint64_t v115 = v112;
      swift_bridgeObjectRelease(v109);
      unint64_t v566 = v114;
      unint64_t v567 = v115;
    }

    uint64_t v116 = 0xE700000000000000LL;
  }

  else
  {
    unint64_t v566 = 0x3C3631444D4953LL;
    unint64_t v567 = 0xE700000000000000LL;
    uint64_t v116 = v108;
  }

  swift_bridgeObjectRelease(v116);
  TypeName = (uint64_t *)swift_getTypeName((unint64_t)v1, 0);
  if (v118 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v119 = (uint8x16_t *)TypeName;
  int64_t v120 = v118;
  v521 = v6;
  v511 = (uint64_t *)((char *)&v511 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  int64_t v121 = validateUTF8(_:)(TypeName, v118);
  if ((v123 & 1) != 0) {
    unint64_t v124 = repairUTF8(_:firstKnownBrokenRange:)(v119->i8, v120, v121, v122);
  }
  else {
    unint64_t v124 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v119, v120, v121 & 1);
  }
  unint64_t v126 = v124;
  unint64_t v127 = v125;
  uint64_t v128 = v567;
  unint64_t v129 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    unint64_t v129 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v129 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    if ((v567 & 0x2000000000000000LL) != 0)
    {
      if ((v125 & 0x2000000000000000LL) != 0)
      {
        unint64_t v131 = specialized _SmallString.init(_:appending:)(v566, v567, v124, v125);
        if ((v133 & 1) == 0)
        {
          unint64_t v134 = v131;
          unint64_t v135 = v132;
          swift_bridgeObjectRelease(v128);
          unint64_t v566 = v134;
          unint64_t v567 = v135;
          swift_bridgeObjectRelease(v127);
          unint64_t v127 = v135;
          unint64_t v126 = v134;
          goto LABEL_27;
        }

        goto LABEL_25;
      }
    }

    else if ((v125 & 0x2000000000000000LL) != 0)
    {
LABEL_25:
      uint64_t v130 = HIBYTE(v127) & 0xF;
      goto LABEL_26;
    }

    uint64_t v130 = v124 & 0xFFFFFFFFFFFFLL;
LABEL_26:
    _StringGuts.append(_:)(v126, v127, 0LL, v130);
    swift_bridgeObjectRelease(v127);
    unint64_t v126 = v566;
    unint64_t v127 = v567;
    goto LABEL_27;
  }

  unint64_t v566 = v124;
  unint64_t v567 = v125;
  swift_bridgeObjectRelease(v128);
LABEL_27:
  uint64_t v136 = HIBYTE(v127) & 0xF;
  if ((v127 & 0x2000000000000000LL) == 0) {
    uint64_t v136 = v126 & 0xFFFFFFFFFFFFLL;
  }
  if (v136 || (v126 & ~v127 & 0x2000000000000000LL) != 0)
  {
    if ((v127 & 0x2000000000000000LL) == 0
      || (unint64_t v137 = specialized _SmallString.init(_:appending:)(v126, v127, 0x283EuLL, 0xE200000000000000LL),
          (v139 & 1) != 0))
    {
      _StringGuts.append(_:)(10302LL, 0xE200000000000000LL, 0LL, 2LL);
    }

    else
    {
      unint64_t v140 = v137;
      unint64_t v141 = v138;
      swift_bridgeObjectRelease(v127);
      unint64_t v566 = v140;
      unint64_t v567 = v141;
    }

    uint64_t v142 = 0xE200000000000000LL;
  }

  else
  {
    unint64_t v566 = 10302LL;
    unint64_t v567 = 0xE200000000000000LL;
    uint64_t v142 = v127;
  }

  swift_bridgeObjectRelease(v142);
  int8x16_t v143 = (const char *)v558[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v143,  (uint64_t)v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v143,  (uint64_t)v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v146 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v558 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  ((void (*)(void))v146)(0LL);
  v561 = (uint64_t *)v1;
  uint32x4_t v147 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v147, v106, v2);
  uint64x2_t v148 = v561;
  uint64_t v149 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  DynamicType = (void *)swift_getDynamicType(v149, v148, 1);
  LODWORD(v148) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if (!(_DWORD)v148)
  {
    memcpy(v102, v106, v2);
    if ((swift_dynamicCast((char *)&v560, (uint64_t *)v102, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
    {
      unint64_t countAndFlagsBits = v560._countAndFlagsBits;
      unint64_t object = (unint64_t)v560._object;
      uint64_t v169 = v567;
      unint64_t v170 = HIBYTE(v567) & 0xF;
      if ((v567 & 0x2000000000000000LL) == 0) {
        unint64_t v170 = v566 & 0xFFFFFFFFFFFFLL;
      }
      uint64x2_t v162 = v558;
      if (!v170 && (v566 & ~v567 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRetain((unint64_t)v560._object, v164, v165, v166);
        swift_bridgeObjectRelease(v169);
        unint64_t v566 = countAndFlagsBits;
        unint64_t v567 = object;
        swift_bridgeObjectRelease(object);
        uint64_t v151 = v559;
        goto LABEL_90;
      }

      uint64_t v151 = v559;
      if ((v567 & 0x2000000000000000LL) == 0)
      {
        if (((uint64_t)v560._object & 0x2000000000000000LL) != 0)
        {
          uint64_t v171 = ((unint64_t)v560._object >> 56) & 0xF;
LABEL_85:
          _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v171);
          swift_bridgeObjectRelease(object);
          goto LABEL_90;
        }

LABEL_158:
  uint64_t v288 = v567;
  unint64_t v289 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    unint64_t v289 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v289 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    if ((v567 & 0x2000000000000000LL) == 0
      || (unint64_t v290 = specialized _SmallString.init(_:appending:)(v566, v567, 0x202CuLL, 0xE200000000000000LL),
          (v292 & 1) != 0))
    {
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
    }

    else
    {
      unint64_t v293 = v290;
      unint64_t v294 = v291;
      swift_bridgeObjectRelease(v288);
      unint64_t v566 = v293;
      unint64_t v567 = v294;
    }

    uint64_t v295 = 0xE200000000000000LL;
  }

  else
  {
    unint64_t v566 = 8236LL;
    unint64_t v567 = 0xE200000000000000LL;
    uint64_t v295 = v288;
  }

  swift_bridgeObjectRelease(v295);
  unint64_t v296 = v551;
  v146(3LL, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  unint64_t v297 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v297, v296, v2);
  v298 = v561;
  v299 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  uint64_t v300 = (void *)swift_getDynamicType(v299, v298, 1);
  LODWORD(v298) = swift_isOptionalType(v300);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v298)
  {
    memcpy(v151, v296, v2);
    uint64_t v301 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v301, 7uLL);
LABEL_169:
    uint64_t v302 = (uint64_t)v561;
    uint64_t v303 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    unint64_t v304 = (*(uint64_t (**)(uint64_t, uint64_t))(v303 + 8))(v302, v303);
    uint64_t v306 = v305;
    specialized String.write<A>(to:)(&v566, v304, v305, v307);
    swift_bridgeObjectRelease(v306);
LABEL_170:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_173;
  }

  uint64_t v308 = v542;
  memcpy(v542, v296, v2);
  if ((swift_dynamicCast((char *)&v560, v308, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v309 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v309);
  }

  else
  {
    v418 = v533;
    memcpy(v533, v296, v2);
    v419 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v418, v1, v419, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      uint64_t v420 = (uint64_t)v561;
      uint64_t v421 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v421 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v420,  v421);
      goto LABEL_170;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v456 = v525;
    memcpy(v525, v296, v2);
    v457 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v456, v1, v457, 6uLL)
      || (uint64_t v565 = 0LL,
          __int128 v563 = 0u,
          __int128 v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  v458 = v515,  memcpy(v515, v296, v2),  v459 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v458, v1, v459, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_169;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v490 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v490, v296, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v491 = v560._object;
    uint64_t v492 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v296,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v492);
    swift_release((uint64_t)v491);
  }

LABEL_173:
  v310 = v552;
  uint64_t v311 = v567;
  unint64_t v312 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    unint64_t v312 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v312 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    uint64_t v311 = 0xE200000000000000LL;
  }

  else
  {
    unint64_t v566 = 8236LL;
    unint64_t v567 = 0xE200000000000000LL;
  }

  swift_bridgeObjectRelease(v311);
  v146(4LL, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v313 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v313, v310, v2);
  size_t v314 = v561;
  char v315 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  unint64_t v316 = (void *)swift_getDynamicType(v315, v314, 1);
  LODWORD(v314) = swift_isOptionalType(v316);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v314)
  {
    memcpy(v151, v310, v2);
    unint64_t v317 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v317, 7uLL);
LABEL_180:
    uint64_t v318 = (uint64_t)v561;
    uint64_t v319 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    unint64_t v320 = (*(uint64_t (**)(uint64_t, uint64_t))(v319 + 8))(v318, v319);
    uint64_t v322 = v321;
    specialized String.write<A>(to:)(&v566, v320, v321, v323);
    swift_bridgeObjectRelease(v322);
LABEL_181:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_184;
  }

  unint64_t v324 = v543;
  memcpy(v543, v310, v2);
  if ((swift_dynamicCast((char *)&v560, v324, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    unint64_t v325 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v325);
  }

  else
  {
    v422 = v534;
    memcpy(v534, v310, v2);
    v423 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v422, v1, v423, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      uint64_t v424 = (uint64_t)v561;
      uint64_t v425 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v425 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v424,  v425);
      goto LABEL_181;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v460 = v526;
    memcpy(v526, v310, v2);
    v461 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v460, v1, v461, 6uLL)
      || (uint64_t v565 = 0LL,
          __int128 v563 = 0u,
          __int128 v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  v462 = v516,  memcpy(v516, v310, v2),  v463 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v462, v1, v463, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_180;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v493 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v493, v310, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v494 = v560._object;
    uint64_t v495 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v310,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v495);
    swift_release((uint64_t)v494);
  }

LABEL_195:
  v342 = v554;
  uint64_t v343 = v567;
  unint64_t v344 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    unint64_t v344 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v344 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    uint64_t v343 = 0xE200000000000000LL;
  }

  else
  {
    unint64_t v566 = 8236LL;
    unint64_t v567 = 0xE200000000000000LL;
  }

  swift_bridgeObjectRelease(v343);
  v146(6LL, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v345 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v345, v342, v2);
  v346 = v561;
  uint64_t v347 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  uint64_t v348 = (void *)swift_getDynamicType(v347, v346, 1);
  LODWORD(v346) = swift_isOptionalType(v348);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v346)
  {
    memcpy(v151, v342, v2);
    v349 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v349, 7uLL);
LABEL_202:
    uint64_t v350 = (uint64_t)v561;
    uint64_t v351 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    unint64_t v352 = (*(uint64_t (**)(uint64_t, uint64_t))(v351 + 8))(v350, v351);
    uint64_t v354 = v353;
    specialized String.write<A>(to:)(&v566, v352, v353, v355);
    swift_bridgeObjectRelease(v354);
LABEL_203:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_206;
  }

  unint64_t v356 = v545;
  memcpy(v545, v342, v2);
  if ((swift_dynamicCast((char *)&v560, v356, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    unint64_t v357 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v357);
  }

  else
  {
    v430 = v536;
    memcpy(v536, v342, v2);
    v431 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v430, v1, v431, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      uint64_t v432 = (uint64_t)v561;
      uint64_t v433 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v433 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v432,  v433);
      goto LABEL_203;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v468 = v528;
    memcpy(v528, v342, v2);
    v469 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v468, v1, v469, 6uLL)
      || (uint64_t v565 = 0LL,
          __int128 v563 = 0u,
          __int128 v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  v470 = v518,  memcpy(v518, v342, v2),  v471 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v470, v1, v471, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_202;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v499 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v499, v342, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v500 = v560._object;
    uint64_t v501 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v342,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v501);
    swift_release((uint64_t)v500);
  }

                LOBYTE(v24) = 1;
                goto LABEL_67;
              }

              goto LABEL_230;
          }

          goto LABEL_230;
        }

        if (v13 < 0xA)
        {
          LOBYTE(v24) = 14;
          uint64_t v25 = 14;
          goto LABEL_67;
        }

        if (v13 < 0xE || v13 == 133) {
          goto LABEL_281;
        }
        if (v13 >> 3 > 0x404)
        {
          if (v13 < 0x202A) {
            goto LABEL_281;
          }
          uint64_t v25 = 14;
          if (v13 - 127488 >= 0xFFFFFFE6) {
            goto LABEL_226;
          }
        }

        else
        {
          uint64_t v25 = 14;
          switch(v13)
          {
            case 0x22u:
              goto LABEL_37;
            case 0x27u:
              goto LABEL_230;
            case 0x200Du:
              uint64_t v18 = 14;
              goto LABEL_9;
          }
        }

        LOBYTE(v24) = 14;
        goto LABEL_67;
    }

LABEL_206:
  v358 = v555;
  uint64_t v359 = v567;
  unint64_t v360 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    unint64_t v360 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v360 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    uint64_t v359 = 0xE200000000000000LL;
  }

  else
  {
    unint64_t v566 = 8236LL;
    unint64_t v567 = 0xE200000000000000LL;
  }

  swift_bridgeObjectRelease(v359);
  v146(7LL, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v361 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v361, v358, v2);
  v362 = v561;
  v363 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v364 = (void *)swift_getDynamicType(v363, v362, 1);
  LODWORD(v362) = swift_isOptionalType(v364);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v362)
  {
    memcpy(v151, v358, v2);
    v365 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v365, 7uLL);
LABEL_213:
    uint64_t v366 = (uint64_t)v561;
    uint64_t v367 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    unint64_t v368 = (*(uint64_t (**)(uint64_t, uint64_t))(v367 + 8))(v366, v367);
    uint64_t v370 = v369;
    specialized String.write<A>(to:)(&v566, v368, v369, v371);
    swift_bridgeObjectRelease(v370);
LABEL_214:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_217;
  }

  v372 = v546;
  memcpy(v546, v358, v2);
  if ((swift_dynamicCast((char *)&v560, v372, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v373 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v373);
  }

  else
  {
    v434 = v537;
    memcpy(v537, v358, v2);
    v435 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v434, v1, v435, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      uint64_t v436 = (uint64_t)v561;
      uint64_t v437 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v437 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v436,  v437);
      goto LABEL_214;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v472 = v529;
    memcpy(v529, v358, v2);
    v473 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v472, v1, v473, 6uLL)
      || (uint64_t v565 = 0LL,
          __int128 v563 = 0u,
          __int128 v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  v474 = v519,  memcpy(v519, v358, v2),  v475 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v474, v1, v475, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_213;
    }

    uint64_t v565 = 0LL;
    __int128 v563 = 0u;
    __int128 v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v502 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v502, v358, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v503 = v560._object;
    uint64_t v504 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v358,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v504);
    swift_release((uint64_t)v503);
  }

uint64_t SIMD16<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 16) + 72LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 16);
  uint64_t v28 = type metadata accessor for SIMD16(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v31 = a7;
  uint64_t v34 = a6;
  uint64_t v35 = a8;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v36 = a3;
  unint64_t v32 = v22;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v33,  AssociatedConformanceWitness);
  }

  while (v24 != 16);
  uint64_t v28 = type metadata accessor for SIMD16(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD32._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage,  a2);
}

uint64_t SIMD32._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t (*SIMD32._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD32.scalarCount.getter()
{
  return 32LL;
}

uint64_t key path getter for SIMD32.subscript(_:) : <A>SIMD32<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x357uLL,  0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(const char **)((char *)a2 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD32.subscript(_:) : <A>SIMD32<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x35BuLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD32.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x357uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD32.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)( const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, const void *a17, const void *a18, const void *a19, const void *a20, const void *a21, const void *a22, const void *a23, const void *a24, const void *a25, const void *a26, const void *a27, const void *a28, const void *a29, const void *a30, const void *a31, const void *a32, uint64_t a33, const char *a34)
{
  uint64_t v53 = a8;
  uint64_t v51 = a7;
  uint64_t v49 = a6;
  uint64_t v48 = a5;
  uint64_t v47 = a4;
  uint64_t v75 = a31;
  uint64_t v76 = a32;
  uint64_t v74 = a30;
  uint64_t v71 = a28;
  uint64_t v72 = a29;
  uint64_t v69 = a26;
  uint64_t v70 = a27;
  uint64_t v67 = a24;
  uint64_t v68 = a25;
  uint64_t v65 = a22;
  uint64_t v66 = a23;
  uint64_t v63 = a20;
  uint64_t v64 = a21;
  uint64_t v61 = a18;
  uint64_t v62 = a19;
  uint64_t v59 = a16;
  uint64_t v60 = a17;
  size_t v37 = *(void *)(*(void *)(a33 - 8) + 64LL);
  uint64_t v57 = a14;
  uint64_t v58 = a15;
  uint64_t v56 = a13;
  uint64_t v55 = a12;
  uint64_t v54 = a11;
  uint64_t v52 = a10;
  uint64_t v50 = a9;
  uint64_t v38 = MEMORY[0x1895F8858](a1);
  uint64_t v73 = (char *)&v46 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v38);
  uint64_t v40 = (char *)&v46 - v39;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a34,  a33,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a34,  a33,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  memcpy(v40, a1, v37);
  uint64_t v43 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v43(v40, 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a2, v37);
  v43(v40, 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a3, v37);
  v43(v40, 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v47, v37);
  v43(v40, 3LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v48, v37);
  v43(v40, 4LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v49, v37);
  v43(v40, 5LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v51, v37);
  v43(v40, 6LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v53, v37);
  v43(v40, 7LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v50, v37);
  v43(v40, 8LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v52, v37);
  v43(v40, 9LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v54, v37);
  v43(v40, 10LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v55, v37);
  v43(v40, 11LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v56, v37);
  v43(v40, 12LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v57, v37);
  v43(v40, 13LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v58, v37);
  v43(v40, 14LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v59, v37);
  v43(v40, 15LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v60, v37);
  v43(v40, 16LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v61, v37);
  v43(v40, 17LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v62, v37);
  v43(v40, 18LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v63, v37);
  v43(v40, 19LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v64, v37);
  v43(v40, 20LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v65, v37);
  v43(v40, 21LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v66, v37);
  v43(v40, 22LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v67, v37);
  v43(v40, 23LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v68, v37);
  v43(v40, 24LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v69, v37);
  v43(v40, 25LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v70, v37);
  v43(v40, 26LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v71, v37);
  v43(v40, 27LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v72, v37);
  v43(v40, 28LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v74, v37);
  v43(v40, 29LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v75, v37);
  v43(v40, 30LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v44 = v73;
  memcpy(v73, v76, v37);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v43)( v44,  31LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD32.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v11 = type metadata accessor for SIMD32(0LL, a3, (uint64_t)a4, v10);
  specialized SIMD32.lowHalf.setter(a1, v11);
  uint64_t v13 = type metadata accessor for SIMD16(0LL, a3, (uint64_t)a4, v12);
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8LL);
  v15(a1, v13);
  specialized SIMD32.highHalf.setter(a2, v11);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD32.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD32.lowHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

uint64_t SIMD32.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD32.highHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

uint64_t SIMD32.lowHalf.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = *(const char **)(v2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t v9 = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = 0LL;
  uint64_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    uint64_t v12 = swift_checkMetadataState(0LL, v8);
    v11(v10, v12, v9);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v4,  v10++,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  }

  while (v10 != 16);
  return result;
}

uint64_t key path getter for SIMD32.lowHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  SIMD32.lowHalf.getter);
}

uint64_t key path setter for SIMD32.lowHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  specialized SIMD32.lowHalf.setter);
}

void (*SIMD32.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD32.lowHalf.getter(a2);
  return SIMD32.lowHalf.modify;
}

void SIMD32.lowHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD32.highHalf.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = *(const char **)(v2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t v9 = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = 0LL;
  uint64_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    uint64_t v12 = swift_checkMetadataState(0LL, v8);
    v11(v10 + 16, v12, v9);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v4,  v10++,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  }

  while (v10 != 16);
  return result;
}

uint64_t key path getter for SIMD32.highHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  SIMD32.highHalf.getter);
}

uint64_t key path setter for SIMD32.highHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  specialized SIMD32.highHalf.setter);
}

void (*SIMD32.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD32.highHalf.getter(a2);
  return SIMD32.highHalf.modify;
}

void SIMD32.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD32.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(const char **)(v4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  do
  {
    uint64_t v16 = swift_checkMetadataState(0LL, v11);
    v15(v13, v16, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v6,  v14,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    v13 += 2LL;
    ++v14;
  }

  while (v14 != 16);
  return result;
}

uint64_t key path getter for SIMD32.evenHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  (uint64_t (*)(uint64_t))SIMD32.evenHalf.getter);
}

uint64_t key path setter for SIMD32.evenHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  specialized SIMD32.evenHalf.setter);
}

uint64_t SIMD32.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD32.evenHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

void (*SIMD32.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD32.evenHalf.modify;
}

void SIMD32.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD32.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(const char **)(v4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v13 = 0LL;
  uint64_t v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  uint64_t v15 = 1LL;
  do
  {
    uint64_t v16 = swift_checkMetadataState(0LL, v11);
    v14(v15, v16, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v6,  v13,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    v15 += 2LL;
    ++v13;
  }

  while (v13 != 16);
  return result;
}

uint64_t key path getter for SIMD32.oddHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  (uint64_t (*)(uint64_t))SIMD32.oddHalf.getter);
}

uint64_t key path setter for SIMD32.oddHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32,  specialized SIMD32.oddHalf.setter);
}

uint64_t SIMD32.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD32.oddHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

void (*SIMD32.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD32.oddHalf.modify;
}

void SIMD32.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD32.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD32<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD32<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>( a1,  a2,  associated type descriptor for SIMDScalar.SIMD32Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD32<A>( unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x357uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD32<A>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x35BuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  unint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  size_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD32<A>( void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x357uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD32<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD32<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD32<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD32<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD32<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD32<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD32<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD32<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v44 = a2;
  uint64_t v4 = a1;
  uint64_t v39 = *(void *)(a3 + 16);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v42 = (char *)&v37 - v8;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  unint64_t v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v37 - v13;
  uint64_t v15 = 0LL;
  char v16 = 1;
  uint64_t v18 = v17;
  uint64_t v19 = *(void (**)(void, void, void))(v17 + 16);
  uint64_t v40 = v12;
  uint64_t v41 = v20;
  size_t v37 = v19;
  uint64_t v38 = v17;
  uint64_t v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      unint64_t v23 = *(const char **)(v3 + 24);
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
      uint64_t v25 = v11;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
      uint64_t v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v28 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      uint64_t v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      uint64_t v30 = v28;
      uint64_t v19 = v37;
      unint64_t v31 = AssociatedConformanceWitness;
      unint64_t v11 = v25;
      uint64_t v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v33 = (uint64_t)v23;
      uint64_t v4 = v40;
      unint64_t v34 = swift_getAssociatedConformanceWitness( v33,  v21,  v32,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      unint64_t v35 = swift_getAssociatedConformanceWitness( v34,  v32,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v18 = v38;
      char v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35 + 8) + 8LL))(v42, v43, v21);
    }

    else
    {
      unint64_t v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      char v16 = 0;
    }

    if (++v15 == 32) {
      break;
    }
    v19(v14, v4, v3);
  }

  return v16 & 1;
}

uint64_t SIMD32<>.init<A>(truncatingIfNeeded:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 96LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 32);
  uint64_t v28 = type metadata accessor for SIMD32(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD32<>.init<A>(clamping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 104LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 32);
  uint64_t v28 = type metadata accessor for SIMD32(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD32<>.init<A>(_:rounding:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v40 = a5;
  uint64_t v41 = a7;
  uint64_t v38 = a2;
  uint64_t v44 = a1;
  uint64_t v42 = a9;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  char v16 = (char *)&v33 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v43 = associated type descriptor for SIMDScalar.SIMD32Storage;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v20,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v39 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  unint64_t v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v24 = swift_getAssociatedTypeWitness( 255LL,  a8,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  v43);
  uint64_t v34 = a8;
  uint64_t v43 = a4;
  unint64_t v36 = v24;
  unint64_t v25 = swift_getAssociatedConformanceWitness( (uint64_t)a8,  (uint64_t)a4,  v24,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v26 = 0LL;
  uint64_t v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  uint64_t v27 = v41;
  uint64_t v28 = v43;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0LL, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(void *)(v27 + 16) + 304LL))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(void *)(v40 + 8) + 80LL))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v18,  v26++,  v37,  AssociatedConformanceWitness);
  }

  while (v26 != 32);
  uint64_t v31 = type metadata accessor for SIMD32(0LL, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v31 - 8) + 8LL))(v44, v31);
}

unint64_t SIMD32.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(swift **)(a1 + 16);
  size_t v3 = *(void *)(*((void *)v2 - 1) + 64LL);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v5 = (char *)&v352 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = MEMORY[0x1895F8858](v4);
  unint64_t v400 = (char *)&v352 - v7;
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v399 = (char *)&v352 - v9;
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v398 = (char *)&v352 - v11;
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  v397 = (char *)&v352 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  v396 = (char *)&v352 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v395 = (char *)&v352 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v394 = (char *)&v352 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v393 = (char *)&v352 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v392 = (char *)&v352 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v391 = (char *)&v352 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v390 = (char *)&v352 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v389 = (char *)&v352 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v388 = (char *)&v352 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v387 = (char *)&v352 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v386 = (char *)&v352 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v385 = (char *)&v352 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  unint64_t v384 = (char *)&v352 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v358 = (uint64_t *)((char *)&v352 - v41);
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v364 = (uint64_t *)((char *)&v352 - v43);
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  uint64_t v370 = (uint64_t *)((char *)&v352 - v45);
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  unint64_t v376 = (uint64_t *)((char *)&v352 - v47);
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  uint64_t v50 = (char *)&v352 - v49;
  uint64_t v51 = MEMORY[0x1895F8858](v48);
  unint64_t v357 = (uint64_t *)((char *)&v352 - v52);
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  v363 = (uint64_t *)((char *)&v352 - v54);
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  unint64_t v369 = (uint64_t *)((char *)&v352 - v56);
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  uint64_t v375 = (uint64_t *)((char *)&v352 - v58);
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  uint64_t v383 = (char *)&v352 - v60;
  uint64_t v61 = MEMORY[0x1895F8858](v59);
  unint64_t v356 = (uint64_t *)((char *)&v352 - v62);
  uint64_t v63 = MEMORY[0x1895F8858](v61);
  v362 = (uint64_t *)((char *)&v352 - v64);
  uint64_t v65 = MEMORY[0x1895F8858](v63);
  unint64_t v368 = (uint64_t *)((char *)&v352 - v66);
  uint64_t v67 = MEMORY[0x1895F8858](v65);
  v374 = (uint64_t *)((char *)&v352 - v68);
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  uint64_t v382 = (char *)&v352 - v70;
  uint64_t v71 = MEMORY[0x1895F8858](v69);
  uint64_t v355 = (uint64_t *)((char *)&v352 - v72);
  uint64_t v73 = MEMORY[0x1895F8858](v71);
  v361 = (uint64_t *)((char *)&v352 - v74);
  uint64_t v75 = MEMORY[0x1895F8858](v73);
  uint64_t v367 = (uint64_t *)((char *)&v352 - v76);
  uint64_t v77 = MEMORY[0x1895F8858](v75);
  v373 = (uint64_t *)((char *)&v352 - v78);
  uint64_t v79 = MEMORY[0x1895F8858](v77);
  v381 = (char *)&v352 - v80;
  uint64_t v81 = MEMORY[0x1895F8858](v79);
  uint64_t v354 = (uint64_t *)((char *)&v352 - v82);
  uint64_t v83 = MEMORY[0x1895F8858](v81);
  unint64_t v360 = (uint64_t *)((char *)&v352 - v84);
  uint64_t v85 = MEMORY[0x1895F8858](v83);
  uint64_t v366 = (uint64_t *)((char *)&v352 - v86);
  uint64_t v87 = MEMORY[0x1895F8858](v85);
  v372 = (uint64_t *)((char *)&v352 - v88);
  uint64_t v89 = MEMORY[0x1895F8858](v87);
  v380 = (char *)&v352 - v90;
  uint64_t v91 = MEMORY[0x1895F8858](v89);
  unint64_t v353 = (uint64_t *)((char *)&v352 - v92);
  uint64_t v93 = MEMORY[0x1895F8858](v91);
  uint64_t v359 = (uint64_t *)((char *)&v352 - v94);
  uint64_t v95 = MEMORY[0x1895F8858](v93);
  v365 = (uint64_t *)((char *)&v352 - v96);
  uint64_t v97 = MEMORY[0x1895F8858](v95);
  v371 = (uint64_t *)((char *)&v352 - v98);
  uint64_t v99 = MEMORY[0x1895F8858](v97);
  uint64_t v101 = (char *)&v352 - v100;
  MEMORY[0x1895F8858](v99);
  uint64_t v379 = (char *)&v352 - v102;
  unint64_t v103 = specialized static String._createEmpty(withInitialCapacity:)(138LL);
  uint64_t v107 = v104;
  unint64_t v407 = v103;
  unint64_t v408 = v104;
  uint64_t v108 = HIBYTE(v104) & 0xF;
  if ((v104 & 0x2000000000000000LL) == 0) {
    uint64_t v108 = v103 & 0xFFFFFFFFFFFFLL;
  }
  if (v108 || (v103 & ~v104 & 0x2000000000000000LL) != 0)
  {
    if ((v104 & 0x2000000000000000LL) == 0
      || (unint64_t v109 = specialized _SmallString.init(_:appending:)(v103, v104, 0x3C3233444D4953uLL, 0xE700000000000000LL),
          (v105 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE700000000000000LL, v104, v105, v106);
      _StringGuts.append(_:)(0x3C3233444D4953LL, 0xE700000000000000LL, 0LL, 7LL);
      swift_bridgeObjectRelease_n(0xE700000000000000LL, 2LL);
    }

    else
    {
      unint64_t v110 = v109;
      unint64_t v111 = v104;
      swift_bridgeObjectRelease(v107);
      swift_bridgeObjectRelease(0xE700000000000000LL);
      unint64_t v407 = v110;
      unint64_t v408 = v111;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v104);
    unint64_t v407 = 0x3C3233444D4953LL;
    unint64_t v408 = 0xE700000000000000LL;
  }

  TypeName = (uint64_t *)swift_getTypeName((unint64_t)v2, 0);
  if (v113 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  unint64_t v114 = (uint8x16_t *)TypeName;
  uint64_t v115 = v113;
  BOOL v116 = _allASCII(_:)(TypeName, v113);
  v377 = v50;
  if (!v116)
  {
    uint64_t v120 = 0LL;
    int64_t v121 = &v114->u8[v115];
    if (!v114) {
      int64_t v121 = 0LL;
    }
    char v117 = 1;
    for (i = v114; ; i = (uint8x16_t *)((char *)i + 3))
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            unsigned int v124 = i->u8[0];
            i = (uint8x16_t *)((char *)i + 1);
            unsigned int v123 = v124;
            if ((v123 & 0x80) != 0) {
              break;
            }
            ++v120;
          }

          if (v123 > 0xDF) {
            break;
          }
          char v117 = 0;
          i = (uint8x16_t *)((char *)i + 1);
          v120 += 2LL;
        }

        if (v123 != 224) {
          break;
        }
        if (!i) {
          goto LABEL_64;
        }
        unint64_t v125 = &i->u8[1];
        if ((i->i8[0] & 0xE0) != 0xA0) {
          goto LABEL_64;
        }
LABEL_42:
        if (v125 == v121 || (*v125 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
        char v117 = 0;
        i = (uint8x16_t *)((char *)i + 2);
        v120 += 3LL;
      }

      if (v123 <= 0xEC) {
        break;
      }
      if (v123 == 237)
      {
        if (!i) {
          goto LABEL_64;
        }
        unint64_t v125 = &i->u8[1];
        unsigned int v126 = i->u8[0];
        if (v126 > 0x9F) {
          goto LABEL_64;
        }
        goto LABEL_41;
      }

      if (v123 <= 0xEF) {
        break;
      }
      if (v123 == 240)
      {
        if (!i) {
          goto LABEL_64;
        }
        unint64_t v127 = &i->u8[1];
      }

      else
      {
        if ((v123 + 15) > 2u)
        {
          if (!i || i == (uint8x16_t *)v121 || (unint64_t v127 = &i->u8[1], v128 = i->u8[0], v128 > 0x8F))
          {
LABEL_64:
            uint64_t v129 = v1;
            uint64_t v130 = swift_allocError( (uint64_t)&unk_189B86A70,  (uint64_t)&protocol witness table for UTF8ValidationError,  0LL,  0);
            unint64_t v352 = v2;
            swift_willThrow();
            unint64_t v131 = v130;
            uint64_t v1 = v129;
            uint64_t v5 = (char *)&v352 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
            swift_errorRelease(v131);
            uint64_t v132 = specialized Collection.subscript.getter(v120, (uint64_t)v114, v115);
            int64_t v136 = findInvalidRange #1 (_:) in validateUTF8(_:)(v132, v133, v134, v135);
            uint64_t v2 = v352;
            unint64_t v118 = repairUTF8(_:firstKnownBrokenRange:)(v114->i8, v115, v136, v137);
            goto LABEL_65;
          }
        }

        else
        {
          unint64_t v127 = &i->u8[1];
          LOBYTE(v128) = i->i8[0];
        }

        if ((v128 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
      }

      char v117 = 0;
      v120 += 4LL;
    }

    unint64_t v125 = &i->u8[1];
    LOBYTE(v126) = i->i8[0];
LABEL_41:
    if ((v126 & 0xC0) != 0x80) {
      goto LABEL_64;
    }
    goto LABEL_42;
  }

  char v117 = 1;
LABEL_12:
  unint64_t v118 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v114, v115, v117 & 1);
LABEL_65:
  unint64_t v138 = v118;
  unint64_t v139 = v119;
  unint64_t v140 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000LL) == 0) {
    unint64_t v140 = v407 & 0xFFFFFFFFFFFFLL;
  }
  if (v140 || (v407 & ~v408 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(v118, v119);
    swift_bridgeObjectRelease(v139);
    unint64_t v138 = v407;
    unint64_t v139 = v408;
  }

  else
  {
    swift_bridgeObjectRelease(v408);
    unint64_t v407 = v138;
    unint64_t v408 = v139;
  }

  uint64_t v141 = HIBYTE(v139) & 0xF;
  if ((v139 & 0x2000000000000000LL) == 0) {
    uint64_t v141 = v138 & 0xFFFFFFFFFFFFLL;
  }
  v378 = v5;
  if (v141 || (v138 & ~v139 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x283EuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v139);
    unint64_t v407 = 10302LL;
    unint64_t v408 = 0xE200000000000000LL;
  }

  uint64_t v142 = *(const char **)(v1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v142,  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v142,  (uint64_t)v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v145 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v146 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint32x4_t v147 = v379;
  v145(0LL, v146, AssociatedConformanceWitness);
  uint64_t v402 = (uint64_t *)v2;
  uint64x2_t v148 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v148, v147, v3);
  uint64_t v149 = v402;
  uint64_t v150 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  DynamicType = (void *)swift_getDynamicType(v150, v149, 1);
  LODWORD(v149) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v149)
  {
    memcpy(v101, v147, v3);
    uint64_t v152 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v152, 7uLL);
LABEL_77:
    uint64_t v153 = (uint64_t)v402;
    uint64_t v154 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    unint64_t v155 = (*(uint64_t (**)(uint64_t, uint64_t))(v154 + 8))(v153, v154);
    uint64_t v157 = v156;
    specialized String.write<A>(to:)(&v407, v155, v156, v158);
    swift_bridgeObjectRelease(v157);
LABEL_78:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_81;
  }

  unint64_t v159 = v371;
  memcpy(v371, v147, v3);
  if ((swift_dynamicCast((char *)&v401, v159, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    unint64_t object = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)object);
  }

  else
  {
    uint64_t v282 = v365;
    memcpy(v365, v147, v3);
    uint64_t v283 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v282, v2, v283, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      uint64_t v284 = (uint64_t)v402;
      uint64_t v285 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v285 + 8))( &v407,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v284,  v285);
      goto LABEL_78;
    }

    uint64_t v406 = 0LL;
    __int128 v404 = 0u;
    __int128 v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v306 = v359;
    memcpy(v359, v147, v3);
    unint64_t v307 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v306, v2, v307, 6uLL)
      || (uint64_t v406 = 0LL,
          __int128 v404 = 0u,
          __int128 v405 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomStringConvertible?),  uint64_t v308 = v353,  memcpy(v353, v147, v3),  v309 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v404, v308, v2, v309, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_77;
    }

    uint64_t v406 = 0LL;
    __int128 v404 = 0u;
    __int128 v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v405 + 1) = v2;
    uint64_t v330 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v330, v147, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    uint64_t v331 = v401._object;
    uint64_t v332 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v147,  &v401,  &v407,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v332);
    swift_release((uint64_t)v331);
  }

uint64_t SIMD32<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 16) + 72LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 32);
  uint64_t v28 = type metadata accessor for SIMD32(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v31 = a7;
  uint64_t v34 = a6;
  uint64_t v35 = a8;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v36 = a3;
  unint64_t v32 = v22;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v33,  AssociatedConformanceWitness);
  }

  while (v24 != 32);
  uint64_t v28 = type metadata accessor for SIMD32(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD64._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage,  a2);
}

uint64_t SIMD64._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t (*SIMD64._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD64.scalarCount.getter()
{
  return 64LL;
}

uint64_t key path getter for SIMD64.subscript(_:) : <A>SIMD64<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x44FuLL,  0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(const char **)((char *)a2 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD64.subscript(_:) : <A>SIMD64<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x453uLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD64.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x44FuLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD64.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)( const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, const void *a17, const void *a18, const void *a19, const void *a20, const void *a21, const void *a22, const void *a23, const void *a24, const void *a25, const void *a26, const void *a27, const void *a28, const void *a29, const void *a30, const void *a31, const void *a32, const void *a33, const void *a34, const void *a35, const void *a36, const void *a37, const void *a38, const void *a39, const void *a40, const void *a41, const void *a42, const void *a43, const void *a44, const void *a45, const void *a46, const void *a47, const void *a48, const void *a49, const void *a50,const void *a51,const void *a52,const void *a53,const void *a54,const void *a55,const void *a56,const void *a57,const void *a58,const void *a59,const void *a60,const void *a61,const void *a62,const void *a63)
{
  v298 = a8;
  uint64_t v295 = a7;
  uint64_t v292 = a6;
  unint64_t v290 = a5;
  unint64_t v287 = a4;
  uint64_t v284 = a3;
  uint64_t v283 = a2;
  Swift::String v278 = a1;
  unint64_t v384 = a63;
  unint64_t v385 = a64;
  uint64_t v382 = a61;
  uint64_t v383 = a62;
  v381 = a60;
  v378 = a58;
  uint64_t v379 = a59;
  unint64_t v376 = a57;
  v374 = a56;
  v372 = a55;
  uint64_t v370 = a54;
  uint64_t v367 = a52;
  unint64_t v368 = a53;
  v365 = a51;
  v363 = a50;
  v361 = a49;
  unint64_t v360 = a48;
  v358 = a47;
  size_t v66 = *(void *)(*(void *)(a65 - 8) + 64LL);
  uint64_t v354 = a46;
  unint64_t v353 = a45;
  uint64_t v351 = a44;
  v349 = a43;
  uint64_t v348 = a42;
  v346 = a41;
  uint64_t v344 = a40;
  v342 = a39;
  v341 = a38;
  uint64_t v339 = a37;
  unint64_t v337 = a36;
  uint64_t v336 = a35;
  uint64_t v334 = a34;
  uint64_t v332 = a33;
  uint64_t v330 = a32;
  v329 = a31;
  uint64_t v327 = a30;
  unint64_t v325 = a29;
  unint64_t v324 = a28;
  uint64_t v322 = a27;
  unint64_t v320 = a26;
  uint64_t v318 = a25;
  unint64_t v317 = a24;
  char v315 = a23;
  v313 = a22;
  uint64_t v311 = a21;
  v310 = a20;
  uint64_t v308 = a19;
  uint64_t v306 = a18;
  uint64_t v305 = a17;
  uint64_t v303 = a16;
  uint64_t v301 = a15;
  v299 = a14;
  uint64_t v297 = a13;
  unint64_t v294 = a12;
  unint64_t v291 = a11;
  uint64_t v289 = a10;
  uint64_t v286 = a9;
  uint64_t v67 = MEMORY[0x1895F8858](a1);
  v380 = (char *)&v261 - ((v66 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v68 = MEMORY[0x1895F8858](v67);
  v377 = (char *)&v261 - v69;
  uint64_t v70 = MEMORY[0x1895F8858](v68);
  uint64_t v375 = (char *)&v261 - v71;
  uint64_t v72 = MEMORY[0x1895F8858](v70);
  v373 = (char *)&v261 - v73;
  uint64_t v74 = MEMORY[0x1895F8858](v72);
  v371 = (char *)&v261 - v75;
  uint64_t v76 = MEMORY[0x1895F8858](v74);
  unint64_t v369 = (char *)&v261 - v77;
  uint64_t v78 = MEMORY[0x1895F8858](v76);
  uint64_t v366 = (char *)&v261 - v79;
  uint64_t v80 = MEMORY[0x1895F8858](v78);
  v364 = (char *)&v261 - v81;
  uint64_t v82 = MEMORY[0x1895F8858](v80);
  v362 = (char *)&v261 - v83;
  uint64_t v84 = MEMORY[0x1895F8858](v82);
  uint64_t v359 = (char *)&v261 - v85;
  uint64_t v86 = MEMORY[0x1895F8858](v84);
  unint64_t v357 = (char *)&v261 - v87;
  uint64_t v88 = MEMORY[0x1895F8858](v86);
  unint64_t v356 = (char *)&v261 - v89;
  uint64_t v90 = MEMORY[0x1895F8858](v88);
  uint64_t v355 = (char *)&v261 - v91;
  uint64_t v92 = MEMORY[0x1895F8858](v90);
  unint64_t v352 = (char *)&v261 - v93;
  uint64_t v94 = MEMORY[0x1895F8858](v92);
  uint64_t v350 = (char *)&v261 - v95;
  uint64_t v96 = MEMORY[0x1895F8858](v94);
  uint64_t v347 = (char *)&v261 - v97;
  uint64_t v98 = MEMORY[0x1895F8858](v96);
  v345 = (char *)&v261 - v99;
  uint64_t v100 = MEMORY[0x1895F8858](v98);
  uint64_t v343 = (char *)&v261 - v101;
  uint64_t v102 = MEMORY[0x1895F8858](v100);
  uint64_t v340 = (char *)&v261 - v103;
  uint64_t v104 = MEMORY[0x1895F8858](v102);
  uint64_t v338 = (char *)&v261 - v105;
  uint64_t v106 = MEMORY[0x1895F8858](v104);
  uint64_t v335 = (char *)&v261 - v107;
  uint64_t v108 = MEMORY[0x1895F8858](v106);
  uint64_t v333 = (char *)&v261 - v109;
  uint64_t v110 = MEMORY[0x1895F8858](v108);
  uint64_t v331 = (char *)&v261 - v111;
  uint64_t v112 = MEMORY[0x1895F8858](v110);
  unint64_t v328 = (char *)&v261 - v113;
  uint64_t v114 = MEMORY[0x1895F8858](v112);
  unint64_t v326 = (char *)&v261 - v115;
  uint64_t v116 = MEMORY[0x1895F8858](v114);
  uint64_t v323 = (char *)&v261 - v117;
  uint64_t v118 = MEMORY[0x1895F8858](v116);
  unint64_t v321 = (char *)&v261 - v119;
  uint64_t v120 = MEMORY[0x1895F8858](v118);
  uint64_t v319 = (char *)&v261 - v121;
  uint64_t v122 = MEMORY[0x1895F8858](v120);
  unint64_t v316 = (char *)&v261 - v123;
  uint64_t v124 = MEMORY[0x1895F8858](v122);
  size_t v314 = (char *)&v261 - v125;
  uint64_t v126 = MEMORY[0x1895F8858](v124);
  unint64_t v312 = (char *)&v261 - v127;
  uint64_t v128 = MEMORY[0x1895F8858](v126);
  v309 = (char *)&v261 - v129;
  uint64_t v130 = MEMORY[0x1895F8858](v128);
  unint64_t v307 = (char *)&v261 - v131;
  uint64_t v132 = MEMORY[0x1895F8858](v130);
  uint64_t v304 = (char *)&v261 - v133;
  uint64_t v134 = MEMORY[0x1895F8858](v132);
  uint64_t v302 = (char *)&v261 - v135;
  uint64_t v136 = MEMORY[0x1895F8858](v134);
  uint64_t v300 = (char *)&v261 - v137;
  uint64_t v138 = MEMORY[0x1895F8858](v136);
  uint64_t v296 = (char *)&v261 - v139;
  uint64_t v140 = MEMORY[0x1895F8858](v138);
  uint64_t v293 = (char *)&v261 - v141;
  uint64_t v142 = MEMORY[0x1895F8858](v140);
  uint64_t v288 = (char *)&v261 - v143;
  uint64_t v144 = MEMORY[0x1895F8858](v142);
  uint64_t v285 = (char *)&v261 - v145;
  uint64_t v146 = MEMORY[0x1895F8858](v144);
  uint64_t v282 = (char *)&v261 - v147;
  uint64_t v148 = MEMORY[0x1895F8858](v146);
  uint64_t v281 = (char *)&v261 - v149;
  uint64_t v150 = MEMORY[0x1895F8858](v148);
  Swift::String v280 = (char *)&v261 - v151;
  uint64_t v152 = MEMORY[0x1895F8858](v150);
  uint64_t v279 = (char *)&v261 - v153;
  uint64_t v154 = MEMORY[0x1895F8858](v152);
  uint64_t v277 = (char *)&v261 - v155;
  uint64_t v156 = MEMORY[0x1895F8858](v154);
  Swift::String v276 = (char *)&v261 - v157;
  uint64_t v158 = MEMORY[0x1895F8858](v156);
  uint64_t v275 = (char *)&v261 - v159;
  uint64_t v160 = MEMORY[0x1895F8858](v158);
  Swift::String v274 = (char *)&v261 - v161;
  uint64_t v162 = MEMORY[0x1895F8858](v160);
  uint64_t v273 = (char *)&v261 - v163;
  uint64_t v164 = MEMORY[0x1895F8858](v162);
  Swift::String v272 = (char *)&v261 - v165;
  uint64_t v166 = MEMORY[0x1895F8858](v164);
  uint64_t v271 = (char *)&v261 - v167;
  uint64_t v168 = MEMORY[0x1895F8858](v166);
  Swift::String v270 = (char *)&v261 - v169;
  uint64_t v170 = MEMORY[0x1895F8858](v168);
  uint64_t v269 = (char *)&v261 - v171;
  uint64_t v172 = MEMORY[0x1895F8858](v170);
  Swift::String v268 = (char *)&v261 - v173;
  uint64_t v174 = MEMORY[0x1895F8858](v172);
  uint64_t v267 = (char *)&v261 - v175;
  uint64_t v176 = MEMORY[0x1895F8858](v174);
  Swift::String v266 = (char *)&v261 - v177;
  uint64_t v178 = MEMORY[0x1895F8858](v176);
  uint64_t v265 = (char *)&v261 - v179;
  uint64_t v180 = MEMORY[0x1895F8858](v178);
  Swift::String v264 = (char *)&v261 - v181;
  uint64_t v182 = MEMORY[0x1895F8858](v180);
  uint64_t v263 = (char *)&v261 - v183;
  uint64_t v184 = MEMORY[0x1895F8858](v182);
  Swift::String v262 = (char *)&v261 - v185;
  uint64_t v186 = MEMORY[0x1895F8858](v184);
  char v188 = (char *)&v261 - v187;
  uint64_t v189 = MEMORY[0x1895F8858](v186);
  unint64_t v191 = (char *)&v261 - v190;
  uint64_t v192 = MEMORY[0x1895F8858](v189);
  uint64_t v194 = (char *)&v261 - v193;
  MEMORY[0x1895F8858](v192);
  unint64_t v196 = (char *)&v261 - v195;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a66,  a65,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a66,  a65,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  memcpy(v196, v278, v66);
  uint64_t v199 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v199(v196, 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v194, v283, v66);
  v199(v194, 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v191, v284, v66);
  v199(v191, 2LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v188, v287, v66);
  v199(v188, 3LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v200 = v262;
  memcpy(v262, v290, v66);
  v199(v200, 4LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v201 = v263;
  memcpy(v263, v292, v66);
  v199(v201, 5LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v202 = v264;
  memcpy(v264, v295, v66);
  v199(v202, 6LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v203 = v265;
  memcpy(v265, v298, v66);
  v199(v203, 7LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v204 = v266;
  memcpy(v266, v286, v66);
  v199(v204, 8LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v205 = v267;
  memcpy(v267, v289, v66);
  v199(v205, 9LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v206 = v268;
  memcpy(v268, v291, v66);
  v199(v206, 10LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v207 = v269;
  memcpy(v269, v294, v66);
  v199(v207, 11LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v208 = v270;
  memcpy(v270, v297, v66);
  v199(v208, 12LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v209 = v271;
  memcpy(v271, v299, v66);
  v199(v209, 13LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  char v210 = v272;
  memcpy(v272, v301, v66);
  v199(v210, 14LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v211 = v273;
  memcpy(v273, v303, v66);
  v199(v211, 15LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v212 = v274;
  memcpy(v274, v305, v66);
  v199(v212, 16LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v213 = v275;
  memcpy(v275, v306, v66);
  v199(v213, 17LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v214 = v276;
  memcpy(v276, v308, v66);
  v199(v214, 18LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v215 = v277;
  memcpy(v277, v310, v66);
  v199(v215, 19LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v216 = v279;
  memcpy(v279, v311, v66);
  v199(v216, 20LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v217 = v280;
  memcpy(v280, v313, v66);
  v199(v217, 21LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v218 = v281;
  memcpy(v281, v315, v66);
  v199(v218, 22LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v219 = v282;
  memcpy(v282, v317, v66);
  v199(v219, 23LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v220 = v285;
  memcpy(v285, v318, v66);
  v199(v220, 24LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v221 = v288;
  memcpy(v288, v320, v66);
  v199(v221, 25LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v222 = v293;
  memcpy(v293, v322, v66);
  v199(v222, 26LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v223 = v296;
  memcpy(v296, v324, v66);
  v199(v223, 27LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64x2_t v224 = v300;
  memcpy(v300, v325, v66);
  v199(v224, 28LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v225 = v302;
  memcpy(v302, v327, v66);
  v199(v225, 29LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v226 = v304;
  memcpy(v304, v329, v66);
  v199(v226, 30LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v227 = v307;
  memcpy(v307, v330, v66);
  v199(v227, 31LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v228 = v309;
  memcpy(v309, v332, v66);
  v199(v228, 32LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v229 = v312;
  memcpy(v312, v334, v66);
  v199(v229, 33LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v230 = v314;
  memcpy(v314, v336, v66);
  v199(v230, 34LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v231 = v316;
  memcpy(v316, v337, v66);
  v199(v231, 35LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v232 = v319;
  memcpy(v319, v339, v66);
  v199(v232, 36LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v233 = v321;
  memcpy(v321, v341, v66);
  v199(v233, 37LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v234 = v323;
  memcpy(v323, v342, v66);
  v199(v234, 38LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v235 = v326;
  memcpy(v326, v344, v66);
  v199(v235, 39LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v236 = v328;
  memcpy(v328, v346, v66);
  v199(v236, 40LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v237 = v331;
  memcpy(v331, v348, v66);
  v199(v237, 41LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v238 = v333;
  memcpy(v333, v349, v66);
  v199(v238, 42LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v239 = v335;
  memcpy(v335, v351, v66);
  v199(v239, 43LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v240 = v338;
  memcpy(v338, v353, v66);
  v199(v240, 44LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v241 = v340;
  memcpy(v340, v354, v66);
  v199(v241, 45LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v242 = v343;
  memcpy(v343, v358, v66);
  v199(v242, 46LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v243 = v345;
  memcpy(v345, v360, v66);
  v199(v243, 47LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v244 = v347;
  memcpy(v347, v361, v66);
  v199(v244, 48LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v245 = v350;
  memcpy(v350, v363, v66);
  v199(v245, 49LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v246 = v352;
  memcpy(v352, v365, v66);
  v199(v246, 50LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v247 = v355;
  memcpy(v355, v367, v66);
  v199(v247, 51LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v248 = v356;
  memcpy(v356, v368, v66);
  v199(v248, 52LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v249 = v357;
  memcpy(v357, v370, v66);
  v199(v249, 53LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v250 = v359;
  memcpy(v359, v372, v66);
  v199(v250, 54LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v251 = v362;
  memcpy(v362, v374, v66);
  v199(v251, 55LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v252 = v364;
  memcpy(v364, v376, v66);
  v199(v252, 56LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v253 = v366;
  memcpy(v366, v378, v66);
  v199(v253, 57LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v254 = v369;
  memcpy(v369, v379, v66);
  v199(v254, 58LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v255 = v371;
  memcpy(v371, v381, v66);
  v199(v255, 59LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v256 = v373;
  memcpy(v373, v382, v66);
  v199(v256, 60LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v257 = v375;
  memcpy(v375, v383, v66);
  v199(v257, 61LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v258 = v377;
  memcpy(v377, v384, v66);
  v199(v258, 62LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v259 = v380;
  memcpy(v380, v385, v66);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v199)( v259,  63LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD64.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v11 = type metadata accessor for SIMD64(0LL, a3, (uint64_t)a4, v10);
  specialized SIMD64.lowHalf.setter(a1, v11);
  uint64_t v13 = type metadata accessor for SIMD32(0LL, a3, (uint64_t)a4, v12);
  uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8LL);
  v15(a1, v13);
  specialized SIMD64.highHalf.setter(a2, v11);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD64.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD64.lowHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

uint64_t SIMD64.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD64.highHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

uint64_t SIMD64.lowHalf.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = *(const char **)(v2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t v9 = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v10 = 0LL;
  uint64_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    uint64_t v12 = swift_checkMetadataState(0LL, v8);
    v11(v10, v12, v9);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v4,  v10++,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  }

  while (v10 != 32);
  return result;
}

uint64_t key path getter for SIMD64.lowHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  SIMD64.lowHalf.getter);
}

uint64_t key path setter for SIMD64.lowHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  specialized SIMD64.lowHalf.setter);
}

void (*SIMD64.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD64.lowHalf.getter(a2);
  return SIMD64.lowHalf.modify;
}

void SIMD64.lowHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD64.highHalf.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = *(const char **)(v2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v5,  v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t v9 = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v1,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v10 = 0LL;
  uint64_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    uint64_t v12 = swift_checkMetadataState(0LL, v8);
    v11(v10 + 32, v12, v9);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v4,  v10++,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  }

  while (v10 != 32);
  return result;
}

uint64_t key path getter for SIMD64.highHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  SIMD64.highHalf.getter);
}

uint64_t key path setter for SIMD64.highHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  specialized SIMD64.highHalf.setter);
}

void (*SIMD64.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD64.highHalf.getter(a2);
  return SIMD64.highHalf.modify;
}

void SIMD64.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD64.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(const char **)(v4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  do
  {
    uint64_t v16 = swift_checkMetadataState(0LL, v11);
    v15(v13, v16, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v6,  v14,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    v13 += 2LL;
    ++v14;
  }

  while (v14 != 32);
  return result;
}

uint64_t key path getter for SIMD64.evenHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  (uint64_t (*)(uint64_t))SIMD64.evenHalf.getter);
}

uint64_t key path setter for SIMD64.evenHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  specialized SIMD64.evenHalf.setter);
}

uint64_t SIMD64.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD64.evenHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

void (*SIMD64.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD64.evenHalf.modify;
}

void SIMD64.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD64.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(const char **)(v4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v7,  v3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v7,  v3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v13 = 0LL;
  uint64_t v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  uint64_t v15 = 1LL;
  do
  {
    uint64_t v16 = swift_checkMetadataState(0LL, v11);
    v14(v15, v16, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( v6,  v13,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    v15 += 2LL;
    ++v13;
  }

  while (v13 != 32);
  return result;
}

uint64_t key path getter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  (uint64_t (*)(uint64_t))SIMD64.oddHalf.getter);
}

uint64_t key path setter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD64,  specialized SIMD64.oddHalf.setter);
}

uint64_t SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter( a1,  a2,  (void (*)(void))specialized SIMD64.oddHalf.setter,  (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

void (*SIMD64.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD64.oddHalf.modify;
}

void SIMD64.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD64.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD64<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD64<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>( a1,  a2,  associated type descriptor for SIMDScalar.SIMD64Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD64<A>( unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x44FuLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD64<A>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x453uLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  unint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  size_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD64<A>( void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x44FuLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD64<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD64<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD64<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD64<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD64<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD64<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD64<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD64<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v44 = a2;
  uint64_t v4 = a1;
  uint64_t v39 = *(void *)(a3 + 16);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v42 = (char *)&v37 - v8;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  unint64_t v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v37 - v13;
  uint64_t v15 = 0LL;
  char v16 = 1;
  uint64_t v18 = v17;
  uint64_t v19 = *(void (**)(void, void, void))(v17 + 16);
  uint64_t v40 = v12;
  uint64_t v41 = v20;
  uint64_t v37 = v19;
  uint64_t v38 = v17;
  uint64_t v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      unint64_t v23 = *(const char **)(v3 + 24);
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
      uint64_t v25 = v11;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
      uint64_t v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v28 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      uint64_t v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      uint64_t v30 = v28;
      uint64_t v19 = v37;
      unint64_t v31 = AssociatedConformanceWitness;
      unint64_t v11 = v25;
      uint64_t v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v33 = (uint64_t)v23;
      uint64_t v4 = v40;
      unint64_t v34 = swift_getAssociatedConformanceWitness( v33,  v21,  v32,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      unint64_t v35 = swift_getAssociatedConformanceWitness( v34,  v32,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v18 = v38;
      char v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35 + 8) + 8LL))(v42, v43, v21);
    }

    else
    {
      unint64_t v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      char v16 = 0;
    }

    if (++v15 == 64) {
      break;
    }
    v19(v14, v4, v3);
  }

  return v16 & 1;
}

uint64_t SIMD64<>.init<A>(truncatingIfNeeded:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 96LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 64);
  uint64_t v28 = type metadata accessor for SIMD64(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD64<>.init<A>(clamping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  char v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 8) + 104LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 64);
  uint64_t v28 = type metadata accessor for SIMD64(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD64<>.init<A>(_:rounding:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v40 = a5;
  uint64_t v41 = a7;
  uint64_t v38 = a2;
  uint64_t v44 = a1;
  uint64_t v42 = a9;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  char v16 = (char *)&v33 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v43 = associated type descriptor for SIMDScalar.SIMD64Storage;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v20,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v39 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  unint64_t v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v24 = swift_getAssociatedTypeWitness( 255LL,  a8,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  v43);
  uint64_t v34 = a8;
  uint64_t v43 = a4;
  unint64_t v36 = v24;
  unint64_t v25 = swift_getAssociatedConformanceWitness( (uint64_t)a8,  (uint64_t)a4,  v24,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v26 = 0LL;
  uint64_t v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  uint64_t v27 = v41;
  uint64_t v28 = v43;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0LL, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(void *)(v27 + 16) + 304LL))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(void *)(v40 + 8) + 80LL))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v18,  v26++,  v37,  AssociatedConformanceWitness);
  }

  while (v26 != 64);
  uint64_t v31 = type metadata accessor for SIMD64(0LL, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v31 - 8) + 8LL))(v44, v31);
}

uint64_t SIMD64.debugDescription.getter(uint64_t a1)
{
  uint64_t v2 = *(swift **)(a1 + 16);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  uint64_t v327 = (char *)&v267 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = MEMORY[0x1895F8858](v3);
  unint64_t v326 = (char *)&v267 - v6;
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  unint64_t v325 = (char *)&v267 - v8;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  unint64_t v324 = (char *)&v267 - v10;
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v323 = (char *)&v267 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v322 = (char *)&v267 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v321 = (char *)&v267 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v320 = (char *)&v267 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v319 = (char *)&v267 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v318 = (char *)&v267 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v317 = (char *)&v267 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  unint64_t v316 = (char *)&v267 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  char v315 = (char *)&v267 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  size_t v314 = (char *)&v267 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  v313 = (char *)&v267 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  unint64_t v312 = (char *)&v267 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v311 = (char *)&v267 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  v310 = (char *)&v267 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  v309 = (char *)&v267 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v308 = (char *)&v267 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  unint64_t v307 = (char *)&v267 - v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v306 = (char *)&v267 - v46;
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  uint64_t v305 = (char *)&v267 - v48;
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  uint64_t v304 = (char *)&v267 - v50;
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  uint64_t v303 = (char *)&v267 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  uint64_t v302 = (char *)&v267 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  uint64_t v301 = (char *)&v267 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  uint64_t v300 = (char *)&v267 - v58;
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  v299 = (char *)&v267 - v60;
  uint64_t v61 = MEMORY[0x1895F8858](v59);
  v298 = (char *)&v267 - v62;
  uint64_t v63 = MEMORY[0x1895F8858](v61);
  uint64_t v297 = (char *)&v267 - v64;
  uint64_t v65 = MEMORY[0x1895F8858](v63);
  uint64_t v296 = (char *)&v267 - v66;
  uint64_t v67 = MEMORY[0x1895F8858](v65);
  uint64_t v295 = (char *)&v267 - v68;
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  unint64_t v294 = (char *)&v267 - v70;
  uint64_t v71 = MEMORY[0x1895F8858](v69);
  uint64_t v293 = (char *)&v267 - v72;
  uint64_t v73 = MEMORY[0x1895F8858](v71);
  uint64_t v292 = (char *)&v267 - v74;
  uint64_t v75 = MEMORY[0x1895F8858](v73);
  unint64_t v291 = (char *)&v267 - v76;
  uint64_t v77 = MEMORY[0x1895F8858](v75);
  unint64_t v290 = (char *)&v267 - v78;
  uint64_t v79 = MEMORY[0x1895F8858](v77);
  uint64_t v289 = (char *)&v267 - v80;
  uint64_t v81 = MEMORY[0x1895F8858](v79);
  uint64_t v288 = (char *)&v267 - v82;
  uint64_t v83 = MEMORY[0x1895F8858](v81);
  unint64_t v287 = (char *)&v267 - v84;
  uint64_t v85 = MEMORY[0x1895F8858](v83);
  uint64_t v286 = (char *)&v267 - v86;
  uint64_t v87 = MEMORY[0x1895F8858](v85);
  uint64_t v285 = (char *)&v267 - v88;
  uint64_t v89 = MEMORY[0x1895F8858](v87);
  uint64_t v284 = (char *)&v267 - v90;
  uint64_t v91 = MEMORY[0x1895F8858](v89);
  uint64_t v283 = (char *)&v267 - v92;
  uint64_t v93 = MEMORY[0x1895F8858](v91);
  uint64_t v282 = (char *)&v267 - v94;
  uint64_t v95 = MEMORY[0x1895F8858](v93);
  uint64_t v281 = (char *)&v267 - v96;
  uint64_t v97 = MEMORY[0x1895F8858](v95);
  Swift::String v280 = (char *)&v267 - v98;
  uint64_t v99 = MEMORY[0x1895F8858](v97);
  uint64_t v279 = (char *)&v267 - v100;
  uint64_t v101 = MEMORY[0x1895F8858](v99);
  Swift::String v278 = (char *)&v267 - v102;
  uint64_t v103 = MEMORY[0x1895F8858](v101);
  uint64_t v277 = (char *)&v267 - v104;
  uint64_t v105 = MEMORY[0x1895F8858](v103);
  Swift::String v276 = (char *)&v267 - v106;
  uint64_t v107 = MEMORY[0x1895F8858](v105);
  uint64_t v275 = (char *)&v267 - v108;
  uint64_t v109 = MEMORY[0x1895F8858](v107);
  Swift::String v274 = (char *)&v267 - v110;
  uint64_t v111 = MEMORY[0x1895F8858](v109);
  uint64_t v273 = (char *)&v267 - v112;
  uint64_t v113 = MEMORY[0x1895F8858](v111);
  Swift::String v272 = (char *)&v267 - v114;
  uint64_t v115 = MEMORY[0x1895F8858](v113);
  uint64_t v271 = (char *)&v267 - v116;
  uint64_t v117 = MEMORY[0x1895F8858](v115);
  Swift::String v270 = (char *)&v267 - v118;
  uint64_t v119 = MEMORY[0x1895F8858](v117);
  uint64_t v269 = (char *)&v267 - v120;
  uint64_t v121 = MEMORY[0x1895F8858](v119);
  Swift::String v268 = (char *)&v267 - v122;
  uint64_t v123 = MEMORY[0x1895F8858](v121);
  uint64_t v267 = (char *)&v267 - v124;
  uint64_t v125 = MEMORY[0x1895F8858](v123);
  uint64_t v127 = (char *)&v267 - v126;
  uint64_t v128 = MEMORY[0x1895F8858](v125);
  uint64_t v130 = (char *)&v267 - v129;
  MEMORY[0x1895F8858](v128);
  uint64_t v132 = (char *)&v267 - v131;
  v328[0] = specialized static String._createEmpty(withInitialCapacity:)(266LL);
  v328[1] = v133;
  v134._unint64_t countAndFlagsBits = 0x3C3436444D4953LL;
  v134._unint64_t object = (void *)0xE700000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v134);
  swift_bridgeObjectRelease(0xE700000000000000LL);
  DefaultStringInterpolation.appendInterpolation(_:)((unint64_t)v2);
  v135._unint64_t countAndFlagsBits = 10302LL;
  v135._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v135);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v136 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v136,  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v136,  (uint64_t)v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v139 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v140 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v139(0LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v132,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v141._unint64_t countAndFlagsBits = 8236LL;
  v141._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v141);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v139(1LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v130,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v142._unint64_t countAndFlagsBits = 8236LL;
  v142._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v142);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v139(2LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v127,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v143._unint64_t countAndFlagsBits = 8236LL;
  v143._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v143);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v144 = (uint64_t)v267;
  v139(3LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v144,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v145._unint64_t countAndFlagsBits = 8236LL;
  v145._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v145);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v146 = (uint64_t)v268;
  v139(4LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v146,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v147._unint64_t countAndFlagsBits = 8236LL;
  v147._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v147);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v148 = (uint64_t)v269;
  v139(5LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v148,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v149._unint64_t countAndFlagsBits = 8236LL;
  v149._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v149);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v150 = (uint64_t)v270;
  v139(6LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v150,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v151._unint64_t countAndFlagsBits = 8236LL;
  v151._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v151);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v152 = (uint64_t)v271;
  v139(7LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v152,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v153._unint64_t countAndFlagsBits = 8236LL;
  v153._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v153);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v154 = (uint64_t)v272;
  v139(8LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v154,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v155._unint64_t countAndFlagsBits = 8236LL;
  v155._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v155);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v156 = (uint64_t)v273;
  v139(9LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v156,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v157._unint64_t countAndFlagsBits = 8236LL;
  v157._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v157);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v158 = (uint64_t)v274;
  v139(10LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v158,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v159._unint64_t countAndFlagsBits = 8236LL;
  v159._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v159);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v160 = (uint64_t)v275;
  v139(11LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v160,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v161._unint64_t countAndFlagsBits = 8236LL;
  v161._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v161);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v162 = (uint64_t)v276;
  v139(12LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v162,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v163._unint64_t countAndFlagsBits = 8236LL;
  v163._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v163);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v164 = (uint64_t)v277;
  v139(13LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v164,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v165._unint64_t countAndFlagsBits = 8236LL;
  v165._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v165);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v166 = (uint64_t)v278;
  v139(14LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v166,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v167._unint64_t countAndFlagsBits = 8236LL;
  v167._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v167);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v168 = (uint64_t)v279;
  v139(15LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v168,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v169._unint64_t countAndFlagsBits = 8236LL;
  v169._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v169);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v170 = (uint64_t)v280;
  v139(16LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v170,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v171._unint64_t countAndFlagsBits = 8236LL;
  v171._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v171);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v172 = (uint64_t)v281;
  v139(17LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v172,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v173._unint64_t countAndFlagsBits = 8236LL;
  v173._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v173);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v174 = (uint64_t)v282;
  v139(18LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v174,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v175._unint64_t countAndFlagsBits = 8236LL;
  v175._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v175);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v176 = (uint64_t)v283;
  v139(19LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v176,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v177._unint64_t countAndFlagsBits = 8236LL;
  v177._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v177);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v178 = (uint64_t)v284;
  v139(20LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v178,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v179._unint64_t countAndFlagsBits = 8236LL;
  v179._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v179);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v180 = (uint64_t)v285;
  v139(21LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v180,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v181._unint64_t countAndFlagsBits = 8236LL;
  v181._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v181);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v182 = (uint64_t)v286;
  v139(22LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v182,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v183._unint64_t countAndFlagsBits = 8236LL;
  v183._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v183);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v184 = (uint64_t)v287;
  v139(23LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v184,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v185._unint64_t countAndFlagsBits = 8236LL;
  v185._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v185);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v186 = (uint64_t)v288;
  v139(24LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v186,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v187._unint64_t countAndFlagsBits = 8236LL;
  v187._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v187);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v188 = (uint64_t)v289;
  v139(25LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v188,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v189._unint64_t countAndFlagsBits = 8236LL;
  v189._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v189);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v190 = (uint64_t)v290;
  v139(26LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v190,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v191._unint64_t countAndFlagsBits = 8236LL;
  v191._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v191);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v192 = (uint64_t)v291;
  v139(27LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v192,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v193._unint64_t countAndFlagsBits = 8236LL;
  v193._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v193);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v194 = (uint64_t)v292;
  v139(28LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v194,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v195._unint64_t countAndFlagsBits = 8236LL;
  v195._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v195);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v196 = (uint64_t)v293;
  v139(29LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v196,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v197._unint64_t countAndFlagsBits = 8236LL;
  v197._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v197);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v198 = (uint64_t)v294;
  v139(30LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v198,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v199._unint64_t countAndFlagsBits = 8236LL;
  v199._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v199);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v200 = (uint64_t)v295;
  v139(31LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v200,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v201._unint64_t countAndFlagsBits = 8236LL;
  v201._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v201);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v202 = (uint64_t)v296;
  v139(32LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v202,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v203._unint64_t countAndFlagsBits = 8236LL;
  v203._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v203);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v204 = (uint64_t)v297;
  v139(33LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v204,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v205._unint64_t countAndFlagsBits = 8236LL;
  v205._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v205);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v206 = (uint64_t)v298;
  v139(34LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v206,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v207._unint64_t countAndFlagsBits = 8236LL;
  v207._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v207);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v208 = (uint64_t)v299;
  v139(35LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v208,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v209._unint64_t countAndFlagsBits = 8236LL;
  v209._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v209);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v210 = (uint64_t)v300;
  v139(36LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v210,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v211._unint64_t countAndFlagsBits = 8236LL;
  v211._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v211);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v212 = (uint64_t)v301;
  v139(37LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v212,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v213._unint64_t countAndFlagsBits = 8236LL;
  v213._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v213);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v214 = (uint64_t)v302;
  v139(38LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v214,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v215._unint64_t countAndFlagsBits = 8236LL;
  v215._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v215);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v216 = (uint64_t)v303;
  v139(39LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v216,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v217._unint64_t countAndFlagsBits = 8236LL;
  v217._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v217);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v218 = (uint64_t)v304;
  v139(40LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v218,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v219._unint64_t countAndFlagsBits = 8236LL;
  v219._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v219);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v220 = (uint64_t)v305;
  v139(41LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v220,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v221._unint64_t countAndFlagsBits = 8236LL;
  v221._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v221);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v222 = (uint64_t)v306;
  v139(42LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v222,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v223._unint64_t countAndFlagsBits = 8236LL;
  v223._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v223);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v224 = (uint64_t)v307;
  v139(43LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v224,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v225._unint64_t countAndFlagsBits = 8236LL;
  v225._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v225);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v226 = (uint64_t)v308;
  v139(44LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v226,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v227._unint64_t countAndFlagsBits = 8236LL;
  v227._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v227);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v228 = (uint64_t)v309;
  v139(45LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v228,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v229._unint64_t countAndFlagsBits = 8236LL;
  v229._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v229);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v230 = (uint64_t)v310;
  v139(46LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v230,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v231._unint64_t countAndFlagsBits = 8236LL;
  v231._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v231);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v232 = (uint64_t)v311;
  v139(47LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v232,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v233._unint64_t countAndFlagsBits = 8236LL;
  v233._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v233);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v234 = (uint64_t)v312;
  v139(48LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v234,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v235._unint64_t countAndFlagsBits = 8236LL;
  v235._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v235);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v236 = (uint64_t)v313;
  v139(49LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v236,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v237._unint64_t countAndFlagsBits = 8236LL;
  v237._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v237);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v238 = (uint64_t)v314;
  v139(50LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v238,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v239._unint64_t countAndFlagsBits = 8236LL;
  v239._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v239);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v240 = (uint64_t)v315;
  v139(51LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v240,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v241._unint64_t countAndFlagsBits = 8236LL;
  v241._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v241);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v242 = (uint64_t)v316;
  v139(52LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v242,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v243._unint64_t countAndFlagsBits = 8236LL;
  v243._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v243);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v244 = (uint64_t)v317;
  v139(53LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v244,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v245._unint64_t countAndFlagsBits = 8236LL;
  v245._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v245);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v246 = (uint64_t)v318;
  v139(54LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v246,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v247._unint64_t countAndFlagsBits = 8236LL;
  v247._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v247);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v248 = (uint64_t)v319;
  v139(55LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v248,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v249._unint64_t countAndFlagsBits = 8236LL;
  v249._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v249);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v250 = (uint64_t)v320;
  v139(56LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v250,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v251._unint64_t countAndFlagsBits = 8236LL;
  v251._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v251);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v252 = (uint64_t)v321;
  v139(57LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v252,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v253._unint64_t countAndFlagsBits = 8236LL;
  v253._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v253);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v254 = (uint64_t)v322;
  v139(58LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v254,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v255._unint64_t countAndFlagsBits = 8236LL;
  v255._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v255);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v256 = (uint64_t)v323;
  v139(59LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v256,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v257._unint64_t countAndFlagsBits = 8236LL;
  v257._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v257);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v258 = (uint64_t)v324;
  v139(60LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v258,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v259._unint64_t countAndFlagsBits = 8236LL;
  v259._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v259);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v260 = (uint64_t)v325;
  v139(61LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v260,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v261._unint64_t countAndFlagsBits = 8236LL;
  v261._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v261);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v262 = (uint64_t)v326;
  v139(62LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v262,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v263._unint64_t countAndFlagsBits = 8236LL;
  v263._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v263);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v264 = (uint64_t)v327;
  v139(63LL, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v264,  (uint64_t)v328,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v265._unint64_t countAndFlagsBits = 41LL;
  v265._unint64_t object = (void *)0xE100000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v265);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v328[0];
}

uint64_t SIMD64<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v31 = a7;
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v36 = a3;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, void, uint64_t))(*(void *)(v34 + 16) + 72LL))( v14,  v36,  *(void *)(v35 + 8),  a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v32,  AssociatedConformanceWitness);
  }

  while (v24 != 64);
  uint64_t v28 = type metadata accessor for SIMD64(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v31 = a7;
  uint64_t v34 = a6;
  uint64_t v35 = a8;
  uint64_t v37 = a1;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v17,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = v31;
  unint64_t v22 = swift_getAssociatedTypeWitness( 255LL,  v31,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v36 = a3;
  unint64_t v32 = v22;
  unint64_t v23 = swift_getAssociatedConformanceWitness( (uint64_t)v21,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v24 = 0LL;
  uint64_t v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    uint64_t v26 = swift_checkMetadataState(0LL, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v16,  v24++,  v33,  AssociatedConformanceWitness);
  }

  while (v24 != 64);
  uint64_t v28 = type metadata accessor for SIMD64(0LL, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v28 - 8) + 8LL))(v37, v28);
}

uint64_t SIMD3._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage,  a2);
}

uint64_t SIMD3._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t EnumeratedSequence.Iterator._base.setter(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a2 + 24), *(void *)(a2 + 16), a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( v4,  a1,  AssociatedTypeWitness);
}

uint64_t (*SIMD3._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD3.scalarCount.getter()
{
  return 3LL;
}

uint64_t key path getter for SIMD3.subscript(_:) : <A>SIMD3<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x587uLL,  0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(const char **)((char *)a2 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD3.subscript(_:) : <A>SIMD3<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x58BuLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD3.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x587uLL,  0);
  }
  uint64_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

void SIMD2.subscript.modify(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (*a1)[6];
  uint64_t v4 = (*a1)[7];
  uint64_t v6 = (void *)(*a1)[4];
  uint64_t v5 = (void *)(*a1)[5];
  uint64_t v7 = (void *)(*a1)[3];
  uint64_t v8 = **a1;
  if ((a2 & 1) != 0) {
    size_t v9 = (void *)(*a1)[3];
  }
  else {
    size_t v9 = (void *)(*a1)[4];
  }
  memcpy(v9, v5, (*a1)[2]);
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v3 + 64))(v9, v8, v4, v3);
  free(v5);
  free(v6);
  free(v7);
  free(v2);
}

uint64_t SIMD3.init(_:_:_:)(const void *a1, const void *a2, const void *a3, uint64_t a4, const char *a5)
{
  size_t v10 = *(void *)(*(void *)(a4 - 8) + 64LL);
  MEMORY[0x1895F8858](a1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, v10);
  uint64_t v14 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v14((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), 0LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), a2, v10);
  v14((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), 1LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), a3, v10);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v14)( (char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL),  2LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD3.x.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  0LL);
}

uint64_t SIMD3.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  0LL);
}

void (*SIMD3.x.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  uint64_t v11 = *(void (**)(void, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(0LL, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

uint64_t SIMD3.y.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  1LL);
}

uint64_t SIMD3.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  1LL);
}

void (*SIMD3.y.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  uint64_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(1LL, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

uint64_t SIMD3.z.getter(uint64_t a1)
{
  return SIMD2.x.getter( a1,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  2LL);
}

uint64_t SIMD2.x.getter(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a2);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a3);
  uint64_t v12 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  size_t v10 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v12(a4, v10, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD2.x : <A>SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = *(void *)(a3 + a2 - 16);
  size_t v9 = *(const char **)(a3 + a2 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a5);
  uint64_t v12 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v12(a6, v13, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD2.x : <A>SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a4 + a3 - 16);
  uint64_t v11 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v21 - v12;
  memcpy((char *)&v21 - v12, v14, v15);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  v10,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v11,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a6);
  uint64_t v18 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 64);
  uint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v18(v13, a7, v19, AssociatedConformanceWitness);
}

uint64_t SIMD3.z.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage,  2LL);
}

uint64_t SIMD2.x.setter(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  memcpy(v11, v12, v10);
  uint64_t v13 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  v9,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v13,  v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a4);
  uint64_t v16 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 64);
  uint64_t v17 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v16(v11, a5, v17, AssociatedConformanceWitness);
}

void (*SIMD3.z.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64LL);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  uint64_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v5[5] = v12;
  v11(2LL, v12, AssociatedConformanceWitness);
  return SIMD4.z.modify;
}

void SIMD2.x.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v6 = *(void *)(*(void *)a1 + 32LL);
  uint64_t v5 = *(void *)(*(void *)a1 + 40LL);
  uint64_t v8 = *(void **)(*(void *)a1 + 16LL);
  size_t v7 = *(void **)(*(void *)a1 + 24LL);
  memcpy(v8, v7, *(void *)(*(void *)a1 + 8LL));
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v6 + 64))(v8, a3, v5, v6);
  free(v7);
  free(v8);
  free(v4);
}

Swift::Int SIMD3.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD3<A>, a3);
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMD3<A>()
{
  return 3LL;
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD2<A>( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a4);
  return (*(uint64_t (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD3<A>( unint64_t a1, uint64_t a2)
{
  if (a1 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x587uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  size_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD3<A>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x58BuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD3<A>( void *a1, unint64_t a2, uint64_t a3))()
{
  size_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *size_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64LL);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x587uLL,  0);
  }
  size_t v10 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD3<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD3<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD3<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD3<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD3<A>);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = 0LL;
  v7[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v7[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v7[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v7[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, a3);
  SIMD.hash(into:)((uint64_t)v7, a2, WitnessTable);
  return Hasher._finalize()();
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD3<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD3<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD3<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v44 = a2;
  uint64_t v4 = a1;
  uint64_t v39 = *(void *)(a3 + 16);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v42 = (char *)&v37 - v8;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v37 - v13;
  uint64_t v15 = 0LL;
  char v16 = 1;
  uint64_t v18 = v17;
  uint64_t v19 = *(void (**)(void, void, void))(v17 + 16);
  uint64_t v40 = v12;
  uint64_t v41 = v20;
  uint64_t v37 = v19;
  uint64_t v38 = v17;
  uint64_t v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      unint64_t v23 = *(const char **)(v3 + 24);
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
      uint64_t v25 = v11;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
      uint64_t v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v28 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      uint64_t v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      uint64_t v30 = v28;
      uint64_t v19 = v37;
      unint64_t v31 = AssociatedConformanceWitness;
      uint64_t v11 = v25;
      uint64_t v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  v23,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v33 = (uint64_t)v23;
      uint64_t v4 = v40;
      unint64_t v34 = swift_getAssociatedConformanceWitness( v33,  v21,  v32,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      unint64_t v35 = swift_getAssociatedConformanceWitness( v34,  v32,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v18 = v38;
      char v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35 + 8) + 8LL))(v42, v43, v21);
    }

    else
    {
      unint64_t v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      char v16 = 0;
    }

    if (++v15 == 3) {
      break;
    }
    v19(v14, v4, v3);
  }

  return v16 & 1;
}

uint64_t SIMD3<>.init<A>(truncatingIfNeeded:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v45 = a6;
  uint64_t v51 = a4;
  uint64_t v52 = a1;
  uint64_t v49 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v44 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v48 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v18 = (uint64_t)a7;
  uint64_t v46 = a7;
  unint64_t v19 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v50 = a3;
  unint64_t v20 = swift_getAssociatedConformanceWitness( v18,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v21 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v20 + 56);
  unint64_t v42 = v20;
  uint64_t v43 = v21;
  unint64_t v40 = v19;
  unint64_t v22 = swift_checkMetadataState(0LL, v19);
  v21(0LL, v22, v20);
  uint64_t v51 = *(void *)(v51 + 8);
  unint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v51 + 96);
  uint64_t v24 = v44;
  uint64_t v45 = *(void *)(v45 + 8);
  uint64_t v25 = v45;
  v23(v14, a3, v45, a2);
  uint64_t v41 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23;
  unint64_t v26 = v48;
  uint64_t v39 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v39)(v24, 0LL, v48);
  uint64_t v27 = swift_checkMetadataState(0LL, v19);
  unint64_t v29 = v42;
  uint64_t v28 = v43;
  v43(1LL, v27, v42);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23)(v14, v50, v25, a2, v51);
  unint64_t v30 = v26;
  unint64_t v31 = AssociatedConformanceWitness;
  unint64_t v32 = v39;
  v39(v24, 1LL, v30, AssociatedConformanceWitness);
  uint64_t v33 = swift_checkMetadataState(0LL, v40);
  uint64_t v34 = v52;
  v28(2LL, v33, v29);
  uint64_t v35 = v50;
  v41(v14, v50, v45, a2, v51);
  v32(v24, 2LL, v48, v31);
  uint64_t v37 = type metadata accessor for SIMD3(0LL, v35, (uint64_t)v46, v36);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v37 - 8) + 8LL))(v34, v37);
}

uint64_t SIMD3<>.init<A>(clamping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v45 = a6;
  uint64_t v51 = a4;
  uint64_t v52 = a1;
  uint64_t v49 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v44 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v48 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v18 = (uint64_t)a7;
  uint64_t v46 = a7;
  unint64_t v19 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v50 = a3;
  unint64_t v20 = swift_getAssociatedConformanceWitness( v18,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v21 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v20 + 56);
  unint64_t v42 = v20;
  uint64_t v43 = v21;
  unint64_t v40 = v19;
  unint64_t v22 = swift_checkMetadataState(0LL, v19);
  v21(0LL, v22, v20);
  uint64_t v51 = *(void *)(v51 + 8);
  unint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v51 + 104);
  uint64_t v24 = v44;
  uint64_t v45 = *(void *)(v45 + 8);
  uint64_t v25 = v45;
  v23(v14, a3, v45, a2);
  uint64_t v41 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23;
  unint64_t v26 = v48;
  uint64_t v39 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v39)(v24, 0LL, v48);
  uint64_t v27 = swift_checkMetadataState(0LL, v19);
  unint64_t v29 = v42;
  uint64_t v28 = v43;
  v43(1LL, v27, v42);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23)(v14, v50, v25, a2, v51);
  unint64_t v30 = v26;
  unint64_t v31 = AssociatedConformanceWitness;
  unint64_t v32 = v39;
  v39(v24, 1LL, v30, AssociatedConformanceWitness);
  uint64_t v33 = swift_checkMetadataState(0LL, v40);
  uint64_t v34 = v52;
  v28(2LL, v33, v29);
  uint64_t v35 = v50;
  v41(v14, v50, v45, a2, v51);
  v32(v24, 2LL, v48, v31);
  uint64_t v37 = type metadata accessor for SIMD3(0LL, v35, (uint64_t)v46, v36);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v37 - 8) + 8LL))(v34, v37);
}

uint64_t SIMD3<>.init<A>(_:rounding:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v59 = a8;
  uint64_t v60 = a7;
  uint64_t v54 = a5;
  uint64_t v45 = a2;
  uint64_t v58 = a1;
  uint64_t v50 = a9;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v51 = (char *)&v43 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v47 = (char *)&v43 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v18,  v17,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v49 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  unint64_t v20 = v59;
  unint64_t v21 = swift_getAssociatedTypeWitness( 255LL,  v59,  a4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v57 = v21;
  unint64_t v22 = swift_getAssociatedConformanceWitness( (uint64_t)v20,  a4,  v21,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v46 = *(void (**)(void, unint64_t *, unint64_t))(v22 + 56);
  unint64_t v23 = v46;
  uint64_t v24 = swift_checkMetadataState(0LL, v21);
  unint64_t v44 = v22;
  v23(0LL, v24, v22);
  uint64_t v25 = v60;
  unint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v60 + 16) + 304LL);
  uint64_t v55 = *(void *)(v60 + 16);
  uint64_t v56 = v26;
  uint64_t v27 = v51;
  ((void (*)(uint64_t, uint64_t))v26)(a2, a4);
  uint64_t v28 = *(void *)(v54 + 8);
  uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 80);
  uint64_t v54 = v28;
  unint64_t v29 = v47;
  v53(v27, a4, v25, a3);
  unint64_t v30 = v49;
  uint64_t v52 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  unint64_t v31 = v29;
  ((void (*)(char *, void, unint64_t))v52)(v29, 0LL, v49);
  unint64_t v32 = swift_checkMetadataState(0LL, v57);
  unint64_t v33 = v22;
  uint64_t v34 = v46;
  v46(1LL, v32, v33);
  uint64_t v35 = v51;
  uint64_t v36 = v45;
  v56(v45, a4, v55);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v53)(v35, a4, v60, a3, v54);
  unint64_t v37 = AssociatedConformanceWitness;
  v52(v31, 1LL, v30, AssociatedConformanceWitness);
  uint64_t v38 = swift_checkMetadataState(0LL, v57);
  uint64_t v39 = v58;
  v34(2LL, v38, v44);
  v56(v36, a4, v55);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v53)(v35, a4, v60, a3, v54);
  v52(v31, 2LL, v49, v37);
  uint64_t v41 = type metadata accessor for SIMD3(0LL, a4, (uint64_t)v59, v40);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v41 - 8) + 8LL))(v39, v41);
}

uint64_t SIMD3.debugDescription.getter(uint64_t a1)
{
  uint64_t v369 = a1;
  uint64_t v2 = *(swift **)(a1 + 16);
  size_t v3 = *(void *)(*((void *)v2 - 1) + 64LL);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v5 = MEMORY[0x1895F8858](v4);
  v361 = (uint64_t *)((char *)&v352 - v6);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  v364 = (uint64_t *)((char *)&v352 - v8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v367 = (uint64_t *)((char *)&v352 - v10);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v352 - v12;
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  unint64_t v357 = (uint64_t *)((char *)&v352 - v15);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v360 = (uint64_t *)((char *)&v352 - v17);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v363 = (uint64_t *)((char *)&v352 - v19);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v366 = (uint64_t *)((char *)&v352 - v21);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v371 = (char *)&v352 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v356 = (uint64_t *)((char *)&v352 - v25);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v359 = (uint64_t *)((char *)&v352 - v27);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v362 = (uint64_t *)((char *)&v352 - v29);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v365 = (uint64_t *)((char *)&v352 - v31);
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v372 = (uint64_t *)((char *)&v352 - v33);
  MEMORY[0x1895F8858](v32);
  uint64_t v370 = (char *)&v352 - v34;
  unint64_t v35 = specialized static String._createEmpty(withInitialCapacity:)(21LL);
  unint64_t v39 = v35;
  unint64_t v40 = v36;
  unint64_t v379 = v35;
  unint64_t v380 = v36;
  if ((v36 & 0x2000000000000000LL) != 0) {
    uint64_t v41 = HIBYTE(v36) & 0xF;
  }
  else {
    uint64_t v41 = v35 & 0xFFFFFFFFFFFFLL;
  }
  v358 = (uint64_t *)((char *)&v352 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v368 = v1;
  if (!v41 && (v35 & ~v36 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v36);
    unint64_t v379 = 0x3C33444D4953LL;
    unint64_t v380 = 0xE600000000000000LL;
    goto LABEL_25;
  }

  if ((v36 & 0x2000000000000000LL) != 0)
  {
    unint64_t v42 = specialized _SmallString.init(_:appending:)(v35, v36, 0x3C33444D4953uLL, 0xE600000000000000LL);
    if ((v37 & 1) == 0)
    {
      unint64_t v44 = v42;
      unint64_t v45 = v43;
      swift_bridgeObjectRelease(v40);
      swift_bridgeObjectRelease(0xE600000000000000LL);
      unint64_t v379 = v44;
      unint64_t v380 = v45;
      goto LABEL_25;
    }
  }

  swift_bridgeObjectRetain_n(0xE600000000000000LL, 6LL, v37, v38);
  if ((v40 & 0x1000000000000000LL) == 0)
  {
    BOOL v46 = __OFADD__(v41, 6LL);
    int64_t v47 = v41 + 6;
    if (!v46) {
      goto LABEL_11;
    }
LABEL_250:
    __break(1u);
    goto LABEL_251;
  }

  Swift::Int v350 = String.UTF8View._foreignCount()();
  int64_t v47 = v350 + 6;
  if (__OFADD__(v350, 6LL)) {
    goto LABEL_250;
  }
LABEL_11:
  if ((v39 & ~v40 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v40 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v48 = _StringGuts.nativeUnusedCapacity.getter(v39, v40);
    if ((v49 & 1) != 0)
    {
      unint64_t v351 = 258LL;
      goto LABEL_255;
    }

    uint64_t v50 = (v40 >> 61) & 1;
    if (v48 < 6) {
      LODWORD(v50) = 1;
    }
    if (v47 <= 15 && (_DWORD)v50)
    {
LABEL_18:
      uint64_t v51 = v13;
      swift_bridgeObjectRelease_n(0xE600000000000000LL, 5LL);
      swift_bridgeObjectRetain(v40, v52, v53, v54);
      unint64_t v55 = _StringGuts._convertedToSmall()(v39, v40);
      unint64_t v57 = v56;
      swift_bridgeObjectRelease(v40);
      v58._rawBits = 1LL;
      v59._rawBits = 393217LL;
      v60._rawBits = _StringGuts.validateScalarRange(_:)(v58, v59, 0x3C33444D4953uLL, 0xE600000000000000LL);
      if (v60._rawBits < 0x10000) {
        v60._rawBits |= 3;
      }
      unint64_t v62 = specialized String.init(_:)(v60, v61, 0x3C33444D4953uLL, 0xE600000000000000LL);
      unint64_t v64 = v63;
      swift_bridgeObjectRelease(0xE600000000000000LL);
      unint64_t v65 = _StringGuts._convertedToSmall()(v62, v64);
      unint64_t v67 = v66;
      swift_bridgeObjectRelease(v64);
      unint64_t v68 = specialized _SmallString.init(_:appending:)(v55, v57, v65, v67);
      if ((v70 & 1) == 0)
      {
        unint64_t v71 = v68;
        unint64_t v72 = v69;
        swift_bridgeObjectRelease(v40);
        swift_bridgeObjectRelease(0xE600000000000000LL);
        unint64_t v379 = v71;
        unint64_t v380 = v72;
        uint64_t v13 = v51;
        goto LABEL_25;
      }

      unint64_t v351 = 266LL;
LABEL_255:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v351,  0);
    }
  }

  else if (v47 <= 15)
  {
    goto LABEL_18;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v47, 6LL);
  swift_bridgeObjectRelease_n(0xE600000000000000LL, 6LL);
  Swift::String v373 = (Swift::String)xmmword_181800020;
  uint64_t v73 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 6LL, (uint64_t)&v373, 6LL);
  _StringGuts.appendInPlace(_:isASCII:)(v73, v74, 1);
  swift_bridgeObjectRelease(0xE600000000000000LL);
LABEL_25:
  TypeName = (uint8x16_t *)swift_getTypeName((unint64_t)v2, 0);
  if (v76 < 0) {
    goto LABEL_247;
  }
  size_t v79 = v76;
  if (!v76)
  {
    uint64_t countAndFlagsBits = 0LL;
    unint64_t object = 0xE000000000000000LL;
    goto LABEL_143;
  }

  uint64_t v80 = (uint64_t *)TypeName;
  uint64_t v81 = TypeName;
  if ((v76 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080LL) != 0) {
      goto LABEL_47;
    }
    uint64_t v81 = TypeName + 1;
    while (v81 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFF0LL])
    {
      uint64_t v82 = v81->i64[0];
      uint64_t v83 = v81->i64[1];
      ++v81;
      if (((v83 | v82) & 0x8080808080808080LL) != 0) {
        goto LABEL_47;
      }
    }
  }

  if (v81 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFF8LL])
  {
    if ((v81->i64[0] & 0x8080808080808080LL) != 0) {
      goto LABEL_47;
    }
    uint64_t v81 = (uint8x16_t *)((char *)v81 + 8);
  }

  if (v81 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v81->i32[0] & 0x80808080) != 0) {
      goto LABEL_47;
    }
    uint64_t v81 = (uint8x16_t *)((char *)v81 + 4);
  }

  if (v81 >= (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_43:
    if (v81 >= (uint8x16_t *)&TypeName->i8[v76] || (v81->i8[0] & 0x80000000) == 0)
    {
      if (v76 > 15)
      {
        char v86 = 1;
LABEL_106:
        unint64_t object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( TypeName->i8,  v76,  v76,  v86 & 1);
        uint64_t countAndFlagsBits = *(void *)(object + 24);
        goto LABEL_143;
      }

uint64_t SIMD3<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v45 = a6;
  uint64_t v51 = a4;
  uint64_t v52 = a1;
  uint64_t v49 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v44 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v48 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v18 = (uint64_t)a7;
  BOOL v46 = a7;
  unint64_t v19 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v50 = a3;
  unint64_t v20 = swift_getAssociatedConformanceWitness( v18,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v21 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v20 + 56);
  unint64_t v42 = v20;
  unint64_t v43 = v21;
  unint64_t v40 = v19;
  uint64_t v22 = swift_checkMetadataState(0LL, v19);
  v21(0LL, v22, v20);
  uint64_t v51 = *(void *)(v51 + 16);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v51 + 72);
  uint64_t v24 = v44;
  uint64_t v45 = *(void *)(v45 + 8);
  uint64_t v25 = v45;
  v23(v14, a3, v45, a2);
  uint64_t v41 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23;
  unint64_t v26 = v48;
  unint64_t v39 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, unint64_t))v39)(v24, 0LL, v48);
  uint64_t v27 = swift_checkMetadataState(0LL, v19);
  unint64_t v29 = v42;
  uint64_t v28 = v43;
  v43(1LL, v27, v42);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23)(v14, v50, v25, a2, v51);
  unint64_t v30 = v26;
  unint64_t v31 = AssociatedConformanceWitness;
  uint64_t v32 = v39;
  v39(v24, 1LL, v30, AssociatedConformanceWitness);
  uint64_t v33 = swift_checkMetadataState(0LL, v40);
  uint64_t v34 = v52;
  v28(2LL, v33, v29);
  uint64_t v35 = v50;
  v41(v14, v50, v45, a2, v51);
  v32(v24, 2LL, v48, v31);
  uint64_t v37 = type metadata accessor for SIMD3(0LL, v35, (uint64_t)v46, v36);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v37 - 8) + 8LL))(v34, v37);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  void (*v22)(void, unint64_t *, unint64_t);
  unint64_t *v23;
  char *v24;
  uint64_t v25;
  void (*v26)(char *, uint64_t, uint64_t, uint64_t);
  char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  void (*v31)(uint64_t, unint64_t *, unint64_t);
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v36)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  void (*v43)(char *, uint64_t, unint64_t, unint64_t);
  void (*v44)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  void (*v45)(void, unint64_t *, unint64_t);
  char *v46;
  const char *v47;
  unint64_t AssociatedConformanceWitness;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v54 = a4;
  unint64_t v55 = a6;
  uint64_t v53 = a1;
  uint64_t v50 = a8;
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  BOOL v46 = (char *)&v42 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v42 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v16,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v49 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  int64_t v47 = a7;
  uint64_t v18 = swift_getAssociatedTypeWitness( 255LL,  a7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v19 = (uint64_t)a7;
  unint64_t v20 = a3;
  uint64_t v51 = v18;
  uint64_t v21 = swift_getAssociatedConformanceWitness( v19,  a3,  v18,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v45 = *(void (**)(void, unint64_t *, unint64_t))(v21 + 56);
  uint64_t v22 = v45;
  uint64_t v52 = v21;
  uint64_t v23 = swift_checkMetadataState(0LL, v18);
  uint64_t v24 = v46;
  v22(0LL, v23, v21);
  uint64_t v25 = v55;
  unint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v54 + 80);
  uint64_t v27 = v15;
  uint64_t v28 = v20;
  v26(v24, v20, v55, a2);
  unint64_t v29 = v49;
  unint64_t v43 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  unint64_t v44 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v26;
  ((void (*)(char *, void, unint64_t))v43)(v15, 0LL, v49);
  unint64_t v30 = swift_checkMetadataState(0LL, v51);
  unint64_t v31 = v45;
  v45(1LL, v30, v52);
  uint64_t v32 = v25;
  uint64_t v33 = v54;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v26)(v24, v28, v32, a2, v54);
  uint64_t v34 = v29;
  uint64_t v35 = AssociatedConformanceWitness;
  uint64_t v36 = v43;
  v43(v27, 1LL, v34, AssociatedConformanceWitness);
  uint64_t v37 = swift_checkMetadataState(0LL, v51);
  uint64_t v38 = v53;
  v31(2LL, v37, v52);
  v44(v24, v28, v55, a2, v33);
  v36(v27, 2LL, v49, v35);
  unint64_t v40 = type metadata accessor for SIMD3(0LL, v28, (uint64_t)v47, v39);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v40 - 8) + 8LL))(v38, v40);
}

uint64_t UInt8.SIMD2Storage._value.setter(uint64_t result)
{
  _WORD *v1 = result;
  return result;
}

uint64_t (*UInt8.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

uint64_t UInt8.SIMD2Storage.init()()
{
  return 0LL;
}

uint64_t (*UInt8.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  double v5 = a3;
  *(_BYTE *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD2Storage( uint64_t a1, uint64_t a2, double a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  double v5 = a3;
  *(_BYTE *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t UInt8.SIMD4Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*UInt8.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

uint64_t UInt8.SIMD4Storage.init()()
{
  return 0LL;
}

uint64_t (*UInt8.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  unint64_t v5 = vmovl_u8(a3).u64[0];
  *(_BYTE *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9LL | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD4Storage( uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  unint64_t v5 = vmovl_u8(a3).u64[0];
  *(_BYTE *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9LL | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

void UInt8.SIMD8Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*UInt8.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double UInt8.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD8Storage@<D0>(void *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0LL;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD8Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

void UInt8.SIMD16Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt8.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double UInt8.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD16Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD16Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt8.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double UInt8.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD32Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD32Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt8.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double UInt8.SIMD64Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD64Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t Int8.SIMD2Storage._value.setter(uint64_t result)
{
  _WORD *v1 = result;
  return result;
}

uint64_t (*Int8.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

uint64_t Int8.SIMD2Storage.init()()
{
  return 0LL;
}

uint64_t Int8.SIMD2Storage.subscript.getter(char a1, __int16 a2)
{
  LODWORD(v2) = a2;
  HIDWORD(v2) = HIBYTE(a2);
  uint64_t v4 = v2;
  return *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (a1 & 1)));
}

__n128 key path getter for Int8.SIMD2Storage.subscript(_:) : Int8.SIMD2Storage@<Q0>( _BYTE *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>, double a4@<D0>)
{
  LOBYTE(a4) = *a1;
  BYTE4(a4) = a1[1];
  uint64_t v4 = (_DWORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (*a2 & 1)));
  double v6 = a4;
  *a3 = *v4;
  result.n128_u32[0] = LODWORD(a4);
  result.n128_u8[4] = BYTE4(a4);
  return result;
}

_BYTE *key path setter for Int8.SIMD2Storage.subscript(_:) : Int8.SIMD2Storage( _BYTE *result, uint64_t a2, unsigned int *a3)
{
  *(_BYTE *)(a2 + *a3) = *result;
  return result;
}

uint64_t Int8.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  double v5 = a3;
  *(_BYTE *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD2Storage@<Q0>( char a1@<W0>, _BYTE *a2@<X8>, double a3@<D0>)
{
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  double v5 = a3;
  *a2 = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (a1 & 1)));
  result.n128_u32[0] = LODWORD(a3);
  result.n128_u8[4] = BYTE4(a3);
  return result;
}

_BYTE *protocol witness for SIMDStorage.subscript.setter in conformance Int8.SIMD2Storage( _BYTE *result, unsigned int a2)
{
  *(_BYTE *)(v2 + a2) = *result;
  return result;
}

unsigned int *UInt8.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_BYTE *)(*((void *)result + 1) + *result) = *((_BYTE *)result + 16);
  return result;
}

uint64_t Int8.SIMD4Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*Int8.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

uint64_t Int8.SIMD4Storage.init()()
{
  return 0LL;
}

uint64_t Int8.SIMD4Storage.subscript.getter(char a1, __int32 a2, int8x8_t a3)
{
  a3.i32[0] = a2;
  int8x8_t v4 = vzip1_s8(a3, a3);
  return *(unsigned __int16 *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (a1 & 3)));
}

double key path getter for Int8.SIMD4Storage.subscript(_:) : Int8.SIMD4Storage@<D0>( __int32 *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>, uint8x8_t a4@<D0>)
{
  a4.i32[0] = *a1;
  *(void *)&double result = vmovl_u8(a4).u64[0];
  double v5 = (_WORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (*a2 & 3)));
  double v6 = result;
  *a3 = *v5;
  return result;
}

uint64_t Int8.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  unint64_t v5 = vmovl_u8(a3).u64[0];
  *(_BYTE *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9LL | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD4Storage@<D0>( char a1@<W0>, _BYTE *a2@<X8>, uint8x8_t a3@<D0>)
{
  a3.i32[0] = *v3;
  *(void *)&double result = vmovl_u8(a3).u64[0];
  double v5 = result;
  *a2 = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (a1 & 3)));
  return result;
}

void Int8.SIMD8Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Int8.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Int8.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD8Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(unsigned __int8 *)((unint64_t)&v3 | a1 & 7);
}

double key path getter for Int8.SIMD8Storage.subscript(_:) : Int8.SIMD8Storage@<D0>( double *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  double result = *a1;
  int8x8_t v4 = (_BYTE *)((unint64_t)&v5 | *a2 & 7);
  double v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int8.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD8Storage@<D0>( char a1@<W0>, _BYTE *a2@<X8>)
{
  double result = *v2;
  double v4 = *v2;
  *a2 = *(_BYTE *)((unint64_t)&v4 | a1 & 7);
  return result;
}

void Int8.SIMD16Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int8.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Int8.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD16Storage.subscript.getter(char a1)
{
  return *(unsigned __int8 *)((unint64_t)&v2 | a1 & 0xF);
}

__n128 key path getter for Int8.SIMD16Storage.subscript(_:) : Int8.SIMD16Storage@<Q0>( __n128 *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  __n128 result = *a1;
  double v4 = (_BYTE *)((unint64_t)&v5 | *a2 & 0xF);
  __n128 v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int8.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD16Storage@<Q0>( char a1@<W0>, _BYTE *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *(_BYTE *)((unint64_t)&v4 | a1 & 0xF);
  return result;
}

void Int8.SIMD32Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int8.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Int8.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD32Storage.subscript.getter(char a1)
{
  return *((unsigned __int8 *)&v2 + (a1 & 0x1F));
}

__n128 key path getter for Int8.SIMD32Storage.subscript(_:) : Int8.SIMD32Storage@<Q0>( __n128 *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  __n128 result = *a1;
  *a3 = *((_BYTE *)&v4 + (*a2 & 0x1F));
  return result;
}

uint64_t Int8.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD32Storage@<Q0>( char a1@<W0>, _BYTE *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *((_BYTE *)&v4 + (a1 & 0x1F));
  return result;
}

void Int8.SIMD64Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  __n128 *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int8.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Int8.SIMD64Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD64Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned __int8 *)v6 + (a1 & 0x3F));
}

__n128 key path getter for Int8.SIMD64Storage.subscript(_:) : Int8.SIMD64Storage@<Q0>( uint64_t a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  __int128 v4 = *(_OWORD *)(a1 + 16);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  uint64_t v6 = *a2 & 0x3F;
  v7[2] = *(_OWORD *)(a1 + 32);
  v7[3] = v5;
  v7[0] = result;
  v7[1] = v4;
  *a3 = *((_BYTE *)v7 + v6);
  return result;
}

uint64_t Int8.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD64Storage@<Q0>( char a1@<W0>, _BYTE *a2@<X8>)
{
  __n128 result = *(__n128 *)v2;
  __int128 v4 = *(_OWORD *)(v2 + 16);
  __int128 v5 = *(_OWORD *)(v2 + 48);
  v6[2] = *(_OWORD *)(v2 + 32);
  v6[3] = v5;
  v6[0] = result;
  v6[1] = v4;
  *a2 = *((_BYTE *)v6 + (a1 & 0x3F));
  return result;
}

uint64_t UInt16.SIMD2Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*UInt16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

uint64_t UInt16.SIMD2Storage.init()()
{
  return 0LL;
}

uint64_t (*UInt16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  double v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD2Storage( uint64_t a1, uint64_t a2, double a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  double v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

void UInt16.SIMD4Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*UInt16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double UInt16.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9LL | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD4Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9LL | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

void UInt16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double UInt16.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1LL | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD8Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1LL | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double UInt16.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD16Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double UInt16.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD32Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double UInt16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[2];
  __int128 v6 = v2[3];
  __int128 v7 = v2[4];
  __int128 v8 = v2[5];
  __int128 v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt16.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD64Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[2];
  __int128 v6 = v2[3];
  __int128 v7 = v2[4];
  __int128 v8 = v2[5];
  __int128 v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t Int16.SIMD2Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*Int16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

uint64_t Int16.SIMD2Storage.init()()
{
  return 0LL;
}

uint64_t Int16.SIMD2Storage.subscript.getter(char a1, __int32 a2, uint16x4_t a3)
{
  a3.i32[0] = a2;
  unint64_t v4 = vmovl_u16(a3).u64[0];
  return *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (a1 & 1)));
}

__n128 key path getter for Int16.SIMD2Storage.subscript(_:) : Int16.SIMD2Storage@<Q0>( _WORD *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>, double a4@<D0>)
{
  LOWORD(a4) = *a1;
  WORD2(a4) = a1[1];
  unint64_t v4 = (_DWORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (*a2 & 1)));
  double v6 = a4;
  *a3 = *v4;
  result.n128_u32[0] = LODWORD(a4);
  result.n128_u16[2] = WORD2(a4);
  return result;
}

_WORD *key path setter for Int16.SIMD2Storage.subscript(_:) : Int16.SIMD2Storage( _WORD *result, uint64_t a2, unsigned int *a3)
{
  *(_WORD *)(a2 + 2LL * *a3) = *result;
  return result;
}

uint64_t Int16.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2LL * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  double v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD2Storage@<Q0>( char a1@<W0>, _WORD *a2@<X8>, double a3@<D0>)
{
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  double v5 = a3;
  *a2 = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (a1 & 1)));
  result.n128_u32[0] = LODWORD(a3);
  result.n128_u16[2] = WORD2(a3);
  return result;
}

_WORD *protocol witness for SIMDStorage.subscript.setter in conformance Int16.SIMD2Storage( _WORD *result, unsigned int a2)
{
  *(_WORD *)(v2 + 2LL * a2) = *result;
  return result;
}

unsigned int *UInt16.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_WORD *)(*((void *)result + 1) + 2LL * *result) = *((_WORD *)result + 8);
  return result;
}

void Int16.SIMD4Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Int16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double Int16.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD4Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(unsigned __int16 *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (a1 & 3)));
}

double key path getter for Int16.SIMD4Storage.subscript(_:) : Int16.SIMD4Storage@<D0>( double *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  double result = *a1;
  unint64_t v4 = (_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (*a2 & 3)));
  double v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int16.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2LL * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9LL | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD4Storage@<D0>( char a1@<W0>, _WORD *a2@<X8>)
{
  double result = *v2;
  double v4 = *v2;
  *a2 = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (a1 & 3)));
  return result;
}

void Int16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Int16.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD8Storage.subscript.getter(char a1)
{
  return *(unsigned __int16 *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF1LL | (2LL * (a1 & 7)));
}

__n128 key path getter for Int16.SIMD8Storage.subscript(_:) : Int16.SIMD8Storage@<Q0>( __n128 *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *a1;
  double v4 = (_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF1LL | (2LL * (*a2 & 7)));
  __n128 v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int16.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2LL * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1LL | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD8Storage@<Q0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1LL | (2LL * (a1 & 7)));
  return result;
}

void Int16.SIMD16Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Int16.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD16Storage.subscript.getter(char a1)
{
  return *((unsigned __int16 *)&v2 + (a1 & 0xF));
}

__n128 key path getter for Int16.SIMD16Storage.subscript(_:) : Int16.SIMD16Storage@<Q0>( __n128 *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *a1;
  *a3 = *((_WORD *)&v4 + (*a2 & 0xF));
  return result;
}

uint64_t Int16.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2LL * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD16Storage@<Q0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *((_WORD *)&v4 + (a1 & 0xF));
  return result;
}

void Int16.SIMD32Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  __n128 *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Int16.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD32Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned __int16 *)v6 + (a1 & 0x1F));
}

__n128 key path getter for Int16.SIMD32Storage.subscript(_:) : Int16.SIMD32Storage@<Q0>( uint64_t a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  __int128 v4 = *(_OWORD *)(a1 + 16);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  uint64_t v6 = *a2 & 0x1F;
  v7[2] = *(_OWORD *)(a1 + 32);
  v7[3] = v5;
  v7[0] = result;
  v7[1] = v4;
  *a3 = *((_WORD *)v7 + v6);
  return result;
}

uint64_t Int16.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2LL * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD32Storage@<Q0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *(__n128 *)v2;
  __int128 v4 = *(_OWORD *)(v2 + 16);
  __int128 v5 = *(_OWORD *)(v2 + 48);
  v6[2] = *(_OWORD *)(v2 + 32);
  v6[3] = v5;
  v6[0] = result;
  v6[1] = v4;
  *a2 = *((_WORD *)v6 + (a1 & 0x1F));
  return result;
}

__n128 Int16.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int16.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Int16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int16.SIMD64Storage.subscript.getter(char a1)
{
  __int128 v2 = *v1;
  __int128 v3 = v1[1];
  __int128 v4 = v1[2];
  __int128 v5 = v1[3];
  __int128 v6 = v1[4];
  __int128 v7 = v1[5];
  __int128 v8 = v1[7];
  v10[6] = v1[6];
  v10[7] = v8;
  v10[4] = v6;
  v10[5] = v7;
  v10[2] = v4;
  v10[3] = v5;
  v10[0] = v2;
  v10[1] = v3;
  return *((unsigned __int16 *)v10 + (a1 & 0x3F));
}

__n128 key path getter for Int16.SIMD64Storage.subscript(_:) : Int16.SIMD64Storage@<Q0>( uint64_t a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  __int128 v4 = *(_OWORD *)(a1 + 16);
  __int128 v5 = *(_OWORD *)(a1 + 32);
  __int128 v6 = *(_OWORD *)(a1 + 48);
  __int128 v7 = *(_OWORD *)(a1 + 64);
  __int128 v8 = *(_OWORD *)(a1 + 80);
  __int128 v9 = *(_OWORD *)(a1 + 112);
  uint64_t v10 = *a2 & 0x3F;
  v11[6] = *(_OWORD *)(a1 + 96);
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = result;
  v11[1] = v4;
  *a3 = *((_WORD *)v11 + v10);
  return result;
}

uint64_t Int16.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2LL * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  __int128 v3 = *v2;
  __int128 v4 = v2[1];
  __int128 v5 = v2[2];
  __int128 v6 = v2[3];
  __int128 v7 = v2[4];
  __int128 v8 = v2[5];
  __int128 v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD64Storage@<Q0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *(__n128 *)v2;
  __int128 v4 = *(_OWORD *)(v2 + 16);
  __int128 v5 = *(_OWORD *)(v2 + 32);
  __int128 v6 = *(_OWORD *)(v2 + 48);
  __int128 v7 = *(_OWORD *)(v2 + 64);
  __int128 v8 = *(_OWORD *)(v2 + 80);
  __int128 v9 = *(_OWORD *)(v2 + 112);
  v10[6] = *(_OWORD *)(v2 + 96);
  v10[7] = v9;
  v10[4] = v7;
  v10[5] = v8;
  v10[2] = v5;
  v10[3] = v6;
  v10[0] = result;
  v10[1] = v4;
  *a2 = *((_WORD *)v10 + (a1 & 0x3F));
  return result;
}

void UInt32.SIMD2Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*UInt32.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double UInt32.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD2Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

void UInt32.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt32.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double UInt32.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD4Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double UInt32.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD8Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double UInt32.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD16Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double UInt32.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt32.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD32Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double UInt32.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt32.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt32.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD64Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

void Int32.SIMD2Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Int32.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double Int32.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD2Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(unsigned int *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (a1 & 1)));
}

uint64_t key path getter for Int32.SIMD2Storage.subscript(_:) : Int32.SIMD2Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 1LL));
  return result;
}

_DWORD *key path setter for Int32.SIMD2Storage.subscript(_:) : Int32.SIMD2Storage( _DWORD *result, uint64_t a2, unsigned int *a3)
{
  *(_DWORD *)(a2 + 4LL * *a3) = *result;
  return result;
}

uint64_t Int32.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4LL * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD2Storage@<X0>( uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 1));
  return result;
}

_DWORD *protocol witness for SIMDStorage.subscript.setter in conformance Int32.SIMD2Storage( _DWORD *result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4LL * a2) = *result;
  return result;
}

unsigned int *UInt32.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_DWORD *)(*((void *)result + 1) + 4LL * *result) = result[4];
  return result;
}

void Int32.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int32.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double Int32.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD4Storage.subscript.getter(char a1)
{
  return *(unsigned int *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF3LL | (4LL * (a1 & 3)));
}

uint64_t key path getter for Int32.SIMD4Storage.subscript(_:) : Int32.SIMD4Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 3LL));
  return result;
}

uint64_t Int32.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4LL * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD4Storage@<X0>( uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 3));
  return result;
}

void Int32.SIMD8Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int32.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Int32.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD8Storage.subscript.getter(char a1)
{
  return *((unsigned int *)&v2 + (a1 & 7));
}

uint64_t key path getter for Int32.SIMD8Storage.subscript(_:) : Int32.SIMD8Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 7LL));
  return result;
}

uint64_t Int32.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4LL * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD8Storage@<X0>( uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 7));
  return result;
}

void Int32.SIMD16Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  __n128 *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int32.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Int32.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD16Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned int *)v6 + (a1 & 0xF));
}

uint64_t key path getter for Int32.SIMD16Storage.subscript(_:) : Int32.SIMD16Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0xFLL));
  return result;
}

uint64_t Int32.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4LL * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD16Storage@<X0>( uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 0xF));
  return result;
}

__n128 Int32.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int32.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int32.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Int32.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int32.SIMD32Storage.subscript.getter(char a1)
{
  return *(unsigned int *)(v1 + 4LL * (a1 & 0x1F));
}

uint64_t key path getter for Int32.SIMD32Storage.subscript(_:) : Int32.SIMD32Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0x1FLL));
  return result;
}

uint64_t Int32.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4LL * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD32Storage@<X0>( uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 0x1F));
  return result;
}

__n128 Int32.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 96);
  __int128 v9 = *(_OWORD *)(v1 + 112);
  __int128 v10 = *(_OWORD *)(v1 + 128);
  __int128 v11 = *(_OWORD *)(v1 + 144);
  __int128 v12 = *(_OWORD *)(v1 + 160);
  __int128 v13 = *(_OWORD *)(v1 + 176);
  __int128 v14 = *(_OWORD *)(v1 + 192);
  __int128 v15 = *(_OWORD *)(v1 + 208);
  __int128 v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int32.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  __int128 v9 = *(_OWORD *)(a1 + 112);
  __int128 v10 = *(_OWORD *)(a1 + 128);
  __int128 v11 = *(_OWORD *)(a1 + 144);
  __int128 v12 = *(_OWORD *)(a1 + 160);
  __int128 v13 = *(_OWORD *)(a1 + 176);
  __int128 v14 = *(_OWORD *)(a1 + 192);
  __int128 v15 = *(_OWORD *)(a1 + 208);
  __int128 v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int32.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Int32.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int32.SIMD64Storage.subscript.getter(char a1)
{
  return *(unsigned int *)(v1 + 4LL * (a1 & 0x3F));
}

uint64_t key path getter for Int32.SIMD64Storage.subscript(_:) : Int32.SIMD64Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0x3FLL));
  return result;
}

uint64_t Int32.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4LL * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD64Storage@<X0>( uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 0x3F));
  return result;
}

void UInt64.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt64.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double UInt64.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD2Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double UInt64.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD4Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double UInt64.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD8Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double UInt64.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD16Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double UInt64.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD32Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double UInt64.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt64.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD64Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void Int64.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int64.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double Int64.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double Int64.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Int64.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Int64.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Int64.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Int64.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void UInt.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double UInt.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double UInt.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double UInt.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double UInt.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double UInt.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double UInt.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void Int.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double Int.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD2Storage.subscript.getter(char a1)
{
  return *(void *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF7LL | (8LL * (a1 & 1)));
}

uint64_t key path getter for Int.SIMD2Storage.subscript(_:) : Int.SIMD2Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 1LL));
  return result;
}

void *key path setter for Int.SIMD2Storage.subscript(_:) : Int.SIMD2Storage( void *result, uint64_t a2, unsigned int *a3)
{
  *(void *)(a2 + 8LL * *a3) = *result;
  return result;
}

uint64_t Int.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8LL * a2) = result;
  return result;
}

uint64_t (*Int.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD2Storage@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 1));
  return result;
}

void *protocol witness for SIMDStorage.subscript.setter in conformance Int.SIMD2Storage( void *result, unsigned int a2)
{
  *(void *)(v2 + 8LL * a2) = *result;
  return result;
}

uint64_t UInt64.SIMD2Storage.subscript.modify(uint64_t result)
{
  *(void *)(*(void *)(result + 16) + 8LL * *(unsigned int *)(result + 8)) = *(void *)result;
  return result;
}

void Int.SIMD4Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double Int.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD4Storage.subscript.getter(char a1)
{
  return *((void *)&v2 + (a1 & 3));
}

uint64_t key path getter for Int.SIMD4Storage.subscript(_:) : Int.SIMD4Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 3LL));
  return result;
}

uint64_t Int.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8LL * a2) = result;
  return result;
}

uint64_t (*Int.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD4Storage@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 3));
  return result;
}

void Int.SIMD8Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  __n128 *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Int.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD8Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((void *)v6 + (a1 & 7));
}

uint64_t key path getter for Int.SIMD8Storage.subscript(_:) : Int.SIMD8Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 7LL));
  return result;
}

uint64_t Int.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8LL * a2) = result;
  return result;
}

uint64_t (*Int.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD8Storage@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 7));
  return result;
}

__n128 Int.SIMD16Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD16Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Int.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD16Storage.subscript.getter(char a1)
{
  return *(void *)(v1 + 8LL * (a1 & 0xF));
}

uint64_t key path getter for Int.SIMD16Storage.subscript(_:) : Int.SIMD16Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 0xFLL));
  return result;
}

uint64_t Int.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8LL * a2) = result;
  return result;
}

uint64_t (*Int.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD16Storage@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 0xF));
  return result;
}

__n128 Int.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 96);
  __int128 v9 = *(_OWORD *)(v1 + 112);
  __int128 v10 = *(_OWORD *)(v1 + 128);
  __int128 v11 = *(_OWORD *)(v1 + 144);
  __int128 v12 = *(_OWORD *)(v1 + 160);
  __int128 v13 = *(_OWORD *)(v1 + 176);
  __int128 v14 = *(_OWORD *)(v1 + 192);
  __int128 v15 = *(_OWORD *)(v1 + 208);
  __int128 v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  __int128 v9 = *(_OWORD *)(a1 + 112);
  __int128 v10 = *(_OWORD *)(a1 + 128);
  __int128 v11 = *(_OWORD *)(a1 + 144);
  __int128 v12 = *(_OWORD *)(a1 + 160);
  __int128 v13 = *(_OWORD *)(a1 + 176);
  __int128 v14 = *(_OWORD *)(a1 + 192);
  __int128 v15 = *(_OWORD *)(a1 + 208);
  __int128 v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Int.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD32Storage.subscript.getter(char a1)
{
  return *(void *)(v1 + 8LL * (a1 & 0x1F));
}

uint64_t key path getter for Int.SIMD32Storage.subscript(_:) : Int.SIMD32Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 0x1FLL));
  return result;
}

uint64_t Int.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8LL * a2) = result;
  return result;
}

uint64_t (*Int.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD32Storage@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 0x1F));
  return result;
}

__n128 Int.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 96);
  __int128 v9 = *(_OWORD *)(v1 + 112);
  __int128 v10 = *(_OWORD *)(v1 + 128);
  __int128 v11 = *(_OWORD *)(v1 + 144);
  __int128 v12 = *(_OWORD *)(v1 + 160);
  __int128 v13 = *(_OWORD *)(v1 + 176);
  __int128 v14 = *(_OWORD *)(v1 + 192);
  __int128 v15 = *(_OWORD *)(v1 + 208);
  __int128 v16 = *(_OWORD *)(v1 + 224);
  __int128 v17 = *(_OWORD *)(v1 + 240);
  __int128 v18 = *(_OWORD *)(v1 + 256);
  __int128 v19 = *(_OWORD *)(v1 + 272);
  __int128 v20 = *(_OWORD *)(v1 + 288);
  __int128 v21 = *(_OWORD *)(v1 + 304);
  __int128 v22 = *(_OWORD *)(v1 + 320);
  __int128 v23 = *(_OWORD *)(v1 + 336);
  __int128 v24 = *(_OWORD *)(v1 + 352);
  __int128 v25 = *(_OWORD *)(v1 + 368);
  __int128 v26 = *(_OWORD *)(v1 + 384);
  __int128 v27 = *(_OWORD *)(v1 + 400);
  __int128 v28 = *(_OWORD *)(v1 + 416);
  __int128 v29 = *(_OWORD *)(v1 + 432);
  __int128 v30 = *(_OWORD *)(v1 + 448);
  __int128 v31 = *(_OWORD *)(v1 + 464);
  __int128 v32 = *(_OWORD *)(v1 + 496);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(v1 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 400) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 320) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  __int128 v9 = *(_OWORD *)(a1 + 112);
  __int128 v10 = *(_OWORD *)(a1 + 128);
  __int128 v11 = *(_OWORD *)(a1 + 144);
  __int128 v12 = *(_OWORD *)(a1 + 160);
  __int128 v13 = *(_OWORD *)(a1 + 176);
  __int128 v14 = *(_OWORD *)(a1 + 192);
  __int128 v15 = *(_OWORD *)(a1 + 208);
  __int128 v16 = *(_OWORD *)(a1 + 224);
  __int128 v17 = *(_OWORD *)(a1 + 240);
  __int128 v18 = *(_OWORD *)(a1 + 256);
  __int128 v19 = *(_OWORD *)(a1 + 272);
  __int128 v20 = *(_OWORD *)(a1 + 288);
  __int128 v21 = *(_OWORD *)(a1 + 304);
  __int128 v22 = *(_OWORD *)(a1 + 320);
  __int128 v23 = *(_OWORD *)(a1 + 336);
  __int128 v24 = *(_OWORD *)(a1 + 352);
  __int128 v25 = *(_OWORD *)(a1 + 368);
  __int128 v26 = *(_OWORD *)(a1 + 384);
  __int128 v27 = *(_OWORD *)(a1 + 400);
  __int128 v28 = *(_OWORD *)(a1 + 416);
  __int128 v29 = *(_OWORD *)(a1 + 432);
  __int128 v30 = *(_OWORD *)(a1 + 448);
  __int128 v31 = *(_OWORD *)(a1 + 464);
  __int128 v32 = *(_OWORD *)(a1 + 496);
  *(_OWORD *)(v1 + 480) = *(_OWORD *)(a1 + 480);
  *(_OWORD *)(v1 + 496) = v32;
  *(_OWORD *)(v1 + 448) = v30;
  *(_OWORD *)(v1 + 464) = v31;
  *(_OWORD *)(v1 + 416) = v28;
  *(_OWORD *)(v1 + 432) = v29;
  *(_OWORD *)(v1 + 384) = v26;
  *(_OWORD *)(v1 + 400) = v27;
  *(_OWORD *)(v1 + 352) = v24;
  *(_OWORD *)(v1 + 368) = v25;
  *(_OWORD *)(v1 + 320) = v22;
  *(_OWORD *)(v1 + 336) = v23;
  *(_OWORD *)(v1 + 288) = v20;
  *(_OWORD *)(v1 + 304) = v21;
  *(_OWORD *)(v1 + 256) = v18;
  *(_OWORD *)(v1 + 272) = v19;
  *(_OWORD *)(v1 + 224) = v16;
  *(_OWORD *)(v1 + 240) = v17;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Int.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD64Storage.subscript.getter(char a1)
{
  return *(void *)(v1 + 8LL * (a1 & 0x3F));
}

uint64_t key path getter for Int.SIMD64Storage.subscript(_:) : Int.SIMD64Storage@<X0>( uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 0x3FLL));
  return result;
}

uint64_t Int.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8LL * a2) = result;
  return result;
}

uint64_t (*Int.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD64Storage@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 0x3F));
  return result;
}

__n128 Float16.SIMD2Storage._value.setter(__n128 result, __n128 a2)
{
  result.n128_u16[1] = a2.n128_u16[0];
  *uint64_t v2 = result.n128_u32[0];
  return result;
}

uint64_t (*Float16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

float Float16.SIMD2Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD2Storage.subscript.getter@<H0>(char a1@<W0>, double a2@<D0>, __n128 a3@<Q1>)
{
  WORD1(a2) = a3.n128_u16[0];
  double v4 = a2;
  return *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (a1 & 3)));
}

__int16 key path getter for Float16.SIMD2Storage.subscript(_:) : Float16.SIMD2Storage@<H0>( uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 1LL));
  *a3 = result;
  return result;
}

__int16 key path setter for Float16.SIMD2Storage.subscript(_:) : Float16.SIMD2Storage@<H0>( __int16 *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>)
{
  __int16 result = *a1;
  *(_WORD *)(a2 + 2LL * *a3) = *a1;
  return result;
}

uint64_t Float16.SIMD2Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2LL * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 1));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD2Storage@<H0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2LL * (a1 & 1));
  *a2 = result;
  return result;
}

__int16 protocol witness for SIMDStorage.subscript.setter in conformance Float16.SIMD2Storage@<H0>( __int16 *a1@<X0>, unsigned int a2@<W1>)
{
  __int16 result = *a1;
  *(_WORD *)(v2 + 2LL * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD2Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 1));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 Float16.SIMD2Storage.subscript.modify@<H0>(unsigned int *a1@<X0>)
{
  __int16 result = *((_WORD *)a1 + 8);
  *(_WORD *)(*((void *)a1 + 1) + 2LL * *a1) = result;
  return result;
}

void Float16.SIMD4Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Float16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double Float16.SIMD4Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD4Storage.subscript.getter@<H0>(char a1@<W0>, double a2@<D0>)
{
  double v3 = a2;
  return *(_WORD *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFF9LL | (2LL * (a1 & 3)));
}

__int16 key path getter for Float16.SIMD4Storage.subscript(_:) : Float16.SIMD4Storage@<H0>( uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 3LL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD4Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2LL * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 3));
  return Float16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance Float16.SIMD4Storage@<D0>(void *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0LL;
  return result;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD4Storage@<H0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2LL * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD4Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 3));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Float16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Float16.SIMD8Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD8Storage.subscript.getter@<H0>(char a1@<W0>)
{
  return *(_WORD *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF1LL | (2LL * (a1 & 7)));
}

__int16 key path getter for Float16.SIMD8Storage.subscript(_:) : Float16.SIMD8Storage@<H0>( uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 7LL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD8Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2LL * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 7));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD8Storage@<H0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2LL * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD8Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 7));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD16Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Float16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Float16.SIMD16Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD16Storage.subscript.getter@<H0>(char a1@<W0>)
{
  return *((_WORD *)&v2 + (a1 & 0xF));
}

__int16 key path getter for Float16.SIMD16Storage.subscript(_:) : Float16.SIMD16Storage@<H0>( uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD16Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2LL * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0xF));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD16Storage@<H0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2LL * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD16Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0xF));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD32Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  __n128 *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Float16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Float16.SIMD32Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD32Storage.subscript.getter@<H0>( char a1@<W0>, __n128 a2@<Q0>, __n128 a3@<Q1>, __n128 a4@<Q2>, __n128 a5@<Q3>)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((_WORD *)v6 + (a1 & 0x1F));
}

__int16 key path getter for Float16.SIMD32Storage.subscript(_:) : Float16.SIMD32Storage@<H0>( uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD32Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2LL * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x1F));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD32Storage@<H0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2LL * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD32Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x1F));
  return Float16.SIMD2Storage.subscript.modify;
}

__n128 Float16.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float16.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Float16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

__int16 Float16.SIMD64Storage.subscript.getter@<H0>(char a1@<W0>)
{
  return *(_WORD *)(v1 + 2LL * (a1 & 0x3F));
}

__int16 key path getter for Float16.SIMD64Storage.subscript(_:) : Float16.SIMD64Storage@<H0>( uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD64Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2LL * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x3F));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD64Storage@<H0>( char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2LL * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD64Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x3F));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float.SIMD2Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Float.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double Float.SIMD2Storage.init()()
{
  return 0.0;
}

float Float.SIMD2Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(float *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFFBLL | (4LL * (a1 & 1)));
}

float key path getter for Float.SIMD2Storage.subscript(_:) : Float.SIMD2Storage@<S0>( uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 1LL));
  *a3 = result;
  return result;
}

float key path setter for Float.SIMD2Storage.subscript(_:) : Float.SIMD2Storage( float *a1, uint64_t a2, unsigned int *a3)
{
  float result = *a1;
  *(float *)(a2 + 4LL * *a3) = *a1;
  return result;
}

uint64_t Float.SIMD2Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4LL * result) = a2;
  return result;
}

uint64_t (*Float.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD2Storage@<S0>( char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4LL * (a1 & 1));
  *a2 = result;
  return result;
}

float protocol witness for SIMDStorage.subscript.setter in conformance Float.SIMD2Storage( float *a1, unsigned int a2)
{
  float result = *a1;
  *(float *)(v2 + 4LL * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD2Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return Float.SIMD2Storage.subscript.modify;
}

float Float.SIMD2Storage.subscript.modify(float *a1)
{
  float result = a1[4];
  *(float *)(*((void *)a1 + 1) + 4LL * *(unsigned int *)a1) = result;
  return result;
}

void Float.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Float.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double Float.SIMD4Storage.init()()
{
  return 0.0;
}

float Float.SIMD4Storage.subscript.getter(char a1)
{
  return *(float *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF3LL | (4LL * (a1 & 3)));
}

float key path getter for Float.SIMD4Storage.subscript(_:) : Float.SIMD4Storage@<S0>( uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 3LL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD4Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4LL * result) = a2;
  return result;
}

uint64_t (*Float.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD4Storage@<S0>( char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4LL * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD4Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return Float.SIMD2Storage.subscript.modify;
}

void Float.SIMD8Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Float.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Float.SIMD8Storage.init()()
{
  return 0.0;
}

float Float.SIMD8Storage.subscript.getter(char a1)
{
  return *((float *)&v2 + (a1 & 7));
}

float key path getter for Float.SIMD8Storage.subscript(_:) : Float.SIMD8Storage@<S0>( uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 7LL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD8Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4LL * result) = a2;
  return result;
}

uint64_t (*Float.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD8Storage@<S0>( char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4LL * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD8Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return Float.SIMD2Storage.subscript.modify;
}

void Float.SIMD16Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  __n128 *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Float.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Float.SIMD16Storage.init()()
{
  return 0.0;
}

float Float.SIMD16Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((float *)v6 + (a1 & 0xF));
}

float key path getter for Float.SIMD16Storage.subscript(_:) : Float.SIMD16Storage@<S0>( uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD16Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4LL * result) = a2;
  return result;
}

uint64_t (*Float.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD16Storage@<S0>( char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4LL * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD16Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return Float.SIMD2Storage.subscript.modify;
}

__n128 Float.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Float.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

float Float.SIMD32Storage.subscript.getter(char a1)
{
  return *(float *)(v1 + 4LL * (a1 & 0x1F));
}

float key path getter for Float.SIMD32Storage.subscript(_:) : Float.SIMD32Storage@<S0>( uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD32Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4LL * result) = a2;
  return result;
}

uint64_t (*Float.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD32Storage@<S0>( char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4LL * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD32Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return Float.SIMD2Storage.subscript.modify;
}

__n128 Float.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 96);
  __int128 v9 = *(_OWORD *)(v1 + 112);
  __int128 v10 = *(_OWORD *)(v1 + 128);
  __int128 v11 = *(_OWORD *)(v1 + 144);
  __int128 v12 = *(_OWORD *)(v1 + 160);
  __int128 v13 = *(_OWORD *)(v1 + 176);
  __int128 v14 = *(_OWORD *)(v1 + 192);
  __int128 v15 = *(_OWORD *)(v1 + 208);
  __int128 v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  __int128 v9 = *(_OWORD *)(a1 + 112);
  __int128 v10 = *(_OWORD *)(a1 + 128);
  __int128 v11 = *(_OWORD *)(a1 + 144);
  __int128 v12 = *(_OWORD *)(a1 + 160);
  __int128 v13 = *(_OWORD *)(a1 + 176);
  __int128 v14 = *(_OWORD *)(a1 + 192);
  __int128 v15 = *(_OWORD *)(a1 + 208);
  __int128 v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Float.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

float Float.SIMD64Storage.subscript.getter(char a1)
{
  return *(float *)(v1 + 4LL * (a1 & 0x3F));
}

float key path getter for Float.SIMD64Storage.subscript(_:) : Float.SIMD64Storage@<S0>( uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD64Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4LL * result) = a2;
  return result;
}

uint64_t (*Float.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD64Storage@<S0>( char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4LL * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD64Storage( uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return Float.SIMD2Storage.subscript.modify;
}

void Double.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Double.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD2Storage.scalarCount.getter()
{
  return 2LL;
}

double Double.SIMD2Storage.init()()
{
  return 0.0;
}

double Double.SIMD2Storage.subscript.getter(char a1)
{
  return *(double *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF7LL | (8LL * (a1 & 1)));
}

double key path getter for Double.SIMD2Storage.subscript(_:) : Double.SIMD2Storage@<D0>( uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 1LL));
  *a3 = result;
  return result;
}

double key path setter for Double.SIMD2Storage.subscript(_:) : Double.SIMD2Storage( double *a1, uint64_t a2, unsigned int *a3)
{
  double result = *a1;
  *(double *)(a2 + 8LL * *a3) = *a1;
  return result;
}

uint64_t Double.SIMD2Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8LL * result) = a2;
  return result;
}

uint64_t (*Double.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD2Storage@<D0>( char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8LL * (a1 & 1));
  *a2 = result;
  return result;
}

double protocol witness for SIMDStorage.subscript.setter in conformance Double.SIMD2Storage( double *a1, unsigned int a2)
{
  double result = *a1;
  *(double *)(v2 + 8LL * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD2Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return Double.SIMD2Storage.subscript.modify;
}

double Double.SIMD2Storage.subscript.modify(uint64_t a1)
{
  double result = *(double *)a1;
  *(void *)(*(void *)(a1 + 16) + 8LL * *(unsigned int *)(a1 + 8)) = *(void *)a1;
  return result;
}

void Double.SIMD4Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Double.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD4Storage.scalarCount.getter()
{
  return 4LL;
}

double Double.SIMD4Storage.init()()
{
  return 0.0;
}

double Double.SIMD4Storage.subscript.getter(char a1)
{
  return *((double *)&v2 + (a1 & 3));
}

double key path getter for Double.SIMD4Storage.subscript(_:) : Double.SIMD4Storage@<D0>( uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 3LL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD4Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8LL * result) = a2;
  return result;
}

uint64_t (*Double.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD4Storage@<D0>( char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8LL * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD4Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return Double.SIMD2Storage.subscript.modify;
}

void Double.SIMD8Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  __n128 *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Double.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD8Storage.scalarCount.getter()
{
  return 8LL;
}

double Double.SIMD8Storage.init()()
{
  return 0.0;
}

double Double.SIMD8Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((double *)v6 + (a1 & 7));
}

double key path getter for Double.SIMD8Storage.subscript(_:) : Double.SIMD8Storage@<D0>( uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 7LL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD8Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8LL * result) = a2;
  return result;
}

uint64_t (*Double.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD8Storage@<D0>( char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8LL * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD8Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD16Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD16Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD16Storage.scalarCount.getter()
{
  return 16LL;
}

double Double.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD16Storage.subscript.getter(char a1)
{
  return *(double *)(v1 + 8LL * (a1 & 0xF));
}

double key path getter for Double.SIMD16Storage.subscript(_:) : Double.SIMD16Storage@<D0>( uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD16Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8LL * result) = a2;
  return result;
}

uint64_t (*Double.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD16Storage@<D0>( char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8LL * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD16Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 96);
  __int128 v9 = *(_OWORD *)(v1 + 112);
  __int128 v10 = *(_OWORD *)(v1 + 128);
  __int128 v11 = *(_OWORD *)(v1 + 144);
  __int128 v12 = *(_OWORD *)(v1 + 160);
  __int128 v13 = *(_OWORD *)(v1 + 176);
  __int128 v14 = *(_OWORD *)(v1 + 192);
  __int128 v15 = *(_OWORD *)(v1 + 208);
  __int128 v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  __int128 v9 = *(_OWORD *)(a1 + 112);
  __int128 v10 = *(_OWORD *)(a1 + 128);
  __int128 v11 = *(_OWORD *)(a1 + 144);
  __int128 v12 = *(_OWORD *)(a1 + 160);
  __int128 v13 = *(_OWORD *)(a1 + 176);
  __int128 v14 = *(_OWORD *)(a1 + 192);
  __int128 v15 = *(_OWORD *)(a1 + 208);
  __int128 v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD32Storage.scalarCount.getter()
{
  return 32LL;
}

double Double.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD32Storage.subscript.getter(char a1)
{
  return *(double *)(v1 + 8LL * (a1 & 0x1F));
}

double key path getter for Double.SIMD32Storage.subscript(_:) : Double.SIMD32Storage@<D0>( uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD32Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8LL * result) = a2;
  return result;
}

uint64_t (*Double.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD32Storage@<D0>( char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8LL * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD32Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  __int128 v4 = *(_OWORD *)(v1 + 32);
  __int128 v5 = *(_OWORD *)(v1 + 48);
  __int128 v6 = *(_OWORD *)(v1 + 64);
  __int128 v7 = *(_OWORD *)(v1 + 80);
  __int128 v8 = *(_OWORD *)(v1 + 96);
  __int128 v9 = *(_OWORD *)(v1 + 112);
  __int128 v10 = *(_OWORD *)(v1 + 128);
  __int128 v11 = *(_OWORD *)(v1 + 144);
  __int128 v12 = *(_OWORD *)(v1 + 160);
  __int128 v13 = *(_OWORD *)(v1 + 176);
  __int128 v14 = *(_OWORD *)(v1 + 192);
  __int128 v15 = *(_OWORD *)(v1 + 208);
  __int128 v16 = *(_OWORD *)(v1 + 224);
  __int128 v17 = *(_OWORD *)(v1 + 240);
  __int128 v18 = *(_OWORD *)(v1 + 256);
  __int128 v19 = *(_OWORD *)(v1 + 272);
  __int128 v20 = *(_OWORD *)(v1 + 288);
  __int128 v21 = *(_OWORD *)(v1 + 304);
  __int128 v22 = *(_OWORD *)(v1 + 320);
  __int128 v23 = *(_OWORD *)(v1 + 336);
  __int128 v24 = *(_OWORD *)(v1 + 352);
  __int128 v25 = *(_OWORD *)(v1 + 368);
  __int128 v26 = *(_OWORD *)(v1 + 384);
  __int128 v27 = *(_OWORD *)(v1 + 400);
  __int128 v28 = *(_OWORD *)(v1 + 416);
  __int128 v29 = *(_OWORD *)(v1 + 432);
  __int128 v30 = *(_OWORD *)(v1 + 448);
  __int128 v31 = *(_OWORD *)(v1 + 464);
  __int128 v32 = *(_OWORD *)(v1 + 496);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(v1 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 400) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 320) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v7 = *(_OWORD *)(a1 + 80);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  __int128 v9 = *(_OWORD *)(a1 + 112);
  __int128 v10 = *(_OWORD *)(a1 + 128);
  __int128 v11 = *(_OWORD *)(a1 + 144);
  __int128 v12 = *(_OWORD *)(a1 + 160);
  __int128 v13 = *(_OWORD *)(a1 + 176);
  __int128 v14 = *(_OWORD *)(a1 + 192);
  __int128 v15 = *(_OWORD *)(a1 + 208);
  __int128 v16 = *(_OWORD *)(a1 + 224);
  __int128 v17 = *(_OWORD *)(a1 + 240);
  __int128 v18 = *(_OWORD *)(a1 + 256);
  __int128 v19 = *(_OWORD *)(a1 + 272);
  __int128 v20 = *(_OWORD *)(a1 + 288);
  __int128 v21 = *(_OWORD *)(a1 + 304);
  __int128 v22 = *(_OWORD *)(a1 + 320);
  __int128 v23 = *(_OWORD *)(a1 + 336);
  __int128 v24 = *(_OWORD *)(a1 + 352);
  __int128 v25 = *(_OWORD *)(a1 + 368);
  __int128 v26 = *(_OWORD *)(a1 + 384);
  __int128 v27 = *(_OWORD *)(a1 + 400);
  __int128 v28 = *(_OWORD *)(a1 + 416);
  __int128 v29 = *(_OWORD *)(a1 + 432);
  __int128 v30 = *(_OWORD *)(a1 + 448);
  __int128 v31 = *(_OWORD *)(a1 + 464);
  __int128 v32 = *(_OWORD *)(a1 + 496);
  *(_OWORD *)(v1 + 480) = *(_OWORD *)(a1 + 480);
  *(_OWORD *)(v1 + 496) = v32;
  *(_OWORD *)(v1 + 448) = v30;
  *(_OWORD *)(v1 + 464) = v31;
  *(_OWORD *)(v1 + 416) = v28;
  *(_OWORD *)(v1 + 432) = v29;
  *(_OWORD *)(v1 + 384) = v26;
  *(_OWORD *)(v1 + 400) = v27;
  *(_OWORD *)(v1 + 352) = v24;
  *(_OWORD *)(v1 + 368) = v25;
  *(_OWORD *)(v1 + 320) = v22;
  *(_OWORD *)(v1 + 336) = v23;
  *(_OWORD *)(v1 + 288) = v20;
  *(_OWORD *)(v1 + 304) = v21;
  *(_OWORD *)(v1 + 256) = v18;
  *(_OWORD *)(v1 + 272) = v19;
  *(_OWORD *)(v1 + 224) = v16;
  *(_OWORD *)(v1 + 240) = v17;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD64Storage.scalarCount.getter()
{
  return 64LL;
}

double Double.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD64Storage.subscript.getter(char a1)
{
  return *(double *)(v1 + 8LL * (a1 & 0x3F));
}

double key path getter for Double.SIMD64Storage.subscript(_:) : Double.SIMD64Storage@<D0>( uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD64Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8LL * result) = a2;
  return result;
}

uint64_t (*Double.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD64Storage@<D0>( char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8LL * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD64Storage( void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return Double.SIMD2Storage.subscript.modify;
}

__int16 *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( __int16 *result@<X0>, uint64_t a2@<X8>)
{
  __int16 v2 = *result;
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 40) = &type metadata for UInt16;
  *(_WORD *)(a2 + 16) = v2;
  return result;
}

char *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( char *result@<X0>, uint64_t a2@<X8>)
{
  char v2 = *result;
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 40) = &type metadata for UInt8;
  *(_BYTE *)(a2 + 16) = v2;
  return result;
}

int *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( int *result@<X0>, uint64_t a2@<X8>)
{
  int v2 = *result;
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 40) = &type metadata for Unicode.Scalar;
  *(_DWORD *)(a2 + 16) = v2;
  return result;
}

void specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( void *a1@<X8>)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[5] = &unk_189B8D178;
}

unint64_t specialized String.UTF16View._foreignIndex(after:)(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000LL) + 65544;
}

unint64_t specialized String.UTF16View._foreignIndex(before:)(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000LL) - 65528;
}

char *specialized _ArrayBuffer._copyContents(subRange:initializing:)( uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_7;
  }
  __int128 v5 = (char *)(a4 + 8 * a1 + 32);
  size_t v6 = 8 * v4;
  __int128 v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  memcpy(__dst, v5, v6);
  return v7;
}

{
  size_t v4;
  char *v5;
  char *v6;
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if ((v4 & 0x8000000000000000LL) != 0) {
    goto LABEL_7;
  }
  __int128 v5 = (char *)(a4 + a1 + 32);
  size_t v6 = &__dst[v4];
  if (v5 < &__dst[v4] && &v5[v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  memcpy(__dst, v5, v4);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_7;
  }
  __int128 v5 = (char *)(a4 + 32 * a1 + 32);
  size_t v6 = &__dst[32 * v4];
  if (v5 < v6 && &v5[32 * v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  swift_arrayInitWithCopy(__dst, v5, v4, (uint64_t)&unk_189B8D218);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_7;
  }
  __int128 v5 = (char *)(a4 + 16 * a1 + 32);
  size_t v6 = 16 * v4;
  __int128 v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  memcpy(__dst, v5, v6);
  return v7;
}

{
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_7;
  }
  __int128 v5 = (char *)(a4 + 8 * a1 + 32);
  size_t v6 = &__dst[8 * v4];
  if (v5 < v6 && &v5[8 * v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  swift_arrayInitWithCopy(__dst, v5, v4, (uint64_t)&unk_189B897D0);
  return v6;
}

unint64_t specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(int a1, unsigned int a2)
{
  BOOL v2 = (a1 - 4352) <= 0x12 && a2 >= 0x1161;
  if (v2 && a2 >> 1 <= 0x8BA)
  {
    unsigned __int8 v3 = 0;
    unsigned int v4 = 28 * a2 + 588 * a1 - 2639516;
  }

  else
  {
    unsigned int v4 = 0;
    unsigned __int8 v3 = 1;
    if ((a1 - 44032) >> 2 <= 0xAE8
      && a2 >> 3 >= 0x235
      && a2 <= 0x11C2
      && (unsigned __int16)(a1 + 21504) == 28 * ((153391690 * (unint64_t)(unsigned __int16)(a1 + 21504)) >> 32))
    {
      unsigned __int8 v3 = 0;
      unsigned int v4 = a1 + a2 - 4519;
    }
  }

  return v4 | ((unint64_t)v3 << 32);
}

int64_t specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( char *a1, size_t a2, int64_t a3, char a4)
{
  unint64_t v6 = a2 | 0xC000000000000000LL;
  if ((a4 & 1) == 0) {
    unint64_t v6 = a2;
  }
  uint64_t v7 = v6 | 0x3000000000000000LL;
  int64_t v8 = _allocateStringStorage(codeUnitCapacity:)(a3);
  *(void *)(v8 + 16) = v9;
  *(void *)(v8 + 24) = v7;
  if (v9 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v7 = *(void *)(v8 + 24);
  }

  *(_BYTE *)(v8 + 32 + (v7 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)(a1, a2, (char *)(v8 + 32));
  return v8;
}

uint64_t specialized static String._uncheckedFromUTF8(_:isASCII:)(uint8x16_t *a1, uint64_t a2, char a3)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 > 15) {
    return *(uint64_t *)(specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( a1->i8,  a2,  a2,  a3 & 1)
  }
                      + 24);
  uint64_t v4 = a2 - 8;
  if (a2 >= 8) {
    unint64_t v5 = 8LL;
  }
  else {
    unint64_t v5 = a2;
  }
  if ((v5 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v5 < 8)
  {
    unint64_t v6 = 0LL;
    int8x8_t v3 = 0LL;
    unint64_t v7 = 0LL;
    goto LABEL_19;
  }

  if (v5 >= 0x10)
  {
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFF0LL;
    uint16x8_t v31 = vmovl_high_u8(*a1);
    int8x16_t v32 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v31.i8);
    uint16x8_t v33 = vmovl_u8(*(uint8x8_t *)a1->i8);
    int8x16_t v34 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v33.i8);
    int8x16_t v35 = (int8x16_t)vmovl_high_u16(v31);
    int8x8_t v36 = (int8x8_t)vextq_s8(v35, v35, 8uLL).u64[0];
    int8x16_t v37 = (int8x16_t)vmovl_high_u16(v33);
    int8x8_t v38 = (int8x8_t)vextq_s8(v37, v37, 8uLL).u64[0];
    *(int8x8_t *)v37.i8 = vorr_s8(*(int8x8_t *)v37.i8, *(int8x8_t *)v35.i8);
    v39.i64[0] = v37.u32[0];
    v39.i64[1] = v37.u32[1];
    int8x16_t v40 = (int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1817FFCE0);
    *(int8x8_t *)v35.i8 = vorr_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)v32.i8);
    v39.i64[0] = v35.u32[0];
    v39.i64[1] = v35.u32[1];
    int8x16_t v41 = vorrq_s8((int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1817FFCD0), v40);
    *(int8x8_t *)v35.i8 = vorr_s8(v38, v36);
    v39.i64[0] = v35.u32[0];
    v39.i64[1] = v35.u32[1];
    int8x16_t v42 = (int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1817FFCC0);
    *(int8x8_t *)v32.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
    v39.i64[0] = v32.u32[0];
    v39.i64[1] = v32.u32[1];
    int8x16_t v43 = vorrq_s8(v41, vorrq_s8((int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1817FFCB0), v42));
    int8x8_t v3 = vorr_s8(*(int8x8_t *)v43.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
    if (v5 == (v5 & 0xFFFFFFFFFFFFFFF0LL)) {
      goto LABEL_21;
    }
    unint64_t v7 = 8 * v6;
    if ((v5 & 8) == 0) {
      goto LABEL_19;
    }
  }

  else
  {
    int8x8_t v3 = 0LL;
    unint64_t v7 = 0LL;
    unint64_t v6 = 0LL;
  }

  unint64_t v8 = v6;
  int64x2_t v9 = vdupq_n_s64(v7);
  unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v7 = 8 * (v5 & 0xFFFFFFFFFFFFFFF8LL);
  int8x16_t v10 = 0uLL;
  int8x16_t v11 = (int8x16_t)(unint64_t)v3;
  int64x2_t v12 = vaddq_s64(v9, (int64x2_t)xmmword_1817FFCC0);
  int64x2_t v13 = vaddq_s64(v9, (int64x2_t)xmmword_1817FFCE0);
  int64x2_t v14 = vaddq_s64(v9, (int64x2_t)xmmword_1817FFCB0);
  int64x2_t v15 = vaddq_s64(v9, (int64x2_t)xmmword_1817FFCD0);
  __int128 v16 = (uint8x8_t *)&a1->i8[v8];
  int8x16_t v17 = (int8x16_t)vdupq_n_s64(0x38uLL);
  unint64_t v18 = v8 - (v5 & 0xFFFFFFFFFFFFFFF8LL);
  int64x2_t v19 = vdupq_n_s64(0x40uLL);
  int8x16_t v20 = 0uLL;
  int8x16_t v21 = 0uLL;
  do
  {
    uint8x8_t v22 = *v16++;
    uint16x8_t v23 = vmovl_u8(v22);
    uint32x4_t v24 = vmovl_high_u16(v23);
    v25.i64[0] = v24.u32[2];
    v25.i64[1] = v24.u32[3];
    uint64x2_t v26 = v25;
    v25.i64[0] = v24.u32[0];
    v25.i64[1] = v24.u32[1];
    uint64x2_t v27 = v25;
    uint32x4_t v28 = vmovl_u16(*(uint16x4_t *)v23.i8);
    v25.i64[0] = v28.u32[2];
    v25.i64[1] = v28.u32[3];
    uint64x2_t v29 = v25;
    v25.i64[0] = v28.u32[0];
    v25.i64[1] = v28.u32[1];
    int8x16_t v21 = vorrq_s8((int8x16_t)vshlq_u64(v26, (uint64x2_t)vandq_s8((int8x16_t)v12, v17)), v21);
    int8x16_t v20 = vorrq_s8((int8x16_t)vshlq_u64(v27, (uint64x2_t)vandq_s8((int8x16_t)v13, v17)), v20);
    int8x16_t v10 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)vandq_s8((int8x16_t)v14, v17)), v10);
    int8x16_t v11 = vorrq_s8((int8x16_t)vshlq_u64(v25, (uint64x2_t)vandq_s8((int8x16_t)v15, v17)), v11);
    int64x2_t v13 = vaddq_s64(v13, v19);
    int64x2_t v14 = vaddq_s64(v14, v19);
    int64x2_t v15 = vaddq_s64(v15, v19);
    int64x2_t v12 = vaddq_s64(v12, v19);
    v18 += 8LL;
  }

  while (v18);
  int8x16_t v30 = vorrq_s8(vorrq_s8(v11, v20), vorrq_s8(v10, v21));
  int8x8_t v3 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
  if (v5 != v6)
  {
LABEL_19:
    unint64_t v44 = &a1->u8[v6];
    unint64_t v45 = v5 - v6;
    do
    {
      unsigned int v46 = *v44++;
      *(void *)&v3 |= (unint64_t)v46 << (v7 & 0x38);
      v7 += 8LL;
      --v45;
    }

    while (v45);
  }

uint64_t specialized static String._uncheckedFromUTF8(_:)(uint8x16_t *a1, uint64_t a2)
{
  if (!a2) {
    goto LABEL_20;
  }
  if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFF0LL) < 1)
  {
    BOOL v2 = a1;
  }

  else
  {
    if (((a1->i64[1] | a1->i64[0]) & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    BOOL v2 = a1 + 1;
    while (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFF0LL])
    {
      uint64_t v3 = v2->i64[0];
      uint64_t v4 = v2->i64[1];
      ++v2;
      if (((v4 | v3) & 0x8080808080808080LL) != 0) {
        goto LABEL_22;
      }
    }
  }

  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFF8LL])
  {
    if ((v2->i64[0] & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    BOOL v2 = (uint8x16_t *)((char *)v2 + 8);
  }

  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v2->i32[0] & 0x80808080) != 0) {
      goto LABEL_22;
    }
    BOOL v2 = (uint8x16_t *)((char *)v2 + 4);
  }

  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFFELL])
  {
    if ((v2->i16[0] & 0x8080) == 0)
    {
      BOOL v2 = (uint8x16_t *)((char *)v2 + 2);
      goto LABEL_18;
    }

uint64_t specialized static String._copying(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    int8x16_t v11 = (uint8x16_t *)specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2, a3, a4);
    uint64_t v12 = specialized static String._uncheckedFromUTF8(_:)(v11 + 2, v11[1].i64[0]);
    swift_release((uint64_t)v11);
    return v12;
  }

  else
  {
    Swift::UInt64 v4 = a1._rawBits >> 16;
    int64_t v5 = a2._rawBits >> 16;
    if ((a4 & 0x2000000000000000LL) == 0)
    {
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        id v6 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v7 = a3 & 0xFFFFFFFFFFFFLL;
        if ((uint64_t)(a3 & 0xFFFFFFFFFFFFLL) >= v5)
        {
LABEL_5:
          unint64_t v8 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v4, v5, (uint64_t)v6, v7);
          return specialized static String._uncheckedFromUTF8(_:)(v8, v9);
        }
      }

      else
      {
        id v6 = _StringObject.sharedUTF8.getter(a3, a4);
        uint64_t v7 = v13;
        if (v13 >= v5) {
          goto LABEL_5;
        }
      }

uint64_t specialized static String._copying(_:)(unint64_t a1, unint64_t a2)
{
  Swift::UInt64 v2 = specialized Collection.subscript.getter(a1, a2);
  Swift::UInt64 v4 = v3;
  unint64_t v6 = v5;
  unint64_t v8 = (unint64_t)v7;
  swift_bridgeObjectRetain((unint64_t)v7, v3, v5, v7);
  v9._rawBits = v2;
  v10._rawBits = v4;
  uint64_t v11 = specialized static String._copying(_:)(v9, v10, v6, v8);
  swift_bridgeObjectRelease(v8);
  return v11;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( int64_t a1, unint64_t *a2)
{
  int64_t v4 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v4 + 16) = v5;
  *(void *)(v4 + 24) = 0x3000000000000000LL;
  if (v5 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v6 = *(void *)(v4 + 24) & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  *(_BYTE *)(v4 + 32 + v6) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v7 = _StringGuts._foreignCopyUTF8(into:)(v4 + 32, a1, *a2, a2[1]);
  if ((v8 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000029LL,  0x80000001818BB170LL,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  0x91uLL,  0);
  }
  *(void *)(v4 + 24) = v7 | 0x3000000000000000LL;
  *(_BYTE *)(v4 + 32 + (v7 & 0xFFFFFFFFFFFFLL)) = 0;
  return v4;
}

uint64_t specialized Slice.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a1;
  if (__OFSUB__(a3, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x62DuLL,  0);
  }
  if (a2 < 1)
  {
    if (v3 > 0 || v3 <= a2) {
      goto LABEL_9;
    }
    return 0LL;
  }

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( int64_t a1, unint64_t *a2)
{
  int64_t v4 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( a1,  a2);
  if (v3) {
    return v2;
  }
  BOOL v5 = v4;
  uint64_t v6 = v4[3];
  Swift::Int v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  char v8 = (char *)(v4 + 4);
  Swift::String::Index v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0LL) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    Swift::String::Index v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0LL) + 32)
    {
      uint64_t v10 = *(void *)v9;
      uint64_t v11 = *((void *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080LL) != 0) {
        goto LABEL_22;
      }
    }
  }

  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8LL])
  {
    if ((*(void *)v9 & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    v9 += 8;
  }

  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v9 += 4;
  }

  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      char v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }

    goto LABEL_22;
  }

  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }

uint64_t specialized static String._createEmpty(withInitialCapacity:)(Swift::Int a1)
{
  if (a1 < 16) {
    return 0LL;
  }
  _StringGuts.grow(_:)(a1);
  return 0LL;
}

uint64_t specialized String.init(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3;
  uint64_t v5 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v5 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 16 || a2._rawBits >> 16 != v5) {
    return specialized static String._copying(_:)(a1, a2, a3, a4);
  }
  swift_bridgeObjectRetain(a4, a2._rawBits, a3, (char *)a4);
  return v4;
}

unint64_t specialized _SmallString.init(_:appending:)( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  uint64_t v5 = HIBYTE(a4) & 0xF;
  if (v5)
  {
    char v6 = 0;
    unint64_t v7 = 0LL;
    do
    {
      unint64_t v8 = v4 + v7;
      unint64_t v9 = v7 + 1;
      if (v7 >= 8) {
        unint64_t v10 = a4;
      }
      else {
        unint64_t v10 = a3;
      }
      unint64_t v11 = v10 >> (v6 & 0x38);
      char v12 = (8 * v4 + v6) & 0x38;
      uint64_t v13 = (-255LL << v12) - 1;
      unint64_t v14 = (unint64_t)v11 << v12;
      unint64_t v15 = v14 | v13 & a2;
      unint64_t v16 = v14 | v13 & result;
      if (v8 < 8) {
        uint64_t result = v16;
      }
      else {
        a2 = v15;
      }
      v6 += 8;
      unint64_t v7 = v9;
    }

    while (v5 != v9);
  }

  return result;
}

BOOL specialized static __CocoaSet.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v8 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different sets",  37LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1FFuLL,  0);
  }
  return a2 < a4;
}

BOOL specialized _StringGutsSlice._isScalarNFCQC(_:_:)(unsigned int a1, _BYTE *a2)
{
  if (a1 >= 0x300) {
    unsigned int NormData = _swift_stdlib_getNormData(a1);
  }
  else {
    unsigned int NormData = 0;
  }
  char v4 = NormData >> 3;
  if (v4) {
    BOOL v5 = *a2 <= (NormData >> 3);
  }
  else {
    BOOL v5 = 1;
  }
  BOOL result = (NormData & 6) == 0 && v5;
  if (result) {
    *a2 = v4;
  }
  return result;
}

uint64_t specialized _ArrayBuffer._nonNative.getter(uint64_t result)
{
  if (result >= 0) {
    return result & 0xFFFFFFFFFFFFFF8LL;
  }
  return result;
}

uint64_t specialized static Hasher._hash(seed:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)algn_18C487058 ^ a2 ^ 0x7465646279746573LL;
  uint64_t v3 = ((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL)
      + (*(void *)algn_18C487058 ^ 0x646F72616E646F6DLL)) ^ __ROR8__( *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL,  51);
  uint64_t v4 = (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL) + v2;
  uint64_t v5 = __ROR8__(v2, 48);
  uint64_t v6 = __ROR8__( (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL)
       + (*(void *)algn_18C487058 ^ 0x646F72616E646F6DLL),
         32)
     + (v4 ^ v5);
  uint64_t v7 = v6 ^ __ROR8__(v4 ^ v5, 43);
  uint64_t v8 = v3 + v4;
  uint64_t v9 = __ROR8__(v8, 32);
  uint64_t v10 = v8 ^ __ROR8__(v3, 47);
  uint64_t v11 = (v6 ^ a2) + v10;
  uint64_t v12 = __ROR8__(v11, 32);
  uint64_t v13 = v11 ^ __ROR8__(v10, 51);
  uint64_t v14 = (v7 ^ 0x800000000000000LL) + v9;
  *((void *)&v15 + 1) = v7;
  *(void *)&__int128 v15 = v7 ^ 0x800000000000000LL;
  uint64_t v16 = (v15 >> 48) ^ v14;
  uint64_t v17 = v16 + v12;
  uint64_t v18 = (v16 + v12) ^ __ROR8__(v16, 43);
  uint64_t v19 = v14 + v13;
  uint64_t v20 = v19 ^ __ROR8__(v13, 47);
  uint64_t v21 = (v17 ^ 0x800000000000000LL) + v20;
  uint64_t v22 = v21 ^ __ROR8__(v20, 51);
  uint64_t v23 = (__ROR8__(v19, 32) ^ 0xFFLL) + v18;
  *(void *)&__int128 v15 = __ROR8__(v18, 48);
  uint64_t v24 = __ROR8__(v21, 32) + (v23 ^ v15);
  uint64_t v25 = v24 ^ __ROR8__(v23 ^ v15, 43);
  uint64_t v26 = v22 + v23;
  uint64_t v27 = __ROR8__(v26, 32);
  uint64_t v28 = v26 ^ __ROR8__(v22, 47);
  uint64_t v29 = v24 + v28;
  uint64_t v30 = (v24 + v28) ^ __ROR8__(v28, 51);
  uint64_t v31 = v27 + v25;
  uint64_t v32 = (v27 + v25) ^ __ROR8__(v25, 48);
  uint64_t v33 = __ROR8__(v29, 32) + v32;
  uint64_t v34 = v33 ^ __ROR8__(v32, 43);
  uint64_t v35 = v30 + v31;
  uint64_t v36 = v35 ^ __ROR8__(v30, 47);
  uint64_t v37 = __ROR8__(v35, 32) + v34;
  uint64_t v38 = (v33 + v36) ^ __ROR8__(v36, 51);
  return __ROR8__(v37 ^ __ROR8__(v34, 48), 43) ^ __ROR8__(v38 + v37, 32) ^ (v38 + v37) ^ __ROR8__(v38, 47);
}

uint64_t specialized static Hasher._hash(seed:bytes:count:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2 | (a3 << 56);
  uint64_t v4 = v3 ^ 0x7465646279746573LL ^ *(void *)algn_18C487058;
  uint64_t v5 = ((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL)
      + (*(void *)algn_18C487058 ^ 0x646F72616E646F6DLL)) ^ __ROR8__( *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL,  51);
  uint64_t v6 = (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL) + v4;
  uint64_t v7 = __ROR8__(v4, 48);
  uint64_t v8 = __ROR8__( (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL)
       + (*(void *)algn_18C487058 ^ 0x646F72616E646F6DLL),
         32)
     + (v6 ^ v7);
  uint64_t v9 = v8 ^ __ROR8__(v6 ^ v7, 43);
  uint64_t v10 = v5 + v6;
  uint64_t v11 = v10 ^ __ROR8__(v5, 47);
  uint64_t v12 = (v8 ^ v3) + v11;
  uint64_t v13 = v12 ^ __ROR8__(v11, 51);
  uint64_t v14 = (__ROR8__(v10, 32) ^ 0xFFLL) + v9;
  uint64_t v15 = __ROR8__(v9, 48);
  uint64_t v16 = __ROR8__(v12, 32) + (v14 ^ v15);
  uint64_t v17 = v16 ^ __ROR8__(v14 ^ v15, 43);
  uint64_t v18 = v13 + v14;
  uint64_t v19 = __ROR8__(v18, 32);
  uint64_t v20 = v18 ^ __ROR8__(v13, 47);
  uint64_t v21 = v16 + v20;
  uint64_t v22 = v21 ^ __ROR8__(v20, 51);
  uint64_t v23 = v19 + v17;
  uint64_t v24 = (v19 + v17) ^ __ROR8__(v17, 48);
  uint64_t v25 = __ROR8__(v21, 32) + v24;
  uint64_t v26 = v25 ^ __ROR8__(v24, 43);
  uint64_t v27 = v22 + v23;
  uint64_t v28 = v27 ^ __ROR8__(v22, 47);
  uint64_t v29 = __ROR8__(v27, 32) + v26;
  uint64_t v30 = (v25 + v28) ^ __ROR8__(v28, 51);
  return __ROR8__(v29 ^ __ROR8__(v26, 48), 43) ^ __ROR8__(v30 + v29, 32) ^ (v30 + v29) ^ __ROR8__(v30, 47);
}

uint64_t specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (result < a4 || (uint64_t)(a5 >> 1) <= result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
  return result;
}

BOOL specialized static __CocoaDictionary.Index.< infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different dictionaries",  45LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x2AFuLL,  0);
  }
  return a2 < a4;
}

uint64_t specialized AnyCollection.endIndex.getter(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t specialized AnyCollection.startIndex.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

unint64_t specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (result >> 14 < a3 >> 14 || a4 >> 14 < a2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  return result;
}

uint64_t specialized KeyPathBuffer.init(base:)(uint64_t a1)
{
  if ((a1 & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  return a1 + 8;
}

void specialized static KeyPathComponent.== infix(_:_:)(__int128 *a1)
{
  __asm { BR              X10 }

BOOL sub_1816F1584()
{
  v5[8] = v2 & 0x1FFFFFFFFFFFFFFFLL;
  outlined init with take of KeyPathComponent(v0, (uint64_t)v5);
  return !(v5[1] >> 61) && v1 == v5[0];
}

uint64_t specialized static AnyKeyPath.== infix(_:_:)(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (*a1 != *a2) {
    return 0LL;
  }
  uint64_t v3 = specialized KeyPathBuffer.init(base:)((uint64_t)(a1 + 3));
  uint64_t v5 = v4;
  int v7 = v6;
  uint64_t v43 = v3;
  uint64_t v44 = v4;
  uint64_t v8 = specialized KeyPathBuffer.init(base:)((uint64_t)(a2 + 3));
  uint64_t v41 = v8;
  uint64_t v42 = v9;
  if (((v7 ^ v10) & 0x100) != 0) {
    return 0LL;
  }
  if (v3 && v5 != v3)
  {
    while (1)
    {
      uint64_t v13 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v43, 1LL);
      if (!v13) {
        goto LABEL_82;
      }
      uint64_t v14 = *v13;
      uint64_t v15 = v43;
      unsigned int v16 = BYTE3(v14) & 0x7F;
      if (v16 == 1) {
        goto LABEL_19;
      }
      if (v16 != 2) {
        break;
      }
      uint64_t v17 = 28LL;
      if ((v14 & 0x400000) == 0) {
        uint64_t v17 = 20LL;
      }
      if ((v14 & 0x80000) != 0)
      {
        if (!v43) {
          goto LABEL_82;
        }
        uint64_t v20 = 24LL;
        if ((v14 & 0x400000) == 0) {
          uint64_t v20 = 16LL;
        }
        uint64_t v21 = v43 + v20 + 4;
        if ((v21 & 7) != 0) {
          goto LABEL_77;
        }
        uint64_t v22 = v17 + 16;
        uint64_t v23 = *(void *)v21;
        BOOL v24 = __OFADD__(v22, v23);
        uint64_t v17 = v22 + v23;
        if (v24)
        {
          __break(1u);
LABEL_79:
          __break(1u);
LABEL_80:
          __break(1u);
LABEL_81:
          __break(1u);
LABEL_82:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }

        if ((v14 & 0x10) != 0)
        {
          BOOL v24 = __OFADD__(v17, 8LL);
          v17 += 8LL;
          if (v24) {
            goto LABEL_80;
          }
        }

        if (v17 < 0) {
          goto LABEL_76;
        }
        goto LABEL_36;
      }

BOOL specialized static __CocoaSet.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v8 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different sets",  37LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1F5uLL,  0);
  }
  return a2 == a4;
}

BOOL specialized _StringGuts.checkIfInEmojiSequence(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((v6 & 1) == 0)
  {
    uint64_t v7 = v5;
    while (1)
    {
      unsigned int v8 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v7, a2, a3);
      if ((v10 & 1) != 0 || v8 < 0x20) {
        break;
      }
      uint64_t v11 = 0LL;
      int32x4_t v12 = vdupq_n_s32(v8);
      if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v12, (int32x4_t)xmmword_181800030),  (uint32x4_t)xmmword_181800050),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v12, (int32x4_t)xmmword_181800040),  (uint32x4_t)xmmword_181800060)))) & 1) != 0 || v8 < 0x7F || v8 == 8205)
      {
        return v11;
      }

      if (v8 - 131070 > 0xFFFFFC01) {
        return 1LL;
      }
      if (v8 - 921600 > 0xFFFFF1EF) {
        return 0LL;
      }
      uint64_t v7 = v9;
      int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v8);
      if (GraphemeBreakProperty != 1) {
        return (GraphemeBreakProperty - 4) <= 1;
      }
    }
  }

  return 0LL;
}

uint64_t specialized _StringGuts.checkIfInIndicSequence(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v7 & 1) == 0)
  {
    int v8 = v5;
    unsigned int v9 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v6, a2, a3);
    if ((v11 & 1) == 0)
    {
      unsigned int v12 = v9;
      uint64_t v13 = v10;
      HIDWORD(v14) = v8 - 2381;
      LODWORD(v14) = v8 - 2381;
      unsigned int v15 = ((v14 >> 7) < 9) & (0x15Bu >> (v14 >> 7));
      while (1)
      {
        if (v12 < 0x20)
        {
LABEL_20:
          LOBYTE(v16) = 1;
          goto LABEL_22;
        }

        if (v12 < 0x7F) {
          goto LABEL_21;
        }
        if (v12 == 8205)
        {
          LOBYTE(v16) = 12;
          goto LABEL_22;
        }

        LOBYTE(v16) = 4;
        if (v12 - 4448 <= 0xFFFFFF9F && v12 - 43389 < 0xFFFFFFE3)
        {
          LOBYTE(v16) = 11;
          if (v12 - 4520 <= 0xFFFFFFB7 && v12 - 55239 <= 0xFFFFFFE8)
          {
            LOBYTE(v16) = 10;
            if (v12 - 4608 <= 0xFFFFFFA7 && v12 - 55292 <= 0xFFFFFFCE)
            {
              if (v12 - 55204 > 0xFFFFD45B)
              {
                HIDWORD(v25) = -1227133513 * ((unsigned __int16)v12 - 16);
                LODWORD(v25) = HIDWORD(v25);
                else {
                  LOBYTE(v16) = 6;
                }
              }

              else if (v12 - 127488 > 0xFFFFFFE5)
              {
                LOBYTE(v16) = 8;
              }

              else
              {
                if (v12 - 131070 <= 0xFFFFFC01)
                {
                  if (v12 - 921600 > 0xFFFFF1EF) {
                    goto LABEL_20;
                  }
                  unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v12);
                  if (GraphemeBreakProperty < 6)
                  {
                    unint64_t v16 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                    goto LABEL_22;
                  }

{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int GraphemeBreakProperty;
  char v17;
  unsigned int v18;
  unint64_t v19;
  BOOL v20;
  unsigned int v21;
  unint64_t v22;
  if (a2 >= a1) {
    return 0LL;
  }
  int v5 = a1;
  uint64_t v6 = a3 - 1;
  do
    char v7 = *(_BYTE *)(v6 + v5--) & 0xC0;
  while (v7 == 128);
  int v8 = _decodeScalar(_:startingAt:)(a3, a2, v5);
  if (v5 <= a2)
  {
LABEL_40:
    uint64_t v17 = 0;
    return v17 & 1;
  }

  HIDWORD(v10) = v8 - 2381;
  LODWORD(v10) = v8 - 2381;
  char v11 = ((v10 >> 7) < 9) & (0x15Bu >> (v10 >> 7));
  while (1)
  {
    do
      unsigned int v12 = *(_BYTE *)(v6 + v5--) & 0xC0;
    while (v12 == 128);
    uint64_t v13 = _decodeScalar(_:startingAt:)(a3, v9, v5);
    unint64_t v14 = v13;
    if (v13 < 0x20)
    {
LABEL_23:
      LOBYTE(v15) = 1;
      goto LABEL_25;
    }

    if (v13 < 0x7F) {
      goto LABEL_24;
    }
    if (v13 == 8205)
    {
      LOBYTE(v15) = 12;
      goto LABEL_25;
    }

    LOBYTE(v15) = 4;
    if (v13 - 4448 <= 0xFFFFFF9F && v13 - 43389 < 0xFFFFFFE3)
    {
      LOBYTE(v15) = 11;
      if (v13 - 4520 <= 0xFFFFFFB7 && v13 - 55239 <= 0xFFFFFFE8)
      {
        LOBYTE(v15) = 10;
        if (v13 - 4608 <= 0xFFFFFFA7 && v13 - 55292 <= 0xFFFFFFCE)
        {
          if (v13 - 55204 > 0xFFFFD45B)
          {
            HIDWORD(v22) = -1227133513 * ((unsigned __int16)v13 - 16);
            LODWORD(v22) = HIDWORD(v22);
            else {
              LOBYTE(v15) = 6;
            }
          }

          else if (v13 - 127488 > 0xFFFFFFE5)
          {
            LOBYTE(v15) = 8;
          }

          else
          {
            if (v13 - 131070 <= 0xFFFFFC01)
            {
              if (v13 - 921600 > 0xFFFFF1EF) {
                goto LABEL_23;
              }
              unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v13);
              if (GraphemeBreakProperty < 6)
              {
                unsigned int v15 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                goto LABEL_25;
              }

uint64_t specialized _StringGuts.countRIs(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((v6 & 1) != 0) {
    return 0LL;
  }
  for (uint64_t i = 0LL; ; ++i)
  {
    unsigned int v8 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v5, a2, a3);
    if ((v9 & 1) != 0
      || v8 < 0x20
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32( (uint32x4_t)vaddq_s32( vdupq_n_s32(v8),  (int32x4_t)xmmword_181800030),  (uint32x4_t)xmmword_181800050))) & 1) != 0 || v8 - 4608 > 0xFFFFFFA7 || v8 - 55292 > 0xFFFFFFCE || v8 - 55204 > 0xFFFFD45B || v8 < 0x7F || v8 == 8205)
    {
      break;
    }

    if (v8 - 127488 <= 0xFFFFFFE5)
    {
      if (v8 - 131070 <= 0xFFFFFC01 && v8 - 921600 <= 0xFFFFF1EF) {
        _swift_stdlib_getGraphemeBreakProperty(v8);
      }
      return i & 1;
    }

    if (__OFADD__(i, 1LL))
    {
      __break(1u);
      return 0LL;
    }
  }

  return i & 1;
}

uint64_t specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)( unsigned int a1, unsigned int a2, uint64_t a3, char *a4, unint64_t a5)
{
  if (a1 == 13 && a2 == 10)
  {
LABEL_15:
    char v12 = 0;
    return v12 & 1;
  }

  int32x4_t v10 = vdupq_n_s32(a1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1817FFF40),  (uint32x4_t)xmmword_1817FFF60),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1817FFF50),  (uint32x4_t)xmmword_1817FFF70)))) & 1) != 0 || a1 - 65438 > 0xFFFFFF62 || a1 < 0x300)
  {
    int32x4_t v11 = vdupq_n_s32(a2);
    char v12 = 1;
    if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1817FFF40),  (uint32x4_t)xmmword_1817FFF60),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1817FFF50),  (uint32x4_t)xmmword_1817FFF70)))) & 1) != 0 || a2 - 65438 > 0xFFFFFF62 || a2 <= 0x2FF)
    {
      return v12 & 1;
    }
  }

  swift_bridgeObjectRetain_n(a5, 4LL, a3, a4);
  char v13 = Unicode._GraphemeBreakProperty.init(from:)(a1);
  char v14 = Unicode._GraphemeBreakProperty.init(from:)(a2);
  if (v13 == 1)
  {
LABEL_32:
    swift_bridgeObjectRelease_n(a5, 4LL);
    char v12 = 1;
    return v12 & 1;
  }

  if (!v13)
  {
    switch(v14)
    {
      case 0:
      case 1:
        goto LABEL_32;
      case 2:
      case 9:
      case 12:
        goto LABEL_14;
      default:
        goto LABEL_12;
    }
  }

  switch(v14)
  {
    case 1:
      goto LABEL_32;
    case 2:
    case 9:
    case 12:
      goto LABEL_14;
    case 4:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }

    case 5:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }

    case 6:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }

    case 10:
      switch(v13)
      {
        case 5:
        case 6:
        case 7:
        case 10:
        case 11:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }

    case 11:
      switch(v13)
      {
        case 4:
        case 5:
        case 7:
        case 11:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }

    default:
      if (v13 == 12)
      {
        if (v14 == 3)
        {
          swift_bridgeObjectRetain(a5, v15, v16, v17);
          char v23 = specialized _StringGuts.checkIfInEmojiSequence(at:with:)(a3, (uint64_t)a4, a5);
LABEL_38:
          char v24 = v23;
          swift_bridgeObjectRelease_n(a5, 5LL);
          char v12 = v24 ^ 1;
          return v12 & 1;
        }

BOOL specialized _StringGuts.checkIfInEmojiSequence(at:with:)(uint64_t a1, uint64_t a2)
{
  if (a1 < 1) {
    return 0LL;
  }
  uint64_t v3 = a1;
  uint64_t v4 = a2 - 1;
  do
    int v5 = *(_BYTE *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  _decodeScalar(_:startingAt:)(a2, a2, v3);
  while (v3 >= 1)
  {
    do
      int v7 = *(_BYTE *)(v4 + v3--) & 0xC0;
    while (v7 == 128);
    unsigned int v8 = _decodeScalar(_:startingAt:)(a2, v6, v3);
    if (v8 < 0x20) {
      break;
    }
    unsigned int v9 = v8;
    BOOL result = 0LL;
    int32x4_t v11 = vdupq_n_s32(v9);
    if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_181800030),  (uint32x4_t)xmmword_181800050),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_181800040),  (uint32x4_t)xmmword_181800060)))) & 1) != 0 || v9 < 0x7F || v9 == 8205)
    {
      return result;
    }

    if (v9 - 131070 > 0xFFFFFC01) {
      return 1LL;
    }
    if (v9 - 921600 > 0xFFFFF1EF) {
      return 0LL;
    }
    int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v9);
    if (GraphemeBreakProperty != 1) {
      return (GraphemeBreakProperty - 4) <= 1;
    }
  }

  return 0LL;
}

uint64_t specialized _StringGuts.checkIfInIndicSequence(at:with:)(uint64_t a1, uint64_t a2)
{
  if (a1 < 1) {
    return 0LL;
  }
  uint64_t v3 = a1;
  uint64_t v4 = a2 - 1;
  do
    int v5 = *(_BYTE *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  int v6 = _decodeScalar(_:startingAt:)(a2, a2, v3);
  if (v3 < 1)
  {
LABEL_39:
    char v15 = 0;
    return v15 & 1;
  }

  HIDWORD(v8) = v6 - 2381;
  LODWORD(v8) = v6 - 2381;
  unsigned int v9 = ((v8 >> 7) < 9) & (0x15Bu >> (v8 >> 7));
  while (1)
  {
    do
      int v10 = *(_BYTE *)(v4 + v3--) & 0xC0;
    while (v10 == 128);
    unsigned int v11 = _decodeScalar(_:startingAt:)(a2, v7, v3);
    unsigned int v12 = v11;
    if (v11 < 0x20)
    {
LABEL_23:
      LOBYTE(v13) = 1;
      goto LABEL_25;
    }

    if (v11 < 0x7F) {
      goto LABEL_24;
    }
    if (v11 == 8205)
    {
      LOBYTE(v13) = 12;
      goto LABEL_25;
    }

    LOBYTE(v13) = 4;
    if (v11 - 4448 <= 0xFFFFFF9F && v11 - 43389 < 0xFFFFFFE3)
    {
      LOBYTE(v13) = 11;
      if (v11 - 4520 <= 0xFFFFFFB7 && v11 - 55239 <= 0xFFFFFFE8)
      {
        LOBYTE(v13) = 10;
        if (v11 - 4608 <= 0xFFFFFFA7 && v11 - 55292 <= 0xFFFFFFCE)
        {
          if (v11 - 55204 > 0xFFFFD45B)
          {
            HIDWORD(v20) = -1227133513 * ((unsigned __int16)v11 - 16);
            LODWORD(v20) = HIDWORD(v20);
            else {
              LOBYTE(v13) = 6;
            }
          }

          else if (v11 - 127488 > 0xFFFFFFE5)
          {
            LOBYTE(v13) = 8;
          }

          else
          {
            if (v11 - 131070 <= 0xFFFFFC01)
            {
              if (v11 - 921600 > 0xFFFFF1EF) {
                goto LABEL_23;
              }
              unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v11);
              if (GraphemeBreakProperty < 6)
              {
                unint64_t v13 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                goto LABEL_25;
              }

uint64_t specialized _StringGuts.countRIs(at:with:)(uint64_t a1, uint64_t a2)
{
  if (a1 < 1) {
    return 0LL;
  }
  uint64_t v3 = a1;
  uint64_t v4 = a2 - 1;
  do
    int v5 = *(_BYTE *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  _decodeScalar(_:startingAt:)(a2, a2, v3);
  for (uint64_t i = 0LL; v3 >= 1; ++i)
  {
    do
      int v8 = *(_BYTE *)(v4 + v3--) & 0xC0;
    while (v8 == 128);
    unsigned int v9 = _decodeScalar(_:startingAt:)(a2, v6, v3);
    if (v9 < 0x20
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32( (uint32x4_t)vaddq_s32( vdupq_n_s32(v9),  (int32x4_t)xmmword_181800030),  (uint32x4_t)xmmword_181800050))) & 1) != 0 || v9 - 4608 > 0xFFFFFFA7 || v9 - 55292 > 0xFFFFFFCE || v9 - 55204 > 0xFFFFD45B || v9 < 0x7F || v9 == 8205)
    {
      break;
    }

    if (v9 - 127488 <= 0xFFFFFFE5)
    {
      if (v9 - 131070 <= 0xFFFFFC01 && v9 - 921600 <= 0xFFFFF1EF) {
        _swift_stdlib_getGraphemeBreakProperty(v9);
      }
      return i & 1;
    }

    if (__OFADD__(i, 1LL))
    {
      __break(1u);
      return 0LL;
    }
  }

  return i & 1;
}

uint64_t specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)( unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a1 == 13 && a2 == 10)
  {
LABEL_3:
    LOBYTE(v8) = 0;
    return v8 & 1;
  }

  int32x4_t v10 = vdupq_n_s32(a1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1817FFE80),  (uint32x4_t)xmmword_1817FFE90),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1817FFF50),  (uint32x4_t)xmmword_1817FFF70)))) & 1) != 0 || a1 - 65438 > 0xFFFFFF62 || a1 < 0x300)
  {
    int32x4_t v11 = vdupq_n_s32(a2);
    LOBYTE(v8) = 1;
    if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1817FFF40),  (uint32x4_t)xmmword_1817FFF60),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1817FFF50),  (uint32x4_t)xmmword_1817FFF70)))) & 1) != 0 || a2 - 65438 > 0xFFFFFF62 || a2 <= 0x2FF)
    {
      return v8 & 1;
    }
  }

  unsigned __int8 v12 = Unicode._GraphemeBreakProperty.init(from:)(a1);
  char v13 = Unicode._GraphemeBreakProperty.init(from:)(a2);
  LOBYTE(v8) = v12;
  if (v12 == 1) {
    return v8 & 1;
  }
  if (!v12)
  {
    if (((0x1207u >> v13) & 1) != 0)
    {
      unsigned int v8 = (0xDFBu >> v13) & 1;
      return v8 & 1;
    }

BOOL specialized static __CocoaDictionary.Index.== infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different dictionaries",  45LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x2A2uLL,  0);
  }
  return a2 == a4;
}

BOOL specialized static Unicode._CharacterRecognizer.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return ((*(_DWORD *)a1 != *(_DWORD *)a2) | ((*(_BYTE *)(a1 + 4) ^ *(_BYTE *)(a2 + 4)) | (*(_BYTE *)(a1 + 5) ^ *(_BYTE *)(a2 + 5))) & 1 | ((*(_BYTE *)(a1 + 6) ^ *(_BYTE *)(a2 + 6)) | (*(_BYTE *)(a2 + 7) ^ *(_BYTE *)(a1 + 7))) & 1) == 0;
}

uint64_t specialized closure #1 in _StringGuts._foreignOpaqueCharacterStride(endingAt:in:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= a1) {
    return 0LL;
  }
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  if (!(v7._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
    v21._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)rawBits)._rawBits;
    LODWORD(result) = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v21._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
  }

  else
  {
    if ((a4 & 0x2000000000000000LL) != 0)
    {
      uint64_t v25 = a3;
      uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
      char v13 = (char *)&v25 + (v7._rawBits >> 16);
      if ((*(v13 - 1) & 0xC0) == 0x80)
      {
        uint64_t v14 = 0LL;
        char v15 = v13 - 2;
        do
          int v16 = v15[v14--] & 0xC0;
        while (v16 == 128);
        uint64_t v12 = 1 - v14;
      }

      else
      {
        uint64_t v12 = 1LL;
      }
    }

    else
    {
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        id v8 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        Swift::UInt64 v22 = v7._rawBits;
        id v8 = _StringObject.sharedUTF8.getter(a3, a4);
        v7._Swift::UInt64 rawBits = v22;
      }

      uint64_t v9 = 0LL;
      Swift::UInt64 v10 = (Swift::UInt64)v8 + (v7._rawBits >> 16) - 1;
      do
        int v11 = *(_BYTE *)(v10 + v9--) & 0xC0;
      while (v11 == 128);
      uint64_t v12 = -v9;
    }

    v18._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)((v7._rawBits - (v12 << 16)) & 0xFFFFFFFFFFFF0000LL | 5))._rawBits >> 16;
    if ((a4 & 0x2000000000000000LL) != 0)
    {
      uint64_t v25 = a3;
      uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
      unsigned int v19 = &v25;
    }

    else if ((a3 & 0x1000000000000000LL) != 0)
    {
      unsigned int v19 = (void *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v23 = a4;
      Swift::UInt64 v24 = v18._rawBits;
      unsigned int v19 = _StringObject.sharedUTF8.getter(a3, v23);
      v18._Swift::UInt64 rawBits = v24;
    }

    LODWORD(result) = _decodeScalar(_:startingAt:)((uint64_t)v19, v17._rawBits, v18._rawBits);
  }

  return result;
}

uint64_t specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= a1) {
    return 0LL;
  }
  uint64_t v4 = a1;
  do
    int v5 = *(_BYTE *)(a3 - 1 + v4--) & 0xC0;
  while (v5 == 128);
  return _decodeScalar(_:startingAt:)(a3, a2, v4);
}

uint64_t specialized _UIntBuffer._elementWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result < a2 || result >= a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return result;
}

unint64_t specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)( unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || result >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return result;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2)
{
  if (a2 < result || HIDWORD(a2) >= result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return result;
}

uint64_t specialized __CocoaDictionary.Index.key.getter(uint64_t a1, uint64_t a2)
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v4 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  uint64_t v5 = *(void *)(v3 + 24);
  if (*(void *)(v5 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
  }
  return *(void *)(v5 + 8 * a2 + 24);
}

uint64_t specialized __CocoaDictionary.key(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v6 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v5, v6)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v5 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x225uLL,  0);
  }
  uint64_t v7 = *(void *)(v5 + 24);
  if (*(void *)(v7 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x28BuLL,  0);
  }
  return *(void *)(v7 + 8 * a2 + 24);
}

uint64_t specialized __CocoaSet.Index.element.getter(uint64_t a1, uint64_t a2)
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v4 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  uint64_t v5 = *(void *)(v3 + 24);
  if (*(void *)(v5 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1E1uLL,  0);
  }
  return *(void *)(v5 + 8 * a2 + 24);
}

Swift::UInt64 specialized String.UnicodeScalarView.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a2._rawBits;
  Swift::UInt64 v7 = a1._rawBits;
  uint64_t v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = a1._rawBits & 0xC;
  uint64_t v10 = 4LL << v8;
  uint64_t v11 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v9 == v10 || (a2._rawBits & 1) == 0 || v11 == v10)
  {
    if (v11 == v10)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v9 != v10) {
        goto LABEL_13;
      }
    }

    else if (v9 != v10)
    {
      goto LABEL_13;
    }

    Swift::UInt64 v7 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v7)._rawBits;
LABEL_13:
    uint64_t v14 = a3 & 0xFFFFFFFFFFFFLL;
    if ((a4 & 0x2000000000000000LL) != 0) {
      uint64_t v14 = HIBYTE(a4) & 0xF;
    }
    if (rawBits >> 14 > 4 * v14 || rawBits >> 14 < v7 >> 14)
    {
      unint64_t v13 = 80LL;
LABEL_21:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v13,  0);
    }

    if ((v7 & 1) != 0)
    {
      if ((rawBits & 1) != 0) {
        return v7;
      }
    }

    else
    {
      Swift::UInt64 v7 = v7 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v7)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((rawBits & 1) != 0) {
        return v7;
      }
    }

    _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    return v7;
  }

  Swift::UInt64 v12 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v12 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v12 < a2._rawBits >> 16)
  {
    unint64_t v13 = 210LL;
    goto LABEL_21;
  }

  return v7;
}

Swift::UInt64 specialized String.UTF8View.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = 4LL << v8;
  if ((a2._rawBits & 0xC) == 4LL << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  }
  if ((a1._rawBits & 0xC) == v9) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  uint64_t v10 = a3 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v10 = HIBYTE(a4) & 0xF;
  }
  if (rawBits >> 14 > 4 * v10 || rawBits >> 14 < a1._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x50uLL,  0);
  }
  return a1._rawBits;
}

Swift::UInt64 specialized Substring.UTF8View.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v10 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v10) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((a2._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  }
  if ((a1._rawBits & 0xC) == v11) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if (a1._rawBits >> 14 < a3 >> 14 || rawBits >> 14 < a1._rawBits >> 14 || a4 >> 14 < rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
  }
  return a1._rawBits;
}

Swift::UInt64 specialized Substring.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits = a2._rawBits;
  Swift::UInt64 v9 = a1._rawBits;
  uint64_t v10 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v10) = 1;
  }
  uint64_t v11 = a1._rawBits & 0xC;
  uint64_t v12 = 4LL << v10;
  uint64_t v13 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v11 == v12 || (a2._rawBits & 1) == 0 || v13 == v12)
  {
    if (v13 == v12)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v11 != v12) {
        goto LABEL_12;
      }
    }

    else if (v11 != v12)
    {
LABEL_12:
      if (v9 >> 14 < a3 >> 14 || rawBits >> 14 < v9 >> 14 || a4 >> 14 < rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
      }
      if ((rawBits & 1) != 0)
      {
        if ((v9 & 1) != 0) {
          return v9;
        }
      }

      else
      {
        _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
        if ((v9 & 1) != 0) {
          return v9;
        }
      }

      return v9 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    }

    Swift::UInt64 v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
    goto LABEL_12;
  }

  if (a1._rawBits >> 14 < a3 >> 14 || a4 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
  }
  return v9;
}

uint64_t specialized _SliceBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  return a3;
}

uint64_t specialized ContiguousArray.subscript.getter(Swift::Int a1, Swift::Int a2, uint64_t a3)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  return a3;
}

uint64_t specialized _ContiguousArrayBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  return a3;
}

uint64_t specialized CollectionDifference.index(after:)(uint64_t a1)
{
  BOOL v1 = __OFADD__(a1, 1LL);
  uint64_t result = a1 + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t specialized static Duration.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = __CFADD__(a1, a3);
  uint64_t result = a1 + a3;
  int v6 = v4;
  if (__OFADD__(a2, a4) || v6 && a2 + a4 == 0x7FFFFFFFFFFFFFFFLL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x25EuLL,  0);
  }
  return result;
}

unint64_t specialized static Duration.- infix(_:_:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4 = __OFSUB__(a2, a4);
  uint64_t v5 = a2 - a4;
  int v6 = v4;
  BOOL v7 = a1 >= a3;
  unint64_t result = a1 - a3;
  if (v7)
  {
    if (v6) {
      goto LABEL_8;
    }
  }

  else
  {
    if (v5 == 0x8000000000000000LL) {
      LOBYTE(v6) = 1;
    }
    if ((v6 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x252uLL,  0);
  }

  return result;
}

unint64_t specialized String.UTF16View._foreignDistance(from:to:)( unint64_t a1, unint64_t a2)
{
  return (a2 >> 16) - (a1 >> 16);
}

unint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)( unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || a3 >> 14 < result >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }
  return result;
}

unint64_t specialized RandomAccessCollection<>.distance(from:to:)( unint64_t a1, unint64_t a2)
{
  if (a1 >= 2 || a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }
  return a2 - a1;
}

{
  if (a1 >= 3 || a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }
  return a2 - a1;
}

void **specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)( void **result, uint64_t a2, void **a3, id a4)
{
  if (__OFSUB__(a2, result))
  {
    __break(1u);
  }

  else
  {
    BOOL v4 = a3;
    uint64_t v6 = (uint64_t)result;
    objc_msgSend(a4, sel_getObjects_range_, a3, result, a2 - (void)result);
    uint64_t v10 = a2 - v6;
    if (a2 != v6)
    {
      if (a2 <= v6) {
        uint64_t v11 = v6;
      }
      else {
        uint64_t v11 = a2;
      }
      uint64_t v12 = v11 - v6;
      do
      {
        if (!v12) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        uint64_t v13 = *v4++;
        swift_unknownObjectRetain(v13, v7, v8, v9);
        --v12;
        --v10;
      }

      while (v10);
    }

    return v4;
  }

  return result;
}

uint64_t specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5 = a3 - a1;
  if (__OFSUB__(a3, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a4,  0);
  }
  if (a2 < 1)
  {
    if (v5 > 0 || v5 <= a2) {
      goto LABEL_9;
    }
    return 0LL;
  }

uint64_t specialized Array.index(_:offsetBy:limitedBy:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - result;
  if (__OFSUB__(a3, result))
  {
    __break(1u);
    goto LABEL_12;
  }

  if (a2 >= 1)
  {
    return 0LL;
  }

  if (v3 <= 0 && v3 > a2) {
    return 0LL;
  }
LABEL_9:
  BOOL v4 = __OFADD__(result, a2);
  result += a2;
  if (v4) {
LABEL_12:
  }
    __break(1u);
  return result;
}

unint64_t specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)( unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 >= 2 || a3 >= 2) {
LABEL_3:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  uint64_t v3 = a3 - a1;
  if (a2 >= 1)
  {
    return 0LL;
  }

  if (v3 <= 0 && v3 > a2) {
    return 0LL;
  }
LABEL_11:
  BOOL v5 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v5)
  {
    __break(1u);
  }

  else if (result >= 2)
  {
    goto LABEL_3;
  }

  return result;
}

{
  uint64_t v3;
  unint64_t result;
  BOOL v5;
  if (a1 >= 3 || a3 >= 3) {
LABEL_3:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  uint64_t v3 = a3 - a1;
  if (a2 >= 1)
  {
    return 0LL;
  }

  if (v3 <= 0 && v3 > a2) {
    return 0LL;
  }
LABEL_11:
  BOOL v5 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v5)
  {
    __break(1u);
  }

  else if (result >= 3)
  {
    goto LABEL_3;
  }

  return result;
}

unint64_t specialized RandomAccessCollection<>.index(_:offsetBy:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v2)
  {
    __break(1u);
  }

  else if (result >= 2)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  return result;
}

{
  BOOL v2;
  unint64_t result;
  BOOL v2 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v2)
  {
    __break(1u);
  }

  else if (result >= 3)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  return result;
}

char *specialized _BidirectionalCollectionBox.init(_base:)(uint64_t a1)
{
  BOOL v2 = v1;
  uint64_t v4 = *(void *)v2;
  uint64_t v5 = *(void *)(*(void *)v2 + 368LL);
  uint64_t v6 = *(void *)(*(void *)(*(void *)v2 + 376LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(&v2[*(void *)(v4 + 384)], a1, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v5, v6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  char v15 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
  v15(&v14[*(void *)(*(void *)v14 + 96LL)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  int v16 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15(&v16[*(void *)(*(void *)v16 + 96LL)], v10, AssociatedTypeWitness);
  *((void *)v2 + 2) = v14;
  *((void *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v2 + 4) = v16;
  *((void *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

char *specialized _RandomAccessCollectionBox.init(_base:)(uint64_t a1)
{
  BOOL v2 = v1;
  uint64_t v4 = *(void *)v2;
  uint64_t v5 = *(void *)(*(void *)v2 + 376LL);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(*(void *)v2 + 384LL) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(&v2[*(void *)(v4 + 392)], a1, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v5, v6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  char v15 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
  v15(&v14[*(void *)(*(void *)v14 + 96LL)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  int v16 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15(&v16[*(void *)(*(void *)v16 + 96LL)], v10, AssociatedTypeWitness);
  *((void *)v2 + 2) = v14;
  *((void *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v2 + 4) = v16;
  *((void *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

char *specialized _CollectionBox.init(_base:)(uint64_t a1)
{
  BOOL v2 = v1;
  uint64_t v4 = *(void *)v2;
  uint64_t v6 = *(void *)(*(void *)v2 + 344LL);
  uint64_t v5 = *(void *)(*(void *)v2 + 352LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(&v2[*(void *)(v4 + 360)], a1, v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v6, v5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  char v15 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
  v15(&v14[*(void *)(*(void *)v14 + 96LL)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v5 + 72))(v6, v5);
  int v16 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15(&v16[*(void *)(*(void *)v16 + 96LL)], v10, AssociatedTypeWitness);
  *((void *)v2 + 2) = v14;
  *((void *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v2 + 4) = v16;
  *((void *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

uint64_t specialized _UInt128.init<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, uint64_t, uint64_t), unint64_t a5)
{
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v11 + 16))(v10);
  uint64_t result = a4(v10, a2, a3);
  if ((v13 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000028LL,  0x80000001818B7CB0LL,  "Swift/LegacyInt128.swift",  24LL,  2,  a5,  0);
  }
  return result;
}

uint64_t specialized UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v7 + 16))(v6);
  uint64_t result = UInt128.init<A>(exactly:)(v6, a2, a3);
  if ((v9 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000052LL,  0x80000001818BAB80LL,  "Swift/UInt128.swift",  19LL,  2,  0x96uLL,  0);
  }
  return result;
}

uint64_t specialized Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v7 + 16))(v6);
  uint64_t result = Int128.init<A>(exactly:)((uint64_t)v6, a2, a3);
  if ((v9 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000051LL,  0x80000001818BAC10LL,  "Swift/Int128.swift",  18LL,  2,  0x99uLL,  0);
  }
  return result;
}

__objc2_class **specialized DiscontiguousSlice._copyToContiguousArray()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v57 = (char *)&v49 - v6;
  unint64_t v7 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v10 = type metadata accessor for Range(0LL, v7, AssociatedConformanceWitness, v9);
  uint64_t v55 = *(void *)(v10 - 8);
  uint64_t v56 = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v54 = (char *)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v53 = (char *)&v49 - v13;
  uint64_t v14 = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  _swift_isClassOrObjCExistentialType((uint64_t)v14, v14);
  uint64_t v15 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v14);
  if (v15)
  {
    uint64_t v18 = (__objc2_class **)v15;
  }

  else
  {
    char v61 = (unint64_t *)&_swiftEmptyArrayStorage;
    uint64_t v19 = type metadata accessor for Array(0LL, (uint64_t)v14, v16, v17);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v19, v20);
    uint64_t v18 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v61, v19, WitnessTable);
  }

  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v63 = v18;
  uint64_t v23 = *(int *)(type metadata accessor for DiscontiguousSlice(0LL, a2, a3, v22) + 36);
  uint64_t v59 = a1;
  char v61 = *(unint64_t **)(a1 + v23);
  unint64_t v62 = 0LL;
  unint64_t v24 = v61[2];
  uint64_t v28 = swift_retain(v61, v25, v26, v27);
  if (v24)
  {
    unint64_t v29 = 0LL;
    uint64_t v52 = (char *)&v62;
    unsigned int v30 = v54;
    do
    {
      if (v29 >= v24) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      uint64_t v50 = v14;
      uint64_t v31 = v55;
      uint64_t v32 = v56;
      (*(void (**)(char *, unint64_t, uint64_t))(v55 + 16))( v30,  (unint64_t)v28 + ((*(unsigned __int8 *)(v31 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v31 + 80))
      + *(void *)(v55 + 72) * v29,
        v56);
      v60[0] = 0LL;
      v60[1] = v24;
      uint64_t v34 = type metadata accessor for RangeSet.Ranges(0LL, v7, AssociatedConformanceWitness, v33);
      uint64_t v36 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v34, v35);
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v52, (uint64_t)v60, v34, v36);
      unint64_t v62 = v29 + 1;
      uint64_t v37 = v53;
      (*(void (**)(char *, char *, uint64_t))(v31 + 32))(v53, v30, v32);
      uint64_t v38 = *(void (**)(char *, uint64_t, uint64_t))(a3 + 88);
      unint64_t v51 = AssociatedConformanceWitness;
      unint64_t v39 = v7;
      char v40 = v57;
      v38(v37, a2, a3);
      uint64_t v41 = *(void (**)(char *, uint64_t))(v31 + 8);
      uint64_t v14 = v50;
      v41(v37, v32);
      uint64_t v44 = type metadata accessor for ContiguousArray(0LL, (uint64_t)v14, v42, v43);
      uint64_t v45 = AssociatedTypeWitness;
      uint64_t v46 = *(void *)(swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection)
                      + 8);
      uint64_t v47 = (uint64_t)v40;
      unint64_t v7 = v39;
      unint64_t AssociatedConformanceWitness = v51;
      ContiguousArray.append<A>(contentsOf:)(v47, v44, v45, v46);
      uint64_t v28 = v61;
      unint64_t v29 = v62;
      unint64_t v24 = v61[2];
    }

    while (v62 != v24);
    uint64_t v18 = v63;
  }

  swift_release((uint64_t)v28);
  return v18;
}

uint64_t specialized AnySequence._copyToContiguousArray()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 144LL))();
}

void *specialized AnyBidirectionalCollection._copyContents(initializing:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)a3 + 152LL))();
  uint64_t v8 = type metadata accessor for AnyIterator(255LL, a4, v6, v7);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyIterator<A>, v8, v9);
  uint64_t v12 = type metadata accessor for _IteratorBox(0LL, v8, WitnessTable, v11);
  uint64_t result = swift_allocObject(v12, 0x18uLL, 7uLL);
  result[2] = v5;
  return result;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)( uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v34 = (char *)&v31 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v31 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v16 = type metadata accessor for ClosedRange(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v31 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  Swift::String::Index v21 = (char *)&v31 - v20;
  uint64_t v32 = v22;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 16);
  v23((char *)&v31 - v20, a2, v16);
  uint64_t v33 = v9;
  unint64_t v24 = *(void (**)(char *, uint64_t, unint64_t))(v9 + 16);
  v24(v13, a1, AssociatedTypeWitness);
  uint64_t v25 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  LOBYTE(a2) = v25(v21, v13, AssociatedTypeWitness, AssociatedConformanceWitness);
  v24(v34, (uint64_t)v13, AssociatedTypeWitness);
  v23(v19, (uint64_t)v21, v16);
  if ((a2 & 1) == 0)
  {
    (*(void (**)(char *, uint64_t))(v32 + 8))(v19, v16);
    (*(void (**)(char *, unint64_t))(v33 + 8))(v34, AssociatedTypeWitness);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  uint64_t v26 = v34;
  char v27 = v25(v34, &v19[*(int *)(v16 + 36)], AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v28 = *(void (**)(char *, uint64_t))(v32 + 8);
  v28(v19, v16);
  unint64_t v29 = *(void (**)(char *, unint64_t))(v33 + 8);
  v29(v26, AssociatedTypeWitness);
  if ((v27 & 1) == 0) {
    goto LABEL_5;
  }
  v29(v13, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, uint64_t))v28)(v21, v16);
}

uint64_t specialized Range<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 40))(a2, a3, a4);
  uint64_t v13 = specialized numericCast<A, B>(_:)((uint64_t)v12, AssociatedTypeWitness, *(void *)(a5 + 8));
  (*(void (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
  return v13;
}

uint64_t specialized static AnyIndex.== infix(_:_:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v9 = (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
  unint64_t v10 = swift_getObjectType(a3);
  if (v9 != (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 8))(v10, a4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Base index types differ",  23LL,  2,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x747uLL,  0);
  }
  unint64_t v11 = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t, unint64_t, uint64_t))(a2 + 24))(a3, a4, v11, a2) & 1;
}

uint64_t specialized static AnyHashable.== infix(_:_:)(void *a1, void *a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v11, v3, v4);
  uint64_t v5 = v12;
  uint64_t v6 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  uint64_t v7 = a2[3];
  uint64_t v8 = a2[4];
  __swift_project_boxed_opaque_existential_0Tm(a2, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v10, v7, v8);
  LOBYTE(a2) = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v6 + 16))(v10, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  return a2 & 1;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)( char *a1, char *a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v11 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v10);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v30 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v30 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v30 - v21;
  uint64_t v31 = v23;
  unint64_t v24 = *(void (**)(char *, char *, uint64_t))(v23 + 16);
  v24((char *)&v30 - v21, a2, v11);
  v24(v20, a1, v11);
  uint64_t v25 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  LOBYTE(a1) = v25(v22, v20, AssociatedTypeWitness, AssociatedConformanceWitness);
  v24(v17, v20, v11);
  v24(v14, v22, v11);
  if ((a1 & 1) == 0)
  {
    unint64_t v29 = *(void (**)(char *, uint64_t))(v31 + 8);
    v29(v14, v11);
    v29(v17, v11);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }

  char v26 = v25(&v17[*(int *)(v11 + 36)], &v14[*(int *)(v11 + 36)], AssociatedTypeWitness, AssociatedConformanceWitness);
  char v27 = *(void (**)(char *, uint64_t))(v31 + 8);
  v27(v14, v11);
  v27(v17, v11);
  if ((v26 & 1) == 0) {
    goto LABEL_5;
  }
  v27(v20, v11);
  return ((uint64_t (*)(char *, uint64_t))v27)(v22, v11);
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)( char *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v32 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v30 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v30 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v16 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v30 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v30 - v20;
  uint64_t v31 = v22;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 16);
  v23((char *)&v30 - v20, a2, v16);
  uint64_t v33 = v8;
  unint64_t v24 = *(void (**)(char *, char *, unint64_t))(v8 + 16);
  v24(v13, v32, AssociatedTypeWitness);
  LOBYTE(a2) = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 24))( v21,  v13,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v32 = v11;
  v24(v11, v13, AssociatedTypeWitness);
  v23(v19, (uint64_t)v21, v16);
  if ((a2 & 1) == 0)
  {
    (*(void (**)(char *, uint64_t))(v31 + 8))(v19, v16);
    (*(void (**)(char *, unint64_t))(v33 + 8))(v32, AssociatedTypeWitness);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  uint64_t v25 = v32;
  char v26 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( v32,  &v19[*(int *)(v16 + 36)],  AssociatedTypeWitness,  AssociatedConformanceWitness);
  char v27 = *(void (**)(char *, uint64_t))(v31 + 8);
  v27(v19, v16);
  uint64_t v28 = *(void (**)(char *, unint64_t))(v33 + 8);
  v28(v25, AssociatedTypeWitness);
  if ((v26 & 1) == 0) {
    goto LABEL_5;
  }
  v28(v13, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, uint64_t))v27)(v21, v16);
}

uint64_t specialized static AnyIndex.< infix(_:_:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v9 = (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
  unint64_t v10 = swift_getObjectType(a3);
  if (v9 != (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 8))(v10, a4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Base index types differ",  23LL,  2,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x755uLL,  0);
  }
  unint64_t v11 = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t, unint64_t, uint64_t))(a2 + 32))(a3, a4, v11, a2) & 1;
}

uint64_t specialized UInt128.init<A>(truncatingIfNeeded:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v16 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = 64LL;
  unint64_t v11 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v10 + 240);
  unint64_t v13 = lazy protocol witness table accessor for type Int and conformance Int(v7, v12, v10);
  v11(a1, &v17, &type metadata for Int, v13, a2, a3);
  uint64_t v14 = *(void (**)(uint64_t, uint64_t))(a3 + 120);
  v14(a2, a3);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  return ((uint64_t (*)(uint64_t, uint64_t))v14)(a2, a3);
}

void *specialized static _Int128.+= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  BOOL v4 = __CFADD__(*result, a2);
  BOOL v5 = __OFADD__(v3, a3);
  uint64_t v6 = v3 + a3;
  if (v5 || (v4 ? (BOOL v7 = v6 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v7 = 0), v7)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x264uLL,  0);
  }
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

void *specialized static Duration.+= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  BOOL v4 = __CFADD__(*result, a2);
  BOOL v5 = __OFADD__(v3, a3);
  uint64_t v6 = v3 + a3;
  if (v5 || (v4 ? (BOOL v7 = v6 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v7 = 0), v7)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x25EuLL,  0);
  }
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

void *specialized static _UInt128.+= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  BOOL v4 = __CFADD__(*result, a2);
  BOOL v5 = __CFADD__(v3, a3);
  uint64_t v6 = v3 + a3;
  if (v5 || (v4 ? (BOOL v7 = v6 == -1) : (BOOL v7 = 0), v7)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x71uLL,  0);
  }
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

char *partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( char *a1, uint64_t a2)
{
  return partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(a1, a2);
}

{
  uint64_t v2;
  return closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( a1,  a2,  *(void *)(v2 + 48),  *(char **)(v2 + 56),  *(void *)(v2 + 16),  *(void *)(v2 + 24),  *(void *)(v2 + 32));
}

uint64_t type metadata accessor for _ArrayBuffer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _ArrayBuffer,  &flag for loading of canonical specialized generic type metadata for _ArrayBuffer);
}

  ;
}

char *specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)( uint64_t a1, uint64_t a2, char *__dst, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v5 < 0) {
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(a5 - 8);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = *(void *)(v6 + 72);
  uint64_t v9 = (char *)(a4 + ((v7 + 32) & ~v7) + v8 * a1);
  uint64_t v10 = v8 * v5;
  unint64_t v11 = &__dst[v10];
  unint64_t v12 = (unint64_t)&v9[v10];
  if (v9 < v11 && v12 > (unint64_t)__dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  swift_arrayInitWithCopy(__dst, v9, v5, a5);
  return v11;
}

char *specialized _ArrayBuffer._copyContents(subRange:initializing:)( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v5 < 0) {
    goto LABEL_9;
  }
  uint64_t v7 = (char *)(a4 + 40 * a1 + 32);
  uint64_t v8 = &a3[40 * v5];
  if (v7 < v8 && &v7[40 * v5] > a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(a5);
  swift_arrayInitWithCopy(a3, v7, v5, v10);
  return v8;
}

uint64_t specialized _ArrayBuffer.owner.getter(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      return a1;
    }
    else {
      return a1 & 0xFFFFFFFFFFFFFF8LL;
    }
  }

  else if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    return a1 & 0xFFFFFFFFFFFFFF8LL;
  }

  else
  {
    return a1;
  }

uint64_t type metadata accessor for CollectionOfOne(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for CollectionOfOne,  &flag for loading of canonical specialized generic type metadata for CollectionOfOne);
}

void specialized _ArrayBuffer.subscript.setter()
{
}

uint64_t partial apply for closure #1 in MutableCollection<>.partition(by:)@<X0>(void *a1@<X8>)
{
  return closure #1 in MutableCollection<>.partition(by:)( *(uint64_t (**)(char *))(v1 + 40),  *(void *)(v1 + 48),  *(void *)(v1 + 16),  *(void *)(v1 + 24),  a1);
}

uint64_t type metadata accessor for ClosedRange(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for ClosedRange,  &flag for loading of canonical specialized generic type metadata for ClosedRange);
}

uint64_t type metadata accessor for Range(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Range,  &flag for loading of canonical specialized generic type metadata for Range);
}

uint64_t type metadata accessor for __StaticArrayStorage()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for __SwiftDeferredNSArray()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for __SwiftDeferredStaticNSArray( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for __SwiftDeferredStaticNSArray);
}

uint64_t type metadata accessor for _ContiguousArrayStorage( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _ContiguousArrayStorage,  &flag for loading of canonical specialized generic type metadata for _ContiguousArrayStorage);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>()
{
  return objc_opt_self();
}

void partial apply for closure #1 in _assertionFailure(_:_:flags:)( const char *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v7 = *(void *)(v4 + 16);
  unint64_t v8 = *(void *)(v4 + 24);
  int v9 = *(_DWORD *)(v4 + 32);
  swift_bridgeObjectRetain(v8, a2, a3, a4);
  if ((v8 & 0x1000000000000000LL) != 0)
  {
    uint64_t v7 = specialized static String._copying(_:)(v7, v8);
    unint64_t v13 = v12;
    swift_bridgeObjectRelease(v8);
    unint64_t v8 = v13;
    if ((v13 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    v14[0] = v7;
    v14[1] = v8 & 0xFFFFFFFFFFFFFFLL;
    closure #1 in closure #1 in _assertionFailure(_:_:flags:)((const char *)v14, HIBYTE(v8) & 0xF, a1, a2, v9);
    swift_bridgeObjectRelease(v8);
    return;
  }

  if ((v8 & 0x2000000000000000LL) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((v7 & 0x1000000000000000LL) != 0)
  {
    uint64_t v10 = (const char *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v11 = v7 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v10 = (const char *)_StringObject.sharedUTF8.getter(v7, v8);
  }

  closure #1 in closure #1 in _assertionFailure(_:_:flags:)(v10, v11, a1, a2, v9);
  swift_bridgeObjectRelease(v8);
}

uint64_t type metadata accessor for UnsafePointer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for UnsafePointer,  &flag for loading of canonical specialized generic type metadata for UnsafePointer);
}

uint64_t type metadata accessor for ContiguousArray(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for ContiguousArray,  &flag for loading of canonical specialized generic type metadata for ContiguousArray);
}

uint64_t type metadata accessor for Array(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Array,  &flag for loading of canonical specialized generic type metadata for Array);
}

_OWORD *outlined init with take of Any(_OWORD *a1, _OWORD *a2)
{
  __int128 v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

uint64_t type metadata accessor for ArraySlice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ArraySlice);
}

uint64_t specialized static _HashTable.scale(forCapacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v2 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v2 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
  }

  else
  {
    unsigned int v5 = 64 - __clz(v4 - 1);
    else {
      return v5;
    }
  }

  return result;
}

uint64_t specialized static _HashTable.capacity(forScale:)(char a1)
{
  double v1 = (double)(1LL << a1) * 0.75;
  if ((~*(void *)&v1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v1 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v1 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  return (uint64_t)v1;
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result <= 1) {
    uint64_t v4 = 1LL;
  }
  else {
    uint64_t v4 = result;
  }
  double v5 = ceil((double)v4 / 0.75);
  if ((~*(void *)&v5 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v5 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v5 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v6 = __OFADD__(v4, 1LL);
  uint64_t v7 = v4 + 1;
  if (v6)
  {
    __break(1u);
    return result;
  }

  char v10 = 64 - __clz(v7 - 1);
  unsigned __int8 v11 = (unint64_t)v7 <= 2 ? 1 : v10;
  uint64_t v12 = 1LL << v11;
  unint64_t v13 = (unint64_t)((1LL << v11) + 63) >> 6;
  uint64_t v14 = type metadata accessor for _DictionaryStorage(0LL, a2, a3, a4);
  uint64_t v15 = *(void *)(a2 - 8);
  uint64_t v16 = *(unsigned __int8 *)(v15 + 80);
  uint64_t v17 = v16 + 8 * v13;
  uint64_t v18 = *(void *)(a3 - 8);
  uint64_t v19 = *(unsigned __int8 *)(v18 + 80);
  uint64_t v20 = (*(void *)(v15 + 72) << v11) + v19;
  uint64_t v21 = (int64x2_t *)swift_allocObject( v14,  ((((v17 + 64) & ~v16) + v20) & ~v19) + (*(void *)(v18 + 72) << v11),  v16 | v19 | 7);
  v21[1].i64[0] = 0LL;
  double v22 = (double)(1LL << v11) * 0.75;
  if ((~*(void *)&v22 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v22 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v22 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v23 = (uint64_t *)v21;
  unint64_t v24 = v21 + 4;
  uint64_t v25 = ((unint64_t)v21[4].u64 + v17) & ~v16;
  v21[1].i64[1] = (uint64_t)v22;
  v21[2].i8[0] = v11;
  v21[2].i8[1] = 0;
  v21[2].i16[1] = 0;
  v21[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v21);
  if ((_BYTE)qword_18C487060) {
    char v26 = (uint64_t *)v11;
  }
  else {
    char v26 = v23;
  }
  v23[5] = (uint64_t)v26;
  v23[6] = v25;
  v23[7] = (v25 + v20) & ~v19;
  if (v12 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v13, v24);
  }
  else {
    v24->i64[0] = -1LL << v12;
  }
  return (uint64_t)v23;
}

void specialized EmptyCollection.subscript.setter()
{
}

char *specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)( uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_7;
  }
  double v5 = (char *)(a4 + 16 * a1 + 32);
  BOOL v6 = &__dst[16 * v4];
  if (v5 < v6 && &v5[16 * v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  swift_arrayInitWithCopy(__dst, v5, v4, (uint64_t)&type metadata for String);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_7;
  }
  double v5 = (char *)(a4 + 4 * a1 + 32);
  BOOL v6 = 4 * v4;
  uint64_t v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  memcpy(__dst, v5, v6);
  return v7;
}

uint64_t type metadata accessor for EmptyCollection(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for EmptyCollection,  &flag for loading of canonical specialized generic type metadata for EmptyCollection);
}

uint64_t specialized Collection.subscript.getter( Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  uint64_t v7 = 4LL << v6;
  uint64_t v8 = a1._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v7)
  {
    if (v8 == v7) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
    }
    uint64_t v11 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000LL) == 0) {
      uint64_t v11 = a2 & 0xFFFFFFFFFFFFLL;
    }
    if (4 * v11 < rawBits >> 14)
    {
      unint64_t v10 = 80LL;
LABEL_15:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v10,  0);
    }

    if ((rawBits & 1) == 0) {
      _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits);
    }
  }

  else
  {
    Swift::UInt64 v9 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000LL) == 0) {
      Swift::UInt64 v9 = a2 & 0xFFFFFFFFFFFFLL;
    }
    if (v9 < a1._rawBits >> 16)
    {
      unint64_t v10 = 210LL;
      goto LABEL_15;
    }
  }

  return 15LL;
}

unint64_t specialized static String.+ infix(_:_:)( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v5 = a3;
  uint64_t v8 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v8 && (a1 & ~a2 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain(a4, a2, a3, (char *)a4);
    return v5;
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain(a2, a2, a3, (char *)a4);
    if ((a4 & 0x2000000000000000LL) != 0) {
      goto LABEL_12;
    }
LABEL_9:
    uint64_t v9 = v5 & 0xFFFFFFFFFFFFLL;
LABEL_13:
    _StringGuts.append(_:)(v5, a4, 0LL, v9);
    return a1;
  }

  swift_bridgeObjectRetain(a2, a2, a3, (char *)a4);
  if ((a4 & 0x2000000000000000LL) == 0) {
    goto LABEL_9;
  }
  unint64_t v10 = specialized _SmallString.init(_:appending:)(a1, a2, v5, a4);
  if ((v11 & 1) != 0)
  {
LABEL_12:
    uint64_t v9 = HIBYTE(a4) & 0xF;
    goto LABEL_13;
  }

  unint64_t v12 = v10;
  swift_bridgeObjectRelease(a2);
  return v12;
}

Swift::UInt64 specialized Collection.subscript.getter( Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000LL) != 0) {
    uint64_t v3 = HIBYTE(a3) & 0xF;
  }
  uint64_t v4 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LODWORD(v4) = 1;
  }
  uint64_t v5 = 11LL;
  if ((_DWORD)v4) {
    uint64_t v5 = 7LL;
  }
  unint64_t v6 = 4 * v3;
  Swift::UInt64 v7 = a1._rawBits >> 14;
  if (4 * v3 < a1._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  Swift::UInt64 rawBits = a1._rawBits;
  Swift::UInt64 v9 = v5 | (v3 << 16);
  uint64_t v10 = a1._rawBits & 0xC;
  uint64_t v11 = 4LL << v4;
  uint64_t v12 = v5 & 0xC;
  if ((a1._rawBits & 1) == 0 || v10 == v11 || v12 == v11)
  {
    if (v12 == v11)
    {
      Swift::UInt64 v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
      if (v10 != v11) {
        goto LABEL_13;
      }
    }

    else if (v10 != v11)
    {
LABEL_13:
      if (v6 < v9 >> 14 || v9 >> 14 < v7) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x50uLL,  0);
      }
      if ((rawBits & 1) != 0)
      {
        if ((v9 & 1) != 0) {
          return rawBits;
        }
      }

      else
      {
        Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        if ((v9 & 1) != 0) {
          return rawBits;
        }
      }

      _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits;
      return rawBits;
    }

    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    Swift::UInt64 v7 = rawBits >> 14;
    goto LABEL_13;
  }

  return rawBits;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  Swift::UInt64 v7;
  Swift::UInt64 rawBits;
  Swift::UInt64 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000LL) != 0) {
    uint64_t v3 = HIBYTE(a3) & 0xF;
  }
  uint64_t v4 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LODWORD(v4) = 1;
  }
  uint64_t v5 = 11LL;
  if ((_DWORD)v4) {
    uint64_t v5 = 7LL;
  }
  unint64_t v6 = 4 * v3;
  Swift::UInt64 v7 = a1._rawBits >> 14;
  if (4 * v3 < a1._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  Swift::UInt64 rawBits = a1._rawBits;
  Swift::UInt64 v9 = v5 | (v3 << 16);
  uint64_t v10 = a1._rawBits & 0xC;
  uint64_t v11 = 4LL << v4;
  uint64_t v12 = v5 & 0xC;
  if ((a1._rawBits & 1) != 0 && v10 != v11 && v12 != v11) {
    goto LABEL_17;
  }
  if (v12 == v11)
  {
    Swift::UInt64 v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
    if (v10 != v11) {
      goto LABEL_13;
    }
  }

  else if (v10 != v11)
  {
    goto LABEL_13;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  Swift::UInt64 v7 = rawBits >> 14;
LABEL_13:
  if (v6 < v9 >> 14 || v9 >> 14 < v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x50uLL,  0);
  }
  if ((rawBits & 1) != 0)
  {
    if ((v9 & 1) != 0) {
      goto LABEL_17;
    }
  }

  else
  {
    Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((v9 & 1) != 0) {
      goto LABEL_17;
    }
  }

  _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits;
LABEL_17:
  if (rawBits >= 0x10000) {
    return rawBits;
  }
  else {
    return rawBits | 3;
  }
}

Swift::Int specialized LazyMapSequence<>.formIndex(after:)( Swift::String::Index *a1, uint64_t a2, unint64_t a3)
{
  v6._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  Swift::UInt64 v7 = (v6._rawBits >> 8) & 0x3F;
  uint64_t v8 = a3 & 0x2000000000000000LL;
  uint64_t v9 = HIBYTE(a3) & 0xF;
  uint64_t v10 = a2 & 0xFFFFFFFFFFFFLL;
  if (v7) {
    goto LABEL_27;
  }
  if (v8) {
    uint64_t v11 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v11 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v6._rawBits >> 14 == 4 * v11)
  {
    Swift::UInt64 v7 = 0LL;
    goto LABEL_27;
  }

  Swift::UInt64 v12 = v6._rawBits >> 16;
  if ((a3 & 0x1000000000000000LL) != 0) {
    goto LABEL_56;
  }
  if (!v8)
  {
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      unint64_t v13 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v14 = a2 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      unint64_t v13 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      Swift::UInt64 v12 = v6._rawBits >> 16;
    }

    if (v12 + 1 != v14)
    {
      if (!v13) {
        goto LABEL_59;
      }
      int v15 = *(unsigned __int16 *)&v13[v12];
      if (v15 == 2573 || (v15 & 0x80808080) != 0) {
        goto LABEL_56;
      }
    }

    uint64_t v8 = 0LL;
LABEL_26:
    Swift::UInt64 v7 = 1LL;
    goto LABEL_27;
  }

  uint64_t v31 = a2;
  uint64_t v32 = a3 & 0xFFFFFFFFFFFFFFLL;
  if (v12 + 1 == v9
    || ((int v17 = *(unsigned __int16 *)((char *)&v31 + v12), v17 != 2573) ? (v18 = (v17 & 0x80808080) == 0) : (v18 = 0), v18))
  {
    uint64_t v8 = 1LL;
    goto LABEL_26;
  }

uint64_t specialized LazyMapSequence<>.distance(from:to:)( Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, unint64_t a4)
{
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(a1)._rawBits;
  v8._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(a2)._rawBits;
  uint64_t v9 = v7._rawBits >> 16;
  if (v7._rawBits >> 14 < v8._rawBits >> 14)
  {
    int64_t v10 = v8._rawBits >> 16;
    if (v9 < v8._rawBits >> 16)
    {
      uint64_t v11 = 1LL;
      if ((a4 & 0x1000000000000000LL) == 0) {
        goto LABEL_6;
      }
LABEL_19:
      int64_t v14 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9) + v9;
      while (v14 < v10)
      {
        ++v11;
        uint64_t v9 = v14;
        if ((a4 & 0x1000000000000000LL) != 0) {
          goto LABEL_19;
        }
LABEL_6:
        if ((a4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v25 = a3;
          uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
          int64_t v14 = v9 + 1;
          if (v9 + 1 != (HIBYTE(a4) & 0xF))
          {
            int v16 = *(unsigned __int16 *)((char *)&v25 + v9);
            if (v16 == 2573 || (v16 & 0x80808080) != 0) {
              goto LABEL_19;
            }
          }
        }

        else
        {
          Swift::UInt64 v12 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v13 = a3 & 0xFFFFFFFFFFFFLL;
          if ((a3 & 0x1000000000000000LL) == 0) {
            Swift::UInt64 v12 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
          }
          int64_t v14 = v9 + 1;
          if (v9 + 1 != v13)
          {
            if (!v12) {
              goto LABEL_43;
            }
            int v15 = *(unsigned __int16 *)&v12[v9];
            if (v15 == 2573 || (v15 & 0x80808080) != 0) {
              goto LABEL_19;
            }
          }
        }
      }

      return v11;
    }

    return 0LL;
  }

  if (v8._rawBits >> 14 >= v7._rawBits >> 14) {
    return 0LL;
  }
  int64_t v18 = v8._rawBits >> 16;
  if (v8._rawBits >> 16 >= v9) {
    return 0LL;
  }
  uint64_t v11 = -1LL;
  if (v9 >= 2) {
    goto LABEL_28;
  }
  while (1)
  {
    Swift::Int v19 = 1LL;
LABEL_26:
    v9 -= v19;
    if (v18 >= v9) {
      return v11;
    }
    while (1)
    {
      --v11;
      if (v9 < 2) {
        break;
      }
LABEL_28:
      if ((a4 & 0x1000000000000000LL) != 0) {
        goto LABEL_41;
      }
      if ((a4 & 0x2000000000000000LL) != 0)
      {
        uint64_t v25 = a3;
        uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v21 = (char *)&v25 + v9;
      }

      else
      {
        unint64_t v20 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a3 & 0x1000000000000000LL) == 0)
        {
          unint64_t v20 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
          if (!v20) {
LABEL_43:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }

        uint64_t v21 = &v20[v9];
      }

      int v22 = *((unsigned __int16 *)v21 - 1);
      if (v22 == 2573 || (v22 & 0x80808080) != 0)
      {
LABEL_41:
        Swift::Int v19 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v9);
        goto LABEL_26;
      }

      if (v18 >= --v9) {
        return v11;
      }
    }
  }

unint64_t specialized _StringGuts.uniqueNativeReplaceSubrange(_:with:isASCII:)( unint64_t result, unint64_t a2, char *a3, size_t a4)
{
  uint64_t v5 = result >> 16;
  unint64_t v6 = (result >> 16) + a4;
  if (__OFADD__(result >> 16, a4))
  {
    __break(1u);
  }

  else
  {
    uint64_t v7 = a2 >> 16;
    unint64_t v8 = v4[1];
    if ((v8 & 0x2000000000000000LL) != 0) {
      uint64_t v9 = HIBYTE(v8) & 0xF;
    }
    else {
      uint64_t v9 = *v4 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v10 = v9 - v7;
    Swift::Int result = v6 + v10;
    if (!__OFADD__(v6, v10))
    {
      _StringGuts.reserveCapacity(_:)(result);
      uint64_t v13 = v4[1];
      __StringStorage.replace(from:to:with:)(v5, v7, a3, a4);
      void *v4 = *(void *)(v13 + 24);
      return v5;
    }
  }

  __break(1u);
  return result;
}

void *specialized _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)( void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2 - (void)result;
  if (__OFSUB__(a2, result))
  {
    __break(1u);
    goto LABEL_7;
  }

  uint64_t v10 = a4 - v8;
  if (__OFSUB__(a4, v8))
  {
LABEL_7:
    __break(1u);
    goto LABEL_8;
  }

  int v16 = result;
  uint64_t v17 = *(void *)(*(void *)(a7 + 8) + 8LL);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 112))(a5, v17);
  BOOL v19 = __OFADD__(v18, v10);
  Swift::Int result = (void *)(v18 + v10);
  if (v19)
  {
LABEL_8:
    __break(1u);
    goto LABEL_9;
  }

  unint64_t v20 = (unint64_t *)_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(newCount:requiredCapacity:)( (uint64_t)result,  (uint64_t)result,  a5,  a7);
  Swift::Int v24 = v20;
  Swift::Int result = (*(void *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v17 + 64))(&v23, a5, v17);
  if (!__OFSUB__(v16, v23))
  {
    MEMORY[0x1895F8858](result);
    v22[2] = a5;
    v22[3] = a6;
    v22[4] = a7;
    v22[5] = a8;
    v22[6] = a3;
    _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( &v24,  v21,  a4,  (void (*)(char *, uint64_t))partial apply for closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:),  (uint64_t)v22,  a5,  (uint64_t (**)(uint64_t, uint64_t, char *))a7);
    return (void *)swift_release((uint64_t)v20);
  }

uint64_t specialized _UIntBuffer.capacity.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 56))();
  if (!v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  return 32 / v2;
}

Swift::UInt64 specialized LazyMapSequence<>.formIndex(after:)( Swift::String::Index *a1, uint64_t a2, uint64_t a3)
{
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }

  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      v13[0] = a2;
      v13[1] = a3 & 0xFFFFFFFFFFFFFFLL;
      int v9 = *((unsigned __int8 *)v13 + v7);
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0) {
        uint64_t v8 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      int v9 = v8[v7];
    }

    int v10 = (char)v9;
    unsigned int v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0) {
      LOBYTE(v11) = 1;
    }
    Swift::UInt64 result = ((v7 + v11) << 16) | 5;
  }

  a1->_Swift::UInt64 rawBits = result;
  return result;
}

uint64_t specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)( uint64_t a1, Swift::String::Index a2, uint64_t a3, uint64_t a4)
{
  Swift::UInt64 v9 = _StringGuts.validateScalarRange_5_7(_:)(a2, a2, *v4, v4[1]);
  return _StringGuts.replaceSubrange<A>(_:with:)(v9, v10, a1, a3, a4);
}

uint64_t specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(int a1, Swift::String::Index a2)
{
  return Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(a2, a2);
}

void specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)( unint64_t *a1, Swift::UInt64 a2, ValueMetadata *a3, Swift::UInt64 a4)
{
}

uint64_t type metadata accessor for PartialRangeFrom(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for PartialRangeFrom,  &flag for loading of canonical specialized generic type metadata for PartialRangeFrom);
}

void sub_1816F7E10()
{
}

uint64_t partial apply for closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, void *a2@<X8>)
{
  return closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  *(void *)(v2 + 24),  *(void *)(v2 + 32),  a2);
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameAbstract(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState2( 255LL,  (char *)a1 + (int)result,  -(result >> 32),  0LL,  0LL);
    *a1 = result;
  }

  return result;
}

uint64_t type metadata accessor for LazyMapSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyMapSequence);
}

uint64_t type metadata accessor for _CollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _CollectionBox);
}

uint64_t canonical specialized generic type metadata accessor for _IndexBox<Int>()
{
  return objc_opt_self();
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2((char *)a1 + (int)result, -(result >> 32), 0LL, 0LL);
    *a1 = result;
  }

  return result;
}

uint64_t type metadata accessor for LazySequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazySequence);
}

unint64_t outlined consume of Mirror.AncestorRepresentation(unint64_t result, uint64_t a2)
{
  if (result >= 2) {
    return swift_release(a2);
  }
  return result;
}

void sub_1816F7F04()
{
}

uint64_t type metadata accessor for _IndexBox(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _IndexBox,  flag for loading of canonical specialized generic type metadata for _IndexBox);
}

unint64_t specialized static String._uncheckedFromASCII(_:)(uint8x16_t *a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 > 15)
  {
    unint64_t v4 = a2 | 0xF000000000000000LL;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(a2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      unint64_t v4 = *(void *)(v5 + 24);
    }

    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)(a1->i8, a2, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }

  uint64_t v8 = a2 - 8;
  unint64_t v9 = 8LL;
  if (a2 < 8) {
    unint64_t v9 = a2;
  }
  if ((v9 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v9 < 8)
  {
    unint64_t v10 = 0LL;
    unint64_t result = 0LL;
    unint64_t v11 = 0LL;
    goto LABEL_20;
  }

  if (v9 >= 0x10)
  {
    unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF0LL;
    uint16x8_t v35 = vmovl_high_u8(*a1);
    int8x16_t v36 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v35.i8);
    uint16x8_t v37 = vmovl_u8(*(uint8x8_t *)a1->i8);
    int8x16_t v38 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v37.i8);
    int8x16_t v39 = (int8x16_t)vmovl_high_u16(v35);
    int8x8_t v40 = (int8x8_t)vextq_s8(v39, v39, 8uLL).u64[0];
    int8x16_t v41 = (int8x16_t)vmovl_high_u16(v37);
    int8x8_t v42 = (int8x8_t)vextq_s8(v41, v41, 8uLL).u64[0];
    *(int8x8_t *)v41.i8 = vorr_s8(*(int8x8_t *)v41.i8, *(int8x8_t *)v39.i8);
    v43.i64[0] = v41.u32[0];
    v43.i64[1] = v41.u32[1];
    int8x16_t v44 = (int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1817FFCE0);
    *(int8x8_t *)v39.i8 = vorr_s8(*(int8x8_t *)v38.i8, *(int8x8_t *)v36.i8);
    v43.i64[0] = v39.u32[0];
    v43.i64[1] = v39.u32[1];
    int8x16_t v45 = vorrq_s8((int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1817FFCD0), v44);
    *(int8x8_t *)v39.i8 = vorr_s8(v42, v40);
    v43.i64[0] = v39.u32[0];
    v43.i64[1] = v39.u32[1];
    int8x16_t v46 = (int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1817FFCC0);
    *(int8x8_t *)v36.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL));
    v43.i64[0] = v36.u32[0];
    v43.i64[1] = v36.u32[1];
    int8x16_t v47 = vorrq_s8(v45, vorrq_s8((int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1817FFCB0), v46));
    unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v47.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL));
    if (v9 == (v9 & 0xFFFFFFFFFFFFFFF0LL)) {
      goto LABEL_22;
    }
    unint64_t v11 = 8 * v10;
    if ((v9 & 8) == 0) {
      goto LABEL_20;
    }
  }

  else
  {
    unint64_t result = 0LL;
    unint64_t v11 = 0LL;
    unint64_t v10 = 0LL;
  }

  unint64_t v12 = v10;
  int64x2_t v13 = vdupq_n_s64(v11);
  unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v11 = 8 * (v9 & 0xFFFFFFFFFFFFFFF8LL);
  int8x16_t v14 = 0uLL;
  int8x16_t v15 = (int8x16_t)result;
  int64x2_t v16 = vaddq_s64(v13, (int64x2_t)xmmword_1817FFCC0);
  int64x2_t v17 = vaddq_s64(v13, (int64x2_t)xmmword_1817FFCE0);
  int64x2_t v18 = vaddq_s64(v13, (int64x2_t)xmmword_1817FFCB0);
  int64x2_t v19 = vaddq_s64(v13, (int64x2_t)xmmword_1817FFCD0);
  unint64_t v20 = (uint8x8_t *)&a1->i8[v12];
  int8x16_t v21 = (int8x16_t)vdupq_n_s64(0x38uLL);
  unint64_t v22 = v12 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
  int64x2_t v23 = vdupq_n_s64(0x40uLL);
  int8x16_t v24 = 0uLL;
  int8x16_t v25 = 0uLL;
  do
  {
    uint8x8_t v26 = *v20++;
    uint16x8_t v27 = vmovl_u8(v26);
    uint32x4_t v28 = vmovl_high_u16(v27);
    v29.i64[0] = v28.u32[2];
    v29.i64[1] = v28.u32[3];
    uint64x2_t v30 = v29;
    v29.i64[0] = v28.u32[0];
    v29.i64[1] = v28.u32[1];
    uint64x2_t v31 = v29;
    uint32x4_t v32 = vmovl_u16(*(uint16x4_t *)v27.i8);
    v29.i64[0] = v32.u32[2];
    v29.i64[1] = v32.u32[3];
    uint64x2_t v33 = v29;
    v29.i64[0] = v32.u32[0];
    v29.i64[1] = v32.u32[1];
    int8x16_t v25 = vorrq_s8((int8x16_t)vshlq_u64(v30, (uint64x2_t)vandq_s8((int8x16_t)v16, v21)), v25);
    int8x16_t v24 = vorrq_s8((int8x16_t)vshlq_u64(v31, (uint64x2_t)vandq_s8((int8x16_t)v17, v21)), v24);
    int8x16_t v14 = vorrq_s8((int8x16_t)vshlq_u64(v33, (uint64x2_t)vandq_s8((int8x16_t)v18, v21)), v14);
    int8x16_t v15 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)vandq_s8((int8x16_t)v19, v21)), v15);
    int64x2_t v17 = vaddq_s64(v17, v23);
    int64x2_t v18 = vaddq_s64(v18, v23);
    int64x2_t v19 = vaddq_s64(v19, v23);
    int64x2_t v16 = vaddq_s64(v16, v23);
    v22 += 8LL;
  }

  while (v22);
  int8x16_t v34 = vorrq_s8(vorrq_s8(v15, v24), vorrq_s8(v14, v25));
  unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  if (v9 != v10)
  {
LABEL_20:
    unint64_t v48 = v9 - v10;
    uint64_t v49 = &a1->u8[v10];
    do
    {
      unsigned int v50 = *v49++;
      result |= (unint64_t)v50 << (v11 & 0x38);
      v11 += 8LL;
      --v48;
    }

    while (v48);
  }

unint64_t specialized static _UInt128.* infix(_:_:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  BOOL v4 = !is_mul_ok(a2, a3);
  BOOL v5 = !is_mul_ok(a1, a4);
  BOOL v6 = __CFADD__(a2 * a3, a1 * a4);
  BOOL v7 = __CFADD__(a2 * a3 + a1 * a4, (a3 * (unsigned __int128)a1) >> 64);
  if (a4) {
    BOOL v8 = a2 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 || v4 || v5 || v6 || v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in *",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0xA3uLL,  0);
  }
  return a3 * a1;
}

double specialized Double.init(sign:exponentBitPattern:significandBitPattern:)( uint64_t a1, __int16 a2, uint64_t a3)
{
  *(void *)&double result = ((unint64_t)(a2 & 0x7FF) << 52) | (a1 << 63) | a3 & 0xFFFFFFFFFFFFFLL;
  return result;
}

uint64_t specialized UnsafeMutableBufferPointer.index(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a1;
  if (__OFSUB__(a3, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x10FuLL,  0);
  }
  if (a2 < 1)
  {
    if (v3 > 0 || v3 <= a2) {
      goto LABEL_9;
    }
    return 0LL;
  }

uint64_t specialized UInt8.init(ascii:)(uint64_t result)
{
  if (result >= 0x80) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Code point value does not fit into ASCII",  40LL,  2,  "Swift/UnicodeScalar.swift",  25LL,  2,  0x16BuLL,  0);
  }
  return result;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( int64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5)
{
  int64_t v11 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v11 + 16) = v12;
  *(void *)(v11 + 24) = 0x3000000000000000LL;
  if (v12 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v13 = *(void *)(v11 + 24) & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  *(_BYTE *)(v11 + 32 + v13) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  closure #1 in StaticBigInt.debugDescription.getter(v11 + 32, a1, a2, a3 & 1, a4, a5);
  if (v5)
  {
    swift_release(v11);
  }

  else
  {
    *(void *)(v11 + 24) = a2 | 0x3000000000000000LL;
    *(_BYTE *)(v11 + 32 + (a2 & 0xFFFFFFFFFFFFLL)) = 0;
  }

  return v11;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( int64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5)
{
  BOOL v7 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( a1,  a2,  a3,  a4,  a5);
  if (v6) {
    return v5;
  }
  BOOL v8 = v7;
  uint64_t v9 = v7[3];
  Swift::Int v10 = v9 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  int64_t v11 = (char *)(v7 + 4);
  uint64_t v12 = (char *)(v7 + 4);
  if ((v9 & 0xFFFFFFFFFFF0LL) != 0)
  {
    if (((v7[5] | v7[4]) & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    uint64_t v12 = (char *)(v7 + 6);
    while (v12 < (char *)v7 + (v9 & 0xFFFFFFFFFFF0LL) + 32)
    {
      uint64_t v13 = *(void *)v12;
      uint64_t v14 = *((void *)v12 + 1);
      v12 += 16;
      if (((v14 | v13) & 0x8080808080808080LL) != 0) {
        goto LABEL_22;
      }
    }
  }

  if (v12 < &v11[v9 & 0xFFFFFFFFFFF8LL])
  {
    if ((*(void *)v12 & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    v12 += 8;
  }

  if (v12 < &v11[v9 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v12 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v12 += 4;
  }

  if (v12 >= &v11[v9 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v12 >= &v11[v10] || (*v12 & 0x80000000) == 0)
    {
LABEL_20:
      char v15 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v10, v15 & 1);
      return v8[3];
    }

    goto LABEL_22;
  }

  if ((*(_WORD *)v12 & 0x8080) == 0)
  {
    v12 += 2;
    goto LABEL_18;
  }

unint64_t specialized String.init(validatingUTF8:)(uint64_t a1)
{
  int64_t v2 = _swift_stdlib_strlen((const char *)a1);
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v3 = v2;
  if (!v2) {
    return 0LL;
  }
  BOOL v4 = (uint64_t *)a1;
  if ((v2 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    if (((*(void *)(a1 + 8) | *(void *)a1) & 0x8080808080808080LL) != 0) {
      goto LABEL_23;
    }
    BOOL v4 = (uint64_t *)(a1 + 16);
    while ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFF0LL))
    {
      uint64_t v5 = *v4;
      uint64_t v6 = v4[1];
      v4 += 2;
      if (((v6 | v5) & 0x8080808080808080LL) != 0) {
        goto LABEL_23;
      }
    }
  }

  if ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFF8LL))
  {
    if ((*v4 & 0x8080808080808080LL) != 0) {
      goto LABEL_23;
    }
    ++v4;
  }

  if ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFFCLL))
  {
    if ((*(_DWORD *)v4 & 0x80808080) != 0) {
      goto LABEL_23;
    }
    BOOL v4 = (uint64_t *)((char *)v4 + 4);
  }

  if ((unint64_t)v4 >= a1 + (v2 & 0xFFFFFFFFFFFFFFFELL))
  {
LABEL_19:
    if ((unint64_t)v4 >= a1 + v2 || (*(char *)v4 & 0x80000000) == 0)
    {
      if (v2 > 15) {
        goto LABEL_94;
      }
LABEL_98:
      unint64_t v42 = v2 - 8;
      uint64_t v43 = 8LL;
      if (v2 < 8) {
        uint64_t v43 = v2;
      }
      if ((v43 & (unint64_t)~(v43 >> 63)) <= v43 - 1) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
      }
      if ((unint64_t)v43 < 8)
      {
        unint64_t v44 = 0LL;
        unint64_t result = 0LL;
        unint64_t v45 = 0LL;
        goto LABEL_114;
      }

      if ((unint64_t)v43 >= 0x10)
      {
        unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFF0LL;
        int64x2_t v69 = (int64x2_t)xmmword_1817FFD60;
        int64x2_t v70 = (int64x2_t)xmmword_1817FFD70;
        int64x2_t v71 = (int64x2_t)xmmword_1817FFD80;
        int64x2_t v72 = (int64x2_t)xmmword_1817FFD90;
        unint64_t v45 = 8 * (v43 & 0xFFFFFFFFFFFFFFF0LL);
        int8x16_t v73 = 0uLL;
        int8x16_t v74 = (int8x16_t)vdupq_n_s64(0x38uLL);
        int64x2_t v75 = vdupq_n_s64(0x80uLL);
        unint64_t v76 = v43 & 0xFFFFFFFFFFFFFFF0LL;
        uint64_t v77 = (uint8x16_t *)a1;
        int64x2_t v78 = (int64x2_t)xmmword_1817FFCC0;
        int8x16_t v79 = 0uLL;
        int8x16_t v80 = 0uLL;
        int64x2_t v81 = (int64x2_t)xmmword_1817FFCE0;
        int8x16_t v82 = 0uLL;
        int8x16_t v83 = 0uLL;
        int64x2_t v84 = (int64x2_t)xmmword_1817FFCB0;
        int8x16_t v85 = 0uLL;
        int8x16_t v86 = 0uLL;
        int64x2_t v87 = (int64x2_t)xmmword_1817FFCD0;
        int8x16_t v88 = 0uLL;
        do
        {
          uint8x16_t v89 = *v77++;
          uint16x8_t v90 = vmovl_u8(*(uint8x8_t *)v89.i8);
          uint32x4_t v91 = vmovl_high_u16(v90);
          v92.i64[0] = v91.u32[2];
          v92.i64[1] = v91.u32[3];
          uint64x2_t v93 = v92;
          uint16x8_t v94 = vmovl_high_u8(v89);
          uint32x4_t v95 = vmovl_u16(*(uint16x4_t *)v94.i8);
          v92.i64[0] = v95.u32[2];
          v92.i64[1] = v95.u32[3];
          uint64x2_t v96 = v92;
          v92.i64[0] = v95.u32[0];
          v92.i64[1] = v95.u32[1];
          uint64x2_t v97 = v92;
          v92.i64[0] = v91.u32[0];
          v92.i64[1] = v91.u32[1];
          uint64x2_t v98 = v92;
          uint32x4_t v99 = vmovl_u16(*(uint16x4_t *)v90.i8);
          v92.i64[0] = v99.u32[2];
          v92.i64[1] = v99.u32[3];
          uint64x2_t v100 = v92;
          uint32x4_t v101 = vmovl_high_u16(v94);
          v92.i64[0] = v101.u32[0];
          v92.i64[1] = v101.u32[1];
          uint64x2_t v102 = v92;
          v92.i64[0] = v99.u32[0];
          v92.i64[1] = v99.u32[1];
          uint64x2_t v103 = v92;
          v92.i64[0] = v101.u32[2];
          v92.i64[1] = v101.u32[3];
          int8x16_t v82 = vorrq_s8((int8x16_t)vshlq_u64(v93, (uint64x2_t)vandq_s8((int8x16_t)v78, v74)), v82);
          int8x16_t v85 = vorrq_s8((int8x16_t)vshlq_u64(v96, (uint64x2_t)vandq_s8((int8x16_t)v71, v74)), v85);
          int8x16_t v83 = vorrq_s8((int8x16_t)vshlq_u64(v97, (uint64x2_t)vandq_s8((int8x16_t)v72, v74)), v83);
          int8x16_t v80 = vorrq_s8((int8x16_t)vshlq_u64(v98, (uint64x2_t)vandq_s8((int8x16_t)v81, v74)), v80);
          int8x16_t v79 = vorrq_s8((int8x16_t)vshlq_u64(v100, (uint64x2_t)vandq_s8((int8x16_t)v84, v74)), v79);
          int8x16_t v86 = vorrq_s8((int8x16_t)vshlq_u64(v102, (uint64x2_t)vandq_s8((int8x16_t)v70, v74)), v86);
          int8x16_t v73 = vorrq_s8((int8x16_t)vshlq_u64(v103, (uint64x2_t)vandq_s8((int8x16_t)v87, v74)), v73);
          int8x16_t v88 = vorrq_s8((int8x16_t)vshlq_u64(v92, (uint64x2_t)vandq_s8((int8x16_t)v69, v74)), v88);
          int64x2_t v81 = vaddq_s64(v81, v75);
          int64x2_t v84 = vaddq_s64(v84, v75);
          int64x2_t v87 = vaddq_s64(v87, v75);
          int64x2_t v78 = vaddq_s64(v78, v75);
          int64x2_t v72 = vaddq_s64(v72, v75);
          int64x2_t v71 = vaddq_s64(v71, v75);
          int64x2_t v70 = vaddq_s64(v70, v75);
          int64x2_t v69 = vaddq_s64(v69, v75);
          v76 -= 16LL;
        }

        while (v76);
        int8x16_t v104 = vorrq_s8( vorrq_s8(vorrq_s8(v73, v83), vorrq_s8(v80, v86)),  vorrq_s8(vorrq_s8(v79, v85), vorrq_s8(v82, v88)));
        unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v104.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v104, v104, 8uLL));
        if (v43 == v44) {
          goto LABEL_116;
        }
        if ((v43 & 8) == 0)
        {
LABEL_114:
          uint64_t v105 = (unsigned __int8 *)(a1 + v44);
          unint64_t v106 = v43 - v44;
          do
          {
            unsigned int v107 = *v105++;
            result |= (unint64_t)v107 << (v45 & 0x38);
            v45 += 8LL;
            --v106;
          }

          while (v106);
          goto LABEL_116;
        }
      }

      else
      {
        unint64_t result = 0LL;
        unint64_t v45 = 0LL;
        unint64_t v44 = 0LL;
      }

      unint64_t v46 = v44;
      int64x2_t v47 = vdupq_n_s64(v45);
      unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFF8LL;
      unint64_t v45 = 8 * (v43 & 0xFFFFFFFFFFFFFFF8LL);
      int8x16_t v48 = 0uLL;
      int8x16_t v49 = (int8x16_t)result;
      int64x2_t v50 = vaddq_s64(v47, (int64x2_t)xmmword_1817FFCC0);
      int64x2_t v51 = vaddq_s64(v47, (int64x2_t)xmmword_1817FFCE0);
      int64x2_t v52 = vaddq_s64(v47, (int64x2_t)xmmword_1817FFCB0);
      int64x2_t v53 = vaddq_s64(v47, (int64x2_t)xmmword_1817FFCD0);
      uint64_t v54 = (uint8x8_t *)(a1 + v46);
      int8x16_t v55 = (int8x16_t)vdupq_n_s64(0x38uLL);
      unint64_t v56 = v46 - (v43 & 0xFFFFFFFFFFFFFFF8LL);
      int64x2_t v57 = vdupq_n_s64(0x40uLL);
      int8x16_t v58 = 0uLL;
      int8x16_t v59 = 0uLL;
      do
      {
        uint8x8_t v60 = *v54++;
        uint16x8_t v61 = vmovl_u8(v60);
        uint32x4_t v62 = vmovl_high_u16(v61);
        v63.i64[0] = v62.u32[2];
        v63.i64[1] = v62.u32[3];
        uint64x2_t v64 = v63;
        v63.i64[0] = v62.u32[0];
        v63.i64[1] = v62.u32[1];
        uint64x2_t v65 = v63;
        uint32x4_t v66 = vmovl_u16(*(uint16x4_t *)v61.i8);
        v63.i64[0] = v66.u32[2];
        v63.i64[1] = v66.u32[3];
        uint64x2_t v67 = v63;
        v63.i64[0] = v66.u32[0];
        v63.i64[1] = v66.u32[1];
        int8x16_t v59 = vorrq_s8((int8x16_t)vshlq_u64(v64, (uint64x2_t)vandq_s8((int8x16_t)v50, v55)), v59);
        int8x16_t v58 = vorrq_s8((int8x16_t)vshlq_u64(v65, (uint64x2_t)vandq_s8((int8x16_t)v51, v55)), v58);
        int8x16_t v48 = vorrq_s8((int8x16_t)vshlq_u64(v67, (uint64x2_t)vandq_s8((int8x16_t)v52, v55)), v48);
        int8x16_t v49 = vorrq_s8((int8x16_t)vshlq_u64(v63, (uint64x2_t)vandq_s8((int8x16_t)v53, v55)), v49);
        int64x2_t v51 = vaddq_s64(v51, v57);
        int64x2_t v52 = vaddq_s64(v52, v57);
        int64x2_t v53 = vaddq_s64(v53, v57);
        int64x2_t v50 = vaddq_s64(v50, v57);
        v56 += 8LL;
      }

      while (v56);
      int8x16_t v68 = vorrq_s8(vorrq_s8(v49, v58), vorrq_s8(v48, v59));
      unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v68.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
      if (v43 != v44) {
        goto LABEL_114;
      }
LABEL_116:
      if (v3 < 9) {
        return result;
      }
      if (v42 < 8)
      {
        unint64_t v108 = 0LL;
        int8x8_t v109 = 0LL;
        unint64_t v110 = 0LL;
        goto LABEL_130;
      }

      if (v42 >= 0x10)
      {
        Swift::String v134 = (uint8x16_t *)(a1 + 8);
        unint64_t v108 = v42 & 0xFFFFFFFFFFFFFFF0LL;
        int64x2_t v135 = (int64x2_t)xmmword_1817FFD60;
        int64x2_t v136 = (int64x2_t)xmmword_1817FFD70;
        int64x2_t v137 = (int64x2_t)xmmword_1817FFD80;
        int64x2_t v138 = (int64x2_t)xmmword_1817FFD90;
        int64x2_t v139 = (int64x2_t)xmmword_1817FFCC0;
        int64x2_t v140 = (int64x2_t)xmmword_1817FFCE0;
        int8x16_t v141 = (int8x16_t)vdupq_n_s64(0x38uLL);
        int64x2_t v142 = vdupq_n_s64(0x80uLL);
        int64x2_t v143 = (int64x2_t)xmmword_1817FFCB0;
        unint64_t v110 = 8 * (v42 & 0xFFFFFFFFFFFFFFF0LL);
        int8x16_t v144 = 0uLL;
        int8x16_t v145 = 0uLL;
        int64x2_t v146 = (int64x2_t)xmmword_1817FFCD0;
        unint64_t v147 = v42 & 0xFFFFFFFFFFFFFFF0LL;
        int8x16_t v148 = 0uLL;
        int8x16_t v149 = 0uLL;
        int8x16_t v150 = 0uLL;
        int8x16_t v151 = 0uLL;
        int8x16_t v152 = 0uLL;
        int8x16_t v153 = 0uLL;
        do
        {
          uint8x16_t v154 = *v134++;
          uint16x8_t v155 = vmovl_u8(*(uint8x8_t *)v154.i8);
          uint32x4_t v156 = vmovl_high_u16(v155);
          v157.i64[0] = v156.u32[2];
          v157.i64[1] = v156.u32[3];
          uint64x2_t v158 = v157;
          uint16x8_t v159 = vmovl_high_u8(v154);
          uint32x4_t v160 = vmovl_u16(*(uint16x4_t *)v159.i8);
          v157.i64[0] = v160.u32[2];
          v157.i64[1] = v160.u32[3];
          uint64x2_t v161 = v157;
          v157.i64[0] = v160.u32[0];
          v157.i64[1] = v160.u32[1];
          uint64x2_t v162 = v157;
          v157.i64[0] = v156.u32[0];
          v157.i64[1] = v156.u32[1];
          uint64x2_t v163 = v157;
          uint32x4_t v164 = vmovl_u16(*(uint16x4_t *)v155.i8);
          v157.i64[0] = v164.u32[2];
          v157.i64[1] = v164.u32[3];
          uint64x2_t v165 = v157;
          uint32x4_t v166 = vmovl_high_u16(v159);
          v157.i64[0] = v166.u32[0];
          v157.i64[1] = v166.u32[1];
          uint64x2_t v167 = v157;
          v157.i64[0] = v164.u32[0];
          v157.i64[1] = v164.u32[1];
          uint64x2_t v168 = v157;
          v157.i64[0] = v166.u32[2];
          v157.i64[1] = v166.u32[3];
          int8x16_t v149 = vorrq_s8((int8x16_t)vshlq_u64(v158, (uint64x2_t)vandq_s8((int8x16_t)v139, v141)), v149);
          int8x16_t v151 = vorrq_s8((int8x16_t)vshlq_u64(v161, (uint64x2_t)vandq_s8((int8x16_t)v137, v141)), v151);
          int8x16_t v150 = vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)vandq_s8((int8x16_t)v138, v141)), v150);
          int8x16_t v148 = vorrq_s8((int8x16_t)vshlq_u64(v163, (uint64x2_t)vandq_s8((int8x16_t)v140, v141)), v148);
          int8x16_t v145 = vorrq_s8((int8x16_t)vshlq_u64(v165, (uint64x2_t)vandq_s8((int8x16_t)v143, v141)), v145);
          int8x16_t v152 = vorrq_s8((int8x16_t)vshlq_u64(v167, (uint64x2_t)vandq_s8((int8x16_t)v136, v141)), v152);
          int8x16_t v144 = vorrq_s8((int8x16_t)vshlq_u64(v168, (uint64x2_t)vandq_s8((int8x16_t)v146, v141)), v144);
          int8x16_t v153 = vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)vandq_s8((int8x16_t)v135, v141)), v153);
          int64x2_t v140 = vaddq_s64(v140, v142);
          int64x2_t v143 = vaddq_s64(v143, v142);
          int64x2_t v146 = vaddq_s64(v146, v142);
          int64x2_t v139 = vaddq_s64(v139, v142);
          int64x2_t v138 = vaddq_s64(v138, v142);
          int64x2_t v137 = vaddq_s64(v137, v142);
          int64x2_t v136 = vaddq_s64(v136, v142);
          int64x2_t v135 = vaddq_s64(v135, v142);
          v147 -= 16LL;
        }

        while (v147);
        int8x16_t v169 = vorrq_s8( vorrq_s8(vorrq_s8(v144, v150), vorrq_s8(v148, v152)),  vorrq_s8(vorrq_s8(v145, v151), vorrq_s8(v149, v153)));
        int8x8_t v109 = vorr_s8(*(int8x8_t *)v169.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v169, v169, 8uLL));
        if (v42 == v108) {
          return result;
        }
        if ((v42 & 8) == 0)
        {
LABEL_130:
          uint64_t v170 = v3 - v108 - 8;
          int8x16_t v171 = (unsigned __int8 *)(v108 + a1 + 8);
          do
          {
            unsigned int v172 = *v171++;
            *(void *)&v109 |= (unint64_t)v172 << (v110 & 0x38);
            v110 += 8LL;
            --v170;
          }

          while (v170);
          return result;
        }
      }

      else
      {
        int8x8_t v109 = 0LL;
        unint64_t v110 = 0LL;
        unint64_t v108 = 0LL;
      }

      unint64_t v111 = v108;
      unint64_t v108 = v42 & 0xFFFFFFFFFFFFFFF8LL;
      int64x2_t v112 = vdupq_n_s64(v110);
      unint64_t v110 = 8 * (v42 & 0xFFFFFFFFFFFFFFF8LL);
      int8x16_t v113 = (int8x16_t)(unint64_t)v109;
      int8x16_t v114 = 0uLL;
      int64x2_t v115 = vaddq_s64(v112, (int64x2_t)xmmword_1817FFCC0);
      int64x2_t v116 = vaddq_s64(v112, (int64x2_t)xmmword_1817FFCE0);
      int64x2_t v117 = vaddq_s64(v112, (int64x2_t)xmmword_1817FFCB0);
      int64x2_t v118 = vaddq_s64(v112, (int64x2_t)xmmword_1817FFCD0);
      uint64_t v119 = (uint8x8_t *)(v111 + a1 + 8);
      int8x16_t v120 = (int8x16_t)vdupq_n_s64(0x38uLL);
      unint64_t v121 = v111 - (v42 & 0xFFFFFFFFFFFFFFF8LL);
      int64x2_t v122 = vdupq_n_s64(0x40uLL);
      int8x16_t v123 = 0uLL;
      int8x16_t v124 = 0uLL;
      do
      {
        uint8x8_t v125 = *v119++;
        uint16x8_t v126 = vmovl_u8(v125);
        uint32x4_t v127 = vmovl_high_u16(v126);
        v128.i64[0] = v127.u32[2];
        v128.i64[1] = v127.u32[3];
        uint64x2_t v129 = v128;
        v128.i64[0] = v127.u32[0];
        v128.i64[1] = v127.u32[1];
        uint64x2_t v130 = v128;
        uint32x4_t v131 = vmovl_u16(*(uint16x4_t *)v126.i8);
        v128.i64[0] = v131.u32[2];
        v128.i64[1] = v131.u32[3];
        uint64x2_t v132 = v128;
        v128.i64[0] = v131.u32[0];
        v128.i64[1] = v131.u32[1];
        int8x16_t v124 = vorrq_s8((int8x16_t)vshlq_u64(v129, (uint64x2_t)vandq_s8((int8x16_t)v115, v120)), v124);
        int8x16_t v123 = vorrq_s8((int8x16_t)vshlq_u64(v130, (uint64x2_t)vandq_s8((int8x16_t)v116, v120)), v123);
        int8x16_t v114 = vorrq_s8((int8x16_t)vshlq_u64(v132, (uint64x2_t)vandq_s8((int8x16_t)v117, v120)), v114);
        int8x16_t v113 = vorrq_s8((int8x16_t)vshlq_u64(v128, (uint64x2_t)vandq_s8((int8x16_t)v118, v120)), v113);
        int64x2_t v116 = vaddq_s64(v116, v122);
        int64x2_t v117 = vaddq_s64(v117, v122);
        int64x2_t v118 = vaddq_s64(v118, v122);
        int64x2_t v115 = vaddq_s64(v115, v122);
        v121 += 8LL;
      }

      while (v121);
      int8x16_t v133 = vorrq_s8(vorrq_s8(v113, v123), vorrq_s8(v114, v124));
      int8x8_t v109 = vorr_s8(*(int8x8_t *)v133.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v133, v133, 8uLL));
      if (v42 == v108) {
        return result;
      }
      goto LABEL_130;
    }

    goto LABEL_23;
  }

  if ((*(_WORD *)v4 & 0x8080) == 0)
  {
    BOOL v4 = (uint64_t *)((char *)v4 + 2);
    goto LABEL_19;
  }

uint64_t specialized Collection._makeKeyValuePairDescription<A, B>(withTypeName:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v218 = *(void *)(a3 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v208 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v217 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v7);
  uint64x2_t v225 = (char *)&v208 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v224 = v12;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, v12, v13, "key value ", 0LL);
  uint64_t v223 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v15, v16);
  uint64_t v222 = *(void *)(v223 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v223);
  uint32x4_t v221 = (char *)&v208 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v208 - v20;
  unint64_t v220 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v208 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v24,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v209 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v27 = (char *)&v208 - v26;
  uint64_t v230 = 91LL;
  unint64_t v231 = 0xE100000000000000LL;
  (*(void (**)(char *, void, uint64_t))(v220 + 16))(v23, v226, a1);
  uint64_t v29 = *(void (**)(uint64_t, uint64_t))(v24 + 32);
  uint64x2_t v219 = v27;
  v29(a1, v24);
  unint64_t v220 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v24,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64x2_t v215 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  char v30 = 1;
  __int128 v226 = xmmword_1817FFC60;
  __int128 v211 = xmmword_1817FFD10;
  uint64_t v28 = -255LL;
  __int128 v210 = xmmword_1817FFC70;
  uint64_t v212 = v5;
  uint64_t v31 = v224;
  uint64_t v32 = v225;
  uint64x2_t v214 = v9;
  for (uint64_t i = TupleTypeMetadata2; ; TupleTypeMetadata2 = i)
  {
    uint64_t v35 = v221;
    v215(v220, AssociatedConformanceWitness);
    (*(void (**)(char *, char *, uint64_t))(v222 + 32))(v21, v35, v223);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 48))( v21,  1LL,  TupleTypeMetadata2) == 1) {
      break;
    }
    uint64_t v36 = &v21[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v37 = *(void (**)(char *, char *, uint64_t))(v217 + 32);
    v37(v32, v21, v31);
    unint64_t v38 = *(void *)(v218 + 32);
    ((void (*)(char *, char *, uint64_t))v38)(v9, v36, v5);
    if ((v30 & 1) != 0) {
      goto LABEL_76;
    }
    uint64_t v42 = v230;
    uint64_t v41 = v231;
    unint64_t v43 = HIBYTE(v231) & 0xF;
    uint64_t v44 = v230 & 0xFFFFFFFFFFFFLL;
    if ((v231 & 0x2000000000000000LL) != 0) {
      unint64_t v45 = HIBYTE(v231) & 0xF;
    }
    else {
      unint64_t v45 = v230 & 0xFFFFFFFFFFFFLL;
    }
    if (v45 || (v230 & ~v231 & 0x2000000000000000LL) != 0)
    {
      if ((v231 & 0x2000000000000000LL) != 0 && v43 <= 0xD)
      {
        unint64_t v46 = 8 * (HIBYTE(v231) & 7);
        uint64_t v47 = (-255LL << v46) - 1;
        uint64_t v48 = 44LL << v46;
        char v49 = v43 + 1;
        if (v43 >= 8)
        {
          uint64_t v50 = v48 | v47 & v231;
          uint64_t v31 = v224;
LABEL_59:
          uint64_t v86 = (32LL << (8 * (v49 & 7u))) | ((-255LL << (8 * (v49 & 7u))) - 1) & v50;
        }

        else
        {
          uint64_t v42 = v48 | v47 & v230;
          uint64_t v31 = v224;
          if (v43 == 7)
          {
            char v49 = 8;
            uint64_t v50 = v231;
            goto LABEL_59;
          }

          uint64_t v42 = (32LL << (8 * (v49 & 7u))) | ((-255LL << (8 * (v49 & 7u))) - 1) & v42;
          uint64_t v86 = v231;
        }

        swift_bridgeObjectRelease(v231);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v93 = 0xE000000000000000LL;
        if (v42 & 0x8080808080808080LL | v86 & 0x80808080808080LL) {
          unint64_t v93 = 0xA000000000000000LL;
        }
        uint64_t v230 = v42;
        unint64_t v231 = (v93 & 0xFF00000000000000LL | (v43 << 56) | v86 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
        goto LABEL_75;
      }

      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v39, v40);
      if ((v41 & 0x1000000000000000LL) != 0) {
        unint64_t v45 = String.UTF8View._foreignCount()();
      }
      BOOL v51 = __OFADD__(v45, 2LL);
      uint64_t v52 = v45 + 2;
      uint64_t v32 = v225;
      if (v51) {
        goto LABEL_227;
      }
      uint64_t v53 = v42 & ~v41;
      if ((v53 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v54 = _StringGuts.nativeUnusedCapacity.getter(v42, v41);
        if ((v55 & 1) != 0) {
          goto LABEL_243;
        }
        if (v52 > 15)
        {
LABEL_48:
          int64_t v82 = _StringGuts.nativeUnusedCapacity.getter(v42, v41);
          BOOL v85 = (v83 & 1) == 0 && v82 > 1;
          if ((v53 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
          {
            uint64_t v5 = v212;
            if (v85) {
              goto LABEL_68;
            }
LABEL_61:
            uint64_t v87 = _StringGuts.nativeCapacity.getter(v42, v41);
            if ((v88 & 1) != 0) {
              uint64_t v89 = 0LL;
            }
            else {
              uint64_t v89 = v87;
            }
            if (v89 + 0x4000000000000000LL < 0) {
              goto LABEL_229;
            }
            uint64_t v90 = 2 * v89;
            if (v90 > v52) {
              uint64_t v52 = v90;
            }
          }

          else
          {
            uint64_t v5 = v212;
            if (!v85) {
              goto LABEL_61;
            }
          }

          _StringGuts.grow(_:)(v52);
LABEL_68:
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
          __int128 v229 = v210;
          uint32x4_t v91 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v229, 2LL);
          _StringGuts.appendInPlace(_:isASCII:)(v91, v92, 1);
          swift_bridgeObjectRelease(0xE200000000000000LL);
          uint64_t v31 = v224;
          goto LABEL_76;
        }

        if ((v41 & 0x2000000000000000LL) == 0)
        {
          if (v54 > 1) {
            goto LABEL_48;
          }
          goto LABEL_28;
        }

        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
LABEL_29:
        unint64_t v59 = v41;
      }

      else
      {
        if (v52 > 15) {
          goto LABEL_48;
        }
LABEL_28:
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        if ((v41 & 0x2000000000000000LL) != 0) {
          goto LABEL_29;
        }
        if ((v41 & 0x1000000000000000LL) != 0)
        {
          uint64_t v42 = _StringGuts._foreignConvertedToSmall()(v42, v41);
          unint64_t v59 = v160;
        }

        else
        {
          if ((v42 & 0x1000000000000000LL) != 0)
          {
            uint8x16_t v154 = (unsigned __int8 *)((v41 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            uint8x16_t v154 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v42, v41);
            uint64_t v44 = v56;
          }

          swift_bridgeObjectRetain(v41, v56, v57, v58);
          closure #1 in _StringGuts._convertedToSmall()(v154, v44, &v229);
          swift_bridgeObjectRelease(v41);
          unint64_t v59 = *((void *)&v229 + 1);
          uint64_t v42 = v229;
        }
      }

      v60._Swift::UInt64 rawBits = 1LL;
      v61._Swift::UInt64 rawBits = 131073LL;
      v62._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v60, v61, 0x202CuLL, 0xE200000000000000LL);
      if (v62._rawBits < 0x10000) {
        v62._rawBits |= 3;
      }
      unint64_t v64 = specialized String.init(_:)(v62, v63, 0x202CuLL, 0xE200000000000000LL);
      unint64_t v66 = v65;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      if ((v66 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v66);
      }

      else if ((v66 & 0x1000000000000000LL) != 0)
      {
        unint64_t v64 = _StringGuts._foreignConvertedToSmall()(v64, v66);
        unint64_t v159 = v158;
        swift_bridgeObjectRelease(v66);
        unint64_t v66 = v159;
      }

      else
      {
        if ((v64 & 0x1000000000000000LL) != 0)
        {
          int8x16_t v152 = (unsigned __int8 *)((v66 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v153 = v64 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          int8x16_t v152 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v64, v66);
        }

        closure #1 in _StringGuts._convertedToSmall()(v152, v153, &v229);
        swift_bridgeObjectRelease(v66);
        unint64_t v66 = *((void *)&v229 + 1);
        unint64_t v64 = v229;
      }

      uint64_t v67 = HIBYTE(v59) & 0xF;
      uint64_t v68 = HIBYTE(v66) & 0xF;
      uint64_t v69 = v68 + v67;
      if (v68)
      {
        char v70 = 0;
        unint64_t v71 = 0LL;
        do
        {
          unint64_t v72 = v67 + v71;
          unint64_t v73 = v71 + 1;
          if (v71 >= 8) {
            unint64_t v74 = v66;
          }
          else {
            unint64_t v74 = v64;
          }
          unint64_t v75 = v74 >> (v70 & 0x38);
          char v76 = (8 * v67 + v70) & 0x38;
          uint64_t v77 = (-255LL << v76) - 1;
          unint64_t v78 = (unint64_t)v75 << v76;
          unint64_t v79 = v78 | v77 & v59;
          unint64_t v80 = v78 | v77 & v42;
          if (v72 < 8) {
            uint64_t v42 = v80;
          }
          else {
            unint64_t v59 = v79;
          }
          v70 += 8;
          unint64_t v71 = v73;
        }

        while (v68 != v73);
      }

      swift_bridgeObjectRelease(v41);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v81 = 0xE000000000000000LL;
      if (v42 & 0x8080808080808080LL | v59 & 0x80808080808080LL) {
        unint64_t v81 = 0xA000000000000000LL;
      }
      uint64_t v230 = v42;
      unint64_t v231 = v81 & 0xFF00000000000000LL | (v69 << 56) | v59 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v5 = v212;
      goto LABEL_70;
    }

    swift_bridgeObjectRelease(v231);
    uint64_t v230 = 8236LL;
    unint64_t v231 = 0xE200000000000000LL;
LABEL_70:
    uint64_t v31 = v224;
LABEL_75:
    uint64_t v32 = v225;
LABEL_76:
    uint64_t v94 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v94, v228);
    *((_OWORD *)inited + 1) = v226;
    inited[7] = v31;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v37(boxed_opaque_existential_0Tm, v32, v31);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v230);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v100 = v230;
    uint64_t v99 = v231;
    unint64_t v101 = HIBYTE(v231) & 0xF;
    uint64_t v41 = v230 & 0xFFFFFFFFFFFFLL;
    if ((v231 & 0x2000000000000000LL) != 0) {
      unint64_t v102 = HIBYTE(v231) & 0xF;
    }
    else {
      unint64_t v102 = v230 & 0xFFFFFFFFFFFFLL;
    }
    if (!v102 && (v230 & ~v231 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v231);
      uint64_t v230 = 8250LL;
      unint64_t v231 = 0xE200000000000000LL;
LABEL_5:
      uint64_t v31 = v224;
      goto LABEL_6;
    }

    if ((v231 & 0x2000000000000000LL) == 0 || v101 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v97, v98);
      if ((v99 & 0x1000000000000000LL) != 0)
      {
        Swift::Int v148 = String.UTF8View._foreignCount()();
        uint64_t v52 = v148 + 2;
        if (__OFADD__(v148, 2LL))
        {
LABEL_226:
          __break(1u);
LABEL_227:
          __break(1u);
LABEL_228:
          __break(1u);
LABEL_229:
          __break(1u);
LABEL_230:
          Swift::Int v200 = String.UTF8View._foreignCount()();
          uint64_t v164 = v200 + 1;
          if (!__OFADD__(v200, 1LL)) {
            goto LABEL_180;
          }
LABEL_232:
          __break(1u);
LABEL_233:
          if ((v164 & 0x1000000000000000LL) != 0)
          {
            uint64_t v52 = _StringGuts._foreignConvertedToSmall()(v52, v164);
            uint64_t v206 = v205;
            swift_bridgeObjectRelease(v164);
            uint64_t v164 = v206;
          }

          else
          {
            if ((v52 & 0x1000000000000000LL) != 0)
            {
              int8x16_t v201 = (unsigned __int8 *)((v164 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v202 = v52 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              int8x16_t v201 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v52, v164);
            }

            closure #1 in _StringGuts._convertedToSmall()(v201, v202, &v229);
            swift_bridgeObjectRelease(v164);
            uint64_t v164 = *((void *)&v229 + 1);
            uint64_t v52 = v229;
          }

          goto LABEL_203;
        }
      }

      else
      {
        BOOL v51 = __OFADD__(v102, 2LL);
        uint64_t v52 = v102 + 2;
        if (v51) {
          goto LABEL_226;
        }
      }

      uint64_t v108 = v100 & ~v99;
      if ((v108 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v99 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v109 = _StringGuts.nativeUnusedCapacity.getter(v100, v99);
        if ((v110 & 1) != 0) {
          goto LABEL_243;
        }
        if (v52 > 15) {
          goto LABEL_114;
        }
        if ((v99 & 0x2000000000000000LL) == 0)
        {
          if (v109 <= 1) {
            goto LABEL_94;
          }
LABEL_114:
          int64_t v137 = _StringGuts.nativeUnusedCapacity.getter(v100, v99);
          uint64_t v41 = (v138 & 1) == 0 && v137 > 1;
          if ((v108 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v99 & 0xFFFFFFFFFFFFFFFLL))
          {
            uint64_t v5 = v212;
            if ((v41 & 1) != 0) {
              goto LABEL_134;
            }
LABEL_127:
            uint64_t v141 = _StringGuts.nativeCapacity.getter(v100, v99);
            if ((v142 & 1) != 0) {
              uint64_t v143 = 0LL;
            }
            else {
              uint64_t v143 = v141;
            }
            if (v143 + 0x4000000000000000LL < 0) {
              goto LABEL_228;
            }
            uint64_t v144 = 2 * v143;
            if (v144 > v52) {
              uint64_t v52 = v144;
            }
          }

          else
          {
            uint64_t v5 = v212;
            if ((v41 & 1) == 0) {
              goto LABEL_127;
            }
          }

          _StringGuts.grow(_:)(v52);
LABEL_134:
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
          __int128 v229 = v211;
          int8x16_t v145 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v229, 2LL);
          _StringGuts.appendInPlace(_:isASCII:)(v145, v146, 1);
          swift_bridgeObjectRelease(0xE200000000000000LL);
          goto LABEL_5;
        }

        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
LABEL_95:
        unint64_t v114 = v99;
      }

      else
      {
        if (v52 > 15) {
          goto LABEL_114;
        }
LABEL_94:
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        if ((v99 & 0x2000000000000000LL) != 0) {
          goto LABEL_95;
        }
        if ((v99 & 0x1000000000000000LL) != 0)
        {
          uint64_t v100 = _StringGuts._foreignConvertedToSmall()(v100, v99);
          unint64_t v114 = v157;
        }

        else
        {
          if ((v100 & 0x1000000000000000LL) != 0)
          {
            int8x16_t v151 = (unsigned __int8 *)((v99 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            int8x16_t v151 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v100, v99);
            uint64_t v41 = v111;
          }

          swift_bridgeObjectRetain(v99, v111, v112, v113);
          closure #1 in _StringGuts._convertedToSmall()(v151, v41, &v229);
          swift_bridgeObjectRelease(v99);
          unint64_t v114 = *((void *)&v229 + 1);
          uint64_t v100 = v229;
        }
      }

      v115._Swift::UInt64 rawBits = 1LL;
      v116._Swift::UInt64 rawBits = 131073LL;
      v117._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v115, v116, 0x203AuLL, 0xE200000000000000LL);
      if (v117._rawBits < 0x10000) {
        v117._rawBits |= 3;
      }
      unint64_t v119 = specialized String.init(_:)(v117, v118, 0x203AuLL, 0xE200000000000000LL);
      unint64_t v121 = v120;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      if ((v121 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v121);
      }

      else if ((v121 & 0x1000000000000000LL) != 0)
      {
        unint64_t v119 = _StringGuts._foreignConvertedToSmall()(v119, v121);
        unint64_t v156 = v155;
        swift_bridgeObjectRelease(v121);
        unint64_t v121 = v156;
      }

      else
      {
        if ((v119 & 0x1000000000000000LL) != 0)
        {
          int8x16_t v149 = (unsigned __int8 *)((v121 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v150 = v119 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          int8x16_t v149 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v119, v121);
        }

        closure #1 in _StringGuts._convertedToSmall()(v149, v150, &v229);
        swift_bridgeObjectRelease(v121);
        unint64_t v121 = *((void *)&v229 + 1);
        unint64_t v119 = v229;
      }

      uint64_t v122 = HIBYTE(v114) & 0xF;
      uint64_t v123 = HIBYTE(v121) & 0xF;
      uint64_t v124 = v123 + v122;
      if (v123)
      {
        char v125 = 0;
        unint64_t v126 = 0LL;
        do
        {
          unint64_t v127 = v122 + v126;
          unint64_t v128 = v126 + 1;
          if (v126 >= 8) {
            unint64_t v129 = v121;
          }
          else {
            unint64_t v129 = v119;
          }
          unint64_t v130 = v129 >> (v125 & 0x38);
          char v131 = (8 * v122 + v125) & 0x38;
          uint64_t v132 = (-255LL << v131) - 1;
          unint64_t v133 = (unint64_t)v130 << v131;
          unint64_t v134 = v133 | v132 & v114;
          unint64_t v135 = v133 | v132 & v100;
          if (v127 < 8) {
            uint64_t v100 = v135;
          }
          else {
            unint64_t v114 = v134;
          }
          v125 += 8;
          unint64_t v126 = v128;
        }

        while (v123 != v128);
      }

      swift_bridgeObjectRelease(v99);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v136 = 0xE000000000000000LL;
      if (v100 & 0x8080808080808080LL | v114 & 0x80808080808080LL) {
        unint64_t v136 = 0xA000000000000000LL;
      }
      uint64_t v230 = v100;
      unint64_t v231 = v136 & 0xFF00000000000000LL | (v124 << 56) | v114 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v5 = v212;
      goto LABEL_5;
    }

    unint64_t v103 = 8 * (HIBYTE(v231) & 7);
    uint64_t v104 = (-255LL << v103) - 1;
    uint64_t v105 = 58LL << v103;
    char v106 = v101 + 1;
    if (v101 >= 8)
    {
      uint64_t v107 = v105 | v104 & v231;
      uint64_t v31 = v224;
    }

    else
    {
      uint64_t v100 = v105 | v104 & v230;
      uint64_t v31 = v224;
      if (v101 != 7)
      {
        uint64_t v100 = (32LL << (8 * (v106 & 7u))) | ((-255LL << (8 * (v106 & 7u))) - 1) & v100;
        uint64_t v140 = v231;
        goto LABEL_136;
      }

      char v106 = 8;
      uint64_t v107 = v231;
    }

    uint64_t v140 = (32LL << (8 * (v106 & 7u))) | ((-255LL << (8 * (v106 & 7u))) - 1) & v107;
LABEL_136:
    swift_bridgeObjectRelease(v231);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v147 = 0xE000000000000000LL;
    if (v100 & 0x8080808080808080LL | v140 & 0x80808080808080LL) {
      unint64_t v147 = 0xA000000000000000LL;
    }
    uint64_t v230 = v100;
    unint64_t v231 = (v147 & 0xFF00000000000000LL | (v101 << 56) | v140 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
LABEL_6:
    uint64_t v33 = swift_initStackObject(v94, v227);
    *((_OWORD *)v33 + 1) = v226;
    v33[7] = v5;
    uint64_t v34 = __swift_allocate_boxed_opaque_existential_0Tm(v33 + 4);
    uint64_t v9 = v214;
    ((void (*)(void *, char *, uint64_t))v38)(v34, v214, v5);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)v33,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v230);
    swift_bridgeObjectRelease((uint64_t)v33);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    char v30 = 0;
    uint64_t v32 = v225;
  }

  (*(void (**)(char *, unint64_t))(v209 + 8))(v219, v220);
  uint64_t v28 = v230;
  uint64_t v41 = v231;
  uint64_t v52 = HIBYTE(v231) & 0xF;
  unint64_t v38 = v230 & 0xFFFFFFFFFFFFLL;
  if ((v231 & 0x2000000000000000LL) != 0) {
    unint64_t v163 = HIBYTE(v231) & 0xF;
  }
  else {
    unint64_t v163 = v230 & 0xFFFFFFFFFFFFLL;
  }
  if (!v163 && (v230 & ~v231 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v231);
    return 93LL;
  }

  if ((v231 & 0x2000000000000000LL) == 0 || v52 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v161, v162);
    if ((v41 & 0x1000000000000000LL) != 0) {
      goto LABEL_230;
    }
    BOOL v51 = __OFADD__(v163, 1LL);
    uint64_t v164 = v163 + 1;
    if (v51) {
      goto LABEL_232;
    }
LABEL_180:
    uint64_t v165 = v28 & ~v41;
    if ((v165 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v166 = _StringGuts.nativeUnusedCapacity.getter(v28, v41);
      if ((v167 & 1) != 0)
      {
LABEL_243:
        unint64_t v204 = 258LL;
LABEL_244:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v204,  0);
      }

      if (v164 > 15) {
        goto LABEL_186;
      }
      if ((v41 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        goto LABEL_198;
      }

      if (v166 > 0)
      {
LABEL_186:
        int64_t v168 = _StringGuts.nativeUnusedCapacity.getter(v28, v41);
        BOOL v171 = (v169 & 1) == 0 && v168 > 0;
        if ((v165 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v171) {
            goto LABEL_222;
          }
        }

        else if (v171)
        {
LABEL_221:
          _StringGuts.grow(_:)(v164);
LABEL_222:
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          __int128 v229 = xmmword_1817FFC80;
          int64x2_t v197 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v229, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v197, v198, 1);
          swift_bridgeObjectRelease(0xE100000000000000LL);
          return v230;
        }

        uint64_t v193 = _StringGuts.nativeCapacity.getter(v28, v41);
        if ((v194 & 1) != 0) {
          uint64_t v195 = 0LL;
        }
        else {
          uint64_t v195 = v193;
        }
        if (v195 + 0x4000000000000000LL >= 0)
        {
          uint64_t v196 = 2 * v195;
          if (v196 > v164) {
            uint64_t v164 = v196;
          }
          goto LABEL_221;
        }

        __break(1u);
        goto LABEL_242;
      }
    }

    else if (v164 > 15)
    {
      goto LABEL_186;
    }

    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    if ((v41 & 0x2000000000000000LL) == 0)
    {
      if ((v41 & 0x1000000000000000LL) != 0)
      {
        uint64_t v28 = _StringGuts._foreignConvertedToSmall()(v28, v41);
        unint64_t v38 = v207;
      }

      else
      {
        if ((v28 & 0x1000000000000000LL) != 0)
        {
          int64x2_t v203 = (unsigned __int8 *)((v41 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          int64x2_t v203 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v28, v41);
          unint64_t v38 = v172;
        }

        swift_bridgeObjectRetain(v41, v172, v173, v174);
        closure #1 in _StringGuts._convertedToSmall()(v203, v38, &v229);
        swift_bridgeObjectRelease(v41);
        unint64_t v38 = *((void *)&v229 + 1);
        uint64_t v28 = v229;
      }

      goto LABEL_199;
    }

uint64_t specialized _bridgeCocoaArray<A>(_:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t type metadata accessor for _ArrayAnyHashableBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _ArrayAnyHashableBox);
}

BOOL specialized _deallocateUninitializedArray<A>(_:)(uint64_t a1, uint64_t *a2)
{
  BOOL result = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  uint64_t v4 = a1 & 0xFFFFFFFFFFFFF8LL;
  if (!result) {
    uint64_t v4 = a1;
  }
  *(void *)(v4 + 16) = 0LL;
  return result;
}

uint64_t type metadata accessor for __ContiguousArrayStorageBase()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _SliceBuffer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _SliceBuffer,  &flag for loading of canonical specialized generic type metadata for _SliceBuffer);
}

uint64_t type metadata accessor for IteratorSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for IteratorSequence);
}

void sub_1816FABEC()
{
}

uint64_t type metadata accessor for _ContiguousArrayBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _ContiguousArrayBuffer);
}

void partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:)( const char *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v7 = *(void *)(v4 + 16);
  unint64_t v8 = *(void *)(v4 + 24);
  uint64_t v10 = *(const char **)(v4 + 32);
  uint64_t v9 = *(void *)(v4 + 40);
  char v11 = *(_BYTE *)(v4 + 48);
  unint64_t v12 = *(void *)(v4 + 56);
  int v13 = *(_DWORD *)(v4 + 64);
  swift_bridgeObjectRetain(v8, a2, a3, a4);
  if ((v8 & 0x1000000000000000LL) != 0)
  {
    uint64_t v7 = specialized static String._copying(_:)(v7, v8);
    unint64_t v17 = v16;
    swift_bridgeObjectRelease(v8);
    unint64_t v8 = v17;
    if ((v17 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    v18[0] = v7;
    v18[1] = v8 & 0xFFFFFFFFFFFFFFLL;
    closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)( (const char *)v18,  HIBYTE(v8) & 0xF,  v10,  v9,  v11,  a1,  a2,  v12,  v13);
    swift_bridgeObjectRelease(v8);
    return;
  }

  if ((v8 & 0x2000000000000000LL) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((v7 & 0x1000000000000000LL) != 0)
  {
    int v14 = (const char *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v15 = v7 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    int v14 = (const char *)_StringObject.sharedUTF8.getter(v7, v8);
  }

  closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(v14, v15, v10, v9, v11, a1, a2, v12, v13);
  swift_bridgeObjectRelease(v8);
}

uint64_t partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:)(const char *a1, uint64_t a2)
{
  return closure #1 in _assertionFailure(_:_:file:line:flags:)( a1,  a2,  *(const char **)(v2 + 16),  *(void *)(v2 + 24),  *(_BYTE *)(v2 + 32),  *(const char **)(v2 + 40),  *(void *)(v2 + 48),  *(_BYTE *)(v2 + 56),  *(void *)(v2 + 64),  *(_DWORD *)(v2 + 72));
}

void partial apply for closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( const char *a1, uint64_t a2)
{
}

uint64_t type metadata accessor for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideToIterator);
}

unint64_t lazy protocol witness table accessor for type Int and conformance Int( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }

  return result;
}

uint64_t type metadata accessor for _SwiftNSMutableArray()
{
  return objc_opt_self();
}

uint64_t *outlined destroy of Any?(uint64_t *a1)
{
  if (!swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::OpaqueExistentialBox<0u>>,true,32ul,8ul,true>::getEnumTagSinglePayload( (uint64_t)a1,  1)) {
    swift::metadataimpl::ValueWitnesses<swift::metadataimpl::OpaqueExistentialBox<0u>>::destroy(a1);
  }
  return a1;
}

uint64_t type metadata accessor for AutoreleasingUnsafeMutablePointer( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for AutoreleasingUnsafeMutablePointer);
}

void sub_1816FAE78()
{
}

void *__swift_allocate_boxed_opaque_existential_0Tm(void *a1)
{
  double v1 = a1;
  uint64_t v2 = a1[3];
  if ((*(_BYTE *)(*(void *)(v2 - 8) + 82LL) & 2) != 0)
  {
    void *v1 = swift_allocBox(v2);
    return (void *)v3;
  }

  return v1;
}

uint64_t type metadata accessor for _KeyedEncodingContainerBox( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _KeyedEncodingContainerBox);
}

uint64_t type metadata accessor for _KeyedDecodingContainerBox( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _KeyedDecodingContainerBox);
}

void *outlined init with copy of EncodingError(void *a1, void *a2)
{
  return initializeWithCopy for EncodingError(a2, a1);
}

uint64_t __swift_destroy_boxed_opaque_existential_1Tm(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[3] - 8);
  if ((*(_BYTE *)(v1 + 82) & 2) != 0) {
    return swift_release(*a1);
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t type metadata accessor for _DictionaryStorage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _DictionaryStorage,  &flag for loading of canonical specialized generic type metadata for _DictionaryStorage);
}

uint64_t type metadata accessor for Dictionary._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary._Variant);
}

uint64_t outlined init with copy of DecodingError(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return initializeWithCopy for DecodingError(a2, a1, a3, a4);
}

uint64_t outlined destroy of DecodingError(uint64_t a1)
{
  return a1;
}

void *__swift_project_boxed_opaque_existential_0Tm(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) + 16LL) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80LL)));
  return result;
}

unint64_t specialized RangeReplaceableCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5( (void (*)(uint64_t *__return_ptr, char *))protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar,  0LL,  a2,  a3);
  uint64_t v4 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v3, 1LL);
  unint64_t v6 = v5;
  swift_bridgeObjectRelease((uint64_t)v3);
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  }
  unint64_t v7 = specialized static String.+ infix(_:_:)(0LL, 0xE000000000000000LL, v4, v6);
  swift_bridgeObjectRelease(v6);
  return v7;
}

unint64_t specialized _GenericIndexKey.init(intValue:)(uint64_t a1)
{
  unint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(8LL);
  uint64_t v4 = v3;
  unint64_t v26 = v2;
  unint64_t v27 = v3;
  uint64_t v5 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    uint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 || (v2 & ~v3 & 0x2000000000000000LL) != 0)
  {
    if ((v3 & 0x2000000000000000LL) == 0
      || (unint64_t v6 = specialized _SmallString.init(_:appending:)(v2, v3, 0x207865646E49uLL, 0xE600000000000000LL),
          (v8 & 1) != 0))
    {
      _StringGuts.append(_:)(0x207865646E49LL, 0xE600000000000000LL, 0LL, 6LL);
      unint64_t v9 = v26;
      unint64_t v10 = v27;
      goto LABEL_11;
    }

    unint64_t v9 = v6;
    unint64_t v10 = v7;
    swift_bridgeObjectRelease(v4);
  }

  else
  {
    unint64_t v9 = 0x207865646E49LL;
    swift_bridgeObjectRelease(v3);
    unint64_t v10 = 0xE600000000000000LL;
  }

  unint64_t v26 = v9;
  unint64_t v27 = v10;
LABEL_11:
  unint64_t v12 = _int64ToString(_:radix:uppercase:)( a1,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v13 = v11;
  uint64_t v14 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000LL) == 0) {
    uint64_t v14 = v9 & 0xFFFFFFFFFFFFLL;
  }
  if (v14 || (v9 & ~v10 & 0x2000000000000000LL) != 0)
  {
    if ((v10 & 0x2000000000000000LL) != 0)
    {
      if ((v11 & 0x2000000000000000LL) != 0)
      {
        unint64_t v16 = specialized _SmallString.init(_:appending:)(v9, v10, v12, v11);
        if ((v18 & 1) == 0)
        {
          unint64_t v19 = v16;
          unint64_t v20 = v17;
          swift_bridgeObjectRelease(v10);
          swift_bridgeObjectRelease(v13);
          unint64_t v26 = v19;
          unint64_t v13 = v20;
          unint64_t v12 = v19;
          goto LABEL_24;
        }

        goto LABEL_22;
      }
    }

    else if ((v11 & 0x2000000000000000LL) != 0)
    {
LABEL_22:
      uint64_t v15 = HIBYTE(v13) & 0xF;
      goto LABEL_23;
    }

    uint64_t v15 = v12 & 0xFFFFFFFFFFFFLL;
LABEL_23:
    _StringGuts.append(_:)(v12, v13, 0LL, v15);
    swift_bridgeObjectRelease(v13);
    unint64_t v12 = v26;
    unint64_t v13 = v27;
    goto LABEL_24;
  }

  swift_bridgeObjectRelease(v10);
  unint64_t v26 = v12;
LABEL_24:
  uint64_t v21 = HIBYTE(v13) & 0xF;
  if ((v13 & 0x2000000000000000LL) == 0) {
    uint64_t v21 = v12 & 0xFFFFFFFFFFFFLL;
  }
  if (v21 || (v12 & ~v13 & 0x2000000000000000LL) != 0)
  {
    if ((v13 & 0x2000000000000000LL) == 0
      || (unint64_t v22 = specialized _SmallString.init(_:appending:)(v12, v13, 0LL, 0xE000000000000000LL), (v23 & 1) != 0))
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      return v26;
    }

    else
    {
      unint64_t v24 = v22;
      swift_bridgeObjectRelease(v13);
      swift_bridgeObjectRelease(0xE000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v13);
    return 0LL;
  }

  return v24;
}

void sub_1816FB29C()
{
}

uint64_t *__swift_mutable_project_boxed_opaque_existential_1(uint64_t *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) & 0x20000) != 0)
  {
    swift_makeBoxUnique(result, a2, *(_DWORD *)(*(void *)(a2 - 8) + 80LL));
    return (uint64_t *)v2;
  }

  return result;
}

float specialized Float16.init(from:)(uint64_t *a1)
{
  uint64_t v4 = v42;
  uint64_t v5 = v43;
  __swift_project_boxed_opaque_existential_0Tm(&v40, v42);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v37, v4, v5);
  if (v1)
  {
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v40);
  }

  else
  {
    uint64_t v6 = v38;
    uint64_t v7 = v39;
    __swift_project_boxed_opaque_existential_0Tm(v37, v38);
    _S8 = (*(float (**)(uint64_t, uint64_t))(v7 + 48))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v37);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v40);
    __asm { FCVT            H9, S8 }

    if ((LOWORD(_S9) & 0x7FFF) == 0x7C00 && (~LODWORD(_S8) & 0x7F800000) != 0)
    {
      swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
      uint64_t v15 = v14;
      uint64_t v16 = a1[3];
      uint64_t v17 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v16);
      uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 8))(v16, v17);
      unint64_t v19 = specialized static String._createEmpty(withInitialCapacity:)(46LL);
      uint64_t v21 = v20;
      unint64_t v40 = v19;
      unint64_t v41 = v20;
      uint64_t v22 = HIBYTE(v20) & 0xF;
      if ((v20 & 0x2000000000000000LL) == 0) {
        uint64_t v22 = v19 & 0xFFFFFFFFFFFFLL;
      }
      if (v22 || (v19 & ~v20 & 0x2000000000000000LL) != 0)
      {
        if ((v20 & 0x2000000000000000LL) != 0
          && ((unint64_t)"ffer is not allowed" & 0x2000000000000000LL) != 0
          && (unint64_t v23 = specialized _SmallString.init(_:appending:)(v19, v20, 0xD000000000000013LL, 0x80000001818BB3D0LL),
              (v25 & 1) == 0))
        {
          unint64_t v26 = v23;
          unint64_t v27 = v24;
          swift_bridgeObjectRelease(v21);
          unint64_t v40 = v26;
          unint64_t v41 = v27;
        }

        else
        {
          else {
            unint64_t v28 = 19LL;
          }
          _StringGuts.append(_:)(0xD000000000000013LL, 0x80000001818BB3D0LL, 0LL, v28);
        }
      }

      else
      {
        swift_bridgeObjectRelease(v20);
        unint64_t v40 = 0xD000000000000013LL;
        unint64_t v41 = 0x80000001818BB3D0LL;
      }

      specialized Float.write<A>(to:)();
      uint64_t v29 = v41;
      unint64_t v30 = HIBYTE(v41) & 0xF;
      if ((v41 & 0x2000000000000000LL) == 0) {
        unint64_t v30 = v40 & 0xFFFFFFFFFFFFLL;
      }
      if (v30 || (v40 & ~v41 & 0x2000000000000000LL) != 0)
      {
        if ((v41 & 0x2000000000000000LL) != 0
          && ((unint64_t)"Parsed JSON number " & 0x2000000000000000LL) != 0
          && (unint64_t v31 = specialized _SmallString.init(_:appending:)(v40, v41, 0xD000000000000019LL, 0x80000001818BB3F0LL),
              (v33 & 1) == 0))
        {
          unint64_t v34 = v31;
          unint64_t v35 = v32;
          swift_bridgeObjectRelease(v29);
        }

        else
        {
          else {
            unint64_t v36 = 25LL;
          }
          _StringGuts.append(_:)(0xD000000000000019LL, 0x80000001818BB3F0LL, 0LL, v36);
          unint64_t v34 = v40;
          unint64_t v35 = v41;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v41);
        unint64_t v34 = 0xD000000000000019LL;
        unint64_t v35 = 0x80000001818BB3F0LL;
      }

      *(void *)uint64_t v15 = v18;
      *(void *)(v15 + 8) = v34;
      *(void *)(v15 + 16) = v35;
      *(void *)(v15 + 24) = 0LL;
      *(_BYTE *)(v15 + 72) = 3;
      swift_willThrow();
    }
  }

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return _S9;
}

uint64_t type metadata accessor for __CocoaSet.Iterator()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for Set._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Set._Variant);
}

unint64_t lazy protocol witness table accessor for type UInt8 and conformance UInt8( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8, &type metadata for UInt8, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8, &type metadata for UInt8, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8, &type metadata for UInt8, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }

  return result;
}

uint64_t specialized _DictionaryCodingKey.init(stringValue:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v6 = HIBYTE(a2) & 0xF;
  uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v8 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v8)
  {
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain(a2, a2, a3, a4);
      specialized _parseInteger<A, B>(ascii:radix:)( a1,  a2,  10LL,  (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:));
      goto LABEL_86;
    }

    if ((a2 & 0x2000000000000000LL) == 0)
    {
      if ((a1 & 0x1000000000000000LL) != 0)
      {
        unint64_t v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
          goto LABEL_9;
        }
      }

      else
      {
        unint64_t v9 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
        uint64_t v7 = a2;
        if (a2 > 0)
        {
LABEL_9:
          int v10 = *v9;
          if (v10 == 43)
          {
            swift_bridgeObjectRetain(a2, a2, a3, a4);
            char v11 = 1;
            uint64_t v38 = specialized Collection.subscript.getter(1LL, (uint64_t)v9, v7);
            uint64_t v42 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v38, v39, v40, v41);
            if (!v43) {
              goto LABEL_82;
            }
            if (v42)
            {
              uint64_t v44 = 0LL;
              while (1)
              {
                unsigned int v45 = *v42 - 48;
                if (v45 > 9) {
                  goto LABEL_76;
                }
                uint64_t v46 = (unsigned __int128)(v44 * (__int128)10LL) >> 64;
                uint64_t v47 = 10 * v44;
                BOOL v48 = v46 != v47 >> 63;
                BOOL v23 = __OFADD__(v47, v45);
                uint64_t v44 = v47 + v45;
                char v49 = v23;
                char v11 = 1;
                if (!v48 && (v49 & 1) == 0)
                {
                  char v11 = 0;
                  ++v42;
                  if (--v43) {
                    continue;
                  }
                }

                goto LABEL_82;
              }
            }
          }

          else
          {
            if (v10 != 45)
            {
              uint64_t v50 = 0LL;
              while (1)
              {
                unsigned int v51 = *v9 - 48;
                if (v51 > 9) {
                  break;
                }
                uint64_t v52 = (unsigned __int128)(v50 * (__int128)10LL) >> 64;
                uint64_t v53 = 10 * v50;
                BOOL v54 = v52 != v53 >> 63;
                BOOL v23 = __OFADD__(v53, v51);
                uint64_t v50 = v53 + v51;
                char v55 = v23;
                char v11 = 1;
                if (v54 || (v55 & 1) != 0) {
                  goto LABEL_81;
                }
                ++v9;
                if (!--v7)
                {
                  char v11 = 0;
                  goto LABEL_81;
                }
              }

              char v11 = 1;
LABEL_81:
              swift_bridgeObjectRetain(a2, a2, a3, a4);
              goto LABEL_82;
            }

            swift_bridgeObjectRetain(a2, a2, a3, a4);
            char v11 = 1;
            uint64_t v12 = specialized Collection.subscript.getter(1LL, (uint64_t)v9, v7);
            uint64_t v16 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v12, v13, v14, v15);
            if (!v17)
            {
LABEL_82:
              char v77 = v11;
LABEL_86:
              swift_bridgeObjectRelease(a2);
              return a1;
            }

            if (v16)
            {
              uint64_t v18 = 0LL;
              while (1)
              {
                unsigned int v19 = *v16 - 48;
                if (v19 > 9) {
                  break;
                }
                uint64_t v20 = (unsigned __int128)(v18 * (__int128)10LL) >> 64;
                uint64_t v21 = 10 * v18;
                BOOL v22 = v20 != v21 >> 63;
                BOOL v23 = __OFSUB__(v21, v19);
                uint64_t v18 = v21 - v19;
                char v24 = v23;
                char v11 = 1;
                if (!v22 && (v24 & 1) == 0)
                {
                  char v11 = 0;
                  ++v16;
                  if (--v17) {
                    continue;
                  }
                }

                goto LABEL_82;
              }

unint64_t specialized _DictionaryCodingKey.init(intValue:)(uint64_t a1)
{
  uint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(2LL);
  unint64_t v4 = v2;
  unint64_t v5 = v3;
  unint64_t v22 = v2;
  unint64_t v23 = v3;
  uint64_t v6 = HIBYTE(v3) & 0xF;
  uint64_t v7 = v2 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000LL) != 0) {
    uint64_t v7 = HIBYTE(v3) & 0xF;
  }
  if (v7 || (v2 & ~v3 & 0x2000000000000000LL) != 0)
  {
    if ((v3 & 0x2000000000000000LL) == 0)
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      unint64_t v4 = v22;
      unint64_t v8 = v23;
      goto LABEL_12;
    }

    swift_bridgeObjectRelease(v3);
    unint64_t v9 = 0xA000000000000000LL;
    if (!(v5 & 0x80808080808080LL | v4 & 0x8080808080808080LL)) {
      unint64_t v9 = 0xE000000000000000LL;
    }
    unint64_t v8 = v9 & 0xFF00000000000000LL | (v6 << 56) | v5 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v22 = v4;
  }

  else
  {
    swift_bridgeObjectRelease(v3);
    unint64_t v4 = 0LL;
    unint64_t v8 = 0xE000000000000000LL;
    unint64_t v22 = 0LL;
  }

  unint64_t v23 = v8;
LABEL_12:
  unint64_t v11 = _int64ToString(_:radix:uppercase:)( a1,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v12 = v10;
  uint64_t v13 = HIBYTE(v8) & 0xF;
  if ((v8 & 0x2000000000000000LL) == 0) {
    uint64_t v13 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v13 || (v4 & ~v8 & 0x2000000000000000LL) != 0)
  {
    if ((v8 & 0x2000000000000000LL) != 0)
    {
      if ((v10 & 0x2000000000000000LL) != 0)
      {
        unint64_t v15 = specialized _SmallString.init(_:appending:)(v4, v8, v11, v10);
        if ((v17 & 1) == 0)
        {
          unint64_t v18 = v15;
          unint64_t v19 = v16;
          swift_bridgeObjectRelease(v8);
          swift_bridgeObjectRelease(v12);
          unint64_t v22 = v18;
          unint64_t v12 = v19;
          unint64_t v11 = v18;
          goto LABEL_25;
        }

        goto LABEL_23;
      }
    }

    else if ((v10 & 0x2000000000000000LL) != 0)
    {
LABEL_23:
      uint64_t v14 = HIBYTE(v12) & 0xF;
      goto LABEL_24;
    }

    uint64_t v14 = v11 & 0xFFFFFFFFFFFFLL;
LABEL_24:
    _StringGuts.append(_:)(v11, v12, 0LL, v14);
    swift_bridgeObjectRelease(v12);
    unint64_t v11 = v22;
    unint64_t v12 = v23;
    goto LABEL_25;
  }

  swift_bridgeObjectRelease(v8);
  unint64_t v22 = v11;
LABEL_25:
  uint64_t v20 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v12 & 0x2000000000000000LL) != 0) {
    uint64_t v20 = HIBYTE(v12) & 0xF;
  }
  if (v20 || (v11 & ~v12 & 0x2000000000000000LL) != 0)
  {
    if ((v12 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v12);
    }

    else
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      return v22;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v12);
    return 0LL;
  }

  return v11;
}

uint64_t specialized Int.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 40))(a2, a3);
}

uint64_t specialized String.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
}

uint64_t type metadata accessor for __CocoaDictionary.Iterator()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _NativeDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _NativeDictionary);
}

uint64_t type metadata accessor for Slice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Slice);
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error)( uint64_t a1, void *a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error)( a1,  a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  unint64_t result = (*(uint64_t (**)(void))(v2 + 40))();
  if (v3) {
    *a2 = v3;
  }
  return result;
}

void sub_1816FBDC4()
{
}

uint64_t partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)( uint64_t a1)
{
  return partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(a1) & 1;
}

{
  void *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v3 = v1[2];
  unint64_t v4 = v1[3];
  uint64_t v6 = v1[4];
  unint64_t v5 = v1[5];
  swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v4 + 8),  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t partial apply for closure #1 in BidirectionalCollection.last(where:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return closure #1 in BidirectionalCollection.last(where:)(a1, *(void *)(v2 + 16), *(void *)(v2 + 24), a2);
}

uint64_t partial apply for closure #1 in BidirectionalCollection<>.lastIndex(of:)(uint64_t a1)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = v1[3];
  uint64_t v6 = v1[4];
  uint64_t v5 = v1[5];
  swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(v4 + 8) + 8LL),  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t specialized static _UInt128.% infix(_:_:)( Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, unint64_t a4)
{
  if (!(a4 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in %=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x1DCuLL,  0);
  }
  v10.low = a2;
  v10.high = (Swift::UInt64)&v7;
  specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, a1, a4, a3);
  return v7;
}

uint64_t specialized Array.init(repeating:count:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  uint64_t v5 = a2;
  uint64_t v7 = a4(a2, a3);
  if (v5 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v9 = v7;
  if (v5)
  {
    uint64_t v10 = v8;
    uint64_t v11 = *(void *)(a3 - 8);
    unint64_t v12 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 16);
    do
    {
      v12(v10, a1, a3);
      v10 += *(void *)(v11 + 72);
      --v5;
    }

    while (v5);
  }

  return v9;
}

uint64_t outlined init with copy of Any(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t outlined init with copy of Any?(uint64_t a1, uint64_t a2)
{
  return initializeWithCopy for ClosedRange<>.Index(a2, a1, &unk_189B88D00);
}

void sub_1816FC0D4()
{
}

uint64_t partial apply for closure #1 in Substring.withUnsafeBytes<A>(_:)(uint64_t a1, uint64_t a2)
{
  return closure #1 in Substring.withUnsafeBytes<A>(_:)(a1, a2, *(uint64_t (**)(uint64_t, uint64_t))(v2 + 24));
}

uint64_t type metadata accessor for ClosedRange<>.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ClosedRange<>.Index);
}

uint64_t type metadata accessor for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DefaultIndices);
}

uint64_t specialized _ContiguousArrayStorage.countByEnumerating(with:objects:count:)(void *a1)
{
  if (*a1) {
    return 0LL;
  }
  uint64_t result = v1[2];
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(*(void *)(*v1 + 144LL) - 8LL) + 80LL);
  *a1 = 1LL;
  a1[1] = (char *)v1 + ((v4 + 32) & ~v4);
  a1[2] = &_fastEnumerationStorageMutationsTarget;
  return result;
}

void specialized _ContiguousArrayBuffer.subscript.setter()
{
}

uint64_t type metadata accessor for UnsafeBufferPointer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for UnsafeBufferPointer,  &flag for loading of canonical specialized generic type metadata for UnsafeBufferPointer);
}

uint64_t specialized _StringGuts._slowWithCString<A>(_:)( unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  int v4 = a3;
  uint64_t v5 = String.utf8CString.getter(a1, a2, a3, a4);
  LOBYTE(v4) = _swift_stdlib_NSObject_isKindOfClass(v4, (char *)v5 + 32);
  swift_release((uint64_t)v5);
  return v4 & 1;
}

id specialized String.withCString<A>(_:)(unint64_t a1, unint64_t a2, void *a3, char *a4)
{
  if ((a2 & 0x1000000000000000LL) != 0 || !(a2 & 0x2000000000000000LL | a1 & 0x1000000000000000LL)) {
    return (id)(specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)a3, a4) & 1);
  }
  if ((a2 & 0x2000000000000000LL) != 0)
  {
    v10[0] = a1;
    v10[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    int v8 = swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
    char isKindOfClass = _swift_stdlib_NSObject_isKindOfClass(v8, (char *)v10);
    swift_unknownObjectRelease(a3);
  }

  else
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      uint64_t v5 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v5 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
      if (!v5)
      {
        id result = swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
        __break(1u);
        return result;
      }
    }

    int v6 = swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
    char isKindOfClass = _swift_stdlib_NSObject_isKindOfClass(v6, v5);
    swift_unknownObjectRelease(a3);
  }

  return (id)(isKindOfClass & 1);
}

uint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)( unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  char v4 = a2;
  int v6 = (uint8x16_t *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 16);
  swift_bridgeObjectRetain(a1, a2, a3, a4);
  if (_allASCII(_:)(v6->i64, v7) && (unint64_t v8 = specialized static String._uncheckedFromASCII(_:)(v6, v7), v9))
  {
    uint64_t v10 = v8;
    swift_bridgeObjectRelease(a1);
  }

  else
  {
    uint64_t v10 = specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1, v4 & 1);
    swift_bridgeObjectRelease(a1);
  }

  return v10;
}

unint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)( uint8x16_t *a1, uint64_t a2, char a3)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  if (a2)
  {
    if (!a1) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
    goto LABEL_6;
  }

  if (a1)
  {
LABEL_6:
    int v6 = &a1->i8[a2];
    goto LABEL_7;
  }

  int v6 = 0LL;
LABEL_7:
  uint64_t v7 = v6 - (__int8 *)a1;
  if (a1) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0LL;
  }
  if (!_allASCII(_:)(a1->i64, v8)) {
    return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1->i8, a2, a3 & 1);
  }
  unint64_t result = specialized static String._uncheckedFromASCII(_:)(a1, v8);
  if (!v10) {
    return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1->i8, a2, a3 & 1);
  }
  return result;
}

unint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)( uint8x16_t *a1, uint64_t a2, ValueMetadata *a3, char *a4)
{
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for UnsafeBufferPointer<UInt8>
    && a3 == &type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, a2, a4 & 1);
  }

  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for [UInt8]
    && a3 == &type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)( (unint64_t)a1,  a4 & 1,  (uint64_t)a3,  a4);
  }

  return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)( (unsigned __int16 *)a1,  a2,  a4 & 1);
}

unint64_t partial apply for closure #2 in static String._fromCodeUnits<A, B>(_:encoding:repair:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(v3 + 32) + 8LL),  *(void *)(v3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = (uint64_t *)UnsafeRawBufferPointer.init<A>(_:)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = (uint8x16_t *)v8;
  if (v8)
  {
    uint64_t v11 = v9 - (void)v8;
    if (v9 - (uint64_t)v8 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  if (_allASCII(_:)(v8, v11))
  {
    unint64_t result = specialized static String._uncheckedFromASCII(_:)(v10, v11);
  }

  else
  {
    unint64_t result = 0LL;
    unint64_t v13 = 0LL;
  }

  *a3 = result;
  a3[1] = v13;
  return result;
}

uint64_t partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:)()
{
  return partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:)();
}

{
  uint64_t v0;
  return (*(uint64_t (**)(void))(v0 + 40))();
}

uint64_t outlined init with copy of AnyHashable?(uint64_t a1, uint64_t a2)
{
  return initializeWithCopy for ClosedRange<>.Index(a2, a1, &unk_189B88AB0);
}

uint64_t *outlined destroy of AnyHashable?(uint64_t *a1)
{
  return a1;
}

uint64_t *outlined destroy of AnyHashable(uint64_t *a1)
{
  return a1;
}

unint64_t specialized String.init(repeating:count:)( unint64_t a1, unint64_t a2, unint64_t a3)
{
  if ((a3 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative count not allowed",  26LL,  2,  "Swift/StringLegacy.swift",  24LL,  2,  0x1FuLL,  0);
  }
  unint64_t v3 = a3;
  unint64_t v5 = a1;
  if (a3 >= 2)
  {
    unint64_t v18 = 0LL;
    unint64_t v19 = 0xE000000000000000LL;
    if ((a2 & 0x2000000000000000LL) != 0) {
      uint64_t v6 = HIBYTE(a2) & 0xF;
    }
    else {
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
    }
    String.reserveCapacity(_:)(v6 * a3);
    while (1)
    {
      while (1)
      {
        if (!v3) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        uint64_t v10 = HIBYTE(v19) & 0xF;
        if ((v19 & 0x2000000000000000LL) == 0) {
          uint64_t v10 = v18 & 0xFFFFFFFFFFFFLL;
        }
        if (v10 || (v18 & ~v19 & 0x2000000000000000LL) != 0) {
          break;
        }
        swift_bridgeObjectRetain(a2, v7, v8, v9);
        swift_bridgeObjectRelease(v19);
        unint64_t v18 = v5;
        unint64_t v19 = a2;
        if (!--v3)
        {
LABEL_23:
          swift_bridgeObjectRelease(a2);
          return v18;
        }
      }

      uint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
      if ((v19 & 0x2000000000000000LL) == 0) {
        break;
      }
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        unint64_t v12 = specialized _SmallString.init(_:appending:)(v18, v19, v5, a2);
        if ((v14 & 1) != 0) {
          goto LABEL_19;
        }
        unint64_t v15 = v12;
        unint64_t v16 = v13;
        swift_bridgeObjectRelease(v19);
        unint64_t v18 = v15;
        unint64_t v19 = v16;
        if (!--v3) {
          goto LABEL_23;
        }
      }

      else
      {
LABEL_20:
        _StringGuts.append(_:)(v5, a2, 0LL, v11);
        if (!--v3) {
          goto LABEL_23;
        }
      }
    }

    if ((a2 & 0x2000000000000000LL) == 0) {
      goto LABEL_20;
    }
LABEL_19:
    uint64_t v11 = HIBYTE(a2) & 0xF;
    goto LABEL_20;
  }

  if (!a3)
  {
    swift_bridgeObjectRelease(a2);
    return 0LL;
  }

  return v5;
}

uint64_t outlined init with copy of AnyHashable(uint64_t a1, uint64_t a2)
{
  __int128 v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

unint64_t specialized static _DebuggerSupport.stringForPrintObject(_:)(uint64_t a1)
{
  uint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v6 = &_swiftEmptySetSingleton;
  v5[0] = 0LL;
  v5[1] = 0xE000000000000000LL;
  outlined init with copy of Any(a1, (uint64_t)v4);
  outlined init with copy of Any(a1, (uint64_t)v3);
  Mirror.init(reflecting:)(v3, (uint64_t)v8);
  specialized static _DebuggerSupport.printForDebuggerImpl<A>(value:mirror:name:indent:maxDepth:isRoot:parentCollectionStatus:refsAlreadySeen:maxItemCounter:target:)( (uint64_t)v4,  (uint64_t)v8,  0LL,  0LL,  0LL,  0x7FFFFFFFFFFFFFFFLL,  1,  0,  (uint64_t)&v6,  &v7,  v5);
  outlined release of Mirror((uint64_t)v8);
  outlined destroy of Any?(v4);
  swift_bridgeObjectRelease((uint64_t)v6);
  return v5[0];
}

uint64_t type metadata accessor for Dictionary(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Dictionary,  &flag for loading of canonical specialized generic type metadata for Dictionary);
}

uint64_t partial apply for closure #1 in Dictionary.init<A>(uniqueKeysWithValues:)()
{
  return swift_willThrow();
}

void specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)( void (*a1)(char *, uint64_t, swift *), char a2, void (*a3)(char *, char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64x2_t v98 = a3;
  uint64_t v99 = a4;
  int64_t v109 = a1;
  uint64_t v111 = *(void *)(*(void *)(a5 + 24) - 8LL);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v97 = (char *)&v91 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64x2_t v96 = (char *)&v91 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint32x4_t v95 = (char *)&v91 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v112 = (char *)&v91 - v17;
  uint64_t v110 = v18;
  uint64_t v92 = *(void *)(*(void *)(v18 + 16) - 8LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v94 = (char *)&v91 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  int8x16_t v113 = (char *)&v91 - v22;
  unint64_t v114 = v21;
  uint64_t v105 = v23;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, (uint64_t)v21, v23, 0LL, 0LL);
  uint64_t v27 = type metadata accessor for Optional(0LL, (uint64_t)TupleTypeMetadata2, v25, v26);
  uint64_t v28 = MEMORY[0x1895F8858](v27);
  unint64_t v30 = (char *)&v91 - v29;
  uint64_t v31 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](v28);
  unsigned int v33 = (char *)&v91 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a7,  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v93 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  BOOL v36 = (char *)&v91 - v35;
  (*(void (**)(char *, void, uint64_t))(v31 + 16))(v33, v109, a6);
  char v37 = v30;
  (*(void (**)(uint64_t))(a7 + 32))(a6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  a6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v39 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v107 = v36;
  unint64_t v108 = AssociatedTypeWitness;
  unint64_t v103 = v39;
  unint64_t v104 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v39)(AssociatedTypeWitness);
  uint64_t v40 = TupleTypeMetadata2;
  unint64_t v102 = *(unsigned int (**)(char *, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 48);
  if (v102(v30, 1LL, TupleTypeMetadata2) == 1)
  {
LABEL_2:
    (*(void (**)(char *, unint64_t))(v93 + 8))(v107, v108);
    return;
  }

  uint64_t v41 = v92;
  int64_t v109 = *(void (**)(char *, uint64_t, swift *))(v92 + 32);
  uint64_t v42 = v111;
  uint64_t v43 = v105;
  uint64_t v100 = v30;
  unint64_t v101 = v40;
  uint64_t v44 = v109;
  while (1)
  {
    unsigned int v45 = &v37[*((int *)v40 + 12)];
    uint64_t v47 = (uint64_t)v113;
    uint64_t v46 = v114;
    v109(v113, (uint64_t)v37, v114);
    BOOL v48 = *(void (**)(char *, char *, uint64_t))(v42 + 32);
    v48(v112, v45, v43);
    char v49 = *(void **)v115;
    uint64_t v50 = *(void *)(v110 + 32);
    unint64_t v52 = __RawDictionaryStorage.find<A>(_:)(v47, (uint64_t)v46, v50);
    uint64_t v53 = v49[2];
    BOOL v54 = (v51 & 1) == 0;
    Swift::Int v55 = v53 + v54;
    if (__OFADD__(v53, v54))
    {
      __break(1u);
LABEL_19:
      __break(1u);
LABEL_20:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v114);
    }

    char v56 = v51;
    if (v49[3] >= v55)
    {
      if ((a2 & 1) == 0) {
        _NativeDictionary.copy()();
      }
    }

    else
    {
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v55, a2 & 1);
      unint64_t v57 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, (uint64_t)v114, v50);
      if ((v56 & 1) != (v58 & 1)) {
        goto LABEL_20;
      }
      unint64_t v52 = v57;
    }

    uint64_t v59 = *(void **)v115;
    if ((v56 & 1) != 0) {
      break;
    }
    BOOL v66 = v94;
    char v67 = v114;
    v44(v94, (uint64_t)v113, v114);
    uint64_t v68 = v97;
    uint64_t v43 = v105;
    v48(v97, v112, v105);
    v59[(v52 >> 6) + 8] |= 1LL << v52;
    v44((char *)(v59[6] + *(void *)(v41 + 72) * v52), (uint64_t)v66, v67);
    v48((char *)(v59[7] + *(void *)(v111 + 72) * v52), v68, v43);
    uint64_t v69 = v59[2];
    BOOL v70 = __OFADD__(v69, 1LL);
    uint64_t v71 = v69 + 1;
    if (v70) {
      goto LABEL_19;
    }
    v59[2] = v71;
    uint64_t v42 = v111;
LABEL_4:
    char v37 = v100;
    v103(v108, v104);
    a2 = 1;
    uint64_t v40 = v101;
    if (v102(v37, 1LL, v101) == 1) {
      goto LABEL_2;
    }
  }

  uint64_t v42 = v111;
  unint64_t v60 = *(void *)(v111 + 72) * v52;
  uint64_t v61 = v96;
  uint64_t v43 = v105;
  (*(void (**)(char *, unint64_t, uint64_t))(v111 + 16))(v96, v59[7] + v60, v105);
  uint64_t v62 = v95;
  unsigned int v63 = v112;
  uint64_t v64 = v106;
  v98(v61, v112);
  if (!v64)
  {
    char v106 = 0LL;
    uint64_t v65 = *(void (**)(char *, uint64_t))(v42 + 8);
    v65(v61, v43);
    v65(v63, v43);
    (*(void (**)(char *, swift *))(v41 + 8))(v113, v114);
    (*(void (**)(unint64_t, char *, uint64_t))(v42 + 40))( *(void *)(*(void *)v115 + 56LL) + v60,  v62,  v43);
    goto LABEL_4;
  }

  uint64_t v72 = *(void (**)(char *, uint64_t))(v42 + 8);
  v72(v61, v43);
  id v118 = v64;
  swift_errorRetain(v64);
  BOOL v73 = (char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
  if (swift_dynamicCast( v73,  (uint64_t *)&v118,  (swift *)v73,  (const char *)&type metadata for _MergeError,  0LL))
  {
    unint64_t v74 = specialized static String._createEmpty(withInitialCapacity:)(30LL);
    uint64_t v76 = v75;
    unint64_t v116 = v74;
    unint64_t v117 = v75;
    uint64_t v77 = HIBYTE(v75) & 0xF;
    if ((v75 & 0x2000000000000000LL) == 0) {
      uint64_t v77 = v74 & 0xFFFFFFFFFFFFLL;
    }
    if (v77 || (v74 & ~v75 & 0x2000000000000000LL) != 0)
    {
      if ((v75 & 0x2000000000000000LL) != 0
        && ((unint64_t)"ment" & 0x2000000000000000LL) != 0
        && (unint64_t v78 = specialized _SmallString.init(_:appending:)(v74, v75, 0xD00000000000001BLL, 0x80000001818BB2C0LL),
            (v80 & 1) == 0))
      {
        unint64_t v81 = v78;
        unint64_t v82 = v79;
        swift_bridgeObjectRelease(v76);
        unint64_t v116 = v81;
        unint64_t v117 = v82;
      }

      else
      {
        else {
          unint64_t v83 = 27LL;
        }
        _StringGuts.append(_:)(0xD00000000000001BLL, 0x80000001818BB2C0LL, 0LL, v83);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v75);
      unint64_t v116 = 0xD00000000000001BLL;
      unint64_t v117 = 0x80000001818BB2C0LL;
    }

    _print_unlocked<A, B>(_:_:)( (uint64_t)v113,  (uint64_t)&v116,  v114,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
    uint64_t v84 = v117;
    unint64_t v85 = HIBYTE(v117) & 0xF;
    if ((v117 & 0x2000000000000000LL) == 0) {
      unint64_t v85 = v116 & 0xFFFFFFFFFFFFLL;
    }
    if (v85 || (v116 & ~v117 & 0x2000000000000000LL) != 0)
    {
      if ((v117 & 0x2000000000000000LL) == 0
        || (unint64_t v88 = specialized _SmallString.init(_:appending:)(v116, v117, 0x27uLL, 0xE100000000000000LL), (v90 & 1) != 0))
      {
        _StringGuts.append(_:)(39LL, 0xE100000000000000LL, 0LL, 1LL);
        unint64_t v87 = v116;
        unint64_t v86 = v117;
      }

      else
      {
        unint64_t v87 = v88;
        unint64_t v86 = v89;
        swift_bridgeObjectRelease(v84);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v117);
      unint64_t v86 = 0xE100000000000000LL;
      unint64_t v87 = 39LL;
    }

    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)v87,  v86,  "Swift/NativeDictionary.swift",  28LL,  2,  0x30FuLL,  0);
  }

  v72(v63, v43);
  (*(void (**)(char *, swift *))(v41 + 8))(v113, v114);
  (*(void (**)(char *, unint64_t))(v93 + 8))(v107, v108);
  swift_errorRelease(v118);
}

unint64_t type metadata accessor for __BridgingBufferStorage(const char *a1)
{
  return type metadata accessor for __BridgingBufferStorage( a1,  (unint64_t *)&type metadata singleton initialization cache for __BridgingBufferStorage,  (unsigned int *)&nominal type descriptor for __BridgingBufferStorage);
}

uint64_t type metadata accessor for __CocoaDictionary.Index.Storage()
{
  return objc_opt_self();
}

void sub_1816FD194()
{
}

void sub_1816FD1A8()
{
}

void sub_1816FD1D0()
{
}

uint64_t partial apply for closure #1 in Dictionary.merge(_:uniquingKeysWith:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(v4 + 16);
  uint64_t v9 = *(void *)(v4 + 24);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 16LL))(a1, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16LL))(a2, a4, v9);
}

uint64_t partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)( a1,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 40),  *(void *)(v2 + 16),  *(void *)(v2 + 24),  a2);
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }

  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1LL << v6;
  unint64_t v8 = (unint64_t)((1LL << v6) + 63) >> 6;
  uint64_t v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, String>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16LL << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (16LL << v6), 7uLL);
  v10[1].i64[0] = 0LL;
  double v11 = (double)(1LL << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v10);
  if ((_BYTE)qword_18C487060) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v13);
  }
  else {
    v13->i64[0] = -1LL << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }

  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1LL << v6;
  unint64_t v8 = (unint64_t)((1LL << v6) + 63) >> 6;
  uint64_t v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, AnyHashable>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16LL << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (40LL << v6), 7uLL);
  v10[1].i64[0] = 0LL;
  double v11 = (double)(1LL << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v10);
  if ((_BYTE)qword_18C487060) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v13);
  }
  else {
    v13->i64[0] = -1LL << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }

  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1LL << v6;
  unint64_t v8 = (unint64_t)((1LL << v6) + 63) >> 6;
  uint64_t v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, String>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((40LL << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (16LL << v6), 7uLL);
  v10[1].i64[0] = 0LL;
  double v11 = (double)(1LL << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v10);
  if ((_BYTE)qword_18C487060) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 40 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v13);
  }
  else {
    v13->i64[0] = -1LL << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }

  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1LL << v6;
  unint64_t v8 = (unint64_t)((1LL << v6) + 63) >> 6;
  uint64_t v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, Int>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16LL << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (8LL << v6), 7uLL);
  v10[1].i64[0] = 0LL;
  double v11 = (double)(1LL << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v10);
  if ((_BYTE)qword_18C487060) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v8, v13);
  }
  else {
    v13->i64[0] = -1LL << v7;
  }
  return (uint64_t)v12;
}

uint64_t partial apply for closure #1 in Sequence<>.contains(_:)(uint64_t a1)
{
  return partial apply for closure #1 in Sequence<>.contains(_:)(a1) & 1;
}

{
  void *v1;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v4 = v1[2];
  BOOL v3 = (const char *)v1[3];
  unsigned __int8 v6 = v1[4];
  char v5 = v1[5];
  swift_getAssociatedTypeWitness( 0LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t type metadata accessor for Dictionary.Keys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Keys);
}

uint64_t type metadata accessor for _DictionaryAnyHashableBox(const char *a1, uint64_t a2)
{
  return swift_getCanonicalPrespecializedGenericMetadata( a1,  a2,  &nominal type descriptor for _DictionaryAnyHashableBox,  &flag for loading of canonical specialized generic type metadata for _DictionaryAnyHashableBox);
}

uint64_t type metadata accessor for Dictionary.Iterator._Variant( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for Dictionary.Iterator._Variant);
}

uint64_t type metadata accessor for _SwiftDeferredNSDictionary( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _SwiftDeferredNSDictionary);
}

uint64_t type metadata accessor for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DiscontiguousSlice);
}

uint64_t type metadata accessor for DiscontiguousSlice.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for DiscontiguousSlice.Index);
}

uint64_t type metadata accessor for RangeSet.Ranges(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for RangeSet.Ranges);
}

uint64_t partial apply for closure #1 in DiscontiguousSlice.distance(from:to:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return closure #1 in DiscontiguousSlice.distance(from:to:)(a1, a2, *(void *)(v3 + 16), *(void *)(v3 + 24), a3);
}

uint64_t partial apply for closure #1 in DiscontiguousSlice._index(of:)(uint64_t a1)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = (const char *)v1[3];
  uint64_t v5 = v1[4];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v9 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 32))( a1 + *(int *)(v9 + 36),  v5,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1;
}

uint64_t type metadata accessor for EnumeratedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for EnumeratedSequence);
}

uint64_t type metadata accessor for RangeSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for RangeSet);
}

uint64_t type metadata accessor for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyDropWhileSequence);
}

uint64_t type metadata accessor for LazyDropWhileSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for LazyDropWhileSequence.Iterator);
}

uint64_t specialized _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)( uint64_t a1, char **a2)
{
  unint64_t v5 = *(void *)a1;
  unsigned __int8 v6 = *(char ***)(a1 + 8);
  uint64_t v7 = *(Swift::UInt **)(a1 + 16);
  __int128 v8 = *(_OWORD *)(a1 + 24);
  __int128 v9 = *(_OWORD *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t offset = v2[4].offset;
  if (offset == v2[5].offset)
  {
    uint64_t result = 0LL;
  }

  else
  {
    __int128 v18 = v9;
    __int128 v19 = v8;
    uint64_t v13 = _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
    *a2 = v13;
    swift_unknownObjectRelease(v13);
    v14.uint64_t offset = _HashTable.occupiedBucket(after:)(v2[4]).offset;
    __int128 v9 = v18;
    __int128 v8 = v19;
    v2[4].uint64_t offset = v14.offset;
    uint64_t result = 1LL;
  }

  if (v5 <= 1) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = v5;
  }
  if (v5) {
    uint64_t v16 = v6;
  }
  else {
    uint64_t v16 = a2;
  }
  *(void *)a1 = v15;
  *(void *)(a1 + 8) = v16;
  uint64_t v17 = &_fastEnumerationStorageMutationsTarget;
  if (v5) {
    uint64_t v17 = v7;
  }
  *(void *)(a1 + 16) = v17;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 4swift_allocError((uint64_t)&type metadata for _MergeError, (uint64_t)&protocol witness table for _MergeError, 0LL, 0) = v9;
  *(void *)(a1 + 56) = v10;
  return result;
}

void specialized _SwiftDictionaryNSEnumerator.init(coder:)()
{
}

void specialized _SwiftDeferredNSDictionary.init(objects:forKeys:count:)()
{
  *(void *)(v0 + 16) = 0LL;
  *(void *)(v0 + 24) = 0LL;
  swift_release(v0);
  __break(1u);
}

uint64_t specialized _SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:using:)(uint64_t a1)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  double v2 = *(uint64_t **)(*v1 + 104LL);
  uint64_t v69 = *(v2 - 1);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  uint64_t v59 = (id *)((char *)&v59 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v63 = v4;
  uint64_t v5 = MEMORY[0x1895F8858](v3);
  uint64_t v68 = (id *)((char *)&v59 - v6);
  __int128 v8 = *(uint64_t **)(v7 + 96);
  uint64_t v9 = *(v8 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](v5);
  unint64_t v60 = (id *)((char *)&v59 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v64 = v11;
  uint64_t v12 = (const void *)MEMORY[0x1895F8858](v10);
  Swift::_HashTable::Bucket v14 = (id *)((char *)&v59 - v13);
  uint64_t v15 = (void (**)(void *, void *, char *, _BYTE *))_Block_copy(v12);
  uint64_t v16 = (char *)_SwiftDeferredNSDictionary.bridgeKeys()((uint64_t)v15);
  __int128 v19 = (char *)_SwiftDeferredNSDictionary.bridgeValues()((uint64_t)v16);
  char v73 = 0;
  BOOL v70 = v1;
  uint64_t v71 = (uint64_t)v16;
  uint64_t v20 = v1[4];
  uint64_t v21 = 1LL << *(_BYTE *)(v20 + 32);
  uint64_t v22 = v20 + 64;
  uint64_t v23 = -1LL;
  if (v21 < 64) {
    uint64_t v23 = ~(-1LL << v21);
  }
  unint64_t v24 = v23 & *(void *)(v20 + 64);
  char v67 = v16 + 40;
  int64_t v65 = (unint64_t)(v21 + 63) >> 6;
  BOOL v66 = v19 + 40;
  uint64_t v61 = v20;
  swift_retain_n(v20, 2LL, v17, v18);
  int64_t v28 = 0LL;
  uint64_t v62 = v22;
  if (!v24) {
    goto LABEL_7;
  }
LABEL_4:
  uint64_t v72 = (v24 - 1) & v24;
  unint64_t v29 = __clz(__rbit64(v24)) | (v28 << 6);
  if (v71)
  {
LABEL_5:
    unint64_t v30 = *(void **)&v67[8 * v29];
    swift_unknownObjectRetain(v30, v25, v26, v27);
    if (v19) {
      goto LABEL_20;
    }
LABEL_22:
    (*(void (**)(id *, unint64_t, uint64_t *))(v69 + 16))( v68,  *(void *)(v70[4] + 56LL) + *(void *)(v69 + 72) * v29,  v2);
    if (!_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
    {
      Swift::Int v55 = v59;
      (*(void (**)(id *, id *, uint64_t *))(v69 + 32))(v59, v68, v2);
      uint64_t v40 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v55, v2, v56, v57);
      goto LABEL_25;
    }

    if (v63 == 8)
    {
      uint64_t v47 = v15;
      BOOL v48 = v14;
      char v49 = v19;
      uint64_t v50 = v8;
      char v51 = v2;
      uint64_t v52 = v9;
      uint64_t v53 = v68;
      uint64_t v40 = (char *)*v68;
      swift_unknownObjectRetain(*v68, v44, v45, v46);
      BOOL v54 = v53;
      uint64_t v9 = v52;
      double v2 = v51;
      __int128 v8 = v50;
      __int128 v19 = v49;
      Swift::_HashTable::Bucket v14 = v48;
      uint64_t v15 = v47;
      uint64_t v22 = v62;
      (*(void (**)(id *, uint64_t *))(v69 + 8))(v54, v2);
      goto LABEL_25;
    }

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)( uint64_t result, uint64_t (*a2)(void))
{
  if (result <= 1) {
    uint64_t v2 = 1LL;
  }
  else {
    uint64_t v2 = result;
  }
  double v3 = ceil((double)v2 / 0.75);
  if ((~*(void *)&v3 & 0x7FF0000000000000LL) == 0) {
    goto LABEL_23;
  }
  if (v3 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v3 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v4 = __OFADD__(v2, 1LL);
  uint64_t v5 = v2 + 1;
  if (v4)
  {
    __break(1u);
    return result;
  }

  char v6 = 64 - __clz(v5 - 1);
  unsigned __int8 v7 = (unint64_t)v5 <= 2 ? 1 : v6;
  uint64_t v8 = 1LL << v7;
  unint64_t v9 = (unint64_t)((1LL << v7) + 63) >> 6;
  uint64_t v10 = a2(0LL);
  uint64_t v11 = (int64x2_t *)swift_allocObject(v10, (((8LL << v7) + 8 * v9 + 71) & 0xFFFFFFFFFFFFFFF8LL) + (8LL << v7), 7uLL);
  v11[1].i64[0] = 0LL;
  double v12 = (double)(1LL << v7) * 0.75;
  if ((~*(void *)&v12 & 0x7FF0000000000000LL) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  if (v12 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  if (v12 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  uint64_t v13 = (uint64_t *)v11;
  Swift::_HashTable::Bucket v14 = v11 + 4;
  uint64_t v15 = (uint64_t)&v11[4].i64[v9];
  v11[1].i64[1] = (uint64_t)v12;
  v11[2].i8[0] = v7;
  v11[2].i8[1] = 0;
  v11[2].i16[1] = 0;
  v11[2].i32[1] = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v11);
  if ((_BYTE)qword_18C487060) {
    uint64_t v16 = (uint64_t *)v7;
  }
  else {
    uint64_t v16 = v13;
  }
  v13[5] = (uint64_t)v16;
  v13[6] = v15;
  v13[7] = v15 + 8 * v8;
  if (v8 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v9, v14);
  }
  else {
    v14->i64[0] = -1LL << v8;
  }
  return (uint64_t)v13;
}

uint64_t specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)( uint64_t a1, void *a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = type metadata accessor for Range(0LL, a4, a5, a4);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  Swift::_HashTable::Bucket v14 = (char *)&v38 - v13;
  Swift::Int v15 = a2[2];
  if ((unint64_t)v15 < 2)
  {
    if (v15)
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v11 + 16))( v14,  (unint64_t)a2 + ((*(unsigned __int8 *)(v11 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80)),  v10);
      if (((*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 16))( a1 + *(int *)(v10 + 36),  v14,  a4,  a5) & 1) == 0)
      {
        char v32 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 40))( a1,  &v14[*(int *)(v10 + 36)],  a4,  a5);
        (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
        return v32 & 1;
      }

      (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    }

    return 0LL;
  }

  else
  {
    uint64_t v39 = &v38;
    v44[2] = a2;
    MEMORY[0x1895F8858](v12);
    uint64_t v34 = a4;
    uint64_t v35 = a5;
    LOBYTE(v36) = a3 & 1;
    uint64_t v37 = a1;
    uint64_t v18 = type metadata accessor for ContiguousArray(0LL, v10, v16, v17);
    uint64_t v38 = a1;
    uint64_t v19 = v18;
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v18, v20);
    Collection._partitioningIndex(where:)( (uint64_t (*)(char *))partial apply for closure #1 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:),  (uint64_t)(&v38 - 6),  v19,  WitnessTable,  (char *)&v45);
    uint64_t v22 = v45;
    if (v15 < v45) {
      goto LABEL_4;
    }
    ContiguousArray._checkIndex(_:)(v45);
    ContiguousArray._checkIndex(_:)(v15);
    uint64_t v39 = &v38;
    id v40 = a2;
    uint64_t v41 = (char *)a2 + ((*(unsigned __int8 *)(v11 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80));
    uint64_t v42 = v22;
    uint64_t v43 = (2 * v15) | 1;
    MEMORY[0x1895F8858](v23);
    uint64_t v34 = a4;
    uint64_t v35 = a5;
    LOBYTE(v36) = a3 & 1;
    uint64_t v37 = v38;
    uint64_t v26 = type metadata accessor for ArraySlice(0LL, v10, v24, v25);
    swift_retain(a2, v27, v28, v29);
    uint64_t v31 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v26, v30);
    Collection._partitioningIndex(where:)( (uint64_t (*)(char *))partial apply for closure #2 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:),  (uint64_t)(&v38 - 6),  v26,  v31,  (char *)v44);
    swift_unknownObjectRelease(v40);
    if (v44[0] < v22) {
LABEL_4:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return v22;
}

uint64_t specialized EmptyCollection.subscript.setter(uint64_t result, uint64_t a2)
{
  if (result | a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/EmptyCollection.swift",  27LL,  2,  0x76uLL,  0);
  }
  return result;
}

uint64_t type metadata accessor for __SharedStringStorage()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _IteratorBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _IteratorBox);
}

uint64_t type metadata accessor for _ClosureBasedIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _ClosureBasedIterator);
}

uint64_t type metadata accessor for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DropFirstSequence);
}

uint64_t type metadata accessor for _SequenceBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SequenceBox);
}

uint64_t type metadata accessor for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DropWhileSequence);
}

uint64_t type metadata accessor for PrefixSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for PrefixSequence);
}

uint64_t type metadata accessor for _BidirectionalCollectionBox( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _BidirectionalCollectionBox);
}

uint64_t type metadata accessor for _RandomAccessCollectionBox( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _RandomAccessCollectionBox);
}

uint64_t type metadata accessor for _ClosureBasedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _ClosureBasedSequence);
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error)( uint64_t a1, void *a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error)(a1, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t result = (*(uint64_t (**)(void))(v2 + 32))();
  if (v3) {
    *a2 = v3;
  }
  return result;
}

void *partial apply for specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)( uint64_t a1)
{
  return specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)( a1,  *(uint64_t (**)(uint64_t, uint64_t *))(v1 + 32));
}

uint64_t type metadata accessor for _AnyBidirectionalCollectionBox( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _AnyBidirectionalCollectionBox);
}

uint64_t type metadata accessor for _AnyRandomAccessCollectionBox( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _AnyRandomAccessCollectionBox);
}

uint64_t type metadata accessor for LazyFilterSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyFilterSequence);
}

uint64_t type metadata accessor for LazyFilterSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for LazyFilterSequence.Iterator);
}

void sub_1816FEA58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(v4 + 16);
  uint64_t v6 = type metadata accessor for LazyFilterSequence(0LL, v5, *(void *)(v4 + 24), a4);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = (*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80);
  unint64_t v9 = (*(void *)(v7 + 64) + v8 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = v4 + v8;
  (*(void (**)(unint64_t, uint64_t))(*(void *)(v5 - 8) + 8LL))(v4 + v8, v5);
  swift_release(*(void *)(v10 + *(int *)(v6 + 36) + 8));
  swift_release(*(void *)(v4 + v9 + 8));
  swift_deallocObject(v4);
}

uint64_t partial apply for closure #1 in LazyFilterSequence.filter(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(v4 + 16);
  uint64_t v7 = *(const char **)(v4 + 24);
  uint64_t v8 = *(void *)(type metadata accessor for LazyFilterSequence(0LL, v6, (uint64_t)v7, a4) - 8);
  unint64_t v9 = (*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);
  uint64_t v10 = v4 + ((*(void *)(v8 + 64) + v9 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  return closure #1 in LazyFilterSequence.filter(_:)( a1,  v4 + v9,  *(uint64_t (**)(char *))v10,  *(void *)(v10 + 8),  v6,  v7);
}

void sub_1816FEB74()
{
}

void sub_1816FEB88()
{
}

uint64_t partial apply for closure #2 in LazySequenceProtocol.compactMap<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return closure #2 in LazySequenceProtocol.compactMap<A>(_:)(a1, *(void *)(v2 + 24), *(void *)(v2 + 32), a2);
}

uint64_t type metadata accessor for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for FlattenSequence.Iterator);
}

uint64_t type metadata accessor for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for FlattenSequence<>.Index);
}

float specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(int a1, char a2, __int16 a3)
{
  LODWORD(result) = (a1 << 15) | ((a2 & 0x1F) << 10) | a3 & 0x3FF;
  return result;
}

float specialized Float.init(sign:exponentBitPattern:significandBitPattern:)( int a1, unsigned __int8 a2, int a3)
{
  LODWORD(result) = (a1 << 31) | (a2 << 23) | a3 & 0x7FFFFF;
  return result;
}

uint64_t type metadata accessor for _ConcreteHashableBox(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _ConcreteHashableBox,  &flag for loading of canonical specialized generic type metadata for _ConcreteHashableBox);
}

uint64_t outlined assign with take of AnyHashable(__int128 *a1, uint64_t a2)
{
  __int128 v4 = *a1;
  __int128 v5 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = v5;
  return a2;
}

uint64_t partial apply for closure #1 in FixedWidthInteger.init<A>(_:radix:)@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return closure #1 in FixedWidthInteger.init<A>(_:radix:)(a1, a2, v3[6], v3[2], v3[4], a3);
}

unint64_t lazy protocol witness table accessor for type UInt16 and conformance UInt16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type UInt and conformance UInt( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt, &type metadata for UInt, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt, &type metadata for UInt, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt, &type metadata for UInt, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type UInt64 and conformance UInt64( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt64, &type metadata for UInt64, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt64, &type metadata for UInt64, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt64, &type metadata for UInt64, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }

  return result;
}

uint64_t type metadata accessor for JoinedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for JoinedSequence);
}

uint64_t type metadata accessor for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for JoinedSequence.Iterator);
}

uint64_t specialized static _Int128./= infix(_:_:)(void *a1, Swift::_Int128 dividingBy)
{
  if (dividingBy.high == -1)
  {
    if (dividingBy.low == -1LL && a1[1] == 0x8000000000000000LL && *a1 == 0LL) {
LABEL_11:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in /=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x3CEuLL,  0);
  }

  else if (!dividingBy.high && !dividingBy.low)
  {
    goto LABEL_11;
  }

  *(_OWORD *)&uint64_t result = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(dividingBy);
  *a1 = result;
  a1[1] = v5;
  return result;
}

Swift::UInt64 specialized static _UInt128./ infix(_:_:)( Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, unint64_t a4)
{
  if (!(a4 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in /=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x1CEuLL,  0);
  }
  v10.low = a2;
  v10.high = (Swift::UInt64)&v7;
  specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, a1, a4, a3);
  return v9;
}

unint64_t specialized static _Int128.* infix(_:_:)( unint64_t a1, int64_t a2, unint64_t a3, unint64_t a4)
{
  if (a2)
  {
    if (!a4)
    {
      int64_t v5 = (unsigned __int128)-(__int128)__PAIR128__(v4, a1) >> 64;
      a4 = 0LL;
      if (a2 >= 0)
      {
        LODWORD(v5) = 0;
      }

      else
      {
        a1 = -(uint64_t)a1;
        a2 = v5;
        LODWORD(v5) = a3 != 0;
      }

      goto LABEL_19;
    }

    if (((a4 ^ a2) & 0x8000000000000000LL) == 0)
    {
      if (a2 < 0)
      {
LABEL_17:
        int64_t v5 = (a4 ^ a2) >> 63;
        BOOL v6 = a1 == 0;
        a1 = -(uint64_t)a1;
        a2 = -(a2 + !v6);
        if ((a4 & 0x8000000000000000LL) == 0) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }

      goto LABEL_9;
    }

    if (a2 < 0) {
      goto LABEL_17;
    }
    LODWORD(v5) = 1;
    if ((a4 & 0x8000000000000000LL) == 0) {
      goto LABEL_19;
    }
  }

  else
  {
    if ((a4 & 0x8000000000000000LL) == 0 || !a1)
    {
LABEL_9:
      LODWORD(v5) = 0;
      if ((a4 & 0x8000000000000000LL) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }

    a2 = 0LL;
    LODWORD(v5) = 1;
  }

uint64_t *specialized static _UInt128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  unint64_t v4 = v3 >> a2;
  uint64_t v5 = (v3 << -a2) | ((unint64_t)*result >> a2);
  if ((a2 & 0x7F) != 0)
  {
    v3 >>= a2;
    unint64_t v2 = v5;
  }

  if ((a2 & 0x7Fu) > 0x3FuLL)
  {
    unint64_t v3 = 0LL;
    unint64_t v2 = v4;
  }

  *uint64_t result = v2;
  result[1] = v3;
  return result;
}

uint64_t *specialized static _Int128.&<<= infix(_:_:)(uint64_t *result, char a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  if ((a2 & 0x7F) != 0)
  {
    uint64_t v3 = (v3 << a2) | ((unint64_t)*result >> -a2);
    uint64_t v2 = *result << a2;
  }

  if ((a2 & 0x7Fu) > 0x3FuLL)
  {
    uint64_t v3 = *result << a2;
    uint64_t v2 = 0LL;
  }

  *uint64_t result = v2;
  result[1] = v3;
  return result;
}

void specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v18[6] = a2;
  uint64_t v12 = type metadata accessor for Optional(0LL, a7, a3, a4);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v14 = *(void *)(a6 - 8);
  v18[3] = a6;
  v18[4] = v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  v18[5] = a7;
  MEMORY[0x1895F8858](v16);
  void v18[2] = (char *)v18 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  RawKeyPathComponent.value.getter(a3, a4, a5, (uint64_t *)v19);
  outlined init with take of KeyPathComponent(v19, (uint64_t)v20);
  __asm { BR              X11 }

uint64_t sub_1816FF234()
{
  return v0 + *(void *)(v1 - 144);
}

uint64_t type metadata accessor for RawKeyPathComponent.ProjectionResult( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for RawKeyPathComponent.ProjectionResult);
}

uint64_t type metadata accessor for KeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for KeyPath);
}

uint64_t type metadata accessor for PartialKeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for PartialKeyPath);
}

uint64_t type metadata accessor for ReferenceWritableKeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for ReferenceWritableKeyPath);
}

void partial apply for closure #1 in closure #1 in closure #1 in _appendingKeyPaths<A, B, C, D>(root:leaf:)( char *a1, void *a2)
{
  uint64_t v3 = *(void *)(v2 + 48);
  unint64_t v4 = *(uint64_t **)(v2 + 56);
  uint64_t v6 = *(void *)(v2 + 64);
  uint64_t v5 = *(void *)(v2 + 72);
  uint64_t v7 = *v4;
  if (*(uint64_t *)(v2 + 32) < 1)
  {
    uint64_t v8 = *v4;
  }

  else
  {
    if (!a1) {
      goto LABEL_31;
    }
    **(void **)(v2 + 4swift_allocError((uint64_t)&type metadata for _MergeError, (uint64_t)&protocol witness table for _MergeError, 0LL, 0) = &a1[v3];
    a1 = (char *)specialized UnsafeMutableRawBufferPointer.init<A>(_:)((uint64_t)a1, v3);
    uint64_t v8 = *v4;
  }

  into._position.value._rawValue = a1;
  into._end.value._rawValue = a2;
  unsigned __int8 v9 = (*(uint64_t (**)(void))(v8 + 160))();
  if (__OFSUB__(v3, 8LL))
  {
    __break(1u);
LABEL_31:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  if (*(_BYTE *)(v6 + 16) == 1) {
    char v10 = *(_BYTE *)(v5 + 16);
  }
  else {
    char v10 = 0;
  }
  int v11 = v9;
  uint64_t v12 = specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)( v3 - 8,  v10,  *(_BYTE *)(v6 + 17) & 1u | (v9 == 2));
  Swift::UnsafeMutableRawBufferPointer v13 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes( v12,  0LL,  (uint64_t)v13._position.value._rawValue,  (uint64_t)v13._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  char v14 = *(_BYTE *)(v5 + 17);
  int v16 = KeyPathBuffer.next()();
  if (v15)
  {
    uint64_t v17 = v15;
    do
    {
      if (v16 < 0) {
        char v18 = v14 ^ 1;
      }
      else {
        char v18 = 0;
      }
      RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v18);
      Swift::UnsafeMutableRawBufferPointer v19 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8LL, 8LL);
      if (!v19._position.value._rawValue
        || (char *)v19._end.value._rawValue - (char *)v19._position.value._rawValue <= 7)
      {
LABEL_29:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes out of bounds",  54LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1BDuLL,  0);
      }

      *(void *)v19._position.value._rawValue = v17;
      int v16 = KeyPathBuffer.next()();
      uint64_t v17 = v20;
    }

    while (v20);
  }

  if (v11 == 2) {
    char v21 = 1;
  }
  else {
    char v21 = v14;
  }
  if ((v21 & 1) != 0) {
    char v22 = v14 ^ 1;
  }
  else {
    char v22 = v16 < 0;
  }
  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v22);
  uint64_t v23 = *(void *)(v7 + 144);
  Swift::UnsafeMutableRawBufferPointer v24 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8LL, 8LL);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes( v23,  0LL,  (uint64_t)v24._position.value._rawValue,  (uint64_t)v24._end.value._rawValue);
  while (1)
  {
    int v25 = KeyPathBuffer.next()();
    uint64_t v27 = v26;
    RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v25 < 0);
    if (!v27) {
      break;
    }
    Swift::UnsafeMutableRawBufferPointer v28 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8LL, 8LL);
    *(void *)v28._position.value._rawValue = v27;
  }

uint64_t type metadata accessor for WritableKeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for WritableKeyPath);
}

unint64_t partial apply for closure #1 in _swift_getKeyPath(pattern:arguments:)( _DWORD *a1, _BYTE *a2)
{
  uint64_t v3 = *(void *)(v2 + 16);
  unint64_t result = _instantiateKeyPathBuffer(_:_:_:_:)(*(void *)(v2 + 24), a1, a2, *(void **)(v2 + 32), *(void **)(v2 + 40));
  *(_DWORD *)uint64_t v3 = result;
  *(_BYTE *)(v3 + 4) = BYTE4(result) & 1;
  return result;
}

void partial apply for closure #2 in _rerootKeyPath<A>(_:to:)(void *a1, void *a2)
{
  unint64_t v3 = *(void *)(v2 + 16);
  char v4 = *(_BYTE *)(v2 + 24);
  char v5 = *(_BYTE *)(v2 + 25);
  uint64_t v6 = *(void *)(v2 + 32);
  into._position.value._rawValue = a1;
  into._end.value._rawValue = a2;
  uint64_t v7 = specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)(v3, v4, v5);
  Swift::UnsafeMutableRawBufferPointer v8 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes( v7,  0LL,  (uint64_t)v8._position.value._rawValue,  (uint64_t)v8._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  if ((((_BYTE)v6 + 24) & 3) != 0) {
LABEL_32:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  uint64_t v9 = v6 + 32 + (*(_DWORD *)(v6 + 24) & 0xFFFFFF);
  uint64_t v25 = v6 + 32;
  uint64_t v26 = v9;
  while (1)
  {
    char v10 = (int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5( v25,  v26);
    if (!v10) {
      goto LABEL_35;
    }
    unint64_t v12 = v11 - (void)v10 - 4;
    if (__OFSUB__(v11 - (void)v10, 4LL))
    {
      __break(1u);
      goto LABEL_32;
    }

    if ((v12 & 0x8000000000000000LL) != 0) {
      goto LABEL_30;
    }
    Swift::UnsafeMutableRawBufferPointer v13 = v10 + 1;
    int v14 = *v10;
    int v15 = HIBYTE(*v10) & 0x7F;
    if (v15 != 1)
    {
      if (v15 == 2)
      {
        if ((v14 & 0x400000) != 0) {
          unint64_t v16 = 28LL;
        }
        else {
          unint64_t v16 = 20LL;
        }
        if ((v14 & 0x80000) != 0)
        {
          if ((v14 & 0x400000) != 0) {
            uint64_t v17 = 6LL;
          }
          else {
            uint64_t v17 = 4LL;
          }
          uint64_t v18 = (uint64_t)&v10[v17 + 2];
          if ((v18 & 7) != 0) {
            goto LABEL_32;
          }
          unint64_t v19 = v16 + 16;
          uint64_t v20 = *(void *)v18;
          BOOL v21 = __OFADD__(v19, v20);
          unint64_t v16 = v19 + v20;
          if (v21)
          {
            __break(1u);
LABEL_34:
            __break(1u);
LABEL_35:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
          }

          if ((v14 & 0x10) != 0)
          {
            BOOL v21 = __OFADD__(v16, 8LL);
            v16 += 8LL;
            if (v21) {
              goto LABEL_34;
            }
          }

          if ((v16 & 0x8000000000000000LL) != 0) {
            goto LABEL_30;
          }
        }

        goto LABEL_22;
      }

      if (v15 != 3)
      {
        unint64_t v16 = 0LL;
        uint64_t v22 = (uint64_t)(v10 + 1);
        goto LABEL_25;
      }
    }

    unint64_t v16 = 4LL * ((~v14 & 0x7FFFFF) == 0);
LABEL_22:
    if (v12 < v16) {
LABEL_30:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
    uint64_t v22 = (uint64_t)v13 + v16;
LABEL_25:
    uint64_t v25 = v22;
    uint64_t v26 = (uint64_t)v13 + v12;
    if (v12 == v16) {
      break;
    }
    uint64_t v23 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v25, 1LL);
    if (!v23) {
      goto LABEL_35;
    }
    uint64_t v24 = *v23;
    RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v14 < 0);
    if (!v24) {
      return;
    }
  }

  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v14 < 0);
}

uint64_t type metadata accessor for KeyValuePairs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for KeyValuePairs);
}

uint64_t partial apply for closure #1 in _StringGuts.withCString<A>(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 24))();
}

uint64_t partial apply for closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)( void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)( a1,  *(void *)(v4 + 16),  *(void *)(v4 + 24),  a4);
}

uint64_t type metadata accessor for ManagedBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ManagedBuffer);
}

uint64_t type metadata accessor for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for LazyMapSequence.Iterator);
}

void sub_1816FFB94()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = type metadata accessor for LazyMapSequence(0LL, v1, v0[3], v0[5]);
  uint64_t v3 = *(unsigned __int8 *)(*(void *)(v2 - 8) + 80LL);
  uint64_t v4 = (v3 + 64) & ~v3;
  swift_release(v0[7]);
  char v5 = (char *)v0 + v4;
  (*(void (**)(char *, uint64_t))(*(void *)(v1 - 8) + 8LL))(v5, v1);
  swift_release(*(void *)&v5[*(int *)(v2 + 44) + 8]);
  swift_deallocObject((uint64_t)v0);
}

uint64_t partial apply for closure #1 in LazyMapSequence.map<A>(_:)(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(v1 + 24);
  return closure #1 in LazyMapSequence.map<A>(_:)( a1,  *(void (**)(char *))(v1 + 48),  *(void *)(v1 + 56),  v1 + ((v5 + 64) & ~v5),  v3,  v4);
}

void sub_1816FFCB0()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = type metadata accessor for LazyMapSequence(0LL, v1, v0[3], *(void *)(v0[5] + 8LL));
  uint64_t v3 = *(unsigned __int8 *)(*(void *)(v2 - 8) + 80LL);
  uint64_t v4 = (v3 + 64) & ~v3;
  swift_release(v0[7]);
  uint64_t v5 = (char *)v0 + v4;
  (*(void (**)(char *, uint64_t))(*(void *)(v1 - 8) + 8LL))(v5, v1);
  swift_release(*(void *)&v5[*(int *)(v2 + 44) + 8]);
  swift_deallocObject((uint64_t)v0);
}

uint64_t partial apply for closure #1 in LazyMapSequence<>.map<A>(_:)(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(v1 + 24);
  uint64_t v5 = *(unsigned __int8 *)(*(void *)(type metadata accessor for LazyMapSequence( 0LL,  v3,  v4,  *(void *)(*(void *)(v1 + 40) + 8LL))
                                      - 8)
                          + 80LL);
  return closure #1 in LazyMapSequence<>.map<A>(_:)( a1,  *(void (**)(char *))(v1 + 48),  *(void *)(v1 + 56),  v1 + ((v5 + 64) & ~v5),  v3,  v4);
}

uint64_t specialized RawKeyPathComponent.Header.init(computedWithIDKind:mutating:settable:hasArguments:instantiatedFromExternalWithArguments:)( char a1, char a2, char a3, char a4, char a5)
{
  if ((a2 & 1) == 0)
  {
    if ((a3 & 1) == 0)
    {
      int v7 = 0;
      if ((a4 & 1) != 0) {
        int v5 = 0x80000;
      }
      else {
        int v5 = 0;
      }
      if ((a5 & 1) == 0) {
        goto LABEL_24;
      }
      goto LABEL_22;
    }

    if ((a4 & 1) == 0)
    {
      int v5 = 0x400000;
      if ((a5 & 1) != 0) {
        goto LABEL_22;
      }
LABEL_23:
      int v7 = 0;
      goto LABEL_24;
    }

    int v5 = 4718592;
LABEL_14:
    if ((a5 & 1) != 0) {
      goto LABEL_22;
    }
    goto LABEL_23;
  }

  if ((a3 & 1) != 0) {
    int v5 = 13107200;
  }
  else {
    int v5 = 8912896;
  }
  if ((a3 & 1) != 0) {
    int v6 = 12582912;
  }
  else {
    int v6 = 0x800000;
  }
  if ((a4 & 1) != 0) {
    goto LABEL_14;
  }
  int v5 = v6;
  if ((a5 & 1) == 0) {
    goto LABEL_23;
  }
LABEL_22:
  int v7 = 16;
LABEL_24:
  int v8 = v5 | v7;
  if (a1)
  {
    int v9 = v8 | 0x200000;
    v8 |= 0x100000u;
    if (a1 == 1) {
      int v8 = v9;
    }
  }

  return v8 | 0x2000000u;
}

uint64_t specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)( unint64_t a1, char a2, char a3)
{
  if ((a1 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  if (HIDWORD(a1)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  if ((a2 & 1) == 0)
  {
    if ((a3 & 1) != 0) {
      goto LABEL_5;
    }
LABEL_7:
    int v3 = 0;
    return a1 | v3;
  }

  LODWORD(a1) = a1 | 0x80000000;
  if ((a3 & 1) == 0) {
    goto LABEL_7;
  }
LABEL_5:
  int v3 = 0x40000000;
  return a1 | v3;
}

uint64_t specialized GetKeyPathClassAndInstanceSizeFromPattern.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)( uint64_t result, uint64_t a2, uint64_t (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  if (a2)
  {
    if ((result & 1) != 0) {
      goto LABEL_6;
    }
    char v11 = 2;
  }

  else
  {
    char v11 = 0;
  }

  *(_BYTE *)(v8 + 8) = v11;
LABEL_6:
  uint64_t v12 = *(void *)v8 + 4LL;
  if (__OFADD__(*(void *)v8, 4LL))
  {
    __break(1u);
    goto LABEL_36;
  }

  *(void *)uint64_t v8 = v12;
  BOOL v13 = __OFADD__(v12, 7LL);
  uint64_t v14 = v12 + 7;
  if (v13)
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }

  unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFF8LL;
  BOOL v13 = __OFADD__(v15, 16LL);
  unint64_t v16 = v15 + 16;
  if (v13)
  {
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }

  *(void *)uint64_t v8 = v16;
  if (!a2) {
    goto LABEL_12;
  }
  BOOL v13 = __OFADD__(v16, 8LL);
  v16 += 8LL;
  if (v13)
  {
LABEL_38:
    __break(1u);
    goto LABEL_39;
  }

  *(void *)uint64_t v8 = v16;
LABEL_12:
  if (a3)
  {
    unint64_t v9 = v16 + 16;
    LOBYTE(v16) = __OFADD__(v16, 16LL);
    if ((a8 & 1) != 0) {
      goto LABEL_31;
    }
    if ((v16 & 1) == 0)
    {
      unint64_t result = a3(*(void *)(v8 + 40));
      unint64_t v17 = v9 + result;
      if (!__OFADD__(v9, result))
      {
        *(void *)uint64_t v8 = v17;
        BOOL v13 = __OFADD__(v17, 7LL);
        unint64_t v18 = v17 + 7;
        if (!v13)
        {
          unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFF8LL;
          BOOL v13 = __OFADD__(v19, 8LL);
          unint64_t v20 = v19 + 8;
          if (!v13)
          {
            if ((unint64_t)(a7 - 0x1000000000000000LL) >> 61 == 7)
            {
              BOOL v13 = __OFADD__(v20, 8 * a7);
              unint64_t v16 = v20 + 8 * a7;
              if (!v13) {
                goto LABEL_33;
              }
              __break(1u);
              goto LABEL_25;
            }

uint64_t specialized MutableCollection<>.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = type metadata accessor for Slice(0LL, a3, *(void *)(a4 + 8), a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v9, v10);
  return _writeBackMutableSlice<A, B>(_:bounds:slice:)(v4, a2, a1, a3, v9, a4, WitnessTable);
}

uint64_t partial apply for closure #1 in MutableCollection.moveSubranges(_:to:)(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(const char **)(*(void *)(v1 + 24) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v7);
  return RangeSet.Ranges._contains(_:)(a1, v8) & 1;
}

BOOL partial apply for closure #2 in MutableCollection.moveSubranges(_:to:)(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(const char **)(*(void *)(v1 + 24) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v7);
  return (RangeSet.Ranges._contains(_:)(a1, v8) & 1) == 0;
}

uint64_t type metadata accessor for _SetStorage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _SetStorage,  &flag for loading of canonical specialized generic type metadata for _SetStorage);
}

uint64_t type metadata accessor for _NativeSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _NativeSet);
}

uint64_t type metadata accessor for __CocoaSet.Index.Storage()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _NewtypeWrapperAnyHashableBox(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for _NewtypeWrapperAnyHashableBox);
}

unint64_t *outlined copy of (@escaping @callee_guaranteed (@guaranteed String) -> ())?( unint64_t *result, unint64_t *a2, uint64_t a3, char *a4)
{
  if (result) {
    return swift_retain(a2, (uint64_t)a2, a3, a4);
  }
  return result;
}

uint64_t outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?( uint64_t result, uint64_t a2)
{
  if (result) {
    return swift_release(a2);
  }
  return result;
}

uint64_t type metadata accessor for LazyPrefixWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence);
}

uint64_t type metadata accessor for LazyPrefixWhileSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence.Iterator);
}

uint64_t type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence<>._IndexRepresentation);
}

uint64_t type metadata accessor for LazyPrefixWhileSequence<>.Index( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence<>.Index);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<AnyHashable>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int64>()
{
  return objc_opt_self();
}

void specialized MutableCollection.subscript.setter()
{
}

Swift::UInt64 specialized Collection.subscript.getter(unint64_t a1, unint64_t a2)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v4 = a1;
  }
  uint64_t v5 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v5 = 11LL;
  }
  v6._Swift::UInt64 rawBits = v5 | (v4 << 16);
  v7._Swift::UInt64 rawBits = 15LL;
  Swift::UInt64 result = _StringGuts.validateScalarRange(_:)(v7, v6, a1, a2);
  if (result < 0x10000) {
    result |= 3uLL;
  }
  return result;
}

void specialized _SliceBuffer.subscript.setter()
{
}

uint64_t specialized Slice<>.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a4;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a3, &v12);
  uint64_t v10 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a3, v9);
  return _writeBackMutableSlice<A, B>(_:bounds:slice:)(v4, a2, a1, a3, a3, WitnessTable, v10);
}

uint64_t specialized MutableCollection.subscript.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(const char **)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v12,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RangeExpression,  (uint64_t)&associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v16 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  MEMORY[0x1895F8858](v16);
  unint64_t v18 = (char *)&v20 - v17;
  (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(a6 + 24))(v6, a3, v12, a4, a6);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 40))(a1, v18, a3, a5);
}

uint64_t specialized MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v65 = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v64 = (char *)&v54 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  unint64_t v60 = (char *)&v54 - v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v61 = *(void *)(v13 - 8);
  uint64_t v62 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v59 = (char *)&v54 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  char v58 = (char *)&v54 - v17;
  unint64_t v18 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  BOOL v66 = (char *)&v54 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v68 = (char *)&v54 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v69 = (char *)&v54 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  char v67 = (char *)&v54 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v29 = (char *)&v54 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v31 = (char *)&v54 - v30;
  uint64_t v33 = type metadata accessor for PartialRangeFrom(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v32);
  uint64_t v56 = *(void *)(v33 - 8);
  uint64_t v57 = v33;
  MEMORY[0x1895F8858](v33);
  uint64_t v35 = (char *)&v54 - v34;
  int v36 = *(void (**)(uint64_t, uint64_t))(v6 + 64);
  uint64_t v70 = a2;
  uint64_t v71 = v3;
  v36(a2, v6);
  uint64_t v37 = (void (*)(char *, char *, unint64_t))v18[2];
  v37(v29, v31, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v29,  v29,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range cannot have an unordered lower bound.",  43LL,  2,  "Swift/Range.swift",  17LL,  2,  0x34FuLL,  0);
  }
  uint64_t v55 = a3;
  uint64_t v38 = (void (*)(char *, unint64_t))v18[1];
  v38(v29, AssociatedTypeWitness);
  uint64_t v39 = (void (*)(char *, char *, unint64_t))v18[4];
  v39(v35, v31, AssociatedTypeWitness);
  id v40 = v67;
  v37(v67, v35, AssociatedTypeWitness);
  uint64_t v41 = v69;
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v70, v6);
  uint64_t v42 = v68;
  v37(v68, v40, AssociatedTypeWitness);
  uint64_t v43 = v66;
  v37(v66, v41, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v42,  v43,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v38(v43, AssociatedTypeWitness);
  v38(v68, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v56 + 8))(v35, v57);
  uint64_t v44 = TupleTypeMetadata2;
  Swift::Int v45 = v60;
  uint64_t v46 = &v60[*((int *)TupleTypeMetadata2 + 12)];
  v39(v60, v67, AssociatedTypeWitness);
  v39(v46, v69, AssociatedTypeWitness);
  uint64_t v47 = v64;
  BOOL v48 = &v64[*((int *)v44 + 12)];
  v37(v64, v45, AssociatedTypeWitness);
  v37(v48, v46, AssociatedTypeWitness);
  char v49 = v59;
  v39(v59, v47, AssociatedTypeWitness);
  v38(v48, AssociatedTypeWitness);
  uint64_t v50 = &v47[*((int *)v44 + 12)];
  v39(v47, v45, AssociatedTypeWitness);
  v39(v50, v46, AssociatedTypeWitness);
  uint64_t v51 = v62;
  v39(&v49[*(int *)(v62 + 36)], v50, AssociatedTypeWitness);
  v38(v47, AssociatedTypeWitness);
  uint64_t v52 = v58;
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v58, v49, v51);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v55 + 40))(v65, v52, v70);
}

uint64_t type metadata accessor for Repeated(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Repeated,  flag for loading of canonical specialized generic type metadata for Repeated);
}

uint64_t partial apply for closure #1 in RangeSet.Ranges.init(_unorderedRanges:)()
{
  return (*(uint64_t (**)(void))(*(void *)(v0 + 24) + 16LL))() & 1;
}

uint64_t partial apply for closure #1 in RangeSet.Ranges._contains(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = v4[2];
  uint64_t v7 = v4[3];
  uint64_t v8 = v4[4];
  uint64_t v9 = type metadata accessor for Range(0LL, v6, v7, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 40))(a1 + *(int *)(v9 + 36), v8, v6, v7) & 1;
}

uint64_t type metadata accessor for _Pair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _Pair);
}

uint64_t partial apply for closure #1 in RangeSet.isSubset(of:)(uint64_t a1)
{
  return closure #1 in RangeSet.isSubset(of:)(a1, v1[4], v1[2], v1[3]) & 1;
}

uint64_t type metadata accessor for Zip2Sequence(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Zip2Sequence);
}

uint64_t type metadata accessor for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Zip2Sequence.Iterator);
}

void partial apply for closure #1 in MutableCollection<>.sort(by:)(uint64_t a1)
{
}

uint64_t type metadata accessor for Result(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Result);
}

uint64_t type metadata accessor for ReversedCollection.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for ReversedCollection.Iterator);
}

uint64_t type metadata accessor for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for ReversedCollection.Index);
}

uint64_t type metadata accessor for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for PrefixSequence.Iterator);
}

uint64_t type metadata accessor for DropWhileSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for DropWhileSequence.Iterator);
}

unint64_t specialized RangeReplaceableCollection.init(repeating:count:)(int a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Repetition count should be non-negative",  39LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x28uLL,  0);
  }
  uint64_t v2 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s8RepeatedVys7UnicodeO6ScalarVG_Tg506_sSS17gh42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n( a2,  a1);
  uint64_t v3 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v2, 1LL);
  unint64_t v5 = v4;
  swift_bridgeObjectRelease((uint64_t)v2);
  if (!v5) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  }
  unint64_t v6 = specialized static String.+ infix(_:_:)(0LL, 0xE000000000000000LL, v3, v5);
  swift_bridgeObjectRelease(v5);
  return v6;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 15LL;
  }
  uint64_t v2 = a2;
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Repetition count should be non-negative",  39LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x28uLL,  0);
  }
  do
  {
    v3._Swift::UInt64 rawBits = 7LL;
    v4._Swift::UInt64 rawBits = 7LL;
    specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v3, v4);
    --v2;
  }

  while (v2);
  return 15LL;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)( unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  if (a3)
  {
    if (a3 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Repetition count should be non-negative",  39LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x28uLL,  0);
    }
    specialized String.append<A>(contentsOf:)(a3, a1, a2, a4);
    swift_bridgeObjectRelease(a2);
  }

  else
  {
    swift_bridgeObjectRelease(a2);
  }

  return 15LL;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(char a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Repetition count should be non-negative",  39LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x28uLL,  0);
  }
  LODWORD(result) = 0;
  int v4 = (a1 + 1);
  do
  {
    if (BYTE3(result)) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
    }
    uint64_t result = (v4 << (-(__clz(result) & 0x18) & 0x18)) | result;
    --a2;
  }

  while (a2);
  return result;
}

__objc2_class **specialized Set.init(_nonEmptyArrayLiteral:)(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a1;
  uint64_t v7 = *(a2 - 1);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  char v58 = (char *)&v48 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v62 = (char *)&v48 - v11;
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v49 = v15;
  MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  Swift::Int v18 = Array._getCount()();
  if (v18)
  {
    Swift::Int v20 = v18;
    uint64_t v21 = type metadata accessor for _SetStorage(0LL, (uint64_t)a2, a3, v19);
    uint64_t v22 = v20;
    uint64_t v3 = v21;
    uint64_t v23 = (__objc2_class **)static _SetStorage.allocate(capacity:)(v22);
  }

  else
  {
    uint64_t v23 = &_swiftEmptySetSingleton;
  }

  Swift::Int v55 = Array._getCount()();
  if (v55)
  {
    unint64_t v24 = 0LL;
    uint64_t v53 = a3;
    unint64_t v54 = v6 & 0xC000000000000001LL;
    unint64_t v60 = v23;
    uint64_t v61 = v23 + 7;
    uint64_t v50 = v14;
    uint64_t v51 = v6;
    uint64_t v52 = v17;
    while (1)
    {
      BOOL v25 = v54 == 0;
      char v26 = v25 | ~_swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v24, v26 & 1);
      if ((v26 & 1) != 0)
      {
        unint64_t v27 = v6
        uint64_t v59 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
        v59(v14, v27, a2);
      }

      else
      {
        id v46 = _ArrayBuffer._getElementSlowPath(_:)(v24, v6, a2);
        uint64_t v3 = (uint64_t)v46;
        if (v49 != 8) {
          goto LABEL_24;
        }
        id v63 = v46;
        uint64_t v59 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
        v59(v14, (unint64_t)&v63, a2);
        swift_unknownObjectRelease((id)v3);
      }

      uint64_t v28 = *(void (**)(char *, char *, uint64_t *))(v7 + 32);
      v28(v17, v14, a2);
      BOOL v29 = __OFADD__(v24++, 1LL);
      if (v29) {
        break;
      }
      uint64_t v57 = v28;
      v28(v62, v17, a2);
      uint64_t v30 = (*(uint64_t (**)(__objc2_class *, uint64_t *, uint64_t))(a3 + 32))(v23[5], a2, a3);
      uint64_t v31 = -1LL << *((_BYTE *)v23 + 32);
      unint64_t v32 = v30 & ~v31;
      uint64_t v3 = v32 >> 6;
      uint64_t v33 = 1LL << v32;
      if (((1LL << v32) & (unint64_t)v61[v32 >> 6]) != 0)
      {
        unint64_t v56 = v24;
        uint64_t v34 = ~v31;
        uint64_t v35 = *(void *)(a3 + 8);
        int v36 = *(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v35 + 8);
        uint64_t v37 = v7;
        uint64_t v38 = *(void *)(v7 + 72);
        while (1)
        {
          uint64_t v39 = v58;
          v59(v58, (unint64_t)v60[6] + v38 * v32, a2);
          uint64_t v3 = v36(v39, v62, a2, v35);
          id v40 = *(void (**)(char *, uint64_t *))(v37 + 8);
          v40(v39, a2);
          if ((v3 & 1) != 0) {
            break;
          }
          unint64_t v32 = (v32 + 1) & v34;
          uint64_t v3 = v32 >> 6;
          uint64_t v33 = 1LL << v32;
          if (((unint64_t)v61[v32 >> 6] & (1LL << v32)) == 0)
          {
            uint64_t v7 = v37;
            uint64_t v14 = v50;
            uint64_t v41 = v51;
            unint64_t v24 = v56;
            goto LABEL_17;
          }
        }

        v40(v62, a2);
        a3 = v53;
        uint64_t v7 = v37;
        uint64_t v14 = v50;
        uint64_t v6 = v51;
        uint64_t v23 = v60;
        unint64_t v24 = v56;
      }

      else
      {
        uint64_t v41 = v6;
LABEL_17:
        uint64_t v43 = v57;
        uint64_t v42 = v58;
        v57(v58, v62, a2);
        v61[v3] = (__objc2_class *)((unint64_t)v61[v3] | v33);
        uint64_t v23 = v60;
        v43((char *)v60[6] + *(void *)(v7 + 72) * v32, v42, a2);
        uint64_t v44 = v23[2];
        BOOL v29 = __OFADD__(v44, 1LL);
        Swift::Int v45 = (__objc2_class *)((char *)&v44->isa + 1);
        if (v29) {
          goto LABEL_23;
        }
        v23[2] = v45;
        uint64_t v6 = v41;
        a3 = v53;
      }

      uint64_t v17 = v52;
      if (v24 == v55) {
        return v23;
      }
    }

    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    swift_unknownObjectRelease((id)v3);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }

  return v23;
}

uint64_t type metadata accessor for _SetAnyHashableBox(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for _SetAnyHashableBox,  &flag for loading of canonical specialized generic type metadata for _SetAnyHashableBox);
}

uint64_t type metadata accessor for Set(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Set,  &flag for loading of canonical specialized generic type metadata for Set);
}

uint64_t type metadata accessor for Set.Iterator._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Set.Iterator._Variant);
}

void sub_181701514()
{
}

uint64_t type metadata accessor for Set.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Set.Index);
}

uint64_t outlined init with take of AnyHashable?(uint64_t a1, uint64_t a2)
{
  return initializeWithTake for ClosedRange<>.Index(a2, a1, &unk_189B88AB0);
}

uint64_t type metadata accessor for _SwiftDeferredNSSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SwiftDeferredNSSet);
}

uint64_t partial apply for implicit closure #1 in Sequence<>.sorted()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(v2 + 32);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(v5 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v2 + 24),  *(void *)(v2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

uint64_t partial apply for implicit closure #1 in MutableCollection<>.sort()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = v2[5];
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(v5 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(v2[3] + 8) + 8LL),  v2[2],  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

uint64_t type metadata accessor for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideTo);
}

uint64_t type metadata accessor for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideThroughIterator);
}

uint64_t type metadata accessor for StrideThrough(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideThrough);
}

uint64_t partial apply for closure #1 in String.init<A, B>(decoding:as:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return closure #1 in String.init<A, B>(decoding:as:)(a1, a2, *(void *)(v3 + 16), *(void *)(v3 + 32), a3);
}

uint64_t type metadata accessor for Unicode.ParseResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Unicode.ParseResult);
}

unint64_t partial apply for closure #1 in String.init<A, B>(validating:as:)@<X0>( uint8x16_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = static String._validate<A>(_:as:)( a1,  a2,  *(ValueMetadata **)(v3 + 16),  *(void *)(v3 + 16),  *(const char **)(v3 + 32));
  *a3 = result;
  a3[1] = v6;
  return result;
}

{
  uint64_t v3;
  return closure #1 in String.init<A, B>(validating:as:)( a1,  a2,  *(ValueMetadata **)(v3 + 16),  *(const char **)(v3 + 32),  a3);
}

uint64_t type metadata accessor for UnsafeBufferPointer.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for UnsafeBufferPointer.Iterator);
}

void partial apply for closure #1 in String._slowWithCString<A, B>(encodedAs:_:)( unsigned __int8 *a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t specialized _SwiftSetNSEnumerator.countByEnumerating(with:objects:count:)(uint64_t a1, char **a2)
{
  unint64_t v5 = *(void *)a1;
  unint64_t v6 = *(char ***)(a1 + 8);
  uint64_t v7 = *(Swift::UInt **)(a1 + 16);
  __int128 v8 = *(_OWORD *)(a1 + 24);
  __int128 v9 = *(_OWORD *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t offset = v2[4].offset;
  if (offset == v2[5].offset)
  {
    uint64_t result = 0LL;
  }

  else
  {
    __int128 v18 = v9;
    __int128 v19 = v8;
    uint64_t v13 = _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
    *a2 = v13;
    swift_unknownObjectRelease(v13);
    v14.uint64_t offset = _HashTable.occupiedBucket(after:)(v2[4]).offset;
    __int128 v9 = v18;
    __int128 v8 = v19;
    v2[4].uint64_t offset = v14.offset;
    uint64_t result = 1LL;
  }

  if (v5 <= 1) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = v5;
  }
  if (v5) {
    uint64_t v16 = v6;
  }
  else {
    uint64_t v16 = a2;
  }
  *(void *)a1 = v15;
  *(void *)(a1 + 8) = v16;
  uint64_t v17 = &_fastEnumerationStorageMutationsTarget;
  if (v5) {
    uint64_t v17 = v7;
  }
  *(void *)(a1 + 16) = v17;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v9;
  *(void *)(a1 + 56) = v10;
  return result;
}

void specialized _SwiftSetNSEnumerator.init(coder:)()
{
}

void specialized _SwiftDeferredNSSet.init(objects:count:)()
{
  *(void *)(v0 + 16) = 0LL;
  swift_release(v0);
  __break(1u);
}

void specialized _SetStorage.init(objects:count:)()
{
}

uint64_t specialized _SetStorage.copy(with:)()
{
  return v0;
}

uint64_t specialized Substring.init<A>(_:)(uint64_t result, uint64_t a2, uint64_t a3, char *a4)
{
  if (&full type metadata for [Character] == &full type metadata for String)
  {
    __break(1u);
  }

  else if (&full type metadata for [Character] != &full type metadata for Substring)
  {
    uint64_t v4 = result;
    specialized String.append<A>(contentsOf:)(result, a2, a3, a4);
    swift_bridgeObjectRelease(v4);
    return 15LL;
  }

  __break(1u);
  return result;
}

unint64_t specialized _SmallString.init(taggedCocoa:)(void *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  __int128 v8 = xmmword_1817FFDF0;
  uint64_t v3 = _NSStringCopyBytes(_:encoding:into:)(a1, a2, (uint64_t)&v8, (unint64_t)&v8 | 0xF);
  char v5 = v4;
  swift_unknownObjectRelease(a1);
  if ((v5 & 1) != 0) {
    return 0LL;
  }
  if (v3 < 1)
  {
    if (v3) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SmallString.swift",  23LL,  2,  0x109uLL,  0);
    }
    return 0LL;
  }

  else
  {
    char v6 = 8;
    if (v3 < 8) {
      char v6 = v3;
    }
    return v8 & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v6) & 0x38));
  }

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( int64_t a1, uint64_t (*a2)(int64_t, int64_t))
{
  int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v5 + 16) = v6;
  *(void *)(v5 + 24) = 0x3000000000000000LL;
  if (v6 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v7 = *(void *)(v5 + 24) & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  *(_BYTE *)(v5 + 32 + v7) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v8 = a2(v5 + 32, a1);
  if (v2)
  {
    swift_release(v5);
  }

  else
  {
    *(void *)(v5 + 24) = v8 | 0x3000000000000000LL;
    *(_BYTE *)(v5 + 32 + (v8 & 0xFFFFFFFFFFFFLL)) = 0;
  }

  return v5;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( int64_t a1, uint64_t (*a2)(int64_t, int64_t))
{
  char v4 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( a1,  a2);
  if (v3) {
    return v2;
  }
  int64_t v5 = v4;
  uint64_t v6 = v4[3];
  Swift::Int v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  uint64_t v8 = (char *)(v4 + 4);
  uint64_t v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0LL) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    uint64_t v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0LL) + 32)
    {
      uint64_t v10 = *(void *)v9;
      uint64_t v11 = *((void *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080LL) != 0) {
        goto LABEL_22;
      }
    }
  }

  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8LL])
  {
    if ((*(void *)v9 & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    v9 += 8;
  }

  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v9 += 4;
  }

  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      char v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }

    goto LABEL_22;
  }

  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( unint64_t a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int64_t v9 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v9 + 16) = v10;
  *(void *)(v9 + 24) = 0x3000000000000000LL;
  if (v10 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v11 = *(void *)(v9 + 24) & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  *(_BYTE *)(v9 + 32 + v11) = 0;
  if ((a1 & 0x8000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  if (a3 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a3)
  {
    unint64_t v12 = a3 - 1;
    if (a3 - 1 >= a1) {
      unint64_t v12 = a1;
    }
    unint64_t v13 = v12 + 1;
    if (v13 > 0x10 && (unint64_t)(v9 - (void)a2 + 32) >= 0x10)
    {
      uint64_t v15 = v13 & 0xF;
      if ((v13 & 0xF) == 0) {
        uint64_t v15 = 16LL;
      }
      unint64_t v14 = v13 - v15;
      v16.i64[0] = -1LL;
      v16.i64[1] = -1LL;
      v17.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
      v17.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
      uint64x2_t v18 = (uint64x2_t)vdupq_n_s64(0x3FFE000000000uLL);
      v19.i64[0] = 0x2020202020202020LL;
      v19.i64[1] = 0x2020202020202020LL;
      unint64_t v20 = v14;
      uint64_t v21 = (int8x16_t *)(v9 + 32);
      unsigned int v22 = a2;
      do
      {
        int8x16_t v23 = *v22++;
        uint8x16_t v24 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v23, v16), 1uLL), v17);
        uint16x8_t v25 = vmovl_u8(*(uint8x8_t *)v24.i8);
        uint32x4_t v26 = vmovl_u16(*(uint16x4_t *)v25.i8);
        v27.i64[0] = v26.u32[0];
        v27.i64[1] = v26.u32[1];
        int64x2_t v28 = v27;
        uint32x4_t v29 = vmovl_high_u16(v25);
        uint16x8_t v30 = vmovl_high_u8(v24);
        v27.i64[0] = v29.u32[0];
        v27.i64[1] = v29.u32[1];
        int64x2_t v31 = v27;
        uint32x4_t v32 = vmovl_u16(*(uint16x4_t *)v30.i8);
        v27.i64[0] = v32.u32[0];
        v27.i64[1] = v32.u32[1];
        int64x2_t v33 = v27;
        int8x16_t v34 = (int8x16_t)vmovl_high_u16(v30);
        v27.i64[0] = v34.u32[0];
        v27.i64[1] = v34.u32[1];
        v41.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, (uint32x4_t)v34));
        v41.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, v32));
        v41.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v27));
        v41.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v33));
        v42.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, v29));
        v42.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, v26));
        v42.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v31));
        v42.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v28));
        v34.i64[0] = vqtbl4q_s8(v42, (int8x16_t)xmmword_1817FFE00).u64[0];
        v34.i64[1] = vqtbl4q_s8(v41, (int8x16_t)xmmword_1817FFE00).u64[0];
        *v21++ = vaddq_s8(vandq_s8(v34, v19), v23);
        v20 -= 16LL;
      }

      while (v20);
    }

    else
    {
      unint64_t v14 = 0LL;
    }

    unint64_t v35 = a1 - v14;
    uint64_t v36 = &a2->u8[v14];
    uint64_t v37 = (_BYTE *)(v14 + v9 + 32);
    uint64_t v38 = a3 - v14;
    do
    {
      if (!v35) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
      }
      int v39 = *v36++;
      *v37++ = ((0x3FFE000000000uLL >> ((v39 - 1) >> 1)) & 0x20) + v39;
      --v35;
      --v38;
    }

    while (v38);
  }

  *(void *)(v9 + 24) = a3 | 0x3000000000000000LL;
  *(_BYTE *)(v9 + 32 + (a3 & 0xFFFFFFFFFFFFLL)) = 0;
  return v9;
}

{
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  int8x16_t v17;
  uint64x2_t v18;
  int8x16_t v19;
  unint64_t v20;
  int8x16_t *v21;
  int8x16_t *v22;
  int8x16_t v23;
  uint8x16_t v24;
  uint16x8_t v25;
  uint32x4_t v26;
  int64x2_t v27;
  int64x2_t v28;
  uint32x4_t v29;
  uint16x8_t v30;
  int64x2_t v31;
  uint32x4_t v32;
  int64x2_t v33;
  int8x16_t v34;
  unint64_t v35;
  unsigned __int8 *v36;
  _BYTE *v37;
  uint64_t v38;
  int v39;
  int8x16x4_t v41;
  int8x16x4_t v42;
  int64_t v9 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v9 + 16) = v10;
  *(void *)(v9 + 24) = 0x3000000000000000LL;
  if (v10 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v11 = *(void *)(v9 + 24) & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  *(_BYTE *)(v9 + 32 + v11) = 0;
  if ((a1 & 0x8000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  if (a3 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a3)
  {
    unint64_t v12 = a3 - 1;
    if (a3 - 1 >= a1) {
      unint64_t v12 = a1;
    }
    unint64_t v13 = v12 + 1;
    if (v13 > 0x10 && (unint64_t)(v9 - (void)a2 + 32) >= 0x10)
    {
      uint64_t v15 = v13 & 0xF;
      if ((v13 & 0xF) == 0) {
        uint64_t v15 = 16LL;
      }
      unint64_t v14 = v13 - v15;
      v16.i64[0] = -1LL;
      v16.i64[1] = -1LL;
      v17.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
      v17.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
      uint64x2_t v18 = (uint64x2_t)vdupq_n_s64(0x1FFF000000000000uLL);
      v19.i64[0] = 0x2020202020202020LL;
      v19.i64[1] = 0x2020202020202020LL;
      unint64_t v20 = v14;
      uint64_t v21 = (int8x16_t *)(v9 + 32);
      unsigned int v22 = a2;
      do
      {
        int8x16_t v23 = *v22++;
        uint8x16_t v24 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v23, v16), 1uLL), v17);
        uint16x8_t v25 = vmovl_u8(*(uint8x8_t *)v24.i8);
        uint32x4_t v26 = vmovl_u16(*(uint16x4_t *)v25.i8);
        v27.i64[0] = v26.u32[0];
        v27.i64[1] = v26.u32[1];
        int64x2_t v28 = v27;
        uint32x4_t v29 = vmovl_high_u16(v25);
        uint16x8_t v30 = vmovl_high_u8(v24);
        v27.i64[0] = v29.u32[0];
        v27.i64[1] = v29.u32[1];
        int64x2_t v31 = v27;
        uint32x4_t v32 = vmovl_u16(*(uint16x4_t *)v30.i8);
        v27.i64[0] = v32.u32[0];
        v27.i64[1] = v32.u32[1];
        int64x2_t v33 = v27;
        int8x16_t v34 = (int8x16_t)vmovl_high_u16(v30);
        v27.i64[0] = v34.u32[0];
        v27.i64[1] = v34.u32[1];
        v41.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, (uint32x4_t)v34));
        v41.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, v32));
        v41.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v27));
        v41.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v33));
        v42.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, v29));
        v42.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0LL, v26));
        v42.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v31));
        v42.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v28));
        v34.i64[0] = vqtbl4q_s8(v42, (int8x16_t)xmmword_1817FFE00).u64[0];
        v34.i64[1] = vqtbl4q_s8(v41, (int8x16_t)xmmword_1817FFE00).u64[0];
        *v21++ = vsubq_s8(v23, vandq_s8(vshlq_n_s8(v34, 5uLL), v19));
        v20 -= 16LL;
      }

      while (v20);
    }

    else
    {
      unint64_t v14 = 0LL;
    }

    unint64_t v35 = a1 - v14;
    uint64_t v36 = &a2->u8[v14];
    uint64_t v37 = (_BYTE *)(v14 + v9 + 32);
    uint64_t v38 = a3 - v14;
    do
    {
      if (!v35) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
      }
      int v39 = *v36++;
      *v37++ = v39 - 32 * ((0x1FFF000000000000uLL >> ((v39 - 1) >> 1)) & 1);
      --v35;
      --v38;
    }

    while (v38);
  }

  *(void *)(v9 + 24) = a3 | 0x3000000000000000LL;
  *(_BYTE *)(v9 + 32 + (a3 & 0xFFFFFFFFFFFFLL)) = 0;
  return v9;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void))
{
  int64_t v9 = (void *)a6();
  if (v7) {
    return v6;
  }
  uint64_t v10 = v9;
  uint64_t v11 = v9[3];
  Swift::Int v12 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v11 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  unint64_t v13 = (char *)(v9 + 4);
  unint64_t v14 = (char *)(v9 + 4);
  if ((v11 & 0xFFFFFFFFFFF0LL) != 0)
  {
    if (((v9[5] | v9[4]) & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    unint64_t v14 = (char *)(v9 + 6);
    while (v14 < (char *)v9 + (v11 & 0xFFFFFFFFFFF0LL) + 32)
    {
      uint64_t v15 = *(void *)v14;
      uint64_t v16 = *((void *)v14 + 1);
      v14 += 16;
      if (((v16 | v15) & 0x8080808080808080LL) != 0) {
        goto LABEL_22;
      }
    }
  }

  if (v14 < &v13[v11 & 0xFFFFFFFFFFF8LL])
  {
    if ((*(void *)v14 & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    v14 += 8;
  }

  if (v14 < &v13[v11 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v14 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v14 += 4;
  }

  if (v14 >= &v13[v11 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v14 >= &v13[v12] || (*v14 & 0x80000000) == 0)
    {
LABEL_20:
      char v17 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v12, v17 & 1);
      return v10[3];
    }

    goto LABEL_22;
  }

  if ((*(_WORD *)v14 & 0x8080) == 0)
  {
    v14 += 2;
    goto LABEL_18;
  }

uint64_t type metadata accessor for __StringStorage()
{
  return objc_opt_self();
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( int64_t a1, unsigned int a2)
{
  int64_t v4 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v4 + 16) = v5;
  *(void *)(v4 + 24) = 0x3000000000000000LL;
  if (v5 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v6 = *(void *)(v4 + 24) & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  *(_BYTE *)(v4 + 32 + v6) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t ScalarName = _swift_stdlib_getScalarName(a2, v4 + 32, a1);
  *(void *)(v4 + 24) = ScalarName | 0x3000000000000000LL;
  *(_BYTE *)(v4 + 32 + (ScalarName & 0xFFFFFFFFFFFFLL)) = 0;
  return v4;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( int64_t a1, unsigned int a2)
{
  int64_t v4 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)( a1,  a2);
  if (v3) {
    return v2;
  }
  uint64_t v5 = v4;
  uint64_t v6 = v4[3];
  Swift::Int v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  uint64_t v8 = (char *)(v4 + 4);
  int64_t v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0LL) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    int64_t v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0LL) + 32)
    {
      uint64_t v10 = *(void *)v9;
      uint64_t v11 = *((void *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080LL) != 0) {
        goto LABEL_22;
      }
    }
  }

  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8LL])
  {
    if ((*(void *)v9 & 0x8080808080808080LL) != 0) {
      goto LABEL_22;
    }
    v9 += 8;
  }

  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v9 += 4;
  }

  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      char v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }

    goto LABEL_22;
  }

  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }

uint64_t specialized static StringProtocol.== infix<A>(_:_:)( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6 = a2 >> 16;
  if ((a6 & 0x2000000000000000LL) != 0) {
    uint64_t v7 = HIBYTE(a6) & 0xF;
  }
  else {
    uint64_t v7 = a5 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a1 >> 16;
  if (a3 == a5 && a4 == a6 && !v8 && v6 == v7) {
    return 1LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a3, a4, v8, v6, a5, a6, 0LL, v7, 0) & 1;
  }
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v7 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a4 >> 16;
  uint64_t v9 = a3 >> 16;
  if (a1 == a5 && a2 == a6 && !v9 && v7 == v8) {
    return 1LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0LL, v7, a5, a6, v9, v8, 0) & 1;
  }
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v6 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1 == a3 && a2 == a4 && v5 == v6) {
    return 1LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0LL, v5, a3, a4, 0LL, v6, 0) & 1;
  }
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6 = a2 >> 16;
  if ((a6 & 0x2000000000000000LL) != 0) {
    uint64_t v7 = HIBYTE(a6) & 0xF;
  }
  else {
    uint64_t v7 = a5 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a1 >> 16;
  if (a3 == a5 && a4 == a6 && !v8 && v6 == v7) {
    return 0LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a3, a4, v8, v6, a5, a6, 0LL, v7, 1) & 1;
  }
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v7 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a4 >> 16;
  uint64_t v9 = a3 >> 16;
  if (a1 == a5 && a2 == a6 && !v9 && v7 == v8) {
    return 0LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0LL, v7, a5, a6, v9, v8, 1) & 1;
  }
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v6 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1 == a3 && a2 == a4 && v5 == v6) {
    return 0LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0LL, v5, a3, a4, 0LL, v6, 1) & 1;
  }
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF16.ForwardParser,  &type metadata for Unicode.UTF16.ForwardParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF16.ForwardParser,  &type metadata for Unicode.UTF16.ForwardParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser);
  }

  return result;
}

uint64_t type metadata accessor for ReversedCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ReversedCollection);
}

Swift::UInt64 specialized String.Index.init(_:within:)( Swift::String::Index a1, unint64_t a2, uint64_t a3)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v5 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v5) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  Swift::Bool v6 = String._isValidIndex(_:)((Swift::String::Index)rawBits);
  swift_bridgeObjectRelease(a3);
  if (v6) {
    return rawBits | 3;
  }
  else {
    return 0LL;
  }
}

Swift::UInt64 specialized String.Index.init(_:within:)( Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= rawBits >> 16)
  {
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      v9._Swift::UInt64 rawBits = rawBits;
      BOOL v10 = String.Index._foreignIsWithin(_:)(a2, a3, v9);
      swift_bridgeObjectRelease(a3);
      if (v10) {
        return rawBits;
      }
    }

    else
    {
      swift_bridgeObjectRelease(a3);
      if ((rawBits & 0xC000) == 0) {
        return rawBits;
      }
    }
  }

  else
  {
    swift_bridgeObjectRelease(a3);
  }

  return 0LL;
}

{
  Swift::UInt64 rawBits;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  BOOL v9;
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= rawBits >> 16)
  {
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      uint64_t v8 = specialized String.Index._foreignIsWithin(_:)(rawBits);
    }

    else
    {
      if ((rawBits & 0xC000) != 0)
      {
        swift_bridgeObjectRelease(a3);
        return rawBits;
      }

      uint64_t v8 = _StringGuts.isOnUnicodeScalarBoundary(_:)((Swift::String::Index)rawBits);
    }

    Swift::String::Index v9 = v8;
    swift_bridgeObjectRelease(a3);
    if (v9) {
      return rawBits;
    }
  }

  else
  {
    swift_bridgeObjectRelease(a3);
  }

  return 0LL;
}

{
  Swift::UInt64 rawBits;
  uint64_t v6;
  unint64_t v7;
  Swift::Bool v8;
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 < rawBits >> 16)
  {
    swift_bridgeObjectRelease(a3);
    return 0LL;
  }

  uint64_t v8 = _StringGuts.isOnUnicodeScalarBoundary(_:)((Swift::String::Index)rawBits);
  swift_bridgeObjectRelease(a3);
  if (!v8) {
    return 0LL;
  }
  return rawBits;
}

BOOL specialized String.Index._foreignIsWithin(_:)(__int16 a1)
{
  return (a1 & 0xC000) == 0LL;
}

double specialized _StringGuts.decidePostFormatBackward(between:and:with:)( char a1, unsigned __int8 a2, uint64_t a3, __n128 a4)
{
  *(_BYTE *)(a3 + 57) = 18;
  switch(a1)
  {
    case 0:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
          goto LABEL_25;
        case 9u:
        case 0xBu:
        case 0xFu:
          goto LABEL_10;
        default:
          return a4.n128_f64[0];
      }

      return a4.n128_f64[0];
    case 2:
      if (a2 == 7)
      {
        uint64_t v4 = *(void *)(a3 + 40);
        a4 = (__n128)xmmword_181800070;
        goto LABEL_36;
      }

      return a4.n128_f64[0];
    case 5:
      if (a2 <= 0xDu && (((1 << a2) & 0x2181) != 0 || a2 == 5)) {
        goto LABEL_25;
      }
      return a4.n128_f64[0];
    case 7:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
        case 0xFu:
          goto LABEL_25;
        case 2u:
          if ((*(_BYTE *)(a3 + 32) & 1) != 0) {
            return a4.n128_f64[0];
          }
          if ((*(_BYTE *)(a3 + 16) & 1) != 0 && *(_OWORD *)a3 >= 2uLL) {
            goto LABEL_53;
          }
          *(void *)(a3 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(void *)(a3 + 24);
          break;
        case 9u:
        case 0xBu:
LABEL_10:
          if ((*(_BYTE *)(a3 + 32) & 1) != 0) {
            return a4.n128_f64[0];
          }
          if ((*(_BYTE *)(a3 + 16) & 1) != 0 && *(_OWORD *)a3 == 0LL) {
            goto LABEL_53;
          }
          *(void *)(a3 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(void *)(a3 + 24);
          break;
        default:
          return a4.n128_f64[0];
      }

      return a4.n128_f64[0];
    case 8:
      if (a2 == 5 || a2 == 8) {
        goto LABEL_25;
      }
      return a4.n128_f64[0];
    case 9:
      int v5 = a2;
      if (a2) {
        goto LABEL_33;
      }
      goto LABEL_34;
    case 10:
      int v6 = a2;
      goto LABEL_22;
    case 11:
      int v6 = a2;
      if (!a2 || a2 == 7) {
        goto LABEL_34;
      }
LABEL_22:
      if (v6 == 13) {
        goto LABEL_35;
      }
      return a4.n128_f64[0];
    case 13:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
          goto LABEL_25;
        case 0xAu:
        case 0xBu:
        case 0xFu:
          if ((*(_BYTE *)(a3 + 32) & 1) == 0)
          {
            if ((*(_BYTE *)(a3 + 16) & 1) != 0 && !(*(void *)a3 ^ 1LL | *(void *)(a3 + 8)))
            {
LABEL_53:
              a4.n128_u16[0] = 0;
              a4.n128_u8[2] = 0;
              a4.n128_u8[3] = 0;
              a4.n128_u8[4] = 0;
              a4.n128_u8[5] = 0;
              a4.n128_u8[6] = 0;
              a4.n128_u8[7] = 0;
              *(_OWORD *)a3 = 0u;
              *(_OWORD *)(a3 + 16) = 0u;
              *(_BYTE *)(a3 + 32) = 1;
              *(void *)(a3 + 48) = 0LL;
              *(_BYTE *)(a3 + 56) = 1;
            }

            else
            {
              *(void *)(a3 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(void *)(a3 + 24);
            }
          }

          break;
        default:
          return a4.n128_f64[0];
      }

      return a4.n128_f64[0];
    case 14:
      if (a2 == 14)
      {
        uint64_t v7 = *(void *)(a3 + 40);
        if ((*(_BYTE *)(a3 + 32) & 1) != 0)
        {
          uint64_t v8 = 0LL;
          uint64_t v9 = *(void *)(a3 + 48);
          if (*(_BYTE *)(a3 + 56)) {
            uint64_t v9 = *(void *)(a3 + 40);
          }
        }

        else if ((*(_BYTE *)(a3 + 16) & 1) != 0)
        {
          uint64_t v8 = 0LL;
          uint64_t v9 = *(void *)(a3 + 40);
        }

        else
        {
          uint64_t v8 = *(void *)a3 + 1LL;
          if (__OFADD__(*(void *)a3, 1LL))
          {
            __break(1u);
            JUMPOUT(0x181704594LL);
          }

          uint64_t v9 = *(void *)(a3 + 24);
          if (*(void *)a3) {
            uint64_t v7 = *(void *)(a3 + 8);
          }
        }

        *(void *)a3 = v8;
        *(void *)(a3 + 8) = v7;
        *(void *)(a3 + 16) = 0LL;
        *(void *)(a3 + 24) = v9;
        *(_BYTE *)(a3 + 32) = 0;
LABEL_25:
        *(void *)(a3 + 48) = 0LL;
        *(_BYTE *)(a3 + 56) = 1;
      }

      return a4.n128_f64[0];
    case 15:
      int v5 = a2;
      if (!a2) {
        goto LABEL_34;
      }
      if (a2 == 13)
      {
LABEL_35:
        uint64_t v4 = *(void *)(a3 + 40);
        a4 = (__n128)xmmword_1817FFD30;
LABEL_36:
        *(__n128 *)a3 = a4;
      }

      else
      {
LABEL_33:
        if (v5 != 7) {
          return a4.n128_f64[0];
        }
LABEL_34:
        uint64_t v4 = *(void *)(a3 + 40);
        *(void *)a3 = 0LL;
        *(void *)(a3 + 8) = 0LL;
      }

      *(void *)(a3 + 16) = 1LL;
      *(void *)(a3 + 24) = v4;
      *(_BYTE *)(a3 + 32) = 0;
      return a4.n128_f64[0];
    default:
      return a4.n128_f64[0];
  }

uint64_t specialized _StringGuts.previousWordBoundary(endingAt:previousScalar:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v7 & 1) != 0)
  {
    swift_bridgeObjectRelease(a3);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringWordBreaking.swift",  30LL,  2,  0xB5uLL,  0);
  }

  unsigned int v8 = v5;
  uint64_t v9 = v6;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  char v29 = 1;
  uint64_t v30 = v6;
  uint64_t v31 = 0LL;
  char v32 = 1;
  __int16 v33 = 18;
  unsigned int v10 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v6, a2, a3);
  if ((v13 & 1) != 0)
  {
LABEL_68:
    if ((v29 & 1) != 0) {
      return v30;
    }
    uint64_t result = *((void *)&v28 + 1);
    if ((v28 & 1) == 0)
    {
      uint64_t v26 = *((void *)&v27 + 1);
      if ((v27 & 1) != 0) {
        uint64_t v26 = *((void *)&v28 + 1);
      }
      if ((void)v27) {
        return v26;
      }
      else {
        return v30;
      }
    }

    return result;
  }

  uint64_t v14 = v11;
  while (1)
  {
    unsigned int v19 = v8;
    unsigned int v8 = v10;
    if (v10 == 13 && v19 == 10) {
      goto LABEL_9;
    }
    unsigned int v20 = 12;
    if (v10 - 10 >= 4 && v10 != 133 && v10 - 8234 < 0xFFFFFFFE)
    {
      switch(v10)
      {
        case 0x22u:
          unsigned int v20 = 2;
          break;
        case 0x200Du:
          unsigned int v20 = 17;
          break;
        case 0x27u:
          unsigned int v20 = 15;
          break;
        default:
          if (v10 - 127488 > 0xFFFFFFE5)
          {
            unsigned int v20 = 14;
          }

          else
          {
            unsigned int WordBreakProperty = _swift_stdlib_getWordBreakProperty(v10);
            if (WordBreakProperty >= 0xC) {
              unsigned int v20 = 1;
            }
            else {
              unsigned int v20 = byte_18180BE40[(char)WordBreakProperty];
            }
          }

          break;
      }
    }

    unsigned int v21 = 12;
    if (v19 - 10 >= 4 && v19 != 133)
    {
      if (v19 - 8234 >= 0xFFFFFFFE)
      {
        unsigned int v21 = 12;
      }

      else
      {
        switch(v19)
        {
          case 0x22u:
            unsigned int v21 = 2;
            break;
          case 0x200Du:
            unsigned int v21 = 17;
            break;
          case 0x27u:
            unsigned int v21 = 15;
            break;
          default:
            if (v19 - 127488 > 0xFFFFFFE5)
            {
              unsigned int v21 = 14;
            }

            else
            {
              unsigned int v24 = _swift_stdlib_getWordBreakProperty(v19);
              if (v24 >= 0xC) {
                unsigned int v21 = 1;
              }
              else {
                unsigned int v21 = byte_18180BE40[(char)v24];
              }
            }

            break;
        }
      }
    }

    if (v20 == 1)
    {
      if (v21 > 0x11) {
        goto LABEL_5;
      }
      if (((1 << v21) & 0x20048) == 0)
      {
        if (((1 << v21) & 0x1002) != 0) {
          goto LABEL_67;
        }
        goto LABEL_5;
      }

uint64_t specialized _StringGuts.previousWordBoundary(endingAt:previousScalar:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 1)
  {
    swift_bridgeObjectRelease(a3);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringWordBreaking.swift",  30LL,  2,  0xB5uLL,  0);
  }

  uint64_t v5 = a1;
  uint64_t v6 = a4 - 1;
  do
    int v7 = *(_BYTE *)(v6 + v5--) & 0xC0;
  while (v7 == 128);
  unsigned int v8 = _decodeScalar(_:startingAt:)(a4, a2, v5);
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  char v27 = 1;
  uint64_t v28 = v5;
  uint64_t v29 = 0LL;
  char v30 = 1;
  __int16 v31 = 18;
  if (v5 < 1)
  {
LABEL_77:
    if ((v27 & 1) != 0) {
      return v28;
    }
    uint64_t result = *((void *)&v26 + 1);
    if ((v26 & 1) == 0)
    {
      uint64_t v24 = *((void *)&v25 + 1);
      if ((v25 & 1) != 0) {
        uint64_t v24 = *((void *)&v26 + 1);
      }
      if ((void)v25) {
        return v24;
      }
      else {
        return v28;
      }
    }

    return result;
  }

  unsigned int v10 = v8;
  while (1)
  {
    unsigned int v13 = v10;
    uint64_t v14 = v5;
    do
      int v15 = *(_BYTE *)(v6 + v5--) & 0xC0;
    while (v15 == 128);
    unsigned int v16 = _decodeScalar(_:startingAt:)(a4, v9, v5);
    unsigned int v10 = v16;
    if (v16 == 13 && v13 == 10) {
      goto LABEL_11;
    }
    unsigned int v18 = 12;
    if (v16 - 10 >= 4 && v16 != 133 && v16 - 8234 < 0xFFFFFFFE)
    {
      switch(v16)
      {
        case 0x22u:
          unsigned int v18 = 2;
          break;
        case 0x200Du:
          unsigned int v18 = 17;
          break;
        case 0x27u:
          unsigned int v18 = 15;
          break;
        default:
          if (v16 - 127488 > 0xFFFFFFE5)
          {
            unsigned int v18 = 14;
          }

          else
          {
            unsigned int WordBreakProperty = _swift_stdlib_getWordBreakProperty(v16);
            if (WordBreakProperty >= 0xC) {
              unsigned int v18 = 1;
            }
            else {
              unsigned int v18 = byte_18180BE40[(char)WordBreakProperty];
            }
          }

          break;
      }
    }

    unsigned int v20 = 12;
    if (v13 - 10 < 4 || v13 == 133) {
      goto LABEL_49;
    }
    if (v13 - 8234 >= 0xFFFFFFFE)
    {
      unsigned int v20 = 12;
      if (v18 == 1) {
        goto LABEL_72;
      }
      goto LABEL_50;
    }

    switch(v13)
    {
      case 0x22u:
        unsigned int v20 = 2;
        if (v18 == 1) {
          goto LABEL_72;
        }
        goto LABEL_50;
      case 0x200Du:
        unsigned int v20 = 17;
        if (v18 == 1) {
          goto LABEL_72;
        }
        goto LABEL_50;
      case 0x27u:
        unsigned int v20 = 15;
        if (v18 == 1) {
          goto LABEL_72;
        }
        goto LABEL_50;
    }

    if (v13 - 127488 > 0xFFFFFFE5)
    {
      unsigned int v20 = 14;
LABEL_49:
      if (v18 == 1) {
        goto LABEL_72;
      }
      goto LABEL_50;
    }

    unsigned int v21 = _swift_stdlib_getWordBreakProperty(v13);
    if (v21 >= 0xC)
    {
      unsigned int v20 = 1;
      if (v18 == 1)
      {
LABEL_72:
        if (v20 > 0x11) {
          goto LABEL_7;
        }
        if (((1 << v20) & 0x20048) == 0)
        {
          if (((1 << v20) & 0x1002) != 0) {
            goto LABEL_76;
          }
          goto LABEL_7;
        }

uint64_t specialized _StringGuts.nextWordBoundary(startingAt:nextScalar:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 <= a1)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringWordBreaking.swift",  30LL,  2,  0x9AuLL,  0);
  }

  unsigned int v8 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(a1, a4, a5);
  if ((v10 & 1) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringWordBreaking.swift",  30LL,  2,  0x9CuLL,  0);
  }

  unsigned int v11 = v8;
  uint64_t v12 = v9;
  unsigned int v13 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(v9, a4, a5);
  if ((v15 & 1) != 0) {
    return v12;
  }
  uint64_t v16 = v14;
  int v36 = 0;
  uint64_t v17 = 0LL;
  unint64_t v37 = 0LL;
  char v38 = 0;
  int v18 = 18;
  char v19 = 1;
  do
  {
    unsigned int v23 = v11;
    unsigned int v11 = v13;
    if (v23 == 13 && v13 == 10) {
      goto LABEL_9;
    }
    if (v23 - 10 < 4 || v23 == 133 || v23 - 8234 >= 0xFFFFFFFE) {
      break;
    }
    switch(v23)
    {
      case 0x200Du:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133) {
            goto LABEL_281;
          }
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A) {
              goto LABEL_281;
            }
            int v25 = 17;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 17;
              goto LABEL_67;
            }

            goto LABEL_226;
          }
        }

        int v24 = 17;
        break;
      case 0x27u:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133) {
            goto LABEL_281;
          }
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A) {
              goto LABEL_281;
            }
            int v25 = 15;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 15;
              goto LABEL_67;
            }

LABEL_204:
                int v25 = 0;
                LOBYTE(v24) = 0;
                goto LABEL_67;
              }

              int v25 = 0;
              goto LABEL_230;
            case 5u:
              if (v11 < 0xA)
              {
                int v24 = 11;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 11;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_207;
                }
                goto LABEL_226;
              }

              int v25 = 11;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 11;
                  goto LABEL_9;
                }

LABEL_219:
                LOBYTE(v24) = 5;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 0xAu:
              if (v11 < 0xA)
              {
                int v24 = 16;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 16;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_222;
                }
                goto LABEL_226;
              }

              int v25 = 16;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 16;
                  goto LABEL_9;
                }

id outlined copy of _StringRepresentation._Form(id result, uint64_t a2, uint64_t a3, char *a4)
{
  return result;
}

void outlined consume of _StringRepresentation._Form(id a1, unsigned __int8 a2)
{
  if (a2 <= 1u) {
    swift_unknownObjectRelease(a1);
  }
}

uint64_t type metadata accessor for SIMDMask(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for SIMDMask);
}

uint64_t specialized Substring.init(cString:)(uint8x16_t *a1)
{
  size_t v2 = _swift_stdlib_strlen(a1->i8);
  if ((v2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  int64_t v3 = v2;
  int64_t v4 = validateUTF8(_:)(a1->i64, v2);
  if ((v6 & 1) != 0) {
    repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v3, v4, v5);
  }
  else {
    specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v3, v4 & 1);
  }
  return 15LL;
}

Swift::UInt64 specialized Substring.init(_:)(Swift::String::Index a1, Swift::String::Index a2)
{
  Swift::UInt64 rawBits = a1._rawBits;
  if ((a1._rawBits & 1) == 0)
  {
    Swift::UInt64 rawBits = a1._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a1)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((a2._rawBits & 1) != 0) {
      return rawBits;
    }
LABEL_5:
    _StringGuts.scalarAlignSlow(_:)(a2)._rawBits;
    return rawBits;
  }

  if ((a2._rawBits & 1) == 0) {
    goto LABEL_5;
  }
  return rawBits;
}

uint64_t partial apply for closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)()
{
  return _StringGuts.replaceSubrange<A>(_:with:)( *(void *)(v0 + 32),  *(void *)(v0 + 40),  *(void *)(v0 + 48),  *(void *)(v0 + 16),  *(void *)(v0 + 24));
}

unint64_t lazy protocol witness table accessor for type UInt32 and conformance UInt32( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt32, &type metadata for UInt32, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt32, &type metadata for UInt32, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt32, &type metadata for UInt32, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }

  return result;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for UnsafeMutablePointer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for UnsafeMutablePointer);
}

uint64_t type metadata accessor for _UIntBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _UIntBuffer);
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF8.ForwardParser,  &type metadata for Unicode.UTF8.ForwardParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF8.ForwardParser,  &type metadata for Unicode.UTF8.ForwardParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser);
  }

  return result;
}

void sub_181705F10()
{
}

BOOL partial apply for closure #1 in LazySequenceProtocol.compactMap<A>(_:)(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v1 + 24) - 8LL) + 48LL))(a1, 1LL) != 1;
}

void sub_181705F4C()
{
}

uint64_t outlined destroy of _PlaygroundQuickLook?(uint64_t a1)
{
  return a1;
}

uint64_t outlined init with take of _PlaygroundQuickLook(__int128 *a1, uint64_t a2)
{
  __int128 v2 = *a1;
  __int128 v3 = a1[1];
  *(_BYTE *)(a2 + 32) = *((_BYTE *)a1 + 32);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

uint64_t type metadata accessor for CollectionDifference.Change( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for CollectionDifference.Change);
}

void partial apply for closure #3 in CollectionDifference<A>.inferringMoves()( uint64_t a1@<X0>, void *a2@<X8>)
{
}

uint64_t type metadata accessor for CollectionDifference.Change<A>._CodingKeys( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for CollectionDifference.Change<A>._CodingKeys);
}

unint64_t lazy protocol witness table accessor for type Int? and conformance <A> A?()
{
  unint64_t result = lazy protocol witness table cache variable for type Int? and conformance <A> A?;
  if (!lazy protocol witness table cache variable for type Int? and conformance <A> A?)
  {
    uint64_t v1 = &protocol witness table for Int;
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, &unk_189B88E40, &v1);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int? and conformance <A> A?);
  }

  return result;
}

{
  unint64_t result;
  _UNKNOWN **v1;
  unint64_t result = lazy protocol witness table cache variable for type Int? and conformance <A> A?;
  if (!lazy protocol witness table cache variable for type Int? and conformance <A> A?)
  {
    uint64_t v1 = &protocol witness table for Int;
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, &unk_189B88E40, &v1);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int? and conformance <A> A?);
  }

  return result;
}

uint64_t type metadata accessor for CollectionDifference.CodingKeys( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for CollectionDifference.CodingKeys);
}

unint64_t *partial apply for closure #1 in RangeReplaceableCollection.applying(_:)(uint64_t a1)
{
  return closure #1 in RangeReplaceableCollection.applying(_:)( a1,  *(void **)(v1 + 32),  *(void *)(v1 + 40),  *(void *)(v1 + 48),  *(void *)(v1 + 56),  *(void **)(v1 + 64),  *(void **)(v1 + 72),  *(void *)(v1 + 16),  *(void *)(v1 + 24));
}

uint64_t type metadata accessor for CollectionDifference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CollectionDifference);
}

void partial apply for closure #1 in _myers<A, B>(from:to:using:)(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
}

{
  uint64_t *v2;
  closure #1 in _myers<A, B>(from:to:using:)(a1, v2[6], v2[2], v2[3], v2[4], a2);
}

uint64_t partial apply for implicit closure #1 in BidirectionalCollection<>.difference<A>(from:)( uint64_t a1, uint64_t a2)
{
  uint64_t v5 = v2[6];
  char v6 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(v5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(v2[4] + 8) + 8LL),  v2[2],  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

unint64_t lazy protocol witness table accessor for type Int64 and conformance Int64( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }

  return result;
}

__objc2_class *specialized _SwiftNSMutableArray.countByEnumerating(with:objects:count:)( void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (*a1) {
    return 0LL;
  }
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = a1[5];
  uint64_t v10 = a1[6];
  uint64_t v11 = a1[7];
  unint64_t v12 = *(void *)(v4 + 16);
  if ((v12 & 0x8000000000000000LL) != 0 || (v12 & 0x4000000000000000LL) != 0)
  {
    unint64_t v14 = swift_bridgeObjectRetain(*(void *)(v4 + 16), a2, a3, a4);
    char v15 = specialized _copyCollectionToContiguousArray<A>(_:)(v14);
    uint64_t v5 = v15[2];
    *a1 = 1LL;
    a1[1] = v15 + 4;
    a1[2] = &_fastEnumerationStorageMutationsTarget;
    a1[3] = v7;
    a1[4] = v8;
    a1[5] = v9;
    a1[6] = v10;
    a1[7] = v11;
    swift_release((uint64_t)v15);
  }

  else
  {
    uint64_t v5 = *(__objc2_class **)((v12 & 0xFFFFFFFFFFFFFF8LL) + 0x10);
    *a1 = 1LL;
    a1[1] = (v12 & 0xFFFFFFFFFFFFFF8LL) + 32;
    a1[2] = &_fastEnumerationStorageMutationsTarget;
    swift_bridgeObjectRetain(v12, a2, a3, a4);
  }

  swift_bridgeObjectRelease(v12);
  return v5;
}

__objc2_class **specialized _SwiftNSMutableArray.copy(with:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void *)(v4 + 16);
  if ((unint64_t)v5 >> 62)
  {
    if (v5 < 0) {
      uint64_t v8 = *(void *)(v4 + 16);
    }
    else {
      uint64_t v8 = v5 & 0xFFFFFFFFFFFFFF8LL;
    }
    swift_bridgeObjectRetain(v5, a2, a3, a4);
  }

  else
  {
    uint64_t v6 = one-time initialization token for _bridgeInitializedSuccessfully;
    swift_bridgeObjectRetain_n(v5, 2LL, a3, a4);
    if (v6 != -1) {
      swift_once( &one-time initialization token for _bridgeInitializedSuccessfully,  (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully,  v7);
    }
    if (!_bridgeInitializedSuccessfully) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0x82uLL,  0);
    }
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFFF8LL;
    _orphanedFoundationSubclassesReparented = 1;
    if (*(void *)((v5 & 0xFFFFFFFFFFFFFF8LL) + 0x10))
    {
      uint64_t v9 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
      swift_bridgeObjectRetain(v5, v10, v11, v12);
      _swift_setClassMetadata(v9, (void *)(v5 & 0xFFFFFFFFFFFFFF8LL));
      swift_bridgeObjectRelease_n(v5, 2LL);
    }

    else
    {
      swift_bridgeObjectRelease_n(v5, 2LL);
      return &_swiftEmptyArrayStorage;
    }
  }

  return (__objc2_class **)v8;
}

uint64_t specialized static Unicode.UTF16.encode(_:into:)(unsigned int a1, void (*a2)(__int16 *))
{
  if (HIWORD(a1))
  {
    unsigned int v5 = ((a1 + 983040) >> 10) & 0x3FF | ((a1 & 0x3FF) << 16) | 0xDC00D800;
    __int16 v7 = ((a1 + 983040) >> 10) & 0x3FF | 0xD800;
    a2(&v7);
    __int16 v6 = HIWORD(v5);
    __int128 v3 = &v6;
  }

  else
  {
    __int16 v7 = a1;
    __int128 v3 = &v7;
  }

  return ((uint64_t (*)(__int16 *))a2)(v3);
}

uint64_t specialized Duration.init(_:scale:)(Swift::UInt64 a1, double a2)
{
  double v4 = trunc(a2);
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v64, v4);
  if ((v66 & 1) != 0)
  {
    unint64_t v10 = specialized static String._createEmpty(withInitialCapacity:)(80LL);
    unint64_t v12 = v11;
    unint64_t v64 = v10;
    unint64_t v65 = v11;
    TypeName = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Double, 0);
    if (v14 < 0) {
      goto LABEL_68;
    }
    char v15 = (uint8x16_t *)TypeName;
    int64_t v16 = v14;
    int64_t v17 = validateUTF8(_:)(TypeName, v14);
    if ((v19 & 1) != 0) {
      unint64_t v20 = repairUTF8(_:firstKnownBrokenRange:)(v15->i8, v16, v17, v18);
    }
    else {
      unint64_t v20 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v15, v16, v17 & 1);
    }
    unint64_t v22 = v20;
    unint64_t v23 = v21;
    uint64_t v24 = HIBYTE(v12) & 0xF;
    if ((v12 & 0x2000000000000000LL) == 0) {
      uint64_t v24 = v10 & 0xFFFFFFFFFFFFLL;
    }
    if (!v24 && (v10 & ~v12 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v12);
      unint64_t v64 = v22;
      unint64_t v65 = v23;
      goto LABEL_23;
    }

    if ((v12 & 0x2000000000000000LL) != 0)
    {
      if ((v21 & 0x2000000000000000LL) != 0)
      {
        unint64_t v26 = specialized _SmallString.init(_:appending:)(v10, v12, v20, v21);
        if ((v28 & 1) == 0)
        {
          unint64_t v29 = v26;
          unint64_t v30 = v27;
          swift_bridgeObjectRelease(v12);
          swift_bridgeObjectRelease(v23);
          unint64_t v64 = v29;
          unint64_t v65 = v30;
          unint64_t v23 = v30;
          unint64_t v22 = v29;
          goto LABEL_23;
        }

        goto LABEL_21;
      }
    }

    else if ((v21 & 0x2000000000000000LL) != 0)
    {
LABEL_21:
      uint64_t v25 = HIBYTE(v23) & 0xF;
      goto LABEL_22;
    }

    uint64_t v25 = v20 & 0xFFFFFFFFFFFFLL;
LABEL_22:
    _StringGuts.append(_:)(v22, v23, 0LL, v25);
    swift_bridgeObjectRelease(v23);
    unint64_t v22 = v64;
    unint64_t v23 = v65;
LABEL_23:
    uint64_t v31 = HIBYTE(v23) & 0xF;
    if ((v23 & 0x2000000000000000LL) == 0) {
      uint64_t v31 = v22 & 0xFFFFFFFFFFFFLL;
    }
    if (v31 || (v22 & ~v23 & 0x2000000000000000LL) != 0)
    {
      if ((v23 & 0x2000000000000000LL) != 0
        && (0x80000001818B69D0LL & 0x2000000000000000LL) != 0
        && (unint64_t v32 = specialized _SmallString.init(_:appending:)( v22,  v23,  0xD00000000000001ELL,  0x80000001818B69D0LL | 0x8000000000000000LL),  (v34 & 1) == 0))
      {
        unint64_t v35 = v32;
        unint64_t v36 = v33;
        swift_bridgeObjectRelease(v23);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
        unint64_t v64 = v35;
        unint64_t v65 = v36;
      }

      else
      {
        if ((0x80000001818B69D0LL & 0x2000000000000000LL) != 0) {
          unint64_t v37 = (0x80000001818B69D0LL >> 56) & 0xF;
        }
        else {
          unint64_t v37 = 30LL;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001818B69D0LL | 0x8000000000000000LL, 0LL, v37);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v23);
      unint64_t v64 = 0xD00000000000001ELL;
      unint64_t v65 = 0x80000001818B69D0LL | 0x8000000000000000LL;
    }

    char v38 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for _Int128, 0);
    if ((v39 & 0x8000000000000000LL) == 0)
    {
      uint64_t v40 = (uint8x16_t *)v38;
      int64_t v41 = v39;
      int64_t v42 = validateUTF8(_:)(v38, v39);
      if ((v44 & 1) != 0) {
        unint64_t v45 = repairUTF8(_:firstKnownBrokenRange:)(v40->i8, v41, v42, v43);
      }
      else {
        unint64_t v45 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v40, v41, v42 & 1);
      }
      unint64_t v47 = v45;
      unint64_t v48 = v46;
      uint64_t v49 = v65;
      unint64_t v50 = HIBYTE(v65) & 0xF;
      if ((v65 & 0x2000000000000000LL) == 0) {
        unint64_t v50 = v64 & 0xFFFFFFFFFFFFLL;
      }
      if (!v50 && (v64 & ~v65 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v65);
        unint64_t v64 = v47;
        unint64_t v65 = v48;
        goto LABEL_54;
      }

      if ((v65 & 0x2000000000000000LL) != 0)
      {
        if ((v46 & 0x2000000000000000LL) != 0)
        {
          unint64_t v52 = specialized _SmallString.init(_:appending:)(v64, v65, v45, v46);
          if ((v54 & 1) == 0)
          {
            unint64_t v55 = v52;
            unint64_t v56 = v53;
            swift_bridgeObjectRelease(v49);
            swift_bridgeObjectRelease(v48);
            unint64_t v64 = v55;
            unint64_t v65 = v56;
            unint64_t v48 = v56;
            unint64_t v47 = v55;
            goto LABEL_54;
          }

          goto LABEL_52;
        }
      }

      else if ((v46 & 0x2000000000000000LL) != 0)
      {
LABEL_52:
        uint64_t v51 = HIBYTE(v48) & 0xF;
        goto LABEL_53;
      }

      uint64_t v51 = v45 & 0xFFFFFFFFFFFFLL;
LABEL_53:
      _StringGuts.append(_:)(v47, v48, 0LL, v51);
      swift_bridgeObjectRelease(v48);
      unint64_t v47 = v64;
      unint64_t v48 = v65;
LABEL_54:
      uint64_t v57 = HIBYTE(v48) & 0xF;
      if ((v48 & 0x2000000000000000LL) == 0) {
        uint64_t v57 = v47 & 0xFFFFFFFFFFFFLL;
      }
      if (v57 || (v47 & ~v48 & 0x2000000000000000LL) != 0)
      {
        if ((v48 & 0x2000000000000000LL) != 0
          && (0x80000001818B69F0LL & 0x2000000000000000LL) != 0
          && (unint64_t v60 = specialized _SmallString.init(_:appending:)( v47,  v48,  0xD00000000000002ELL,  0x80000001818B69F0LL | 0x8000000000000000LL),  (v62 & 1) == 0))
        {
          Swift::Int v59 = (char *)v60;
          unint64_t v58 = v61;
          swift_bridgeObjectRelease(v48);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
        }

        else
        {
          if ((0x80000001818B69F0LL & 0x2000000000000000LL) != 0) {
            unint64_t v63 = (0x80000001818B69F0LL >> 56) & 0xF;
          }
          else {
            unint64_t v63 = 46LL;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001818B69F0LL | 0x8000000000000000LL, 0LL, v63);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
          Swift::Int v59 = (char *)v64;
          unint64_t v58 = v65;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v48);
        unint64_t v58 = 0x80000001818B69F0LL | 0x8000000000000000LL;
        Swift::Int v59 = (char *)0xD00000000000002ELL;
      }

      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v59,  v58,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
    }

uint64_t specialized Duration.init(from:)(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v3 + 32))(v10, v2, v3);
  uint64_t v4 = v11;
  uint64_t v5 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  (*(void (**)(uint64_t, uint64_t))(v5 + 112))(v4, v5);
  uint64_t v6 = v11;
  uint64_t v7 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 160))(v6, v7);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v8;
}

unint64_t *specialized static Duration.-= infix(_:_:)( unint64_t *result, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  BOOL v5 = __OFSUB__(v3, a3);
  unint64_t v6 = v3 - a3;
  int v7 = v5;
  BOOL v8 = v4 >= a2;
  unint64_t v9 = v4 - a2;
  if (v8)
  {
    if (v7) {
      goto LABEL_8;
    }
  }

  else
  {
    if (v6 == 0x8000000000000000LL) {
      LOBYTE(v7) = 1;
    }
    if ((v7 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x252uLL,  0);
    --v6;
  }

  *unint64_t result = v9;
  result[1] = v6;
  return result;
}

uint64_t specialized static Duration./ infix(_:_:)(unint64_t a1, uint64_t a2, double a3)
{
  if ((v61 & 1) != 0)
  {
    *(double *)&unint64_t v5 = COERCE_DOUBLE(specialized static String._createEmpty(withInitialCapacity:)(80LL));
    unint64_t v7 = v6;
    double v59 = *(double *)&v5;
    unint64_t v60 = v6;
    TypeName = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Double, 0);
    if (v9 < 0) {
      goto LABEL_66;
    }
    unint64_t v10 = (uint8x16_t *)TypeName;
    int64_t v11 = v9;
    int64_t v12 = validateUTF8(_:)(TypeName, v9);
    if ((v14 & 1) != 0) {
      unint64_t v15 = repairUTF8(_:firstKnownBrokenRange:)(v10->i8, v11, v12, v13);
    }
    else {
      unint64_t v15 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v10, v11, v12 & 1);
    }
    unint64_t v17 = v15;
    unint64_t v18 = v16;
    uint64_t v19 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000LL) == 0) {
      uint64_t v19 = v5 & 0xFFFFFFFFFFFFLL;
    }
    if (!v19 && (v5 & ~v7 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v7);
      double v59 = *(double *)&v17;
      unint64_t v60 = v18;
      goto LABEL_21;
    }

    if ((v7 & 0x2000000000000000LL) != 0)
    {
      if ((v16 & 0x2000000000000000LL) != 0)
      {
        unint64_t v21 = specialized _SmallString.init(_:appending:)(v5, v7, v15, v16);
        if ((v23 & 1) == 0)
        {
          double v24 = *(double *)&v21;
          unint64_t v25 = v22;
          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v18);
          double v59 = v24;
          unint64_t v60 = v25;
          unint64_t v18 = v25;
          *(double *)&unint64_t v17 = v24;
          goto LABEL_21;
        }

        goto LABEL_19;
      }
    }

    else if ((v16 & 0x2000000000000000LL) != 0)
    {
LABEL_19:
      uint64_t v20 = HIBYTE(v18) & 0xF;
      goto LABEL_20;
    }

    uint64_t v20 = v15 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v17, v18, 0LL, v20);
    swift_bridgeObjectRelease(v18);
    *(double *)&unint64_t v17 = v59;
    unint64_t v18 = v60;
LABEL_21:
    uint64_t v26 = HIBYTE(v18) & 0xF;
    if ((v18 & 0x2000000000000000LL) == 0) {
      uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
    }
    if (v26 || (v17 & ~v18 & 0x2000000000000000LL) != 0)
    {
      if ((v18 & 0x2000000000000000LL) != 0
        && (0x80000001818B69D0LL & 0x2000000000000000LL) != 0
        && (unint64_t v27 = specialized _SmallString.init(_:appending:)( v17,  v18,  0xD00000000000001ELL,  0x80000001818B69D0LL | 0x8000000000000000LL),  (v29 & 1) == 0))
      {
        double v30 = *(double *)&v27;
        unint64_t v31 = v28;
        swift_bridgeObjectRelease(v18);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
        double v59 = v30;
        unint64_t v60 = v31;
      }

      else
      {
        if ((0x80000001818B69D0LL & 0x2000000000000000LL) != 0) {
          unint64_t v32 = (0x80000001818B69D0LL >> 56) & 0xF;
        }
        else {
          unint64_t v32 = 30LL;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001818B69D0LL | 0x8000000000000000LL, 0LL, v32);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v18);
      double v59 = -2.31584178e77;
      unint64_t v60 = 0x80000001818B69D0LL | 0x8000000000000000LL;
    }

    unint64_t v33 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for _Int128, 0);
    if ((v34 & 0x8000000000000000LL) == 0)
    {
      unint64_t v35 = (uint8x16_t *)v33;
      int64_t v36 = v34;
      int64_t v37 = validateUTF8(_:)(v33, v34);
      if ((v39 & 1) != 0) {
        unint64_t v40 = repairUTF8(_:firstKnownBrokenRange:)(v35->i8, v36, v37, v38);
      }
      else {
        unint64_t v40 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v35, v36, v37 & 1);
      }
      unint64_t v42 = v40;
      unint64_t v43 = v41;
      uint64_t v44 = v60;
      unint64_t v45 = HIBYTE(v60) & 0xF;
      if ((v60 & 0x2000000000000000LL) == 0) {
        unint64_t v45 = *(void *)&v59 & 0xFFFFFFFFFFFFLL;
      }
      if (!v45 && (*(void *)&v59 & ~v60 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v60);
        double v59 = *(double *)&v42;
        unint64_t v60 = v43;
        goto LABEL_52;
      }

      if ((v60 & 0x2000000000000000LL) != 0)
      {
        if ((v41 & 0x2000000000000000LL) != 0)
        {
          unint64_t v47 = specialized _SmallString.init(_:appending:)(*(unint64_t *)&v59, v60, v40, v41);
          if ((v49 & 1) == 0)
          {
            double v50 = *(double *)&v47;
            unint64_t v51 = v48;
            swift_bridgeObjectRelease(v44);
            swift_bridgeObjectRelease(v43);
            double v59 = v50;
            unint64_t v60 = v51;
            unint64_t v43 = v51;
            *(double *)&unint64_t v42 = v50;
            goto LABEL_52;
          }

          goto LABEL_50;
        }
      }

      else if ((v41 & 0x2000000000000000LL) != 0)
      {
LABEL_50:
        uint64_t v46 = HIBYTE(v43) & 0xF;
        goto LABEL_51;
      }

      uint64_t v46 = v40 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v42, v43, 0LL, v46);
      swift_bridgeObjectRelease(v43);
      *(double *)&unint64_t v42 = v59;
      unint64_t v43 = v60;
LABEL_52:
      uint64_t v52 = HIBYTE(v43) & 0xF;
      if ((v43 & 0x2000000000000000LL) == 0) {
        uint64_t v52 = v42 & 0xFFFFFFFFFFFFLL;
      }
      if (v52 || (v42 & ~v43 & 0x2000000000000000LL) != 0)
      {
        if ((v43 & 0x2000000000000000LL) != 0
          && (0x80000001818B69F0LL & 0x2000000000000000LL) != 0
          && (unint64_t v55 = specialized _SmallString.init(_:appending:)( v42,  v43,  0xD00000000000002ELL,  0x80000001818B69F0LL | 0x8000000000000000LL),  (v57 & 1) == 0))
        {
          char v54 = (char *)v55;
          unint64_t v53 = v56;
          swift_bridgeObjectRelease(v43);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
        }

        else
        {
          if ((0x80000001818B69F0LL & 0x2000000000000000LL) != 0) {
            unint64_t v58 = (0x80000001818B69F0LL >> 56) & 0xF;
          }
          else {
            unint64_t v58 = 46LL;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001818B69F0LL | 0x8000000000000000LL, 0LL, v58);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
          char v54 = *(char **)&v59;
          unint64_t v53 = v60;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v43);
        unint64_t v53 = 0x80000001818B69F0LL | 0x8000000000000000LL;
        char v54 = (char *)0xD00000000000002ELL;
      }

      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v54,  v53,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
    }

uint64_t specialized Int128.init<A>(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v11 = 4;
  (*(void (**)(char *))(*(void *)(v7 + 16) + 304LL))(&v11);
  uint64_t result = Int128.init<A>(exactly:)(v6, a2, a3);
  if ((v9 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000051LL,  0x80000001818BAC10LL,  "Swift/Int128.swift",  18LL,  2,  0xD4uLL,  0);
  }
  return result;
}

void sub_181707114()
{
}

uint64_t outlined init with take of MirrorPath(__int128 *a1, uint64_t a2)
{
  __int128 v2 = *a1;
  __int128 v3 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

uint64_t outlined retain of Mirror(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(unint64_t **)(a1 + 32);
  swift_retain(*(unint64_t **)(a1 + 8), a2, a3, a4);
  swift_retain(v5, v6, v7, v8);
  return a1;
}

uint64_t specialized UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v11 = 4;
  (*(void (**)(char *))(*(void *)(v7 + 16) + 304LL))(&v11);
  uint64_t result = UInt128.init<A>(exactly:)(v6, a2, a3);
  if ((v9 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000052LL,  0x80000001818BAB80LL,  "Swift/UInt128.swift",  19LL,  2,  0xC6uLL,  0);
  }
  return result;
}

void sub_18170726C()
{
}

uint64_t partial apply for closure #1 in sequence<A>(first:next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return closure #1 in sequence<A>(first:next:)( a1,  *(void (**)(char *))(v2 + 24),  *(void *)(v2 + 32),  *(void *)(v2 + 16),  a2);
}

uint64_t type metadata accessor for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for UnfoldSequence);
}

void *partial apply for closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)( const void *a1, size_t a2)
{
  return closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)( a1,  a2,  *(void *)(v2 + 32),  *(void *)(v2 + 40),  *(void *)(v2 + 48),  *(void **)(v2 + 56),  *(void *)(v2 + 16),  *(void *)(v2 + 24));
}

uint64_t type metadata accessor for __VaListBuilder()
{
  return objc_opt_self();
}

void partial apply for closure #1 in SIMD.description.getter(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
}

BOOL partial apply for specialized closure #1 in Sequence<>.contains(_:)(unsigned __int16 *a1)
{
  return *a1 == **(unsigned __int16 **)(v1 + 16);
}

_BYTE *partial apply for closure #1 in closure #1 in Float.init<A>(_:)@<X0>(_BYTE *a1@<X0>, BOOL *a2@<X8>)
{
  return partial apply for closure #1 in closure #1 in Float.init<A>(_:)( a1,  (uint64_t (*)(void))_swift_stdlib_strtof_clocale,  a2);
}

_BYTE *partial apply for closure #1 in closure #1 in Double.init<A>(_:)@<X0>(_BYTE *a1@<X0>, BOOL *a2@<X8>)
{
  return partial apply for closure #1 in closure #1 in Float.init<A>(_:)( a1,  (uint64_t (*)(void))_swift_stdlib_strtod_clocale,  a2);
}

_BYTE *partial apply for closure #1 in closure #1 in Float.init<A>(_:)@<X0>( _BYTE *result@<X0>, uint64_t (*a2)(void)@<X1>, BOOL *a3@<X8>)
{
  unsigned int v4 = *result;
  BOOL v5 = v4 > 0x20;
  uint64_t v6 = (1LL << v4) & 0x100003E01LL;
  BOOL v7 = v5 || v6 == 0;
  v8 = v7 && (uint64_t result = (_BYTE *)a2()) != 0LL && *result == 0;
  *a3 = v8;
  return result;
}

__int16 specialized Float16.init(sign:exponent:significand:)@<H0>( char a1@<W0>, uint64_t a2@<X1>, float _S0@<S0>)
{
  float v3 = _S0;
  __asm { FCVT            S0, H0 }

  _S0 = -_S0;
  __asm { FCVT            H0, S0 }

  if ((a1 & 1) == 0) {
    _S0 = v3;
  }
  int v10 = (LODWORD(v3) >> 10) & 0x1F;
  if (v10 != 31 && v10 | LOWORD(v3) & 0x3FF)
  {
    if (a2 > -15)
    {
      if (a2 >= 16)
      {
        if (a2 >= 45) {
          a2 = 45LL;
        }
        do
        {
          a2 -= 15LL;
          __asm { FCVT            S0, H0 }

          _S0 = _S0 * 32768.0;
          __asm { FCVT            H0, S0 }
        }

        while ((unint64_t)a2 > 0xF);
      }
    }

    else
    {
      if (a2 <= -42) {
        uint64_t v11 = -42LL;
      }
      else {
        uint64_t v11 = a2;
      }
      do
      {
        LOWORD(a2) = v11 + 14;
        __asm { FCVT            S0, H0 }

        _S0 = _S0 * 0.000061035;
        __asm { FCVT            H0, S0 }

        _CF = __CFADD__(v11, 28LL);
        v11 += 14LL;
      }

      while (!_CF);
    }

    _H1 = (((_WORD)a2 << 10) + 15360) & 0x7C00;
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }

    _S0 = _S0 * _S1;
    __asm { FCVT            H0, S0 }
  }

  return LOWORD(_S0);
}

float _stdlib_squareRootf(float a1)
{
  return sqrtf(a1);
}

float specialized Float.init(sign:exponent:significand:)(char a1, uint64_t a2, float a3)
{
  float result = -a3;
  if ((a1 & 1) == 0) {
    float result = a3;
  }
  int v5 = (LODWORD(a3) >> 23);
  if (v5 != 255 && v5 | LODWORD(a3) & 0x7FFFFF)
  {
    if (a2 > -127)
    {
      if (a2 >= 128)
      {
        if (a2 >= 381) {
          a2 = 381LL;
        }
        do
        {
          a2 -= 127LL;
          float result = result * 1.7014e38;
        }

        while ((unint64_t)a2 > 0x7F);
      }
    }

    else
    {
      if (a2 <= -378) {
        uint64_t v6 = -378LL;
      }
      else {
        uint64_t v6 = a2;
      }
      do
      {
        LODWORD(a2) = v6 + 126;
        float result = result * 1.1755e-38;
        BOOL v7 = __CFADD__(v6, 252LL);
        v6 += 126LL;
      }

      while (!v7);
    }

    return result * COERCE_FLOAT((((_DWORD)a2 << 23) + 1065353216) & 0x7F800000);
  }

  return result;
}

double specialized Double.init(sign:exponent:significand:)(char a1, uint64_t a2, double a3)
{
  double result = -a3;
  if ((a1 & 1) == 0) {
    double result = a3;
  }
  uint64_t v5 = (*(void *)&a3 >> 52) & 0x7FFLL;
  if (v5 != 2047 && v5 | *(void *)&a3 & 0xFFFFFFFFFFFFFLL)
  {
    if (a2 > -1023)
    {
      if (a2 >= 1024)
      {
        if (a2 >= 3069) {
          a2 = 3069LL;
        }
        do
        {
          a2 -= 1023LL;
          double result = result * 8.98846567e307;
        }

        while ((unint64_t)a2 > 0x3FF);
      }
    }

    else
    {
      if (a2 <= -3066) {
        uint64_t v6 = -3066LL;
      }
      else {
        uint64_t v6 = a2;
      }
      do
      {
        a2 = v6 + 1022;
        double result = result * 2.22507386e-308;
        BOOL v7 = __CFADD__(v6, 2044LL);
        v6 += 1022LL;
      }

      while (!v7);
    }

    return result * COERCE_DOUBLE(((a2 << 52) + 0x3FF0000000000000LL) & 0x7FF0000000000000LL);
  }

  return result;
}

double _stdlib_squareRoot(double a1)
{
  return sqrt(a1);
}

uint64_t type metadata accessor for UnsafeMutableBufferPointer( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for UnsafeMutableBufferPointer);
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error)( uint64_t a1, uint64_t a2, void *a3)
{
  return partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error)( a1,  a2,  a3);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  double result = (*(uint64_t (**)(void))(v3 + 40))();
  if (v4) {
    *a3 = v4;
  }
  return result;
}

uint64_t type metadata accessor for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD2);
}

unint64_t *specialized static _UInt128.-= infix(_:_:)( unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  BOOL v5 = v3 >= a3;
  unint64_t v6 = v3 - a3;
  int v7 = !v5;
  BOOL v5 = v4 >= a2;
  unint64_t v8 = v4 - a2;
  if (v5)
  {
    if (v7) {
      goto LABEL_8;
    }
  }

  else
  {
    if (!v6) {
      LOBYTE(v7) = 1;
    }
    if ((v7 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x65uLL,  0);
    --v6;
  }

  *double result = v8;
  result[1] = v6;
  return result;
}

unint64_t *specialized static _UInt128.*= infix(_:_:)( unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  BOOL v5 = !is_mul_ok(v4, a2);
  BOOL v6 = !is_mul_ok(*result, a3);
  unint64_t v7 = v4 * a2 + *result * a3;
  BOOL v8 = __CFADD__(v4 * a2, *result * a3);
  uint64_t v9 = (v3 * (unsigned __int128)a2) >> 64;
  BOOL v10 = __CFADD__(v7, v9);
  unint64_t v11 = v7 + v9;
  int v12 = v10;
  if (a3) {
    BOOL v13 = v4 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13 || v5 || v6 || v8 || v12) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in *=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0xA9uLL,  0);
  }
  *double result = v3 * a2;
  result[1] = v11;
  return result;
}

Swift::UInt64 specialized static _UInt128./= infix(_:_:)( Swift::UInt64 *a1, unint64_t a2, unint64_t a3)
{
  if (!(a3 | a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in /=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x1CEuLL,  0);
  }
  v9.Swift::UInt64 low = a1[1];
  v9.Swift::Int64 high = (Swift::UInt64)&v6;
  Swift::UInt64 result = specialized _wideDivide22<A>(_:by:)(&v8, &v7, v9, *a1, a3, a2);
  *a1 = v8;
  a1[1] = result;
  return result;
}

Swift::UInt64 specialized static _UInt128.%= infix(_:_:)( Swift::UInt64 *a1, unint64_t a2, unint64_t a3)
{
  if (!(a3 | a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in %=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x1DCuLL,  0);
  }
  v10.Swift::UInt64 low = a1[1];
  v10.Swift::Int64 high = (Swift::UInt64)&v7;
  Swift::UInt64 result = specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, *a1, a3, a2);
  Swift::UInt64 v6 = v8;
  *a1 = v7;
  a1[1] = v6;
  return result;
}

unint64_t *specialized static _Int128.-= infix(_:_:)( unint64_t *result, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  BOOL v5 = __OFSUB__(v3, a3);
  unint64_t v6 = v3 - a3;
  int v7 = v5;
  BOOL v8 = v4 >= a2;
  unint64_t v9 = v4 - a2;
  if (v8)
  {
    if (v7) {
      goto LABEL_8;
    }
  }

  else
  {
    if (v6 == 0x8000000000000000LL) {
      LOBYTE(v7) = 1;
    }
    if ((v7 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x258uLL,  0);
    --v6;
  }

  *Swift::UInt64 result = v9;
  result[1] = v6;
  return result;
}

uint64_t type metadata accessor for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD4);
}

uint64_t specialized SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a3;
  uint64_t v22 = a4;
  uint64_t v4 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  unint64_t v6 = (char *)&v20 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  BOOL v8 = *(const char **)(v7 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  unint64_t v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  int v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v11(0LL, v12, AssociatedConformanceWitness);
  unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  v8,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t v14 = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v4,  v13,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v15 = *(void (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
  unint64_t v16 = swift_checkMetadataState(0LL, v13);
  v15(v6, v21, v16, v14);
  unint64_t v17 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v11(1LL, v17, AssociatedConformanceWitness);
  unint64_t v18 = swift_checkMetadataState(0LL, v13);
  return ((uint64_t (*)(char *, uint64_t, unint64_t *, unint64_t))v15)(v6, v22, v18, v14);
}

uint64_t type metadata accessor for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD8);
}

uint64_t specialized SIMD8.lowHalf.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v29 = a5;
  uint64_t v30 = a6;
  uint64_t v27 = a3;
  uint64_t v28 = a4;
  uint64_t v6 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  BOOL v8 = (char *)&v26 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::tuple_high_UInt64_low_UInt64 v10 = *(const char **)(v9 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v13 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  unint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v13(0LL, v14, AssociatedConformanceWitness);
  unint64_t v15 = swift_getAssociatedTypeWitness( 255LL,  v10,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t v16 = swift_getAssociatedConformanceWitness( (uint64_t)v10,  v6,  v15,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  unint64_t v17 = *(void (**)(char *, uint64_t, unint64_t *, unint64_t))(v16 + 64);
  unint64_t v18 = swift_checkMetadataState(0LL, v15);
  v17(v8, v27, v18, v16);
  uint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v13(1LL, v19, AssociatedConformanceWitness);
  uint64_t v20 = swift_checkMetadataState(0LL, v15);
  v17(v8, v28, v20, v16);
  uint64_t v21 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v13(2LL, v21, AssociatedConformanceWitness);
  uint64_t v22 = swift_checkMetadataState(0LL, v15);
  v17(v8, v29, v22, v16);
  char v23 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v13(3LL, v23, AssociatedConformanceWitness);
  double v24 = swift_checkMetadataState(0LL, v15);
  return ((uint64_t (*)(char *, uint64_t, unint64_t *, unint64_t))v17)(v8, v30, v24, v16);
}

uint64_t specialized SIMD16.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v16 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    Swift::tuple_high_UInt64_low_UInt64 v10 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v9(v8, v10, AssociatedConformanceWitness);
    unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
    unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    unint64_t v13 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v12 + 64);
    unint64_t v14 = swift_checkMetadataState(0LL, v11);
    uint64_t result = v13(v4, v8++, v14, v12);
  }

  while (v8 != 8);
  return result;
}

uint64_t type metadata accessor for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD16);
}

uint64_t specialized SIMD16.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v9 = 0LL;
  Swift::tuple_high_UInt64_low_UInt64 v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    unint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v10(v9, v11, AssociatedConformanceWitness);
    unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
    unint64_t v13 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v12,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    unint64_t v14 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v13 + 64);
    unint64_t v15 = swift_checkMetadataState(0LL, v12);
    uint64_t result = v14(v4, v9 + 8, v15, v13);
    ++v9;
  }

  while (v9 != 8);
  return result;
}

uint64_t specialized SIMD16.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  Swift::tuple_high_UInt64_low_UInt64 v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v11 = v9 + 1;
    unint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v10(v9, v12, AssociatedConformanceWitness);
    unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
    unint64_t v14 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v13,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    unint64_t v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    uint64_t v16 = swift_checkMetadataState(0LL, v13);
    uint64_t result = v15(v4, v8, v16, v14);
    v8 += 2LL;
    uint64_t v9 = v11;
  }

  while (v11 != 8);
  return result;
}

uint64_t specialized SIMD16.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v10 = 1LL;
  do
  {
    uint64_t v11 = v8 + 1;
    unint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v9(v8, v12, AssociatedConformanceWitness);
    unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
    unint64_t v14 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v13,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    unint64_t v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    uint64_t v16 = swift_checkMetadataState(0LL, v13);
    uint64_t result = v15(v4, v10, v16, v14);
    v10 += 2LL;
    uint64_t v8 = v11;
  }

  while (v11 != 8);
  return result;
}

uint64_t specialized SIMD32.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v16 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v10 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v9(v8, v10, AssociatedConformanceWitness);
    unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
    unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    unint64_t v13 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v12 + 64);
    unint64_t v14 = swift_checkMetadataState(0LL, v11);
    uint64_t result = v13(v4, v8++, v14, v12);
  }

  while (v8 != 16);
  return result;
}

uint64_t type metadata accessor for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD32);
}

uint64_t specialized SIMD32.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v9 = 0LL;
  uint64_t v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    unint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v10(v9, v11, AssociatedConformanceWitness);
    unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
    unint64_t v13 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v12,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    unint64_t v14 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v13 + 64);
    unint64_t v15 = swift_checkMetadataState(0LL, v12);
    uint64_t result = v14(v4, v9 + 16, v15, v13);
    ++v9;
  }

  while (v9 != 16);
  return result;
}

uint64_t specialized SIMD32.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v11 = v9 + 1;
    unint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v10(v9, v12, AssociatedConformanceWitness);
    unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
    unint64_t v14 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v13,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    unint64_t v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    uint64_t v16 = swift_checkMetadataState(0LL, v13);
    uint64_t result = v15(v4, v8, v16, v14);
    v8 += 2LL;
    uint64_t v9 = v11;
  }

  while (v11 != 16);
  return result;
}

uint64_t specialized SIMD32.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v10 = 1LL;
  do
  {
    uint64_t v11 = v8 + 1;
    unint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v9(v8, v12, AssociatedConformanceWitness);
    unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
    unint64_t v14 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v13,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    unint64_t v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    uint64_t v16 = swift_checkMetadataState(0LL, v13);
    uint64_t result = v15(v4, v10, v16, v14);
    v10 += 2LL;
    uint64_t v8 = v11;
  }

  while (v11 != 16);
  return result;
}

uint64_t specialized SIMD64.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v16 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v10 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v9(v8, v10, AssociatedConformanceWitness);
    unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
    unint64_t v12 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v11,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    unint64_t v13 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v12 + 64);
    unint64_t v14 = swift_checkMetadataState(0LL, v11);
    uint64_t result = v13(v4, v8++, v14, v12);
  }

  while (v8 != 32);
  return result;
}

uint64_t type metadata accessor for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD64);
}

uint64_t specialized SIMD64.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v9 = 0LL;
  uint64_t v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    unint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v10(v9, v11, AssociatedConformanceWitness);
    unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
    unint64_t v13 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v12,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    unint64_t v14 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v13 + 64);
    unint64_t v15 = swift_checkMetadataState(0LL, v12);
    uint64_t result = v14(v4, v9 + 32, v15, v13);
    ++v9;
  }

  while (v9 != 32);
  return result;
}

uint64_t specialized SIMD64.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v11 = v9 + 1;
    unint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v10(v9, v12, AssociatedConformanceWitness);
    unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
    unint64_t v14 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v13,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    unint64_t v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    uint64_t v16 = swift_checkMetadataState(0LL, v13);
    uint64_t result = v15(v4, v8, v16, v14);
    v8 += 2LL;
    uint64_t v9 = v11;
  }

  while (v11 != 32);
  return result;
}

uint64_t specialized SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(const char **)(v5 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v10 = 1LL;
  do
  {
    uint64_t v11 = v8 + 1;
    unint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    v9(v8, v12, AssociatedConformanceWitness);
    unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  v6,  v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
    unint64_t v14 = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v2,  v13,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    unint64_t v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    uint64_t v16 = swift_checkMetadataState(0LL, v13);
    uint64_t result = v15(v4, v10, v16, v14);
    v10 += 2LL;
    uint64_t v8 = v11;
  }

  while (v11 != 32);
  return result;
}

uint64_t type metadata accessor for SIMD3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in EnumeratedSequence<A>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EnumeratedSequence<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for _ArrayBuffer<A>,  (uint64_t)&protocol conformance descriptor for _ArrayBuffer<A>);
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _ArrayBuffer<A>()
{
  return &protocol witness table for Int;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for IndexingIterator<A>, a1, a3);
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for [A],  (uint64_t)&protocol conformance descriptor for [A]);
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <A> [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for ArraySlice<A>,  (uint64_t)&protocol conformance descriptor for ArraySlice<A>);
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> ArraySlice<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>;
  if (!lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, &unk_189B86B68, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser;
  if (!lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.ASCII.Parser,  &type metadata for Unicode.ASCII.Parser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.ASCII and conformance Unicode.ASCII( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII;
  if (!lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.ASCII,  &type metadata for Unicode.ASCII,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII);
  }

  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UnsafeBitset()
{
  return &protocol witness table for _UnsafeBitset.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UnsafeBitset.Word()
{
  return &protocol witness table for _UnsafeBitset.Word;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByBooleanLiteral.BooleanLiteralType : _ExpressibleByBuiltinBooleanLiteral in Bool()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in AutoreleasingUnsafeMutablePointer<A>()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in Character()
{
  return &protocol witness table for Character;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in Character()
{
  return &protocol witness table for Character;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _CocoaArrayWrapper( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>( &lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>,  (uint64_t)&protocol conformance descriptor for <> Range<A>,  a3);
}

unint64_t lazy protocol witness table accessor for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, &unk_189B86B28, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, &unk_189B86B28, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, &unk_189B86B28, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for _CocoaArrayWrapper( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _CocoaArrayWrapper,  &type metadata for _CocoaArrayWrapper,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _CocoaArrayWrapper,  &type metadata for _CocoaArrayWrapper,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _CocoaArrayWrapper,  &type metadata for _CocoaArrayWrapper,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }

  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _CocoaArrayWrapper( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>( &lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>,  (uint64_t)&protocol conformance descriptor for <> Range<A>,  a3);
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _CocoaArrayWrapper( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>( &lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>,  (uint64_t)&protocol conformance descriptor for <> Range<A>,  a3);
}

uint64_t lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>( unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    v6[0] = &protocol witness table for Int;
    v6[1] = lazy protocol witness table accessor for type Int and conformance Int(0LL, a2, a3);
    uint64_t result = swift_getWitnessTable(a2, &unk_189B86D40, v6);
    atomic_store(result, a1);
  }

  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _CocoaArrayWrapper()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<_CocoaArrayWrapper>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for ContiguousArray<A>,  (uint64_t)&protocol conformance descriptor for ContiguousArray<A>);
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> ContiguousArray<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> ContiguousArray<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for RangeExpression.Bound : Comparable in ClosedRange<A>( uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> ClosedRange<A>()
{
  return &protocol witness table for ClosedRange<A><>.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <> ClosedRange<A>( uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> ClosedRange<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;
  __int128 v5 = *a3;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> ClosedRange<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;
  __int128 v5 = *a3;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> ClosedRange<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t instantiation function for generic protocol witness table for _ContiguousArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for _ContiguousArrayBuffer<A>,  (uint64_t)&protocol conformance descriptor for _ContiguousArrayBuffer<A>);
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in __CocoaDictionary()
{
  return &protocol witness table for __CocoaDictionary.Iterator;
}

uint64_t instantiation function for generic protocol witness table for <> DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> DiscontiguousSlice<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in DiscontiguousSlice<A>()
{
  return &protocol witness table for DiscontiguousSlice<A>.Index;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> DiscontiguousSlice<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DiscontiguousSlice<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyDropWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyDropWhileSequence<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for LazyDropWhileSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyDropWhileSequence<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyDropWhileSequence<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyDropWhileSequence<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyDropWhileSequence<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyDropWhileSequence<A>,  (uint64_t)&protocol conformance descriptor for LazyDropWhileSequence<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in EmptyCollection<A>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in EmptyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for EmptyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in EmptyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in EmptyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in EmptyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in AnyIterator<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyIterator<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in AnyCollection<A>()
{
  return &protocol witness table for AnyIndex;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AnyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AnyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in AnyBidirectionalCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in AnyBidirectionalCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyBidirectionalCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyBidirectionalCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in AnyRandomAccessCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in AnyRandomAccessCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyRandomAccessCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in AnyRandomAccessCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in AnyRandomAccessCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyRandomAccessCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyFilterSequence<A>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection,  (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyFilterSequence<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyFilterSequence<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>,  (uint64_t)&protocol conformance descriptor for LazyFilterSequence<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection,  (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in FlattenSequence<A>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for FlattenSequence<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> FlattenSequence<A>()
{
  return &protocol witness table for FlattenSequence<A><>.Index;
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for FlattenSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> FlattenSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> FlattenSequence<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> FlattenSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> FlattenSequence<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int8x16_t v9 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, &v9);
  return swift_getWitnessTable(a5, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>( uint64_t a1, uint64_t a2, void *a3)
{
  return instantiation function for generic protocol witness table for <> FlattenSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> FlattenSequence<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _HashTable()
{
  return &protocol witness table for _HashTable.Iterator;
}

unint64_t associated type witness table accessor for Collection.Index : Comparable in DefaultIndices<A>( uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a2 + 24),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
}

uint64_t instantiation function for generic protocol witness table for DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in JoinedSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for JoinedSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in KeyValuePairs<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for KeyValuePairs<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in KeyValuePairs<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

unint64_t associated type witness table accessor for Collection.Index : Comparable in <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a3 - 8),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
}

unint64_t associated type witness table accessor for Collection.Indices : Collection in <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a3 - 8),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Indices: Collection);
}

uint64_t instantiation function for generic protocol witness table for <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for LazySequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> LazySequence<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> LazySequence<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(void *)(a3 - 8);
}

uint64_t instantiation function for generic protocol witness table for <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazySequence<A>,  (uint64_t)&protocol conformance descriptor for LazySequence<A>);
}

unint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a3 - 8),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.Indices: BidirectionalCollection);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazySequence<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a3 - 8),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for RandomAccessCollection,  (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.Indices: RandomAccessCollection);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazySequence<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in <> ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a1, a3);
}

unint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazySequence<A>( uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a2 + 24),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyMapSequence<A, B>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection,  (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection,  (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>,  (uint64_t)&protocol conformance descriptor for LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for RandomAccessCollection,  (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection,  (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( *(void *)(a3 - 8),  *(void *)(a2 + 16),  *(void *)(a1 + 16),  a4,  a5);
  return swift_getWitnessTable(a6, a1, &AssociatedConformanceWitness);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in Unicode.Scalar()
{
  return &protocol witness table for Unicode.Scalar;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF16View,  &type metadata for Unicode.Scalar.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF16View,  &type metadata for Unicode.Scalar.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF16View,  &type metadata for Unicode.Scalar.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF16View,  &type metadata for Unicode.Scalar.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.Scalar.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Unicode.Scalar.UTF16View> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Unicode.Scalar.UTF16View>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF8View,  &type metadata for Unicode.Scalar.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF8View,  &type metadata for Unicode.Scalar.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF8View,  &type metadata for Unicode.Scalar.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.Scalar.UTF8View,  &type metadata for Unicode.Scalar.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.Scalar.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Unicode.Scalar.UTF8View> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Unicode.Scalar.UTF8View>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _NativeDictionary<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _NativeDictionary<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _NativeSet<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _NativeSet<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <A> A?( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Identifiable.ID : Hashable in Never()
{
  return &protocol witness table for Never;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyPrefixWhileSequence<A>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyPrefixWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyPrefixWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyPrefixWhileSequence<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> LazyPrefixWhileSequence<A>()
{
  return &protocol witness table for LazyPrefixWhileSequence<A><>.Index;
}

uint64_t instantiation function for generic protocol witness table for <> LazyPrefixWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for LazyPrefixWhileSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyPrefixWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyPrefixWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>,  (uint64_t)&protocol conformance descriptor for LazyPrefixWhileSequence<A>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *a3;
  *(void *)(a1 + 8) = swift_getWitnessTable(a4, a2, &v10);
  uint64_t result = swift_getWitnessTable(a5, a2, v8);
  *(void *)(a1 + 16) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyPrefixWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyPrefixWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> Range<A>( uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;
  __int128 v5 = *a3;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;
  __int128 v5 = *a3;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in <> PartialRangeFrom<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for PartialRangeFrom<A><>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Repeated<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for Repeated<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Repeated<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> Result<A, B>( uint64_t a1, uint64_t a2, void *a3)
{
  return instantiation function for generic protocol witness table for <> FlattenSequence<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> Result<A, B>);
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>( uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a3[1] + 8LL);
  v7[0] = *(void *)(*a3 + 8LL);
  v7[1] = v5;
  uint64_t result = swift_getWitnessTable(a4, a2, v7);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in ReversedCollection<A>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in ReversedCollection<A>()
{
  return &protocol witness table for ReversedCollection<A>.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> ReversedCollection<A>,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for <> ReversedCollection<A>,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, &v9);
  return swift_getWitnessTable(a5, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in PrefixSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for PrefixSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in DropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for DropWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in IteratorSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for IteratorSequence<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Set<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Set<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in Set<A>()
{
  return &protocol witness table for Set<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for Set<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in __CocoaSet()
{
  return &protocol witness table for __CocoaSet.Iterator;
}

unint64_t associated type witness table accessor for Collection.Indices : Collection in Slice<A>( uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a2 + 24),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Indices: Collection);
}

uint64_t instantiation function for generic protocol witness table for Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

unint64_t lazy protocol witness table accessor for type _SmallString and conformance _SmallString( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _SmallString,  &type metadata for _SmallString,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _SmallString,  &type metadata for _SmallString,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _SmallString,  &type metadata for _SmallString,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _SmallString,  &type metadata for _SmallString,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _SmallString,  &type metadata for _SmallString,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for _SmallString( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _SmallString()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<_SmallString> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<_SmallString>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringLiteral.StringLiteralType : _ExpressibleByBuiltinStringLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in StrideTo<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for StrideToIterator<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in StrideThrough<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for StrideThroughIterator<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringLiteral.StringLiteralType : _ExpressibleByBuiltinStringLiteral in String()
{
  return &protocol witness table for String;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in String()
{
  return &protocol witness table for String;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in String()
{
  return &protocol witness table for String;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type DefaultIndices<String> and conformance <> DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String>,  (uint64_t (*)(void))lazy protocol witness table accessor for type String and conformance String,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type String and conformance String( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String and conformance String;
  if (!lazy protocol witness table cache variable for type String and conformance String)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for String, &type metadata for String, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String and conformance String);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type String and conformance String;
  if (!lazy protocol witness table cache variable for type String and conformance String)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for String, &type metadata for String, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String and conformance String);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Substring and conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for String( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String and conformance String(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type String and conformance String(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in String()
{
  return &protocol witness table for String.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type DefaultIndices<String> and conformance DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String>,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String()
{
  return &protocol witness table for String.Iterator;
}

unint64_t lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View;
  if (!lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for String.UTF16View,  &type metadata for String.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View;
  if (!lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for String.UTF16View,  &type metadata for String.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for String.UTF8View,  &type metadata for String.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for String.UTF8View,  &type metadata for String.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for String.UTF8View,  &type metadata for String.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for String.UnicodeScalarView,  &type metadata for String.UnicodeScalarView,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for String.UnicodeScalarView,  &type metadata for String.UnicodeScalarView,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView);
  }

  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringInterpolation.StringInterpolation : StringInterpolationProtocol in String()
{
  return &protocol witness table for DefaultStringInterpolation;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type DefaultIndices<String.UnicodeScalarView> and conformance <> DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String.UnicodeScalarView>,  (uint64_t (*)(void))lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UnicodeScalarView,  &type metadata for Substring.UnicodeScalarView,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UnicodeScalarView,  &type metadata for Substring.UnicodeScalarView,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UnicodeScalarView,  &type metadata for Substring.UnicodeScalarView,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UnicodeScalarView,  &type metadata for Substring.UnicodeScalarView,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type DefaultIndices<String.UnicodeScalarView> and conformance DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String.UnicodeScalarView>,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UnicodeScalarView()
{
  return &protocol witness table for String.UnicodeScalarView.Iterator;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type DefaultIndices<String.UTF16View> and conformance <> DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String.UTF16View>,  (uint64_t (*)(void))lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UTF16View,  &type metadata for Substring.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UTF16View,  &type metadata for Substring.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UTF16View,  &type metadata for Substring.UTF16View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type DefaultIndices<String.UTF16View> and conformance DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String.UTF16View>,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UTF16View()
{
  return &protocol witness table for String.UTF16View.Iterator;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type DefaultIndices<String.UTF8View> and conformance <> DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String.UTF8View>,  (uint64_t (*)(void))lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UTF8View,  &type metadata for Substring.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UTF8View,  &type metadata for Substring.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Substring.UTF8View,  &type metadata for Substring.UTF8View,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type DefaultIndices<String.UTF8View> and conformance DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<String.UTF8View>,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<String.UTF8View> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<String.UTF8View>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in Substring()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type DefaultIndices<Substring> and conformance <> DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<Substring>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Substring and conformance Substring,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in Substring()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type DefaultIndices<Substring> and conformance DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<Substring>,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Substring> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Substring>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Substring.UTF8View> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Substring.UTF8View>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Substring.UTF16View> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Substring.UTF16View>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Substring.UnicodeScalarView> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Substring.UnicodeScalarView>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UIntBuffer<A>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _UIntBuffer<A>()
{
  return &protocol witness table for _UIntBuffer<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(L"D\r\r\u0AD5", a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._NFD()
{
  return &protocol witness table for Unicode._NFD.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._NFC()
{
  return &protocol witness table for Unicode._NFC.Iterator;
}

_UNKNOWN **_sSPyxGSxsRi_zrl6StrideSx_s13SignedNumericPWT()
{
  return &protocol witness table for Int;
}

unint64_t lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _ValidUTF8Buffer,  &type metadata for _ValidUTF8Buffer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _ValidUTF8Buffer,  &type metadata for _ValidUTF8Buffer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _ValidUTF8Buffer,  &type metadata for _ValidUTF8Buffer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _ValidUTF8Buffer,  &type metadata for _ValidUTF8Buffer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF8.ReverseParser,  &type metadata for Unicode.UTF8.ReverseParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF8.ReverseParser,  &type metadata for Unicode.UTF8.ReverseParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8 and conformance Unicode.UTF8( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF8,  &type metadata for Unicode.UTF8,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8);
  }

  return result;
}

uint64_t associated type witness table accessor for _UnicodeEncoding.EncodedScalar : BidirectionalCollection in Unicode.UTF16()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type _UIntBuffer<UInt16> and conformance _UIntBuffer<A>,  &demangling cache variable for type metadata for _UIntBuffer<UInt16>,  (uint64_t)&protocol conformance descriptor for _UIntBuffer<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF16.ReverseParser,  &type metadata for Unicode.UTF16.ReverseParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF16.ReverseParser,  &type metadata for Unicode.UTF16.ReverseParser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16 and conformance Unicode.UTF16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF16,  &type metadata for Unicode.UTF16,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>;
  if (!lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, &unk_189B86A98, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF32.Parser,  &type metadata for Unicode.UTF32.Parser,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF32 and conformance Unicode.UTF32( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32;
  if (!lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for Unicode.UTF32,  &type metadata for Unicode.UTF32,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF8( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.UTF8 and conformance Unicode.UTF8(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.UTF16 and conformance Unicode.UTF16(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF32( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.UTF32 and conformance Unicode.UTF32(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _ValidUTF8Buffer.Iterator()
{
  return &protocol witness table for _ValidUTF8Buffer.Iterator;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _ValidUTF8Buffer()
{
  return &protocol witness table for _ValidUTF8Buffer.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance <> DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for _ValidUTF8Buffer( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance <> DefaultIndices<A>,  &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in CollectionDifference<A>()
{
  return &protocol witness table for CollectionDifference<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for CollectionDifference<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> CollectionDifference<A>.Change( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> CollectionDifference<A>.Change, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> CollectionDifference<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8LL);
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> CollectionDifference<A>, a2, &v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int128()
{
  return &protocol witness table for Int128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Int128()
{
  return &protocol witness table for UInt128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Int128()
{
  return &protocol witness table for UInt128;
}

unint64_t lazy protocol witness table accessor for type UInt128 and conformance UInt128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt128, &type metadata for UInt128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt128, &type metadata for UInt128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt128, &type metadata for UInt128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt128.Words,  &type metadata for UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt128.Words,  &type metadata for UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt128.Words,  &type metadata for UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt128.Words,  &type metadata for UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type Int128 and conformance Int128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int128 and conformance Int128;
  if (!lazy protocol witness table cache variable for type Int128 and conformance Int128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int128, &type metadata for Int128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int128 and conformance Int128);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int128 and conformance Int128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for _SliceBuffer<A>,  (uint64_t)&protocol conformance descriptor for _SliceBuffer<A>);
}

{
  uint64_t result;
  unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a1 + 8) = swift_getWitnessTable(a4, a2, a3);
  uint64_t result = swift_getWitnessTable(a5, a2, v8);
  *(void *)(a1 + 16) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in StaticBigInt()
{
  return &protocol witness table for StaticBigInt;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt128()
{
  return &protocol witness table for UInt128;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt128.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt128.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt128.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UInt128.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<UInt128.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<UInt128.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt128 and conformance UInt128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnfoldSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for UnfoldSequence<A, B>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Zip2Sequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Zip2Sequence<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : FixedWidthInteger in SIMDMask<A>( uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 32);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : SignedInteger in SIMDMask<A>( uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 40);
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

unint64_t instantiation function for generic protocol witness table for Float16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Float16 and conformance Float16(a1, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Float16 and conformance Float16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Float16 and conformance Float16;
  if (!lazy protocol witness table cache variable for type Float16 and conformance Float16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Float16, &type metadata for Float16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Float16 and conformance Float16);
  }

  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Float16()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Float16()
{
  return &protocol witness table for Float16;
}

unint64_t instantiation function for generic protocol witness table for Float( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Float and conformance Float(a1, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Float and conformance Float( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Float and conformance Float;
  if (!lazy protocol witness table cache variable for type Float and conformance Float)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Float, &type metadata for Float, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Float and conformance Float);
  }

  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Float()
{
  return &protocol witness table for Float;
}

unint64_t instantiation function for generic protocol witness table for Double( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Double and conformance Double(a1, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Double and conformance Double( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Double and conformance Double;
  if (!lazy protocol witness table cache variable for type Double and conformance Double)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Double, &type metadata for Double, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Double and conformance Double);
  }

  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Double()
{
  return &protocol witness table for Double;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt8.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt8.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt8.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UInt8.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<UInt8.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<UInt8.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt8( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt8 and conformance UInt8(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt8()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt8()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt8()
{
  return &protocol witness table for UInt8;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int8.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int8.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int8.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<Int8.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Int8.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Int8.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int8 and conformance Int8( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int8( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int8 and conformance Int8(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int8()
{
  return &protocol witness table for Int8;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt16.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt16.Words,  &type metadata for UInt16.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt16.Words,  &type metadata for UInt16.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt16.Words,  &type metadata for UInt16.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt16.Words,  &type metadata for UInt16.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt16.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt16.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UInt16.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<UInt16.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<UInt16.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt16 and conformance UInt16(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt16()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt16()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt16()
{
  return &protocol witness table for UInt16;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int16.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int16.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int16.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<Int16.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Int16.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Int16.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int16 and conformance Int16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int16 and conformance Int16(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int16()
{
  return &protocol witness table for Int16;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt32.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt32.Words,  &type metadata for UInt32.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt32.Words,  &type metadata for UInt32.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt32.Words,  &type metadata for UInt32.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt32.Words,  &type metadata for UInt32.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt32.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt32.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UInt32.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<UInt32.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<UInt32.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt32( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt32()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt32()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt32()
{
  return &protocol witness table for UInt32;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int32.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int32.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int32.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<Int32.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Int32.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Int32.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int32 and conformance Int32( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int32( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int32 and conformance Int32(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int32()
{
  return &protocol witness table for Int32;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt64.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt64.Words,  &type metadata for UInt64.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt64.Words,  &type metadata for UInt64.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt64.Words,  &type metadata for UInt64.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UInt64.Words,  &type metadata for UInt64.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt64.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt64.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UInt64.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<UInt64.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<UInt64.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt64( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt64 and conformance UInt64(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt64()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt64()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt64()
{
  return &protocol witness table for UInt64;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int64.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int64.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int64.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<Int64.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Int64.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Int64.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Int64( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int64 and conformance Int64(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UInt.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UInt.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<UInt.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<UInt.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt and conformance UInt(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt()
{
  return &protocol witness table for UInt;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int.Words and conformance Int.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int.Words and conformance Int.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for Int.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<Int.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<Int.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int.Words and conformance Int.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<Int.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<Int.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<Int.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<Int.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Int( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int()
{
  return &protocol witness table for Int;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for UnsafeBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnsafeMutableRawBufferPointer()
{
  return &protocol witness table for UnsafeRawBufferPointer.Iterator;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeMutableRawBufferPointer,  &type metadata for UnsafeMutableRawBufferPointer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeMutableRawBufferPointer,  &type metadata for UnsafeMutableRawBufferPointer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeMutableRawBufferPointer,  &type metadata for UnsafeMutableRawBufferPointer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeMutableRawBufferPointer,  &type metadata for UnsafeMutableRawBufferPointer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }

  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for UnsafeMutableRawBufferPointer( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeRawBufferPointer,  &type metadata for UnsafeRawBufferPointer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeRawBufferPointer,  &type metadata for UnsafeRawBufferPointer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for UnsafeRawBufferPointer,  &type metadata for UnsafeRawBufferPointer,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for UnsafeRawBufferPointer( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer( a1,  a2,  a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>,  (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a1, a3);
}

unint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : FixedWidthInteger in SIMD2<A>( uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a2 + 24),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMDMaskScalar: FixedWidthInteger);
}

unint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : SignedInteger in SIMD2<A>( uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness( *(void *)(a2 + 24),  *(void *)(a2 + 16),  a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMDMaskScalar: SignedInteger);
}

uint64_t instantiation function for generic protocol witness table for SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD2<A>,  (uint64_t)&protocol conformance descriptor for SIMD2<A>);
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>( a1,  a2,  a3,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Decodable);
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Encodable in SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>( a1,  a2,  a3,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Encodable);
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Hashable in SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>( a1,  a2,  a3,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD4<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD4<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD4<A>,  (uint64_t)&protocol conformance descriptor for SIMD4<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD8<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD8<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD8<A>,  (uint64_t)&protocol conformance descriptor for SIMD8<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD16<A>,  (uint64_t)&protocol conformance descriptor for SIMD16<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD32<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD32<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD32<A>,  (uint64_t)&protocol conformance descriptor for SIMD32<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD64<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD64<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD64<A>,  (uint64_t)&protocol conformance descriptor for SIMD64<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD3<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD3<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMD3<A>,  (uint64_t)&protocol conformance descriptor for SIMD3<A>);
}

uint64_t instantiation function for generic protocol witness table for SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a1 + 32) = swift_getWitnessTable(a4, a2, a3);
  uint64_t result = swift_getWitnessTable(a5, a2, v8);
  *(void *)(a1 + 48) = result;
  return result;
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  return swift_getAssociatedConformanceWitness( AssociatedConformanceWitness,  AssociatedTypeWitness,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  a4);
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD8Storage;
}

uint64_t sub_181710250()
{
  return 8LL;
}

void *sub_18171025C(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_181710268()
{
  return 8LL;
}

uint64_t sub_181710274()
{
  return 8LL;
}

uint64_t sub_181710280()
{
  return 8LL;
}

uint64_t sub_18171028C()
{
  return 8LL;
}

uint64_t sub_181710298()
{
  return 8LL;
}

uint64_t sub_1817102A4()
{
  return 8LL;
}

uint64_t sub_1817102B0()
{
  return 8LL;
}

uint64_t sub_1817102BC()
{
  return 8LL;
}

uint64_t sub_1817102C8()
{
  return 8LL;
}

uint64_t sub_1817102D4()
{
  return 8LL;
}

uint64_t sub_1817102E0()
{
  return 8LL;
}

uint64_t sub_1817102EC()
{
  return 8LL;
}

uint64_t sub_1817102F8()
{
  return 8LL;
}

uint64_t sub_181710304()
{
  return 8LL;
}

uint64_t sub_181710310()
{
  return 24LL;
}

__n128 sub_18171031C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181710330()
{
  return 24LL;
}

__n128 sub_18171033C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181710350()
{
  return 24LL;
}

__n128 sub_18171035C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181710370()
{
  return 24LL;
}

__n128 sub_18171037C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181710390()
{
  return 24LL;
}

__n128 sub_18171039C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1817103B0()
{
  return 24LL;
}

__n128 sub_1817103BC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1817103D0()
{
  return 24LL;
}

__n128 sub_1817103DC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1817103F0()
{
  return 16LL;
}

__n128 sub_1817103FC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710408()
{
  return 8LL;
}

uint64_t sub_181710414()
{
  return 8LL;
}

uint64_t sub_181710420()
{
  return 16LL;
}

__n128 sub_18171042C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710438()
{
  return 16LL;
}

__n128 sub_181710444(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710450()
{
  return 16LL;
}

__n128 sub_18171045C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710468()
{
  return 16LL;
}

__n128 sub_181710474(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710480()
{
  return 24LL;
}

__n128 sub_18171048C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1817104A0()
{
  return 32LL;
}

__n128 sub_1817104AC(uint64_t a1, _OWORD *a2)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

uint64_t sub_1817104B8()
{
  return 16LL;
}

__n128 sub_1817104C4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817104D0()
{
  return 16LL;
}

__n128 sub_1817104DC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817104E8()
{
  return 16LL;
}

__n128 sub_1817104F4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710500()
{
  return 16LL;
}

__n128 sub_18171050C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710518()
{
  return 16LL;
}

__n128 sub_181710524(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710530()
{
  return 0LL;
}

uint64_t sub_181710540()
{
  return 0LL;
}

uint64_t sub_181710550()
{
  return 8LL;
}

uint64_t sub_18171055C()
{
  return 8LL;
}

uint64_t sub_181710568()
{
  return 8LL;
}

uint64_t sub_181710574()
{
  return 8LL;
}

uint64_t sub_181710580()
{
  return 8LL;
}

uint64_t sub_18171058C()
{
  return 8LL;
}

uint64_t sub_181710598()
{
  return 8LL;
}

uint64_t sub_1817105A4()
{
  return 8LL;
}

uint64_t sub_1817105B0()
{
  return 8LL;
}

uint64_t sub_1817105BC()
{
  return 32LL;
}

__n128 sub_1817105C8(uint64_t a1, _OWORD *a2)
{
  __n128 result = *(__n128 *)a1;
  __int128 v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

uint64_t sub_1817105D4()
{
  return 8LL;
}

uint64_t sub_1817105E0()
{
  return 8LL;
}

uint64_t sub_1817105EC()
{
  return 8LL;
}

uint64_t sub_1817105F8()
{
  return 0LL;
}

uint64_t sub_181710608()
{
  return 0LL;
}

uint64_t sub_181710618()
{
  return 0LL;
}

uint64_t sub_181710628()
{
  return 0LL;
}

uint64_t sub_181710638()
{
  return 16LL;
}

__n128 sub_181710644(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710650()
{
  return 16LL;
}

__n128 sub_18171065C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710668()
{
  return 16LL;
}

__n128 sub_181710674(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710680()
{
  return 16LL;
}

__n128 sub_18171068C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710698()
{
  return 16LL;
}

__n128 sub_1817106A4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817106B0()
{
  return 16LL;
}

__n128 sub_1817106BC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817106C8()
{
  return 16LL;
}

__n128 sub_1817106D4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817106E0()
{
  return 16LL;
}

__n128 sub_1817106EC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817106F8()
{
  return 16LL;
}

__n128 sub_181710704(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710710()
{
  return 16LL;
}

__n128 sub_18171071C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710728()
{
  return 16LL;
}

__n128 sub_181710734(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710740()
{
  return 16LL;
}

__n128 sub_18171074C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710758()
{
  return 16LL;
}

__n128 sub_181710764(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710770()
{
  return 16LL;
}

__n128 sub_18171077C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710788()
{
  return 16LL;
}

__n128 sub_181710794(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817107A0()
{
  return 16LL;
}

__n128 sub_1817107AC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817107B8()
{
  return 16LL;
}

__n128 sub_1817107C4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817107D0()
{
  return 16LL;
}

__n128 sub_1817107DC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817107E8()
{
  return 16LL;
}

__n128 sub_1817107F4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710800()
{
  return 16LL;
}

__n128 sub_18171080C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710818()
{
  return 16LL;
}

__n128 sub_181710824(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710830()
{
  return 16LL;
}

__n128 sub_18171083C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710848()
{
  return 16LL;
}

__n128 sub_181710854(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710860()
{
  return 16LL;
}

__n128 sub_18171086C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710878()
{
  return 16LL;
}

__n128 sub_181710884(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710890()
{
  return 16LL;
}

__n128 sub_18171089C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817108A8()
{
  return 16LL;
}

__n128 sub_1817108B4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817108C0()
{
  return 16LL;
}

__n128 sub_1817108CC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817108D8()
{
  return 16LL;
}

__n128 sub_1817108E4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1817108F0()
{
  return 16LL;
}

__n128 sub_1817108FC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710908()
{
  return 16LL;
}

__n128 sub_181710914(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710920()
{
  return 16LL;
}

__n128 sub_18171092C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710938()
{
  return 16LL;
}

__n128 sub_181710944(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710950()
{
  return 16LL;
}

__n128 sub_18171095C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710968()
{
  return 16LL;
}

__n128 sub_181710974(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710980()
{
  return 16LL;
}

__n128 sub_18171098C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181710998()
{
  return 0LL;
}

uint64_t sub_1817109A8()
{
  return 0LL;
}

uint64_t sub_1817109B8()
{
  return 0LL;
}

uint64_t sub_1817109C8()
{
  return 0LL;
}

uint64_t sub_1817109D8()
{
  return 0LL;
}

uint64_t sub_1817109E8()
{
  return 0LL;
}

uint64_t sub_1817109F8()
{
  return 0LL;
}

uint64_t sub_181710A08()
{
  return 0LL;
}

uint64_t sub_181710A18()
{
  return 0LL;
}

uint64_t sub_181710A28()
{
  return 0LL;
}

uint64_t sub_181710A38()
{
  return 0LL;
}

uint64_t sub_181710A48()
{
  return 0LL;
}

uint64_t sub_181710A58()
{
  return 0LL;
}

uint64_t sub_181710A68()
{
  return 0LL;
}

uint64_t sub_181710A78()
{
  return 0LL;
}

uint64_t sub_181710A88()
{
  return 0LL;
}

uint64_t sub_181710A98()
{
  return 0LL;
}

uint64_t sub_181710AA8()
{
  return 0LL;
}

uint64_t sub_181710AB8()
{
  return 0LL;
}

uint64_t sub_181710AC8()
{
  return 0LL;
}

uint64_t sub_181710AD8()
{
  return 0LL;
}

uint64_t sub_181710AE8()
{
  return 0LL;
}

uint64_t sub_181710AF8()
{
  return 0LL;
}

uint64_t sub_181710B08()
{
  return 0LL;
}

uint64_t sub_181710B18()
{
  return 0LL;
}

uint64_t sub_181710B28()
{
  return 0LL;
}

uint64_t sub_181710B38()
{
  return 0LL;
}

uint64_t sub_181710B48()
{
  return 0LL;
}

uint64_t sub_181710B58()
{
  return 0LL;
}

uint64_t sub_181710B68()
{
  return 0LL;
}

uint64_t sub_181710B78()
{
  return 0LL;
}

uint64_t sub_181710B88()
{
  return 0LL;
}

uint64_t sub_181710B98()
{
  return 0LL;
}

uint64_t sub_181710BA8()
{
  return 0LL;
}

uint64_t sub_181710BB8()
{
  return 0LL;
}

uint64_t sub_181710BC8()
{
  return 0LL;
}

uint64_t sub_181710BD8()
{
  return 0LL;
}

uint64_t sub_181710BE8()
{
  return 0LL;
}

uint64_t sub_181710BF8()
{
  return 0LL;
}

uint64_t sub_181710C08()
{
  return 0LL;
}

uint64_t sub_181710C18()
{
  return 0LL;
}

uint64_t sub_181710C28()
{
  return 0LL;
}

uint64_t sub_181710C38()
{
  return 0LL;
}

uint64_t sub_181710C48()
{
  return 0LL;
}

uint64_t sub_181710C58()
{
  return 0LL;
}

uint64_t sub_181710C68()
{
  return 0LL;
}

uint64_t sub_181710C78()
{
  return 0LL;
}

uint64_t sub_181710C88()
{
  return 0LL;
}

uint64_t sub_181710C98()
{
  return 0LL;
}

uint64_t sub_181710CA8()
{
  return 0LL;
}

uint64_t sub_181710CB8()
{
  return 0LL;
}

uint64_t sub_181710CC8()
{
  return 0LL;
}

uint64_t sub_181710CD8()
{
  return 0LL;
}

uint64_t sub_181710CE8()
{
  return 0LL;
}

uint64_t sub_181710CF8()
{
  return 0LL;
}

uint64_t sub_181710D08()
{
  return 0LL;
}

uint64_t sub_181710D18()
{
  return 0LL;
}

uint64_t sub_181710D28()
{
  return 0LL;
}

uint64_t sub_181710D38()
{
  return 0LL;
}

uint64_t sub_181710D48()
{
  return 0LL;
}

uint64_t sub_181710D58()
{
  return 0LL;
}

uint64_t sub_181710D68()
{
  return 0LL;
}

uint64_t sub_181710D78()
{
  return 0LL;
}

uint64_t sub_181710D88()
{
  return 0LL;
}

uint64_t sub_181710D98()
{
  return 0LL;
}

uint64_t sub_181710DA8()
{
  return 0LL;
}

uint64_t sub_181710DB8()
{
  return 0LL;
}

uint64_t sub_181710DC8()
{
  return 0LL;
}

uint64_t sub_181710DD8()
{
  return 0LL;
}

uint64_t sub_181710DE8()
{
  return 0LL;
}

uint64_t sub_181710DF8()
{
  return 0LL;
}

uint64_t sub_181710E08()
{
  return 0LL;
}

uint64_t sub_181710E18()
{
  return 0LL;
}

uint64_t sub_181710E28()
{
  return 0LL;
}

uint64_t sub_181710E38()
{
  return 0LL;
}

uint64_t sub_181710E48()
{
  return 0LL;
}

uint64_t sub_181710E58()
{
  return 0LL;
}

uint64_t sub_181710E68()
{
  return 0LL;
}

uint64_t type metadata instantiation function for EnumeratedSequence(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x20);
}

unint64_t type metadata completion function for EnumeratedSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  (uint64_t)&value witness table for Builtin.Int64.size);
}

unint64_t **initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t destroy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

void storeEnumTagSinglePayload for EnumeratedSequence.Iterator( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

ValueMetadata *type metadata accessor for _ArrayBody()
{
  return &type metadata for _ArrayBody;
}

uint64_t type metadata instantiation function for _ArrayBuffer(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x18);
}

uint64_t dispatch thunk of _ArrayBufferProtocol.init(_buffer:shiftedToStartIndex:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.init(copying:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol._copyContents(subRange:initializing:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.requestNativeBuffer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void))(a8 + 80))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.subscript.getter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 96))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 104))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.count.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.count.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.subscriptBaseAddress.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.identity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

ValueMetadata *type metadata accessor for _DependenceToken()
{
  return &type metadata for _DependenceToken;
}

__n128 __swift_memcpy32_8(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t assignWithTake for ArraySlice(uint64_t a1, _OWORD *a2)
{
  __int128 v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  return a1;
}

uint64_t dispatch thunk of _ArrayProtocol._owner.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of _ArrayProtocol.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

ValueMetadata *type metadata accessor for Unicode.ASCII()
{
  return &type metadata for Unicode.ASCII;
}

ValueMetadata *type metadata accessor for Unicode.ASCII.Parser()
{
  return &type metadata for Unicode.ASCII.Parser;
}

uint64_t default associated conformance accessor for BidirectionalCollection.Collection.Indices: BidirectionalCollection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &v4);
}

uint64_t default associated conformance accessor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t dispatch thunk of BidirectionalCollection.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of BidirectionalCollection.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of BidirectionalCollection.index(_:offsetBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of BidirectionalCollection.index(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 56))();
}

uint64_t dispatch thunk of BidirectionalCollection.distance(from:to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

ValueMetadata *type metadata accessor for _UnsafeBitset()
{
  return &type metadata for _UnsafeBitset;
}

ValueMetadata *type metadata accessor for _UnsafeBitset.Iterator()
{
  return &type metadata for _UnsafeBitset.Iterator;
}

ValueMetadata *type metadata accessor for _UnsafeBitset.Word()
{
  return &type metadata for _UnsafeBitset.Word;
}

_BYTE *__swift_memcpy1_1(_BYTE *result, _BYTE *a2)
{
  *__n128 result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for Bool()
{
  return &type metadata for Bool;
}

uint64_t dispatch thunk of static _ObjectiveCBridgeable._unconditionallyBridgeFromObjectiveC(_:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

void *__swift_memcpy8_8(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for _BridgeableMetatype()
{
  return &type metadata for _BridgeableMetatype;
}

uint64_t type metadata accessor for _BridgeStorage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _BridgeStorage);
}

void *initializeBufferWithCopyOfBuffer for Character(void *a1, void *a2, uint64_t a3, char *a4)
{
  unint64_t v5 = a2[1];
  *a1 = *a2;
  a1[1] = v5;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  return a1;
}

void destroy for Character(uint64_t a1)
{
}

void *assignWithTake for Character(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = a1[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

ValueMetadata *type metadata accessor for Character()
{
  return &type metadata for Character;
}

ValueMetadata *type metadata accessor for _CocoaArrayWrapper()
{
  return &type metadata for _CocoaArrayWrapper;
}

uint64_t dispatch thunk of Encodable.encode(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of Decodable.init(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of CodingKey.stringValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of CodingKey.intValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of CodingKey.init(intValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of Encoder.container<A>(keyedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of Encoder.unkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Encoder.singleValueContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of Decoder.container<A>(keyedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of Decoder.unkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Decoder.singleValueContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeNil(forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

{
  return (*(uint64_t (**)(void))(a4 + 120))();
}

{
  return (*(uint64_t (**)(void))(a4 + 128))();
}

{
  return (*(uint64_t (**)(void))(a4 + 136))();
}

{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

{
  return (*(uint64_t (**)(void))(a5 + 112))();
}

{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 168))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeConditional<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 176))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 184))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 192))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 200))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 216))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 248))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 264))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 296))(a1, a2 & 1);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(unint64_t))(a4 + 208))(a1 | ((HIDWORD(a1) & 1) << 32));
}

{
  return (*(uint64_t (**)(unint64_t))(a4 + 240))(a1 | ((HIDWORD(a1) & 1) << 32));
}

{
  return (*(uint64_t (**)(unint64_t))(a4 + 288))(a1 | ((HIDWORD(a1) & 1) << 32));
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( __int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 224))(a1 & 0x1FF);
}

{
  return (*(uint64_t (**)(void))(a4 + 272))(a1 & 0x1FF);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 232))(a1 & 0x1FFFF);
}

{
  return (*(uint64_t (**)(void))(a4 + 280))(a1 & 0x1FFFF);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a6 + 256))(a1, a2, a3 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a6 + 304))(a1, a2, a3 & 1);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 312))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 320))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.nestedUnkeyedContainer(forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 328))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.superEncoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 336))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.superEncoder(forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 344))();
}

uint64_t type metadata accessor for KeyedEncodingContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for KeyedEncodingContainer);
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeNil(forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))() & 1;
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decode(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))() & 1;
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

{
  return (*(uint64_t (**)(void))(a3 + 152))();
}

{
  return (*(uint64_t (**)(void))(a3 + 160))();
}

{
  return (*(uint64_t (**)(void))(a3 + 168))();
}

{
  return (*(uint64_t (**)(void))(a3 + 176))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decode<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 184))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 192))();
}

{
  return (*(uint64_t (**)(void))(a3 + 200))();
}

{
  return (*(uint64_t (**)(void))(a3 + 208))();
}

{
  unint64_t v3;
  uint64_t v3 = (*(uint64_t (**)(void))(a3 + 216))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 224))();
}

{
  return (*(uint64_t (**)(void))(a3 + 232))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a3 + 240))() & 0x1FFFF;
}

{
  unint64_t v3;
  uint64_t v3 = (*(uint64_t (**)(void))(a3 + 248))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 256))();
}

{
  return (*(uint64_t (**)(void))(a3 + 264))();
}

{
  return (*(uint64_t (**)(void))(a3 + 272))();
}

{
  return (*(uint64_t (**)(void))(a3 + 280))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a3 + 288))() & 0x1FFFF;
}

{
  unint64_t v3;
  uint64_t v3 = (*(uint64_t (**)(void))(a3 + 296))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 304))();
}

{
  return (*(uint64_t (**)(void))(a3 + 312))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 320))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 328))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.nestedUnkeyedContainer(forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 336))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.superDecoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 344))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.superDecoder(forKey:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 352))();
}

uint64_t type metadata accessor for KeyedDecodingContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for KeyedDecodingContainer);
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encodeConditional<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 168))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(contentsOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 176))();
}

{
  return (*(uint64_t (**)(void))(a5 + 184))();
}

{
  return (*(uint64_t (**)(void))(a5 + 192))();
}

{
  return (*(uint64_t (**)(void))(a5 + 200))();
}

{
  return (*(uint64_t (**)(void))(a5 + 208))();
}

{
  return (*(uint64_t (**)(void))(a5 + 216))();
}

{
  return (*(uint64_t (**)(void))(a5 + 224))();
}

{
  return (*(uint64_t (**)(void))(a5 + 232))();
}

{
  return (*(uint64_t (**)(void))(a5 + 240))();
}

{
  return (*(uint64_t (**)(void))(a5 + 248))();
}

{
  return (*(uint64_t (**)(void))(a5 + 256))();
}

{
  return (*(uint64_t (**)(void))(a5 + 264))();
}

{
  return (*(uint64_t (**)(void))(a5 + 272))();
}

{
  return (*(uint64_t (**)(void))(a5 + 280))();
}

{
  return (*(uint64_t (**)(void))(a5 + 288))();
}

{
  return (*(uint64_t (**)(void))(a5 + 296))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(contentsOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 304))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.nestedContainer<A>(keyedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 312))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.nestedUnkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 320))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.superEncoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.isAtEnd.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.currentIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))() & 1;
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))() & 1;
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 176))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeIfPresent(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 184))();
}

{
  return (*(uint64_t (**)(void))(a2 + 192))();
}

{
  return (*(uint64_t (**)(void))(a2 + 200))();
}

{
  unint64_t v2;
  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 208))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 216))();
}

{
  return (*(uint64_t (**)(void))(a2 + 224))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a2 + 232))() & 0x1FFFF;
}

{
  unint64_t v2;
  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 240))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 248))();
}

{
  return (*(uint64_t (**)(void))(a2 + 256))();
}

{
  return (*(uint64_t (**)(void))(a2 + 264))();
}

{
  return (*(uint64_t (**)(void))(a2 + 272))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a2 + 280))() & 0x1FFFF;
}

{
  unint64_t v2;
  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 288))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 296))();
}

{
  return (*(uint64_t (**)(void))(a2 + 304))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeIfPresent<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 312))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.nestedContainer<A>(keyedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 320))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.nestedUnkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.superDecoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 336))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 152))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))() & 1;
}

{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 152))();
}

ValueMetadata *type metadata accessor for CodingUserInfoKey()
{
  return &type metadata for CodingUserInfoKey;
}

void destroy for EncodingError(uint64_t a1)
{
}

void *initializeWithCopy for EncodingError(void *a1, void *a2)
{
  uint64_t v4 = a2[3];
  a1[3] = v4;
  (**(void (***)(void))(v4 - 8))();
  unint64_t v5 = a2[4];
  uint64_t v6 = a2[5];
  a1[4] = v5;
  a1[5] = v6;
  unint64_t v8 = a2[6];
  uint64_t v7 = (void *)a2[7];
  a1[6] = v8;
  swift_bridgeObjectRetain(v5, v9, v10, v11);
  swift_bridgeObjectRetain(v8, v12, v13, v14);
  swift_errorRetain(v7);
  a1[7] = v7;
  return a1;
}

uint64_t *assignWithCopy for EncodingError(uint64_t *a1, void *a2, uint64_t a3, char *a4)
{
  unint64_t v6 = a2[4];
  uint64_t v7 = a1[4];
  a1[4] = v6;
  swift_bridgeObjectRetain(v6, v8, v9, v10);
  swift_bridgeObjectRelease(v7);
  a1[5] = a2[5];
  unint64_t v11 = a2[6];
  uint64_t v12 = a1[6];
  a1[6] = v11;
  swift_bridgeObjectRetain(v11, v13, v14, v15);
  swift_bridgeObjectRelease(v12);
  uint64_t v16 = (void *)a1[7];
  uint64_t v17 = (void *)a2[7];
  swift_errorRetain(v17);
  a1[7] = (uint64_t)v17;
  swift_errorRelease(v16);
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_0(uint64_t *result, uint64_t a2, uint64_t a3, char *a4)
{
  if (result != (uint64_t *)a2)
  {
    unint64_t v5 = result;
    uint64_t v6 = result[3];
    uint64_t v7 = *(void *)(a2 + 24);
    if (v6 == v7)
    {
      uint64_t v14 = *(void *)(v6 - 8);
      if ((*(_BYTE *)(v14 + 82) & 2) != 0)
      {
        uint64_t v16 = *result;
        uint64_t v17 = *(unint64_t **)a2;
        swift_retain(*(unint64_t **)a2, a2, a3, a4);
        __n128 result = (uint64_t *)swift_release(v16);
        *unint64_t v5 = v17;
      }

      else
      {
        return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v14 + 24))(result, a2, result[3]);
      }
    }

    else
    {
      result[3] = v7;
      uint64_t v8 = *(void *)(v6 - 8);
      uint64_t v9 = *(void *)(v7 - 8);
      int v10 = *(_DWORD *)(v9 + 80);
      if ((*(_BYTE *)(v8 + 82) & 2) != 0)
      {
        uint64_t v15 = *result;
        if ((v10 & 0x20000) != 0)
        {
          uint64_t v19 = *(unint64_t **)a2;
          *unint64_t v5 = *(void *)a2;
          swift_retain(v19, a2, a3, a4);
        }

        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t))(v9 + 16))(result, a2, v7);
        }

        return (uint64_t *)swift_release(v15);
      }

      else
      {
        (*(void (**)(_BYTE *, uint64_t *, uint64_t))(v8 + 32))(v20, result, v6);
        if ((v10 & 0x20000) != 0)
        {
          uint64_t v18 = *(unint64_t **)a2;
          *unint64_t v5 = *(void *)a2;
          swift_retain(v18, v11, v12, v13);
        }

        else
        {
          (*(void (**)(void *, uint64_t, uint64_t))(v9 + 16))(v5, a2, v7);
        }

        return (uint64_t *)(*(uint64_t (**)(_BYTE *, uint64_t))(v8 + 8))(v20, v6);
      }
    }
  }

  return result;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for EncodingError(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_bridgeObjectRelease(v5);
  uint64_t v6 = *(void *)(a2 + 48);
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v6;
  swift_bridgeObjectRelease(v7);
  uint64_t v8 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  swift_errorRelease(v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for EncodingError(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 64)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for EncodingError(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 56) = 0LL;
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 64) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 64) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for EncodingError()
{
  return &type metadata for EncodingError;
}

ValueMetadata *type metadata accessor for EncodingError.Context()
{
  return &type metadata for EncodingError.Context;
}

void destroy for DecodingError(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 72);
  while (2)
  {
    switch(v2)
    {
      case 0:
      case 1:
        swift_bridgeObjectRelease(*(void *)(a1 + 8));
        swift_bridgeObjectRelease(*(void *)(a1 + 24));
        __int128 v3 = (id *)(a1 + 32);
        break;
      case 2:
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
        swift_bridgeObjectRelease(*(void *)(a1 + 40));
        swift_bridgeObjectRelease(*(void *)(a1 + 56));
        __int128 v3 = (id *)(a1 + 64);
        break;
      case 3:
        swift_bridgeObjectRelease(*(void *)a1);
        swift_bridgeObjectRelease(*(void *)(a1 + 16));
        __int128 v3 = (id *)(a1 + 24);
        break;
      default:
        int v2 = *(_DWORD *)a1 + 4;
        continue;
    }

    break;
  }

  swift_errorRelease(*v3);
}

uint64_t initializeWithCopy for DecodingError(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  int v6 = *(unsigned __int8 *)(a2 + 72);
  while (2)
  {
    switch(v6)
    {
      case 0:
        unint64_t v7 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v7;
        unint64_t v8 = *(void *)(a2 + 24);
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        *(void *)(a1 + 24) = v8;
        uint64_t v9 = *(void **)(a2 + 32);
        swift_bridgeObjectRetain(v7, a2, a3, a4);
        swift_bridgeObjectRetain(v8, v10, v11, v12);
        swift_errorRetain(v9);
        char v13 = 0;
        *(void *)(a1 + 32) = v9;
        break;
      case 1:
        unint64_t v32 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v32;
        unint64_t v33 = *(void *)(a2 + 24);
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        *(void *)(a1 + 24) = v33;
        uint64_t v34 = *(void **)(a2 + 32);
        swift_bridgeObjectRetain(v32, a2, a3, a4);
        swift_bridgeObjectRetain(v33, v35, v36, v37);
        swift_errorRetain(v34);
        *(void *)(a1 + 32) = v34;
        char v13 = 1;
        break;
      case 2:
        __int128 v14 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 24) = v14;
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        unint64_t v15 = *(void *)(a2 + 40);
        uint64_t v16 = *(void *)(a2 + 48);
        *(void *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v15;
        *(void *)(a1 + 48) = v16;
        unint64_t v18 = *(void *)(a2 + 56);
        uint64_t v17 = *(void **)(a2 + 64);
        *(void *)(a1 + 56) = v18;
        swift_bridgeObjectRetain(v15, v19, v20, v21);
        swift_bridgeObjectRetain(v18, v22, v23, v24);
        swift_errorRetain(v17);
        *(void *)(a1 + 64) = v17;
        char v13 = 2;
        break;
      case 3:
        unint64_t v25 = *(void *)a2;
        uint64_t v26 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v26;
        unint64_t v28 = *(void *)(a2 + 16);
        uint64_t v27 = *(void **)(a2 + 24);
        *(void *)(a1 + 16) = v28;
        swift_bridgeObjectRetain(v25, a2, a3, a4);
        swift_bridgeObjectRetain(v28, v29, v30, v31);
        swift_errorRetain(v27);
        *(void *)(a1 + 24) = v27;
        char v13 = 3;
        break;
      default:
        int v6 = *(_DWORD *)a2 + 4;
        continue;
    }

    break;
  }

  *(_BYTE *)(a1 + 72) = v13;
  return a1;
}

uint64_t assignWithCopy for DecodingError(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(unsigned __int8 *)(a1 + 72);
    while (2)
    {
      switch(v4)
      {
        case 0:
        case 1:
          swift_bridgeObjectRelease(*(void *)(a1 + 8));
          swift_bridgeObjectRelease(*(void *)(a1 + 24));
          uint64_t v5 = (id *)(a1 + 32);
          break;
        case 2:
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
          swift_bridgeObjectRelease(*(void *)(a1 + 40));
          swift_bridgeObjectRelease(*(void *)(a1 + 56));
          uint64_t v5 = (id *)(a1 + 64);
          break;
        case 3:
          swift_bridgeObjectRelease(*(void *)a1);
          swift_bridgeObjectRelease(*(void *)(a1 + 16));
          uint64_t v5 = (id *)(a1 + 24);
          break;
        default:
          int v4 = *(_DWORD *)a1 + 4;
          continue;
      }

      break;
    }

    swift_errorRelease(*v5);
    int v9 = *(unsigned __int8 *)(a2 + 72);
    while (2)
    {
      switch(v9)
      {
        case 0:
          *(void *)a1 = *(void *)a2;
          unint64_t v10 = *(void *)(a2 + 8);
          *(void *)(a1 + 8) = v10;
          *(void *)(a1 + 16) = *(void *)(a2 + 16);
          unint64_t v11 = *(void *)(a2 + 24);
          *(void *)(a1 + 24) = v11;
          uint64_t v12 = *(void **)(a2 + 32);
          swift_bridgeObjectRetain(v10, v6, v7, v8);
          swift_bridgeObjectRetain(v11, v13, v14, v15);
          swift_errorRetain(v12);
          char v16 = 0;
          *(void *)(a1 + 32) = v12;
          break;
        case 1:
          *(void *)a1 = *(void *)a2;
          unint64_t v17 = *(void *)(a2 + 8);
          *(void *)(a1 + 8) = v17;
          *(void *)(a1 + 16) = *(void *)(a2 + 16);
          unint64_t v18 = *(void *)(a2 + 24);
          *(void *)(a1 + 24) = v18;
          uint64_t v19 = *(void **)(a2 + 32);
          swift_bridgeObjectRetain(v17, v6, v7, v8);
          swift_bridgeObjectRetain(v18, v20, v21, v22);
          swift_errorRetain(v19);
          *(void *)(a1 + 32) = v19;
          char v16 = 1;
          break;
        case 2:
          uint64_t v23 = *(void *)(a2 + 24);
          *(void *)(a1 + 24) = v23;
          *(void *)(a1 + 32) = *(void *)(a2 + 32);
          (**(void (***)(uint64_t, uint64_t))(v23 - 8))(a1, a2);
          unint64_t v24 = *(void *)(a2 + 40);
          *(void *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v24;
          *(void *)(a1 + 48) = *(void *)(a2 + 48);
          unint64_t v25 = *(void *)(a2 + 56);
          *(void *)(a1 + 56) = v25;
          uint64_t v26 = *(void **)(a2 + 64);
          swift_bridgeObjectRetain(v24, v27, v28, v29);
          swift_bridgeObjectRetain(v25, v30, v31, v32);
          swift_errorRetain(v26);
          *(void *)(a1 + 64) = v26;
          char v16 = 2;
          break;
        case 3:
          unint64_t v33 = *(void *)a2;
          *(void *)a1 = *(void *)a2;
          *(void *)(a1 + 8) = *(void *)(a2 + 8);
          unint64_t v34 = *(void *)(a2 + 16);
          *(void *)(a1 + 16) = v34;
          uint64_t v35 = *(void **)(a2 + 24);
          swift_bridgeObjectRetain(v33, v6, v7, v8);
          swift_bridgeObjectRetain(v34, v36, v37, v38);
          swift_errorRetain(v35);
          *(void *)(a1 + 24) = v35;
          char v16 = 3;
          break;
        default:
          int v9 = *(_DWORD *)a2 + 4;
          continue;
      }

      break;
    }

    *(_BYTE *)(a1 + 72) = v16;
  }

  return a1;
}

__n128 __swift_memcpy73_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 57) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t assignWithTake for DecodingError(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(unsigned __int8 *)(a1 + 72);
    while (2)
    {
      switch(v4)
      {
        case 0:
        case 1:
          swift_bridgeObjectRelease(*(void *)(a1 + 8));
          swift_bridgeObjectRelease(*(void *)(a1 + 24));
          uint64_t v5 = (id *)(a1 + 32);
          break;
        case 2:
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
          swift_bridgeObjectRelease(*(void *)(a1 + 40));
          swift_bridgeObjectRelease(*(void *)(a1 + 56));
          uint64_t v5 = (id *)(a1 + 64);
          break;
        case 3:
          swift_bridgeObjectRelease(*(void *)a1);
          swift_bridgeObjectRelease(*(void *)(a1 + 16));
          uint64_t v5 = (id *)(a1 + 24);
          break;
        default:
          int v4 = *(_DWORD *)a1 + 4;
          continue;
      }

      break;
    }

    swift_errorRelease(*v5);
    int v6 = *(unsigned __int8 *)(a2 + 72);
    while (2)
    {
      switch(v6)
      {
        case 0:
          char v7 = 0;
          __int128 v8 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v8;
          *(void *)(a1 + 32) = *(void *)(a2 + 32);
          break;
        case 1:
          __int128 v9 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v9;
          *(void *)(a1 + 32) = *(void *)(a2 + 32);
          char v7 = 1;
          break;
        case 2:
          __int128 v10 = *(_OWORD *)(a2 + 48);
          *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
          *(_OWORD *)(a1 + 48) = v10;
          *(void *)(a1 + 64) = *(void *)(a2 + 64);
          __int128 v11 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v11;
          char v7 = 2;
          break;
        case 3:
          __int128 v12 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v12;
          char v7 = 3;
          break;
        default:
          int v6 = *(_DWORD *)a2 + 4;
          continue;
      }

      break;
    }

    *(_BYTE *)(a1 + 72) = v7;
  }

  return a1;
}

uint64_t getEnumTagSinglePayload for DecodingError(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFD && *(_BYTE *)(a1 + 73)) {
    return (*(_DWORD *)a1 + 253);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 72);
  if (v3 >= 4) {
    return (v3 ^ 0xFF) + 1;
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for DecodingError(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_OWORD *)(result + 57) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)__n128 result = a2 - 253;
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 73) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 73) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 72) = -(char)a2;
    }
  }

  return result;
}

uint64_t getEnumTag for DecodingError(uint64_t a1)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 72);
  return result;
}

uint64_t destructiveInjectEnumTag for DecodingError(uint64_t result, unsigned int a2)
{
  if (a2 > 3)
  {
    *(void *)(result + 64) = 0LL;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)uint64_t result = a2 - 4;
    LOBYTE(a2) = 4;
  }

  *(_BYTE *)(result + 72) = a2;
  return result;
}

ValueMetadata *type metadata accessor for DecodingError()
{
  return &type metadata for DecodingError;
}

void destroy for EncodingError.Context(uint64_t a1)
{
}

unint64_t *initializeWithCopy for EncodingError.Context( unint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  *a1 = *a2;
  a1[1] = v6;
  unint64_t v7 = a2[2];
  __int128 v8 = (void *)a2[3];
  a1[2] = v7;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRetain(v7, v9, v10, v11);
  swift_errorRetain(v8);
  a1[3] = (unint64_t)v8;
  return a1;
}

uint64_t *assignWithCopy for EncodingError.Context(uint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *a2;
  uint64_t v7 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v6, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  a1[1] = a2[1];
  unint64_t v8 = a2[2];
  uint64_t v9 = a1[2];
  a1[2] = v8;
  swift_bridgeObjectRetain(v8, v10, v11, v12);
  swift_bridgeObjectRelease(v9);
  uint64_t v13 = (void *)a1[3];
  uint64_t v14 = (void *)a2[3];
  swift_errorRetain(v14);
  a1[3] = (uint64_t)v14;
  swift_errorRelease(v13);
  return a1;
}

uint64_t *assignWithTake for EncodingError.Context(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  *a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  a1[1] = *(void *)(a2 + 8);
  swift_bridgeObjectRelease(a1[2]);
  unint64_t v5 = (void *)a1[3];
  *((_OWORD *)a1 + 1) = *(_OWORD *)(a2 + 16);
  swift_errorRelease(v5);
  return a1;
}

ValueMetadata *type metadata accessor for DecodingError.Context()
{
  return &type metadata for DecodingError.Context;
}

uint64_t type metadata accessor for _KeyedEncodingContainerBase()
{
  return objc_opt_self();
}

void *type metadata completion function for _KeyedEncodingContainerBox(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 416));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    uint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 432);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t type metadata accessor for _KeyedDecodingContainerBase()
{
  return objc_opt_self();
}

void *type metadata completion function for _KeyedDecodingContainerBox(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 424));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    uint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 440);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t dispatch thunk of CodingKeyRepresentable.init<A>(codingKey:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

unint64_t type metadata completion function for IndexingIterator(uint64_t a1)
{
  int v2 = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  unint64_t v3 = (unint64_t)v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 1) + 64;
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
    unint64_t v3 = AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      v8[1] = *(void *)(AssociatedTypeWitness - 8) + 64LL;
      swift_initStructMetadata(a1, 0, 2uLL, (char *)v8, a1 + 32);
      return 0LL;
    }
  }

  return v3;
}

unint64_t **initializeBufferWithCopyOfBuffer for IndexingIterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = *(_DWORD *)(v12 + 80);
  uint64_t v14 = v7 + v13;
  uint64_t v15 = (*(_BYTE *)(v6 + 80) | *(_BYTE *)(v12 + 80));
  if (v15 > 7
    || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v12 + 80)) & 0x100000) != 0
    || (v14 & (unint64_t)~v13) + *(void *)(v12 + 64) > 0x18)
  {
    unint64_t v18 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v18 + ((v15 + 16) & ~v15));
    swift_retain(v18, v9, v10, v11);
  }

  else
  {
    unint64_t v19 = AssociatedTypeWitness;
    uint64_t v20 = ~v13;
    (*(void (**)(unint64_t **, unint64_t **, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v12 + 16))( ((unint64_t)a1 + v14) & v20,  ((unint64_t)a2 + v14) & v20,  v19);
  }

  return a1;
}

uint64_t destroy for IndexingIterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, v4);
  uint64_t v6 = *(void *)(v5 + 64) + a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( (v6 + *(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL),  AssociatedTypeWitness);
}

uint64_t initializeWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 16))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 24))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 32))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 40))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for IndexingIterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v12 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v13 = *(void *)(v6 + 64) + v12;
  if (a2 <= v11) {
    goto LABEL_23;
  }
  uint64_t v14 = (v13 & ~v12) + *(void *)(v9 + 64);
  char v15 = 8 * v14;
  if (v14 <= 3)
  {
    unsigned int v17 = ((a2 - v11 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      int v16 = *(_DWORD *)(a1 + v14);
      if (!v16) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v17 > 0xFF)
    {
      int v16 = *(unsigned __int16 *)(a1 + v14);
      if (!*(_WORD *)(a1 + v14)) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v17 < 2)
    {
LABEL_23:
      if (v11)
      {
        else {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))( (v13 + a1) & ~v12,  v10,  AssociatedTypeWitness);
        }
      }

      return 0LL;
    }
  }

  int v16 = *(unsigned __int8 *)(a1 + v14);
  if (!*(_BYTE *)(a1 + v14)) {
    goto LABEL_23;
  }
LABEL_14:
  int v18 = (v16 - 1) << v15;
  if ((_DWORD)v14)
  {
    else {
      int v19 = 4;
    }
    __asm { BR              X12 }
  }

  return v11 + v18 + 1;
}

void storeEnumTagSinglePayload for IndexingIterator(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                  - 8);
  if (*(_DWORD *)(v10 + 84) <= v9) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v10 + 84);
  }
  if (a3 <= v11)
  {
    unsigned int v13 = 0u;
  }

  else if (v12 <= 3)
  {
    unsigned int v15 = ((a3 - v11 + ~(-1 << (8 * v12))) >> (8 * v12)) + 1;
    if (HIWORD(v15))
    {
      unsigned int v13 = 4u;
    }

    else if (v15 >= 0x100)
    {
      unsigned int v13 = 2;
    }

    else
    {
      unsigned int v13 = v15 > 1;
    }
  }

  else
  {
    unsigned int v13 = 1u;
  }

  if (v11 < a2)
  {
    unsigned int v14 = ~v11 + a2;
    if (v12 < 4)
    {
      if ((_DWORD)v12)
      {
        int v16 = v14 & ~(-1 << (8 * v12));
        bzero(a1, v12);
        if ((_DWORD)v12 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }

        else if ((_DWORD)v12 == 2)
        {
          *(_WORD *)a1 = v16;
        }

        else
        {
          *a1 = v16;
        }
      }
    }

    else
    {
      bzero(a1, v12);
      *(_DWORD *)a1 = v14;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X13 }

uint64_t dispatch thunk of Collection.startIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of Collection.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of Collection.subscript.read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

uint64_t dispatch thunk of Collection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

uint64_t dispatch thunk of Collection.indices.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of Collection.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of Collection.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of Collection._customIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of Collection._customLastIndexOfEquatableElement(_:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

uint64_t dispatch thunk of Collection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 136))();
}

uint64_t dispatch thunk of Collection.index(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 144))();
}

uint64_t dispatch thunk of Collection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of Collection._failEarlyRangeCheck(_:bounds:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 160))();
}

{
  return (*(uint64_t (**)(void))(a4 + 168))();
}

{
  return (*(uint64_t (**)(void))(a4 + 176))();
}

uint64_t dispatch thunk of Collection.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 184))();
}

uint64_t dispatch thunk of Collection.formIndex(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 192))();
}

uint64_t dispatch thunk of static Comparable.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t dispatch thunk of static Comparable.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of static Comparable.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static Comparable.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of RawRepresentable.init(rawValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of RawRepresentable.rawValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t default associated conformance accessor for CaseIterable.CaseIterable.AllCases: Collection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for [A], a1, a3);
}

uint64_t dispatch thunk of ExpressibleByNilLiteral.init(nilLiteral:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:)( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of ExpressibleByFloatLiteral.init(floatLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinBooleanLiteral.init(_builtinBooleanLiteral:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

uint64_t dispatch thunk of ExpressibleByStringLiteral.init(stringLiteral:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of ExpressibleByArrayLiteral.init(arrayLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of ExpressibleByDictionaryLiteral.init(dictionaryLiteral:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of StringInterpolationProtocol.init(literalCapacity:interpolationCount:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of StringInterpolationProtocol.appendLiteral(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _ExpressibleByColorLiteral.init(_colorLiteralRed:green:blue:alpha:)( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByImageLiteral.init(imageLiteralResourceName:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t dispatch thunk of _HasContiguousBytes.withUnsafeBytes<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 8))();
}

uint64_t dispatch thunk of _HasContiguousBytes._providesContiguousBytesNoCopy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t getEnumTag for ClosedRange<>.Index(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 48LL))(a1, 1LL);
}

uint64_t destructiveInjectEnumTag for ClosedRange<>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8LL) + 56LL))( a1,  a2,  1LL);
}

uint64_t type metadata accessor for __EmptyArrayStorage()
{
  return objc_opt_self();
}

uint64_t method lookup function for __EmptyArrayStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __EmptyArrayStorage);
}

uint64_t dispatch thunk of __EmptyArrayStorage.__allocating_init(_doNotCallMe:)()
{
  return (*(uint64_t (**)(void))(v0 + 144))();
}

uint64_t method lookup function for __StaticArrayStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __StaticArrayStorage);
}

swift *type metadata completion function for _ContiguousArrayStorage(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 152);
}

uint64_t initializeBufferWithCopyOfBuffer for _UnsafePartiallyInitializedContiguousArrayBuffer( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(unint64_t **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_retain(v5, a2, a3, a4);
  return a1;
}

uint64_t *assignWithCopy for _UnsafePartiallyInitializedContiguousArrayBuffer( uint64_t *a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v6 = *a2;
  uint64_t v7 = *a1;
  *a1 = (uint64_t)*a2;
  swift_retain(v6, (uint64_t)a2, a3, a4);
  swift_release(v7);
  a1[1] = (uint64_t)a2[1];
  a1[2] = (uint64_t)a2[2];
  return a1;
}

__n128 __swift_memcpy24_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

uint64_t *assignWithTake for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(void *)(a2 + 16);
  return a1;
}

uint64_t type metadata accessor for _UnsafePartiallyInitializedContiguousArrayBuffer( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _UnsafePartiallyInitializedContiguousArrayBuffer);
}

ValueMetadata *type metadata accessor for OpaquePointer()
{
  return &type metadata for OpaquePointer;
}

ValueMetadata *type metadata accessor for CVaListPointer()
{
  return &type metadata for CVaListPointer;
}

ValueMetadata *type metadata accessor for _DebuggerSupport()
{
  return &type metadata for _DebuggerSupport;
}

uint64_t type metadata instantiation function for Dictionary(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x28);
}

uint64_t type metadata accessor for Dictionary.Values(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Values);
}

unint64_t *initializeBufferWithCopyOfBuffer for Dictionary.Keys.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v4 = *a2;
  *a1 = *a2;
  uint64_t v5 = v4 + 2;
  swift_retain(v4, (uint64_t)a2, a3, a4);
  return v5;
}

uint64_t destroy for Dictionary.Keys.Iterator(void *a1, uint64_t a2)
{
  return destroy for Dictionary.Keys.Iterator( a1,  a2,  (uint64_t (*)(void, void, void, void, void))outlined consume of [A : B].Iterator._Variant<A, B>);
}

void *initializeWithCopy for Dictionary.Keys.Iterator(void *a1, void *a2, uint64_t a3)
{
  return initializeWithCopy for Dictionary.Keys.Iterator( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of [A : B].Iterator._Variant<A, B>);
}

uint64_t *assignWithCopy for Dictionary.Keys.Iterator(uint64_t *a1, void *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Keys.Iterator( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of [A : B].Iterator._Variant<A, B>,  (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Iterator._Variant<A, B>);
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

void *assignWithTake for Dictionary.Keys.Iterator(void *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Keys.Iterator( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Iterator._Variant<A, B>);
}

uint64_t type metadata accessor for Dictionary.Keys.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for Dictionary.Keys.Iterator);
}

uint64_t type metadata accessor for Dictionary.Values.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for Dictionary.Values.Iterator);
}

ValueMetadata *type metadata accessor for _MergeError()
{
  return &type metadata for _MergeError;
}

uint64_t initializeBufferWithCopyOfBuffer for Dictionary.Index(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for Dictionary.Index( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t))outlined copy of [A : B].Index._Variant<A, B>);
}

uint64_t *assignWithCopy for Dictionary.Index(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Index( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t))outlined copy of [A : B].Index._Variant<A, B>,  (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Index._Variant<A, B>);
}

__n128 __swift_memcpy17_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

uint64_t *assignWithTake for Dictionary.Index(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Index( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Index._Variant<A, B>);
}

uint64_t type metadata accessor for Dictionary.Index(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Dictionary.Index,  &flag for loading of canonical specialized generic type metadata for Dictionary.Index);
}

void destroy for Dictionary.Index._Variant(uint64_t a1)
{
}

uint64_t getEnumTag for Dictionary.Index._Variant(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

uint64_t destructiveInjectEnumTag for Dictionary.Index._Variant(uint64_t result, char a2)
{
  *(_BYTE *)(result + 16) = a2 & 1;
  return result;
}

uint64_t type metadata accessor for Dictionary.Index._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for Dictionary.Index._Variant);
}

uint64_t type metadata accessor for Dictionary.Iterator(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Dictionary.Iterator,  &flag for loading of canonical specialized generic type metadata for Dictionary.Iterator);
}

uint64_t getEnumTag for Dictionary.Iterator._Variant(void *a1)
{
  return *a1 >> 63;
}

void *destructiveProjectEnumData for Dictionary.Iterator._Variant(void *result)
{
  *result &= ~0x8000000000000000LL;
  return result;
}

uint64_t *destructiveInjectEnumTag for Dictionary.Iterator._Variant(uint64_t *result, uint64_t a2)
{
  *__n128 result = *result & 0xFFFFFFFFFFFFFF8LL | (a2 << 63);
  return result;
}

swift *type metadata completion function for _SwiftDictionaryNSEnumerator(uint64_t a1)
{
  v2[0] = &unk_189B8B980;
  v2[1] = "\b";
  v2[2] = &value witness table for Builtin.Int64.size;
  v2[3] = &value witness table for Builtin.Int64.size;
  return swift_initClassMetadata2(a1, 0, 4uLL, (uint64_t)v2, a1 + 120);
}

uint64_t type metadata accessor for _SwiftDictionaryNSEnumerator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _SwiftDictionaryNSEnumerator);
}

swift *type metadata completion function for _SwiftDeferredNSDictionary(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = "\b";
  v2[2] = &unk_189B8B980;
  return swift_initClassMetadata2(a1, 0, 3uLL, (uint64_t)v2, a1 + 120);
}

ValueMetadata *type metadata accessor for __CocoaDictionary()
{
  return &type metadata for __CocoaDictionary;
}

ValueMetadata *type metadata accessor for __CocoaDictionary.Index()
{
  return &type metadata for __CocoaDictionary.Index;
}

uint64_t method lookup function for __CocoaDictionary.Iterator(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __CocoaDictionary.Iterator);
}

uint64_t type metadata accessor for _DictionaryBuilder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _DictionaryBuilder);
}

uint64_t type metadata accessor for __RawDictionaryStorage()
{
  return objc_opt_self();
}

uint64_t method lookup function for __RawDictionaryStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __RawDictionaryStorage);
}

uint64_t type metadata accessor for __EmptyDictionarySingleton()
{
  return objc_opt_self();
}

uint64_t method lookup function for __EmptyDictionarySingleton(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __EmptyDictionarySingleton);
}

swift *type metadata completion function for _DictionaryStorage(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 200);
}

uint64_t method lookup function for _DictionaryStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _DictionaryStorage);
}

unint64_t *type metadata completion function for DiscontiguousSlice( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice(a1, a2, a3, (uint64_t)&unk_189B8B980);
}

unint64_t type metadata completion function for DiscontiguousSlice.Index(uint64_t a1)
{
  v4[0] = &value witness table for Builtin.Int64.size;
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    v4[1] = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v4, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for DiscontiguousSlice.Index( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  if (v10 > 7
    || (*(_DWORD *)(v9 + 80) & 0x100000) != 0
    || ((v10 + 8) & (unint64_t)~v10) + *(void *)(v9 + 64) > 0x18)
  {
    unsigned int v13 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v13 + ((v10 & 0xF8 ^ 0x1F8) & (v10 + 16)));
    swift_retain(v13, v6, v7, v8);
  }

  else
  {
    *a1 = *a2;
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v9 + 16))( ((unint64_t)a1 + v10 + 8) & ~v10,  ((unint64_t)a2 + v10 + 8) & ~v10,  AssociatedTypeWitness);
  }

  return a1;
}

uint64_t destroy for DiscontiguousSlice.Index(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( (a1 + *(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL),  AssociatedTypeWitness);
}

void *initializeWithCopy for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 16))( ((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  AssociatedTypeWitness);
  return a1;
}

void *assignWithCopy for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 24))( ((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  AssociatedTypeWitness);
  return a1;
}

void *initializeWithTake for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 32))( ((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  AssociatedTypeWitness);
  return a1;
}

void *assignWithTake for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 40))( ((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for DiscontiguousSlice.Index(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  if (!a2) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v9 = ((v8 + 8) & ~v8) + *(void *)(v6 + 64);
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v12 = ((a2 - v7 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      int v11 = *(_DWORD *)(a1 + v9);
      if (!v11) {
        goto LABEL_20;
      }
      goto LABEL_11;
    }

    if (v12 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)(a1 + v9);
      if (!*(_WORD *)(a1 + v9)) {
        goto LABEL_20;
      }
      goto LABEL_11;
    }

    if (v12 < 2)
    {
LABEL_20:
      if ((_DWORD)v7) {
        return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v6 + 48))( (a1 + v8 + 8) & ~v8,  v7,  AssociatedTypeWitness);
      }
      return 0LL;
    }
  }

  int v11 = *(unsigned __int8 *)(a1 + v9);
  if (!*(_BYTE *)(a1 + v9)) {
    goto LABEL_20;
  }
LABEL_11:
  int v13 = (v11 - 1) << v10;
  if ((_DWORD)v9)
  {
    else {
      int v14 = 4;
    }
    __asm { BR              X11 }
  }

  return (v7 + v13 + 1);
}

void storeEnumTagSinglePayload for DiscontiguousSlice.Index( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                 - 8);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  size_t v9 = ((*(unsigned __int8 *)(v7 + 80) + 8LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80)) + *(void *)(v7 + 64);
  if (a3 <= v8)
  {
    unsigned int v10 = 0u;
  }

  else if (v9 <= 3)
  {
    unsigned int v12 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
    if (HIWORD(v12))
    {
      unsigned int v10 = 4u;
    }

    else if (v12 >= 0x100)
    {
      unsigned int v10 = 2;
    }

    else
    {
      unsigned int v10 = v12 > 1;
    }
  }

  else
  {
    unsigned int v10 = 1u;
  }

  if (v8 < a2)
  {
    unsigned int v11 = ~v8 + a2;
    if (v9 < 4)
    {
      if ((_DWORD)v9)
      {
        int v13 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *(_WORD *)a1 = v13;
          a1[2] = BYTE2(v13);
        }

        else if ((_DWORD)v9 == 2)
        {
          *(_WORD *)a1 = v13;
        }

        else
        {
          *a1 = v13;
        }
      }
    }

    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X13 }

unint64_t *type metadata completion function for LazyDropWhileSequence( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice(a1, a2, a3, (uint64_t)&unk_189B8CBB8);
}

uint64_t type metadata instantiation function for EmptyCollection(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x10);
}

uint64_t type metadata accessor for EmptyCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for EmptyCollection.Iterator);
}

uint64_t dispatch thunk of static Equatable.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t type metadata accessor for AnyIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnyIterator);
}

void *initializeBufferWithCopyOfBuffer for _ClosureBasedIterator( void *a1, void *a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (unint64_t *)a2[1];
  *a1 = *a2;
  a1[1] = v5;
  swift_retain(v5, (uint64_t)a2, a3, a4);
  return a1;
}

uint64_t destroy for _ClosureBasedIterator(uint64_t a1)
{
  return swift_release(*(void *)(a1 + 8));
}

uint64_t assignWithTake for _ClosureBasedIterator(uint64_t a1, _OWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = *a2;
  swift_release(v3);
  return a1;
}

uint64_t type metadata accessor for _AnyIteratorBoxBase(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnyIteratorBoxBase);
}

uint64_t method lookup function for _AnyIteratorBoxBase(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnyIteratorBoxBase);
}

uint64_t dispatch thunk of _AnyIteratorBoxBase.next()()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 96LL))();
}

void *type metadata completion function for _IteratorBox(uint64_t a1)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 104));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    unint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 120);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for _IteratorBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _IteratorBox);
}

uint64_t dispatch thunk of _IteratorBox.__allocating_init(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 128))();
}

swift *type metadata completion function for _AnyIteratorBoxBase(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 88);
}

uint64_t type metadata accessor for _AnySequenceBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnySequenceBox);
}

uint64_t method lookup function for _AnySequenceBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnySequenceBox);
}

uint64_t dispatch thunk of _AnySequenceBox.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

uint64_t dispatch thunk of _AnySequenceBox._makeIterator()()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 96LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._underestimatedCount.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 104LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._map<A>(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 112LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._filter(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 120LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._forEach(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 128LL))();
}

uint64_t dispatch thunk of _AnySequenceBox.__customContainsEquatableElement(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 136LL))();
}

uint64_t dispatch thunk of _AnySequenceBox.__copyToContiguousArray()()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 144LL))();
}

uint64_t dispatch thunk of _AnySequenceBox.__copyContents(initializing:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 152LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._drop(while:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 160LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._dropFirst(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 168LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._dropLast(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 176LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._prefix(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 184LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._prefix(while:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 192LL))();
}

uint64_t dispatch thunk of _AnySequenceBox._suffix(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 200LL))();
}

swift *type metadata completion function for _AnyCollectionBox(uint64_t a1)
{
  v2[0] = &unk_181808AC8;
  v2[1] = &unk_181808AC8;
  return swift_initClassMetadata2(a1, 0, 2uLL, (uint64_t)v2, a1 + 216);
}

uint64_t type metadata accessor for _AnyCollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnyCollectionBox);
}

uint64_t method lookup function for _AnyCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnyCollectionBox);
}

uint64_t dispatch thunk of _AnyCollectionBox._dropLast(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 232LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._prefix(while:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 240LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._suffix(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 248LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox.subscript.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 256LL))();
}

{
  uint64_t v0;
  return (*(uint64_t (**)(void))(*(void *)v0 + 336LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(after:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 264LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(after:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 272LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(_:offsetBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 280LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(_:offsetBy:limitedBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 288LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(_:offsetBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 296LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(_:offsetBy:limitedBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 304LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._distance(from:to:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 312LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox._count.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 320LL))();
}

uint64_t dispatch thunk of _AnyCollectionBox.__allocating_init(_startIndex:endIndex:)()
{
  return (*(uint64_t (**)(void))(v0 + 328))();
}

swift *type metadata completion function for _AnyBidirectionalCollectionBox(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 352);
}

uint64_t method lookup function for _AnyBidirectionalCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnyBidirectionalCollectionBox);
}

uint64_t dispatch thunk of _AnyBidirectionalCollectionBox._index(before:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 352LL))();
}

uint64_t dispatch thunk of _AnyBidirectionalCollectionBox._formIndex(before:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 360LL))();
}

swift *type metadata completion function for _AnyRandomAccessCollectionBox(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 376);
}

void *type metadata completion function for _SequenceBox(uint64_t a1)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 208));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    unint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 224);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for _SequenceBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _SequenceBox);
}

uint64_t dispatch thunk of _SequenceBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 232))();
}

void *type metadata completion function for _CollectionBox(uint64_t a1)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 344));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    unint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 360);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for _CollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _CollectionBox);
}

uint64_t dispatch thunk of _CollectionBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 368))();
}

void *type metadata completion function for _BidirectionalCollectionBox(uint64_t a1)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 368));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    unint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 384);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for _BidirectionalCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _BidirectionalCollectionBox);
}

uint64_t dispatch thunk of _BidirectionalCollectionBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 392))();
}

void *type metadata completion function for _RandomAccessCollectionBox(uint64_t a1)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 376));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    unint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 392);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for _RandomAccessCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _RandomAccessCollectionBox);
}

uint64_t dispatch thunk of _RandomAccessCollectionBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 400))();
}

void *assignWithCopy for _ClosureBasedIterator(void *a1, void *a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (unint64_t *)a2[1];
  uint64_t v6 = a1[1];
  *a1 = *a2;
  a1[1] = v5;
  swift_retain(v5, (uint64_t)a2, a3, a4);
  swift_release(v6);
  return a1;
}

uint64_t type metadata accessor for AnySequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnySequence);
}

uint64_t dispatch thunk of _AnyIndexBox._unbox<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t dispatch thunk of _AnyIndexBox._isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of _AnyIndexBox._isLess(than:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t method lookup function for _IndexBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _IndexBox);
}

uint64_t dispatch thunk of _IndexBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 104))();
}

__int128 *initializeBufferWithCopyOfBuffer for AnyIndex(__int128 *a1, __int128 *a2, uint64_t a3, char *a4)
{
  __int128 v5 = *a2;
  *a1 = *a2;
  swift_unknownObjectRetain((id)v5, (uint64_t)a2, a3, a4);
  return a1;
}

uint64_t assignWithCopy for AnyIndex(uint64_t a1, void **a2, uint64_t a3, char *a4)
{
  __int128 v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = *(void **)a1;
  *(void *)a1 = *a2;
  swift_unknownObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_unknownObjectRelease(v7);
  *(void *)(a1 + 8) = v6;
  return a1;
}

id *assignWithTake for AnyIndex(id *a1, _OWORD *a2)
{
  *(_OWORD *)a1 = *a2;
  return a1;
}

ValueMetadata *type metadata accessor for AnyIndex()
{
  return &type metadata for AnyIndex;
}

uint64_t type metadata accessor for AnyCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnyCollection);
}

uint64_t type metadata accessor for AnyBidirectionalCollection( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for AnyBidirectionalCollection);
}

uint64_t type metadata accessor for AnyRandomAccessCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for AnyRandomAccessCollection);
}

unint64_t type metadata completion function for LazyFilterSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  (uint64_t)&unk_189B8CBB8);
}

unint64_t **initializeBufferWithCopyOfBuffer for LazyFilterSequence.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(void *)(v9 + 64);
  int v11 = *(_DWORD *)(v9 + 80);
  if ((v11 & 0x1000F8) != 0 || ((v10 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 16 > 0x18)
  {
    int v14 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v14
                             + ((unsigned __int16)((v11 & 0xF8) + 23) & (unsigned __int16)~(v11 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))( a1,  a2,  AssociatedTypeWitness);
    int v13 = (void *)(((unint64_t)a2 + v10 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    int v14 = (unint64_t *)v13[1];
    unsigned int v15 = (void *)(((unint64_t)a1 + v10 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    *unsigned int v15 = *v13;
    v15[1] = v14;
  }

  swift_retain(v14, v6, v7, v8);
  return a1;
}

uint64_t destroy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v4 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v4 + 8))(a1, AssociatedTypeWitness);
  return swift_release(*(void *)(((a1 + *(void *)(v4 + 64) + 7) & 0xFFFFFFFFFFFFF8LL) + 8));
}

uint64_t initializeWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 16))(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 64) + 7LL;
  unsigned int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v10 = (unint64_t *)v9[1];
  *unsigned int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10, v11, v12, v13);
  return a1;
}

uint64_t assignWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 24))(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 64) + 7LL;
  unsigned int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v10 = (unint64_t *)v9[1];
  uint64_t v11 = v8[1];
  *unsigned int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10, v12, v13, v14);
  swift_release(v11);
  return a1;
}

uint64_t initializeWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 32))(a1, a2, AssociatedTypeWitness);
  *(_OWORD *)((*(void *)(v6 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(_OWORD *)((*(void *)(v6 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t assignWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 40))(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 64) + 7LL;
  unint64_t v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v9 = *(void *)(v8 + 8);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)((v7 + a2) & 0xFFFFFFFFFFFFF8LL);
  swift_release(v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyFilterSequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  unsigned int v6 = *(_DWORD *)(v5 + 84);
  if (v6 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v5 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(v5 + 64);
  if (v7 < a2)
  {
    if (((((v8 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 16) & 0xFFFFFFF8) != 0) {
      unsigned int v9 = 2;
    }
    else {
      unsigned int v9 = a2 - v7 + 1;
    }
    if (v9 >= 0x10000) {
      unsigned int v10 = 4;
    }
    else {
      unsigned int v10 = 2;
    }
    if (v9 < 0x100) {
      unsigned int v10 = 1;
    }
    if (v9 >= 2) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0LL;
    }
    __asm { BR              X15 }
  }

  if (v6 >= 0x7FFFFFFF) {
    return (*(uint64_t (**)(uint64_t))(v5 + 48))(a1);
  }
  unint64_t v13 = *(void *)((a1 + v8 + 7) & 0xFFFFFFFFFFFFF8LL);
  if (v13 >= 0xFFFFFFFF) {
    LODWORD(v13) = -1;
  }
  return (v13 + 1);
}

void storeEnumTagSinglePayload for LazyFilterSequence.Iterator( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  if (*(_DWORD *)(v7 + 84) <= 0x7FFFFFFFu) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v7 + 84);
  }
  if (v8 >= a3)
  {
    int v11 = 0u;
    if (a2 <= v8) {
      goto LABEL_17;
    }
  }

  else
  {
    if (((*(_DWORD *)(v7 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
      unsigned int v9 = a3 - v8 + 1;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v9 >= 0x10000) {
      int v10 = 4;
    }
    else {
      int v10 = 2;
    }
    if (v9 < 0x100) {
      int v10 = 1;
    }
    if (v9 >= 2) {
      int v11 = v10;
    }
    else {
      int v11 = 0;
    }
    if (a2 <= v8) {
LABEL_17:
    }
      __asm { BR              X12 }
  }

  if (((*(_DWORD *)(v7 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
  {
    unsigned int v12 = ~v8 + a2;
    bzero(a1, ((*(void *)(v7 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 16);
    *a1 = v12;
  }

  __asm { BR              X10 }

void sub_181715690()
{
  *(_BYTE *)(v0 + v1) = v2;
  JUMPOUT(0x18171570CLL);
}

void sub_181715698()
{
  *(_DWORD *)(v0 + v2) = 0;
  if (v1) {
    JUMPOUT(0x1817156A0LL);
  }
  JUMPOUT(0x18171570CLL);
}

void sub_1817156E4()
{
  *(_WORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171570CLL);
}

void sub_1817156EC()
{
  *(_DWORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171570CLL);
}

uint64_t sub_1817156F4@<X0>(unsigned int a1@<W2>, uint64_t a2@<X8>)
{
  *(_WORD *)(v3 + v5) = 0;
  if (!(_DWORD)v4) {
    JUMPOUT(0x18171570CLL);
  }
  if (a1 < 0x7FFFFFFF)
  {
    if ((v4 & 0x80000000) == 0) {
      JUMPOUT(0x181715708LL);
    }
    JUMPOUT(0x181715700LL);
  }

  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(v3, v4);
}

uint64_t type metadata accessor for FlattenSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for FlattenSequence);
}

unint64_t type metadata completion function for FlattenSequence.Iterator(void *a1)
{
  uint64_t v3 = a1[2];
  int v2 = (const char *)a1[3];
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v12[0] = *(void *)(result - 8) + 64LL;
    unsigned int v6 = (const char *)a1[4];
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    unint64_t result = type metadata accessor for Optional((const char *)0x13F, v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(void *)(result - 8) + 64LL;
      swift_initStructMetadata((uint64_t)a1, 0, 2uLL, (char *)v12, (uint64_t)(a1 + 5));
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for FlattenSequence.Iterator( unint64_t **a1, unint64_t **a2, void *a3)
{
  uint64_t v7 = a3[2];
  unsigned int v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v17 = *(void *)(v13 - 8);
  int v18 = *(_DWORD *)(v17 + 80);
  uint64_t v19 = v18;
  uint64_t v20 = v10 + v18;
  if (*(_DWORD *)(v17 + 84)) {
    size_t v21 = *(void *)(v17 + 64);
  }
  else {
    size_t v21 = *(void *)(v17 + 64) + 1LL;
  }
  int v22 = *(_DWORD *)(v9 + 80) | v18;
  uint64_t v23 = (*(_BYTE *)(v9 + 80) | v18);
  int v24 = v22 & 0x100000;
  if (v23 > 7 || v24 != 0 || ((v10 + v19) & ~v19) + v21 > 0x18)
  {
    uint64_t v27 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v27 + ((v23 + 16) & ~v23));
    swift_retain(v27, v14, v15, v16);
  }

  else
  {
    unint64_t v28 = v13;
    uint64_t v29 = ~v19;
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))( a1,  a2,  AssociatedTypeWitness);
    uint64_t v30 = (const void *)(((unint64_t)a2 + v20) & v29);
    if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v17 + 48))(v30, 1LL, v28))
    {
      memcpy((void *)(((unint64_t)a1 + v20) & v29), v30, v21);
    }

    else
    {
      (*(void (**)(unint64_t, const void *, unint64_t))(v17 + 16))( ((unint64_t)a1 + v20) & v29,  v30,  v28);
      (*(void (**)(unint64_t, void, uint64_t, unint64_t))(v17 + 56))( ((unint64_t)a1 + v20) & v29,  0LL,  1LL,  v28);
    }
  }

  return a1;
}

uint64_t destroy for FlattenSequence.Iterator(uint64_t a1, void *a2)
{
  uint64_t v5 = a2[2];
  uint64_t v4 = (const char *)a2[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 64) + a1;
  uint64_t v9 = (const char *)a2[4];
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  v9,  v10,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v12 = *(void *)(v11 - 8);
  unint64_t v13 = (v8 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, unint64_t))(v12 + 48))(v13, 1LL, v11);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(unint64_t, unint64_t))(v12 + 8))(v13, v11);
  }
  return result;
}

uint64_t initializeWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  unsigned int v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1LL, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1LL;
    }
    memcpy(v16, v17, v18);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 16))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
  }

  return a1;
}

uint64_t assignWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  unsigned int v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 24))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1LL, v13);
  int v19 = v18(v17, 1LL, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
      return a1;
    }
  }

  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 24))(v16, v17, v13);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }

  if (*(_DWORD *)(v14 + 84)) {
    size_t v20 = *(void *)(v14 + 64);
  }
  else {
    size_t v20 = *(void *)(v14 + 64) + 1LL;
  }
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  unsigned int v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 32))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1LL, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1LL;
    }
    memcpy(v16, v17, v18);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 32))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
  }

  return a1;
}

uint64_t assignWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  unsigned int v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 40))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1LL, v13);
  int v19 = v18(v17, 1LL, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
      return a1;
    }
  }

  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 40))(v16, v17, v13);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }

  if (*(_DWORD *)(v14 + 84)) {
    size_t v20 = *(void *)(v14 + 64);
  }
  else {
    size_t v20 = *(void *)(v14 + 64) + 1LL;
  }
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence.Iterator(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v7 = a3[2];
  unsigned int v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v13 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                  - 8);
  int v14 = *(_DWORD *)(v13 + 84);
  if (v14) {
    unsigned int v15 = v14 - 1;
  }
  else {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  if (v14) {
    uint64_t v17 = *(void *)(v13 + 64);
  }
  else {
    uint64_t v17 = *(void *)(v13 + 64) + 1LL;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v18 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v19 = *(void *)(v9 + 64) + v18;
  if (a2 <= v16) {
    goto LABEL_29;
  }
  uint64_t v20 = v17 + (v19 & ~v18);
  char v21 = 8 * v20;
  if (v20 <= 3)
  {
    unsigned int v23 = ((a2 - v16 + ~(-1 << v21)) >> v21) + 1;
    if (HIWORD(v23))
    {
      int v22 = *(_DWORD *)(a1 + v20);
      if (!v22) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }

    if (v23 > 0xFF)
    {
      int v22 = *(unsigned __int16 *)(a1 + v20);
      if (!*(_WORD *)(a1 + v20)) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }

    if (v23 < 2)
    {
LABEL_29:
      if (v16)
      {
        if (v10 >= v15) {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))( a1,  v10,  AssociatedTypeWitness);
        }
        unsigned int v26 = (*(uint64_t (**)(uint64_t))(v13 + 48))((v19 + a1) & ~v18);
        if (v26 >= 2) {
          return v26 - 1;
        }
        else {
          return 0LL;
        }
      }

      return 0LL;
    }
  }

  int v22 = *(unsigned __int8 *)(a1 + v20);
  if (!*(_BYTE *)(a1 + v20)) {
    goto LABEL_29;
  }
LABEL_20:
  int v24 = (v22 - 1) << v21;
  if ((_DWORD)v20)
  {
    else {
      int v25 = 4;
    }
    __asm { BR              X12 }
  }

  return v16 + v24 + 1;
}

void storeEnumTagSinglePayload for FlattenSequence.Iterator( _BYTE *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v9 = a4[2];
  uint64_t v8 = (const char *)a4[3];
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v8,  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                  - 8);
  unsigned int v11 = *(_DWORD *)(v10 + 84);
  unint64_t v12 = (const char *)a4[4];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unsigned int v14 = 0u;
  uint64_t v15 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                  - 8);
  int v16 = *(_DWORD *)(v15 + 84);
  unsigned int v17 = v16 - 1;
  if (!v16) {
    unsigned int v17 = 0;
  }
  if (v17 <= v11) {
    unsigned int v18 = v11;
  }
  else {
    unsigned int v18 = v17;
  }
  uint64_t v19 = *(unsigned __int8 *)(v15 + 80);
  if (v16) {
    uint64_t v21 = *(void *)(v15 + 64);
  }
  else {
    uint64_t v21 = *(void *)(v15 + 64) + 1LL;
  }
  uint64_t v20 = *(void *)(v10 + 64) + v19;
  unsigned int v22 = (v20 & ~(_DWORD)v19) + v21;
  if (a3 > v18)
  {
    if (v22 > 3)
    {
      unsigned int v14 = 1u;
      if (v18 >= a2) {
LABEL_25:
      }
        __asm { BR              X14 }

void sub_181716534()
{
  *(_BYTE *)(v2 + v1) = v0;
}

void sub_18171653C()
{
  *(_WORD *)(v2 + v1) = v0;
}

void sub_181716568()
{
  *(_WORD *)uint64_t v0 = v1;
  *(_BYTE *)(v0 + 2) = BYTE2(v1);
}

void sub_181716578()
{
  _WORD *v0 = v1;
}

void sub_181716580()
{
  _DWORD *v0 = v1;
}

unint64_t type metadata completion function for FlattenSequence<>.Index(void *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  (const char *)v3,  v2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  if (v5 <= 0x3F)
  {
    v12[0] = *(void *)(result - 8) + 64LL;
    unsigned int v6 = (const char *)a1[4];
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v3 + 8),  v2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
    unint64_t result = type metadata accessor for Optional((const char *)0x13F, v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(void *)(result - 8) + 64LL;
      swift_initStructMetadata((uint64_t)a1, 0, 2uLL, (char *)v12, (uint64_t)(a1 + 5));
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for FlattenSequence<>.Index( unint64_t **a1, unint64_t **a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v17 = *(void *)(v13 - 8);
  int v18 = *(_DWORD *)(v17 + 80);
  uint64_t v19 = v18;
  uint64_t v20 = v10 + v18;
  if (*(_DWORD *)(v17 + 84)) {
    size_t v21 = *(void *)(v17 + 64);
  }
  else {
    size_t v21 = *(void *)(v17 + 64) + 1LL;
  }
  int v22 = *(_DWORD *)(v9 + 80) | v18;
  uint64_t v23 = (*(_BYTE *)(v9 + 80) | v18);
  int v24 = v22 & 0x100000;
  if (v23 > 7 || v24 != 0 || ((v10 + v19) & ~v19) + v21 > 0x18)
  {
    uint64_t v27 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v27 + ((v23 + 16) & ~v23));
    swift_retain(v27, v14, v15, v16);
  }

  else
  {
    unint64_t v28 = v13;
    uint64_t v29 = ~v19;
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))( a1,  a2,  AssociatedTypeWitness);
    uint64_t v30 = (const void *)(((unint64_t)a2 + v20) & v29);
    if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v17 + 48))(v30, 1LL, v28))
    {
      memcpy((void *)(((unint64_t)a1 + v20) & v29), v30, v21);
    }

    else
    {
      (*(void (**)(unint64_t, const void *, unint64_t))(v17 + 16))( ((unint64_t)a1 + v20) & v29,  v30,  v28);
      (*(void (**)(unint64_t, void, uint64_t, unint64_t))(v17 + 56))( ((unint64_t)a1 + v20) & v29,  0LL,  1LL,  v28);
    }
  }

  return a1;
}

uint64_t destroy for FlattenSequence<>.Index(uint64_t a1, void *a2)
{
  uint64_t v5 = a2[2];
  uint64_t v4 = a2[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v4,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 64) + a1;
  uint64_t v9 = (const char *)a2[4];
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v4 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  v9,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = *(void *)(v11 - 8);
  unint64_t v13 = (v8 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, unint64_t))(v12 + 48))(v13, 1LL, v11);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(unint64_t, unint64_t))(v12 + 8))(v13, v11);
  }
  return result;
}

uint64_t initializeWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1LL, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1LL;
    }
    memcpy(v16, v17, v18);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 16))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
  }

  return a1;
}

uint64_t assignWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 24))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1LL, v13);
  int v19 = v18(v17, 1LL, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
      return a1;
    }
  }

  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 24))(v16, v17, v13);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }

  if (*(_DWORD *)(v14 + 84)) {
    size_t v20 = *(void *)(v14 + 64);
  }
  else {
    size_t v20 = *(void *)(v14 + 64) + 1LL;
  }
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 32))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1LL, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1LL;
    }
    memcpy(v16, v17, v18);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 32))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
  }

  return a1;
}

uint64_t assignWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 40))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  int v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1LL, v13);
  int v19 = v18(v17, 1LL, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
      return a1;
    }
  }

  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 40))(v16, v17, v13);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }

  if (*(_DWORD *)(v14 + 84)) {
    size_t v20 = *(void *)(v14 + 64);
  }
  else {
    size_t v20 = *(void *)(v14 + 64) + 1LL;
  }
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence<>.Index(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v13 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                  - 8);
  int v14 = *(_DWORD *)(v13 + 84);
  if (v14) {
    unsigned int v15 = v14 - 1;
  }
  else {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  if (v14) {
    uint64_t v17 = *(void *)(v13 + 64);
  }
  else {
    uint64_t v17 = *(void *)(v13 + 64) + 1LL;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v18 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v19 = *(void *)(v9 + 64) + v18;
  if (a2 <= v16) {
    goto LABEL_29;
  }
  uint64_t v20 = v17 + (v19 & ~v18);
  char v21 = 8 * v20;
  if (v20 <= 3)
  {
    unsigned int v23 = ((a2 - v16 + ~(-1 << v21)) >> v21) + 1;
    if (HIWORD(v23))
    {
      int v22 = *(_DWORD *)(a1 + v20);
      if (!v22) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }

    if (v23 > 0xFF)
    {
      int v22 = *(unsigned __int16 *)(a1 + v20);
      if (!*(_WORD *)(a1 + v20)) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }

    if (v23 < 2)
    {
LABEL_29:
      if (v16)
      {
        if (v10 >= v15) {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))( a1,  v10,  AssociatedTypeWitness);
        }
        unsigned int v26 = (*(uint64_t (**)(uint64_t))(v13 + 48))((v19 + a1) & ~v18);
        if (v26 >= 2) {
          return v26 - 1;
        }
        else {
          return 0LL;
        }
      }

      return 0LL;
    }
  }

  int v22 = *(unsigned __int8 *)(a1 + v20);
  if (!*(_BYTE *)(a1 + v20)) {
    goto LABEL_29;
  }
LABEL_20:
  int v24 = (v22 - 1) << v21;
  if ((_DWORD)v20)
  {
    else {
      int v25 = 4;
    }
    __asm { BR              X12 }
  }

  return v16 + v24 + 1;
}

void storeEnumTagSinglePayload for FlattenSequence<>.Index( _BYTE *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v9 = a4[2];
  uint64_t v8 = a4[3];
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                  - 8);
  unsigned int v11 = *(_DWORD *)(v10 + 84);
  unint64_t v12 = (const char *)a4[4];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v8 + 8),  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unsigned int v14 = 0u;
  uint64_t v15 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                  - 8);
  int v16 = *(_DWORD *)(v15 + 84);
  unsigned int v17 = v16 - 1;
  if (!v16) {
    unsigned int v17 = 0;
  }
  if (v17 <= v11) {
    unsigned int v18 = v11;
  }
  else {
    unsigned int v18 = v17;
  }
  uint64_t v19 = *(unsigned __int8 *)(v15 + 80);
  if (v16) {
    uint64_t v21 = *(void *)(v15 + 64);
  }
  else {
    uint64_t v21 = *(void *)(v15 + 64) + 1LL;
  }
  uint64_t v20 = *(void *)(v10 + 64) + v19;
  unsigned int v22 = (v20 & ~(_DWORD)v19) + v21;
  if (a3 > v18)
  {
    if (v22 > 3)
    {
      unsigned int v14 = 1u;
      if (v18 >= a2) {
LABEL_25:
      }
        __asm { BR              X14 }

void sub_1817173C0()
{
  *(_BYTE *)(v2 + v1) = v0;
}

void sub_1817173C8()
{
  *(_WORD *)(v2 + v1) = v0;
}

void sub_1817173F4()
{
  *(_WORD *)uint64_t v0 = v1;
  *(_BYTE *)(v0 + 2) = BYTE2(v1);
}

void sub_181717404()
{
  _WORD *v0 = v1;
}

void sub_18171740C()
{
  _DWORD *v0 = v1;
}

uint64_t dispatch thunk of FloatingPoint.init(sign:exponent:significand:)( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))(a1 & 1);
}

uint64_t dispatch thunk of FloatingPoint.init(signOf:magnitudeOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of FloatingPoint.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of FloatingPoint.init<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of static FloatingPoint.radix.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

uint64_t dispatch thunk of static FloatingPoint.nan.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of static FloatingPoint.signalingNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of static FloatingPoint.infinity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of static FloatingPoint.greatestFiniteMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of static FloatingPoint.pi.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of FloatingPoint.ulp.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of static FloatingPoint.ulpOfOne.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of static FloatingPoint.leastNormalMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of static FloatingPoint.leastNonzeroMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of FloatingPoint.sign.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))() & 1;
}

uint64_t dispatch thunk of FloatingPoint.exponent.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 176))();
}

uint64_t dispatch thunk of FloatingPoint.significand.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 184))();
}

uint64_t dispatch thunk of static FloatingPoint./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 192))();
}

uint64_t dispatch thunk of static FloatingPoint./= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 200))();
}

uint64_t dispatch thunk of FloatingPoint.remainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 208))();
}

uint64_t dispatch thunk of FloatingPoint.formRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 216))();
}

uint64_t dispatch thunk of FloatingPoint.truncatingRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 224))();
}

uint64_t dispatch thunk of FloatingPoint.formTruncatingRemainder(dividingBy:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 232))();
}

uint64_t dispatch thunk of FloatingPoint.squareRoot()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 240))();
}

uint64_t dispatch thunk of FloatingPoint.formSquareRoot()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 248))();
}

uint64_t dispatch thunk of FloatingPoint.addingProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 256))();
}

uint64_t dispatch thunk of FloatingPoint.addProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 264))();
}

uint64_t dispatch thunk of static FloatingPoint.minimum(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 272))();
}

uint64_t dispatch thunk of static FloatingPoint.maximum(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 280))();
}

uint64_t dispatch thunk of static FloatingPoint.minimumMagnitude(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 288))();
}

uint64_t dispatch thunk of static FloatingPoint.maximumMagnitude(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 296))();
}

uint64_t dispatch thunk of FloatingPoint.rounded(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 304))();
}

uint64_t dispatch thunk of FloatingPoint.round(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 312))();
}

uint64_t dispatch thunk of FloatingPoint.nextUp.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 320))();
}

uint64_t dispatch thunk of FloatingPoint.nextDown.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of FloatingPoint.isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 336))();
}

uint64_t dispatch thunk of FloatingPoint.isLess(than:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 344))();
}

uint64_t dispatch thunk of FloatingPoint.isLessThanOrEqualTo(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 352))();
}

uint64_t dispatch thunk of FloatingPoint.isTotallyOrdered(belowOrEqualTo:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 360))();
}

uint64_t dispatch thunk of FloatingPoint.isNormal.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 368))();
}

uint64_t dispatch thunk of FloatingPoint.isFinite.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 376))();
}

uint64_t dispatch thunk of FloatingPoint.isZero.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 384))();
}

uint64_t dispatch thunk of FloatingPoint.isSubnormal.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 392))();
}

uint64_t dispatch thunk of FloatingPoint.isInfinite.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 400))();
}

uint64_t dispatch thunk of FloatingPoint.isNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 408))();
}

uint64_t dispatch thunk of FloatingPoint.isSignalingNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 416))();
}

uint64_t dispatch thunk of FloatingPoint.floatingPointClass.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 424))();
}

uint64_t dispatch thunk of FloatingPoint.isCanonical.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 432))();
}

_BYTE *destructiveInjectEnumTag for FloatingPointSign(_BYTE *result, char a2)
{
  *uint64_t result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointSign()
{
  return &type metadata for FloatingPointSign;
}

uint64_t getEnumTagSinglePayload for FloatingPointClassification(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF7) {
    goto LABEL_17;
  }
  if (a2 + 9 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 9) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 9;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 9;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 9;
    }
  }

uint64_t storeEnumTagSinglePayload for FloatingPointClassification( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 9 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 9) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xF7) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF6) {
    return ((uint64_t (*)(void))((char *)&loc_1817176B8 + 4 * byte_181800368[v4]))();
  }
  *a1 = a2 + 9;
  return ((uint64_t (*)(void))((char *)sub_1817176EC + 4 * byte_181800363[v4]))();
}

uint64_t sub_1817176EC(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1817176F4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x1817176FCLL);
  }
  return result;
}

uint64_t sub_181717708(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x181717710LL);
  }
  *(_BYTE *)uint64_t result = a2 + 9;
  return result;
}

uint64_t sub_181717714(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18171771C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointClassification()
{
  return &type metadata for FloatingPointClassification;
}

uint64_t getEnumTagSinglePayload for FloatingPointRoundingRule(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFB) {
    goto LABEL_17;
  }
  if (a2 + 5 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 5) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 5;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }

uint64_t storeEnumTagSinglePayload for FloatingPointRoundingRule(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 5 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 5) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFB) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFA) {
    return ((uint64_t (*)(void))((char *)&loc_181717814 + 4 * byte_181800372[v4]))();
  }
  *a1 = a2 + 5;
  return ((uint64_t (*)(void))((char *)sub_181717848 + 4 * byte_18180036D[v4]))();
}

uint64_t sub_181717848(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_181717850(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x181717858LL);
  }
  return result;
}

uint64_t sub_181717864(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x18171786CLL);
  }
  *(_BYTE *)uint64_t result = a2 + 5;
  return result;
}

uint64_t sub_181717870(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_181717878(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointRoundingRule()
{
  return &type metadata for FloatingPointRoundingRule;
}

uint64_t dispatch thunk of BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:)( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 56))(a1 & 1);
}

uint64_t dispatch thunk of BinaryFloatingPoint.init(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.init<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 80))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.init<A>(exactly:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 88))();
}

uint64_t dispatch thunk of static BinaryFloatingPoint.exponentBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of static BinaryFloatingPoint.significandBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.exponentBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.significandBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.binade.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.significandWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of Hashable.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Hashable.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of Hashable._rawHashValue(seed:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _HasCustomAnyHashableRepresentation._toCustomAnyHashable()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _AnyHashableBox._canonicalBox.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _AnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of _AnyHashableBox._hashValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of _AnyHashableBox._hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _AnyHashableBox._rawHashValue(_seed:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of _AnyHashableBox._base.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of _AnyHashableBox._unbox<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of _AnyHashableBox._downCastConditional<A>(into:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t destroy for AnyHashable(uint64_t *a1)
{
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t initializeWithCopy for AnyHashable(uint64_t a1, uint64_t a2)
{
  __int128 v3 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 24) = v3;
  (**(void (***)(void))(v3 - 8))();
  return a1;
}

uint64_t *assignWithCopy for AnyHashable(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_1(uint64_t *result, uint64_t a2, uint64_t a3, char *a4)
{
  if (result != (uint64_t *)a2)
  {
    uint64_t v5 = result;
    uint64_t v6 = result[3];
    uint64_t v7 = *(void *)(a2 + 24);
    if (v6 == v7)
    {
      uint64_t v14 = *(void *)(v6 - 8);
      if ((*(_BYTE *)(v14 + 82) & 2) != 0)
      {
        uint64_t v16 = *result;
        unsigned int v17 = *(unint64_t **)a2;
        swift_retain(*(unint64_t **)a2, a2, a3, a4);
        uint64_t result = (uint64_t *)swift_release(v16);
        *uint64_t v5 = v17;
      }

      else
      {
        return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v14 + 24))(result, a2, result[3]);
      }
    }

    else
    {
      result[3] = v7;
      result[4] = *(void *)(a2 + 32);
      uint64_t v8 = *(void *)(v6 - 8);
      uint64_t v9 = *(void *)(v7 - 8);
      int v10 = *(_DWORD *)(v9 + 80);
      if ((*(_BYTE *)(v8 + 82) & 2) != 0)
      {
        uint64_t v15 = *result;
        if ((v10 & 0x20000) != 0)
        {
          uint64_t v19 = *(unint64_t **)a2;
          *uint64_t v5 = *(void *)a2;
          swift_retain(v19, a2, a3, a4);
        }

        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t))(v9 + 16))(result, a2, v7);
        }

        return (uint64_t *)swift_release(v15);
      }

      else
      {
        (*(void (**)(_BYTE *, uint64_t *, uint64_t))(v8 + 32))(v20, result, v6);
        if ((v10 & 0x20000) != 0)
        {
          unsigned int v18 = *(unint64_t **)a2;
          *uint64_t v5 = *(void *)a2;
          swift_retain(v18, v11, v12, v13);
        }

        else
        {
          (*(void (**)(void *, uint64_t, uint64_t))(v9 + 16))(v5, a2, v7);
        }

        return (uint64_t *)(*(uint64_t (**)(_BYTE *, uint64_t))(v8 + 8))(v20, v6);
      }
    }
  }

  return result;
}

uint64_t assignWithTake for AnyHashable(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for AnyHashable(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for AnyHashable(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)uint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for AnyHashable()
{
  return &type metadata for AnyHashable;
}

ValueMetadata *type metadata accessor for Hasher._TailBuffer()
{
  return &type metadata for Hasher._TailBuffer;
}

__n128 __swift_memcpy72_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t getEnumTagSinglePayload for Hasher._Core(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 72)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for Hasher._Core(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 72) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Hasher._Core()
{
  return &type metadata for Hasher._Core;
}

ValueMetadata *type metadata accessor for Hasher()
{
  return &type metadata for Hasher;
}

uint64_t type metadata accessor for __SwiftEmptyNSEnumerator()
{
  return objc_opt_self();
}

unint64_t type metadata accessor for __BridgingHashBuffer(const char *a1)
{
  return type metadata accessor for __BridgingBufferStorage( a1,  (unint64_t *)&type metadata singleton initialization cache for __BridgingHashBuffer,  (unsigned int *)&nominal type descriptor for __BridgingHashBuffer);
}

unint64_t type metadata accessor for __BridgingBufferStorage( const char *a1, unint64_t *a2, unsigned int *a3)
{
  unint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata(a1, a3);
  }
  return result;
}

swift *type metadata completion function for __BridgingBufferStorage(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 256, 0LL, (uint64_t)v2, a1 + 112);
}

uint64_t dispatch thunk of _HashTableDelegate.hashValue(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of _HashTableDelegate.moveEntry(from:to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t getEnumTagSinglePayload for _UnsafeBitset(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 != 1 && *(_BYTE *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafeBitset(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)unint64_t result = a2 - 2;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 2) {
      *(_BYTE *)(result + 16) = 1;
    }
  }

  else
  {
    if (a3 >= 2) {
      *(_BYTE *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)unint64_t result = 0LL;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for _HashTable()
{
  return &type metadata for _HashTable;
}

ValueMetadata *type metadata accessor for _HashTable.Bucket()
{
  return &type metadata for _HashTable.Bucket;
}

uint64_t __swift_memcpy12_8(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_DWORD *)(result + 8) = *((_DWORD *)a2 + 2);
  *(void *)unint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for _HashTable.Index(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 12)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for _HashTable.Index(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_DWORD *)(result + 8) = 0;
    *(void *)unint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 12) = v3;
  return result;
}

ValueMetadata *type metadata accessor for _HashTable.Index()
{
  return &type metadata for _HashTable.Index;
}

uint64_t getEnumTagSinglePayload for _UnsafeBitset.Iterator(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 != 1 && *(_BYTE *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafeBitset.Iterator( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)unint64_t result = a2 - 2;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 2) {
      *(_BYTE *)(result + 32) = 1;
    }
  }

  else
  {
    if (a3 >= 2) {
      *(_BYTE *)(result + 32) = 0;
    }
    if (a2) {
      *(void *)unint64_t result = 0LL;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for _HashTable.Iterator()
{
  return &type metadata for _HashTable.Iterator;
}

unint64_t type metadata completion function for DefaultIndices(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  unint64_t v3 = (unint64_t)v2;
  if (v4 <= 0x3F)
  {
    uint64_t v8 = *(v2 - 1) + 64;
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
    unint64_t v3 = AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      uint64_t v9 = *(void *)(AssociatedTypeWitness - 8) + 64LL;
      uint64_t v10 = v9;
      swift_initStructMetadata(a1, 0, 3uLL, (char *)&v8, a1 + 32);
      return 0LL;
    }
  }

  return v3;
}

unint64_t **initializeBufferWithCopyOfBuffer for DefaultIndices( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = *(_DWORD *)(v12 + 80);
  uint64_t v14 = v7 + v13;
  uint64_t v15 = (v7 + v13) & ~v13;
  uint64_t v16 = *(void *)(v12 + 64);
  uint64_t v17 = v16 + v13;
  unint64_t v18 = ((v15 + v16 + v13) & ~v13) + v16;
  uint64_t v19 = (*(_BYTE *)(v6 + 80) | *(_BYTE *)(v12 + 80));
  if (v19 > 7 || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v12 + 80)) & 0x100000) != 0 || v18 > 0x18)
  {
    unsigned int v22 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v22 + ((v19 + 16) & ~v19));
    swift_retain(v22, v9, v10, v11);
  }

  else
  {
    unint64_t v23 = AssociatedTypeWitness;
    uint64_t v24 = ~v13;
    (*(void (**)(unint64_t **, unint64_t **, uint64_t))(v6 + 16))(a1, a2, v5);
    unint64_t v25 = ((unint64_t)a2 + v14) & v24;
    unsigned int v26 = *(void (**)(unint64_t, unint64_t, unint64_t))(v12 + 16);
    v26(((unint64_t)a1 + v14) & v24, v25, v23);
    v26(((((unint64_t)a1 + v14) & v24) + v17) & v24, (v25 + v17) & v24, v23);
  }

  return a1;
}

uint64_t destroy for DefaultIndices(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, v4);
  uint64_t v6 = *(void *)(v5 + 64) + a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v10 = (v6 + v9) & ~v9;
  uint64_t v12 = *(void (**)(uint64_t, unint64_t))(v8 + 8);
  v12(v10, AssociatedTypeWitness);
  return ((uint64_t (*)(uint64_t, unint64_t))v12)( (*(void *)(v8 + 64) + v9 + v10) & ~v9,  AssociatedTypeWitness);
}

uint64_t initializeWithCopy for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 16);
  v14(v12, v13, AssociatedTypeWitness);
  v14((v12 + *(void *)(v10 + 64) + v11) & ~v11, (v13 + *(void *)(v10 + 64) + v11) & ~v11, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 24);
  v14(v12, v13, AssociatedTypeWitness);
  v14((v12 + *(void *)(v10 + 64) + v11) & ~v11, (v13 + *(void *)(v10 + 64) + v11) & ~v11, AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 32);
  v14(v12, v13, AssociatedTypeWitness);
  v14((v12 + *(void *)(v10 + 64) + v11) & ~v11, (v13 + *(void *)(v10 + 64) + v11) & ~v11, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 40);
  v14(v12, v13, AssociatedTypeWitness);
  v14((v12 + *(void *)(v10 + 64) + v11) & ~v11, (v13 + *(void *)(v10 + 64) + v11) & ~v11, AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for DefaultIndices(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v12 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v13 = *(void *)(v6 + 64) + v12;
  if (a2 <= v11) {
    goto LABEL_23;
  }
  uint64_t v14 = ((*(void *)(v9 + 64) + v12 + (v13 & ~v12)) & ~v12) + *(void *)(v9 + 64);
  char v15 = 8 * v14;
  if (v14 <= 3)
  {
    unsigned int v17 = ((a2 - v11 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      int v16 = *(_DWORD *)(a1 + v14);
      if (!v16) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v17 > 0xFF)
    {
      int v16 = *(unsigned __int16 *)(a1 + v14);
      if (!*(_WORD *)(a1 + v14)) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v17 < 2)
    {
LABEL_23:
      if (v11)
      {
        else {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))( (v13 + a1) & ~v12,  v10,  AssociatedTypeWitness);
        }
      }

      return 0LL;
    }
  }

  int v16 = *(unsigned __int8 *)(a1 + v14);
  if (!*(_BYTE *)(a1 + v14)) {
    goto LABEL_23;
  }
LABEL_14:
  int v18 = (v16 - 1) << v15;
  if ((_DWORD)v14)
  {
    else {
      int v19 = 4;
    }
    __asm { BR              X12 }
  }

  return v11 + v18 + 1;
}

void storeEnumTagSinglePayload for DefaultIndices(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                  - 8);
  if (*(_DWORD *)(v10 + 84) <= v9) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v10 + 84);
  }
  size_t v12 = ((*(void *)(v10 + 64)
        + *(unsigned __int8 *)(v10 + 80)
  if (a3 <= v11)
  {
    unsigned int v13 = 0u;
  }

  else if (v12 <= 3)
  {
    unsigned int v15 = ((a3 - v11 + ~(-1 << (8 * v12))) >> (8 * v12)) + 1;
    if (HIWORD(v15))
    {
      unsigned int v13 = 4u;
    }

    else if (v15 >= 0x100)
    {
      unsigned int v13 = 2;
    }

    else
    {
      unsigned int v13 = v15 > 1;
    }
  }

  else
  {
    unsigned int v13 = 1u;
  }

  if (v11 < a2)
  {
    unsigned int v14 = ~v11 + a2;
    if (v12 < 4)
    {
      if ((_DWORD)v12)
      {
        int v16 = v14 & ~(-1 << (8 * v12));
        bzero(a1, v12);
        if ((_DWORD)v12 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }

        else if ((_DWORD)v12 == 2)
        {
          *(_WORD *)a1 = v16;
        }

        else
        {
          *a1 = v16;
        }
      }
    }

    else
    {
      bzero(a1, v12);
      *(_DWORD *)a1 = v14;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X13 }

uint64_t dispatch thunk of static AdditiveArithmetic.+= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static AdditiveArithmetic.- infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of static AdditiveArithmetic.-= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of Numeric.init<A>(exactly:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

uint64_t dispatch thunk of Numeric.magnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of static Numeric.* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t dispatch thunk of static Numeric.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

uint64_t dispatch thunk of SignedNumeric.negate()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of static BinaryInteger.isSigned.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 96))();
}

uint64_t dispatch thunk of BinaryInteger.init<A>(clamping:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 104))();
}

uint64_t dispatch thunk of BinaryInteger._lowWord.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of BinaryInteger.bitWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of BinaryInteger.trailingZeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of static BinaryInteger./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of static BinaryInteger./= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 160))();
}

uint64_t dispatch thunk of static BinaryInteger.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 168))();
}

uint64_t dispatch thunk of static BinaryInteger.%= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 176))();
}

uint64_t dispatch thunk of static BinaryInteger.~ prefix(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 184))();
}

uint64_t dispatch thunk of static BinaryInteger.| infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 208))();
}

uint64_t dispatch thunk of static BinaryInteger.|= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 216))();
}

uint64_t dispatch thunk of static BinaryInteger.^ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 224))();
}

uint64_t dispatch thunk of static BinaryInteger.^= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 232))();
}

uint64_t dispatch thunk of static BinaryInteger.>> infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 240))();
}

uint64_t dispatch thunk of static BinaryInteger.>>= infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 248))();
}

uint64_t dispatch thunk of static BinaryInteger.<< infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 256))();
}

uint64_t dispatch thunk of static BinaryInteger.<<= infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 264))();
}

uint64_t dispatch thunk of BinaryInteger.quotientAndRemainder(dividingBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 272))();
}

uint64_t dispatch thunk of BinaryInteger.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 280))();
}

uint64_t dispatch thunk of BinaryInteger.signum()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 288))();
}

uint64_t dispatch thunk of static FixedWidthInteger.bitWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of static FixedWidthInteger.max.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of static FixedWidthInteger.min.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of FixedWidthInteger.addingReportingOverflow(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

uint64_t dispatch thunk of FixedWidthInteger.subtractingReportingOverflow(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

uint64_t dispatch thunk of FixedWidthInteger.multipliedReportingOverflow(by:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

uint64_t dispatch thunk of FixedWidthInteger.dividedReportingOverflow(by:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

uint64_t dispatch thunk of FixedWidthInteger.remainderReportingOverflow(dividingBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 112))();
}

uint64_t dispatch thunk of FixedWidthInteger.multipliedFullWidth(by:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 120))();
}

uint64_t dispatch thunk of FixedWidthInteger.dividingFullWidth(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 128))();
}

uint64_t dispatch thunk of FixedWidthInteger.init(_truncatingBits:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of FixedWidthInteger.leadingZeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of FixedWidthInteger.init(bigEndian:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 160))();
}

uint64_t dispatch thunk of FixedWidthInteger.init(littleEndian:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 168))();
}

uint64_t dispatch thunk of FixedWidthInteger.byteSwapped.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 192))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&>> infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 200))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&>>= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 208))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&<< infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 216))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&<<= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 224))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&* infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 232))();
}

uint64_t dispatch thunk of static SignedInteger._maskingAdd(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of static SignedInteger._maskingSubtract(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

unint64_t *type metadata completion function for JoinedSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for JoinedSequence(a1, a2, a3, (uint64_t)&unk_189B8B980);
}

unint64_t **initializeBufferWithCopyOfBuffer for DiscontiguousSlice( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  int v9 = *(_DWORD *)(v7 + 80);
  if ((v9 & 0x1000F8) != 0 || ((v8 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8 > 0x18)
  {
    size_t v12 = *a2;
    *uint64_t v5 = *a2;
    uint64_t v5 = (unint64_t **)((char *)v12
                             + ((unsigned __int16)((v9 & 0xF8) + 23) & (unsigned __int16)~(v9 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **))(v7 + 16))(a1, a2);
    unsigned int v11 = (unint64_t **)(((unint64_t)a2 + v8 + 7) & 0xFFFFFFFFFFFFF8LL);
    size_t v12 = *v11;
    *(void *)(((unint64_t)v5 + v8 + 7) & 0xFFFFFFFFFFFFF8LL) = *v11;
  }

  swift_retain(v12, (uint64_t)a2, v6, a4);
  return v5;
}

uint64_t destroy for DiscontiguousSlice(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 16) - 8LL);
  (*(void (**)(void))(v3 + 8))();
  return swift_release(*(void *)((a1 + *(void *)(v3 + 64) + 7) & 0xFFFFFFFFFFFFF8LL));
}

uint64_t initializeWithCopy for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 16))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  uint64_t v7 = (void *)((v6 + a1) & 0xFFFFFFFFFFFFF8LL);
  uint64_t v8 = (unint64_t **)((v6 + a2) & 0xFFFFFFFFFFFFF8LL);
  int v9 = *v8;
  *uint64_t v7 = *v8;
  swift_retain(v9, v10, v11, v12);
  return a1;
}

uint64_t assignWithCopy for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 24))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  uint64_t v7 = (uint64_t *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v8 = (unint64_t **)((v6 + a2) & 0xFFFFFFFFFFFFF8LL);
  int v9 = *v8;
  uint64_t v10 = *v7;
  *uint64_t v7 = (uint64_t)*v8;
  swift_retain(v9, v11, v12, v13);
  swift_release(v10);
  return a1;
}

uint64_t assignWithTake for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 40))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  uint64_t v7 = (uint64_t *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v8 = *v7;
  *uint64_t v7 = *(void *)((v6 + a2) & 0xFFFFFFFFFFFFF8LL);
  swift_release(v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for DiscontiguousSlice(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(v4 + 64);
  if (v6 >= a2)
  {
    if (v5 < 0x7FFFFFFF)
    {
      unint64_t v12 = *(void *)((a1 + v7 + 7) & 0xFFFFFFFFFFFFF8LL);
      if (v12 >= 0xFFFFFFFF) {
        LODWORD(v12) = -1;
      }
      return (v12 + 1);
    }

    else
    {
      return (*(uint64_t (**)(void))(v4 + 48))();
    }
  }

  else
  {
    if (((((v7 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8) & 0xFFFFFFF8) != 0) {
      unsigned int v8 = 2;
    }
    else {
      unsigned int v8 = a2 - v6 + 1;
    }
    if (v8 >= 0x10000) {
      unsigned int v9 = 4;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v8 < 0x100) {
      unsigned int v9 = 1;
    }
    if (v8 >= 2) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0LL;
    }
    return ((uint64_t (*)(void))((char *)&loc_181718D04 + 4 * byte_181800385[v10]))();
  }

void storeEnumTagSinglePayload for DiscontiguousSlice( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 16) - 8LL);
  if (*(_DWORD *)(v5 + 84) <= 0x7FFFFFFFu) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v5 + 84);
  }
  if (v6 >= a3)
  {
    int v9 = 0u;
    if (a2 <= v6) {
      goto LABEL_17;
    }
  }

  else
  {
    if (((*(_DWORD *)(v5 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
      unsigned int v7 = a3 - v6 + 1;
    }
    else {
      unsigned int v7 = 2;
    }
    if (v7 >= 0x10000) {
      int v8 = 4;
    }
    else {
      int v8 = 2;
    }
    if (v7 < 0x100) {
      int v8 = 1;
    }
    if (v7 >= 2) {
      int v9 = v8;
    }
    else {
      int v9 = 0;
    }
    if (a2 <= v6) {
LABEL_17:
    }
      __asm { BR              X12 }
  }

  if (((*(_DWORD *)(v5 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
  {
    unsigned int v10 = ~v6 + a2;
    bzero(a1, ((*(void *)(v5 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 8);
    *a1 = v10;
  }

  __asm { BR              X10 }

void sub_181718E7C()
{
  *(_BYTE *)(v0 + v1) = v2;
  JUMPOUT(0x181718EF0LL);
}

void sub_181718E84(uint64_t a1, int a2)
{
  *(_DWORD *)(v2 + v3) = 0;
  if (a2) {
    JUMPOUT(0x181718E8CLL);
  }
  JUMPOUT(0x181718EF0LL);
}

void sub_181718ECC()
{
  *(_WORD *)(v0 + v1) = v2;
  JUMPOUT(0x181718EF0LL);
}

void sub_181718ED4()
{
  *(_DWORD *)(v0 + v1) = v2;
  JUMPOUT(0x181718EF0LL);
}

uint64_t sub_181718EDC(uint64_t a1, int a2, unsigned int a3)
{
  *(_WORD *)(v5 + v6) = 0;
  if (!a2) {
    JUMPOUT(0x181718EF0LL);
  }
  if (a3 < 0x7FFFFFFF)
  {
    if ((a2 & 0x80000000) == 0) {
      JUMPOUT(0x181718EECLL);
    }
    JUMPOUT(0x181718EE8LL);
  }

  return (*(uint64_t (**)(uint64_t))(v4 + 56))(v5);
}

uint64_t type metadata instantiation function for JoinedSequence.Iterator( _DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x38);
}

unint64_t type metadata completion function for JoinedSequence.Iterator(void *a1)
{
  uint64_t v3 = a1[2];
  int v2 = (const char *)a1[3];
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v12[0] = *(void *)(result - 8) + 64LL;
    uint64_t v6 = (const char *)a1[4];
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    unint64_t result = type metadata accessor for Optional((const char *)0x13F, v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(void *)(result - 8) + 64LL;
      void v12[2] = &unk_189B8B980;
      v12[3] = &unk_1818090F8;
      v12[4] = &unk_181809110;
      swift_initStructMetadata((uint64_t)a1, 0, 5uLL, (char *)v12, (uint64_t)(a1 + 5));
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for JoinedSequence.Iterator( unint64_t **a1, unint64_t **a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v17 = *(void *)(v13 - 8);
  uint64_t v18 = *(_DWORD *)(v17 + 80);
  uint64_t v19 = v10 + v18;
  if (*(_DWORD *)(v17 + 84)) {
    size_t v20 = *(void *)(v17 + 64);
  }
  else {
    size_t v20 = *(void *)(v17 + 64) + 1LL;
  }
  unsigned int v21 = v18 | *(_DWORD *)(v9 + 80) & 0xF8;
  if (v21 > 7
    || ((*(_DWORD *)(v9 + 80) | *(_DWORD *)(v17 + 80)) & 0x100000) != 0
    || ((((v20 + ((v10 + v18) & ~v18) + 7) & 0xFFFFFFFFFFFFFFF8LL) + 15) & 0xFFFFFFFFFFFFFFF8LL) + 17 > 0x18)
  {
    uint64_t v24 = *a2;
    *a1 = v24;
    a1 = (unint64_t **)((char *)v24 + (((v21 | 7) + 16LL) & ~(unint64_t)(v21 | 7)));
  }

  else
  {
    unint64_t v25 = v13;
    uint64_t v26 = ~v18;
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))( a1,  a2,  AssociatedTypeWitness);
    uint64_t v27 = (const void *)(((unint64_t)a2 + v19) & v26);
    if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v17 + 48))(v27, 1LL, v25))
    {
      memcpy((void *)(((unint64_t)a1 + v19) & v26), v27, v20);
    }

    else
    {
      (*(void (**)(unint64_t, const void *, unint64_t))(v17 + 16))( ((unint64_t)a1 + v19) & v26,  v27,  v25);
      (*(void (**)(unint64_t, void, uint64_t, unint64_t))(v17 + 56))( ((unint64_t)a1 + v19) & v26,  0LL,  1LL,  v25);
    }

    uint64_t v31 = (void *)(((((unint64_t)a1 + v19) & v26) + v20 + 7) & 0xFFFFFFFFFFFFF8LL);
    unint64_t v32 = (unint64_t **)(((unint64_t)v27 + v20 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    unint64_t v33 = *v32;
    *uint64_t v31 = *v32;
    unint64_t v34 = ((unint64_t)v31 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v35 = ((unint64_t)v32 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v24 = *(unint64_t **)v35;
    *(void *)unint64_t v34 = *(void *)v35;
    *(void *)(v34 + 8) = *(void *)(v35 + 8);
    *(_BYTE *)(v34 + 16) = *(_BYTE *)(v35 + 16);
    swift_retain(v33, v28, v29, v30);
  }

  swift_retain(v24, v14, v15, v16);
  return a1;
}

uint64_t destroy for JoinedSequence.Iterator(uint64_t a1, void *a2)
{
  uint64_t v5 = a2[2];
  uint64_t v4 = (const char *)a2[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 64) + a1;
  uint64_t v9 = (const char *)a2[4];
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  v9,  v10,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v12 = *(void *)(v11 - 8);
  unint64_t v13 = (v8 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  unint64_t v14 = v13 + *(void *)(v12 + 64);
  if (!*(_DWORD *)(v12 + 84)) {
    ++v14;
  }
  unint64_t v15 = v14 + 7;
  unint64_t v16 = (v15 & 0xFFFFFFFFFFFFFFF8LL) + 15;
  swift_release(*(void *)(v15 & 0xFFFFFFFFFFFFFFF8LL));
  return swift_release(*(void *)(v16 & 0xFFFFFFFFFFFFF8LL));
}

uint64_t initializeWithCopy for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1LL, v13))
  {
    int v18 = *(_DWORD *)(v14 + 84);
    size_t v19 = *(void *)(v14 + 64);
    if (v18) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v19 + 1;
    }
    memcpy(v16, v17, v20);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 16))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
    int v18 = *(_DWORD *)(v14 + 84);
    size_t v19 = *(void *)(v14 + 64);
  }

  if (v18) {
    size_t v24 = v19;
  }
  else {
    size_t v24 = v19 + 1;
  }
  unint64_t v25 = (void *)(((unint64_t)v16 + v24 + 7) & 0xFFFFFFFFFFFFF8LL);
  uint64_t v26 = (unint64_t **)(((unint64_t)v17 + v24 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v27 = *v26;
  *unint64_t v25 = *v26;
  unint64_t v28 = ((unint64_t)v25 + 15) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v29 = ((unint64_t)v26 + 15) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v30 = *(unint64_t **)v29;
  *(void *)unint64_t v28 = *(void *)v29;
  *(void *)(v28 + 8) = *(void *)(v29 + 8);
  *(_BYTE *)(v28 + 16) = *(_BYTE *)(v29 + 16);
  swift_retain(v27, v21, v22, v23);
  swift_retain(v30, v31, v32, v33);
  return a1;
}

uint64_t assignWithCopy for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 24))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  int v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1LL, v13);
  int v19 = v18(v17, 1LL, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
      goto LABEL_10;
    }
  }

  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 24))(v16, v17, v13);
      goto LABEL_10;
    }

    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }

  if (*(_DWORD *)(v14 + 84)) {
    size_t v23 = *(void *)(v14 + 64);
  }
  else {
    size_t v23 = *(void *)(v14 + 64) + 1LL;
  }
  memcpy(v16, v17, v23);
LABEL_10:
  if (*(_DWORD *)(v14 + 84)) {
    uint64_t v24 = *(void *)(v14 + 64);
  }
  else {
    uint64_t v24 = *(void *)(v14 + 64) + 1LL;
  }
  uint64_t v25 = (uint64_t)v16 + v24 + 7;
  uint64_t v26 = (uint64_t)v17 + v24 + 7;
  unint64_t v28 = (v26 & 0xFFFFFFFFFFFFFFF8LL) + 15;
  uint64_t v27 = *(unint64_t **)(v26 & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v29 = *(void *)(v25 & 0xFFFFFFFFFFFFFFF8LL);
  *(void *)(v25 & 0xFFFFFFFFFFFFFFF8LL) = v27;
  unint64_t v30 = (v25 & 0xFFFFFFFFFFFFFFF8LL) + 15;
  swift_retain(v27, v20, v21, v22);
  swift_release(v29);
  v30 &= 0xFFFFFFFFFFFFFFF8LL;
  v28 &= 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v31 = *(unint64_t **)v28;
  uint64_t v32 = *(void *)v30;
  *(void *)unint64_t v30 = *(void *)v28;
  swift_retain(v31, v33, v34, v35);
  swift_release(v32);
  *(void *)(v30 + 8) = *(void *)(v28 + 8);
  *(_BYTE *)(v30 + 16) = *(_BYTE *)(v28 + 16);
  return a1;
}

uint64_t initializeWithTake for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 32))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1LL, v13))
  {
    int v18 = *(_DWORD *)(v14 + 84);
    size_t v19 = *(void *)(v14 + 64);
    if (v18) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v19 + 1;
    }
    memcpy(v16, v17, v20);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 32))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
    int v18 = *(_DWORD *)(v14 + 84);
    size_t v19 = *(void *)(v14 + 64);
  }

  if (v18) {
    size_t v21 = v19;
  }
  else {
    size_t v21 = v19 + 1;
  }
  uint64_t v22 = (void *)(((unint64_t)v16 + v21 + 7) & 0xFFFFFFFFFFFFF8LL);
  size_t v23 = (void *)(((unint64_t)v17 + v21 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  void *v22 = *v23;
  unint64_t v24 = ((unint64_t)v22 + 15) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v25 = ((unint64_t)v23 + 15) & 0xFFFFFFFFFFFFFFF8LL;
  *(_OWORD *)unint64_t v24 = *(_OWORD *)v25;
  *(_BYTE *)(v24 + 16) = *(_BYTE *)(v25 + 16);
  return a1;
}

uint64_t assignWithTake for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 40))(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  int v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1LL, v13);
  int v19 = v18(v17, 1LL, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v14 + 56))(v16, 0LL, 1LL, v13);
      goto LABEL_10;
    }
  }

  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 40))(v16, v17, v13);
      goto LABEL_10;
    }

    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }

  if (*(_DWORD *)(v14 + 84)) {
    size_t v20 = *(void *)(v14 + 64);
  }
  else {
    size_t v20 = *(void *)(v14 + 64) + 1LL;
  }
  memcpy(v16, v17, v20);
LABEL_10:
  if (*(_DWORD *)(v14 + 84)) {
    uint64_t v21 = *(void *)(v14 + 64);
  }
  else {
    uint64_t v21 = *(void *)(v14 + 64) + 1LL;
  }
  uint64_t v22 = (uint64_t)v16 + v21 + 7;
  size_t v23 = (void *)(((unint64_t)v17 + v21 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v24 = *(void *)(v22 & 0xFFFFFFFFFFFFFFF8LL);
  *(void *)(v22 & 0xFFFFFFFFFFFFFFF8LL) = *v23;
  unint64_t v25 = (v22 & 0xFFFFFFFFFFFFFFF8LL) + 15;
  swift_release(v24);
  v25 &= 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v26 = ((unint64_t)v23 + 15) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v27 = *(void *)v25;
  *(void *)unint64_t v25 = *(void *)v26;
  swift_release(v27);
  *(void *)(v25 + 8) = *(void *)(v26 + 8);
  *(_BYTE *)(v25 + 16) = *(_BYTE *)(v26 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for JoinedSequence.Iterator(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (const char *)a3[3];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  unint64_t v11 = (const char *)a3[4];
  unint64_t v12 = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v13 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v11,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                  - 8);
  unsigned int v14 = *(_DWORD *)(v13 + 84);
  if (v14) {
    unsigned int v15 = v14 - 1;
  }
  else {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  if (v16 <= 0x7FFFFFFF) {
    unsigned int v16 = 0x7FFFFFFF;
  }
  uint64_t v17 = *(void *)(v13 + 64);
  if (!v14) {
    ++v17;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v18 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v19 = *(void *)(v9 + 64) + v18;
  uint64_t v20 = v17 + 7;
  if (v16 < a2)
  {
    unsigned int v21 = ((((v20 + (v19 & ~(_DWORD)v18)) & 0xFFFFFFF8) + 15) & 0xFFFFFFF8) + 17;
    if (v21 < 4) {
      unsigned int v22 = ((a2 - v16 + 255) >> (8 * v21)) + 1;
    }
    else {
      unsigned int v22 = 2;
    }
    if (v22 >= 0x10000) {
      unsigned int v23 = 4;
    }
    else {
      unsigned int v23 = 2;
    }
    if (v22 < 0x100) {
      unsigned int v23 = 1;
    }
    if (v22 >= 2) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 0LL;
    }
    __asm { BR              X0 }
  }

  if ((_DWORD)v10 == v16) {
    return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))(a1, v10, AssociatedTypeWitness);
  }
  uint64_t v26 = (v19 + a1) & ~v18;
  if (v15 == v16)
  {
    if (v14 < 2) {
      return 0LL;
    }
    unsigned int v28 = (*(uint64_t (**)(uint64_t))(v13 + 48))(v26);
    if (v28 >= 2) {
      return v28 - 1;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    unint64_t v27 = *(void *)((v20 + v26) & 0xFFFFFFFFFFFFF8LL);
    if (v27 >= 0xFFFFFFFF) {
      LODWORD(v27) = -1;
    }
    return (v27 + 1);
  }

void storeEnumTagSinglePayload for JoinedSequence.Iterator( _BYTE *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v9 = a4[2];
  uint64_t v8 = (const char *)a4[3];
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v8,  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                  - 8);
  unsigned int v11 = *(_DWORD *)(v10 + 84);
  unint64_t v12 = (const char *)a4[4];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  int v14 = 0u;
  uint64_t v15 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                  - 8);
  int v16 = *(_DWORD *)(v15 + 84);
  unsigned int v17 = v16 - 1;
  if (!v16) {
    unsigned int v17 = 0;
  }
  if (v17 <= v11) {
    unsigned int v18 = v11;
  }
  else {
    unsigned int v18 = v17;
  }
  if (v18 <= 0x7FFFFFFF) {
    unsigned int v18 = 0x7FFFFFFF;
  }
  uint64_t v19 = *(void *)(v15 + 64);
  if (!v16) {
    ++v19;
  }
  size_t v20 = ((((v19
          + 7
          + ((*(void *)(v10 + 64) + *(unsigned __int8 *)(v15 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80))) & 0xFFFFFFFFFFFFFFF8LL)
        + 15) & 0xFFFFFFFFFFFFFFF8LL)
      + 17;
  if (v18 < a3)
  {
    else {
      unsigned int v21 = 2;
    }
    if (v21 >= 0x10000) {
      int v22 = 4;
    }
    else {
      int v22 = 2;
    }
    if (v21 < 0x100) {
      int v22 = 1;
    }
    if (v21 >= 2) {
      int v14 = v22;
    }
    else {
      int v14 = 0;
    }
  }

  if (v18 < a2)
  {
    int v23 = ~v18 + a2;
    int v24 = (~(_BYTE)v18 + a2);
    else {
      int v25 = v24;
    }
    bzero(a1, v20);
    if ((_DWORD)v20 == 1) {
      *a1 = v25;
    }
    else {
      *(_DWORD *)a1 = v25;
    }
    __asm { BR              X10 }
  }

  __asm { BR              X16 }

void sub_181719E24()
{
  *(_BYTE *)(v0 + v2) = v1;
  JUMPOUT(0x181719EC4LL);
}

void sub_181719E2C()
{
  *(_DWORD *)(v0 + v2) = 0;
  if (v1) {
    JUMPOUT(0x181719E34LL);
  }
  JUMPOUT(0x181719EC4LL);
}

void sub_181719E8C()
{
  *(_WORD *)(v0 + v2) = v1;
  JUMPOUT(0x181719EC4LL);
}

void sub_181719E94()
{
  *(_DWORD *)(v0 + v2) = v1;
  JUMPOUT(0x181719EC4LL);
}

uint64_t sub_181719E9C@<X0>(uint64_t a1@<X2>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  *(_WORD *)(v11 + v15) = 0;
  if (!(_DWORD)v12) {
    JUMPOUT(0x181719EC4LL);
  }
  if ((_DWORD)v14 == v8)
  {
    uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 56);
    uint64_t v4 = v11;
    uint64_t v5 = v12;
    a1 = v14;
    a2 = v16;
  }

  else
  {
    uint64_t v4 = (v9 + v11) & v10;
    if (v7 != v8) {
      JUMPOUT(0x181719EA8LL);
    }
    uint64_t v5 = (v12 + 1);
    uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 56);
  }

  return v3(v4, v5, a1, a2);
}

uint64_t type metadata accessor for JoinedSequence.Iterator._JoinIteratorState( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for JoinedSequence.Iterator._JoinIteratorState);
}

uint64_t type metadata accessor for AnyKeyPath()
{
  return objc_opt_self();
}

uint64_t method lookup function for AnyKeyPath(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for AnyKeyPath);
}

uint64_t dispatch thunk of AnyKeyPath._kvcKeyPathString.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 104LL))();
}

uint64_t dispatch thunk of static AnyKeyPath._rootAndValueType.getter()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t dispatch thunk of AnyKeyPath._storedInlineOffset.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 128LL))();
}

swift *type metadata completion function for PartialKeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 144);
}

swift *type metadata completion function for KeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 160);
}

uint64_t method lookup function for KeyPath(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for KeyPath);
}

uint64_t method lookup function for WritableKeyPath(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for WritableKeyPath);
}

uint64_t dispatch thunk of WritableKeyPath._projectMutableAddress(from:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 184LL))();
}

swift *type metadata completion function for ReferenceWritableKeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 208);
}

swift *type metadata completion function for ClassHolder(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = &value witness table for Builtin.UnknownObject.size;
  return swift_initClassMetadata2(a1, 0, 2uLL, (uint64_t)v2, a1 + 88);
}

uint64_t type metadata accessor for ClassHolder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ClassHolder);
}

void *type metadata completion function for MutatingWritebackBuffer(uint64_t a1)
{
  v4[0] = "\b";
  v4[1] = &unk_189B8BA30;
  void v4[2] = &unk_189B8BA30;
  v4[3] = &unk_189B8BA30;
  uint64_t v4[4] = &value witness table for Builtin.Int64.size;
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 88));
  if (v3 <= 0x3F)
  {
    v4[5] = *(result - 1) + 64LL;
    unint64_t result = swift_initClassMetadata2(a1, 0, 6uLL, (uint64_t)v4, a1 + 96);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t type metadata accessor for MutatingWritebackBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for MutatingWritebackBuffer);
}

void *type metadata completion function for NonmutatingWritebackBuffer(uint64_t a1)
{
  v5[0] = "\b";
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 80));
  if (v3 <= 0x3F)
  {
    v5[1] = *(result - 1) + 64LL;
    unint64_t v5[2] = &unk_189B8BA30;
    v5[3] = &unk_189B8BA30;
    v5[4] = &value witness table for Builtin.Int64.size;
    unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 88));
    if (v4 <= 0x3F)
    {
      v5[5] = *(result - 1) + 64LL;
      unint64_t result = swift_initClassMetadata2(a1, 0, 6uLL, (uint64_t)v5, a1 + 96);
      if (!result) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t type metadata accessor for NonmutatingWritebackBuffer( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for NonmutatingWritebackBuffer);
}

unint64_t default associated conformance accessor for LazyCollectionProtocol.LazySequenceProtocol.Elements: Collection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a3 + 16),  a2,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  return swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for LazyCollectionProtocol,  (uint64_t)&associated conformance descriptor for LazyCollectionProtocol.LazySequenceProtocol.Elements: Collection);
}

unint64_t default associated conformance accessor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence( uint64_t a1, uint64_t a2, const char *a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a3,  a2,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  return swift_getAssociatedConformanceWitness( (uint64_t)a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  (uint64_t)&associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
}

uint64_t destroy for LazySequence(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a2 + 16) - 8LL) + 8LL))();
}

uint64_t initializeWithCopy for LazySequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t assignWithCopy for LazySequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t initializeWithTake for LazySequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t assignWithTake for LazySequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

void *type metadata completion function for _IndexBox(uint64_t a1)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 80));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64LL;
    unint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 96);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

uint64_t method lookup function for ManagedBuffer(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for ManagedBuffer);
}

uint64_t dispatch thunk of ManagedBuffer.__allocating_init(_doNotCallMe:)()
{
  return (*(uint64_t (**)(void))(v0 + 104))();
}

uint64_t type metadata accessor for ManagedBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ManagedBufferPointer);
}

unint64_t *type metadata completion function for LazyMapSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for JoinedSequence(a1, a2, a3, (uint64_t)&unk_189B8CBB8);
}

unint64_t *type metadata completion function for JoinedSequence( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v7 <= 0x3F)
  {
    v8[0] = *(result - 1) + 64;
    v8[1] = a4;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v8, a1 + 40);
    return 0LL;
  }

  return result;
}

unint64_t type metadata completion function for LazyMapSequence.Iterator(uint64_t a1)
{
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 32),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v4[0] = *(void *)(result - 8) + 64LL;
    v4[1] = &unk_189B8CBB8;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v4, a1 + 40);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for LazyMapSequence.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(void *)(v9 + 64);
  int v11 = *(_DWORD *)(v9 + 80);
  if ((v11 & 0x1000F8) != 0 || ((v10 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 16 > 0x18)
  {
    uint64_t v14 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v14
                             + ((unsigned __int16)((v11 & 0xF8) + 23) & (unsigned __int16)~(v11 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))( a1,  a2,  AssociatedTypeWitness);
    uint64_t v13 = (void *)(((unint64_t)a2 + v10 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v14 = (unint64_t *)v13[1];
    uint64_t v15 = (void *)(((unint64_t)a1 + v10 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    *uint64_t v15 = *v13;
    v15[1] = v14;
  }

  swift_retain(v14, v6, v7, v8);
  return a1;
}

uint64_t destroy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 32),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v4 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v4 + 8))(a1, AssociatedTypeWitness);
  return swift_release(*(void *)(((a1 + *(void *)(v4 + 64) + 7) & 0xFFFFFFFFFFFFF8LL) + 8));
}

uint64_t initializeWithCopy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 16))(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 64) + 7LL;
  int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v10 = (unint64_t *)v9[1];
  *int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10, v11, v12, v13);
  return a1;
}

uint64_t assignWithCopy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 24))(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 64) + 7LL;
  int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v10 = (unint64_t *)v9[1];
  uint64_t v11 = v8[1];
  *int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10, v12, v13, v14);
  swift_release(v11);
  return a1;
}

uint64_t initializeWithTake for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 32))(a1, a2, AssociatedTypeWitness);
  *(_OWORD *)((*(void *)(v6 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(_OWORD *)((*(void *)(v6 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t assignWithTake for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 40))(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 64) + 7LL;
  unint64_t v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v9 = *(void *)(v8 + 8);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)((v7 + a2) & 0xFFFFFFFFFFFFF8LL);
  swift_release(v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyMapSequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  unsigned int v6 = *(_DWORD *)(v5 + 84);
  if (v6 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v5 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(v5 + 64);
  if (v7 < a2)
  {
    if (((((v8 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 16) & 0xFFFFFFF8) != 0) {
      unsigned int v9 = 2;
    }
    else {
      unsigned int v9 = a2 - v7 + 1;
    }
    if (v9 >= 0x10000) {
      unsigned int v10 = 4;
    }
    else {
      unsigned int v10 = 2;
    }
    if (v9 < 0x100) {
      unsigned int v10 = 1;
    }
    if (v9 >= 2) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0LL;
    }
    __asm { BR              X15 }
  }

  if (v6 >= 0x7FFFFFFF) {
    return (*(uint64_t (**)(uint64_t))(v5 + 48))(a1);
  }
  unint64_t v13 = *(void *)((a1 + v8 + 7) & 0xFFFFFFFFFFFFF8LL);
  if (v13 >= 0xFFFFFFFF) {
    LODWORD(v13) = -1;
  }
  return (v13 + 1);
}

void storeEnumTagSinglePayload for LazyMapSequence.Iterator( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 32),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  if (*(_DWORD *)(v7 + 84) <= 0x7FFFFFFFu) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v7 + 84);
  }
  if (v8 >= a3)
  {
    int v11 = 0u;
    if (a2 <= v8) {
      goto LABEL_17;
    }
  }

  else
  {
    if (((*(_DWORD *)(v7 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
      unsigned int v9 = a3 - v8 + 1;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v9 >= 0x10000) {
      int v10 = 4;
    }
    else {
      int v10 = 2;
    }
    if (v9 < 0x100) {
      int v10 = 1;
    }
    if (v9 >= 2) {
      int v11 = v10;
    }
    else {
      int v11 = 0;
    }
    if (a2 <= v8) {
LABEL_17:
    }
      __asm { BR              X12 }
  }

  if (((*(_DWORD *)(v7 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
  {
    unsigned int v12 = ~v8 + a2;
    bzero(a1, ((*(void *)(v7 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 16);
    *a1 = v12;
  }

  __asm { BR              X10 }

void sub_18171AABC()
{
  *(_BYTE *)(v0 + v1) = v2;
  JUMPOUT(0x18171AB38LL);
}

void sub_18171AAC4()
{
  *(_DWORD *)(v0 + v2) = 0;
  if (v1) {
    JUMPOUT(0x18171AACCLL);
  }
  JUMPOUT(0x18171AB38LL);
}

void sub_18171AB10()
{
  *(_WORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171AB38LL);
}

void sub_18171AB18()
{
  *(_DWORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171AB38LL);
}

uint64_t sub_18171AB20@<X0>(unsigned int a1@<W2>, uint64_t a2@<X8>)
{
  *(_WORD *)(v3 + v5) = 0;
  if (!(_DWORD)v4) {
    JUMPOUT(0x18171AB38LL);
  }
  if (a1 < 0x7FFFFFFF)
  {
    if ((v4 & 0x80000000) == 0) {
      JUMPOUT(0x18171AB34LL);
    }
    JUMPOUT(0x18171AB2CLL);
  }

  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(v3, v4);
}

uint64_t type metadata accessor for MemoryLayout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for MemoryLayout);
}

ValueMetadata *type metadata accessor for Unicode.Scalar()
{
  return &type metadata for Unicode.Scalar;
}

ValueMetadata *type metadata accessor for Unicode.Scalar.UTF16View()
{
  return &type metadata for Unicode.Scalar.UTF16View;
}

ValueMetadata *type metadata accessor for Unicode.Scalar.UTF8View()
{
  return &type metadata for Unicode.Scalar.UTF8View;
}

uint64_t default associated conformance accessor for MutableCollection.Collection.SubSequence: MutableCollection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t dispatch thunk of MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of MutableCollection.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of MutableCollection.partition(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of MutableCollection.swapAt(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t dispatch thunk of MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 80))();
}

uint64_t type metadata accessor for _NativeDictionary.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _NativeDictionary.Iterator);
}

uint64_t destroy for _NativeSet.Iterator(uint64_t *a1)
{
  return swift_release(*a1);
}

uint64_t initializeWithCopy for _NativeSet.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(unint64_t **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  swift_retain(v5, a2, a3, a4);
  return a1;
}

uint64_t *assignWithCopy for _NativeDictionary.Iterator( uint64_t *a1, unint64_t **a2, uint64_t a3, char *a4)
{
  unsigned int v6 = *a2;
  uint64_t v7 = *a1;
  *a1 = (uint64_t)*a2;
  swift_retain(v6, (uint64_t)a2, a3, a4);
  swift_release(v7);
  a1[1] = (uint64_t)a2[1];
  a1[2] = (uint64_t)a2[2];
  a1[3] = (uint64_t)a2[3];
  a1[4] = (uint64_t)a2[4];
  return a1;
}

uint64_t assignWithTake for _NativeDictionary.Iterator(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for _NativeDictionary.Iterator(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _NativeDictionary.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)unint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)unint64_t result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t type metadata accessor for _NativeSet.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _NativeSet.Iterator);
}

ValueMetadata *type metadata accessor for ObjectIdentifier()
{
  return &type metadata for ObjectIdentifier;
}

unint64_t *type metadata completion function for ClosedRange<>.Index(uint64_t a1)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    swift_initEnumMetadataSinglePayload(a1, 0, *(result - 1) + 64, (char *)1);
    return 0LL;
  }

  return result;
}

ValueMetadata *type metadata accessor for _OptionalNilComparisonType()
{
  return &type metadata for _OptionalNilComparisonType;
}

uint64_t dispatch thunk of TextOutputStream._lock()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of TextOutputStream._unlock()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of TextOutputStream.write(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of TextOutputStreamable.write<A>(to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 8))();
}

uint64_t dispatch thunk of CustomStringConvertible.description.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _Pointer.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

ValueMetadata *type metadata accessor for Never()
{
  return &type metadata for Never;
}

unint64_t **initializeBufferWithCopyOfBuffer for LazyDropWhileSequence( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  int v9 = *(_DWORD *)(v7 + 80);
  if ((v9 & 0x1000F8) != 0 || ((v8 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 16 > 0x18)
  {
    unsigned int v12 = *a2;
    *uint64_t v5 = *a2;
    uint64_t v5 = (unint64_t **)((char *)v12
                             + ((unsigned __int16)((v9 & 0xF8) + 23) & (unsigned __int16)~(v9 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **))(v7 + 16))(a1, a2);
    int v11 = (void *)(((unint64_t)a2 + v8 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    unsigned int v12 = (unint64_t *)v11[1];
    unint64_t v13 = (void *)(((unint64_t)v5 + v8 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    *unint64_t v13 = *v11;
    v13[1] = v12;
  }

  swift_retain(v12, (uint64_t)a2, v6, a4);
  return v5;
}

uint64_t destroy for LazyDropWhileSequence(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 16) - 8LL);
  (*(void (**)(void))(v3 + 8))();
  return swift_release(*(void *)(((a1 + *(void *)(v3 + 64) + 7) & 0xFFFFFFFFFFFFF8LL) + 8));
}

uint64_t initializeWithCopy for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 16))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  uint64_t v7 = (void *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v8 = (void *)((v6 + a2) & 0xFFFFFFFFFFFFFFF8LL);
  int v9 = (unint64_t *)v8[1];
  *uint64_t v7 = *v8;
  v7[1] = v9;
  swift_retain(v9, v10, v11, v12);
  return a1;
}

uint64_t assignWithCopy for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 24))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  uint64_t v7 = (void *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v8 = (void *)((v6 + a2) & 0xFFFFFFFFFFFFFFF8LL);
  int v9 = (unint64_t *)v8[1];
  uint64_t v10 = v7[1];
  *uint64_t v7 = *v8;
  v7[1] = v9;
  swift_retain(v9, v11, v12, v13);
  swift_release(v10);
  return a1;
}

uint64_t initializeWithTake for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 32))();
  *(_OWORD *)((*(void *)(v5 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(_OWORD *)((*(void *)(v5 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t assignWithTake for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 40))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v8 = *(void *)(v7 + 8);
  *(_OWORD *)unint64_t v7 = *(_OWORD *)((v6 + a2) & 0xFFFFFFFFFFFFF8LL);
  swift_release(v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyDropWhileSequence(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(v4 + 64);
  if (v6 >= a2)
  {
    if (v5 < 0x7FFFFFFF)
    {
      unint64_t v12 = *(void *)((a1 + v7 + 7) & 0xFFFFFFFFFFFFF8LL);
      if (v12 >= 0xFFFFFFFF) {
        LODWORD(v12) = -1;
      }
      return (v12 + 1);
    }

    else
    {
      return (*(uint64_t (**)(void))(v4 + 48))();
    }
  }

  else
  {
    if (((((v7 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 16) & 0xFFFFFFF8) != 0) {
      unsigned int v8 = 2;
    }
    else {
      unsigned int v8 = a2 - v6 + 1;
    }
    if (v8 >= 0x10000) {
      unsigned int v9 = 4;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v8 < 0x100) {
      unsigned int v9 = 1;
    }
    if (v8 >= 2) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0LL;
    }
    return ((uint64_t (*)(void))((char *)&loc_18171B178 + 4 * byte_1818003B2[v10]))();
  }

void storeEnumTagSinglePayload for LazyDropWhileSequence( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 16) - 8LL);
  if (*(_DWORD *)(v5 + 84) <= 0x7FFFFFFFu) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v5 + 84);
  }
  if (v6 >= a3)
  {
    int v9 = 0u;
    if (a2 <= v6) {
      goto LABEL_17;
    }
  }

  else
  {
    if (((*(_DWORD *)(v5 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
      unsigned int v7 = a3 - v6 + 1;
    }
    else {
      unsigned int v7 = 2;
    }
    if (v7 >= 0x10000) {
      int v8 = 4;
    }
    else {
      int v8 = 2;
    }
    if (v7 < 0x100) {
      int v8 = 1;
    }
    if (v7 >= 2) {
      int v9 = v8;
    }
    else {
      int v9 = 0;
    }
    if (a2 <= v6) {
LABEL_17:
    }
      __asm { BR              X12 }
  }

  if (((*(_DWORD *)(v5 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
  {
    unsigned int v10 = ~v6 + a2;
    bzero(a1, ((*(void *)(v5 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 16);
    *a1 = v10;
  }

  __asm { BR              X10 }

void sub_18171B2F0()
{
  *(_BYTE *)(v0 + v1) = v2;
  JUMPOUT(0x18171B368LL);
}

void sub_18171B2F8(uint64_t a1, int a2)
{
  *(_DWORD *)(v2 + v3) = 0;
  if (a2) {
    JUMPOUT(0x18171B300LL);
  }
  JUMPOUT(0x18171B368LL);
}

void sub_18171B340()
{
  *(_WORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171B368LL);
}

void sub_18171B348()
{
  *(_DWORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171B368LL);
}

uint64_t sub_18171B350(uint64_t a1, int a2, unsigned int a3)
{
  *(_WORD *)(v5 + v6) = 0;
  if (!a2) {
    JUMPOUT(0x18171B368LL);
  }
  if (a3 < 0x7FFFFFFF)
  {
    if ((a2 & 0x80000000) == 0) {
      JUMPOUT(0x18171B364LL);
    }
    JUMPOUT(0x18171B35CLL);
  }

  return (*(uint64_t (**)(uint64_t))(v4 + 56))(v5);
}

unint64_t type metadata completion function for LazyDropWhileSequence.Iterator(uint64_t a1)
{
  v4[0] = &unk_181808918;
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v4[1] = *(void *)(result - 8) + 64LL;
    void v4[2] = &unk_189B8CBB8;
    swift_initStructMetadata(a1, 0, 3uLL, (char *)v4, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for LazyDropWhileSequence.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  uint64_t v11 = *(void *)(v9 + 64) + 7LL;
  if (v10 > 7
    || (*(_DWORD *)(v9 + 80) & 0x100000) != 0
    || ((v11 + ((v10 + 1) & ~v10)) & 0xFFFFFFFFFFFFFFF8LL) + 16 > 0x18)
  {
    size_t v20 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v20 + ((v10 & 0xF8 ^ 0x1F8) & (v10 + 16)));
  }

  else
  {
    uint64_t v14 = ~v10;
    *(_BYTE *)a1 = *(_BYTE *)a2;
    uint64_t v15 = (char *)a1 + v10;
    uint64_t v16 = (char *)a2 + v10;
    uint64_t v17 = (unint64_t)(v15 + 1) & v14;
    uint64_t v18 = (unint64_t)(v16 + 1) & v14;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16))(v17, v18, AssociatedTypeWitness);
    uint64_t v19 = (void *)((v11 + v18) & 0xFFFFFFFFFFFFFFF8LL);
    size_t v20 = (unint64_t *)v19[1];
    unsigned int v21 = (void *)((v11 + v17) & 0xFFFFFFFFFFFFFFF8LL);
    *unsigned int v21 = *v19;
    v21[1] = v20;
  }

  swift_retain(v20, v6, v7, v8);
  return a1;
}

uint64_t destroy for LazyDropWhileSequence.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v4 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v5 = (a1 + *(unsigned __int8 *)(v4 + 80) + 1) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
  (*(void (**)(unint64_t, unint64_t))(v4 + 8))(v5, AssociatedTypeWitness);
  return swift_release(*(void *)(((*(void *)(v4 + 64) + v5 + 7) & 0xFFFFFFFFFFFFF8LL) + 8));
}

_BYTE *initializeWithCopy for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = (unint64_t)&a1[v7 + 1] & ~v7;
  uint64_t v9 = (unint64_t)&a2[v7 + 1] & ~v7;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 16))(v8, v9, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v6 + 64) + 7LL;
  uint64_t v11 = (void *)((v10 + v8) & 0xFFFFFFFFFFFFFFF8LL);
  unint64_t v12 = (void *)((v10 + v9) & 0xFFFFFFFFFFFFFFF8LL);
  unint64_t v13 = (unint64_t *)v12[1];
  *uint64_t v11 = *v12;
  v11[1] = v13;
  swift_retain(v13, v14, v15, v16);
  return a1;
}

_BYTE *assignWithCopy for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = (unint64_t)&a1[v7 + 1] & ~v7;
  uint64_t v9 = (unint64_t)&a2[v7 + 1] & ~v7;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 24))(v8, v9, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v6 + 64) + 7LL;
  uint64_t v11 = (void *)((v10 + v8) & 0xFFFFFFFFFFFFFFF8LL);
  unint64_t v12 = (void *)((v10 + v9) & 0xFFFFFFFFFFFFFFF8LL);
  unint64_t v13 = (unint64_t *)v12[1];
  uint64_t v14 = v11[1];
  *uint64_t v11 = *v12;
  v11[1] = v13;
  swift_retain(v13, v15, v16, v17);
  swift_release(v14);
  return a1;
}

_BYTE *initializeWithTake for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = (unint64_t)&a1[v7 + 1] & ~v7;
  uint64_t v9 = (unint64_t)&a2[v7 + 1] & ~v7;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 32))(v8, v9, AssociatedTypeWitness);
  *(_OWORD *)((*(void *)(v6 + 64) + 7LL + v8) & 0xFFFFFFFFFFFFF8LL) = *(_OWORD *)((*(void *)(v6 + 64) + 7LL + v9) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

_BYTE *assignWithTake for LazyDropWhileSequence.Iterator(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = *a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = (unint64_t)&a1[v7 + 1] & ~v7;
  uint64_t v9 = (unint64_t)&a2[v7 + 1] & ~v7;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 40))(v8, v9, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v6 + 64) + 7LL;
  unint64_t v11 = (v10 + v8) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v12 = *(void *)(v11 + 8);
  *(_OWORD *)unint64_t v11 = *(_OWORD *)((v10 + v9) & 0xFFFFFFFFFFFFF8LL);
  swift_release(v12);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyDropWhileSequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  unsigned int v6 = *(_DWORD *)(v5 + 84);
  if (v6 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v5 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v8 = *(unsigned __int8 *)(v5 + 80);
  uint64_t v9 = *(void *)(v5 + 64) + 7LL;
  if (v7 < a2)
  {
    if (((((v9 + ((v8 + 1) & ~v8)) & 0xFFFFFFFFFFFFFFF8LL) + 16) & 0xFFFFFFF8) != 0) {
      unsigned int v10 = 2;
    }
    else {
      unsigned int v10 = a2 - v7 + 1;
    }
    if (v10 >= 0x10000) {
      unsigned int v11 = 4;
    }
    else {
      unsigned int v11 = 2;
    }
    if (v10 < 0x100) {
      unsigned int v11 = 1;
    }
    if (v10 >= 2) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0LL;
    }
    __asm { BR              X16 }
  }

  uint64_t v14 = (a1 + v8 + 1) & ~v8;
  if (v6 >= 0x7FFFFFFF) {
    return (*(uint64_t (**)(uint64_t))(v5 + 48))(v14);
  }
  unint64_t v15 = *(void *)((v9 + v14) & 0xFFFFFFFFFFFFF8LL);
  if (v15 >= 0xFFFFFFFF) {
    LODWORD(v15) = -1;
  }
  return (v15 + 1);
}

void storeEnumTagSinglePayload for LazyDropWhileSequence.Iterator( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  if (*(_DWORD *)(v7 + 84) <= 0x7FFFFFFFu) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v7 + 84);
  }
  if (v8 >= a3)
  {
    int v11 = 0u;
    if (a2 <= v8) {
      goto LABEL_17;
    }
  }

  else
  {
    else {
      unsigned int v9 = 2;
    }
    if (v9 >= 0x10000) {
      int v10 = 4;
    }
    else {
      int v10 = 2;
    }
    if (v9 < 0x100) {
      int v10 = 1;
    }
    if (v9 >= 2) {
      int v11 = v10;
    }
    else {
      int v11 = 0;
    }
    if (a2 <= v8) {
LABEL_17:
    }
      __asm { BR              X14 }
  }

  if (((*(_DWORD *)(v7 + 64) + 7 + ((*(unsigned __int8 *)(v7 + 80) + 1) & ~*(unsigned __int8 *)(v7 + 80))) & 0xFFFFFFF8) != 0xFFFFFFF0)
  {
    unsigned int v12 = ~v8 + a2;
    bzero( a1,  ((*(void *)(v7 + 64)
      + 7LL
    *a1 = v12;
  }

  __asm { BR              X10 }

void sub_18171BA80()
{
  *(_BYTE *)(v0 + v1) = v2;
  JUMPOUT(0x18171BB00LL);
}

void sub_18171BA88()
{
  *(_DWORD *)(v1 + v2) = 0;
  if (v0) {
    JUMPOUT(0x18171BA90LL);
  }
  JUMPOUT(0x18171BB00LL);
}

void sub_18171BAD8()
{
  *(_WORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171BB00LL);
}

void sub_18171BAE0()
{
  *(_DWORD *)(v0 + v1) = v2;
  JUMPOUT(0x18171BB00LL);
}

uint64_t sub_18171BAE8@<X0>(unsigned int a1@<W2>, uint64_t a2@<X8>)
{
  *(_WORD *)(v6 + v7) = 0;
  if (!(_DWORD)v5) {
    JUMPOUT(0x18171BB00LL);
  }
  if (a1 < 0x7FFFFFFF)
  {
    if ((v5 & 0x80000000) == 0) {
      JUMPOUT(0x18171BAFCLL);
    }
    JUMPOUT(0x18171BAF4LL);
  }

  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))((v6 + v3 + 1) & v4, v5);
}

unint64_t type metadata completion function for LazyPrefixWhileSequence<>._IndexRepresentation( uint64_t a1)
{
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    swift_initEnumMetadataSinglePayload(a1, 0, *(void *)(result - 8) + 64LL, (char *)1);
    return 0LL;
  }

  return result;
}

uint64_t getEnumTag for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 48LL))( a1,  1LL,  AssociatedTypeWitness);
}

uint64_t destructiveInjectEnumTag for LazyPrefixWhileSequence<>._IndexRepresentation( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8)
                                                                                + 56LL))( a1,  a2,  1LL,  AssociatedTypeWitness);
}

uint64_t type metadata completion function for LazyPrefixWhileSequence<>.Index( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation( 319LL,  *(void *)(a1 + 16),  *(void *)(a1 + 24),  a4);
  if (v6 <= 0x3F)
  {
    uint64_t v7 = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v7, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for LazyPrefixWhileSequence<>._IndexRepresentation( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  int v10 = *(_DWORD *)(v9 + 80);
  if (*(_DWORD *)(v9 + 84)) {
    size_t v11 = *(void *)(v9 + 64);
  }
  else {
    size_t v11 = *(void *)(v9 + 64) + 1LL;
  }
  if (*(_DWORD *)(v9 + 80) > 7u || (v10 & 0x100000) != 0 || v11 > 0x18)
  {
    uint64_t v14 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v14 + ((v10 + 16LL) & ~(unint64_t)v10));
    swift_retain(v14, v6, v7, v8);
  }

  else
  {
    unint64_t v15 = AssociatedTypeWitness;
    if ((*(unsigned int (**)(unint64_t **, uint64_t, unint64_t))(v9 + 48))( a2,  1LL,  AssociatedTypeWitness))
    {
      memcpy(a1, a2, v11);
    }

    else
    {
      (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))(a1, a2, v15);
      (*(void (**)(unint64_t **, void, uint64_t, unint64_t))(v9 + 56))(a1, 0LL, 1LL, v15);
    }
  }

  return a1;
}

uint64_t destroy for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v4 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v4 + 48))(a1, 1LL, AssociatedTypeWitness);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, unint64_t))(v4 + 8))(a1, AssociatedTypeWitness);
  }
  return result;
}

void *initializeWithCopy for LazyPrefixWhileSequence<>._IndexRepresentation( void *a1, const void *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v6 + 48))( a2,  1LL,  AssociatedTypeWitness))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1LL;
    }
    memcpy(a1, a2, v7);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v6 + 16))(a1, a2, AssociatedTypeWitness);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v6 + 56))(a1, 0LL, 1LL, AssociatedTypeWitness);
  }

  return a1;
}

void *assignWithCopy for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, void *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v6 + 48);
  int v8 = v7(a1, 1LL, AssociatedTypeWitness);
  int v9 = v7(a2, 1LL, AssociatedTypeWitness);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, unint64_t))(v6 + 16))(a1, a2, AssociatedTypeWitness);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v6 + 56))(a1, 0LL, 1LL, AssociatedTypeWitness);
      return a1;
    }
  }

  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, unint64_t))(v6 + 24))(a1, a2, AssociatedTypeWitness);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v6 + 8))(a1, AssociatedTypeWitness);
  }

  if (*(_DWORD *)(v6 + 84)) {
    size_t v10 = *(void *)(v6 + 64);
  }
  else {
    size_t v10 = *(void *)(v6 + 64) + 1LL;
  }
  memcpy(a1, a2, v10);
  return a1;
}

void *initializeWithTake for LazyPrefixWhileSequence<>._IndexRepresentation( void *a1, const void *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v6 + 48))( a2,  1LL,  AssociatedTypeWitness))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1LL;
    }
    memcpy(a1, a2, v7);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v6 + 32))(a1, a2, AssociatedTypeWitness);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v6 + 56))(a1, 0LL, 1LL, AssociatedTypeWitness);
  }

  return a1;
}

void *assignWithTake for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, void *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v6 + 48);
  int v8 = v7(a1, 1LL, AssociatedTypeWitness);
  int v9 = v7(a2, 1LL, AssociatedTypeWitness);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, unint64_t))(v6 + 32))(a1, a2, AssociatedTypeWitness);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v6 + 56))(a1, 0LL, 1LL, AssociatedTypeWitness);
      return a1;
    }
  }

  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, unint64_t))(v6 + 40))(a1, a2, AssociatedTypeWitness);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v6 + 8))(a1, AssociatedTypeWitness);
  }

  if (*(_DWORD *)(v6 + 84)) {
    size_t v10 = *(void *)(v6 + 64);
  }
  else {
    size_t v10 = *(void *)(v6 + 64) + 1LL;
  }
  memcpy(a1, a2, v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyPrefixWhileSequence<>._IndexRepresentation( uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                 - 8);
  unsigned int v6 = *(_DWORD *)(v5 + 84);
  unsigned int v7 = v6 - 1;
  if (!v6) {
    unsigned int v7 = 0;
  }
  uint64_t v8 = *(void *)(v5 + 64);
  if (!v6) {
    ++v8;
  }
  if (!a2) {
    return 0LL;
  }
  if (a2 > v7)
  {
    char v9 = 8 * v8;
    unsigned int v11 = ((a2 - v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)(a1 + v8);
      if (v10) {
        goto LABEL_15;
      }
    }

    else
    {
      if (v11 <= 0xFF)
      {
        if (v11 < 2) {
          goto LABEL_22;
        }
LABEL_8:
        int v10 = *(unsigned __int8 *)(a1 + v8);
        if (!*(_BYTE *)(a1 + v8)) {
          goto LABEL_22;
        }
LABEL_15:
        int v12 = (v10 - 1) << v9;
        if ((_DWORD)v8)
        {
          __asm { BR              X12 }
        }

        return v7 + v12 + 1;
      }

      int v10 = *(unsigned __int16 *)(a1 + v8);
      if (*(_WORD *)(a1 + v8)) {
        goto LABEL_15;
      }
    }
  }

void storeEnumTagSinglePayload for LazyPrefixWhileSequence<>._IndexRepresentation( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unsigned int v7 = 0u;
  uint64_t v8 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                 - 8);
  int v9 = *(_DWORD *)(v8 + 84);
  unsigned int v10 = v9 - 1;
  if (v9)
  {
    size_t v11 = *(void *)(v8 + 64);
  }

  else
  {
    unsigned int v10 = 0;
    size_t v11 = *(void *)(v8 + 64) + 1LL;
  }

  if (a3 > v10)
  {
    if (v11 > 3)
    {
      unsigned int v7 = 1u;
      if (v10 >= a2) {
LABEL_20:
      }
        __asm { BR              X11 }

void sub_18171C4B0()
{
  *(_BYTE *)(v0 + v1) = v2;
}

void sub_18171C4B8()
{
  *(_WORD *)(v0 + v1) = v2;
}

uint64_t dispatch thunk of RandomNumberGenerator.next()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

ValueMetadata *type metadata accessor for SystemRandomNumberGenerator()
{
  return &type metadata for SystemRandomNumberGenerator;
}

uint64_t default associated conformance accessor for RandomAccessCollection.Collection.Indices: RandomAccessCollection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &v4);
}

uint64_t default associated conformance accessor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t dispatch thunk of RandomAccessCollection.index(_:offsetBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of RandomAccessCollection.index(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 40))();
}

uint64_t dispatch thunk of RandomAccessCollection.distance(from:to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of RangeExpression.relative<A>(to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of RangeExpression.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

unint64_t *type metadata completion function for ClosedRange(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 1) + 64;
    v4[1] = v4[0];
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v4, a1 + 32);
    return 0LL;
  }

  return result;
}

uint64_t type metadata accessor for PartialRangeUpTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for PartialRangeUpTo);
}

uint64_t type metadata accessor for PartialRangeThrough(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for PartialRangeThrough);
}

unint64_t *type metadata completion function for FlattenSequence(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v4, a1 + 40);
    return 0LL;
  }

  return result;
}

uint64_t type metadata accessor for PartialRangeFrom<>.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for PartialRangeFrom<>.Iterator);
}

ValueMetadata *type metadata accessor for UnboundedRange_()
{
  return &type metadata for UnboundedRange_;
}

uint64_t default associated conformance accessor for RangeReplaceableCollection.Collection.SubSequence: RangeReplaceableCollection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t dispatch thunk of RangeReplaceableCollection.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.replaceSubrange<A>(_:with:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 32))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.reserveCapacity(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.init(repeating:count:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.init<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 56))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.append(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.append<A>(contentsOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.insert(_:at:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.insert<A>(contentsOf:at:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 88))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.remove(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeSubrange(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

uint64_t dispatch thunk of RangeReplaceableCollection._customRemoveLast(_:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeFirst(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeAll(keepingCapacity:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeAll(where:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

ValueMetadata *type metadata accessor for _EachFieldOptions()
{
  return &type metadata for _EachFieldOptions;
}

uint64_t getEnumTagSinglePayload for _MetadataKind(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF1) {
    goto LABEL_17;
  }
  if (a2 + 15 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 15) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 15;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 15;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 15;
    }
  }

uint64_t storeEnumTagSinglePayload for _MetadataKind(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 15 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 15) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xF1) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF0) {
    return ((uint64_t (*)(void))((char *)&loc_18171C82C + 4 * byte_1818003E3[v4]))();
  }
  *a1 = a2 + 15;
  return ((uint64_t (*)(void))((char *)sub_18171C860 + 4 * byte_1818003DE[v4]))();
}

uint64_t sub_18171C860(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18171C868(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x18171C870LL);
  }
  return result;
}

uint64_t sub_18171C87C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x18171C884LL);
  }
  *(_BYTE *)uint64_t result = a2 + 15;
  return result;
}

uint64_t sub_18171C888(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18171C890(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

_BYTE *destructiveInjectEnumTag for _MetadataKind(_BYTE *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

ValueMetadata *type metadata accessor for _MetadataKind()
{
  return &type metadata for _MetadataKind;
}

unint64_t *type metadata completion function for Repeated(uint64_t a1)
{
  v4[0] = &value witness table for Builtin.Int64.size;
  uint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[1] = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v4, a1 + 24);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for Repeated( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  if (v7 > 7
    || (*(_DWORD *)(v6 + 80) & 0x100000) != 0
    || ((v7 + 8) & (unint64_t)~v7) + *(void *)(v6 + 64) > 0x18)
  {
    unsigned int v10 = *a2;
    const char *v4 = *a2;
    uint64_t v4 = (unint64_t **)((char *)v10 + ((v7 & 0xF8 ^ 0x1F8) & (v7 + 16)));
    swift_retain(v10, (uint64_t)a2, v5, a4);
  }

  else
  {
    *a1 = *a2;
    (*(void (**)(unint64_t, unint64_t))(v6 + 16))( ((unint64_t)a1 + v7 + 8) & ~v7,  ((unint64_t)a2 + v7 + 8) & ~v7);
  }

  return v4;
}

uint64_t destroy for Repeated(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(unint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 8LL))((a1 + *(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL));
}

void *initializeWithCopy for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v4 + 16))( ((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

void *assignWithCopy for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v4 + 24))( ((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

void *initializeWithTake for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v4 + 32))( ((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

void *assignWithTake for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v4 + 40))( ((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

uint64_t getEnumTagSinglePayload for Repeated(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 80);
  unsigned int v7 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_18;
  }
  uint64_t v8 = ((v6 + 8) & ~v6) + *(void *)(v4 + 64);
  char v9 = 8 * v8;
  if (v8 <= 3)
  {
    unsigned int v11 = ((v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)(a1 + v8);
      if (!v10) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v11 > 0xFF)
    {
      int v10 = *(unsigned __int16 *)(a1 + v8);
      if (!*(_WORD *)(a1 + v8)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v11 < 2)
    {
LABEL_18:
      if (v5) {
        return (*(uint64_t (**)(uint64_t))(v4 + 48))((a1 + v6 + 8) & ~v6);
      }
      return 0LL;
    }
  }

  int v10 = *(unsigned __int8 *)(a1 + v8);
  if (!*(_BYTE *)(a1 + v8)) {
    goto LABEL_18;
  }
LABEL_11:
  int v12 = (v10 - 1) << v9;
  if (!(_DWORD)v8) {
    return v5 + v12 + 1;
  }
  return ((uint64_t (*)(void))((char *)&loc_18171CBF4 + 4 * byte_1818003E8[(v8 - 1)]))();
}

void storeEnumTagSinglePayload for Repeated(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  size_t v9 = ((v8 + 8) & ~v8) + *(void *)(v6 + 64);
  BOOL v10 = a3 >= v7;
  unsigned int v11 = a3 - v7;
  if (v11 != 0 && v10)
  {
    if (v9 <= 3)
    {
      unsigned int v14 = ((v11 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
      if (HIWORD(v14))
      {
        unsigned int v12 = 4u;
      }

      else if (v14 >= 0x100)
      {
        unsigned int v12 = 2;
      }

      else
      {
        unsigned int v12 = v14 > 1;
      }
    }

    else
    {
      unsigned int v12 = 1u;
    }
  }

  else
  {
    unsigned int v12 = 0u;
  }

  if (v7 < a2)
  {
    unsigned int v13 = ~v7 + a2;
    if (v9 < 4)
    {
      if ((_DWORD)v9)
      {
        int v15 = v13 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *a1 = v15;
          *((_BYTE *)a1 + 2) = BYTE2(v15);
        }

        else if ((_DWORD)v9 == 2)
        {
          *a1 = v15;
        }

        else
        {
          *(_BYTE *)a1 = v15;
        }
      }
    }

    else
    {
      bzero(a1, ((v8 + 8) & ~v8) + *(void *)(v6 + 64));
      *(_DWORD *)a1 = v13;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X13 }

unint64_t type metadata completion function for ReversedCollection.Iterator(uint64_t a1)
{
  int v2 = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  unint64_t v3 = (unint64_t)v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 1) + 64;
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(*(void *)(a1 + 24) + 8LL),  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
    unint64_t v3 = AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      v8[1] = *(void *)(AssociatedTypeWitness - 8) + 64LL;
      swift_initStructMetadata(a1, 0, 2uLL, (char *)v8, a1 + 32);
      return 0LL;
    }
  }

  return v3;
}

unint64_t **initializeBufferWithCopyOfBuffer for ReversedCollection.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = *(_DWORD *)(v12 + 80);
  uint64_t v14 = v7 + v13;
  uint64_t v15 = (*(_BYTE *)(v6 + 80) | *(_BYTE *)(v12 + 80));
  if (v15 > 7
    || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v12 + 80)) & 0x100000) != 0
    || (v14 & (unint64_t)~v13) + *(void *)(v12 + 64) > 0x18)
  {
    uint64_t v18 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v18 + ((v15 + 16) & ~v15));
    swift_retain(v18, v9, v10, v11);
  }

  else
  {
    unint64_t v19 = AssociatedTypeWitness;
    uint64_t v20 = ~v13;
    (*(void (**)(unint64_t **, unint64_t **, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v12 + 16))( ((unint64_t)a1 + v14) & v20,  ((unint64_t)a2 + v14) & v20,  v19);
  }

  return a1;
}

uint64_t destroy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, v4);
  uint64_t v6 = *(void *)(v5 + 64) + a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a2 + 24) + 8LL),  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( (v6 + *(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL),  AssociatedTypeWitness);
}

uint64_t initializeWithCopy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 16))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 24))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 32))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 40))( (v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for ReversedCollection.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v12 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v13 = *(void *)(v6 + 64) + v12;
  if (a2 <= v11) {
    goto LABEL_23;
  }
  uint64_t v14 = (v13 & ~v12) + *(void *)(v9 + 64);
  char v15 = 8 * v14;
  if (v14 <= 3)
  {
    unsigned int v17 = ((a2 - v11 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      int v16 = *(_DWORD *)(a1 + v14);
      if (!v16) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v17 > 0xFF)
    {
      int v16 = *(unsigned __int16 *)(a1 + v14);
      if (!*(_WORD *)(a1 + v14)) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v17 < 2)
    {
LABEL_23:
      if (v11)
      {
        else {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))( (v13 + a1) & ~v12,  v10,  AssociatedTypeWitness);
        }
      }

      return 0LL;
    }
  }

  int v16 = *(unsigned __int8 *)(a1 + v14);
  if (!*(_BYTE *)(a1 + v14)) {
    goto LABEL_23;
  }
LABEL_14:
  int v18 = (v16 - 1) << v15;
  if ((_DWORD)v14)
  {
    else {
      int v19 = 4;
    }
    __asm { BR              X12 }
  }

  return v11 + v18 + 1;
}

void storeEnumTagSinglePayload for ReversedCollection.Iterator( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a4 + 24) + 8LL),  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                  - 8);
  if (*(_DWORD *)(v10 + 84) <= v9) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v10 + 84);
  }
  if (a3 <= v11)
  {
    unsigned int v13 = 0u;
  }

  else if (v12 <= 3)
  {
    unsigned int v15 = ((a3 - v11 + ~(-1 << (8 * v12))) >> (8 * v12)) + 1;
    if (HIWORD(v15))
    {
      unsigned int v13 = 4u;
    }

    else if (v15 >= 0x100)
    {
      unsigned int v13 = 2;
    }

    else
    {
      unsigned int v13 = v15 > 1;
    }
  }

  else
  {
    unsigned int v13 = 1u;
  }

  if (v11 < a2)
  {
    unsigned int v14 = ~v11 + a2;
    if (v12 < 4)
    {
      if ((_DWORD)v12)
      {
        int v16 = v14 & ~(-1 << (8 * v12));
        bzero(a1, v12);
        if ((_DWORD)v12 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }

        else if ((_DWORD)v12 == 2)
        {
          *(_WORD *)a1 = v16;
        }

        else
        {
          *a1 = v16;
        }
      }
    }

    else
    {
      bzero(a1, v12);
      *(_DWORD *)a1 = v14;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X13 }

unint64_t type metadata completion function for ReversedCollection.Index(uint64_t a1)
{
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(*(void *)(a1 + 24) + 8LL),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v4, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for ReversedCollection.Index( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  if (v10 <= 7 && *(void *)(v9 + 64) <= 0x18uLL && (*(_DWORD *)(v9 + 80) & 0x100000) == 0)
  {
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))( a1,  a2,  AssociatedTypeWitness);
  }

  else
  {
    unsigned int v13 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v13 + ((v10 + 16) & ~v10));
    swift_retain(v13, v6, v7, v8);
  }

  return a1;
}

uint64_t destroy for ReversedCollection.Index(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a2 + 24) + 8LL),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( a1,  AssociatedTypeWitness);
}

uint64_t initializeWithCopy for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 24LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for ReversedCollection.Index(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  if (!a2) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  uint64_t v8 = *(void *)(v6 + 64);
  char v9 = 8 * v8;
  if (v8 <= 3)
  {
    unsigned int v11 = ((a2 - v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)(a1 + v8);
      if (!v10) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v11 > 0xFF)
    {
      int v10 = *(unsigned __int16 *)(a1 + v8);
      if (!*(_WORD *)(a1 + v8)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v11 < 2)
    {
LABEL_18:
      if ((_DWORD)v7) {
        return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v6 + 48))(a1, v7, AssociatedTypeWitness);
      }
      return 0LL;
    }
  }

  int v10 = *(unsigned __int8 *)(a1 + v8);
  if (!*(_BYTE *)(a1 + v8)) {
    goto LABEL_18;
  }
LABEL_11:
  int v12 = (v10 - 1) << v9;
  if ((_DWORD)v8)
  {
    __asm { BR              X11 }
  }

  return (v7 + v12 + 1);
}

void storeEnumTagSinglePayload for ReversedCollection.Index( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a4 + 24) + 8LL),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                 - 8);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  size_t v9 = *(void *)(v7 + 64);
  if (a3 <= v8)
  {
    unsigned int v10 = 0u;
  }

  else if (v9 <= 3)
  {
    unsigned int v12 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
    if (HIWORD(v12))
    {
      unsigned int v10 = 4u;
    }

    else if (v12 >= 0x100)
    {
      unsigned int v10 = 2;
    }

    else
    {
      unsigned int v10 = v12 > 1;
    }
  }

  else
  {
    unsigned int v10 = 1u;
  }

  if (v8 < a2)
  {
    unsigned int v11 = ~v8 + a2;
    if (v9 < 4)
    {
      if ((_DWORD)v9)
      {
        int v13 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *(_WORD *)a1 = v13;
          a1[2] = BYTE2(v13);
        }

        else if ((_DWORD)v9 == 2)
        {
          *(_WORD *)a1 = v13;
        }

        else
        {
          *a1 = v13;
        }
      }
    }

    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X11 }

uint64_t type metadata accessor for __SwiftNativeNSArray()
{
  return objc_opt_self();
}

uint64_t method lookup function for __SwiftNativeNSArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __SwiftNativeNSArray);
}

uint64_t dispatch thunk of __SwiftNativeNSArray.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 80))();
}

uint64_t type metadata accessor for _SwiftNativeNSMutableArray()
{
  return objc_opt_self();
}

uint64_t method lookup function for _SwiftNativeNSMutableArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _SwiftNativeNSMutableArray);
}

uint64_t type metadata accessor for __SwiftNativeNSDictionary()
{
  return objc_opt_self();
}

uint64_t method lookup function for __SwiftNativeNSDictionary(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __SwiftNativeNSDictionary);
}

uint64_t type metadata accessor for __SwiftNativeNSSet()
{
  return objc_opt_self();
}

uint64_t method lookup function for __SwiftNativeNSSet(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __SwiftNativeNSSet);
}

uint64_t type metadata accessor for __SwiftNativeNSEnumerator()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for __stdlib_ReturnAutoreleasedDummy()
{
  return objc_opt_self();
}

uint64_t storeEnumTagSinglePayload for Hasher._State(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 56) = 0LL;
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)unint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 64) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Hasher._State()
{
  return &type metadata for Hasher._State;
}

uint64_t dispatch thunk of IteratorProtocol.next()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Sequence.makeIterator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Sequence.underestimatedCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of Sequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of Sequence._copyToContiguousArray()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of Sequence._copyContents(initializing:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 64))();
}

uint64_t dispatch thunk of Sequence.withContiguousStorageIfAvailable<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

unint64_t *type metadata completion function for DropFirstSequence( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice( a1,  a2,  a3,  (uint64_t)&value witness table for Builtin.Int64.size);
}

unint64_t *type metadata completion function for DiscontiguousSlice( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v7 <= 0x3F)
  {
    v8[0] = *(result - 1) + 64;
    v8[1] = a4;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v8, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for DropFirstSequence( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  int v9 = *(_DWORD *)(v7 + 80);
  if ((v9 & 0x1000F8) != 0 || ((v8 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8 > 0x18)
  {
    unsigned int v11 = *a2;
    *uint64_t v5 = *a2;
    uint64_t v5 = (unint64_t **)((char *)v11
                             + ((unsigned __int16)((v9 & 0xF8) + 23) & (unsigned __int16)~(v9 & 0xF8) & 0x1F8));
    swift_retain(v11, (uint64_t)a2, v6, a4);
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **))(v7 + 16))(a1, a2);
    *(void *)(((unint64_t)v5 + v8 + 7) & 0xFFFFFFFFFFFFF8LL) = *(void *)(((unint64_t)a2 + v8 + 7) & 0xFFFFFFFFFFFFF8LL);
  }

  return v5;
}

uint64_t initializeWithCopy for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 16))();
  *(void *)((*(void *)(v5 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v5 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t assignWithCopy for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 24))();
  *(void *)((*(void *)(v5 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v5 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t initializeWithTake for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 32))();
  *(void *)((*(void *)(v5 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v5 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t assignWithTake for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 40))();
  *(void *)((*(void *)(v5 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v5 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t getEnumTagSinglePayload for DropFirstSequence(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (v5 >= a2)
  {
    if (v5) {
      return (*(uint64_t (**)(void))(v4 + 48))();
    }
    return 0LL;
  }

  if (((((*(void *)(v4 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 8) & 0xFFFFFFF8) != 0) {
    unsigned int v6 = 2;
  }
  else {
    unsigned int v6 = a2 - v5 + 1;
  }
  if (v6 >= 0x10000) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = 2;
  }
  if (v6 < 0x100) {
    unsigned int v7 = 1;
  }
  if (v6 >= 2) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0LL;
  }
  return ((uint64_t (*)(void))((char *)&loc_18171E17C + 4 * byte_181800412[v8]))();
}

void storeEnumTagSinglePayload for DropFirstSequence( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 >= a3)
  {
    int v11 = 0u;
    if (a2 <= v7) {
      goto LABEL_14;
    }
  }

  else
  {
    unsigned int v8 = a3 - v7;
    if (((*(_DWORD *)(v6 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
      unsigned int v9 = v8 + 1;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v9 >= 0x10000) {
      int v10 = 4;
    }
    else {
      int v10 = 2;
    }
    if (v9 < 0x100) {
      int v10 = 1;
    }
    if (v9 >= 2) {
      int v11 = v10;
    }
    else {
      int v11 = 0;
    }
    if (a2 <= v7) {
LABEL_14:
    }
      __asm { BR              X11 }
  }

  if (((*(_DWORD *)(v6 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
  {
    unsigned int v12 = ~v7 + a2;
    bzero(a1, ((*(void *)(v6 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 8);
    *a1 = v12;
  }

  __asm { BR              X10 }

void sub_18171E2BC()
{
  *(_BYTE *)(v0 + v1) = v2;
}

void sub_18171E2C4(uint64_t a1, int a2)
{
  *(_DWORD *)(v2 + v3) = 0;
  if (a2) {
    JUMPOUT(0x18171E2CCLL);
  }
}

void sub_18171E2E8()
{
  *(_WORD *)(v0 + v1) = v2;
}

void sub_18171E2F0()
{
  *(_DWORD *)(v0 + v1) = v2;
}

uint64_t sub_18171E2F8(uint64_t a1, int a2)
{
  *(_WORD *)(v4 + v5) = 0;
  if (!a2) {
    JUMPOUT(0x18171E300LL);
  }
  return (*(uint64_t (**)(uint64_t))(v3 + 56))(v4);
}

unint64_t type metadata completion function for PrefixSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  (uint64_t)&value witness table for Builtin.Int64.size);
}

unint64_t type metadata completion function for EnumeratedSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  unint64_t result = swift_getAssociatedTypeWitness(319LL, *(const char **)(a1 + 24), *(void *)(a1 + 16), a4, a5);
  if (v9 <= 0x3F)
  {
    v10[0] = *(void *)(result - 8) + 64LL;
    v10[1] = a6;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v10, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for PrefixSequence.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

unint64_t **initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = *(void *)(v11 + 64);
  int v13 = *(_DWORD *)(v11 + 80);
  if ((v13 & 0x1000F8) != 0 || ((v12 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8 > 0x18)
  {
    unsigned int v15 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v15
                             + ((unsigned __int16)((v13 & 0xF8) + 23) & (unsigned __int16)~(v13 & 0xF8) & 0x1F8));
    swift_retain(v15, v8, v9, v10);
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v11 + 16))( a1,  a2,  AssociatedTypeWitness);
    *(void *)(((unint64_t)a1 + v12 + 7) & 0xFFFFFFFFFFFFF8LL) = *(void *)(((unint64_t)a2 + v12 + 7) & 0xFFFFFFFFFFFFF8LL);
  }

  return a1;
}

uint64_t destroy for PrefixSequence.Iterator(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithCopy for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithCopy for EnumeratedSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 16))(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v8 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t assignWithCopy for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithCopy for EnumeratedSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 24))(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v8 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t initializeWithTake for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithTake for EnumeratedSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 32))(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v8 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t assignWithTake for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithTake for EnumeratedSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 40))(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 64) + 7LL + a1) & 0xFFFFFFFFFFFFF8LL) = *(void *)((*(void *)(v8 + 64) + 7LL + a2) & 0xFFFFFFFFFFFFF8LL);
  return a1;
}

uint64_t getEnumTagSinglePayload for PrefixSequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for EnumeratedSequence.Iterator( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence.Iterator( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  if (!a2) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  if (v9 < a2)
  {
    if (((((*(void *)(v8 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 8) & 0xFFFFFFF8) != 0) {
      unsigned int v10 = 2;
    }
    else {
      unsigned int v10 = a2 - v9 + 1;
    }
    if (v10 >= 0x10000) {
      unsigned int v11 = 4;
    }
    else {
      unsigned int v11 = 2;
    }
    if (v10 < 0x100) {
      unsigned int v11 = 1;
    }
    if (v10 >= 2) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0LL;
    }
    __asm { BR              X13 }
  }

  if ((_DWORD)v9) {
    return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v8 + 48))(a1, v9, AssociatedTypeWitness);
  }
  else {
    return 0LL;
  }
}

void storeEnumTagSinglePayload for PrefixSequence.Iterator( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

void storeEnumTagSinglePayload for EnumeratedSequence.Iterator( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v9 = *(void *)(swift_getAssociatedTypeWitness(0LL, *(const char **)(a4 + 24), *(void *)(a4 + 16), a5, a6) - 8);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  if (v10 >= a3)
  {
    int v13 = 0u;
    if (a2 <= v10) {
      goto LABEL_14;
    }
  }

  else
  {
    if (((*(_DWORD *)(v9 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
      unsigned int v11 = a3 - v10 + 1;
    }
    else {
      unsigned int v11 = 2;
    }
    if (v11 >= 0x10000) {
      int v12 = 4;
    }
    else {
      int v12 = 2;
    }
    if (v11 < 0x100) {
      int v12 = 1;
    }
    if (v11 >= 2) {
      int v13 = v12;
    }
    else {
      int v13 = 0;
    }
    if (a2 <= v10) {
LABEL_14:
    }
      __asm { BR              X11 }
  }

  if (((*(_DWORD *)(v9 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
  {
    unsigned int v14 = ~v10 + a2;
    bzero(a1, ((*(void *)(v9 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 8);
    *a1 = v14;
  }

  __asm { BR              X10 }

void sub_18171E8BC()
{
  *(_BYTE *)(v0 + v1) = v2;
}

void sub_18171E8C4()
{
  *(_DWORD *)(v0 + v2) = 0;
  if (v1) {
    JUMPOUT(0x18171E8CCLL);
  }
}

void sub_18171E8EC()
{
  *(_WORD *)(v0 + v1) = v2;
}

void sub_18171E8F4()
{
  *(_DWORD *)(v0 + v1) = v2;
}

uint64_t sub_18171E8FC@<X0>(uint64_t a1@<X8>)
{
  *(_WORD *)(v2 + v4) = 0;
  if (!(_DWORD)v3) {
    JUMPOUT(0x18171E904LL);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 56))(v2, v3);
}

unint64_t type metadata completion function for DropWhileSequence(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(const char **)(a1 + 24);
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v10[0] = *(void *)(result - 8) + 64LL;
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    unint64_t result = type metadata accessor for Optional((const char *)0x13F, AssociatedTypeWitness, v7, v8);
    if (v9 <= 0x3F)
    {
      v10[1] = *(void *)(result - 8) + 64LL;
      swift_initStructMetadata(a1, 0, 2uLL, (char *)v10, a1 + 32);
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for DropWhileSequence( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = *(void *)(v8 + 64);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v14 = *(void *)(v10 - 8);
  int v15 = *(_DWORD *)(v14 + 80);
  uint64_t v16 = v15;
  uint64_t v17 = v9 + v15;
  if (*(_DWORD *)(v14 + 84)) {
    size_t v18 = *(void *)(v14 + 64);
  }
  else {
    size_t v18 = *(void *)(v14 + 64) + 1LL;
  }
  int v19 = *(_DWORD *)(v8 + 80) | v15;
  uint64_t v20 = (*(_BYTE *)(v8 + 80) | v15);
  int v21 = v19 & 0x100000;
  if (v20 > 7 || v21 != 0 || (v17 & ~v16) + v18 > 0x18)
  {
    int v24 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v24 + ((v20 + 16) & ~v20));
    swift_retain(v24, v11, v12, v13);
  }

  else
  {
    unint64_t v25 = v10;
    uint64_t v26 = ~v16;
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v8 + 16))( a1,  a2,  AssociatedTypeWitness);
    unint64_t v27 = (const void *)(((unint64_t)a2 + v17) & v26);
    if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v27, 1LL, v25))
    {
      memcpy((void *)(((unint64_t)a1 + v17) & v26), v27, v18);
    }

    else
    {
      (*(void (**)(unint64_t, const void *, unint64_t))(v14 + 16))( ((unint64_t)a1 + v17) & v26,  v27,  v25);
      (*(void (**)(unint64_t, void, uint64_t, unint64_t))(v14 + 56))( ((unint64_t)a1 + v17) & v26,  0LL,  1LL,  v25);
    }
  }

  return a1;
}

uint64_t destroy for DropWhileSequence(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v6 + 8))(a1, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 64) + a1;
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = *(void *)(v8 - 8);
  unint64_t v10 = (v7 + *(unsigned __int8 *)(v9 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, unint64_t))(v9 + 48))(v10, 1LL, v8);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(unint64_t, unint64_t))(v9 + 8))(v10, v8);
  }
  return result;
}

uint64_t initializeWithCopy for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 16))(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 64);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  int v13 = (void *)((v9 + v12 + a1) & ~v12);
  uint64_t v14 = (const void *)((v9 + v12 + a2) & ~v12);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v11 + 48))(v14, 1LL, v10))
  {
    if (*(_DWORD *)(v11 + 84)) {
      size_t v15 = *(void *)(v11 + 64);
    }
    else {
      size_t v15 = *(void *)(v11 + 64) + 1LL;
    }
    memcpy(v13, v14, v15);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v11 + 16))(v13, v14, v10);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v11 + 56))(v13, 0LL, 1LL, v10);
  }

  return a1;
}

uint64_t assignWithCopy for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 24))(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 64);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  int v13 = (void *)((v9 + v12 + a1) & ~v12);
  uint64_t v14 = (void *)((v9 + v12 + a2) & ~v12);
  size_t v15 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v11 + 48);
  int v16 = v15(v13, 1LL, v10);
  int v17 = v15(v14, 1LL, v10);
  if (v16)
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, unint64_t))(v11 + 16))(v13, v14, v10);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v11 + 56))(v13, 0LL, 1LL, v10);
      return a1;
    }
  }

  else
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, unint64_t))(v11 + 24))(v13, v14, v10);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v11 + 8))(v13, v10);
  }

  if (*(_DWORD *)(v11 + 84)) {
    size_t v18 = *(void *)(v11 + 64);
  }
  else {
    size_t v18 = *(void *)(v11 + 64) + 1LL;
  }
  memcpy(v13, v14, v18);
  return a1;
}

uint64_t initializeWithTake for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 32))(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 64);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  int v13 = (void *)((v9 + v12 + a1) & ~v12);
  uint64_t v14 = (const void *)((v9 + v12 + a2) & ~v12);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v11 + 48))(v14, 1LL, v10))
  {
    if (*(_DWORD *)(v11 + 84)) {
      size_t v15 = *(void *)(v11 + 64);
    }
    else {
      size_t v15 = *(void *)(v11 + 64) + 1LL;
    }
    memcpy(v13, v14, v15);
  }

  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v11 + 32))(v13, v14, v10);
    (*(void (**)(void *, void, uint64_t, unint64_t))(v11 + 56))(v13, 0LL, 1LL, v10);
  }

  return a1;
}

uint64_t assignWithTake for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 40))(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 64);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  int v13 = (void *)((v9 + v12 + a1) & ~v12);
  uint64_t v14 = (void *)((v9 + v12 + a2) & ~v12);
  size_t v15 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v11 + 48);
  int v16 = v15(v13, 1LL, v10);
  int v17 = v15(v14, 1LL, v10);
  if (v16)
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, unint64_t))(v11 + 32))(v13, v14, v10);
      (*(void (**)(void *, void, uint64_t, unint64_t))(v11 + 56))(v13, 0LL, 1LL, v10);
      return a1;
    }
  }

  else
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, unint64_t))(v11 + 40))(v13, v14, v10);
      return a1;
    }

    (*(void (**)(void *, unint64_t))(v11 + 8))(v13, v10);
  }

  if (*(_DWORD *)(v11 + 84)) {
    size_t v18 = *(void *)(v11 + 64);
  }
  else {
    size_t v18 = *(void *)(v11 + 64) + 1LL;
  }
  memcpy(v13, v14, v18);
  return a1;
}

uint64_t getEnumTagSinglePayload for DropWhileSequence(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element)
                  - 8);
  int v11 = *(_DWORD *)(v10 + 84);
  if (v11) {
    unsigned int v12 = v11 - 1;
  }
  else {
    unsigned int v12 = 0;
  }
  else {
    unsigned int v13 = v12;
  }
  if (v11) {
    uint64_t v14 = *(void *)(v10 + 64);
  }
  else {
    uint64_t v14 = *(void *)(v10 + 64) + 1LL;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v15 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v16 = *(void *)(v8 + 64) + v15;
  if (a2 <= v13) {
    goto LABEL_29;
  }
  uint64_t v17 = v14 + (v16 & ~v15);
  char v18 = 8 * v17;
  if (v17 <= 3)
  {
    unsigned int v20 = ((a2 - v13 + ~(-1 << v18)) >> v18) + 1;
    if (HIWORD(v20))
    {
      int v19 = *(_DWORD *)(a1 + v17);
      if (!v19) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }

    if (v20 > 0xFF)
    {
      int v19 = *(unsigned __int16 *)(a1 + v17);
      if (!*(_WORD *)(a1 + v17)) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }

    if (v20 < 2)
    {
LABEL_29:
      if (v13)
      {
        if (v9 >= v12) {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v8 + 48))( a1,  v9,  AssociatedTypeWitness);
        }
        unsigned int v23 = (*(uint64_t (**)(uint64_t))(v10 + 48))((v16 + a1) & ~v15);
        if (v23 >= 2) {
          return v23 - 1;
        }
        else {
          return 0LL;
        }
      }

      return 0LL;
    }
  }

  int v19 = *(unsigned __int8 *)(a1 + v17);
  if (!*(_BYTE *)(a1 + v17)) {
    goto LABEL_29;
  }
LABEL_20:
  int v21 = (v19 - 1) << v18;
  if ((_DWORD)v17)
  {
    else {
      int v22 = 4;
    }
    __asm { BR              X12 }
  }

  return v13 + v21 + 1;
}

void storeEnumTagSinglePayload for DropWhileSequence( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 16);
  uint64_t v7 = *(const char **)(a4 + 24);
  uint64_t v9 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  v7,  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unsigned int v12 = 0u;
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  int v14 = *(_DWORD *)(v13 + 84);
  unsigned int v15 = v14 - 1;
  if (!v14) {
    unsigned int v15 = 0;
  }
  if (v15 <= v10) {
    unsigned int v16 = v10;
  }
  else {
    unsigned int v16 = v15;
  }
  uint64_t v17 = *(unsigned __int8 *)(v13 + 80);
  if (v14) {
    uint64_t v19 = *(void *)(v13 + 64);
  }
  else {
    uint64_t v19 = *(void *)(v13 + 64) + 1LL;
  }
  uint64_t v18 = *(void *)(v9 + 64) + v17;
  unsigned int v20 = (v18 & ~(_DWORD)v17) + v19;
  if (a3 > v16)
  {
    if (v20 > 3)
    {
      unsigned int v12 = 1u;
      if (v16 >= a2) {
LABEL_25:
      }
        __asm { BR              X14 }

void sub_18171F604()
{
  *(_BYTE *)(v0 + v2) = v1;
}

void sub_18171F60C()
{
  *(_WORD *)(v0 + v2) = v1;
}

void sub_18171F634()
{
  *(_WORD *)uint64_t v0 = v1;
  *(_BYTE *)(v0 + 2) = BYTE2(v1);
}

void sub_18171F644()
{
  _WORD *v0 = v1;
}

void sub_18171F64C()
{
  _DWORD *v0 = v1;
}

uint64_t initializeBufferWithCopyOfBuffer for Set.Index(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for Dictionary.Index( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t))outlined copy of Set<A>.Index._Variant<A>);
}

uint64_t *assignWithCopy for Set.Index(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Index( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t))outlined copy of Set<A>.Index._Variant<A>,  (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of Set<A>.Index._Variant<A>);
}

uint64_t *assignWithTake for Set.Index(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Index( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of Set<A>.Index._Variant<A>);
}

uint64_t type metadata accessor for Set.Index._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Set.Index._Variant);
}

uint64_t destroy for Set.Iterator(void *a1, uint64_t a2)
{
  return destroy for Dictionary.Keys.Iterator( a1,  a2,  (uint64_t (*)(void, void, void, void, void))outlined consume of Set<String>.Iterator._Variant);
}

void *initializeWithCopy for Set.Iterator(void *a1, void *a2, uint64_t a3)
{
  return initializeWithCopy for Dictionary.Keys.Iterator( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of Set<A>.Iterator._Variant<A>);
}

uint64_t *assignWithCopy for Set.Iterator(uint64_t *a1, void *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Keys.Iterator( a1,  a2,  a3,  (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of Set<A>.Iterator._Variant<A>,  (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of Set<String>.Iterator._Variant);
}

void *assignWithTake for Set.Iterator(void *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Keys.Iterator( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of Set<String>.Iterator._Variant);
}

uint64_t type metadata accessor for Set.Iterator(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Set.Iterator,  &flag for loading of canonical specialized generic type metadata for Set.Iterator);
}

uint64_t dispatch thunk of SetAlgebra.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of SetAlgebra.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of SetAlgebra.intersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t dispatch thunk of SetAlgebra.symmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of SetAlgebra.insert(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

uint64_t dispatch thunk of SetAlgebra.remove(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

uint64_t dispatch thunk of SetAlgebra.update(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

uint64_t dispatch thunk of SetAlgebra.formUnion(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

uint64_t dispatch thunk of SetAlgebra.formSymmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

uint64_t dispatch thunk of SetAlgebra.isSubset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

uint64_t dispatch thunk of SetAlgebra.isDisjoint(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of SetAlgebra.isSuperset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

uint64_t dispatch thunk of SetAlgebra.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of SetAlgebra.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of SetAlgebra.subtract(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 168))();
}

swift *type metadata completion function for _SwiftSetNSEnumerator(uint64_t a1)
{
  v2[0] = &unk_189B8B980;
  v2[1] = "\b";
  void v2[2] = &value witness table for Builtin.Int64.size;
  void v2[3] = &value witness table for Builtin.Int64.size;
  return swift_initClassMetadata2(a1, 0, 4uLL, (uint64_t)v2, a1 + 112);
}

uint64_t type metadata accessor for _SwiftSetNSEnumerator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SwiftSetNSEnumerator);
}

swift *type metadata completion function for _SwiftDeferredNSSet(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = &unk_189B8B980;
  return swift_initClassMetadata2(a1, 0, 2uLL, (uint64_t)v2, a1 + 112);
}

ValueMetadata *type metadata accessor for __CocoaSet()
{
  return &type metadata for __CocoaSet;
}

unint64_t *initializeBufferWithCopyOfBuffer for __CocoaSet.Index( unint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  *a1 = *a2;
  a1[1] = v6;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  return a1;
}

void destroy for __CocoaSet.Index(uint64_t *a1)
{
}

uint64_t *assignWithCopy for __CocoaDictionary.Index(uint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *a2;
  uint64_t v7 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v6, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  a1[1] = a2[1];
  return a1;
}

uint64_t *assignWithTake for __CocoaSet.Index(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRelease(v4);
  a1[1] = a2[1];
  return a1;
}

ValueMetadata *type metadata accessor for __CocoaSet.Index()
{
  return &type metadata for __CocoaSet.Index;
}

uint64_t method lookup function for __CocoaSet.Iterator(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __CocoaSet.Iterator);
}

unint64_t **initializeBufferWithCopyOfBuffer for _SetBuilder( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  *a1 = *a2;
  a1[1] = v6;
  swift_retain(v5, (uint64_t)a2, a3, a4);
  return a1;
}

uint64_t *assignWithCopy for _DictionaryBuilder(uint64_t *a1, unint64_t **a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *a2;
  uint64_t v7 = *a1;
  *a1 = (uint64_t)*a2;
  swift_retain(v6, (uint64_t)a2, a3, a4);
  swift_release(v7);
  a1[1] = (uint64_t)a2[1];
  return a1;
}

uint64_t *assignWithTake for _SetBuilder(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  *a1 = *a2;
  swift_release(v4);
  a1[1] = a2[1];
  return a1;
}

uint64_t type metadata accessor for _SetBuilder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SetBuilder);
}

uint64_t type metadata accessor for __RawSetStorage()
{
  return objc_opt_self();
}

uint64_t method lookup function for __RawSetStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __RawSetStorage);
}

uint64_t type metadata accessor for __EmptySetSingleton()
{
  return objc_opt_self();
}

uint64_t method lookup function for __EmptySetSingleton(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __EmptySetSingleton);
}

swift *type metadata completion function for WritableKeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 184);
}

uint64_t method lookup function for _SetStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _SetStorage);
}

unint64_t type metadata completion function for Slice(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  v2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  if (v4 <= 0x3F)
  {
    v6[0] = *(void *)(result - 8) + 64LL;
    v6[1] = v6[0];
    unint64_t result = (unint64_t)swift_checkMetadataState((const char *)0x13F, v2);
    if (v5 <= 0x3F)
    {
      void v6[2] = *(void *)(result - 8) + 64LL;
      swift_initStructMetadata(a1, 0, 3uLL, (char *)v6, a1 + 32);
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for Slice( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = *(void *)(v10 + 64);
  unint64_t v12 = *(_DWORD *)(v10 + 80);
  uint64_t v13 = v11 + v12;
  uint64_t v14 = *(void *)(v5 - 8);
  uint64_t v15 = *(_DWORD *)(v14 + 80);
  uint64_t v16 = v11 + v15;
  if ((v15 | v12) > 7
    || ((*(_DWORD *)(v14 + 80) | *(_DWORD *)(v10 + 80)) & 0x100000) != 0
    || ((v11 + v15 + ((v11 + v12) & ~v12)) & ~v15) + *(void *)(v14 + 64) > 0x18)
  {
    uint64_t v19 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v19 + (((v15 | v12) + 16) & ~(v15 | v12)));
    swift_retain(v19, v7, v8, v9);
  }

  else
  {
    unint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = ~v12;
    uint64_t v25 = ~v15;
    unsigned int v22 = *(void (**)(unint64_t **, unint64_t **, unint64_t))(v10 + 16);
    v22(a1, a2, AssociatedTypeWitness);
    unint64_t v23 = ((unint64_t)a2 + v13) & v21;
    v22((unint64_t **)(((unint64_t)a1 + v13) & v21), (unint64_t **)v23, v20);
    (*(void (**)(unint64_t, unint64_t, uint64_t))(v14 + 16))( (v16 + (((unint64_t)a1 + v13) & v21)) & v25,  (v16 + v23) & v25,  v5);
  }

  return a1;
}

uint64_t destroy for Slice(unint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  v3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v5 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v6 = *(void (**)(unint64_t, unint64_t))(v5 + 8);
  v6(a1, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v5 + 64);
  unint64_t v8 = (v7 + a1 + *(unsigned __int8 *)(v5 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  v6(v8, AssociatedTypeWitness);
  return (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)(v3 - 8) + 8LL))( (v8 + v7 + *(unsigned __int8 *)(*(void *)(v3 - 8) + 80LL)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v3 - 8) + 80LL),  v3);
}

uint64_t initializeWithCopy for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 16);
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, AssociatedTypeWitness);
  uint64_t v13 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v13 + 16))( (v9 + *(unsigned __int8 *)(v13 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  (v9 + *(unsigned __int8 *)(v13 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  v5);
  return a1;
}

uint64_t assignWithCopy for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 24);
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, AssociatedTypeWitness);
  uint64_t v13 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v13 + 24))( (v9 + *(unsigned __int8 *)(v13 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  (v9 + *(unsigned __int8 *)(v13 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  v5);
  return a1;
}

uint64_t initializeWithTake for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 32);
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, AssociatedTypeWitness);
  uint64_t v13 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v13 + 32))( (v9 + *(unsigned __int8 *)(v13 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  (v9 + *(unsigned __int8 *)(v13 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  v5);
  return a1;
}

uint64_t assignWithTake for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 40);
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, AssociatedTypeWitness);
  uint64_t v13 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v13 + 40))( (v9 + *(unsigned __int8 *)(v13 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  (v9 + *(unsigned __int8 *)(v13 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80),  v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for Slice(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(void *)(v5 - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  unint64_t v12 = AssociatedTypeWitness;
  uint64_t v13 = *(void *)(v7 + 64);
  uint64_t v14 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v15 = v13 + v14;
  uint64_t v16 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v17 = v13 + v16;
  if (a2 <= v11) {
    goto LABEL_23;
  }
  uint64_t v18 = ((v17 + (v15 & ~v14)) & ~v16) + *(void *)(v9 + 64);
  char v19 = 8 * v18;
  if (v18 <= 3)
  {
    unsigned int v21 = ((a2 - v11 + ~(-1 << v19)) >> v19) + 1;
    if (HIWORD(v21))
    {
      int v20 = *(_DWORD *)(a1 + v18);
      if (!v20) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v21 > 0xFF)
    {
      int v20 = *(unsigned __int16 *)(a1 + v18);
      if (!*(_WORD *)(a1 + v18)) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v21 < 2)
    {
LABEL_23:
      if (v11)
      {
        if (v8 >= v10) {
          return (*(uint64_t (**)(uint64_t, void, unint64_t))(v7 + 48))( a1,  *(unsigned int *)(v7 + 84),  v12);
        }
        else {
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9 + 48))( (v17 + ((v15 + a1) & ~v14)) & ~v16,  v10,  v5);
        }
      }

      return 0LL;
    }
  }

  int v20 = *(unsigned __int8 *)(a1 + v18);
  if (!*(_BYTE *)(a1 + v18)) {
    goto LABEL_23;
  }
LABEL_14:
  int v22 = (v20 - 1) << v19;
  if ((_DWORD)v18)
  {
    else {
      int v23 = 4;
    }
    __asm { BR              X12 }
  }

  return v11 + v22 + 1;
}

void storeEnumTagSinglePayload for Slice(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index)
                 - 8);
  uint64_t v9 = *(void *)(v7 - 8);
  if (*(_DWORD *)(v9 + 84) <= *(_DWORD *)(v8 + 84)) {
    unsigned int v10 = *(_DWORD *)(v8 + 84);
  }
  else {
    unsigned int v10 = *(_DWORD *)(v9 + 84);
  }
  uint64_t v11 = *(void *)(v8 + 64);
  uint64_t v12 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v13 = *(unsigned __int8 *)(v9 + 80);
  size_t v14 = ((v11 + v13 + ((v11 + v12) & ~v12)) & ~v13) + *(void *)(v9 + 64);
  if (a3 <= v10)
  {
    unsigned int v15 = 0u;
  }

  else if (v14 <= 3)
  {
    unsigned int v17 = ((a3 - v10 + ~(-1 << (8 * v14))) >> (8 * v14)) + 1;
    if (HIWORD(v17))
    {
      unsigned int v15 = 4u;
    }

    else if (v17 >= 0x100)
    {
      unsigned int v15 = 2;
    }

    else
    {
      unsigned int v15 = v17 > 1;
    }
  }

  else
  {
    unsigned int v15 = 1u;
  }

  if (v10 < a2)
  {
    unsigned int v16 = ~v10 + a2;
    if (v14 < 4)
    {
      if ((_DWORD)v14)
      {
        int v18 = v16 & ~(-1 << (8 * v14));
        bzero(a1, v14);
        if ((_DWORD)v14 == 3)
        {
          *(_WORD *)a1 = v18;
          a1[2] = BYTE2(v18);
        }

        else if ((_DWORD)v14 == 2)
        {
          *(_WORD *)a1 = v18;
        }

        else
        {
          *a1 = v18;
        }
      }
    }

    else
    {
      bzero(a1, ((v11 + v13 + ((v11 + v12) & ~v12)) & ~v13) + *(void *)(v9 + 64));
      *(_DWORD *)a1 = v16;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X17 }

ValueMetadata *type metadata accessor for _SmallString()
{
  return &type metadata for _SmallString;
}

uint64_t getEnumTagSinglePayload for StaticString(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 17)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for StaticString(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_BYTE *)(result + 16) = 0;
    *(void *)unint64_t result = (a2 - 1);
    *(void *)(result + 8) = 0LL;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 17) = v3;
  return result;
}

ValueMetadata *type metadata accessor for StaticString()
{
  return &type metadata for StaticString;
}

uint64_t dispatch thunk of Strideable.distance(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of Strideable.advanced(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of static Strideable._step(after:from:by:)( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a8 + 56))(a1, a2, a3 & 1);
}

unint64_t type metadata completion function for StrideToIterator(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  unint64_t v3 = (unint64_t)v2;
  if (v4 <= 0x3F)
  {
    uint64_t v5 = *(v2 - 1) + 64;
    v10[0] = v5;
    v10[1] = v5;
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
    unint64_t v3 = AssociatedTypeWitness;
    if (v7 <= 0x3F)
    {
      void v10[2] = *(void *)(AssociatedTypeWitness - 8) + 64LL;
      swift_getTupleTypeLayout2((uint64_t)v9, (uint64_t)"\t", v5);
      uint64_t v10[3] = v9;
      swift_initStructMetadata(a1, 0, 4uLL, (char *)v10, a1 + 32);
      return 0LL;
    }
  }

  return v3;
}

unint64_t **initializeBufferWithCopyOfBuffer for StrideToIterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = *(void *)(v4 + 64);
  int v6 = *(_DWORD *)(v4 + 80);
  uint64_t v7 = v6;
  uint64_t v8 = v5 + v6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(_DWORD *)(v13 + 80);
  uint64_t v15 = v5 + v14;
  uint64_t v16 = *(void *)(v13 + 64) + (v6 | 7LL);
  if ((v14 | (unint64_t)v6) > 7
    || ((*(_DWORD *)(v13 + 80) | v6) & 0x100000) != 0
    || ((v6 + 9LL) & ~(unint64_t)v6)
     + v5
     + ((v16 + ((v5 + v14 + ((v5 + v6) & ~(unint64_t)v6)) & ~v14)) & ~(v6 | 7LL)) > 0x18)
  {
    char v19 = *a2;
    *a1 = *a2;
    int v22 = (unint64_t **)((char *)v19
    swift_retain(v19, v10, v11, v12);
  }

  else
  {
    unint64_t v20 = ~(unint64_t)v6;
    uint64_t v30 = ~v14;
    unint64_t v31 = AssociatedTypeWitness;
    uint64_t v32 = ~(v6 | 7LL);
    uint64_t v33 = v6 + 9LL;
    unsigned int v21 = *(void (**)(unint64_t **, unint64_t **, uint64_t))(v4 + 16);
    int v22 = a1;
    v21(a1, a2, v3);
    unint64_t v23 = ((unint64_t)a2 + v8) & ~v7;
    v21((unint64_t **)(((unint64_t)a1 + v8) & v20), (unint64_t **)v23, v3);
    unint64_t v24 = ((((unint64_t)a1 + v8) & v20) + v15) & v30;
    unint64_t v25 = (v23 + v15) & v30;
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v13 + 16))(v24, v25, v31);
    uint64_t v26 = (v16 + v24) & v32;
    uint64_t v27 = (v16 + v25) & v32;
    char v28 = *(_BYTE *)(v27 + 8);
    *(void *)uint64_t v26 = *(void *)v27;
    *(_BYTE *)(v26 + 8) = v28;
    v21((unint64_t **)((v33 + v26) & v20), (unint64_t **)((v33 + v27) & v20), v3);
  }

  return v22;
}

uint64_t initializeWithCopy for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 16))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  char v20 = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v20;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  return a1;
}

uint64_t assignWithCopy for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 24))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  char v20 = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v20;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  return a1;
}

uint64_t initializeWithTake for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 32))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  char v20 = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v20;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  return a1;
}

uint64_t assignWithTake for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 40))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  char v20 = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v20;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideToIterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v12 = *(void *)(v6 + 64);
  uint64_t v13 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v14 = v12 + v13;
  uint64_t v15 = *(unsigned __int8 *)(v9 + 80);
  if (a2 <= v11) {
    goto LABEL_23;
  }
  uint64_t v16 = ((v13 + 9) & ~v13)
      + v12
      + (((v13 | 7) + *(void *)(v9 + 64) + ((v12 + v15 + (v14 & ~v13)) & ~v15)) & ~(v13 | 7));
  char v17 = 8 * v16;
  if (v16 <= 3)
  {
    unsigned int v19 = ((a2 - v11 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      int v18 = *(_DWORD *)(a1 + v16);
      if (!v18) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v19 > 0xFF)
    {
      int v18 = *(unsigned __int16 *)(a1 + v16);
      if (!*(_WORD *)(a1 + v16)) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v19 < 2)
    {
LABEL_23:
      if (v11)
      {
        else {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))( (((v14 + a1) & ~v13) + v12 + v15) & ~v15,  v10,  AssociatedTypeWitness);
        }
      }

      return 0LL;
    }
  }

  int v18 = *(unsigned __int8 *)(a1 + v16);
  if (!*(_BYTE *)(a1 + v16)) {
    goto LABEL_23;
  }
LABEL_14:
  int v20 = (v18 - 1) << v17;
  if ((_DWORD)v16)
  {
    else {
      int v21 = 4;
    }
    __asm { BR              X12 }
  }

  return v11 + v20 + 1;
}

void storeEnumTagSinglePayload for StrideToIterator(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride)
                  - 8);
  if (*(_DWORD *)(v10 + 84) <= v9) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v12 = *(unsigned __int8 *)(v8 + 80);
  size_t v13 = ((v12 + 9) & ~v12)
      + *(void *)(v8 + 64)
      + (((v12 | 7)
        + *(void *)(v10 + 64)
        + ((*(void *)(v8 + 64) + *(unsigned __int8 *)(v10 + 80) + ((*(void *)(v8 + 64) + v12) & ~v12)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80))) & ~(v12 | 7));
  if (a3 <= v11)
  {
    unsigned int v14 = 0u;
  }

  else if (v13 <= 3)
  {
    unsigned int v16 = ((a3 - v11 + ~(-1 << (8 * v13))) >> (8 * v13)) + 1;
    if (HIWORD(v16))
    {
      unsigned int v14 = 4u;
    }

    else if (v16 >= 0x100)
    {
      unsigned int v14 = 2;
    }

    else
    {
      unsigned int v14 = v16 > 1;
    }
  }

  else
  {
    unsigned int v14 = 1u;
  }

  if (v11 < a2)
  {
    unsigned int v15 = ~v11 + a2;
    if (v13 < 4)
    {
      if ((_DWORD)v13)
      {
        int v17 = v15 & ~(-1 << (8 * v13));
        bzero(a1, v13);
        if ((_DWORD)v13 == 3)
        {
          *(_WORD *)a1 = v17;
          a1[2] = BYTE2(v17);
        }

        else if ((_DWORD)v13 == 2)
        {
          *(_WORD *)a1 = v17;
        }

        else
        {
          *a1 = v17;
        }
      }
    }

    else
    {
      bzero(a1, v13);
      *(_DWORD *)a1 = v15;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X16 }

uint64_t type metadata instantiation function for StrideThroughIterator( _DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x30);
}

unint64_t type metadata completion function for StrideThroughIterator(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  unint64_t v3 = (unint64_t)v2;
  if (v4 <= 0x3F)
  {
    uint64_t v5 = *(v2 - 1) + 64;
    v10[0] = v5;
    v10[1] = v5;
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
    unint64_t v3 = AssociatedTypeWitness;
    if (v7 <= 0x3F)
    {
      void v10[2] = *(void *)(AssociatedTypeWitness - 8) + 64LL;
      swift_getTupleTypeLayout2((uint64_t)v9, (uint64_t)"\t", v5);
      uint64_t v10[3] = v9;
      void v10[4] = &unk_181808918;
      swift_initStructMetadata(a1, 0, 5uLL, (char *)v10, a1 + 32);
      return 0LL;
    }
  }

  return v3;
}

unint64_t **initializeBufferWithCopyOfBuffer for StrideThroughIterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = *(void *)(v4 + 64);
  int v6 = *(_DWORD *)(v4 + 80);
  uint64_t v7 = v5 + v6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = *(_DWORD *)(v12 + 80);
  uint64_t v14 = v5 + v13;
  uint64_t v15 = *(void *)(v12 + 64) + (v6 | 7LL);
  if ((v13 | (unint64_t)v6) > 7
    || ((*(_DWORD *)(v12 + 80) | v6) & 0x100000) != 0
    || ((v6 + 9LL) & ~(unint64_t)v6)
     + v5
     + ((v15 + ((v5 + v13 + ((v5 + v6) & ~(unint64_t)v6)) & ~v13)) & ~(v6 | 7LL))
     + 1 > 0x18)
  {
    int v18 = *a2;
    *a1 = *a2;
    uint64_t v27 = (char *)v18
        + (((v13 | v6) & 0xF8 ^ 0x1F8) & ((v13 | v6) + 16));
    swift_retain(v18, v9, v10, v11);
  }

  else
  {
    uint64_t v29 = ~v13;
    unint64_t v30 = AssociatedTypeWitness;
    uint64_t v31 = ~(v6 | 7LL);
    uint64_t v32 = ((v6 + 9LL) & ~(unint64_t)v6) + v5;
    unsigned int v19 = *(void (**)(unint64_t **, unint64_t **, uint64_t))(v4 + 16);
    v19(a1, a2, v3);
    unint64_t v20 = ((unint64_t)a1 + v7) & ~(unint64_t)v6;
    unint64_t v21 = ((unint64_t)a2 + v7) & ~(unint64_t)v6;
    v19((unint64_t **)v20, (unint64_t **)v21, v3);
    unint64_t v22 = (v20 + v14) & v29;
    unint64_t v23 = (v21 + v14) & v29;
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v12 + 16))(v22, v23, v30);
    uint64_t v24 = (v15 + v22) & v31;
    uint64_t v25 = (v15 + v23) & v31;
    char v26 = *(_BYTE *)(v25 + 8);
    *(void *)uint64_t v24 = *(void *)v25;
    *(_BYTE *)(v24 + 8) = v26;
    v19( (unint64_t **)((v6 + 9LL + v24) & ~(unint64_t)v6),  (unint64_t **)((v6 + 9LL + v25) & ~(unint64_t)v6),  v3);
    *(_BYTE *)(v24 + v32) = *(_BYTE *)(v25 + v32);
    return a1;
  }

  return (unint64_t **)v27;
}

uint64_t destroy for StrideToIterator(unint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v13 = *(uint64_t (**)(unint64_t, uint64_t))(v5 + 8);
  v13(a1, v4);
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v7 = *(unsigned __int8 *)(v5 + 80);
  unint64_t v8 = (v6 + a1 + v7) & ~v7;
  v13(v8, v4);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  v4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v11 = (v8 + v6 + *(unsigned __int8 *)(v10 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80);
  (*(void (**)(unint64_t, unint64_t))(v10 + 8))(v11, AssociatedTypeWitness);
  return v13((v7 + ((*(void *)(v10 + 64) + (v7 | 7) + v11) & ~(v7 | 7)) + 9) & ~v7, v4);
}

uint64_t initializeWithCopy for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 16))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  LOBYTE(v17) = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v17;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  *(_BYTE *)(v18 + ((v10 + 9) & ~v10) + v9) = *(_BYTE *)(v19 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t assignWithCopy for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 24))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  LOBYTE(v17) = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v17;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  *(_BYTE *)(v18 + ((v10 + 9) & ~v10) + v9) = *(_BYTE *)(v19 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t initializeWithTake for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 32))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  LOBYTE(v17) = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v17;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  *(_BYTE *)(v18 + ((v10 + 9) & ~v10) + v9) = *(_BYTE *)(v19 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t assignWithTake for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = (v9 + v14 + ((v9 + v10 + a1) & ~v10)) & ~v14;
  uint64_t v16 = (v9 + v14 + v11) & ~v14;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v13 + 40))(v15, v16, AssociatedTypeWitness);
  uint64_t v17 = *(void *)(v13 + 64) + (v10 | 7);
  uint64_t v18 = (v17 + v15) & ~(v10 | 7);
  uint64_t v19 = (v17 + v16) & ~(v10 | 7);
  LOBYTE(v17) = *(_BYTE *)(v19 + 8);
  *(void *)uint64_t v18 = *(void *)v19;
  *(_BYTE *)(v18 + 8) = v17;
  v8((v10 + 9 + v18) & ~v10, (v10 + 9 + v19) & ~v10, v6);
  *(_BYTE *)(v18 + ((v10 + 9) & ~v10) + v9) = *(_BYTE *)(v19 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideThroughIterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  if (v11 <= 0xFE) {
    unsigned int v11 = 254;
  }
  if (!a2) {
    return 0LL;
  }
  unint64_t v12 = AssociatedTypeWitness;
  uint64_t v13 = *(void *)(v6 + 64);
  uint64_t v14 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v15 = v13 + v14;
  uint64_t v16 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v17 = v14 | 7;
  uint64_t v18 = (v14 | 7) + *(void *)(v9 + 64);
  uint64_t v19 = ((v14 + 9) & ~v14) + v13;
  if (a2 <= v11) {
    goto LABEL_25;
  }
  uint64_t v20 = v19 + ((v18 + ((v13 + v16 + (v15 & ~v14)) & ~v16)) & ~v17) + 1;
  char v21 = 8 * v20;
  unsigned int v23 = ((a2 - v11 + ~(-1 << v21)) >> v21) + 1;
  if (HIWORD(v23))
  {
    int v22 = *(_DWORD *)(a1 + v20);
    if (v22) {
      goto LABEL_16;
    }
  }

  else
  {
    if (v23 <= 0xFF)
    {
      if (v23 < 2) {
        goto LABEL_25;
      }
LABEL_9:
      int v22 = *(unsigned __int8 *)(a1 + v20);
      if (!*(_BYTE *)(a1 + v20)) {
        goto LABEL_25;
      }
LABEL_16:
      int v24 = (v22 - 1) << v21;
      if ((_DWORD)v19
         + (((_DWORD)v18 + (((_DWORD)v13 + (_DWORD)v16 + (v15 & ~(_DWORD)v14)) & ~(_DWORD)v16)) & ~(_DWORD)v17) != -1)
      {
        else {
          int v25 = 4;
        }
        __asm { BR              X12 }
      }

      int v30 = v11 + v24;
      return (v30 + 1);
    }

    int v22 = *(unsigned __int16 *)(a1 + v20);
    if (*(_WORD *)(a1 + v20)) {
      goto LABEL_16;
    }
  }

void storeEnumTagSinglePayload for StrideThroughIterator( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride)
                  - 8);
  if (*(_DWORD *)(v10 + 84) <= v9) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v10 + 84);
  }
  if (v11 <= 0xFE) {
    unsigned int v11 = 254;
  }
  uint64_t v12 = *(unsigned __int8 *)(v8 + 80);
  size_t v13 = ((v12 + 9) & ~v12)
      + *(void *)(v8 + 64)
      + (((v12 | 7)
        + *(void *)(v10 + 64)
  if (a3 <= v11)
  {
    unsigned int v14 = 0u;
  }

  else if (v13 <= 3)
  {
    unsigned int v16 = ((a3 - v11 + ~(-1 << (8 * v13))) >> (8 * v13)) + 1;
    if (HIWORD(v16))
    {
      unsigned int v14 = 4u;
    }

    else if (v16 >= 0x100)
    {
      unsigned int v14 = 2;
    }

    else
    {
      unsigned int v14 = v16 > 1;
    }
  }

  else
  {
    unsigned int v14 = 1u;
  }

  if (v11 < a2)
  {
    int v15 = ~v11 + a2;
    if (v13 < 4)
    {
      if ((((_DWORD)v12 + 9) & ~(_DWORD)v12)
         + *(_DWORD *)(v8 + 64)
         + (((v12 | 7)
           + *(_DWORD *)(v10 + 64)
           + ((*(_DWORD *)(v8 + 64)
             + *(unsigned __int8 *)(v10 + 80)
             + ((*(_DWORD *)(v8 + 64) + (_DWORD)v12) & ~(_DWORD)v12)) & ~*(unsigned __int8 *)(v10 + 80))) & ~(v12 | 7)) != -1)
      {
        int v17 = v15 & ~(-1 << (8 * v13));
        bzero(a1, v13);
        if ((_DWORD)v13 == 3)
        {
          *(_WORD *)a1 = v17;
          a1[2] = BYTE2(v17);
        }

        else if ((_DWORD)v13 == 2)
        {
          *(_WORD *)a1 = v17;
        }

        else
        {
          *a1 = v17;
        }
      }
    }

    else
    {
      bzero(a1, v13);
      *(_DWORD *)a1 = v15;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X4 }

unint64_t type metadata completion function for StrideTo(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  unint64_t v3 = (unint64_t)v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 1) + 64;
    v8[1] = v8[0];
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
    unint64_t v3 = AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      void v8[2] = *(void *)(AssociatedTypeWitness - 8) + 64LL;
      swift_initStructMetadata(a1, 0, 3uLL, (char *)v8, a1 + 32);
      return 0LL;
    }
  }

  return v3;
}

unint64_t **initializeBufferWithCopyOfBuffer for StrideTo( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  int v7 = *(_DWORD *)(v5 + 80);
  uint64_t v8 = v7;
  uint64_t v9 = v6 + v7;
  uint64_t v10 = (v6 + v8) & ~v8;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v16 = *(_DWORD *)(v15 + 80);
  uint64_t v17 = v6 + v16;
  if ((v16 | (unint64_t)v7) > 7
    || ((*(_DWORD *)(v15 + 80) | v7) & 0x100000) != 0
    || ((v17 + v10) & (unint64_t)~v16) + *(void *)(v15 + 64) > 0x18)
  {
    uint64_t v20 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v20 + (((v16 | v7) + 16) & ~(v16 | v7)));
    swift_retain(v20, v12, v13, v14);
  }

  else
  {
    unint64_t v21 = AssociatedTypeWitness;
    uint64_t v26 = ~v16;
    int v22 = *(void (**)(unint64_t **, unint64_t **, uint64_t))(v5 + 16);
    v22(a1, a2, v4);
    unint64_t v23 = ((unint64_t)a1 + v9) & ~v8;
    unint64_t v24 = ((unint64_t)a2 + v9) & ~v8;
    v22((unint64_t **)v23, (unint64_t **)v24, v4);
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v15 + 16))( (v23 + v17) & v26,  (v24 + v17) & v26,  v21);
  }

  return a1;
}

uint64_t destroy for StrideTo(unint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = *(void (**)(unint64_t, uint64_t))(v5 + 8);
  v6(a1, v4);
  uint64_t v7 = *(void *)(v5 + 64);
  unint64_t v8 = (v7 + a1 + *(unsigned __int8 *)(v5 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  v6(v8, v4);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  v4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( (v8 + v7 + *(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL),  AssociatedTypeWitness);
}

uint64_t initializeWithCopy for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v14 + 16))( (v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v14 + 24))( (v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v14 + 32))( (v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v14 + 40))( (v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideTo(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  v5,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v12 = *(void *)(v6 + 64);
  uint64_t v13 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v14 = v12 + v13;
  uint64_t v15 = *(unsigned __int8 *)(v9 + 80);
  if (a2 <= v11) {
    goto LABEL_23;
  }
  uint64_t v16 = ((v12 + v15 + (v14 & ~v13)) & ~v15) + *(void *)(v9 + 64);
  char v17 = 8 * v16;
  if (v16 <= 3)
  {
    unsigned int v19 = ((a2 - v11 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      int v18 = *(_DWORD *)(a1 + v16);
      if (!v18) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v19 > 0xFF)
    {
      int v18 = *(unsigned __int16 *)(a1 + v16);
      if (!*(_WORD *)(a1 + v16)) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v19 < 2)
    {
LABEL_23:
      if (v11)
      {
        else {
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))( (((v14 + a1) & ~v13) + v12 + v15) & ~v15,  v10,  AssociatedTypeWitness);
        }
      }

      return 0LL;
    }
  }

  int v18 = *(unsigned __int8 *)(a1 + v16);
  if (!*(_BYTE *)(a1 + v16)) {
    goto LABEL_23;
  }
LABEL_14:
  int v20 = (v18 - 1) << v17;
  if ((_DWORD)v16)
  {
    else {
      int v21 = 4;
    }
    __asm { BR              X12 }
  }

  return v11 + v20 + 1;
}

void storeEnumTagSinglePayload for StrideTo(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride)
                  - 8);
  if (*(_DWORD *)(v10 + 84) <= v9) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v10 + 84);
  }
  size_t v12 = ((*(void *)(v8 + 64)
        + *(unsigned __int8 *)(v10 + 80)
  if (a3 <= v11)
  {
    unsigned int v13 = 0u;
  }

  else if (v12 <= 3)
  {
    unsigned int v15 = ((a3 - v11 + ~(-1 << (8 * v12))) >> (8 * v12)) + 1;
    if (HIWORD(v15))
    {
      unsigned int v13 = 4u;
    }

    else if (v15 >= 0x100)
    {
      unsigned int v13 = 2;
    }

    else
    {
      unsigned int v13 = v15 > 1;
    }
  }

  else
  {
    unsigned int v13 = 1u;
  }

  if (v11 < a2)
  {
    unsigned int v14 = ~v11 + a2;
    if (v12 < 4)
    {
      if ((_DWORD)v12)
      {
        int v16 = v14 & ~(-1 << (8 * v12));
        bzero(a1, v12);
        if ((_DWORD)v12 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }

        else if ((_DWORD)v12 == 2)
        {
          *(_WORD *)a1 = v16;
        }

        else
        {
          *a1 = v16;
        }
      }
    }

    else
    {
      bzero(a1, v12);
      *(_DWORD *)a1 = v14;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X16 }

ValueMetadata *type metadata accessor for String()
{
  return &type metadata for String;
}

uint64_t type metadata accessor for _StringBreadcrumbs()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for __SwiftNativeNSString()
{
  return objc_opt_self();
}

uint64_t method lookup function for __SwiftNativeNSString(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __SwiftNativeNSString);
}

ValueMetadata *type metadata accessor for String.Iterator()
{
  return &type metadata for String.Iterator;
}

ValueMetadata *type metadata accessor for _StringComparisonResult()
{
  return &type metadata for _StringComparisonResult;
}

ValueMetadata *type metadata accessor for _StringGuts()
{
  return &type metadata for _StringGuts;
}

ValueMetadata *type metadata accessor for _StringObject()
{
  return &type metadata for _StringObject;
}

ValueMetadata *type metadata accessor for _StringObject.Nibbles()
{
  return &type metadata for _StringObject.Nibbles;
}

ValueMetadata *type metadata accessor for _StringObject.CountAndFlags()
{
  return &type metadata for _StringObject.CountAndFlags;
}

uint64_t dispatch thunk of StringProtocol.hasPrefix(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

uint64_t dispatch thunk of StringProtocol.hasSuffix(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of StringProtocol.lowercased()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of StringProtocol.uppercased()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

uint64_t dispatch thunk of StringProtocol.init<A, B>(decoding:as:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void))(a8 + 176))();
}

uint64_t dispatch thunk of StringProtocol.init(cString:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 184))();
}

uint64_t dispatch thunk of StringProtocol.init<A>(decodingCString:as:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 192))();
}

uint64_t dispatch thunk of StringProtocol.withCString<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 200))();
}

uint64_t dispatch thunk of StringProtocol.withCString<A, B>(encodedAs:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void))(a8 + 208))();
}

ValueMetadata *type metadata accessor for String.Index()
{
  return &type metadata for String.Index;
}

ValueMetadata *type metadata accessor for DefaultStringInterpolation()
{
  return &type metadata for DefaultStringInterpolation;
}

ValueMetadata *type metadata accessor for _OpaqueStringSwitchCache()
{
  return &type metadata for _OpaqueStringSwitchCache;
}

void destroy for _StringRepresentation(uint64_t a1)
{
}

uint64_t initializeWithCopy for _StringRepresentation(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  uint64_t v5 = *(void **)(a2 + 24);
  unsigned __int8 v6 = *(_BYTE *)(a2 + 32);
  outlined copy of _StringRepresentation._Form(v5, v6, a3, a4);
  *(void *)(a1 + 24) = v5;
  *(_BYTE *)(a1 + 32) = v6;
  return a1;
}

uint64_t assignWithCopy for _StringRepresentation(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  uint64_t v5 = *(void **)(a2 + 24);
  unsigned __int8 v6 = *(_BYTE *)(a2 + 32);
  outlined copy of _StringRepresentation._Form(v5, v6, a3, a4);
  uint64_t v7 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = v5;
  unsigned __int8 v8 = *(_BYTE *)(a1 + 32);
  *(_BYTE *)(a1 + 32) = v6;
  outlined consume of _StringRepresentation._Form(v7, v8);
  return a1;
}

__n128 __swift_memcpy33_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for _StringRepresentation(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  char v3 = *(_BYTE *)(a2 + 32);
  uint64_t v4 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  unsigned __int8 v5 = *(_BYTE *)(a1 + 32);
  *(_BYTE *)(a1 + 32) = v3;
  outlined consume of _StringRepresentation._Form(v4, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for _StringRepresentation(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && a1[33]) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *a1;
  BOOL v4 = v3 >= 2;
  int v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for _StringRepresentation( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(_BYTE *)(result + 32) = 0;
    *(void *)__n128 result = a2 - 255;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 33) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 33) = 0;
    }
    if (a2) {
      *(_BYTE *)__n128 result = a2 + 1;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for _StringRepresentation()
{
  return &type metadata for _StringRepresentation;
}

uint64_t initializeBufferWithCopyOfBuffer for _StringRepresentation._Form( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  id v5 = *(id *)a2;
  unsigned __int8 v6 = *(_BYTE *)(a2 + 8);
  outlined copy of _StringRepresentation._Form(*(id *)a2, v6, a3, a4);
  *(void *)a1 = v5;
  *(_BYTE *)(a1 + 8) = v6;
  return a1;
}

void destroy for _StringRepresentation._Form(uint64_t a1)
{
}

uint64_t assignWithCopy for _StringRepresentation._Form(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  id v5 = *(id *)a2;
  unsigned __int8 v6 = *(_BYTE *)(a2 + 8);
  outlined copy of _StringRepresentation._Form(*(id *)a2, v6, a3, a4);
  uint64_t v7 = *(void **)a1;
  *(void *)a1 = v5;
  unsigned __int8 v8 = *(_BYTE *)(a1 + 8);
  *(_BYTE *)(a1 + 8) = v6;
  outlined consume of _StringRepresentation._Form(v7, v8);
  return a1;
}

uint64_t __swift_memcpy9_8(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_BYTE *)(result + 8) = *((_BYTE *)a2 + 8);
  *(void *)__n128 result = v2;
  return result;
}

uint64_t assignWithTake for _StringRepresentation._Form(uint64_t a1, uint64_t a2)
{
  char v3 = *(_BYTE *)(a2 + 8);
  BOOL v4 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  unsigned __int8 v5 = *(_BYTE *)(a1 + 8);
  *(_BYTE *)(a1 + 8) = v3;
  outlined consume of _StringRepresentation._Form(v4, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for _StringRepresentation._Form(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFD && *(_BYTE *)(a1 + 9)) {
    return (*(_DWORD *)a1 + 253);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 8);
  if (v3 <= 3) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for _StringRepresentation._Form( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_BYTE *)(result + 8) = 0;
    *(void *)__n128 result = a2 - 253;
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 9) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 9) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 8) = -(char)a2;
    }
  }

  return result;
}

uint64_t getEnumTag for _StringRepresentation._Form(uint64_t a1)
{
  else {
    return (*(_DWORD *)a1 + 3);
  }
}

uint64_t destructiveInjectEnumTag for _StringRepresentation._Form(uint64_t result, unsigned int a2)
{
  if (a2 >= 3)
  {
    *(void *)__n128 result = a2 - 3;
    LOBYTE(a2) = 3;
  }

  *(_BYTE *)(result + 8) = a2;
  return result;
}

ValueMetadata *type metadata accessor for _StringRepresentation._Form()
{
  return &type metadata for _StringRepresentation._Form;
}

ValueMetadata *type metadata accessor for String.UnicodeScalarView()
{
  return &type metadata for String.UnicodeScalarView;
}

uint64_t initializeWithCopy for String.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v5;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  return a1;
}

void *assignWithCopy for String.Iterator(void *a1, void *a2, uint64_t a3, char *a4)
{
  *a1 = *a2;
  unint64_t v6 = a2[1];
  uint64_t v7 = a1[1];
  a1[1] = v6;
  swift_bridgeObjectRetain(v6, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  a1[2] = a2[2];
  a1[3] = a2[3];
  return a1;
}

uint64_t assignWithTake for String.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for String.Iterator(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for String.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for String.UnicodeScalarView.Iterator()
{
  return &type metadata for String.UnicodeScalarView.Iterator;
}

ValueMetadata *type metadata accessor for String.UTF16View()
{
  return &type metadata for String.UTF16View;
}

uint64_t initializeWithCopy for String.UTF16View.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v5;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(_BYTE *)(a1 + 34) = *(_BYTE *)(a2 + 34);
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  return a1;
}

uint64_t assignWithCopy for String.UTF16View.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  *(void *)a1 = *(void *)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v6;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  __int16 v8 = *(_WORD *)(a2 + 32);
  *(_BYTE *)(a1 + 34) = *(_BYTE *)(a2 + 34);
  *(_WORD *)(a1 + 32) = v8;
  return a1;
}

__n128 __swift_memcpy35_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 31) = *(_DWORD *)(a2 + 31);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for String.UTF16View.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(_BYTE *)(a1 + 34) = *(_BYTE *)(a2 + 34);
  return a1;
}

uint64_t getEnumTagSinglePayload for String.UTF16View.Iterator(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 35)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for String.UTF16View.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(_BYTE *)(result + 34) = 0;
    *(_WORD *)(result + 32) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 35) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 35) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for String.UTF16View.Iterator()
{
  return &type metadata for String.UTF16View.Iterator;
}

void *assignWithCopy for Character(void *a1, void *a2, uint64_t a3, char *a4)
{
  *a1 = *a2;
  unint64_t v5 = a2[1];
  uint64_t v6 = a1[1];
  a1[1] = v5;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for Character(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Character(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 16) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for String.UTF8View()
{
  return &type metadata for String.UTF8View;
}

ValueMetadata *type metadata accessor for Substring()
{
  return &type metadata for Substring;
}

ValueMetadata *type metadata accessor for Substring.UTF8View()
{
  return &type metadata for Substring.UTF8View;
}

ValueMetadata *type metadata accessor for Substring.UTF16View()
{
  return &type metadata for Substring.UTF16View;
}

void destroy for Substring.UnicodeScalarView(uint64_t a1)
{
}

ValueMetadata *type metadata accessor for Substring.UnicodeScalarView()
{
  return &type metadata for Substring.UnicodeScalarView;
}

uint64_t type metadata accessor for __SwiftNativeNSArrayWithContiguousStorage()
{
  return objc_opt_self();
}

uint64_t method lookup function for __SwiftNativeNSArrayWithContiguousStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod( a1,  a2,  (unsigned int *)&nominal type descriptor for __SwiftNativeNSArrayWithContiguousStorage);
}

uint64_t method lookup function for _SwiftNSMutableArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _SwiftNSMutableArray);
}

uint64_t method lookup function for __SwiftDeferredNSArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __SwiftDeferredNSArray);
}

uint64_t dispatch thunk of __SwiftDeferredNSArray.__allocating_init(_nativeStorage:)()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

swift *type metadata completion function for __SwiftDeferredStaticNSArray(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0LL, (uint64_t)v2, a1 + 128);
}

uint64_t method lookup function for __ContiguousArrayStorageBase(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __ContiguousArrayStorageBase);
}

uint64_t dispatch thunk of __ContiguousArrayStorageBase.canStoreElements(ofDynamicType:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 128LL))();
}

uint64_t dispatch thunk of __ContiguousArrayStorageBase.staticElementType.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 136LL))();
}

uint64_t __swift_memcpy5_4(uint64_t result, int *a2)
{
  int v2 = *a2;
  *(_BYTE *)(result + 4) = *((_BYTE *)a2 + 4);
  *(_DWORD *)__n128 result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for _UIntBuffer.Iterator(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 5)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for _UIntBuffer.Iterator(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_BYTE *)(result + 4) = 0;
    *(_DWORD *)__n128 result = a2 - 1;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 5) = v3;
  return result;
}

uint64_t type metadata accessor for _UIntBuffer.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _UIntBuffer.Iterator);
}

uint64_t type metadata accessor for _UIntBuffer.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _UIntBuffer.Index);
}

uint64_t dispatch thunk of static _UnicodeEncoding.encodedReplacementCharacter.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

uint64_t dispatch thunk of static _UnicodeEncoding.decode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

uint64_t dispatch thunk of static _UnicodeEncoding.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

uint64_t dispatch thunk of static _UnicodeEncoding.transcode<A>(_:from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 104))();
}

uint64_t dispatch thunk of static _UnicodeEncoding._isScalar(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

unint64_t *type metadata completion function for Unicode.ParseResult(uint64_t a1)
{
  __n128 result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 1) + 64;
    v4[1] = &value witness table for Builtin.Int64.size;
    swift_initEnumMetadataMultiPayload(a1, 0, 2uLL, (char *)v4);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for Unicode.ParseResult( unint64_t **__dst, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v4 = __dst;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if (*(void *)(v6 + 64) <= 8uLL) {
    uint64_t v7 = 8LL;
  }
  else {
    uint64_t v7 = *(void *)(v6 + 64);
  }
  int v8 = *(_DWORD *)(v6 + 80);
  if ((v8 & 0x1000F8) != 0 || (unint64_t)(v7 + 1) > 0x18)
  {
    uint64_t v10 = *a2;
    void *v4 = *a2;
    uint64_t v4 = (unint64_t **)((char *)v10
                             + ((unsigned __int16)((v8 & 0xF8) + 23) & (unsigned __int16)~(v8 & 0xF8) & 0x1F8));
    swift_retain(v10, (uint64_t)a2, v5, a4);
  }

  else
  {
    unsigned int v11 = *((unsigned __int8 *)a2 + v7);
    if (v11 >= 2)
    {
      else {
        uint64_t v12 = 4LL;
      }
      __asm { BR              X14 }
    }

    if (v11 == 1)
    {
      *__dst = *a2;
      *((_BYTE *)__dst + v7) = 1;
    }

    else
    {
      (*(void (**)(unint64_t **))(v6 + 16))(__dst);
      *((_BYTE *)v4 + v7) = 0;
    }
  }

  return v4;
}

uint64_t destroy for Unicode.ParseResult(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a2 + 16) - 8LL);
  unint64_t v3 = *(void *)(v2 + 64);
  if (v3 <= 8) {
    unint64_t v3 = 8LL;
  }
  if (*(unsigned __int8 *)(result + v3) < 2u)
  {
    if (!*(_BYTE *)(result + v3)) {
      return (*(uint64_t (**)(void))(v2 + 8))();
    }
  }

  else
  {
    else {
      uint64_t v4 = 4LL;
    }
    return ((uint64_t (*)(void))((char *)&loc_18172338C + 4 * byte_18180047F[v4]))();
  }

  return result;
}

_BYTE *initializeWithCopy for Unicode.ParseResult(_BYTE *__dst, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  if (*(void *)(v4 + 64) <= 8uLL) {
    uint64_t v5 = 8LL;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 64);
  }
  unsigned int v6 = *((unsigned __int8 *)a2 + v5);
  if (v6 >= 2)
  {
    else {
      uint64_t v7 = 4LL;
    }
    __asm { BR              X13 }
  }

  if (v6 == 1)
  {
    *(void *)__dst = *a2;
    __dst[v5] = 1;
  }

  else
  {
    (*(void (**)(_BYTE *))(v4 + 16))(__dst);
    __dst[v5] = 0;
  }

  return __dst;
}

unsigned __int8 *assignWithCopy for Unicode.ParseResult( unsigned __int8 *__dst, unsigned __int8 *__src, uint64_t a3)
{
  if (__dst != __src)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    if (*(void *)(v6 + 64) <= 8uLL) {
      uint64_t v7 = 8LL;
    }
    else {
      uint64_t v7 = *(void *)(v6 + 64);
    }
    if (__dst[v7] >= 2u)
    {
      else {
        uint64_t v8 = 4LL;
      }
      __asm { BR              X11 }
    }

    if (!__dst[v7]) {
      (*(void (**)(unsigned __int8 *, void))(v6 + 8))(__dst, *(void *)(a3 + 16));
    }
    unsigned int v9 = __src[v7];
    if (v9 >= 2)
    {
      else {
        uint64_t v10 = 4LL;
      }
      __asm { BR              X12 }
    }

    if (v9 == 1)
    {
      *(void *)__dst = *(void *)__src;
      __dst[v7] = 1;
    }

    else
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 16))(__dst, __src, v5);
      __dst[v7] = 0;
    }
  }

  return __dst;
}

_BYTE *initializeWithTake for Unicode.ParseResult(_BYTE *__dst, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  if (*(void *)(v4 + 64) <= 8uLL) {
    uint64_t v5 = 8LL;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 64);
  }
  unsigned int v6 = *((unsigned __int8 *)a2 + v5);
  if (v6 >= 2)
  {
    else {
      uint64_t v7 = 4LL;
    }
    __asm { BR              X13 }
  }

  if (v6 == 1)
  {
    *(void *)__dst = *a2;
    __dst[v5] = 1;
  }

  else
  {
    (*(void (**)(_BYTE *))(v4 + 32))(__dst);
    __dst[v5] = 0;
  }

  return __dst;
}

unsigned __int8 *assignWithTake for Unicode.ParseResult( unsigned __int8 *__dst, unsigned __int8 *__src, uint64_t a3)
{
  if (__dst != __src)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    if (*(void *)(v6 + 64) <= 8uLL) {
      uint64_t v7 = 8LL;
    }
    else {
      uint64_t v7 = *(void *)(v6 + 64);
    }
    if (__dst[v7] >= 2u)
    {
      else {
        uint64_t v8 = 4LL;
      }
      __asm { BR              X11 }
    }

    if (!__dst[v7]) {
      (*(void (**)(unsigned __int8 *, void))(v6 + 8))(__dst, *(void *)(a3 + 16));
    }
    unsigned int v9 = __src[v7];
    if (v9 >= 2)
    {
      else {
        uint64_t v10 = 4LL;
      }
      __asm { BR              X12 }
    }

    if (v9 == 1)
    {
      *(void *)__dst = *(void *)__src;
      __dst[v7] = 1;
    }

    else
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 32))(__dst, __src, v5);
      __dst[v7] = 0;
    }
  }

  return __dst;
}

uint64_t getEnumTagSinglePayload for Unicode.ParseResult(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = 8LL;
  if (*(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL) > 8uLL) {
    uint64_t v3 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL);
  }
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFE) {
    goto LABEL_21;
  }
  uint64_t v4 = v3 + 1;
  char v5 = 8 * (v3 + 1);
  if ((v3 + 1) <= 3)
  {
    unsigned int v8 = ((a2 + ~(-1 << v5) - 253) >> v5) + 1;
    if (HIWORD(v8))
    {
      int v6 = *(_DWORD *)(a1 + v4);
      if (!v6) {
        goto LABEL_21;
      }
      goto LABEL_14;
    }

    if (v8 > 0xFF)
    {
      int v6 = *(unsigned __int16 *)(a1 + v4);
      if (!*(_WORD *)(a1 + v4)) {
        goto LABEL_21;
      }
      goto LABEL_14;
    }

    if (v8 < 2)
    {
LABEL_21:
      unsigned int v10 = *(unsigned __int8 *)(a1 + v3);
      if (v10 >= 3) {
        return (v10 ^ 0xFF) + 1;
      }
      else {
        return 0LL;
      }
    }
  }

  int v6 = *(unsigned __int8 *)(a1 + v4);
  if (!*(_BYTE *)(a1 + v4)) {
    goto LABEL_21;
  }
LABEL_14:
  int v9 = (v6 - 1) << v5;
  if (!(_DWORD)v4) {
    return (v9 + 254);
  }
  return ((uint64_t (*)(void))((char *)&loc_181723998 + 4 * byte_1818004A2[(v4 - 1)]))();
}

void storeEnumTagSinglePayload for Unicode.ParseResult( _WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8LL) + 64LL);
  if (v5 <= 8) {
    unint64_t v5 = 8LL;
  }
  size_t v6 = v5 + 1;
  if (a3 < 0xFE)
  {
    unsigned int v7 = 0u;
  }

  else if (v6 <= 3)
  {
    unsigned int v9 = ((a3 + ~(-1 << (8 * v6)) - 253) >> (8 * v6)) + 1;
    if (HIWORD(v9))
    {
      unsigned int v7 = 4u;
    }

    else if (v9 >= 0x100)
    {
      unsigned int v7 = 2;
    }

    else
    {
      unsigned int v7 = v9 > 1;
    }
  }

  else
  {
    unsigned int v7 = 1u;
  }

  if (a2 <= 0xFD) {
    __asm { BR              X11 }
  }

  unsigned int v8 = a2 - 254;
  if (v6 < 4)
  {
    if ((_DWORD)v5 != -1)
    {
      int v10 = v8 & ~(-1 << (8 * v6));
      bzero(a1, v6);
      if ((_DWORD)v6 == 3)
      {
        *a1 = v10;
        *((_BYTE *)a1 + 2) = BYTE2(v10);
      }

      else if ((_DWORD)v6 == 2)
      {
        *a1 = v10;
      }

      else
      {
        *(_BYTE *)a1 = v10;
      }
    }
  }

  else
  {
    bzero(a1, v5 + 1);
    *(_DWORD *)a1 = v8;
  }

  __asm { BR              X10 }

uint64_t getEnumTag for Unicode.ParseResult(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 8LL;
  if (*(void *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 64LL) > 8uLL) {
    uint64_t v2 = *(void *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 64LL);
  }
  else {
    uint64_t v3 = 4LL;
  }
  return ((uint64_t (*)(void))((char *)&loc_181723BD4 + 4 * byte_1818004B0[v3]))();
}

void destructiveInjectEnumTag for Unicode.ParseResult(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  if (*(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL) <= 8uLL) {
    size_t v4 = 8LL;
  }
  else {
    size_t v4 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL);
  }
  if (a2 > 1)
  {
    unsigned int v5 = a2 - 2;
    if (v4 < 4)
    {
      unsigned int v6 = v5 >> (8 * v4);
      int v7 = v5 & ~(-1 << (8 * v4));
      a1[v4] = v6 + 2;
      bzero(a1, v4);
      if ((_DWORD)v4 == 3)
      {
        *(_WORD *)a1 = v7;
        a1[2] = BYTE2(v7);
      }

      else if ((_DWORD)v4 == 2)
      {
        *(_WORD *)a1 = v7;
      }

      else
      {
        *a1 = v7;
      }
    }

    else
    {
      a1[v4] = 2;
      bzero(a1, v4);
      *(_DWORD *)a1 = v5;
    }
  }

  else
  {
    a1[v4] = a2;
  }

uint64_t dispatch thunk of _UnicodeParser.parseScalar<A>(from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 32))();
}

ValueMetadata *type metadata accessor for Unicode.Scalar.Properties()
{
  return &type metadata for Unicode.Scalar.Properties;
}

uint64_t getEnumTagSinglePayload for Unicode.GeneralCategory(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xE3) {
    goto LABEL_17;
  }
  if (a2 + 29 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 29) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 29;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 29;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 29;
    }
  }

uint64_t storeEnumTagSinglePayload for Unicode.GeneralCategory(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 29 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 29) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xE3) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xE2) {
    return ((uint64_t (*)(void))((char *)&loc_181723DD8 + 4 * byte_1818004BA[v4]))();
  }
  *a1 = a2 + 29;
  return ((uint64_t (*)(void))((char *)sub_181723E0C + 4 * byte_1818004B5[v4]))();
}

uint64_t sub_181723E0C(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_181723E14(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x181723E1CLL);
  }
  return result;
}

uint64_t sub_181723E28(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x181723E30LL);
  }
  *(_BYTE *)__n128 result = a2 + 29;
  return result;
}

uint64_t sub_181723E34(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_181723E3C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for Unicode.GeneralCategory()
{
  return &type metadata for Unicode.GeneralCategory;
}

ValueMetadata *type metadata accessor for Unicode.CanonicalCombiningClass()
{
  return &type metadata for Unicode.CanonicalCombiningClass;
}

ValueMetadata *type metadata accessor for Unicode.NumericType()
{
  return &type metadata for Unicode.NumericType;
}

ValueMetadata *type metadata accessor for Unicode._NFD()
{
  return &type metadata for Unicode._NFD;
}

void destroy for Unicode._NFD.Iterator(uint64_t *a1)
{
}

uint64_t initializeWithCopy for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  __int128 v6 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v6;
  unint64_t v7 = *(void *)(a2 + 48);
  *(void *)(a1 + 48) = v7;
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  swift_bridgeObjectRetain(v7, v8, v9, v10);
  return a1;
}

uint64_t assignWithCopy for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *(void *)a2;
  uint64_t v7 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(void *)(a2 + 40);
  unint64_t v8 = *(void *)(a2 + 48);
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v8;
  swift_bridgeObjectRetain(v8, v10, v11, v12);
  swift_bridgeObjectRelease(v9);
  return a1;
}

__n128 __swift_memcpy56_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  __int128 v5 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v5;
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease(v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFD.Iterator(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 56)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFD.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 56) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 56) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for Unicode._NFD.Iterator()
{
  return &type metadata for Unicode._NFD.Iterator;
}

uint64_t initializeWithCopy for Substring(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  unint64_t v5 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v5;
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  return a1;
}

void *assignWithCopy for Substring(void *a1, void *a2, uint64_t a3, char *a4)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  unint64_t v5 = a2[3];
  uint64_t v6 = a1[3];
  a1[3] = v5;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v6);
  return a1;
}

uint64_t assignWithTake for Substring(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for Substring(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Substring(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for Unicode._NFC()
{
  return &type metadata for Unicode._NFC;
}

void destroy for Unicode._NFC.Iterator(uint64_t *a1)
{
}

uint64_t initializeWithCopy for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  unint64_t v6 = *(void *)(a2 + 24);
  *(void *)(a1 + 24) = v6;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_OWORD *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  unint64_t v7 = *(void *)(a2 + 72);
  *(void *)(a1 + 72) = v7;
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  swift_bridgeObjectRetain(v6, v8, v9, v10);
  swift_bridgeObjectRetain(v7, v11, v12, v13);
  return a1;
}

uint64_t assignWithCopy for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *(void *)a2;
  uint64_t v7 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  int v8 = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_DWORD *)(a1 + 12) = v8;
  unint64_t v9 = *(void *)(a2 + 24);
  uint64_t v10 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v9;
  swift_bridgeObjectRetain(v9, v11, v12, v13);
  swift_bridgeObjectRelease(v10);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(void *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  unint64_t v14 = *(void *)(a2 + 72);
  uint64_t v15 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v14;
  swift_bridgeObjectRetain(v14, v16, v17, v18);
  swift_bridgeObjectRelease(v15);
  return a1;
}

__n128 __swift_memcpy80_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(__n128 *)(a1 + 16) = result;
  *(_OWORD *)(a1 + 32) = v3;
  return result;
}

uint64_t assignWithTake for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_OWORD *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  uint64_t v6 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRelease(v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFC.Iterator(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 80)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFC.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 72) = 0LL;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for Unicode._NFC.Iterator()
{
  return &type metadata for Unicode._NFC.Iterator;
}

uint64_t getEnumTagSinglePayload for _BridgeableMetatype(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 8)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _BridgeableMetatype(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 8) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 8) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t type metadata accessor for Unmanaged(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Unmanaged,  &flag for loading of canonical specialized generic type metadata for Unmanaged);
}

ValueMetadata *type metadata accessor for UnsafeRawPointer()
{
  return &type metadata for UnsafeRawPointer;
}

ValueMetadata *type metadata accessor for UnsafeMutableRawPointer()
{
  return &type metadata for UnsafeMutableRawPointer;
}

uint64_t dispatch thunk of _UTFParser._parseMultipleCodeUnits()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))() & 0xFFFFFF01LL;
}

uint64_t dispatch thunk of _UTFParser._bufferedScalar(bitCount:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _UTFParser._buffer.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))() & 0xFFFFFFFFFFLL;
}

uint64_t dispatch thunk of _UTFParser._buffer.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(a3 + 48))(a1 & 0xFFFFFFFFFFLL);
}

uint64_t dispatch thunk of _UTFParser._buffer.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

ValueMetadata *type metadata accessor for Unicode.UTF8()
{
  return &type metadata for Unicode.UTF8;
}

ValueMetadata *type metadata accessor for Unicode.UTF8.ForwardParser()
{
  return &type metadata for Unicode.UTF8.ForwardParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF8.ReverseParser()
{
  return &type metadata for Unicode.UTF8.ReverseParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF16()
{
  return &type metadata for Unicode.UTF16;
}

ValueMetadata *type metadata accessor for Unicode.UTF16.ForwardParser()
{
  return &type metadata for Unicode.UTF16.ForwardParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF16.ReverseParser()
{
  return &type metadata for Unicode.UTF16.ReverseParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF32()
{
  return &type metadata for Unicode.UTF32;
}

ValueMetadata *type metadata accessor for Unicode.UTF32.Parser()
{
  return &type metadata for Unicode.UTF32.Parser;
}

uint64_t getEnumTag for UnicodeDecodingResult(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t destructiveInjectEnumTag for UnicodeDecodingResult(uint64_t result, int a2)
{
  if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_BYTE *)(result + 4) = 1;
  }

  else
  {
    *(_BYTE *)(result + 4) = 0;
  }

  return result;
}

ValueMetadata *type metadata accessor for UnicodeDecodingResult()
{
  return &type metadata for UnicodeDecodingResult;
}

uint64_t dispatch thunk of UnicodeCodec.decode<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = (*(uint64_t (**)(void))(a5 + 24))();
  return v5 | ((HIDWORD(v5) & 1) << 32);
}

uint64_t dispatch thunk of static UnicodeCodec.encode(_:into:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 32))();
}

uint64_t dispatch thunk of static UnicodeCodec._nullCodeUnitOffset(in:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of static _StringElement._toUTF16CodeUnit(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of static _StringElement._fromUTF16CodeUnit(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

ValueMetadata *type metadata accessor for Unicode()
{
  return &type metadata for Unicode;
}

void *__swift_memcpy8_4(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for Unicode._CharacterRecognizer(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 4);
  BOOL v4 = v3 >= 2;
  int v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._CharacterRecognizer( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 8) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 8) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 4) = a2 + 1;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for Unicode._CharacterRecognizer()
{
  return &type metadata for Unicode._CharacterRecognizer;
}

ValueMetadata *type metadata accessor for _ValidUTF8Buffer()
{
  return &type metadata for _ValidUTF8Buffer;
}

ValueMetadata *type metadata accessor for _ValidUTF8Buffer.Iterator()
{
  return &type metadata for _ValidUTF8Buffer.Iterator;
}

ValueMetadata *type metadata accessor for _ValidUTF8Buffer.Index()
{
  return &type metadata for _ValidUTF8Buffer.Index;
}

void destroy for _PlaygroundQuickLook(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 32);
  while (2)
  {
    switch(v2)
    {
      case 0:
      case 17:
        swift_bridgeObjectRelease(*(void *)(a1 + 8));
        break;
      case 1:
      case 2:
      case 3:
      case 4:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
        return;
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 15:
      case 16:
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
        break;
      case 18:
        swift_bridgeObjectRelease(*(void *)a1);
        swift_bridgeObjectRelease(*(void *)(a1 + 16));
        break;
      default:
        int v2 = *(_DWORD *)a1 + 19;
        continue;
    }

    break;
  }

uint64_t initializeWithCopy for _PlaygroundQuickLook(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  int v5 = *(unsigned __int8 *)(a2 + 32);
  while (2)
  {
    switch(v5)
    {
      case 0:
        unint64_t v6 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v6;
        *(_BYTE *)(a1 + 32) = 0;
        goto LABEL_23;
      case 1:
        *(void *)a1 = *(void *)a2;
        *(_BYTE *)(a1 + 32) = 1;
        return a1;
      case 2:
        *(void *)a1 = *(void *)a2;
        *(_BYTE *)(a1 + 32) = 2;
        return a1;
      case 3:
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_BYTE *)(a1 + 32) = 3;
        return a1;
      case 4:
        *(void *)a1 = *(void *)a2;
        *(_BYTE *)(a1 + 32) = 4;
        return a1;
      case 5:
        uint64_t v7 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v7;
        (**(void (***)(uint64_t))(v7 - 8))(a1);
        *(_BYTE *)(a1 + 32) = 5;
        return a1;
      case 6:
        uint64_t v8 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v8;
        (**(void (***)(uint64_t))(v8 - 8))(a1);
        *(_BYTE *)(a1 + 32) = 6;
        return a1;
      case 7:
        uint64_t v9 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v9;
        (**(void (***)(uint64_t))(v9 - 8))(a1);
        *(_BYTE *)(a1 + 32) = 7;
        return a1;
      case 8:
        uint64_t v10 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v10;
        (**(void (***)(uint64_t))(v10 - 8))(a1);
        *(_BYTE *)(a1 + 32) = 8;
        return a1;
      case 9:
        uint64_t v11 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v11;
        (**(void (***)(uint64_t))(v11 - 8))(a1);
        *(_BYTE *)(a1 + 32) = 9;
        return a1;
      case 10:
        __int128 v12 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v12;
        *(_BYTE *)(a1 + 32) = 10;
        return a1;
      case 11:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_BYTE *)(a1 + 32) = 11;
        return a1;
      case 12:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_BYTE *)(a1 + 32) = 12;
        return a1;
      case 13:
        *(_BYTE *)a1 = *(_BYTE *)a2;
        *(_BYTE *)(a1 + 32) = 13;
        return a1;
      case 14:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_BYTE *)(a1 + 32) = 14;
        return a1;
      case 15:
        uint64_t v13 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v13;
        (**(void (***)(uint64_t))(v13 - 8))(a1);
        *(_BYTE *)(a1 + 32) = 15;
        return a1;
      case 16:
        uint64_t v14 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v14;
        (**(void (***)(uint64_t))(v14 - 8))(a1);
        *(_BYTE *)(a1 + 32) = 16;
        return a1;
      case 17:
        unint64_t v6 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v6;
        *(_BYTE *)(a1 + 32) = 17;
        goto LABEL_23;
      case 18:
        unint64_t v15 = *(void *)a2;
        uint64_t v16 = *(void *)(a2 + 8);
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = v16;
        unint64_t v17 = *(void *)(a2 + 16);
        *(void *)(a1 + 16) = v17;
        *(_BYTE *)(a1 + 32) = 18;
        swift_bridgeObjectRetain(v15, a2, a3, a4);
        unint64_t v6 = v17;
LABEL_23:
        swift_bridgeObjectRetain(v6, a2, a3, a4);
        return a1;
      default:
        int v5 = *(_DWORD *)a2 + 19;
        continue;
    }
  }

uint64_t assignWithCopy for _PlaygroundQuickLook(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a1 != a2)
  {
    int v6 = *(unsigned __int8 *)(a1 + 32);
    while (2)
    {
      switch(v6)
      {
        case 0:
        case 17:
          uint64_t v7 = *(void *)(a1 + 8);
          goto LABEL_8;
        case 1:
        case 2:
        case 3:
        case 4:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
          goto LABEL_9;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 15:
        case 16:
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
          goto LABEL_9;
        case 18:
          swift_bridgeObjectRelease(*(void *)a1);
          uint64_t v7 = *(void *)(a1 + 16);
LABEL_8:
          swift_bridgeObjectRelease(v7);
LABEL_9:
          int v8 = *(unsigned __int8 *)(a2 + 32);
          while (2)
          {
            switch(v8)
            {
              case 0:
                *(void *)a1 = *(void *)a2;
                unint64_t v9 = *(void *)(a2 + 8);
                *(void *)(a1 + 8) = v9;
                *(_BYTE *)(a1 + 32) = 0;
                goto LABEL_31;
              case 1:
                *(void *)a1 = *(void *)a2;
                *(_BYTE *)(a1 + 32) = 1;
                return a1;
              case 2:
                *(void *)a1 = *(void *)a2;
                *(_BYTE *)(a1 + 32) = 2;
                return a1;
              case 3:
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_BYTE *)(a1 + 32) = 3;
                return a1;
              case 4:
                *(void *)a1 = *(void *)a2;
                *(_BYTE *)(a1 + 32) = 4;
                return a1;
              case 5:
                uint64_t v10 = *(void *)(a2 + 24);
                *(void *)(a1 + 24) = v10;
                (**(void (***)(uint64_t, uint64_t))(v10 - 8))(a1, a2);
                *(_BYTE *)(a1 + 32) = 5;
                return a1;
              case 6:
                uint64_t v11 = *(void *)(a2 + 24);
                *(void *)(a1 + 24) = v11;
                (**(void (***)(uint64_t, uint64_t))(v11 - 8))(a1, a2);
                *(_BYTE *)(a1 + 32) = 6;
                return a1;
              case 7:
                uint64_t v12 = *(void *)(a2 + 24);
                *(void *)(a1 + 24) = v12;
                (**(void (***)(uint64_t, uint64_t))(v12 - 8))(a1, a2);
                *(_BYTE *)(a1 + 32) = 7;
                return a1;
              case 8:
                uint64_t v13 = *(void *)(a2 + 24);
                *(void *)(a1 + 24) = v13;
                (**(void (***)(uint64_t, uint64_t))(v13 - 8))(a1, a2);
                *(_BYTE *)(a1 + 32) = 8;
                return a1;
              case 9:
                uint64_t v14 = *(void *)(a2 + 24);
                *(void *)(a1 + 24) = v14;
                (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
                *(_BYTE *)(a1 + 32) = 9;
                return a1;
              case 10:
                __int128 v15 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v15;
                *(_BYTE *)(a1 + 32) = 10;
                return a1;
              case 11:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_BYTE *)(a1 + 32) = 11;
                return a1;
              case 12:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_BYTE *)(a1 + 32) = 12;
                return a1;
              case 13:
                *(_BYTE *)a1 = *(_BYTE *)a2;
                *(_BYTE *)(a1 + 32) = 13;
                return a1;
              case 14:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_BYTE *)(a1 + 32) = 14;
                return a1;
              case 15:
                uint64_t v16 = *(void *)(a2 + 24);
                *(void *)(a1 + 24) = v16;
                (**(void (***)(uint64_t, uint64_t))(v16 - 8))(a1, a2);
                *(_BYTE *)(a1 + 32) = 15;
                return a1;
              case 16:
                uint64_t v17 = *(void *)(a2 + 24);
                *(void *)(a1 + 24) = v17;
                (**(void (***)(uint64_t, uint64_t))(v17 - 8))(a1, a2);
                *(_BYTE *)(a1 + 32) = 16;
                return a1;
              case 17:
                *(void *)a1 = *(void *)a2;
                unint64_t v9 = *(void *)(a2 + 8);
                *(void *)(a1 + 8) = v9;
                *(_BYTE *)(a1 + 32) = 17;
                goto LABEL_31;
              case 18:
                unint64_t v18 = *(void *)a2;
                *(void *)a1 = *(void *)a2;
                *(void *)(a1 + 8) = *(void *)(a2 + 8);
                unint64_t v19 = *(void *)(a2 + 16);
                *(void *)(a1 + 16) = v19;
                *(_BYTE *)(a1 + 32) = 18;
                swift_bridgeObjectRetain(v18, a2, a3, a4);
                unint64_t v9 = v19;
LABEL_31:
                swift_bridgeObjectRetain(v9, a2, a3, a4);
                break;
              default:
                int v8 = *(_DWORD *)a2 + 19;
                continue;
            }

            break;
          }

          break;
        default:
          int v6 = *(_DWORD *)a1 + 19;
          continue;
      }

      break;
    }
  }

  return a1;
}

uint64_t assignWithTake for _PlaygroundQuickLook(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(unsigned __int8 *)(a1 + 32);
    while (2)
    {
      switch(v4)
      {
        case 0:
        case 17:
          uint64_t v5 = *(void *)(a1 + 8);
          goto LABEL_8;
        case 1:
        case 2:
        case 3:
        case 4:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
          goto LABEL_9;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 15:
        case 16:
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
          goto LABEL_9;
        case 18:
          swift_bridgeObjectRelease(*(void *)a1);
          uint64_t v5 = *(void *)(a1 + 16);
LABEL_8:
          swift_bridgeObjectRelease(v5);
LABEL_9:
          int v6 = *(unsigned __int8 *)(a2 + 32);
          while (2)
          {
            switch(v6)
            {
              case 0:
                char v7 = 0;
                *(_OWORD *)a1 = *(_OWORD *)a2;
                break;
              case 1:
                *(void *)a1 = *(void *)a2;
                char v7 = 1;
                break;
              case 2:
                *(void *)a1 = *(void *)a2;
                char v7 = 2;
                break;
              case 3:
                *(_DWORD *)a1 = *(_DWORD *)a2;
                char v7 = 3;
                break;
              case 4:
                *(void *)a1 = *(void *)a2;
                char v7 = 4;
                break;
              case 5:
                __int128 v8 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v8;
                char v7 = 5;
                break;
              case 6:
                __int128 v9 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v9;
                char v7 = 6;
                break;
              case 7:
                __int128 v10 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v10;
                char v7 = 7;
                break;
              case 8:
                __int128 v11 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v11;
                char v7 = 8;
                break;
              case 9:
                __int128 v12 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v12;
                char v7 = 9;
                break;
              case 10:
                __int128 v13 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v13;
                char v7 = 10;
                break;
              case 11:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                char v7 = 11;
                break;
              case 12:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                char v7 = 12;
                break;
              case 13:
                *(_BYTE *)a1 = *(_BYTE *)a2;
                char v7 = 13;
                break;
              case 14:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                char v7 = 14;
                break;
              case 15:
                __int128 v14 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v14;
                char v7 = 15;
                break;
              case 16:
                __int128 v15 = *(_OWORD *)(a2 + 16);
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(_OWORD *)(a1 + 16) = v15;
                char v7 = 16;
                break;
              case 17:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                char v7 = 17;
                break;
              case 18:
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(void *)(a1 + 16) = *(void *)(a2 + 16);
                char v7 = 18;
                break;
              default:
                int v6 = *(_DWORD *)a2 + 19;
                continue;
            }

            break;
          }

          *(_BYTE *)(a1 + 32) = v7;
          break;
        default:
          int v4 = *(_DWORD *)a1 + 19;
          continue;
      }

      break;
    }
  }

  return a1;
}

uint64_t getEnumTagSinglePayload for _PlaygroundQuickLook(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xEE && *(_BYTE *)(a1 + 33)) {
    return (*(_DWORD *)a1 + 238);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 32);
  if (v3 >= 0x13) {
    return (v3 ^ 0xFF) + 1;
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for _PlaygroundQuickLook(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xED)
  {
    *(_BYTE *)(result + 32) = 0;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)__n128 result = a2 - 238;
    if (a3 >= 0xEE) {
      *(_BYTE *)(result + 33) = 1;
    }
  }

  else
  {
    if (a3 >= 0xEE) {
      *(_BYTE *)(result + 33) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 32) = -(char)a2;
    }
  }

  return result;
}

uint64_t getEnumTag for _PlaygroundQuickLook(uint64_t a1)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 32);
  return result;
}

uint64_t destructiveInjectEnumTag for _PlaygroundQuickLook(uint64_t result, unsigned int a2)
{
  if (a2 > 0x12)
  {
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)uint64_t result = a2 - 19;
    LOBYTE(a2) = 19;
  }

  *(_BYTE *)(result + 32) = a2;
  return result;
}

ValueMetadata *type metadata accessor for _PlaygroundQuickLook()
{
  return &type metadata for _PlaygroundQuickLook;
}

uint64_t dispatch thunk of _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

unint64_t *type metadata completion function for CollectionDifference.Change(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_getTupleTypeLayout3((uint64_t)v6, (uint64_t)&value witness table for Builtin.Int64.size, v4, (uint64_t)"\t");
    v7[0] = v6;
    swift_getTupleTypeLayout3((uint64_t)v5, (uint64_t)&value witness table for Builtin.Int64.size, v4, (uint64_t)"\t");
    v7[1] = v5;
    swift_initEnumMetadataMultiPayload(a1, 0, 2uLL, (char *)v7);
    return 0LL;
  }

  return result;
}

void *initializeBufferWithCopyOfBuffer for CollectionDifference.Change( void *a1, unsigned __int8 *a2, uint64_t a3, char *a4)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  uint64_t v8 = *(void *)(v6 + 64) + 7LL;
  unint64_t v9 = (v8 + ((v7 + 8) & ~v7)) & 0xFFFFFFFFFFFFFFF8LL;
  if (v7 > 7 || (*(_DWORD *)(v6 + 80) & 0x100000) != 0 || v9 + 10 > 0x18)
  {
    __int128 v12 = *(unint64_t **)a2;
    void *v4 = *(void *)a2;
    uint64_t v4 = (unint64_t *)((char *)v12 + ((v7 & 0xF8 ^ 0x1F8) & (v7 + 16)));
    swift_retain(v12, (uint64_t)a2, v5, a4);
    return v4;
  }

  uint64_t v13 = ~v7;
  unint64_t v14 = v9 + 9;
  unsigned int v15 = a2[v9 + 9];
  if (v15 >= 2)
  {
    if ((_DWORD)v9 == -8)
    {
      int v16 = *a2;
LABEL_14:
      unsigned int v15 = (v16 | ((v15 - 2) << (8 * v14))) + 2;
      goto LABEL_16;
    }

    int v16 = *(_DWORD *)a2;
    unsigned int v15 = v16 + 2;
  }

void *initializeWithCopy for CollectionDifference.Change(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  uint64_t v5 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = ~v5;
  uint64_t v7 = *(void *)(v4 + 64) + 7LL;
  unint64_t v8 = ((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8LL) + 9;
  unsigned int v9 = a2[v8];
  unsigned int v10 = v9 - 2;
  if (v9 >= 2)
  {
    if ((((_DWORD)v7 + (((_DWORD)v5 + 8) & ~(_DWORD)v5)) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      int v11 = *a2;
    }

    else
    {
      int v11 = *(_DWORD *)a2;
      if (v8 >= 4)
      {
        unsigned int v9 = v11 + 2;
        goto LABEL_7;
      }
    }

    unsigned int v9 = (v11 | (v10 << (8 * v8))) + 2;
  }

unsigned __int8 *assignWithCopy for CollectionDifference.Change( unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
    uint64_t v8 = *(void *)(v6 + 64) + 7LL;
    unint64_t v9 = ((v8 + ((v7 + 8) & ~v7)) & 0xFFFFFFFFFFFFFFF8LL) + 9;
    uint64_t v10 = (unint64_t)&a1[v7 + 8] & ~v7;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v10, v5);
    unsigned int v11 = a2[v9];
    unsigned int v12 = v11 - 2;
    if (v11 >= 2)
    {
      if ((((_DWORD)v8 + (((_DWORD)v7 + 8) & ~(_DWORD)v7)) & 0xFFFFFFF8) == 0xFFFFFFF8)
      {
        int v13 = *a2;
      }

      else
      {
        int v13 = *(_DWORD *)a2;
        if (v9 >= 4)
        {
          unsigned int v11 = v13 + 2;
          goto LABEL_8;
        }
      }

      unsigned int v11 = (v13 | (v12 << (8 * v9))) + 2;
    }

void *initializeWithTake for CollectionDifference.Change(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  uint64_t v5 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = ~v5;
  uint64_t v7 = *(void *)(v4 + 64) + 7LL;
  unint64_t v8 = ((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8LL) + 9;
  unsigned int v9 = a2[v8];
  unsigned int v10 = v9 - 2;
  if (v9 >= 2)
  {
    if ((((_DWORD)v7 + (((_DWORD)v5 + 8) & ~(_DWORD)v5)) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      int v11 = *a2;
    }

    else
    {
      int v11 = *(_DWORD *)a2;
      if (v8 >= 4)
      {
        unsigned int v9 = v11 + 2;
        goto LABEL_7;
      }
    }

    unsigned int v9 = (v11 | (v10 << (8 * v8))) + 2;
  }

unsigned __int8 *assignWithTake for CollectionDifference.Change( unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
    uint64_t v8 = *(void *)(v6 + 64) + 7LL;
    unint64_t v9 = ((v8 + ((v7 + 8) & ~v7)) & 0xFFFFFFFFFFFFFFF8LL) + 9;
    uint64_t v10 = (unint64_t)&a1[v7 + 8] & ~v7;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v10, v5);
    unsigned int v11 = a2[v9];
    unsigned int v12 = v11 - 2;
    if (v11 >= 2)
    {
      if ((((_DWORD)v8 + (((_DWORD)v7 + 8) & ~(_DWORD)v7)) & 0xFFFFFFF8) == 0xFFFFFFF8)
      {
        int v13 = *a2;
      }

      else
      {
        int v13 = *(_DWORD *)a2;
        if (v9 >= 4)
        {
          unsigned int v11 = v13 + 2;
          goto LABEL_8;
        }
      }

      unsigned int v11 = (v13 | (v12 << (8 * v9))) + 2;
    }

uint64_t getEnumTagSinglePayload for CollectionDifference.Change(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  unint64_t v3 = (*(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL)
  if (a2 < 0xFF)
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + v3 + 9);
    if (v8 >= 2) {
      return (v8 ^ 0xFF) + 1;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    else {
      unsigned int v4 = 2;
    }
    if (v4 >= 0x10000) {
      unsigned int v5 = 4;
    }
    else {
      unsigned int v5 = 2;
    }
    if (v4 < 0x100) {
      unsigned int v5 = 1;
    }
    if (v4 >= 2) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0LL;
    }
    return ((uint64_t (*)(void))((char *)&loc_1817256FC + 4 * byte_181800531[v6]))();
  }

void storeEnumTagSinglePayload for CollectionDifference.Change( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unint64_t v5 = (*(void *)(*(void *)(*(void *)(a4 + 16) - 8LL) + 64LL)
  unsigned int v6 = v5 + 10;
  if (a3 < 0xFF)
  {
    int v9 = 0u;
    if (a2 > 0xFE) {
      goto LABEL_14;
    }
  }

  else
  {
    if (v6 <= 3) {
      unsigned int v7 = ((a3 + 65281) >> (8 * (v5 + 10))) + 1;
    }
    else {
      unsigned int v7 = 2;
    }
    if (v7 >= 0x10000) {
      int v8 = 4;
    }
    else {
      int v8 = 2;
    }
    if (v7 < 0x100) {
      int v8 = 1;
    }
    if (v7 >= 2) {
      int v9 = v8;
    }
    else {
      int v9 = 0;
    }
    if (a2 > 0xFE)
    {
LABEL_14:
      unsigned int v10 = a2 - 255;
      bzero(a1, v5 + 10);
      if (v6 > 3) {
        *a1 = v10;
      }
      else {
        *(_WORD *)a1 = v10;
      }
      __asm { BR              X11 }
    }
  }

  __asm { BR              X11 }

void sub_181725874(char a1@<W8>)
{
  *(_BYTE *)(v1 + v2) = a1;
}

void sub_18172587C(uint64_t a1, int a2)
{
  *(_WORD *)(v2 + v3) = 0;
  if (a2) {
    JUMPOUT(0x181725884LL);
  }
}

void sub_181725890(int a1@<W1>, uint64_t a2@<X8>)
{
  *(_DWORD *)(v2 + v3) = 0;
  if (a1) {
    *(_BYTE *)(v2 + a2) = -(char)a1;
  }
}

void sub_18172589C(int a1@<W8>)
{
  *(_DWORD *)(v1 + v2) = a1;
}

uint64_t getEnumTag for CollectionDifference.Change(unsigned __int8 *a1, uint64_t a2)
{
  unint64_t v2 = ((*(void *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 64LL)
       + ((*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL) + 8LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL))
       + 7) & 0xFFFFFFFFFFFFFFF8LL)
     + 9;
  uint64_t v3 = a1[v2];
  int v4 = v3 - 2;
  if (v3 >= 2)
  {
    if (((*(_DWORD *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 64LL)
         + ((*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL) + 8) & ~*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL))
         + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      int v5 = *a1;
    }

    else
    {
      int v5 = *(_DWORD *)a1;
    }

    v5 |= v4 << (8 * v2);
    return (v5 + 2);
  }

  return v3;
}

void destructiveInjectEnumTag for CollectionDifference.Change(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL)
     + 7LL
     + ((*(unsigned __int8 *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 80LL) + 8LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 80LL));
  if (a2 > 1)
  {
    size_t v5 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 9;
    unsigned int v6 = ((a2 - 2) >> (8 * v5)) + 2;
    if (v5 < 4)
    {
      unsigned int v7 = (a2 - 2);
    }

    else
    {
      LOBYTE(v6) = 2;
      unsigned int v7 = a2 - 2;
    }

    a1[v5] = v6;
    bzero(a1, v5);
    if ((_DWORD)v5 == 1) {
      *a1 = v7;
    }
    else {
      *(_DWORD *)a1 = v7;
    }
  }

  else
  {
    a1[(v4 & 0xFFFFFFFFFFFFF8LL) + 9] = a2;
  }

uint64_t type metadata accessor for CollectionDifference.Index( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for CollectionDifference.Index);
}

unint64_t *type metadata completion function for CollectionOfOne(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v4, a1 + 24);
    return 0LL;
  }

  return result;
}

uint64_t type metadata completion function for CollectionOfOne.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = type metadata accessor for Optional((const char *)0x13F, *(void *)(a1 + 16), a3, a4);
  if (v6 <= 0x3F)
  {
    uint64_t v7 = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v7, a1 + 24);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for ClosedRange<>.Index( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  int v8 = *(_DWORD *)(v7 + 80);
  if (*(_DWORD *)(v7 + 84)) {
    size_t v9 = *(void *)(v7 + 64);
  }
  else {
    size_t v9 = *(void *)(v7 + 64) + 1LL;
  }
  if (*(_DWORD *)(v7 + 80) > 7u || (v8 & 0x100000) != 0 || v9 > 0x18)
  {
    unsigned int v12 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v12 + ((v8 + 16LL) & ~(unint64_t)v8));
    swift_retain(v12, (uint64_t)a2, a3, a4);
  }

  else if ((*(unsigned int (**)(unint64_t **, uint64_t, void))(v7 + 48))( a2,  1LL,  *(void *)(a3 + 16)))
  {
    memcpy(a1, a2, v9);
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **, uint64_t))(v7 + 16))(a1, a2, v6);
    (*(void (**)(unint64_t **, void, uint64_t, uint64_t))(v7 + 56))(a1, 0LL, 1LL, v6);
  }

  return a1;
}

uint64_t destroy for ClosedRange<>.Index(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v4 + 48))(a1, 1LL, v3);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 8))(a1, v3);
  }
  return result;
}

void *initializeWithCopy for ClosedRange<>.Index(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v6 + 48))(a2, 1LL, v5))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1LL;
    }
    memcpy(a1, a2, v7);
  }

  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0LL, 1LL, v5);
  }

  return a1;
}

void *assignWithCopy for ClosedRange<>.Index(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v6 + 48);
  int v8 = v7(a1, 1LL, v5);
  int v9 = v7(a2, 1LL, v5);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 16))(a1, a2, v5);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0LL, 1LL, v5);
      return a1;
    }
  }

  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 24))(a1, a2, v5);
      return a1;
    }

    (*(void (**)(void *, uint64_t))(v6 + 8))(a1, v5);
  }

  if (*(_DWORD *)(v6 + 84)) {
    size_t v10 = *(void *)(v6 + 64);
  }
  else {
    size_t v10 = *(void *)(v6 + 64) + 1LL;
  }
  memcpy(a1, a2, v10);
  return a1;
}

void *initializeWithTake for ClosedRange<>.Index(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v6 + 48))(a2, 1LL, v5))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1LL;
    }
    memcpy(a1, a2, v7);
  }

  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v6 + 32))(a1, a2, v5);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0LL, 1LL, v5);
  }

  return a1;
}

void *assignWithTake for ClosedRange<>.Index(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v6 + 48);
  int v8 = v7(a1, 1LL, v5);
  int v9 = v7(a2, 1LL, v5);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 32))(a1, a2, v5);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0LL, 1LL, v5);
      return a1;
    }
  }

  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 40))(a1, a2, v5);
      return a1;
    }

    (*(void (**)(void *, uint64_t))(v6 + 8))(a1, v5);
  }

  if (*(_DWORD *)(v6 + 84)) {
    size_t v10 = *(void *)(v6 + 64);
  }
  else {
    size_t v10 = *(void *)(v6 + 64) + 1LL;
  }
  memcpy(a1, a2, v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for ClosedRange<>.Index(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  unsigned int v6 = v5 - 1;
  if (!v5) {
    unsigned int v6 = 0;
  }
  uint64_t v7 = *(void *)(v4 + 64);
  if (!v5) {
    ++v7;
  }
  if (!a2) {
    return 0LL;
  }
  int v8 = a2 - v6;
  if (a2 > v6)
  {
    char v9 = 8 * v7;
    unsigned int v11 = ((v8 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)(a1 + v7);
      if (v10) {
        goto LABEL_15;
      }
    }

    else
    {
      if (v11 <= 0xFF)
      {
        if (v11 < 2) {
          goto LABEL_24;
        }
LABEL_8:
        int v10 = *(unsigned __int8 *)(a1 + v7);
        if (!*(_BYTE *)(a1 + v7)) {
          goto LABEL_24;
        }
LABEL_15:
        int v12 = (v10 - 1) << v9;
        if ((_DWORD)v7)
        {
          else {
            int v13 = 4;
          }
          __asm { BR              X12 }
        }

        return v6 + v12 + 1;
      }

      int v10 = *(unsigned __int16 *)(a1 + v7);
      if (*(_WORD *)(a1 + v7)) {
        goto LABEL_15;
      }
    }
  }

void storeEnumTagSinglePayload for ClosedRange<>.Index( _WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unsigned int v6 = 0u;
  uint64_t v7 = *(void *)(*(void *)(a4 + 16) - 8LL);
  int v8 = *(_DWORD *)(v7 + 84);
  unsigned int v9 = v8 - 1;
  if (v8)
  {
    size_t v10 = *(void *)(v7 + 64);
  }

  else
  {
    unsigned int v9 = 0;
    size_t v10 = *(void *)(v7 + 64) + 1LL;
  }

  BOOL v11 = a3 >= v9;
  unsigned int v12 = a3 - v9;
  if (v12 != 0 && v11)
  {
    if (v10 > 3)
    {
      unsigned int v6 = 1u;
      if (v9 < a2) {
        goto LABEL_14;
      }
      goto LABEL_21;
    }

    unsigned int v13 = ((v12 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
    if (HIWORD(v13))
    {
      unsigned int v6 = 4u;
      if (v9 < a2)
      {
LABEL_14:
        unsigned int v14 = ~v9 + a2;
        if (v10 < 4)
        {
          if ((_DWORD)v10)
          {
            int v15 = v14 & ~(-1 << (8 * v10));
            bzero(a1, v10);
            if ((_DWORD)v10 == 3)
            {
              *a1 = v15;
              *((_BYTE *)a1 + 2) = BYTE2(v15);
            }

            else if ((_DWORD)v10 == 2)
            {
              *a1 = v15;
            }

            else
            {
              *(_BYTE *)a1 = v15;
            }
          }
        }

        else
        {
          bzero(a1, v10);
          *(_DWORD *)a1 = v14;
        }

        __asm { BR              X10 }
      }

void sub_1817261C4()
{
  *(_BYTE *)(v0 + v1) = v2;
}

void sub_1817261CC()
{
  *(_WORD *)(v0 + v1) = v2;
}

uint64_t type metadata accessor for CollectionOfOne.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for CollectionOfOne.Iterator);
}

ValueMetadata *type metadata accessor for Duration()
{
  return &type metadata for Duration;
}

uint64_t dispatch thunk of static DurationProtocol./ infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of static DurationProtocol./= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static DurationProtocol.* infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of static DurationProtocol.*= infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

ValueMetadata *type metadata accessor for Int128()
{
  return &type metadata for Int128;
}

__n128 __swift_memcpy41_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Mirror()
{
  return &type metadata for Mirror;
}

void *destroy for Mirror.AncestorRepresentation(void *result)
{
  if (*result >= 0xFFFFFFFFuLL) {
    return (void *)swift_release(result[1]);
  }
  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for Mirror.AncestorRepresentation( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (*(void *)a2 < 0xFFFFFFFFuLL)
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
  }

  else
  {
    unsigned int v5 = *(unint64_t **)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(void *)(a1 + 8) = v5;
    swift_retain(v5, a2, a3, a4);
  }

  return a1;
}

unint64_t *assignWithCopy for Mirror.AncestorRepresentation( unint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *a2;
  if (*a1 < 0xFFFFFFFF)
  {
    if (v6 >= 0xFFFFFFFF)
    {
      unsigned int v9 = (unint64_t *)a2[1];
      *a1 = v6;
      a1[1] = (unint64_t)v9;
      swift_retain(v9, (uint64_t)a2, a3, a4);
      return a1;
    }

unint64_t *assignWithTake for Mirror.AncestorRepresentation( unint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  if (*a1 < 0xFFFFFFFF)
  {
    if (v4 >= 0xFFFFFFFF)
    {
      unint64_t v7 = a2[1];
      *a1 = v4;
      a1[1] = v7;
      return a1;
    }

uint64_t getEnumTagSinglePayload for Mirror.AncestorRepresentation(uint64_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0x7FFFFFFE && *((_BYTE *)a1 + 16)) {
    return (*(_DWORD *)a1 + 2147483646);
  }
  uint64_t v3 = *a1;
  unsigned int v4 = v3 + 1;
  unsigned int v5 = v3 - 1;
  if (v4 >= 3) {
    return v5;
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for Mirror.AncestorRepresentation( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFD)
  {
    *(void *)__n128 result = 0LL;
    *(void *)(result + 8) = 0LL;
    *(_DWORD *)__n128 result = a2 - 2147483646;
    if (a3 >= 0x7FFFFFFE) {
      *(_BYTE *)(result + 16) = 1;
    }
  }

  else
  {
    if (a3 >= 0x7FFFFFFE) {
      *(_BYTE *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)__n128 result = a2 + 1;
    }
  }

  return result;
}

uint64_t getEnumTag for Mirror.AncestorRepresentation(uint64_t *a1)
{
  uint64_t v1 = *a1;
  return (v1 + 1);
}

void *destructiveInjectEnumTag for Mirror.AncestorRepresentation(void *result, int a2)
{
  if (a2 < 0)
  {
    uint64_t v2 = a2 ^ 0x80000000;
    result[1] = 0LL;
  }

  else
  {
    if (!a2) {
      return result;
    }
    uint64_t v2 = (a2 - 1);
  }

  *__n128 result = v2;
  return result;
}

ValueMetadata *type metadata accessor for Mirror.AncestorRepresentation()
{
  return &type metadata for Mirror.AncestorRepresentation;
}

uint64_t getEnumTagSinglePayload for Mirror.DisplayStyle(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF9) {
    goto LABEL_17;
  }
  if (a2 + 7 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 7) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 7;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }

uint64_t storeEnumTagSinglePayload for Mirror.DisplayStyle(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 7 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 7) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xF9) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF8) {
    return ((uint64_t (*)(void))((char *)&loc_1817265C8 + 4 * byte_181800553[v4]))();
  }
  *a1 = a2 + 7;
  return ((uint64_t (*)(void))((char *)sub_1817265FC + 4 * byte_18180054E[v4]))();
}

uint64_t sub_1817265FC(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_181726604(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x18172660CLL);
  }
  return result;
}

uint64_t sub_181726618(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x181726620LL);
  }
  *(_BYTE *)__n128 result = a2 + 7;
  return result;
}

uint64_t sub_181726624(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18172662C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for Mirror.DisplayStyle()
{
  return &type metadata for Mirror.DisplayStyle;
}

uint64_t dispatch thunk of CustomReflectable.customMirror.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of CustomPlaygroundDisplayConvertible.playgroundDescription.getter( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

ValueMetadata *type metadata accessor for CommandLine()
{
  return &type metadata for CommandLine;
}

uint64_t initializeWithCopy for ArraySlice(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unsigned int v5 = *(void **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_unknownObjectRetain(v5, a2, a3, a4);
  return a1;
}

uint64_t assignWithCopy for ArraySlice(uint64_t a1, void **a2, uint64_t a3, char *a4)
{
  unsigned int v6 = *a2;
  BOOL v7 = *(void **)a1;
  *(void *)a1 = *a2;
  swift_unknownObjectRetain(v6, (uint64_t)a2, a3, a4);
  swift_unknownObjectRelease(v7);
  *(void *)(a1 + 8) = a2[1];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = a2[3];
  return a1;
}

uint64_t getEnumTagSinglePayload for ArraySlice(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for ArraySlice(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 32) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for StaticBigInt()
{
  return &type metadata for StaticBigInt;
}

ValueMetadata *type metadata accessor for UInt128()
{
  return &type metadata for UInt128;
}

ValueMetadata *type metadata accessor for UInt128.Words()
{
  return &type metadata for UInt128.Words;
}

unint64_t *type metadata completion function for UnfoldSequence(uint64_t a1)
{
  __n128 result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 24));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 1) + 64;
    v4[1] = &unk_189B8CBB8;
    void v4[2] = &unk_181808918;
    swift_initStructMetadata(a1, 0, 3uLL, (char *)v4, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for UnfoldSequence( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  unsigned int v5 = a1;
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  int v9 = *(_DWORD *)(v7 + 80);
  if ((v9 & 0x1000F8) != 0 || ((v8 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 17 > 0x18)
  {
    unsigned int v13 = *a2;
    *unsigned int v5 = *a2;
    unsigned int v5 = (unint64_t **)((char *)v13
                             + ((unsigned __int16)((v9 & 0xF8) + 23) & (unsigned __int16)~(v9 & 0xF8) & 0x1F8));
  }

  else
  {
    (*(void (**)(unint64_t **, unint64_t **))(v7 + 16))(a1, a2);
    unint64_t v11 = ((unint64_t)v5 + v8 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v12 = ((unint64_t)a2 + v8 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    unsigned int v13 = *(unint64_t **)(v12 + 8);
    *(void *)unint64_t v11 = *(void *)v12;
    *(void *)(v11 + 8) = v13;
    *(_BYTE *)(v11 + 16) = *(_BYTE *)(v12 + 16);
  }

  swift_retain(v13, (uint64_t)a2, v6, a4);
  return v5;
}

uint64_t destroy for UnfoldSequence(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 24) - 8LL);
  (*(void (**)(void))(v3 + 8))();
  return swift_release(*(void *)(((a1 + *(void *)(v3 + 64) + 7) & 0xFFFFFFFFFFFFF8LL) + 8));
}

uint64_t initializeWithCopy for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(void))(v5 + 16))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8LL;
  int v9 = *(unint64_t **)(v8 + 8);
  *(void *)unint64_t v7 = *(void *)v8;
  *(void *)(v7 + 8) = v9;
  *(_BYTE *)(v7 + 16) = *(_BYTE *)(v8 + 16);
  swift_retain(v9, v10, v11, v12);
  return a1;
}

uint64_t assignWithCopy for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(void))(v5 + 24))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8LL;
  int v9 = *(unint64_t **)(v8 + 8);
  uint64_t v10 = *(void *)(v7 + 8);
  *(void *)unint64_t v7 = *(void *)v8;
  *(void *)(v7 + 8) = v9;
  swift_retain(v9, v11, v12, v13);
  swift_release(v10);
  *(_BYTE *)(v7 + 16) = *(_BYTE *)(v8 + 16);
  return a1;
}

uint64_t initializeWithTake for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(void))(v5 + 32))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8LL;
  *(_OWORD *)unint64_t v7 = *(_OWORD *)v8;
  *(_BYTE *)(v7 + 16) = *(_BYTE *)(v8 + 16);
  return a1;
}

uint64_t assignWithTake for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(void))(v5 + 40))();
  uint64_t v6 = *(void *)(v5 + 64) + 7LL;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v9 = *(void *)(v7 + 8);
  *(_OWORD *)unint64_t v7 = *(_OWORD *)v8;
  swift_release(v9);
  *(_BYTE *)(v7 + 16) = *(_BYTE *)(v8 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for UnfoldSequence(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 24) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(v4 + 64);
  if (v6 >= a2)
  {
    if (v5 < 0x7FFFFFFF)
    {
      unint64_t v14 = *(void *)((a1 + v7 + 7) & 0xFFFFFFFFFFFFF8LL);
      if (v14 >= 0xFFFFFFFF) {
        LODWORD(v14) = -1;
      }
      return (v14 + 1);
    }

    else
    {
      return (*(uint64_t (**)(void))(v4 + 48))();
    }
  }

  else
  {
    unsigned int v8 = ((v7 + 7) & 0xFFFFFFF8) + 17;
    unsigned int v9 = (a2 - v6 + 255) >> (8 * v8);
    if (v8 < 4) {
      unsigned int v10 = v9 + 1;
    }
    else {
      unsigned int v10 = 2;
    }
    if (v10 >= 0x10000) {
      unsigned int v11 = 4;
    }
    else {
      unsigned int v11 = 2;
    }
    if (v10 < 0x100) {
      unsigned int v11 = 1;
    }
    if (v10 >= 2) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0LL;
    }
    return ((uint64_t (*)(void))((char *)&loc_181726B70 + 4 * byte_181800558[v12]))();
  }

void storeEnumTagSinglePayload for UnfoldSequence(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 24) - 8LL);
  if (*(_DWORD *)(v5 + 84) <= 0x7FFFFFFFu) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v5 + 84);
  }
  size_t v7 = ((*(void *)(v5 + 64) + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 17;
  if (v6 >= a3)
  {
    int v10 = 0u;
    if (v6 >= a2) {
      goto LABEL_17;
    }
  }

  else
  {
    else {
      unsigned int v8 = 2;
    }
    if (v8 >= 0x10000) {
      int v9 = 4;
    }
    else {
      int v9 = 2;
    }
    if (v8 < 0x100) {
      int v9 = 1;
    }
    if (v8 >= 2) {
      int v10 = v9;
    }
    else {
      int v10 = 0;
    }
    if (v6 >= a2) {
LABEL_17:
    }
      __asm { BR              X12 }
  }

  else {
    unsigned int v11 = (~(_BYTE)v6 + a2);
  }
  bzero(a1, v7);
  if ((_DWORD)v7 == 1) {
    *a1 = v11;
  }
  else {
    *(_DWORD *)a1 = v11;
  }
  __asm { BR              X10 }

void sub_181726D20()
{
  *(_BYTE *)(v0 + v1) = v2;
  JUMPOUT(0x181726D98LL);
}

void sub_181726D28(uint64_t a1, int a2)
{
  *(_DWORD *)(v2 + v3) = 0;
  if (a2) {
    JUMPOUT(0x181726D30LL);
  }
  JUMPOUT(0x181726D98LL);
}

void sub_181726D70()
{
  *(_WORD *)(v0 + v1) = v2;
  JUMPOUT(0x181726D98LL);
}

void sub_181726D78()
{
  *(_DWORD *)(v0 + v1) = v2;
  JUMPOUT(0x181726D98LL);
}

uint64_t sub_181726D80(uint64_t a1, int a2, unsigned int a3)
{
  *(_WORD *)(v5 + v6) = 0;
  if (!a2) {
    JUMPOUT(0x181726D98LL);
  }
  if (a3 < 0x7FFFFFFF)
  {
    if ((a2 & 0x80000000) == 0) {
      JUMPOUT(0x181726D94LL);
    }
    JUMPOUT(0x181726D8CLL);
  }

  return (*(uint64_t (**)(uint64_t))(v4 + 56))(v5);
}

uint64_t method lookup function for __VaListBuilder(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __VaListBuilder);
}

uint64_t dispatch thunk of __VaListBuilder.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

unint64_t type metadata completion function for Zip2Sequence.Iterator(uint64_t a1)
{
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 32),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v5[0] = *(void *)(result - 8) + 64LL;
    unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 40),  *(void *)(a1 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    if (v4 <= 0x3F)
    {
      v5[1] = *(void *)(result - 8) + 64LL;
      unint64_t v5[2] = &unk_181808918;
      swift_initStructMetadata(a1, 0, 3uLL, (char *)v5, a1 + 48);
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for Zip2Sequence.Iterator( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 40),  *(void *)(a3 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v13 = *(void *)(v9 - 8);
  uint64_t v14 = *(_DWORD *)(v13 + 80);
  uint64_t v15 = v8 + v14;
  uint64_t v16 = *(void *)(v13 + 64);
  uint64_t v17 = (*(_BYTE *)(v7 + 80) | *(_BYTE *)(v13 + 80));
  if (v17 > 7
    || ((*(_DWORD *)(v7 + 80) | *(_DWORD *)(v13 + 80)) & 0x100000) != 0
    || v16 + (v15 & (unint64_t)~v14) + 1 > 0x18)
  {
    char v20 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v20 + ((v17 + 16) & ~v17));
    swift_retain(v20, v10, v11, v12);
  }

  else
  {
    unint64_t v21 = v9;
    uint64_t v22 = ~v14;
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v7 + 16))( a1,  a2,  AssociatedTypeWitness);
    unint64_t v23 = ((unint64_t)a2 + v15) & v22;
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v13 + 16))( ((unint64_t)a1 + v15) & v22,  v23,  v21);
    *(_BYTE *)((((unint64_t)a1 + v15) & v22) + v16) = *(_BYTE *)(v23 + v16);
  }

  return a1;
}

uint64_t destroy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 32),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v5 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v5 + 8))(a1, AssociatedTypeWitness);
  uint64_t v6 = *(void *)(v5 + 64) + a1;
  unint64_t v7 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 40),  *(void *)(a2 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)(v7 - 8) + 8LL))( (v6 + *(unsigned __int8 *)(*(void *)(v7 - 8) + 80LL)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v7 - 8) + 80LL),  v7);
}

uint64_t initializeWithCopy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 16))(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 40),  *(void *)(a3 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 16))(v12, v13, v9);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t assignWithCopy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 24))(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 40),  *(void *)(a3 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 24))(v12, v13, v9);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t initializeWithTake for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 32))(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 40),  *(void *)(a3 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 32))(v12, v13, v9);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t assignWithTake for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 40))(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 40),  *(void *)(a3 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v8 + v11 + a1) & ~v11;
  uint64_t v13 = (v8 + v11 + a2) & ~v11;
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 40))(v12, v13, v9);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t getEnumTagSinglePayload for Zip2Sequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 32),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = *(unsigned int *)(v7 + 84);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 40),  *(void *)(a3 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = *(unsigned int *)(v10 + 84);
  else {
    unsigned int v12 = *(_DWORD *)(v10 + 84);
  }
  if (v12 <= 0xFE) {
    unsigned int v12 = 254;
  }
  if (!a2) {
    return 0LL;
  }
  unint64_t v13 = v9;
  uint64_t v14 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v15 = *(void *)(v7 + 64) + v14;
  uint64_t v16 = *(void *)(v10 + 64);
  if (a2 <= v12) {
    goto LABEL_25;
  }
  uint64_t v17 = v16 + (v15 & ~v14) + 1;
  char v18 = 8 * v17;
  unsigned int v20 = ((a2 - v12 + ~(-1 << v18)) >> v18) + 1;
  if (HIWORD(v20))
  {
    int v19 = *(_DWORD *)(a1 + v17);
    if (v19) {
      goto LABEL_16;
    }
  }

  else
  {
    if (v20 <= 0xFF)
    {
      if (v20 < 2) {
        goto LABEL_25;
      }
LABEL_9:
      int v19 = *(unsigned __int8 *)(a1 + v17);
      if (!*(_BYTE *)(a1 + v17)) {
        goto LABEL_25;
      }
LABEL_16:
      int v21 = (v19 - 1) << v18;
      if ((_DWORD)v16 + (v15 & ~(_DWORD)v14) != -1)
      {
        else {
          int v22 = 4;
        }
        __asm { BR              X12 }
      }

      int v27 = v12 + v21;
      return (v27 + 1);
    }

    int v19 = *(unsigned __int16 *)(a1 + v17);
    if (*(_WORD *)(a1 + v17)) {
      goto LABEL_16;
    }
  }

void storeEnumTagSinglePayload for Zip2Sequence.Iterator( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 32),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 40),  *(void *)(a4 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator)
                  - 8);
  if (*(_DWORD *)(v10 + 84) <= v9) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v10 + 84);
  }
  if (v11 <= 0xFE) {
    unsigned int v12 = 254;
  }
  else {
    unsigned int v12 = v11;
  }
  size_t v13 = *(void *)(v10 + 64)
  if (a3 <= v12)
  {
    unsigned int v14 = 0u;
  }

  else if (v13 <= 3)
  {
    unsigned int v16 = ((a3 - v12 + ~(-1 << (8 * v13))) >> (8 * v13)) + 1;
    if (HIWORD(v16))
    {
      unsigned int v14 = 4u;
    }

    else if (v16 >= 0x100)
    {
      unsigned int v14 = 2;
    }

    else
    {
      unsigned int v14 = v16 > 1;
    }
  }

  else
  {
    unsigned int v14 = 1u;
  }

  if (v12 < a2)
  {
    int v15 = ~v12 + a2;
    if (v13 < 4)
    {
      if (*(_DWORD *)(v10 + 64)
         + ((*(_DWORD *)(v8 + 64) + *(unsigned __int8 *)(v10 + 80)) & ~*(unsigned __int8 *)(v10 + 80)) != -1)
      {
        int v17 = v15 & ~(-1 << (8 * v13));
        bzero(a1, v13);
        if ((_DWORD)v13 == 3)
        {
          *(_WORD *)a1 = v17;
          a1[2] = BYTE2(v17);
        }

        else if ((_DWORD)v13 == 2)
        {
          *(_WORD *)a1 = v17;
        }

        else
        {
          *a1 = v17;
        }
      }
    }

    else
    {
      bzero(a1, v13);
      *(_DWORD *)a1 = v15;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X15 }

uint64_t dispatch thunk of SIMDStorage.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of SIMDStorage.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t dispatch thunk of SIMDStorage.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t dispatch thunk of SIMDStorage.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

uint64_t type metadata accessor for _stdlib_AtomicInt()
{
  return objc_opt_self();
}

uint64_t method lookup function for _stdlib_AtomicInt(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _stdlib_AtomicInt);
}

uint64_t dispatch thunk of _stdlib_AtomicInt.__allocating_init(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

ValueMetadata *type metadata accessor for Float16()
{
  return &type metadata for Float16;
}

ValueMetadata *type metadata accessor for Float()
{
  return &type metadata for Float;
}

ValueMetadata *type metadata accessor for Double()
{
  return &type metadata for Double;
}

ValueMetadata *type metadata accessor for Float80()
{
  return &type metadata for Float80;
}

ValueMetadata *type metadata accessor for UInt8()
{
  return &type metadata for UInt8;
}

ValueMetadata *type metadata accessor for UInt8.Words()
{
  return &type metadata for UInt8.Words;
}

ValueMetadata *type metadata accessor for Int8()
{
  return &type metadata for Int8;
}

ValueMetadata *type metadata accessor for Int8.Words()
{
  return &type metadata for Int8.Words;
}

ValueMetadata *type metadata accessor for UInt16()
{
  return &type metadata for UInt16;
}

ValueMetadata *type metadata accessor for UInt16.Words()
{
  return &type metadata for UInt16.Words;
}

ValueMetadata *type metadata accessor for Int16()
{
  return &type metadata for Int16;
}

ValueMetadata *type metadata accessor for Int16.Words()
{
  return &type metadata for Int16.Words;
}

ValueMetadata *type metadata accessor for UInt32()
{
  return &type metadata for UInt32;
}

ValueMetadata *type metadata accessor for UInt32.Words()
{
  return &type metadata for UInt32.Words;
}

ValueMetadata *type metadata accessor for Int32()
{
  return &type metadata for Int32;
}

ValueMetadata *type metadata accessor for Int32.Words()
{
  return &type metadata for Int32.Words;
}

ValueMetadata *type metadata accessor for UInt64()
{
  return &type metadata for UInt64;
}

ValueMetadata *type metadata accessor for UInt64.Words()
{
  return &type metadata for UInt64.Words;
}

ValueMetadata *type metadata accessor for Int64()
{
  return &type metadata for Int64;
}

ValueMetadata *type metadata accessor for Int64.Words()
{
  return &type metadata for Int64.Words;
}

ValueMetadata *type metadata accessor for UInt()
{
  return &type metadata for UInt;
}

ValueMetadata *type metadata accessor for UInt.Words()
{
  return &type metadata for UInt.Words;
}

ValueMetadata *type metadata accessor for Int()
{
  return &type metadata for Int;
}

ValueMetadata *type metadata accessor for Int.Words()
{
  return &type metadata for Int.Words;
}

uint64_t getEnumTagSinglePayload for UnsafeBufferPointer.Iterator(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for UnsafeBufferPointer.Iterator(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)unint64_t result = (a2 - 1);
    *(void *)(result + 8) = 0LL;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for UnsafeMutableRawBufferPointer()
{
  return &type metadata for UnsafeMutableRawBufferPointer;
}

ValueMetadata *type metadata accessor for UnsafeRawBufferPointer()
{
  return &type metadata for UnsafeRawBufferPointer;
}

ValueMetadata *type metadata accessor for UnsafeRawBufferPointer.Iterator()
{
  return &type metadata for UnsafeRawBufferPointer.Iterator;
}

unint64_t type metadata completion function for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

unint64_t **initializeBufferWithCopyOfBuffer for SIMD2( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t destroy for SIMD2(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t initializeWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t assignWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t initializeWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t assignWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t getEnumTagSinglePayload for SIMD2(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
}

void storeEnumTagSinglePayload for SIMD2(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

unint64_t type metadata completion function for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

unint64_t **initializeBufferWithCopyOfBuffer for SIMD4( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t destroy for SIMD4(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t initializeWithCopy for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t assignWithCopy for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t initializeWithTake for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t assignWithTake for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t getEnumTagSinglePayload for SIMD4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
}

void storeEnumTagSinglePayload for SIMD4(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

unint64_t type metadata completion function for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

unint64_t **initializeBufferWithCopyOfBuffer for SIMD8( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t destroy for SIMD8(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t initializeWithCopy for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t assignWithCopy for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t initializeWithTake for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t assignWithTake for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t getEnumTagSinglePayload for SIMD8(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
}

void storeEnumTagSinglePayload for SIMD8(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

unint64_t type metadata completion function for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

unint64_t **initializeBufferWithCopyOfBuffer for SIMD16( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t destroy for SIMD16(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t initializeWithCopy for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t assignWithCopy for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t initializeWithTake for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t assignWithTake for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t getEnumTagSinglePayload for SIMD16(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
}

void storeEnumTagSinglePayload for SIMD16(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

unint64_t type metadata completion function for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

unint64_t **initializeBufferWithCopyOfBuffer for SIMD32( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t destroy for SIMD32(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t initializeWithCopy for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t assignWithCopy for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t initializeWithTake for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t assignWithTake for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t getEnumTagSinglePayload for SIMD32(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
}

void storeEnumTagSinglePayload for SIMD32(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

unint64_t type metadata completion function for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

unint64_t **initializeBufferWithCopyOfBuffer for SIMD64( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t destroy for SIMD64(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t initializeWithCopy for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t assignWithCopy for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t initializeWithTake for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t assignWithTake for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t getEnumTagSinglePayload for SIMD64(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
}

void storeEnumTagSinglePayload for SIMD64(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

ValueMetadata *type metadata accessor for UInt8.SIMD2Storage()
{
  return &type metadata for UInt8.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt8.SIMD4Storage()
{
  return &type metadata for UInt8.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt8.SIMD8Storage()
{
  return &type metadata for UInt8.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt8.SIMD16Storage()
{
  return &type metadata for UInt8.SIMD16Storage;
}

__n128 __swift_memcpy32_16(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

ValueMetadata *type metadata accessor for UInt8.SIMD32Storage()
{
  return &type metadata for UInt8.SIMD32Storage;
}

__n128 __swift_memcpy64_16(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for UInt8.SIMD64Storage()
{
  return &type metadata for UInt8.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD2Storage()
{
  return &type metadata for Int8.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD4Storage()
{
  return &type metadata for Int8.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD8Storage()
{
  return &type metadata for Int8.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD16Storage()
{
  return &type metadata for Int8.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD32Storage()
{
  return &type metadata for Int8.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD64Storage()
{
  return &type metadata for Int8.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD2Storage()
{
  return &type metadata for UInt16.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD4Storage()
{
  return &type metadata for UInt16.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD8Storage()
{
  return &type metadata for UInt16.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD16Storage()
{
  return &type metadata for UInt16.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD32Storage()
{
  return &type metadata for UInt16.SIMD32Storage;
}

__n128 __swift_memcpy128_16(uint64_t a1, __int128 *a2)
{
  __int128 v2 = *a2;
  __int128 v3 = a2[1];
  __int128 v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __n128 result = (__n128)a2[4];
  __int128 v6 = a2[5];
  __int128 v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(__n128 *)(a1 + 64) = result;
  *(_OWORD *)(a1 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v6;
  return result;
}

ValueMetadata *type metadata accessor for UInt16.SIMD64Storage()
{
  return &type metadata for UInt16.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD2Storage()
{
  return &type metadata for Int16.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD4Storage()
{
  return &type metadata for Int16.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD8Storage()
{
  return &type metadata for Int16.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD16Storage()
{
  return &type metadata for Int16.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD32Storage()
{
  return &type metadata for Int16.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD64Storage()
{
  return &type metadata for Int16.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD2Storage()
{
  return &type metadata for UInt32.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD4Storage()
{
  return &type metadata for UInt32.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD8Storage()
{
  return &type metadata for UInt32.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD16Storage()
{
  return &type metadata for UInt32.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD32Storage()
{
  return &type metadata for UInt32.SIMD32Storage;
}

__n128 __swift_memcpy256_16(uint64_t a1, __int128 *a2)
{
  __int128 v2 = *a2;
  __int128 v3 = a2[1];
  __int128 v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __int128 v5 = a2[4];
  __int128 v6 = a2[5];
  __int128 v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v6;
  __int128 v8 = a2[8];
  __int128 v9 = a2[9];
  __int128 v10 = a2[11];
  *(_OWORD *)(a1 + 16_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = a2[10];
  *(_OWORD *)(a1 + 176) = v10;
  *(_OWORD *)(a1 + 128) = v8;
  *(_OWORD *)(a1 + 144) = v9;
  __n128 result = (__n128)a2[12];
  __int128 v12 = a2[13];
  __int128 v13 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v13;
  *(__n128 *)(a1 + 192) = result;
  *(_OWORD *)(a1 + 208) = v12;
  return result;
}

ValueMetadata *type metadata accessor for UInt32.SIMD64Storage()
{
  return &type metadata for UInt32.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD2Storage()
{
  return &type metadata for Int32.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD4Storage()
{
  return &type metadata for Int32.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD8Storage()
{
  return &type metadata for Int32.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD16Storage()
{
  return &type metadata for Int32.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD32Storage()
{
  return &type metadata for Int32.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD64Storage()
{
  return &type metadata for Int32.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD2Storage()
{
  return &type metadata for UInt64.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD4Storage()
{
  return &type metadata for UInt64.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD8Storage()
{
  return &type metadata for UInt64.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD16Storage()
{
  return &type metadata for UInt64.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD32Storage()
{
  return &type metadata for UInt64.SIMD32Storage;
}

void *__swift_memcpy512_16(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x200uLL);
}

ValueMetadata *type metadata accessor for UInt64.SIMD64Storage()
{
  return &type metadata for UInt64.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD2Storage()
{
  return &type metadata for Int64.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD4Storage()
{
  return &type metadata for Int64.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD8Storage()
{
  return &type metadata for Int64.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD16Storage()
{
  return &type metadata for Int64.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD32Storage()
{
  return &type metadata for Int64.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD64Storage()
{
  return &type metadata for Int64.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD2Storage()
{
  return &type metadata for UInt.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD4Storage()
{
  return &type metadata for UInt.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD8Storage()
{
  return &type metadata for UInt.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD16Storage()
{
  return &type metadata for UInt.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD32Storage()
{
  return &type metadata for UInt.SIMD32Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD64Storage()
{
  return &type metadata for UInt.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD2Storage()
{
  return &type metadata for Int.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD4Storage()
{
  return &type metadata for Int.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD8Storage()
{
  return &type metadata for Int.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD16Storage()
{
  return &type metadata for Int.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD32Storage()
{
  return &type metadata for Int.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD64Storage()
{
  return &type metadata for Int.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD2Storage()
{
  return &type metadata for Float16.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD4Storage()
{
  return &type metadata for Float16.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD8Storage()
{
  return &type metadata for Float16.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD16Storage()
{
  return &type metadata for Float16.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD32Storage()
{
  return &type metadata for Float16.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD64Storage()
{
  return &type metadata for Float16.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD2Storage()
{
  return &type metadata for Float.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD4Storage()
{
  return &type metadata for Float.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD8Storage()
{
  return &type metadata for Float.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD16Storage()
{
  return &type metadata for Float.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD32Storage()
{
  return &type metadata for Float.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD64Storage()
{
  return &type metadata for Float.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Double.SIMD2Storage()
{
  return &type metadata for Double.SIMD2Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD4Storage(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD4Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + 8) = 0LL;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 32) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD4Storage()
{
  return &type metadata for Double.SIMD4Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD8Storage(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

ValueMetadata *type metadata accessor for Double.SIMD8Storage()
{
  return &type metadata for Double.SIMD8Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD16Storage(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 128)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD16Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 12_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0LL;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 128) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD16Storage()
{
  return &type metadata for Double.SIMD16Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD32Storage(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 256)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD32Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 248) = 0LL;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 20_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 12_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 256) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD32Storage()
{
  return &type metadata for Double.SIMD32Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD64Storage(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 512)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD64Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 504) = 0LL;
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 20_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 12_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 488) = 0u;
    *(_OWORD *)(result + 472) = 0u;
    *(_OWORD *)(result + 456) = 0u;
    *(_OWORD *)(result + 44_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 424) = 0u;
    *(_OWORD *)(result + 408) = 0u;
    *(_OWORD *)(result + 392) = 0u;
    *(_OWORD *)(result + 376) = 0u;
    *(_OWORD *)(result + 36_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 344) = 0u;
    *(_OWORD *)(result + 328) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 28_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 512) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD64Storage()
{
  return &type metadata for Double.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Mirror._DefaultDescendantRepresentation()
{
  return &type metadata for Mirror._DefaultDescendantRepresentation;
}

_DWORD *__swift_memcpy4_1(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for _GraphemeBreakingState(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && a1[4]) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *a1;
  BOOL v4 = v3 >= 2;
  int v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for _GraphemeBreakingState( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_DWORD *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 4) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 4) = 0;
    }
    if (a2) {
      *(_BYTE *)__n128 result = a2 + 1;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for _GraphemeBreakingState()
{
  return &type metadata for _GraphemeBreakingState;
}

uint64_t type metadata accessor for Unicode._InternalNFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Unicode._InternalNFC);
}

uint64_t type metadata completion function for Unicode._InternalNFC.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = &unk_18180B080;
  v7[1] = &unk_18180B098;
  uint64_t result = type metadata accessor for Unicode._InternalNFD.Iterator( 319LL,  *(void *)(a1 + 16),  *(void *)(a1 + 24),  a4);
  if (v6 <= 0x3F)
  {
    void v7[2] = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0, 3uLL, (char *)v7, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t initializeBufferWithCopyOfBuffer for Unicode._InternalNFC.Iterator( unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  uint64_t v11 = ~(v10 | 7);
  uint64_t v12 = v10 + 24;
  unint64_t v13 = ((v10 + 24) & ~v10) + *(void *)(v9 + 64) + (((v10 | 7) + 17) & v11);
  int v14 = *(_DWORD *)(v9 + 80) & 0x100000;
  int v15 = *(unint64_t **)a2;
  *(void *)a1 = *(void *)a2;
  if (v10 > 7 || v14 != 0 || v13 > 0x18)
  {
    a1 = (unint64_t)v15 + ((v10 + 16) & v11);
    swift_retain(v15, v5, v6, v7);
  }

  else
  {
    uint64_t v18 = ~v10;
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
    unint64_t v19 = a1 & 0xFFFFFFFFFFFFFFFCLL;
    int v20 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 12);
    *(_BYTE *)(v19 + 16) = *(_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 16);
    *(_DWORD *)(v19 + 12) = v20;
    uint64_t v21 = (a1 + 24) & v11;
    uint64_t v22 = (a2 + 24) & v11;
    unint64_t v23 = *(void *)v22;
    *(void *)uint64_t v21 = *(void *)v22;
    *(_BYTE *)(v21 + 8) = *(_BYTE *)(v22 + 8);
    *(void *)(v21 + 16) = *(void *)(v22 + 16);
    uint64_t v24 = (v12 + v21) & v18;
    uint64_t v25 = (v12 + v22) & v18;
    unsigned int v26 = *(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16);
    swift_bridgeObjectRetain((unint64_t)v15, v5, v6, v7);
    swift_bridgeObjectRetain(v23, v27, v28, v29);
    v26(v24, v25, AssociatedTypeWitness);
  }

  return a1;
}

uint64_t destroy for Unicode._InternalNFC.Iterator(uint64_t *a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v5 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 80);
  __int128 v7 = (uint64_t *)((((unint64_t)a1 & 0xFFFFFFFFFFFFFFFCLL) + (v6 | 7) + 17) & ~(v6 | 7));
  swift_bridgeObjectRelease(*v7);
  return (*(uint64_t (**)(unint64_t, unint64_t))(v5 + 8))( ((unint64_t)v7 + v6 + 24) & ~v6,  AssociatedTypeWitness);
}

uint64_t initializeWithCopy for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  unint64_t v5 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFFCLL;
  int v7 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 12);
  *(_BYTE *)(v5 + 16) = *(_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 16);
  *(_DWORD *)(v5 + 12) = v7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = (v10 | 7) + 17;
  uint64_t v12 = (v11 + v5) & ~(v10 | 7);
  uint64_t v13 = (v11 + v6) & ~(v10 | 7);
  unint64_t v14 = *(void *)v13;
  *(void *)uint64_t v12 = *(void *)v13;
  *(_BYTE *)(v12 + 8) = *(_BYTE *)(v13 + 8);
  *(void *)(v12 + 16) = *(void *)(v13 + 0x10);
  uint64_t v15 = (v10 + 24 + v12) & ~v10;
  uint64_t v16 = (v10 + 24 + v13) & ~v10;
  int v17 = *(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16);
  swift_bridgeObjectRetain(v4, v18, v19, v20);
  swift_bridgeObjectRetain(v14, v21, v22, v23);
  v17(v15, v16, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFC.Iterator( uint64_t a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v5 = (unint64_t)a2;
  unint64_t v7 = *a2;
  uint64_t v8 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRetain(v7, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v8);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(v5 + 8);
  unint64_t v9 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  v5 &= 0xFFFFFFFFFFFFFFFCLL;
  int v10 = *(_DWORD *)(v5 + 12);
  *(_BYTE *)(v9 + 16) = *(_BYTE *)(v5 + 16);
  *(_DWORD *)(v9 + 12) = v10;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = *(unsigned __int8 *)(v12 + 80);
  uint64_t v14 = (v13 | 7) + 17;
  unint64_t v15 = (v14 + (a1 & 0xFFFFFFFFFFFFFFFCLL)) & ~(v13 | 7);
  uint64_t v16 = (v14 + v5) & ~(v13 | 7);
  unint64_t v17 = *(void *)v16;
  uint64_t v18 = *(void *)v15;
  *(void *)unint64_t v15 = *(void *)v16;
  swift_bridgeObjectRetain(v17, v19, v20, v21);
  swift_bridgeObjectRelease(v18);
  *(_BYTE *)(v15 + 8) = *(_BYTE *)(v16 + 8);
  *(void *)(v15 + 16) = *(void *)(v16 + 16);
  (*(void (**)(unint64_t, uint64_t, unint64_t))(v12 + 24))( (v13 + 24 + v15) & ~v13,  (v13 + 24 + v16) & ~v13,  AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = *(void *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  unint64_t v4 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v5 = a2 & 0xFFFFFFFFFFFFFFFCLL;
  int v6 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 12);
  *(_BYTE *)(v4 + 16) = *(_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 16);
  *(_DWORD *)(v4 + 12) = v6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v10 = (v9 | 7) + 17;
  uint64_t v11 = (v10 + v4) & ~(v9 | 7);
  uint64_t v12 = (v10 + v5) & ~(v9 | 7);
  LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(_BYTE *)(v12 + 8);
  *(void *)uint64_t v11 = *(void *)v12;
  *(_BYTE *)(v11 + 8) = v10;
  *(void *)(v11 + 16) = *(void *)(v12 + 16);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 32))( (v9 + 24 + v11) & ~v9,  (v9 + 24 + v12) & ~v9,  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFC.Iterator(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v4 = (unint64_t)a2;
  uint64_t v6 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRelease(v6);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(v4 + 8);
  unint64_t v7 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  v4 &= 0xFFFFFFFFFFFFFFFCLL;
  int v8 = *(_DWORD *)(v4 + 12);
  *(_BYTE *)(v7 + 16) = *(_BYTE *)(v4 + 16);
  *(_DWORD *)(v7 + 12) = v8;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v11 | 7) + 17;
  unint64_t v13 = (v12 + (a1 & 0xFFFFFFFFFFFFFFFCLL)) & ~(v11 | 7);
  uint64_t v14 = (v12 + v4) & ~(v11 | 7);
  uint64_t v15 = *(void *)v13;
  *(void *)unint64_t v13 = *(void *)v14;
  swift_bridgeObjectRelease(v15);
  *(_BYTE *)(v13 + 8) = *(_BYTE *)(v14 + 8);
  *(void *)(v13 + 16) = *(void *)(v14 + 16);
  (*(void (**)(unint64_t, uint64_t, unint64_t))(v10 + 40))( (v11 + 24 + v13) & ~v11,  (v11 + 24 + v14) & ~v11,  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFC.Iterator( unint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView)
                 - 8);
  int v6 = *(_DWORD *)(v5 + 84);
  else {
    int v7 = *(_DWORD *)(v5 + 84);
  }
  if (v6 >= 0) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = v7;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v9 = *(unsigned __int8 *)(v5 + 80);
  uint64_t v10 = v9 | 7;
  uint64_t v11 = v9 + 24;
  if (a2 <= v8) {
    goto LABEL_27;
  }
  uint64_t v12 = (v11 & ~v9) + *(void *)(v5 + 64) + ((v10 + 17) & ~v10);
  char v13 = 8 * v12;
  if (v12 <= 3)
  {
    unsigned int v16 = ((a2 - v8 + ~(-1 << v13)) >> v13) + 1;
    if (HIWORD(v16))
    {
      int v14 = *(_DWORD *)(a1 + v12);
      if (!v14) {
        goto LABEL_27;
      }
      goto LABEL_18;
    }

    if (v16 > 0xFF)
    {
      int v14 = *(unsigned __int16 *)(a1 + v12);
      if (!*(_WORD *)(a1 + v12)) {
        goto LABEL_27;
      }
      goto LABEL_18;
    }

    if (v16 < 2)
    {
LABEL_27:
      if (v8 != 0x7FFFFFFF) {
        return (*(uint64_t (**)(unint64_t))(v5 + 48))((v11
      }
                                                                      + (((a1 & 0xFFFFFFFFFFFFFFFCLL) + v10 + 17) & ~v10)) & ~v9);
      uint64_t v19 = *(void *)a1;
      if (*(void *)a1 >= 0xFFFFFFFFuLL) {
        LODWORD(v19) = -1;
      }
      return (v19 + 1);
    }
  }

  int v14 = *(unsigned __int8 *)(a1 + v12);
  if (!*(_BYTE *)(a1 + v12)) {
    goto LABEL_27;
  }
LABEL_18:
  int v17 = (v14 - 1) << v13;
  if ((_DWORD)v12)
  {
    else {
      int v18 = 4;
    }
    __asm { BR              X12 }
  }

  return v8 + v17 + 1;
}

void storeEnumTagSinglePayload for Unicode._InternalNFC.Iterator( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView)
                 - 8);
  int v8 = *(_DWORD *)(v7 + 84);
  else {
    int v9 = *(_DWORD *)(v7 + 84);
  }
  if (v8 >= 0) {
    unsigned int v10 = 0x7FFFFFFF;
  }
  else {
    unsigned int v10 = v9;
  }
  size_t v11 = ((*(unsigned __int8 *)(v7 + 80) + 24LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
      + *(void *)(v7 + 64)
      + (((*(unsigned __int8 *)(v7 + 80) | 7LL) + 17) & ~(*(unsigned __int8 *)(v7 + 80) | 7LL));
  if (a3 <= v10)
  {
    unsigned int v12 = 0u;
  }

  else if (v11 <= 3)
  {
    unsigned int v14 = ((a3 - v10 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v14))
    {
      unsigned int v12 = 4u;
    }

    else if (v14 >= 0x100)
    {
      unsigned int v12 = 2;
    }

    else
    {
      unsigned int v12 = v14 > 1;
    }
  }

  else
  {
    unsigned int v12 = 1u;
  }

  if (v10 < a2)
  {
    int v13 = ~v10 + a2;
    if (v11 < 4)
    {
      if ((_DWORD)v11)
      {
        int v15 = v13 & ~(-1 << (8 * v11));
        bzero(a1, v11);
        if ((_DWORD)v11 == 3)
        {
          *(_WORD *)a1 = v15;
          a1[2] = BYTE2(v15);
        }

        else if ((_DWORD)v11 == 2)
        {
          *(_WORD *)a1 = v15;
        }

        else
        {
          *a1 = v15;
        }
      }
    }

    else
    {
      bzero(a1, v11);
      *(_DWORD *)a1 = v13;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X16 }

uint64_t type metadata accessor for Unicode._InternalNFC.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for Unicode._InternalNFC.Iterator);
}

uint64_t type metadata accessor for Unicode._InternalNFD.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for Unicode._InternalNFD.Iterator);
}

unint64_t type metadata completion function for Unicode._InternalNFD( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

unint64_t type metadata completion function for SIMD2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t result = swift_getAssociatedTypeWitness(319LL, *(const char **)(a1 + 24), *(void *)(a1 + 16), a4, a5);
  if (v7 <= 0x3F)
  {
    uint64_t v8 = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v8, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for Unicode._InternalNFD( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

unint64_t **initializeBufferWithCopyOfBuffer for SIMD2( unint64_t **a1, unint64_t **a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = *(_DWORD *)(v11 + 80);
  if (v12 <= 7 && *(void *)(v11 + 64) <= 0x18uLL && (*(_DWORD *)(v11 + 80) & 0x100000) == 0)
  {
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v11 + 16))( a1,  a2,  AssociatedTypeWitness);
  }

  else
  {
    int v15 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v15 + ((v12 + 16) & ~v12));
    swift_retain(v15, v8, v9, v10);
  }

  return a1;
}

uint64_t destroy for Unicode._InternalNFD(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator( a1,  a2,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t destroy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a2 + 24), *(void *)(a2 + 16), a3, a4);
  return (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( a1,  AssociatedTypeWitness);
}

uint64_t initializeWithCopy for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t initializeWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t assignWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 24LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t initializeWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t assignWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( a1,  a2,  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFD(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2( a1,  a2,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t getEnumTagSinglePayload for SIMD2(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  if (!a2) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *(void *)(v8 + 64);
  char v11 = 8 * v10;
  if (v10 <= 3)
  {
    unsigned int v13 = ((a2 - v9 + ~(-1 << v11)) >> v11) + 1;
    if (HIWORD(v13))
    {
      int v12 = *(_DWORD *)(a1 + v10);
      if (!v12) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v13 > 0xFF)
    {
      int v12 = *(unsigned __int16 *)(a1 + v10);
      if (!*(_WORD *)(a1 + v10)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v13 < 2)
    {
LABEL_18:
      if ((_DWORD)v9) {
        return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v8 + 48))(a1, v9, AssociatedTypeWitness);
      }
      return 0LL;
    }
  }

  int v12 = *(unsigned __int8 *)(a1 + v10);
  if (!*(_BYTE *)(a1 + v10)) {
    goto LABEL_18;
  }
LABEL_11:
  int v14 = (v12 - 1) << v11;
  if ((_DWORD)v10)
  {
    __asm { BR              X11 }
  }

  return (v9 + v14 + 1);
}

void storeEnumTagSinglePayload for Unicode._InternalNFD( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
}

void storeEnumTagSinglePayload for SIMD2( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v9 = *(void *)(swift_getAssociatedTypeWitness(0LL, *(const char **)(a4 + 24), *(void *)(a4 + 16), a5, a6) - 8);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  size_t v11 = *(void *)(v9 + 64);
  if (a3 <= v10)
  {
    unsigned int v12 = 0u;
  }

  else if (v11 <= 3)
  {
    unsigned int v14 = ((a3 - v10 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v14))
    {
      unsigned int v12 = 4u;
    }

    else if (v14 >= 0x100)
    {
      unsigned int v12 = 2;
    }

    else
    {
      unsigned int v12 = v14 > 1;
    }
  }

  else
  {
    unsigned int v12 = 1u;
  }

  if (v10 < a2)
  {
    unsigned int v13 = ~v10 + a2;
    if (v11 < 4)
    {
      if ((_DWORD)v11)
      {
        int v15 = v13 & ~(-1 << (8 * v11));
        bzero(a1, v11);
        if ((_DWORD)v11 == 3)
        {
          *(_WORD *)a1 = v15;
          a1[2] = BYTE2(v15);
        }

        else if ((_DWORD)v11 == 2)
        {
          *(_WORD *)a1 = v15;
        }

        else
        {
          *a1 = v15;
        }
      }
    }

    else
    {
      bzero(a1, v11);
      *(_DWORD *)a1 = v13;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X11 }

uint64_t type metadata accessor for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Unicode._InternalNFD);
}

unint64_t type metadata completion function for Unicode._InternalNFD.Iterator(uint64_t a1)
{
  v4[0] = &unk_18180B080;
  v4[1] = &value witness table for Builtin.Int64.size;
  unint64_t result = swift_getAssociatedTypeWitness( 319LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  if (v3 <= 0x3F)
  {
    void v4[2] = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0, 3uLL, (char *)v4, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t initializeBufferWithCopyOfBuffer for Unicode._InternalNFD.Iterator( unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  unint64_t v11 = ((v10 + 24) & ~v10) + *(void *)(v9 + 64);
  int v12 = *(_DWORD *)(v9 + 80) & 0x100000;
  unsigned int v13 = *(unint64_t **)a2;
  *(void *)a1 = *(void *)a2;
  if (v10 > 7 || v12 != 0 || v11 > 0x18)
  {
    a1 = (unint64_t)v13 + ((v10 & 0xF8 ^ 0x1F8) & (v10 + 16));
    swift_retain(v13, v5, v6, v7);
  }

  else
  {
    uint64_t v16 = ~v10;
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
    *(void *)((a1 & 0xFFFFFFFFFFFFFFF8LL) + 16) = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8LL) + 16);
    uint64_t v17 = (a1 & 0xFFFFFFFFFFFFFFF8LL) + v10;
    uint64_t v18 = (a2 & 0xFFFFFFFFFFFFFFF8LL) + v10;
    uint64_t v19 = (v17 + 24) & v16;
    uint64_t v20 = (v18 + 24) & v16;
    uint64_t v21 = *(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16);
    swift_bridgeObjectRetain((unint64_t)v13, v5, v6, v7);
    v21(v19, v20, AssociatedTypeWitness);
  }

  return a1;
}

uint64_t destroy for Unicode._InternalNFD.Iterator(uint64_t *a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( (((unint64_t)a1 & 0xFFFFFFFFFFFFFFF8LL)
          + *(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL)
          + 24) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL),
           AssociatedTypeWitness);
}

uint64_t initializeWithCopy for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  unint64_t v5 = a1 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8LL) + 16) = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8LL) + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v10 = (v9 + 24 + v5) & ~v9;
  uint64_t v11 = (v9 + 24 + v6) & ~v9;
  int v12 = *(void (**)(uint64_t, uint64_t, unint64_t))(v8 + 16);
  swift_bridgeObjectRetain(v4, v13, v14, v15);
  v12(v10, v11, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFD.Iterator( uint64_t a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v5 = (unint64_t)a2;
  unint64_t v7 = *a2;
  uint64_t v8 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRetain(v7, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v8);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(v5 + 8);
  v5 &= 0xFFFFFFFFFFFFFFF8LL;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8LL) + 16) = *(void *)(v5 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 24))( (*(unsigned __int8 *)(v10 + 80) + 24LL + (a1 & 0xFFFFFFFFFFFFFFF8LL)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  (*(unsigned __int8 *)(v10 + 80) + 24LL + v5) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = *(void *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  unint64_t v4 = a1 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v5 = a2 & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8LL) + 16) = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8LL) + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v7 + 32))( (*(unsigned __int8 *)(v7 + 80) + 24LL + v4) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80),  (*(unsigned __int8 *)(v7 + 80) + 24LL + v5) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFD.Iterator(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v4 = (unint64_t)a2;
  uint64_t v6 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRelease(v6);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(v4 + 8);
  v4 &= 0xFFFFFFFFFFFFFFF8LL;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8LL) + 16) = *(void *)(v4 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v8 + 40))( (*(unsigned __int8 *)(v8 + 80) + 24LL + (a1 & 0xFFFFFFFFFFFFFFF8LL)) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80),  (*(unsigned __int8 *)(v8 + 80) + 24LL + v4) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80),  AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFD.Iterator( unint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView)
                 - 8);
  unsigned int v6 = *(_DWORD *)(v5 + 84);
  if (v6 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v5 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v8 = *(unsigned __int8 *)(v5 + 80);
  if (a2 <= v7) {
    goto LABEL_24;
  }
  uint64_t v9 = ((v8 + 24) & ~v8) + *(void *)(v5 + 64);
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v13 = ((a2 - v7 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v13))
    {
      int v11 = *(_DWORD *)(a1 + v9);
      if (!v11) {
        goto LABEL_24;
      }
      goto LABEL_15;
    }

    if (v13 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)(a1 + v9);
      if (!*(_WORD *)(a1 + v9)) {
        goto LABEL_24;
      }
      goto LABEL_15;
    }

    if (v13 < 2)
    {
LABEL_24:
      if ((v6 & 0x80000000) != 0) {
        return (*(uint64_t (**)(unint64_t))(v5 + 48))(((a1 & 0xFFFFFFFFFFFFFFF8LL) + v8 + 24) & ~v8);
      }
      uint64_t v16 = *(void *)a1;
      if (*(void *)a1 >= 0xFFFFFFFFuLL) {
        LODWORD(v16) = -1;
      }
      return (v16 + 1);
    }
  }

  int v11 = *(unsigned __int8 *)(a1 + v9);
  if (!*(_BYTE *)(a1 + v9)) {
    goto LABEL_24;
  }
LABEL_15:
  int v14 = (v11 - 1) << v10;
  if ((_DWORD)v9)
  {
    else {
      int v15 = 4;
    }
    __asm { BR              X12 }
  }

  return v7 + v14 + 1;
}

void storeEnumTagSinglePayload for Unicode._InternalNFD.Iterator( _BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 24),  *(void *)(a4 + 16),  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView)
                 - 8);
  if (*(_DWORD *)(v7 + 84) <= 0x7FFFFFFFu) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v7 + 84);
  }
  if (a3 <= v8)
  {
    unsigned int v10 = 0u;
  }

  else if (v9 <= 3)
  {
    unsigned int v12 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
    if (HIWORD(v12))
    {
      unsigned int v10 = 4u;
    }

    else if (v12 >= 0x100)
    {
      unsigned int v10 = 2;
    }

    else
    {
      unsigned int v10 = v12 > 1;
    }
  }

  else
  {
    unsigned int v10 = 1u;
  }

  if (v8 < a2)
  {
    int v11 = ~v8 + a2;
    if (v9 < 4)
    {
      if ((_DWORD)v9)
      {
        int v13 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *(_WORD *)a1 = v13;
          a1[2] = BYTE2(v13);
        }

        else if ((_DWORD)v9 == 2)
        {
          *(_WORD *)a1 = v13;
        }

        else
        {
          *a1 = v13;
        }
      }
    }

    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X13 }

void *type metadata accessor for _CapacityAndFlags()
{
  return &unk_189B86178;
}

uint64_t initializeBufferWithCopyOfBuffer for __BridgingHashBuffer.Header( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_unknownObjectRetain(v5, a2, a3, a4);
  return a1;
}

uint64_t assignWithCopy for __BridgingHashBuffer.Header(uint64_t a1, void **a2, uint64_t a3, char *a4)
{
  unsigned int v6 = *a2;
  uint64_t v7 = *(void **)a1;
  *(void *)a1 = *a2;
  swift_unknownObjectRetain(v6, (uint64_t)a2, a3, a4);
  swift_unknownObjectRelease(v7);
  *(void *)(a1 + 8) = a2[1];
  *(void *)(a1 + 16) = a2[2];
  return a1;
}

uint64_t assignWithTake for __BridgingHashBuffer.Header(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 24)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafePartiallyInitializedContiguousArrayBuffer( uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)unint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)unint64_t result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 24) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for __BridgingHashBuffer.Header()
{
  return &type metadata for __BridgingHashBuffer.Header;
}

__n128 __swift_memcpy128_8(uint64_t a1, __int128 *a2)
{
  __int128 v2 = *a2;
  __int128 v3 = a2[1];
  __int128 v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __n128 result = (__n128)a2[4];
  __int128 v6 = a2[5];
  __int128 v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(__n128 *)(a1 + 64) = result;
  *(_OWORD *)(a1 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v6;
  return result;
}

ValueMetadata *type metadata accessor for _CocoaFastEnumerationStackBuf()
{
  return &type metadata for _CocoaFastEnumerationStackBuf;
}

void type metadata accessor for _SwiftNSFastEnumerationState(uint64_t a1)
{
}

ValueMetadata *type metadata accessor for _BridgingBufferHeader()
{
  return &type metadata for _BridgingBufferHeader;
}

void type metadata accessor for _SwiftArrayBodyStorage(uint64_t a1)
{
}

void type metadata accessor for _SwiftStdlibVersion(uint64_t a1)
{
}

void type metadata accessor for _SwiftNSFastEnumerationState(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata(0, a3);
    if (!v5) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }

uint64_t type metadata accessor for _IntegerAnyHashableBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for _IntegerAnyHashableBox);
}

ValueMetadata *type metadata accessor for _DoubleAnyHashableBox()
{
  return &type metadata for _DoubleAnyHashableBox;
}

ValueMetadata *type metadata accessor for _FloatAnyHashableBox()
{
  return &type metadata for _FloatAnyHashableBox;
}

uint64_t destroy for Mirror(uint64_t a1)
{
  return swift_release(*(void *)(a1 + 32));
}

uint64_t initializeWithCopy for Mirror(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(unint64_t **)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v5;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  __int128 v6 = *(unint64_t **)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v6;
  *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(_BYTE *)(a2 + 40);
  swift_retain(v5, a2, a3, a4);
  swift_retain(v6, v7, v8, v9);
  return a1;
}

uint64_t assignWithCopy for Mirror(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  *(void *)a1 = *(void *)a2;
  __int128 v6 = *(unint64_t **)(a2 + 8);
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v6;
  swift_retain(v6, a2, a3, a4);
  swift_release(v7);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  uint64_t v8 = *(unint64_t **)(a2 + 32);
  uint64_t v9 = *(void *)(a1 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v8;
  swift_retain(v8, v10, v11, v12);
  swift_release(v9);
  *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(_BYTE *)(a2 + 40);
  return a1;
}

uint64_t assignWithTake for Mirror(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  swift_release(v4);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  uint64_t v5 = *(void *)(a1 + 32);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  swift_release(v5);
  *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(_BYTE *)(a2 + 40);
  return a1;
}

uint64_t getEnumTagSinglePayload for Mirror(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 41)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Mirror(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_BYTE *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 41) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 41) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for Mirror._Dummy()
{
  return &type metadata for Mirror._Dummy;
}

ValueMetadata *type metadata accessor for _Int128()
{
  return &type metadata for _Int128;
}

uint64_t getEnumTagSinglePayload for FloatingPointSign(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

uint64_t storeEnumTagSinglePayload for FloatingPointSign(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFE) {
    return ((uint64_t (*)(void))((char *)&loc_18172A4AC + 4 * byte_1818005A4[v4]))();
  }
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_18172A4E0 + 4 * byte_18180059F[v4]))();
}

uint64_t sub_18172A4E0(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18172A4E8(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x18172A4F0LL);
  }
  return result;
}

uint64_t sub_18172A4FC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x18172A504LL);
  }
  *(_BYTE *)__n128 result = a2 + 1;
  return result;
}

uint64_t sub_18172A508(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18172A510(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

uint64_t getEnumTagSinglePayload for JoinedSequence.Iterator._JoinIteratorState( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFD) {
    goto LABEL_17;
  }
  if (a2 + 3 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 3) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 3;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

uint64_t storeEnumTagSinglePayload for JoinedSequence.Iterator._JoinIteratorState( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFC) {
    return ((uint64_t (*)(void))((char *)&loc_18172A600 + 4 * byte_1818005AE[v4]))();
  }
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_18172A634 + 4 * byte_1818005A9[v4]))();
}

uint64_t sub_18172A634(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18172A63C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x18172A644LL);
  }
  return result;
}

uint64_t sub_18172A650(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x18172A658LL);
  }
  *(_BYTE *)__n128 result = a2 + 3;
  return result;
}

uint64_t sub_18172A65C(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18172A664(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

void destroy for _SetAnyHashableBox(uint64_t *a1)
{
}

unint64_t *type metadata completion function for _Pair(uint64_t a1)
{
  __n128 result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    swift_getTupleTypeLayout2((uint64_t)v4, *(result - 1) + 64, *(result - 1) + 64);
    uint64_t v5 = v4;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v5, a1 + 24);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for ClosedRange( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = *(_DWORD *)(v7 + 80);
  uint64_t v10 = ~v9;
  uint64_t v11 = v8 + v9;
  unint64_t v12 = ((v8 + v9) & ~v9) + v8;
  if (v9 > 7 || (*(_DWORD *)(v7 + 80) & 0x100000) != 0 || v12 > 0x18)
  {
    int v15 = *a2;
    *uint64_t v5 = *a2;
    uint64_t v5 = (unint64_t **)((char *)v15 + ((v9 + 16) & v10));
    swift_retain(v15, (uint64_t)a2, a3, a4);
  }

  else
  {
    uint64_t v16 = *(void (**)(unint64_t **, unint64_t **, uint64_t))(v7 + 16);
    v16(a1, a2, *(void *)(a3 + 16));
    v16( (unint64_t **)(((unint64_t)v5 + v11) & v10),  (unint64_t **)(((unint64_t)a2 + v11) & v10),  v6);
  }

  return v5;
}

uint64_t destroy for ClosedRange(unint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v6 = *(uint64_t (**)(unint64_t, uint64_t))(v4 + 8);
  v6(a1, v3);
  return v6( (*(void *)(v4 + 64) + a1 + *(unsigned __int8 *)(v4 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80),  v3);
}

unint64_t initializeWithCopy for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 16);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

unint64_t assignWithCopy for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 24);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

unint64_t initializeWithTake for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 32);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

unint64_t assignWithTake for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 40);
  v7(a1, a2, v5);
  v7( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80),  v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for ClosedRange(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  unsigned int v6 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_18;
  }
  char v8 = 8 * v7;
  if (v7 <= 3)
  {
    unsigned int v10 = ((v6 + ~(-1 << v8)) >> v8) + 1;
    if (HIWORD(v10))
    {
      int v9 = *(_DWORD *)(a1 + v7);
      if (!v9) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v10 > 0xFF)
    {
      int v9 = *(unsigned __int16 *)(a1 + v7);
      if (!*(_WORD *)(a1 + v7)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v10 < 2)
    {
LABEL_18:
      if (v5) {
        return (*(uint64_t (**)(void))(v4 + 48))();
      }
      return 0LL;
    }
  }

  int v9 = *(unsigned __int8 *)(a1 + v7);
  if (!*(_BYTE *)(a1 + v7)) {
    goto LABEL_18;
  }
LABEL_11:
  int v11 = (v9 - 1) << v8;
  if (!(_DWORD)v7) {
    return v5 + v11 + 1;
  }
  return ((uint64_t (*)(void))((char *)&loc_18172AAB4 + 4 * byte_1818005B3[(v7 - 1)]))();
}

void storeEnumTagSinglePayload for ClosedRange(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  BOOL v9 = a3 >= v7;
  unsigned int v10 = a3 - v7;
  if (v10 != 0 && v9)
  {
    if (v8 <= 3)
    {
      unsigned int v13 = ((v10 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (HIWORD(v13))
      {
        unsigned int v11 = 4u;
      }

      else if (v13 >= 0x100)
      {
        unsigned int v11 = 2;
      }

      else
      {
        unsigned int v11 = v13 > 1;
      }
    }

    else
    {
      unsigned int v11 = 1u;
    }
  }

  else
  {
    unsigned int v11 = 0u;
  }

  if (v7 < a2)
  {
    unsigned int v12 = ~v7 + a2;
    if (v8 < 4)
    {
      if ((_DWORD)v8)
      {
        int v14 = v12 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if ((_DWORD)v8 == 3)
        {
          *a1 = v14;
          *((_BYTE *)a1 + 2) = BYTE2(v14);
        }

        else if ((_DWORD)v8 == 2)
        {
          *a1 = v14;
        }

        else
        {
          *(_BYTE *)a1 = v14;
        }
      }
    }

    else
    {
      bzero(a1, v8);
      *(_DWORD *)a1 = v12;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X11 }

unint64_t *type metadata completion function for SIMDMask(uint64_t a1)
{
  __n128 result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v4, a1 + 48);
    return 0LL;
  }

  return result;
}

unint64_t *type metadata completion function for Result(uint64_t a1)
{
  __n128 result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(result - 1) + 64;
    __n128 result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[1] = *(result - 1) + 64;
      swift_initEnumMetadataMultiPayload(a1, 0, 2uLL, (char *)v5);
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for Result( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  unsigned int v5 = a1;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void *)(*(void *)(a3 + 24) - 8LL);
  if (*(void *)(v8 + 64) <= *(void *)(v7 + 64)) {
    uint64_t v9 = *(void *)(v7 + 64);
  }
  else {
    uint64_t v9 = *(void *)(v8 + 64);
  }
  uint64_t v10 = (*(_BYTE *)(v8 + 80) | *(_BYTE *)(v7 + 80));
  if (v10 <= 7
    && (unint64_t)(v9 + 1) <= 0x18
    && ((*(_DWORD *)(v8 + 80) | *(_DWORD *)(v7 + 80)) & 0x100000) == 0)
  {
    unsigned int v14 = *((unsigned __int8 *)a2 + v9);
    if (v14 >= 2)
    {
      else {
        uint64_t v15 = 4LL;
      }
      __asm { BR              X15 }
    }

    if (v14 == 1)
    {
      (*(void (**)(unint64_t **))(v8 + 16))(a1);
      *((_BYTE *)v5 + v9) = 1;
    }

    else
    {
      (*(void (**)(unint64_t **))(v7 + 16))(a1);
      *((_BYTE *)v5 + v9) = 0;
    }
  }

  else
  {
    unsigned int v13 = *a2;
    *unsigned int v5 = *a2;
    unsigned int v5 = (unint64_t **)((char *)v13 + ((v10 + 16) & ~v10));
    swift_retain(v13, (uint64_t)a2, v6, a4);
  }

  return v5;
}

uint64_t destroy for Result(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  uint64_t v3 = *(void *)(*(void *)(a2 + 16) - 8LL);
  unint64_t v4 = *(void *)(v3 + 64);
  uint64_t v5 = *(void *)(v2 - 8);
  if (*(void *)(v5 + 64) > v4) {
    unint64_t v4 = *(void *)(v5 + 64);
  }
  unsigned int v6 = *(unsigned __int8 *)(a1 + v4);
  if (v6 < 2)
  {
    if (v6 == 1) {
      uint64_t v3 = *(void *)(v2 - 8);
    }
    return (*(uint64_t (**)(void))(v3 + 8))();
  }

  else
  {
    else {
      uint64_t v7 = 4LL;
    }
    return ((uint64_t (*)(void))((char *)&loc_18172AF3C + 4 * byte_1818005C6[v7]))();
  }

uint64_t initializeWithCopy for Result(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 24);
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  uint64_t v6 = *(void *)(v4 - 8);
  if (*(void *)(v6 + 64) <= *(void *)(v5 + 64)) {
    uint64_t v7 = *(void *)(v5 + 64);
  }
  else {
    uint64_t v7 = *(void *)(v6 + 64);
  }
  unsigned int v8 = *(unsigned __int8 *)(a2 + v7);
  if (v8 >= 2)
  {
    else {
      uint64_t v9 = 4LL;
    }
    __asm { BR              X16 }
  }

  BOOL v10 = v8 == 1;
  if (v8 == 1) {
    uint64_t v5 = *(void *)(v4 - 8);
  }
  (*(void (**)(uint64_t))(v5 + 16))(a1);
  *(_BYTE *)(a1 + v7) = v10;
  return a1;
}

uint64_t assignWithCopy for Result(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(a3 + 24);
    uint64_t v7 = *(void *)(v5 - 8);
    uint64_t v8 = *(void *)(v6 - 8);
    if (*(void *)(v8 + 64) <= *(void *)(v7 + 64)) {
      uint64_t v9 = *(void *)(v7 + 64);
    }
    else {
      uint64_t v9 = *(void *)(v8 + 64);
    }
    unsigned int v10 = *(unsigned __int8 *)(a1 + v9);
    if (v10 >= 2)
    {
      else {
        uint64_t v11 = 4LL;
      }
      __asm { BR              X12 }
    }

    if (v10 == 1) {
      uint64_t v12 = *(void *)(v6 - 8);
    }
    else {
      uint64_t v12 = *(void *)(v5 - 8);
    }
    if (v10 == 1) {
      uint64_t v13 = *(void *)(a3 + 24);
    }
    else {
      uint64_t v13 = *(void *)(a3 + 16);
    }
    (*(void (**)(uint64_t, uint64_t))(v12 + 8))(a1, v13);
    unsigned int v14 = *(unsigned __int8 *)(a2 + v9);
    if (v14 >= 2)
    {
      else {
        uint64_t v15 = 4LL;
      }
      __asm { BR              X12 }
    }

    BOOL v16 = v14 == 1;
    if (v14 == 1) {
      uint64_t v17 = v8;
    }
    else {
      uint64_t v17 = v7;
    }
    if (v14 == 1) {
      uint64_t v18 = v6;
    }
    else {
      uint64_t v18 = v5;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 16))(a1, a2, v18);
    *(_BYTE *)(a1 + v9) = v16;
  }

  return a1;
}

uint64_t initializeWithTake for Result(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 24);
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  uint64_t v6 = *(void *)(v4 - 8);
  if (*(void *)(v6 + 64) <= *(void *)(v5 + 64)) {
    uint64_t v7 = *(void *)(v5 + 64);
  }
  else {
    uint64_t v7 = *(void *)(v6 + 64);
  }
  unsigned int v8 = *(unsigned __int8 *)(a2 + v7);
  if (v8 >= 2)
  {
    else {
      uint64_t v9 = 4LL;
    }
    __asm { BR              X16 }
  }

  BOOL v10 = v8 == 1;
  if (v8 == 1) {
    uint64_t v5 = *(void *)(v4 - 8);
  }
  (*(void (**)(uint64_t))(v5 + 32))(a1);
  *(_BYTE *)(a1 + v7) = v10;
  return a1;
}

uint64_t assignWithTake for Result(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(a3 + 24);
    uint64_t v7 = *(void *)(v5 - 8);
    uint64_t v8 = *(void *)(v6 - 8);
    if (*(void *)(v8 + 64) <= *(void *)(v7 + 64)) {
      uint64_t v9 = *(void *)(v7 + 64);
    }
    else {
      uint64_t v9 = *(void *)(v8 + 64);
    }
    unsigned int v10 = *(unsigned __int8 *)(a1 + v9);
    if (v10 >= 2)
    {
      else {
        uint64_t v11 = 4LL;
      }
      __asm { BR              X12 }
    }

    if (v10 == 1) {
      uint64_t v12 = *(void *)(v6 - 8);
    }
    else {
      uint64_t v12 = *(void *)(v5 - 8);
    }
    if (v10 == 1) {
      uint64_t v13 = *(void *)(a3 + 24);
    }
    else {
      uint64_t v13 = *(void *)(a3 + 16);
    }
    (*(void (**)(uint64_t, uint64_t))(v12 + 8))(a1, v13);
    unsigned int v14 = *(unsigned __int8 *)(a2 + v9);
    if (v14 >= 2)
    {
      else {
        uint64_t v15 = 4LL;
      }
      __asm { BR              X12 }
    }

    BOOL v16 = v14 == 1;
    if (v14 == 1) {
      uint64_t v17 = v8;
    }
    else {
      uint64_t v17 = v7;
    }
    if (v14 == 1) {
      uint64_t v18 = v6;
    }
    else {
      uint64_t v18 = v5;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 32))(a1, a2, v18);
    *(_BYTE *)(a1 + v9) = v16;
  }

  return a1;
}

uint64_t getEnumTagSinglePayload for Result(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(*(void *)(*(void *)(a3 + 24) - 8LL) + 64LL);
  if (v3 <= *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL)) {
    unint64_t v3 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL);
  }
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFF) {
    goto LABEL_21;
  }
  unint64_t v4 = v3 + 1;
  char v5 = 8 * (v3 + 1);
  if ((v3 + 1) <= 3)
  {
    unsigned int v8 = ((a2 + ~(-1 << v5) - 254) >> v5) + 1;
    if (HIWORD(v8))
    {
      int v6 = *(_DWORD *)(a1 + v4);
      if (!v6) {
        goto LABEL_21;
      }
      goto LABEL_14;
    }

    if (v8 > 0xFF)
    {
      int v6 = *(unsigned __int16 *)(a1 + v4);
      if (!*(_WORD *)(a1 + v4)) {
        goto LABEL_21;
      }
      goto LABEL_14;
    }

    if (v8 < 2)
    {
LABEL_21:
      unsigned int v10 = *(unsigned __int8 *)(a1 + v3);
      if (v10 >= 2) {
        return (v10 ^ 0xFF) + 1;
      }
      else {
        return 0LL;
      }
    }
  }

  int v6 = *(unsigned __int8 *)(a1 + v4);
  if (!*(_BYTE *)(a1 + v4)) {
    goto LABEL_21;
  }
LABEL_14:
  int v9 = (v6 - 1) << v5;
  if (!(_DWORD)v4) {
    return (v9 + 255);
  }
  return ((uint64_t (*)(void))((char *)&loc_18172B50C + 4 * byte_1818005E9[(v4 - 1)]))();
}

void storeEnumTagSinglePayload for Result(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8LL) + 64LL);
  if (*(void *)(*(void *)(*(void *)(a4 + 24) - 8LL) + 64LL) > v5) {
    unint64_t v5 = *(void *)(*(void *)(*(void *)(a4 + 24) - 8LL) + 64LL);
  }
  size_t v6 = v5 + 1;
  if (a3 < 0xFF)
  {
    unsigned int v7 = 0u;
  }

  else if (v6 <= 3)
  {
    unsigned int v9 = ((a3 + ~(-1 << (8 * v6)) - 254) >> (8 * v6)) + 1;
    if (HIWORD(v9))
    {
      unsigned int v7 = 4u;
    }

    else if (v9 >= 0x100)
    {
      unsigned int v7 = 2;
    }

    else
    {
      unsigned int v7 = v9 > 1;
    }
  }

  else
  {
    unsigned int v7 = 1u;
  }

  if (a2 <= 0xFE) {
    __asm { BR              X11 }
  }

  unsigned int v8 = a2 - 255;
  if (v6 < 4)
  {
    if ((_DWORD)v5 != -1)
    {
      int v10 = v8 & ~(-1 << (8 * v6));
      bzero(a1, v6);
      if ((_DWORD)v6 == 3)
      {
        *a1 = v10;
        *((_BYTE *)a1 + 2) = BYTE2(v10);
      }

      else if ((_DWORD)v6 == 2)
      {
        *a1 = v10;
      }

      else
      {
        *(_BYTE *)a1 = v10;
      }
    }
  }

  else
  {
    bzero(a1, v5 + 1);
    *(_DWORD *)a1 = v8;
  }

  __asm { BR              X10 }

uint64_t getEnumTag for Result(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(*(void *)(*(void *)(a2 + 24) - 8LL) + 64LL);
  if (v2 <= *(void *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 64LL)) {
    unint64_t v2 = *(void *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 64LL);
  }
  else {
    uint64_t v3 = 4LL;
  }
  return ((uint64_t (*)(void))((char *)&loc_18172B758 + 4 * byte_1818005F7[v3]))();
}

void destructiveInjectEnumTag for Result(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  if (a2 > 1)
  {
    if (*(void *)(*(void *)(*(void *)(a3 + 24) - 8LL) + 64LL) <= *(void *)(*(void *)(*(void *)(a3 + 16)
                                                                                              - 8LL)
                                                                                  + 64LL))
      size_t v5 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL);
    else {
      size_t v5 = *(void *)(*(void *)(*(void *)(a3 + 24) - 8LL) + 64LL);
    }
    unsigned int v6 = a2 - 2;
    if (v5 < 4)
    {
      unsigned int v7 = v6 >> (8 * v5);
      int v8 = v6 & ~(-1 << (8 * v5));
      a1[v5] = v7 + 2;
      bzero(a1, v5);
      if ((_DWORD)v5 == 3)
      {
        *(_WORD *)a1 = v8;
        a1[2] = BYTE2(v8);
      }

      else if ((_DWORD)v5 == 2)
      {
        *(_WORD *)a1 = v8;
      }

      else
      {
        *a1 = v8;
      }
    }

    else
    {
      a1[v5] = 2;
      bzero(a1, v5);
      *(_DWORD *)a1 = v6;
    }
  }

  else
  {
    unint64_t v4 = *(void *)(*(void *)(*(void *)(a3 + 24) - 8LL) + 64LL);
    if (v4 <= *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL)) {
      unint64_t v4 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 64LL);
    }
    a1[v4] = a2;
  }

unint64_t *type metadata completion function for EnumeratedSequence(uint64_t a1)
{
  __n128 result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (char *)&v4, a1 + 32);
    return 0LL;
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for EnumeratedSequence( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  if (v7 <= 7 && *(void *)(v6 + 64) <= 0x18uLL && (*(_DWORD *)(v6 + 80) & 0x100000) == 0)
  {
    (*(void (**)(unint64_t **))(v6 + 16))(a1);
  }

  else
  {
    int v10 = *a2;
    void *v4 = *a2;
    uint64_t v4 = (unint64_t **)((char *)v10 + ((v7 + 16) & ~v7));
    swift_retain(v10, (uint64_t)a2, v5, a4);
  }

  return v4;
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  unsigned int v6 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_18;
  }
  uint64_t v7 = *(void *)(v4 + 64);
  char v8 = 8 * v7;
  if (v7 <= 3)
  {
    unsigned int v10 = ((v6 + ~(-1 << v8)) >> v8) + 1;
    if (HIWORD(v10))
    {
      int v9 = *(_DWORD *)(a1 + v7);
      if (!v9) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v10 > 0xFF)
    {
      int v9 = *(unsigned __int16 *)(a1 + v7);
      if (!*(_WORD *)(a1 + v7)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v10 < 2)
    {
LABEL_18:
      if (v5) {
        return (*(uint64_t (**)(void))(v4 + 48))();
      }
      return 0LL;
    }
  }

  int v9 = *(unsigned __int8 *)(a1 + v7);
  if (!*(_BYTE *)(a1 + v7)) {
    goto LABEL_18;
  }
LABEL_11:
  int v11 = (v9 - 1) << v8;
  if (!(_DWORD)v7) {
    return v5 + v11 + 1;
  }
  return ((uint64_t (*)(void))((char *)&loc_18172BA18 + 4 * byte_1818005FC[(v7 - 1)]))();
}

void storeEnumTagSinglePayload for EnumeratedSequence( _WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  size_t v8 = *(void *)(v6 + 64);
  BOOL v9 = a3 >= v7;
  unsigned int v10 = a3 - v7;
  if (v10 != 0 && v9)
  {
    if (v8 <= 3)
    {
      unsigned int v13 = ((v10 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (HIWORD(v13))
      {
        unsigned int v11 = 4u;
      }

      else if (v13 >= 0x100)
      {
        unsigned int v11 = 2;
      }

      else
      {
        unsigned int v11 = v13 > 1;
      }
    }

    else
    {
      unsigned int v11 = 1u;
    }
  }

  else
  {
    unsigned int v11 = 0u;
  }

  if (v7 < a2)
  {
    unsigned int v12 = ~v7 + a2;
    if (v8 < 4)
    {
      if ((_DWORD)v8)
      {
        int v14 = v12 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if ((_DWORD)v8 == 3)
        {
          *a1 = v14;
          *((_BYTE *)a1 + 2) = BYTE2(v14);
        }

        else if ((_DWORD)v8 == 2)
        {
          *a1 = v14;
        }

        else
        {
          *(_BYTE *)a1 = v14;
        }
      }
    }

    else
    {
      bzero(a1, *(void *)(v6 + 64));
      *(_DWORD *)a1 = v12;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X11 }

ValueMetadata *type metadata accessor for _Stdout()
{
  return &type metadata for _Stdout;
}

unint64_t *initializeBufferWithCopyOfBuffer for CollectionDifference( unint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  *a1 = *a2;
  a1[1] = v6;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRetain(v6, v7, v8, v9);
  return a1;
}

uint64_t *assignWithCopy for CollectionDifference(uint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *a2;
  uint64_t v7 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v6, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  unint64_t v8 = a2[1];
  uint64_t v9 = a1[1];
  a1[1] = v8;
  swift_bridgeObjectRetain(v8, v10, v11, v12);
  swift_bridgeObjectRelease(v9);
  return a1;
}

uint64_t *assignWithTake for CollectionDifference(uint64_t *a1, _OWORD *a2)
{
  uint64_t v4 = a1[1];
  *(_OWORD *)a1 = *a2;
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for __CocoaDictionary.Index(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for __CocoaDictionary.Index(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 16) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

__n128 __swift_memcpy25_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 9) = *(_OWORD *)(a2 + 9);
  *(__n128 *)a1 = result;
  return result;
}

ValueMetadata *type metadata accessor for _DictionaryCodingKey()
{
  return &type metadata for _DictionaryCodingKey;
}

uint64_t initializeWithCopy for _DictionaryCodingKey(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  return a1;
}

uint64_t assignWithCopy for _DictionaryCodingKey(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  *(void *)a1 = *(void *)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v6;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  uint64_t v8 = *(void *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(void *)(a1 + 16) = v8;
  return a1;
}

uint64_t assignWithTake for _DictionaryCodingKey(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for _DictionaryCodingKey(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 25)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _DictionaryCodingKey(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(_BYTE *)(result + 24) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 25) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 25) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for _GenericIndexKey()
{
  return &type metadata for _GenericIndexKey;
}

void *type metadata accessor for UTF8ValidationError()
{
  return &unk_189B86A70;
}

uint64_t destroy for Dictionary.Keys.Iterator( void *a1, uint64_t a2, uint64_t (*a3)(void, void, void, void, void))
{
  return a3(*a1, a1[1], a1[2], a1[3], a1[4]);
}

void *initializeWithCopy for Dictionary.Keys.Iterator( void *a1, void *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = a2[2];
  uint64_t v8 = a2[3];
  uint64_t v9 = a2[4];
  a4(*a2, v6, v7, v8, v9);
  *a1 = v5;
  a1[1] = v6;
  a1[2] = v7;
  a1[3] = v8;
  a1[4] = v9;
  return a1;
}

uint64_t *assignWithCopy for Dictionary.Keys.Iterator( uint64_t *a1, void *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t, uint64_t, uint64_t), void (*a5)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  uint64_t v9 = a2[2];
  uint64_t v10 = a2[3];
  uint64_t v11 = a2[4];
  a4(*a2, v8, v9, v10, v11);
  uint64_t v12 = *a1;
  uint64_t v13 = a1[1];
  uint64_t v14 = a1[2];
  uint64_t v15 = a1[3];
  uint64_t v16 = a1[4];
  *a1 = v7;
  a1[1] = v8;
  a1[2] = v9;
  a1[3] = v10;
  a1[4] = v11;
  a5(v12, v13, v14, v15, v16);
  return a1;
}

void *assignWithTake for Dictionary.Keys.Iterator( void *a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = *a1;
  uint64_t v9 = a1[1];
  uint64_t v8 = a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = a1[4];
  __int128 v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *((_OWORD *)a1 + 1) = v12;
  a1[4] = v6;
  a4(v7, v9, v8, v10, v11);
  return a1;
}

uint64_t getEnumTagSinglePayload for Dictionary.Keys.Iterator(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0x7F && *(_BYTE *)(a1 + 40)) {
    return (*(_DWORD *)a1 + 127);
  }
  unsigned int v3 = (((*(void *)a1 >> 57) >> 6) | (2 * ((*(void *)a1 >> 57) & 0x38 | *(void *)a1 & 7))) ^ 0x7F;
  if (v3 >= 0x7E) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for Dictionary.Keys.Iterator( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7E)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)__n128 result = a2 - 127;
    if (a3 >= 0x7F) {
      *(_BYTE *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 1;
    }
  }

  else
  {
    if (a3 >= 0x7F) {
      *(_BYTE *)(result + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    }
    if (a2)
    {
      uint64_t v3 = (-a2 >> 1) & 0x3F | ((-a2 & 0x7F) << 6);
      *(void *)__n128 result = (v3 | (v3 << 57)) & 0xF000000000000007LL;
      *(_OWORD *)(result + 8) = 0u;
      *(_OWORD *)(result + 24) = 0u;
    }
  }

  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for Dictionary.Index( uint64_t a1, uint64_t *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t))
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = *((unsigned __int8 *)a2 + 16);
  a4(*a2, v6, v7);
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = v6;
  *(_BYTE *)(a1 + 16) = v7;
  return a1;
}

uint64_t *assignWithCopy for Dictionary.Index( uint64_t *a1, uint64_t *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t), void (*a5)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  uint64_t v9 = *((unsigned __int8 *)a2 + 16);
  a4(*a2, v8, v9);
  uint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  uint64_t v12 = *((unsigned __int8 *)a1 + 16);
  *a1 = v7;
  a1[1] = v8;
  *((_BYTE *)a1 + 16) = v9;
  a5(v10, v11, v12);
  return a1;
}

uint64_t *assignWithTake for Dictionary.Index( uint64_t *a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t))
{
  char v5 = *(_BYTE *)(a2 + 16);
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  uint64_t v8 = *((unsigned __int8 *)a1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *((_BYTE *)a1 + 16) = v5;
  a4(v6, v7, v8);
  return a1;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _Pair<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for _Pair<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _Pair<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

unint64_t instantiation function for generic protocol witness table for _Int128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _Int128 and conformance _Int128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type _Int128 and conformance _Int128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _Int128 and conformance _Int128;
  if (!lazy protocol witness table cache variable for type _Int128 and conformance _Int128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _Int128, &type metadata for _Int128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _Int128 and conformance _Int128);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _Int128 and conformance _Int128;
  if (!lazy protocol witness table cache variable for type _Int128 and conformance _Int128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _Int128, &type metadata for _Int128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _Int128 and conformance _Int128);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for _UInt128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type _UInt128 and conformance _UInt128( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _UInt128, &type metadata for _UInt128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _UInt128, &type metadata for _UInt128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _UInt128, &type metadata for _UInt128, a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _Int128.Words,  &type metadata for _Int128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _Int128.Words,  &type metadata for _Int128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _Int128.Words,  &type metadata for _Int128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _Int128.Words,  &type metadata for _Int128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }

  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _Int128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<_Int128.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<_Int128.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _Int128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<_Int128.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for _Int128.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _Int128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<_Int128.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _Int128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<_Int128.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in _Int128()
{
  return &protocol witness table for _UInt128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in _Int128()
{
  return &protocol witness table for _UInt128;
}

unint64_t lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _UInt128.Words,  &type metadata for _UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _UInt128.Words,  &type metadata for _UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _UInt128.Words,  &type metadata for _UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for _UInt128.Words,  &type metadata for _UInt128.Words,  a3);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }

  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type IndexingIterator<_UInt128.Words> and conformance IndexingIterator<A>,  &demangling cache variable for type metadata for IndexingIterator<_UInt128.Words>,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( &lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance Slice<A>,  &demangling cache variable for type metadata for Slice<_UInt128.Words>,  (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>( unint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v6 = __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    uint64_t result = swift_getWitnessTable(a3, v6, v7);
    atomic_store(result, a1);
  }

  return result;
}

unint64_t instantiation function for generic protocol witness table for _UInt128.Words( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;
  unint64_t result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<_UInt128.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( &lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>,  &demangling cache variable for type metadata for Slice<_UInt128.Words>,  (uint64_t (*)(void))lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>( unint64_t *a1, uint64_t *a2, uint64_t (*a3)(void), uint64_t a4)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v8 = __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    uint64_t v9 = a3();
    uint64_t result = swift_getWitnessTable(a4, v8, &v9);
    atomic_store(result, a1);
  }

  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._InternalNFD<A>()
{
  return &protocol witness table for Unicode._InternalNFD<A>.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._InternalNFC<A>()
{
  return &protocol witness table for Unicode._InternalNFC<A>.Iterator;
}

uint64_t instantiation function for generic protocol witness table for _FixedArray16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t result = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _FixedArray16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in _FixedArray16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = &protocol witness table for Int;
  v7[1] = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  return swift_getWitnessTable(a4, a1, v7);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _FixedArray16<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t outlined destroy of _HasContiguousBytes?(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8LL))(a1, v3);
  return a1;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, AnyHashable>()
{
  return objc_opt_self();
}

uint64_t partial apply for closure #1 in _FixedArray16.subscript.setter(uint64_t a1)
{
  return partial apply for closure #1 in _FixedArray16.subscript.setter(a1);
}

{
  void *v1;
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(v1[2] - 8LL) + 24LL))( a1 + *(void *)(*(void *)(v1[2] - 8LL) + 72LL) * v1[3],  v1[4]);
}

uint64_t outlined init with take of KeyPathComponent(__int128 *a1, uint64_t a2)
{
  __int128 v2 = *a1;
  __int128 v3 = a1[1];
  __int128 v4 = a1[2];
  *(void *)(a2 + 48) = *((void *)a1 + 6);
  *(_OWORD *)(a2 + 16) = v3;
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)a2 = v2;
  return a2;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>()
{
  return objc_opt_self();
}

__n128 partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage.countByEnumerating(with:objects:count:)@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t v5 = *(void *)(v3 + 24);
  *(void *)(v4 + 8) = a1;
  *(void *)(v4 + 16) = &_fastEnumerationStorageMutationsTarget;
  *(void *)uint64_t v4 = 1LL;
  uint64_t v6 = *(void *)(v4 + 56);
  __n128 result = *(__n128 *)(v4 + 24);
  __int128 v8 = *(_OWORD *)(v4 + 40);
  *(void *)uint64_t v5 = 1LL;
  *(void *)(v5 + 8) = a1;
  *(void *)(v5 + 16) = &_fastEnumerationStorageMutationsTarget;
  *(__n128 *)(v5 + 24) = result;
  *(_OWORD *)(v5 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v8;
  *(void *)(v5 + 56) = v6;
  *a3 = a2;
  return result;
}

char *partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage.getObjects(_:range:)( char *result, uint64_t a2)
{
  uint64_t v3 = *(void *)(v2 + 16);
  if (v3 < 0 || v3 > a2)
  {
    unint64_t v6 = 104LL;
    goto LABEL_13;
  }

  uint64_t v4 = *(void *)(v2 + 24);
  uint64_t v5 = v3 + v4;
  if (__OFADD__(v3, v4))
  {
    __break(1u);
    goto LABEL_16;
  }

  if (v5 < 0 || v5 > a2)
  {
    unint64_t v6 = 108LL;
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index out of range",  24LL,  2,  "Swift/SwiftNativeNSArray.swift",  30LL,  2,  v6,  0);
  }

  if (a2)
  {
    if (!result) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SwiftNativeNSArray.swift",  30LL,  2,  0x77uLL,  0);
    }
    if ((unint64_t)(v4 - 0x1000000000000000LL) >> 61 == 7)
    {
      if (((8 * v4) & 0x8000000000000000LL) == 0) {
        return (char *)memmove(*(void **)(v2 + 32), &result[8 * v3], 8 * v4);
      }
LABEL_17:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
    }

uint64_t partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)(a1, a2, *(void *)(v3 + 16), a3);
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafePointer<UInt8>) -> (@unowned Bool)@<X0>( _BYTE *a1@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void))(v1 + 16))();
  *a1 = result & 1;
  return result;
}

BOOL partial apply for specialized closure #1 in _AbstractStringStorage._isEqual(_:)(void *__s2)
{
  size_t v2 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  if ((*(void *)(v3 + 32) & 0xFFFFFFFFFFFFLL) != v2) {
    return 0LL;
  }
  uint64_t v5 = *(void **)(v3 + 24);
  return v5 == __s2 || memcmp(v5, __s2, v2) == 0;
}

{
  uint64_t v1;
  size_t v2;
  uint64_t v3;
  size_t v2 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  if ((*(void *)(v3 + 24) & 0xFFFFFFFFFFFFLL) != v2) {
    return 0LL;
  }
  return memcmp((const void *)(v3 + 32), __s2, v2) == 0;
}

uint64_t partial apply for specialized closure #1 in _arrayForceCast<A, B>(_:)@<X0>( uint64_t a1@<X0>, char *a2@<X8>)
{
  return specialized closure #1 in _arrayForceCast<A, B>(_:)(a1, *(swift **)(v2 + 16), a2);
}

uint64_t partial apply for specialized closure #1 in MutableCollection<>.partition(by:)@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = specialized MutableCollection<>._partitionImpl(by:)(*(uint64_t (**)(char *))(v1 + 16));
  if (!v2) {
    *a1 = result;
  }
  return result;
}

_BYTE *closure #1 in closure #1 in Double.init<A>(_:)partial apply@<X0>( _BYTE *result@<X0>, uint64_t (*a2)(void)@<X1>, BOOL *a3@<X8>)
{
  unsigned int v4 = *result;
  BOOL v5 = v4 > 0x20;
  uint64_t v6 = (1LL << v4) & 0x100003E01LL;
  BOOL v7 = v5 || v6 == 0;
  v8 = v7 && (uint64_t result = (_BYTE *)a2()) != 0LL && *result == 0;
  *a3 = v8;
  return result;
}

BOOL closure #1 in Sequence<>.contains(_:)specialized partial apply(_DWORD *a1)
{
  return *a1 == **(_DWORD **)(v1 + 16);
}

{
  return closure #1 in Sequence<>.contains(_:)specialized partial apply(a1);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Unicode.Scalar>()
{
  return objc_opt_self();
}

uint64_t partial apply for specialized closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)()
{
  return specialized _StringGuts.replaceSubrange<A>(_:with:)( *(void *)(v0 + 16),  *(void *)(v0 + 24),  **(_DWORD **)(v0 + 32));
}

{
  uint64_t v0;
  return specialized _StringGuts.replaceSubrange<A>(_:with:)(*(void *)(v0 + 16), *(void *)(v0 + 24));
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt32>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt16>()
{
  return objc_opt_self();
}

uint64_t partial apply for closure #1 in Slice.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return closure #1 in Slice.withContiguousStorageIfAvailable<A>(_:)( a1,  a2,  *(char **)(v3 + 40),  *(uint64_t (**)(uint64_t))(v3 + 48),  *(void *)(v3 + 56),  *(void *)(v3 + 16),  *(void *)(v3 + 32),  a3);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Character>()
{
  return objc_opt_self();
}

void *partial apply for closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)(uint64_t *a1)
{
  return closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)( a1,  *(void *)(v1 + 40),  *(void *)(v1 + 48),  *(void (**)(void *))(v1 + 56),  *(void *)(v1 + 64),  *(void *)(v1 + 16),  *(void *)(v1 + 24),  *(void *)(v1 + 32));
}

unint64_t partial apply for closure #1 in Slice._copyContents(initializing:)@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  return closure #1 in Slice._copyContents(initializing:)( a1,  a2,  *(char **)(v3 + 32),  *(void *)(v3 + 40),  *(void *)(v3 + 16),  *(void *)(v3 + 24),  a3);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_HashTable.Bucket>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>()
{
  return objc_opt_self();
}

double partial apply for closure #1 in closure #1 in _myers<A, B>(from:to:using:)@<D0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  return closure #1 in closure #1 in _myers<A, B>(from:to:using:)( a1,  a2,  *(void *)(v3 + 48),  *(void *)(v3 + 56),  *(uint64_t (**)(char *, char *))(v3 + 64),  *(void *)(v3 + 72),  *(void *)(v3 + 16),  *(void *)(v3 + 32),  a3);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_V>()
{
  return objc_opt_self();
}

BOOL partial apply for closure #1 in closure #2 in CollectionDifference<A>.inferringMoves()( uint64_t a1, uint64_t a2, char a3)
{
  return (a3 & 1) == 0;
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool)( uint64_t a1, uint64_t a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool)(a1, a2) & 1;
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, void, void))(v2 + 32))(a1, *(void *)a2, *(unsigned __int8 *)(a2 + 8)) & 1;
}

BOOL partial apply for closure #1 in CollectionDifference.init<A>(_validatedChanges:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return closure #1 in CollectionDifference.init<A>(_validatedChanges:)(a1, a2, *(void *)(v4 + 16), a4);
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<Int>()
{
  return objc_opt_self();
}

uint64_t outlined retain of Substring(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a1;
}

uint64_t outlined release of Substring(uint64_t a1)
{
  return a1;
}

uint64_t canonical specialized generic type metadata accessor for _IndexBox<String.Index>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String.Index>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, Int>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int8>()
{
  return objc_opt_self();
}

uint64_t partial apply for closure #1 in closure #1 in String._slowWithCString<A, B>(encodedAs:_:)( uint64_t a1)
{
  return closure #1 in closure #1 in String._slowWithCString<A, B>(encodedAs:_:)( a1,  *(void *)(v1 + 40),  *(void *)(v1 + 24),  *(const char **)(v1 + 32));
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Range<Int>>()
{
  return objc_opt_self();
}

uint64_t partial apply for closure #1 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(v4 + 16);
  uint64_t v6 = *(void *)(v4 + 24);
  int v7 = *(unsigned __int8 *)(v4 + 32);
  uint64_t v8 = *(void *)(v4 + 40);
  uint64_t v9 = a1 + *(int *)(type metadata accessor for Range(0LL, v5, v6, a4) + 36);
  uint64_t v10 = 40LL;
  if (v7) {
    uint64_t v10 = 32LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + v10))(v9, v8, v5, v6) & 1;
}

uint64_t partial apply for closure #2 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(v4 + 16);
  uint64_t v7 = *(void *)(v4 + 24);
  int v8 = *(unsigned __int8 *)(v4 + 32);
  uint64_t v9 = *(void *)(v4 + 40);
  uint64_t v10 = v9 + *(int *)(type metadata accessor for Range(0LL, v6, v7, a4) + 36);
  uint64_t v11 = 32LL;
  if (v8) {
    uint64_t v11 = 40LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + v11))(a1, v10, v6, v7) & 1;
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<AnyHashable>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<String>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, String>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, Any>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, Any>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, AnyHashable>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, String>()
{
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Bool>()
{
  return objc_opt_self();
}

uint64_t outlined init with take of (key: AnyHashable, value: AnyHashable)?( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32LL))(a2, a1, v5);
  return a2;
}

uint64_t outlined consume of Mirror?(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
  {
    swift_release(a2);
    return swift_release(a5);
  }

  return result;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<ObjectIdentifier, Int>()
{
  return objc_opt_self();
}

uint64_t outlined release of Mirror(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  swift_release(*(void *)(a1 + 32));
  swift_release(v2);
  return a1;
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>()
{
  return objc_opt_self();
}

uint64_t outlined init with take of Mirror?(uint64_t a1, uint64_t a2)
{
  return initializeWithTake for ClosedRange<>.Index(a2, a1, &unk_189B89D98);
}

void sub_18172D7F0()
{
}

_OWORD *partial apply for closure #1 in Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(unint64_t **)(v2 + 48);
  uint64_t v5 = *a1;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  swift_reflectionMirror_subscript((swift::SwiftError **)(v2 + 16), v4, v5, &v14, &v13, (uint64_t *)&unk_189B8D218, v12);
  uint64_t v6 = v14;
  if (!v14)
  {
    unint64_t v7 = 0LL;
    uint64_t v9 = 0LL;
    uint64_t v10 = v13;
    if (!v13) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  unint64_t v7 = specialized String.init(validatingUTF8:)((uint64_t)v14);
  uint64_t v9 = v8;
  uint64_t v10 = v13;
  if (v13) {
LABEL_3:
  }
    ((void (*)(char *))v10)(v6);
LABEL_4:
  uint64_t result = outlined init with take of Any(v12, (_OWORD *)(a2 + 16));
  *(void *)a2 = v7;
  *(void *)(a2 + 8) = v9;
  return result;
}

void sub_18172D8B8()
{
  if (v0[3])
  {
    swift_release(v0[4]);
    swift_release(v0[7]);
  }

  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 9);
  swift_deallocObject((uint64_t)v0);
}

unint64_t *partial apply for closure #2 in Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>( uint64_t a1@<X8>)
{
  uint64_t v3 = *(uint64_t **)(v1 + 16);
  outlined init with take of Mirror?(v1 + 24, (uint64_t)v27);
  uint64_t v4 = v28;
  uint64_t v5 = v29;
  if (swift_isClassType(v3)) {
    uint64_t result = (unint64_t *)v3;
  }
  else {
    uint64_t result = 0LL;
  }
  if (!result || (uint64_t result = (unint64_t *)_swift_class_getSuperclass((swift *)result)) == 0LL)
  {
    *(_OWORD *)(a1 + 25) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    return result;
  }

  unint64_t v7 = result;
  outlined init with take of Mirror?(v1 + 24, (uint64_t)v30);
  if (!v30[0]) {
    goto LABEL_11;
  }
  uint64_t v11 = v30[1];
  uint64_t v12 = v31;
  uint64_t v14 = v32;
  uint64_t v13 = v33;
  char v15 = v34;
  if ((unint64_t *)v30[0] == v7)
  {
    *(void *)a1 = v7;
    *(void *)(a1 + 8) = v11;
    *(void *)(a1 + 16) = v12;
    *(void *)(a1 + 24) = v14;
    *(void *)(a1 + 32) = v13;
    *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v15;
    goto LABEL_13;
  }

  if (!v34)
  {
LABEL_11:
    outlined init with copy of Any(v1 + 72, (uint64_t)v22);
    outlined init with take of Mirror?(v1 + 24, (uint64_t)v21);
    outlined retain of Mirror?(v1 + 24);
    uint64_t result = Mirror.init(internalReflecting:subjectType:customAncestor:)(&v23, v22, v7, v21);
    uint64_t v16 = v24;
    char v17 = v26;
    *(_OWORD *)a1 = v23;
    *(void *)(a1 + 16) = v16;
    *(_OWORD *)(a1 + 24) = v25;
    *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v17;
    return result;
  }

  *(void *)a1 = v30[0];
  *(void *)(a1 + 8) = v11;
  *(void *)(a1 + 16) = v12;
  *(void *)(a1 + 24) = v14;
  *(void *)(a1 + 32) = v13;
  *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 1;
LABEL_13:
  swift_retain(v4, v8, v9, v10);
  return swift_retain(v5, v18, v19, v20);
}

uint64_t outlined retain of Mirror?(uint64_t a1)
{
  return a1;
}

unint64_t *outlined copy of Mirror?( unint64_t *result, unint64_t *a2, uint64_t a3, char *a4, unint64_t *a5)
{
  if (result)
  {
    swift_retain(a2, (uint64_t)a2, a3, a4);
    return swift_retain(a5, v6, v7, v8);
  }

  return result;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_DictionaryCodingKey>()
{
  return objc_opt_self();
}

uint64_t outlined init with copy of MirrorPath(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t outlined init with copy of (String, Any)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (String, Any));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

void partial apply for closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( const char *a1, uint64_t a2)
{
}

void partial apply for closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)( const char *a1, uint64_t a2)
{
}

uint64_t partial apply for closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)( uint64_t a1, uint64_t a2)
{
  return closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)( a1,  a2,  v2[6],  v2[2],  v2[3],  v2[4],  v2[5]);
}

void sub_18172DBB0()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = *(void *)(v1 - 8);
  unint64_t v3 = (*(unsigned __int8 *)(v2 + 80) + 48LL) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80);
  swift_release(*(void *)(v0 + 32));
  (*(void (**)(unint64_t, uint64_t))(v2 + 8))(v0 + v3, v1);
  swift_deallocObject(v0);
}

void *partial apply for closure #2 in static Mirror._superclassIterator<A>(_:_:)@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *(swift::SwiftError **)(v1 + 16);
  uint64_t v5 = *((void *)v4 - 1);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 80);
  uint64_t v7 = *(uint64_t **)(v1 + 40);
  uint64_t result = (*(void *(**)(uint64_t **__return_ptr))(v1 + 24))(&v21);
  uint64_t v10 = v21;
  uint64_t v9 = v22;
  uint64_t v11 = v23;
  uint64_t v12 = v24;
  uint64_t v13 = v25;
  char v14 = v26;
  if (v21 != v7 && (v26 & 1) == 0)
  {
    uint64_t v15 = v2 + ((v6 + 48) & ~v6);
    v20[3] = v4;
    uint64_t v16 = v22;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v20);
    (*(void (**)(void *, uint64_t, swift::SwiftError *))(v5 + 16))(boxed_opaque_existential_0Tm, v15, v4);
    v18[0] = v10;
    v18[1] = v16;
    void v18[2] = v11;
    v18[3] = v12;
    v18[4] = v13;
    char v19 = 0;
    uint64_t result = (void *)Mirror.init(internalReflecting:subjectType:customAncestor:)(v20, v7, (uint64_t)v18, (uint64_t)&v21);
    uint64_t v10 = v21;
    uint64_t v9 = v22;
    LODWORD(v11) = v23;
    uint64_t v12 = v24;
    uint64_t v13 = v25;
    char v14 = v26;
  }

  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v11;
  *(void *)(a1 + 24) = v12;
  *(void *)(a1 + 32) = v13;
  *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v14;
  return result;
}

void sub_18172DD10()
{
}

double partial apply for closure #1 in static Mirror._superclassIterator<A>(_:_:)@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = *(swift::SwiftError **)(v1 + 16);
  uint64_t v4 = *((void *)v3 - 1);
  unint64_t v5 = (*(unsigned __int8 *)(v4 + 80) + 24LL) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = v1 + v5;
  uint64_t v7 = *(uint64_t **)(v1 + ((*(void *)(v4 + 64) + v5 + 7) & 0xFFFFFFFFFFFFF8LL));
  v13[3] = v3;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v13);
  (*(void (**)(void *, uint64_t, swift::SwiftError *))(v4 + 16))(boxed_opaque_existential_0Tm, v6, v3);
  memset(v12, 0, 41);
  Mirror.init(internalReflecting:subjectType:customAncestor:)(v13, v7, (uint64_t)v12, (uint64_t)&v14);
  uint64_t v9 = v15;
  char v10 = v17;
  *(_OWORD *)a1 = v14;
  *(void *)(a1 + 16) = v9;
  double result = *(double *)&v16;
  *(_OWORD *)(a1 + 24) = v16;
  *(_BYTE *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v10;
  return result;
}

void sub_18172DE30()
{
}

uint64_t __swift_instantiateGenericMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6[0] = a2;
  v6[1] = a3;
  void v6[2] = a4;
  return swift_getGenericMetadata(a1, v6, a5);
}

uint64_t __swift_instantiateCanonicalPrespecializedGenericMetadata( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, dispatch_once_t *a6)
{
  v7[0] = a2;
  v7[1] = a3;
  void v7[2] = a4;
  return swift_getCanonicalPrespecializedGenericMetadata(a1, (uint64_t)v7, a5, a6);
}

unint64_t *type metadata completion function for Zip2Sequence(uint64_t a1)
{
  double result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(result - 1) + 64;
    double result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[1] = *(result - 1) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, (char *)v5, a1 + 48);
      return 0LL;
    }
  }

  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for Zip2Sequence( unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v6 = a1;
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t v8 = *(void *)(a3 + 24);
  uint64_t v9 = *(void *)(v7 - 8);
  uint64_t v10 = *(void *)(v8 - 8);
  uint64_t v11 = *(_DWORD *)(v10 + 80);
  uint64_t v12 = *(void *)(v9 + 64) + v11;
  uint64_t v13 = (*(_BYTE *)(v9 + 80) | *(_BYTE *)(v10 + 80));
  if (v13 > 7
    || ((*(_DWORD *)(v9 + 80) | *(_DWORD *)(v10 + 80)) & 0x100000) != 0
    || (v12 & (unint64_t)~v11) + *(void *)(v10 + 64) > 0x18)
  {
    __int128 v16 = *a2;
    *uint64_t v6 = *a2;
    uint64_t v6 = (unint64_t **)((char *)v16 + ((v13 + 16) & ~v13));
    swift_retain(v16, (uint64_t)a2, v7, a4);
  }

  else
  {
    uint64_t v17 = ~v11;
    (*(void (**)(unint64_t **, unint64_t **))(v9 + 16))(a1, a2);
    (*(void (**)(unint64_t, unint64_t, uint64_t))(v10 + 16))( ((unint64_t)v6 + v12) & v17,  ((unint64_t)a2 + v12) & v17,  v8);
  }

  return v6;
}

uint64_t destroy for Zip2Sequence(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(a2 + 16) - 8LL);
  (*(void (**)(void))(v4 + 8))();
  return (*(uint64_t (**)(unint64_t))(*(void *)(*(void *)(a2 + 24) - 8LL) + 8LL))((*(void *)(v4 + 64) + a1 + *(unsigned __int8 *)(*(void *)(*(void *)(a2 + 24) - 8LL) + 80LL)) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 24) - 8LL) + 80LL));
}

uint64_t initializeWithCopy for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 16))();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v7 + 16))( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t assignWithCopy for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 24))();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v7 + 24))( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t initializeWithTake for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 32))();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v7 + 32))( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t assignWithTake for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 40))();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v7 + 40))( (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80),  (*(void *)(v6 + 64) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t getEnumTagSinglePayload for Zip2Sequence(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(void *)(*(void *)(a3 + 24) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= v5) {
    unsigned int v8 = *(_DWORD *)(v4 + 84);
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = *(void *)(v4 + 64) + v9;
  unsigned int v11 = a2 - v8;
  if (a2 <= v8) {
    goto LABEL_23;
  }
  uint64_t v12 = (v10 & ~v9) + *(void *)(v6 + 64);
  char v13 = 8 * v12;
  if (v12 <= 3)
  {
    unsigned int v15 = ((v11 + ~(-1 << v13)) >> v13) + 1;
    if (HIWORD(v15))
    {
      int v14 = *(_DWORD *)(a1 + v12);
      if (!v14) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v15 > 0xFF)
    {
      int v14 = *(unsigned __int16 *)(a1 + v12);
      if (!*(_WORD *)(a1 + v12)) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }

    if (v15 < 2)
    {
LABEL_23:
      if (v8)
      {
        if (v5 >= v7) {
          return (*(uint64_t (**)(void))(v4 + 48))();
        }
        else {
          return (*(uint64_t (**)(uint64_t))(v6 + 48))((v10 + a1) & ~v9);
        }
      }

      return 0LL;
    }
  }

  int v14 = *(unsigned __int8 *)(a1 + v12);
  if (!*(_BYTE *)(a1 + v12)) {
    goto LABEL_23;
  }
LABEL_14:
  int v16 = (v14 - 1) << v13;
  if (!(_DWORD)v12) {
    return v8 + v16 + 1;
  }
  else {
    int v17 = 4;
  }
  return ((uint64_t (*)(void))((char *)&loc_18172E2F4 + 4 * byte_18180060A[v17 - 1]))();
}

void storeEnumTagSinglePayload for Zip2Sequence(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 16) - 8LL);
  uint64_t v6 = *(void *)(*(void *)(a4 + 24) - 8LL);
  if (*(_DWORD *)(v6 + 84) <= *(_DWORD *)(v5 + 84)) {
    unsigned int v7 = *(_DWORD *)(v5 + 84);
  }
  else {
    unsigned int v7 = *(_DWORD *)(v6 + 84);
  }
  if (a3 > v7)
  {
    if (v8 <= 3)
    {
      unsigned int v11 = ((a3 - v7 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (HIWORD(v11))
      {
        unsigned int v9 = 4u;
      }

      else if (v11 >= 0x100)
      {
        unsigned int v9 = 2;
      }

      else
      {
        unsigned int v9 = v11 > 1;
      }
    }

    else
    {
      unsigned int v9 = 1u;
    }
  }

  else
  {
    unsigned int v9 = 0u;
  }

  if (v7 < a2)
  {
    unsigned int v10 = ~v7 + a2;
    if (v8 < 4)
    {
      if ((_DWORD)v8)
      {
        int v12 = v10 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if ((_DWORD)v8 == 3)
        {
          *a1 = v12;
          *((_BYTE *)a1 + 2) = BYTE2(v12);
        }

        else if ((_DWORD)v8 == 2)
        {
          *a1 = v12;
        }

        else
        {
          *(_BYTE *)a1 = v12;
        }
      }
    }

    else
    {
      bzero(a1, v8);
      *(_DWORD *)a1 = v10;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X16 }

uint64_t type metadata accessor for _TeeStream(const char *a1, uint64_t a2)
{
  return swift_getCanonicalPrespecializedGenericMetadata( a1,  a2,  &nominal type descriptor for _TeeStream,  &flag for loading of canonical specialized generic type metadata for _TeeStream);
}

uint64_t getEnumTagSinglePayload for _MergeError(unsigned int *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  else {
    int v2 = 2;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4) {
    return *a1;
  }
  if (v3 == 2) {
    return *(unsigned __int16 *)a1;
  }
  return *(unsigned __int8 *)a1;
}

uint64_t storeEnumTagSinglePayload for _MergeError(uint64_t a1, int a2, int a3)
{
  else {
    int v3 = 2;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2) {
    return ((uint64_t (*)(void))((char *)sub_18172E61C + 4 * byte_181800618[v4]))();
  }
  else {
    return ((uint64_t (*)(void))((char *)sub_18172E63C + 4 * byte_18180061D[v4]))();
  }
}

_BYTE *sub_18172E61C(_BYTE *result, char a2)
{
  *double result = a2;
  return result;
}

_BYTE *sub_18172E63C(_BYTE *result)
{
  *double result = 0;
  return result;
}

_DWORD *sub_18172E644(_DWORD *result, int a2)
{
  *double result = a2;
  return result;
}

_WORD *sub_18172E64C(_WORD *result, __int16 a2)
{
  *double result = a2;
  return result;
}

_WORD *sub_18172E654(_WORD *result)
{
  *double result = 0;
  return result;
}

_DWORD *sub_18172E65C(_DWORD *result)
{
  *double result = 0;
  return result;
}

void *type metadata accessor for _ApplicationError()
{
  return &unk_189B897A8;
}

void *type metadata accessor for _V()
{
  return &unk_189B897D0;
}

unint64_t *type metadata completion function for _FixedArray16(uint64_t a1)
{
  double result = swift_checkMetadataState((const char *)0x13F, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = (uint64_t *)(*(result - 1) + 64);
    p_size = v4;
    uint64_t v6 = v4;
    unsigned int v7 = v4;
    size_t v8 = v4;
    unsigned int v9 = v4;
    unsigned int v10 = v4;
    unsigned int v11 = v4;
    int v12 = v4;
    char v13 = v4;
    int v14 = v4;
    unsigned int v15 = v4;
    int v16 = v4;
    int v17 = v4;
    uint64_t v18 = v4;
    char v19 = v4;
    swift_getTupleTypeLayout((uint64_t)v20, 0LL, 0x10u, (uint64_t)&v4);
    uint64_t v4 = (uint64_t *)v20;
    p_size = &value witness table for Builtin.Int8.size;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)&v4, a1 + 24);
    return 0LL;
  }

  return result;
}

void *initializeBufferWithCopyOfBuffer for _FixedArray16(void *a1, void *a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(_DWORD *)(v7 + 80);
  uint64_t v9 = ~v8;
  BOOL v10 = v8 <= 7 && (*(_DWORD *)(v7 + 80) & 0x100000) == 0;
  if (v10
    && (uint64_t v11 = *(void *)(v7 + 64),
        uint64_t v12 = v11 + v8,
        uint64_t v13 = ((v11
              + v8
              + ((v11
                + v8
                + ((v11
                  + v8
                  + ((v11
                    + v8
                    + ((v11
                      + v8
                      + ((v11
                        + v8
                        + ((v11
                          + v8
                          + ((v11
                            + v8
                            + ((v11
                              + v8
                              + ((v11
                                + v8
                                + ((v11
                                  + v8
                                  + ((v11 + v8 + ((v11 + v8 + ((v11 + v8 + ((v11 + v8) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)
            + v11,
        (unint64_t)(v13 + 1) <= 0x18))
  {
    int v14 = *(void (**)(void *, void *, uint64_t))(v7 + 16);
    v14(a1, a2, *(void *)(a3 + 16));
    v14((void *)(((unint64_t)v5 + v12) & v9), (void *)(((unint64_t)a2 + v12) & v9), v6);
    unint64_t v15 = (v12 + (((unint64_t)a2 + v12) & v9)) & v9;
    v14((void *)((v12 + (((unint64_t)v5 + v12) & v9)) & v9), (void *)v15, v6);
    unint64_t v16 = (v12 + v15) & v9;
    v14((void *)((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9), (void *)v16, v6);
    unint64_t v17 = (v12 + v16) & v9;
    v14((void *)((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9), (void *)v17, v6);
    uint64_t v18 = (v12 + v17) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v18,  v6);
    uint64_t v19 = (v12 + v18) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v19,  v6);
    uint64_t v20 = (v12 + v19) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v20,  v6);
    uint64_t v21 = (v12 + v20) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v21,  v6);
    uint64_t v22 = (v12 + v21) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v22,  v6);
    uint64_t v23 = (v12 + v22) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v23,  v6);
    uint64_t v24 = (v12 + v23) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v24,  v6);
    uint64_t v25 = (v12 + v24) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v25,  v6);
    uint64_t v26 = (v12 + v25) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v26,  v6);
    uint64_t v27 = (v12 + v26) & v9;
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)v27,  v6);
    v14( (void *)((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + ((v12 + (((unint64_t)v5 + v12) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9),  (void *)((v12 + v27) & v9),  v6);
    *((_BYTE *)v5 + v13) = *((_BYTE *)a2 + v13);
  }

  else
  {
    uint64_t v28 = (unint64_t *)*a2;
    *uint64_t v5 = *a2;
    uint64_t v5 = (unint64_t *)((char *)v28 + ((v8 + 16) & v9));
    swift_retain(v28, (uint64_t)a2, a3, a4);
  }

  return v5;
}

uint64_t destroy for _FixedArray16(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v23 = *(void (**)(uint64_t, uint64_t))(v4 + 8);
  v23(a1, v3);
  uint64_t v5 = *(void *)(v4 + 64);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v7 = v5 + v6;
  uint64_t v8 = (v5 + v6 + a1) & ~v6;
  v23(v8, v3);
  uint64_t v9 = (v7 + v8) & ~v6;
  v23(v9, v3);
  uint64_t v10 = (v7 + v9) & ~v6;
  v23(v10, v3);
  uint64_t v11 = (v7 + v10) & ~v6;
  v23(v11, v3);
  uint64_t v12 = (v7 + v11) & ~v6;
  v23(v12, v3);
  uint64_t v13 = (v7 + v12) & ~v6;
  v23(v13, v3);
  uint64_t v14 = (v7 + v13) & ~v6;
  v23(v14, v3);
  uint64_t v15 = (v7 + v14) & ~v6;
  v23(v15, v3);
  uint64_t v16 = (v7 + v15) & ~v6;
  v23(v16, v3);
  uint64_t v17 = (v7 + v16) & ~v6;
  v23(v17, v3);
  uint64_t v18 = (v7 + v17) & ~v6;
  v23(v18, v3);
  uint64_t v19 = (v7 + v18) & ~v6;
  v23(v19, v3);
  uint64_t v20 = (v7 + v19) & ~v6;
  v23(v20, v3);
  uint64_t v21 = (v7 + v20) & ~v6;
  v23(v21, v3);
  return ((uint64_t (*)(uint64_t, uint64_t))v23)((v7 + v21) & ~v6, v3);
}

uint64_t initializeWithCopy for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v16,  v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v17,  v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v18,  v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v19,  v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v20,  v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v21,  v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v22,  v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v23,  v5);
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  (v10 + v23) & ~v9,  v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(_BYTE *)(v24 + a1) = *(_BYTE *)(v24 + a2);
  return a1;
}

uint64_t assignWithCopy for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 24);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v16,  v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v17,  v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v18,  v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v19,  v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v20,  v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v21,  v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v22,  v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v23,  v5);
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  (v10 + v23) & ~v9,  v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(_BYTE *)(v24 + a1) = *(_BYTE *)(v24 + a2);
  return a1;
}

uint64_t initializeWithTake for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v16,  v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v17,  v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v18,  v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v19,  v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v20,  v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v21,  v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v22,  v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v23,  v5);
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  (v10 + v23) & ~v9,  v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(_BYTE *)(v24 + a1) = *(_BYTE *)(v24 + a2);
  return a1;
}

uint64_t assignWithTake for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 40);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v16,  v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v17,  v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v18,  v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v19,  v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v20,  v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v21,  v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v22,  v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  v23,  v5);
  v7( (v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9,  (v10 + v23) & ~v9,  v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(_BYTE *)(v24 + a1) = *(_BYTE *)(v24 + a2);
  return a1;
}

uint64_t getEnumTagSinglePayload for _FixedArray16(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  unsigned int v6 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_18;
  }
  uint64_t v7 = *(void *)(v4 + 64);
  uint64_t v8 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v9 = v7
     + ((v7
       + v8
       + ((v7
         + v8
         + ((v7
           + v8
           + ((v7
             + v8
             + ((v7
               + v8
               + ((v7
                 + v8
                 + ((v7
                   + v8
                   + ((v7
                     + v8
                     + ((v7
                       + v8
                       + ((v7
                         + v8
                         + ((v7 + v8 + ((v7 + v8 + ((v7 + v8 + ((v7 + v8 + ((v7 + v8) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)
     + 1;
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v12 = ((v6 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      int v11 = *(_DWORD *)(a1 + v9);
      if (!v11) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v12 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)(a1 + v9);
      if (!*(_WORD *)(a1 + v9)) {
        goto LABEL_18;
      }
      goto LABEL_11;
    }

    if (v12 < 2)
    {
LABEL_18:
      if (v5) {
        return (*(uint64_t (**)(void))(v4 + 48))();
      }
      return 0LL;
    }
  }

  int v11 = *(unsigned __int8 *)(a1 + v9);
  if (!*(_BYTE *)(a1 + v9)) {
    goto LABEL_18;
  }
LABEL_11:
  int v13 = (v11 - 1) << v10;
  if (!(_DWORD)v9) {
    return v5 + v13 + 1;
  }
  return ((uint64_t (*)(void))((char *)&loc_18172F824 + 4 * byte_181800622[(v9 - 1)]))();
}

void storeEnumTagSinglePayload for _FixedArray16(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  size_t v10 = v8
      + ((v8
        + v9
        + ((v8
          + v9
          + ((v8
            + v9
            + ((v8
              + v9
              + ((v8
                + v9
                + ((v8
                  + v9
                  + ((v8
                    + v9
                    + ((v8
                      + v9
                      + ((v8
                        + v9
                        + ((v8
                          + v9
                          + ((v8 + v9 + ((v8 + v9 + ((v8 + v9 + ((v8 + v9 + ((v8 + v9) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + 1;
  BOOL v11 = a3 >= v7;
  unsigned int v12 = a3 - v7;
  if (v12 != 0 && v11)
  {
    if (v10 <= 3)
    {
      unsigned int v15 = ((v12 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
      if (HIWORD(v15))
      {
        unsigned int v13 = 4u;
      }

      else if (v15 >= 0x100)
      {
        unsigned int v13 = 2;
      }

      else
      {
        unsigned int v13 = v15 > 1;
      }
    }

    else
    {
      unsigned int v13 = 1u;
    }
  }

  else
  {
    unsigned int v13 = 0u;
  }

  if (v7 < a2)
  {
    unsigned int v14 = ~v7 + a2;
    if (v10 < 4)
    {
      if ((_DWORD)v8
         + (((_DWORD)v8
           + (_DWORD)v9
           + (((_DWORD)v8
             + (_DWORD)v9
             + (((_DWORD)v8
               + (_DWORD)v9
               + (((_DWORD)v8
                 + (_DWORD)v9
                 + (((_DWORD)v8
                   + (_DWORD)v9
                   + (((_DWORD)v8
                     + (_DWORD)v9
                     + (((_DWORD)v8
                       + (_DWORD)v9
                       + (((_DWORD)v8
                         + (_DWORD)v9
                         + (((_DWORD)v8
                           + (_DWORD)v9
                           + (((_DWORD)v8
                             + (_DWORD)v9
                             + (((_DWORD)v8
                               + (_DWORD)v9
                               + (((_DWORD)v8
                                 + (_DWORD)v9
                                 + (((_DWORD)v8
                                   + (_DWORD)v9
                                   + (((_DWORD)v8 + (_DWORD)v9 + (((_DWORD)v8 + (_DWORD)v9) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9)) & ~(_DWORD)v9) != -1)
      {
        int v16 = v14 & ~(-1 << (8 * v10));
        bzero(a1, v10);
        if ((_DWORD)v10 == 3)
        {
          *a1 = v16;
          *((_BYTE *)a1 + 2) = BYTE2(v16);
        }

        else if ((_DWORD)v10 == 2)
        {
          *a1 = v16;
        }

        else
        {
          *(_BYTE *)a1 = v16;
        }
      }
    }

    else
    {
      bzero(a1, v10);
      *(_DWORD *)a1 = v14;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X11 }

uint64_t type metadata accessor for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _FixedArray16);
}

uint64_t getEnumTagSinglePayload for KeyPathComponent(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 56)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *(void *)(a1 + 8) >> 2;
  else {
    int v3 = -1;
  }
  return (v3 + 1);
}

double storeEnumTagSinglePayload for KeyPathComponent(uint64_t a1, int a2, int a3)
{
  if (a2 < 0)
  {
    double result = 0.0;
    *(_OWORD *)(a1 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    *(void *)a1 = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(a1 + 56) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)a1 = 0LL;
      *(void *)(a1 + 8) = 4LL * -a2;
      double result = 0.0;
      *(_OWORD *)(a1 + 16) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
      *(void *)(a1 + 48) = 0LL;
      return result;
    }

    *(_BYTE *)(a1 + 56) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t getEnumTag for KeyPathComponent(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8) >> 61;
  else {
    return (*(_DWORD *)a1 + 5);
  }
}

uint64_t destructiveProjectEnumData for KeyPathComponent(uint64_t result)
{
  *(void *)(result + 8) &= 0x1FFFFFFFFFFFFFFFuLL;
  return result;
}

uint64_t destructiveInjectEnumTag for KeyPathComponent(uint64_t result, uint64_t a2)
{
  if (a2 < 5)
  {
    *(void *)(result + 8) = *(void *)(result + 8) & 3LL | (a2 << 61);
  }

  else
  {
    *(void *)double result = (a2 - 5);
    *(void *)(result + 8) = 0xA000000000000000LL;
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(void *)(result + 48) = 0LL;
  }

  return result;
}

ValueMetadata *type metadata accessor for KeyPathComponent()
{
  return &type metadata for KeyPathComponent;
}

ValueMetadata *type metadata accessor for Unicode._NormData()
{
  return &type metadata for Unicode._NormData;
}

uint64_t getEnumTagSinglePayload for Dictionary.Index(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 17)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 <= 1) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for Dictionary.Index(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_BYTE *)(result + 16) = 0;
    *(void *)double result = a2 - 255;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 17) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 17) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 16) = -(char)a2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for UTF8ValidationResult()
{
  return &type metadata for UTF8ValidationResult;
}

uint64_t storeEnumTagSinglePayload for _WordQuestion(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)double result = 0LL;
    *(void *)(result + 8) = 0LL;
    *(_BYTE *)(result + 16) = 0;
    *(_DWORD *)double result = a2 - 1;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 17) = v3;
  return result;
}

uint64_t getEnumTag for _WordQuestion(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t destructiveInjectEnumTag for _WordQuestion(uint64_t result, int a2)
{
  if (a2)
  {
    *(void *)double result = (a2 - 1);
    *(void *)(result + 8) = 0LL;
    *(_BYTE *)(result + 16) = 1;
  }

  else
  {
    *(_BYTE *)(result + 16) = 0;
  }

  return result;
}

ValueMetadata *type metadata accessor for _WordQuestion()
{
  return &type metadata for _WordQuestion;
}

ValueMetadata *type metadata accessor for _UInt128.Words()
{
  return &type metadata for _UInt128.Words;
}

ValueMetadata *type metadata accessor for _Int128.Words()
{
  return &type metadata for _Int128.Words;
}

ValueMetadata *type metadata accessor for _UInt128()
{
  return &type metadata for _UInt128;
}

uint64_t initializeBufferWithCopyOfBuffer for Unicode._NormDataBuffer( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  return a1;
}

uint64_t assignWithCopy for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v6 = *(void *)a2;
  uint64_t v7 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  return a1;
}

uint64_t assignWithTake for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NormDataBuffer(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *((_BYTE *)a1 + 9)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NormDataBuffer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_BYTE *)(result + 8) = 0;
    *(void *)double result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 9) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)double result = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 9) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for Unicode._NormDataBuffer()
{
  return &type metadata for Unicode._NormDataBuffer;
}

uint64_t getEnumTagSinglePayload for RawKeyPathComponent(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for RawKeyPathComponent(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)double result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 24) = v3;
  return result;
}

ValueMetadata *type metadata accessor for RawKeyPathComponent()
{
  return &type metadata for RawKeyPathComponent;
}

ValueMetadata *type metadata accessor for RawKeyPathComponent.Header()
{
  return &type metadata for RawKeyPathComponent.Header;
}

uint64_t getEnumTagSinglePayload for KeyPathComponent.ArgumentRef(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 != 1 && *(_BYTE *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)(a1 + 16)) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for KeyPathComponent.ArgumentRef( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)double result = a2 - 2;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 2) {
      *(_BYTE *)(result + 32) = 1;
    }
  }

  else
  {
    if (a3 >= 2) {
      *(_BYTE *)(result + 32) = 0;
    }
    if (a2) {
      *(void *)(result + 16) = 0LL;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for KeyPathComponent.ArgumentRef()
{
  return &type metadata for KeyPathComponent.ArgumentRef;
}

ValueMetadata *type metadata accessor for ComputedAccessorsPtr()
{
  return &type metadata for ComputedAccessorsPtr;
}

uint64_t getEnumTagSinglePayload for ComputedPropertyID(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 9)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 8);
  BOOL v4 = v3 >= 3;
  int v5 = v3 - 3;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for ComputedPropertyID(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_BYTE *)(result + 8) = 0;
    *(void *)double result = a2 - 254;
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 9) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 9) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 8) = a2 + 2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for ComputedPropertyID()
{
  return &type metadata for ComputedPropertyID;
}

uint64_t getEnumTagSinglePayload for Bool(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

uint64_t storeEnumTagSinglePayload for Bool(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFE) {
    return ((uint64_t (*)(void))((char *)&loc_181730114 + 4 * byte_181800635[v4]))();
  }
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_181730148 + 4 * byte_181800630[v4]))();
}

uint64_t sub_181730148(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_181730150(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x181730158LL);
  }
  return result;
}

uint64_t sub_181730164(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x18173016CLL);
  }
  *(_BYTE *)double result = a2 + 1;
  return result;
}

uint64_t sub_181730170(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_181730178(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for UTF8ExtraInfo()
{
  return &type metadata for UTF8ExtraInfo;
}

uint64_t getEnumTagSinglePayload for AutoreleasingUnsafeMutablePointer(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 != 1 && *(_BYTE *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for AutoreleasingUnsafeMutablePointer( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)double result = a2 - 2;
    if (a3 >= 2) {
      *(_BYTE *)(result + 8) = 1;
    }
  }

  else
  {
    if (a3 >= 2) {
      *(_BYTE *)(result + 8) = 0;
    }
    if (a2) {
      *(void *)double result = 0LL;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for ComputedArgumentWitnessesPtr()
{
  return &type metadata for ComputedArgumentWitnessesPtr;
}

uint64_t getEnumTagSinglePayload for Unicode.NumericType(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }

uint64_t storeEnumTagSinglePayload for Unicode.NumericType(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFD) {
    return ((uint64_t (*)(void))((char *)&loc_181730308 + 4 * byte_18180063F[v4]))();
  }
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_18173033C + 4 * byte_18180063A[v4]))();
}

uint64_t sub_18173033C(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_181730344(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x18173034CLL);
  }
  return result;
}

uint64_t sub_181730358(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x181730360LL);
  }
  *(_BYTE *)double result = a2 + 2;
  return result;
}

uint64_t sub_181730364(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18173036C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for KeyPathComputedIDKind()
{
  return &type metadata for KeyPathComputedIDKind;
}

uint64_t closure #1 in Substring.withUnsafeBytes<A>(_:)partial apply(uint64_t a1, uint64_t a2)
{
  return partial apply for closure #1 in Substring.withUnsafeBytes<A>(_:)(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring.UnicodeScalarView( a1,  a2);
}

uint64_t withUnsafeMutablePointer<A, B>(to:_:)(uint64_t a1, uint64_t (*a2)(void))
{
  return withUnsafePointer<A, B>(to:_:)(a1, a2);
}

void *thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply( uint64_t a1)
{
  return partial apply for specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)(a1);
}

void preconditionFailure(_:file:line:)( uint64_t (*a1)(void), uint64_t a2, const char *a3, uint64_t a4, char a5, unint64_t a6)
{
}

uint64_t closure #1 in String.init<A, B>(decoding:as:)partial apply@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return partial apply for closure #1 in String.init<A, B>(decoding:as:)(a1, a2, a3);
}

uint64_t closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)partial apply@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)(a1, a2, a3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _CocoaArrayWrapper@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int.Words(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Unicode.Scalar.UTF16View@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _ValidUTF8Buffer.Iterator( a1,  a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UInt8.Words@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int8.Words(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UInt16.Words@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int16.Words(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _UnsafeBitset@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance String.UnicodeScalarView( a1,  a2);
}

void ContiguousArray.__specialize_append(_:)(uint64_t a1, uint64_t a2)
{
}

uint64_t protocol witness for Decodable.init(from:) in conformance <> PartialRangeThrough<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for Decodable.init(from:) in conformance <> PartialRangeFrom<A>(a1, a2, a3, a4);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> Range<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Encodable.encode(to:) in conformance <> ClosedRange<A>(a1, a2, a3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> PartialRangeThrough<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Encodable.encode(to:) in conformance <> PartialRangeFrom<A>(a1, a2, a3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeBufferPointer<A>( a1,  a2,  a3);
}

uint64_t swift::getOverride_dynamicCast(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastClass(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastClassUnconditional(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastUnknownClass(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastUnknownClassUnconditional(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastMetatype(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastMetatypeUnconditional(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClassMetatype(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClassMetatypeUnconditional(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_conformsToProtocol(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_conformsToProtocol2(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_conformsToProtocolCommon(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_getKeyPath(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_getTypeByMangledNode(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_getTypeByMangledName(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_getAssociatedTypeWitnessSlow(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_getAssociatedConformanceWitnessSlow(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClass(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClassUnconditional(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClassMetatype(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClassMetatypeUnconditional(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClass(swift *this)
{
  else {
    return 0LL;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClassUnconditional(swift *this)
{
  else {
    return 0LL;
  }
}

uint8_t *getOverrideSectionPtr(void)::$_0::__invoke()
{
  uint64_t v0 = _NSGetMachExecuteHeader();
  double result = getsectiondata(v0, "__DATA", "__swift60_hooks", &size);
  if (size >= 0xC0 || result == 0LL) {
    uint64_t v3 = (uint64_t)result;
  }
  else {
    uint64_t v3 = 0LL;
  }
  getOverrideSectionPtr(void)::OverrideSectionPtr = v3;
  return result;
}

uint64_t (***swift::hashable_support::findHashableBaseTypeOfHashableType(uint64_t a1))()
{
  do
    unsigned int v2 = __ldaxr((unsigned int *)&HashableConformances);
  while (__stxr(v2 + 1, (unsigned int *)&HashableConformances));
  do
  {
    unint64_t v3 = atomic_load(&qword_18C476928);
    unint64_t v4 = atomic_load((unint64_t *)&qword_18C476930);
    unsigned int v5 = atomic_load((unsigned int *)&dword_18C476924);
    unint64_t v6 = atomic_load(&qword_18C476928);
  }

  while (v3 != v6);
  uint64_t v31 = a1;
  if (v3) {
    BOOL v7 = v4 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7 && v5 != 0)
  {
    if (v9)
    {
      ConformingSuperclass = *(uint64_t (****)())(v9 + 8);
      do
        unsigned int v11 = __ldxr((unsigned int *)&HashableConformances);
      while (__stlxr(v11 - 1, (unsigned int *)&HashableConformances));
      return ConformingSuperclass;
    }
  }

  do
    unsigned int v12 = __ldxr((unsigned int *)&HashableConformances);
  while (__stlxr(v12 - 1, (unsigned int *)&HashableConformances));
  unsigned int v13 = (uint64_t *)swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for Hashable);
  ConformingSuperclass = swift::findConformingSuperclass(a1, *v13);
  uint64_t v31 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_18C476938);
  uint64_t v14 = qword_18C476930;
  unsigned int v15 = (unsigned __int8 *)(qword_18C476930 & 0xFFFFFFFFFFFFFFFCLL);
  if ((qword_18C476930 & 3) == 0 || v15 == 0LL) {
    int v17 = 4;
  }
  else {
    int v17 = *v15;
  }
  unint64_t v18 = dword_18C476924;
  uint64_t v19 = (_DWORD *)qword_18C476928;
  if (!v20)
  {
    uint64_t v30 = (v18 + 1);
    if ((1LL << v17) / (unint64_t)((1LL << v17) - v30) < 4)
    {
      if (!v19)
      {
LABEL_31:
        unint64_t v24 = v18 + (v18 >> 2);
        if (v24 <= v18 + 1) {
          unint64_t v24 = v18 + 1;
        }
        size_t v25 = malloc_good_size((16 * v24) | 8);
        uint64_t v26 = malloc(v25);
        if (!v26) {
          swift::hashable_support::findHashableBaseTypeOfHashableType();
        }
        unint64_t v23 = (unint64_t)v26;
        *uint64_t v26 = (v25 + 0xFFFFFFFF8LL) >> 4;
        if (v19)
        {
          memcpy(v26 + 2, v19 + 2, 16 * v18);
          uint64_t v27 = malloc(0x10uLL);
          *uint64_t v27 = qword_18C476940;
          v27[1] = v19;
          qword_18C476940 = (uint64_t)v27;
        }

        atomic_store(v23, &qword_18C476928);
LABEL_37:
        unint64_t v28 = v23 + 16 * v18;
        *(void *)(v28 + 8) = a1;
        *(void *)(v28 + 16) = ConformingSuperclass;
        atomic_store(v30, (unsigned int *)&dword_18C476924);
        __asm { BR              X11 }
      }
    }

    else
    {
      if (!v19) {
        goto LABEL_31;
      }
    }

    unint64_t v23 = (unint64_t)v19;
    goto LABEL_31;
  }

  __dmb(0xBu);
  if (!HashableConformances)
  {
    uint64_t v21 = (void **)qword_18C476940;
    if (qword_18C476940)
    {
      do
      {
        uint64_t v22 = (void **)*v21;
        free(v21[1]);
        free(v21);
        uint64_t v21 = v22;
      }

      while (v22);
    }

    qword_18C476940 = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476938);
  return ConformingSuperclass;
}

uint64_t (***swift::hashable_support::findHashableBaseType(uint64_t a1))()
{
  do
    unsigned int v2 = __ldaxr((unsigned int *)&HashableConformances);
  while (__stxr(v2 + 1, (unsigned int *)&HashableConformances));
  do
  {
    unint64_t v3 = atomic_load(&qword_18C476928);
    unint64_t v4 = atomic_load((unint64_t *)&qword_18C476930);
    unsigned int v5 = atomic_load((unsigned int *)&dword_18C476924);
    unint64_t v6 = atomic_load(&qword_18C476928);
  }

  while (v3 != v6);
  uint64_t v31 = a1;
  if (v3) {
    BOOL v7 = v4 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7 && v5 != 0)
  {
    if (v9)
    {
      ConformingSuperclass = *(uint64_t (****)())(v9 + 8);
      do
        unsigned int v11 = __ldxr((unsigned int *)&HashableConformances);
      while (__stlxr(v11 - 1, (unsigned int *)&HashableConformances));
      return ConformingSuperclass;
    }
  }

  do
    unsigned int v12 = __ldxr((unsigned int *)&HashableConformances);
  while (__stlxr(v12 - 1, (unsigned int *)&HashableConformances));
  unsigned int v13 = (uint64_t *)swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for Hashable);
  if (!v13) {
    return 0LL;
  }
  ConformingSuperclass = swift::findConformingSuperclass(a1, *v13);
  uint64_t v31 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_18C476938);
  uint64_t v14 = qword_18C476930;
  unsigned int v15 = (unsigned __int8 *)(qword_18C476930 & 0xFFFFFFFFFFFFFFFCLL);
  if ((qword_18C476930 & 3) == 0 || v15 == 0LL) {
    int v17 = 4;
  }
  else {
    int v17 = *v15;
  }
  unint64_t v18 = dword_18C476924;
  uint64_t v19 = (_DWORD *)qword_18C476928;
  if (!v20)
  {
    uint64_t v30 = (v18 + 1);
    if ((1LL << v17) / (unint64_t)((1LL << v17) - v30) < 4)
    {
      if (!v19)
      {
LABEL_33:
        unint64_t v24 = v18 + (v18 >> 2);
        if (v24 <= v18 + 1) {
          unint64_t v24 = v18 + 1;
        }
        size_t v25 = malloc_good_size((16 * v24) | 8);
        uint64_t v26 = malloc(v25);
        if (!v26) {
          swift::hashable_support::findHashableBaseTypeOfHashableType();
        }
        unint64_t v23 = (unint64_t)v26;
        *uint64_t v26 = (v25 + 0xFFFFFFFF8LL) >> 4;
        if (v19)
        {
          memcpy(v26 + 2, v19 + 2, 16 * v18);
          uint64_t v27 = malloc(0x10uLL);
          *uint64_t v27 = qword_18C476940;
          v27[1] = v19;
          qword_18C476940 = (uint64_t)v27;
        }

        atomic_store(v23, &qword_18C476928);
LABEL_39:
        unint64_t v28 = v23 + 16 * v18;
        *(void *)(v28 + 8) = a1;
        *(void *)(v28 + 16) = ConformingSuperclass;
        atomic_store(v30, (unsigned int *)&dword_18C476924);
        __asm { BR              X11 }
      }
    }

    else
    {
      if (!v19) {
        goto LABEL_33;
      }
    }

    unint64_t v23 = (unint64_t)v19;
    goto LABEL_33;
  }

  __dmb(0xBu);
  if (!HashableConformances)
  {
    uint64_t v21 = (void **)qword_18C476940;
    if (qword_18C476940)
    {
      do
      {
        uint64_t v22 = (void **)*v21;
        free(v21[1]);
        free(v21);
        uint64_t v21 = v22;
      }

      while (v22);
    }

    qword_18C476940 = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476938);
  return ConformingSuperclass;
}

uint64_t _swift_makeAnyHashableUpcastingToHashableBaseType( swift **a1, objc_object *a2, uint64_t (***a3)(), uint64_t a4)
{
  while (1)
  {
    int v8 = *a3;
    if (((_DWORD)v8 - 515) >= 2 && (_DWORD)v8 != 773 && (_DWORD)v8 != 0)
    {
      uint64_t v17 = (uint64_t)a1;
      uint64_t v18 = (uint64_t)a2;
      HashableBaseTypeOfHashableType = a3;
      return _swift_makeAnyHashableUsingDefaultRepresentation(v17, v18, (uint64_t)HashableBaseTypeOfHashableType, a4);
    }

    AsSwiftValue = swift::getAsSwiftValue(*a1, a2);
    if (!AsSwiftValue) {
      break;
    }
    uint64_t ValueFromSwiftValue = swift::getValueFromSwiftValue(AsSwiftValue, v11);
    uint64_t v14 = v13;
    uint64_t v15 = swift_conformsToProtocolCommon(ValueFromSwiftValue, (uint64_t)&protocol descriptor for Hashable);
    if (!v15) {
      break;
    }
    a1 = v14;
    a3 = (uint64_t (***)())ValueFromSwiftValue;
    a4 = v15;
  }

  HashableBaseTypeOfHashableType = swift::hashable_support::findHashableBaseTypeOfHashableType((uint64_t)a3);
  uint64_t v17 = (uint64_t)a1;
  uint64_t v18 = (uint64_t)a2;
  return _swift_makeAnyHashableUsingDefaultRepresentation(v17, v18, (uint64_t)HashableBaseTypeOfHashableType, a4);
}

void swift::ConcurrentReadableHashMap<anonymous namespace'::HashableConformanceEntry,swift::LazyMutex>::find<anonymous namespace'::HashableConformanceKey>( uint64_t a1, char a2)
{
  if ((v2 & 1) == 0)
  {
    char v5 = a2;
    a2 = v5;
    if (v3)
    {
      unint64_t v4 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
      if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
        unint64_t v4 = 0xFF51AFD7ED558CCDLL;
      }
      __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v4;
      a2 = v5;
    }
  }

  __asm { BR              X13 }

unint64_t swift::ConcurrentReadableHashMap<anonymous namespace'::HashableConformanceEntry,swift::LazyMutex>::resize( uint64_t a1, int a2)
{
  char v4 = a2 + 1;
  unsigned int v5 = (a2 + 1);
  if (v5 >= 0x11) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = 2;
  }
  if (v5 < 9) {
    size_t v7 = 1LL;
  }
  else {
    size_t v7 = v6;
  }
  unint64_t v8 = (unint64_t)calloc(2LL << a2, v7);
  if (!v8) {
    swift::hashable_support::findHashableBaseTypeOfHashableType();
  }
  if ((_DWORD)v7 != 1)
  {
    if ((_DWORD)v7 == 4) {
      size_t v7 = 3LL;
    }
    else {
      size_t v7 = 2LL;
    }
  }

  unint64_t v9 = v7 | v8;
  *(_BYTE *)unint64_t v8 = v4;
  if (a2) {
    __asm { BR              X0 }
  }

  unint64_t v10 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  atomic_store(v9, (unint64_t *)&qword_18C476930);
  if ((a1 & 3) != 0 && v10)
  {
    unsigned int v11 = malloc(0x10uLL);
    *unsigned int v11 = qword_18C476940;
    v11[1] = v10;
    qword_18C476940 = (uint64_t)v11;
  }

  return v9;
}

char *swift_arrayInitWithCopy(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 1) == 0) {
      return (char *)memcpy(__dst, __src, v9 * a3);
    }
    uint64_t v10 = *(void *)a4;
    if (*(void *)a4 > 0x7FFuLL) {
      LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    }
    if ((int)v10 > 514)
    {
      if ((_DWORD)v10 != 515 && (_DWORD)v10 != 516) {
        goto LABEL_16;
      }
    }

    else if ((v10 - 512) >= 3)
    {
      if (!(_DWORD)v10 && (*(_BYTE *)(a4 + 32) & 2) != 0)
      {
        unsigned int v11 = (uint64_t *)(a4 + 64);
LABEL_14:
        uint64_t v12 = *v11;
        if (v12 && (*(_BYTE *)(v12 + 2) & 0x10) != 0) {
          return (char *)swift::swift_generic_arrayInitWithCopy(__dst, __src, a3, *(void *)(v8 + 72), a4);
        }
      }

char *swift_arrayInitWithTakeNoAlias(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 0x10) != 0)
    {
      uint64_t v10 = 0LL;
      unsigned int v11 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 32);
      do
      {
        __dst = (char *)v11(&v7[v10], &__src[v10], a4);
        v10 += v9;
        --v5;
      }

      while (v5);
    }

    else
    {
      return (char *)memcpy(__dst, __src, v9 * a3);
    }
  }

  return __dst;
}

char *swift_arrayInitWithTakeFrontToBack(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 0x10) != 0)
    {
      uint64_t v10 = 0LL;
      unsigned int v11 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 32);
      do
      {
        __dst = (char *)v11(&v7[v10], &__src[v10], a4);
        v10 += v9;
        --v5;
      }

      while (v5);
    }

    else
    {
      return (char *)memmove(__dst, __src, v9 * a3);
    }
  }

  return __dst;
}

char *swift_arrayInitWithTakeBackToFront(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 0x10) != 0)
    {
      uint64_t v10 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 32);
      uint64_t v11 = v9 * (a3 - 1);
      do
      {
        --v5;
        __dst = (char *)v10(&v7[v11], &__src[v11], a4);
        v11 -= v9;
      }

      while (v5);
    }

    else
    {
      return (char *)memmove(__dst, __src, v9 * a3);
    }
  }

  return __dst;
}

char *swift_arrayAssignWithCopyNoAlias(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 1) == 0) {
      return (char *)memcpy(__dst, __src, v9 * a3);
    }
    uint64_t v10 = *(void *)a4;
    if (*(void *)a4 > 0x7FFuLL) {
      LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    }
    if ((int)v10 > 514)
    {
      if ((_DWORD)v10 != 515 && (_DWORD)v10 != 516) {
        goto LABEL_16;
      }
    }

    else if ((v10 - 512) >= 3)
    {
      if (!(_DWORD)v10 && (*(_BYTE *)(a4 + 32) & 2) != 0)
      {
        uint64_t v11 = (uint64_t *)(a4 + 64);
LABEL_14:
        uint64_t v12 = *v11;
        if (v12 && (*(_BYTE *)(v12 + 2) & 0x10) != 0) {
          return (char *)swift_generic_arrayAssignWithCopy(__dst, __src, a3, *(void *)(v8 + 72), a4);
        }
      }

char *swift_arrayAssignWithCopyFrontToBack(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 1) == 0) {
      return (char *)memmove(__dst, __src, v9 * a3);
    }
    uint64_t v10 = *(void *)a4;
    if (*(void *)a4 > 0x7FFuLL) {
      LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    }
    if ((int)v10 > 514)
    {
      if ((_DWORD)v10 != 515 && (_DWORD)v10 != 516) {
        goto LABEL_16;
      }
    }

    else if ((v10 - 512) >= 3)
    {
      if (!(_DWORD)v10 && (*(_BYTE *)(a4 + 32) & 2) != 0)
      {
        uint64_t v11 = (uint64_t *)(a4 + 64);
LABEL_14:
        uint64_t v12 = *v11;
        if (v12 && (*(_BYTE *)(v12 + 2) & 0x10) != 0) {
          return (char *)swift_generic_arrayAssignWithCopy(__dst, __src, a3, *(void *)(v8 + 72), a4);
        }
      }

char *swift_arrayAssignWithCopyBackToFront(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 1) != 0)
    {
      uint64_t v10 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 24);
      uint64_t v11 = v9 * (a3 - 1);
      do
      {
        --v5;
        __dst = (char *)v10(&v7[v11], &__src[v11], a4);
        v11 -= v9;
      }

      while (v5);
    }

    else
    {
      return (char *)memmove(__dst, __src, v9 * a3);
    }
  }

  return __dst;
}

char *swift_arrayAssignWithTake(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    size_t v7 = __dst;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(_BYTE *)(v8 + 82) & 0x11) != 0)
    {
      uint64_t v10 = 0LL;
      uint64_t v11 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 40);
      do
      {
        __dst = (char *)v11(&v7[v10], &__src[v10], a4);
        v10 += v9;
        --v5;
      }

      while (v5);
    }

    else
    {
      return (char *)memcpy(__dst, __src, v9 * a3);
    }
  }

  return __dst;
}

void swift_arrayDestroy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a3 - 8);
    if ((*(_BYTE *)(v4 + 82) & 1) != 0)
    {
      uint64_t v5 = a2;
      uint64_t v6 = a1;
      uint64_t v7 = *(void *)(v4 + 72);
      uint64_t v8 = *(void *)a3;
      if (*(void *)a3 > 0x7FFuLL) {
        LODWORD(v8) = 0;
      }
      if ((int)v8 > 514)
      {
        if ((_DWORD)v8 != 515 && (_DWORD)v8 != 516) {
          goto LABEL_15;
        }
      }

      else if ((v8 - 512) >= 3)
      {
        if (!(_DWORD)v8 && (*(_BYTE *)(a3 + 32) & 2) != 0)
        {
          uint64_t v9 = (uint64_t *)(a3 + 64);
LABEL_13:
          uint64_t v10 = *v9;
          if (v10 && (*(_BYTE *)(v10 + 2) & 0x10) != 0)
          {
            swift::swift_generic_arrayDestroy(a1, a2, *(void *)(v4 + 72), a3);
            return;
          }

          goto LABEL_15;
        }

        do
        {
LABEL_15:
          (*(void (**)(uint64_t, uint64_t))(v4 + 8))(v6, a3);
          v6 += v7;
          --v5;
        }

        while (v5);
        return;
      }

      uint64_t v9 = (uint64_t *)(a3 + 8);
      goto LABEL_13;
    }
  }

double swift_autoDiffCreateLinearMapContext(uint64_t a1)
{
  __int16 v1 = malloc(a1 + 192);
  void *v1 = &unk_18C565A18;
  v1[1] = 3LL;
  v1[2] = 0LL;
  void v1[3] = 0LL;
  v1[4] = v1 + 6;
  *(void *)&double result = 0x400000000LL;
  v1[5] = 0x400000000LL;
  v1[12] = 0LL;
  v1[10] = v1 + 12;
  v1[11] = 0LL;
  v1[13] = 1LL;
  v1[14] = v1 + 16;
  v1[15] = 0x400000000LL;
  return result;
}

uint64_t swift_autoDiffProjectTopLevelSubcontext(uint64_t a1)
{
  return a1 + 192;
}

uint64_t swift_autoDiffAllocateSubcontext(uint64_t a1, uint64_t a2)
{
  return __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate( (uint64_t *)(a1 + 16),  a2,  3);
}

void *swift_autoDiffCreateLinearMapContextWithType(uint64_t a1)
{
  unsigned __int8 v2 = malloc(*(void *)(*(void *)(a1 - 8) + 64LL) + 192LL);
  *unsigned __int8 v2 = &unk_18C565A18;
  v2[1] = 3LL;
  void v2[2] = 0LL;
  void v2[3] = 0LL;
  void v2[4] = v2 + 6;
  v2[5] = 0x400000000LL;
  v2[12] = 0LL;
  v2[10] = v2 + 12;
  v2[11] = 0LL;
  v2[13] = 1LL;
  v2[14] = v2 + 16;
  v2[15] = 0x400000000LL;
  uint64_t v5 = a1;
  uint64_t v6 = v2 + 24;
  Address = __swift::__runtime::llvm::SmallVectorTemplateBase<swift::AutoDiffLinearMapContext::AllocatedContextObjectRecord,false>::reserveForParamAndGetAddress( (uint64_t)(v2 + 14),  (unint64_t)&v5,  1LL);
  *(_OWORD *)(v2[14] + 16LL * *((unsigned int *)v2 + 30)) = *Address;
  *(void *)Address = 0LL;
  *((void *)Address + 1) = 0LL;
  ++*((_DWORD *)v2 + 30);
  if (v5 && v6) {
    (*(void (**)(void))(*(void *)(v5 - 8) + 8LL))();
  }
  return v2;
}

uint64_t swift_autoDiffAllocateSubcontextWithType(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate( (uint64_t *)(a1 + 16),  *(void *)(*(void *)(a2 - 8) + 64LL),  __clz(*(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL) + 1LL) ^ 0x3Fu);
  uint64_t v7 = a2;
  uint64_t v8 = v4;
  Address = __swift::__runtime::llvm::SmallVectorTemplateBase<swift::AutoDiffLinearMapContext::AllocatedContextObjectRecord,false>::reserveForParamAndGetAddress( a1 + 112,  (unint64_t)&v7,  1LL);
  *(_OWORD *)(*(void *)(a1 + 112) + 16LL * *(unsigned int *)(a1 + 120)) = *Address;
  *(void *)Address = 0LL;
  *((void *)Address + 1) = 0LL;
  ++*(_DWORD *)(a1 + 120);
  if (v7 && v8) {
    (*(void (**)(void))(*(void *)(v7 - 8) + 8LL))();
  }
  return v4;
}

void destroyLinearMapContext()
{
  __int16 v1 = *(char **)(v0 + 112);
  uint64_t v2 = *(unsigned int *)(v0 + 120);
  if ((_DWORD)v2)
  {
    uint64_t v3 = 16 * v2;
    do
    {
      uint64_t v4 = *(void *)&v1[v3 - 16];
      if (v4 && *(void *)&v1[v3 - 8]) {
        (*(void (**)(void))(*(void *)(v4 - 8) + 8LL))();
      }
      v3 -= 16LL;
    }

    while (v3);
    __int16 v1 = *(char **)(v0 + 112);
  }

  __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v0 + 16);
  free((void *)v0);
}

uint64_t __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl( uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24)) {
    __swift::__runtime::llvm::deallocate_buffer(**(__swift::__runtime::llvm ***)(a1 + 16), (void *)0x1000);
  }
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(_DWORD *)(a1 + 72)) {
    __swift::__runtime::llvm::deallocate_buffer(*(__swift::__runtime::llvm **)v2, *(void **)(v2 + 8));
  }
  if (v2 != a1 + 80) {
    free(*(void **)(a1 + 64));
  }
  uint64_t v3 = *(void **)(a1 + 16);
  return a1;
}

_OWORD *__swift::__runtime::llvm::SmallVectorTemplateBase<swift::AutoDiffLinearMapContext::AllocatedContextObjectRecord,false>::reserveForParamAndGetAddress( uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = v4 + a3;
  if (v4 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v8 = *(void *)a1 + 16 * v4;
    if (*(void *)a1 <= a2 && v8 > a2)
    {
      uint64_t v20 = a2 - *(void *)a1;
      uint64_t v21 = __swift::__runtime::llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, v5, 16LL, &v32);
      uint64_t v22 = v21;
      unint64_t v23 = *(void **)a1;
      uint64_t v24 = *(unsigned int *)(a1 + 8);
      if ((_DWORD)v24)
      {
        uint64_t v25 = 16 * v24;
        uint64_t v26 = v21;
        do
        {
          *v26++ = *(_OWORD *)v23;
          void *v23 = 0LL;
          v23[1] = 0LL;
          v23 += 2;
          v25 -= 16LL;
        }

        while (v25);
        unint64_t v23 = *(void **)a1;
        uint64_t v27 = *(unsigned int *)(a1 + 8);
        if ((_DWORD)v27)
        {
          uint64_t v28 = 2 * v27;
          do
          {
            uint64_t v29 = v23[v28 - 2];
            if (v29 && v23[v28 - 1]) {
              (*(void (**)(void))(*(void *)(v29 - 8) + 8LL))();
            }
            v28 -= 2LL;
          }

          while (v28 * 8);
          unint64_t v23 = *(void **)a1;
        }
      }

      uint64_t v30 = v20 >> 4;
      int v31 = v32;
      if (v23 != (void *)(a1 + 16)) {
        free(v23);
      }
      *(void *)a1 = v22;
      *(_DWORD *)(a1 + 12) = v31;
      return &v22[v30];
    }

    else
    {
      uint64_t v10 = __swift::__runtime::llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, v5, 16LL, &v32);
      uint64_t v11 = v10;
      uint64_t v12 = *(void **)a1;
      uint64_t v13 = *(unsigned int *)(a1 + 8);
      if ((_DWORD)v13)
      {
        uint64_t v14 = 16 * v13;
        uint64_t v15 = v10;
        do
        {
          *v15++ = *(_OWORD *)v12;
          *uint64_t v12 = 0LL;
          v12[1] = 0LL;
          v12 += 2;
          v14 -= 16LL;
        }

        while (v14);
        uint64_t v12 = *(void **)a1;
        uint64_t v16 = *(unsigned int *)(a1 + 8);
        if ((_DWORD)v16)
        {
          uint64_t v17 = 2 * v16;
          do
          {
            uint64_t v18 = v12[v17 - 2];
            if (v18 && v12[v17 - 1]) {
              (*(void (**)(void))(*(void *)(v18 - 8) + 8LL))();
            }
            v17 -= 2LL;
          }

          while (v17 * 8);
          uint64_t v12 = *(void **)a1;
        }
      }

      int v19 = v32;
      if (v12 != (void *)(a1 + 16)) {
        free(v12);
      }
      *(void *)a1 = v11;
      *(_DWORD *)(a1 + 12) = v19;
    }
  }

  return (_OWORD *)a2;
}

uint64_t __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate( uint64_t *__sz, uint64_t a2, char a3)
{
  unint64_t v5 = __sz + 10;
  __sz[10] += a2;
  uint64_t v6 = (1LL << a3) - 1;
  uint64_t v7 = *__sz;
  uint64_t v8 = -(1LL << a3);
  uint64_t v9 = ((v6 + *__sz) & v8) - *__sz;
  if (v9 + a2 <= (unint64_t)(__sz[1] - *__sz))
  {
    uint64_t result = v7 + v9;
    *__sz = v7 + v9 + a2;
  }

  else
  {
    uint64_t v10 = a2 + (1LL << a3);
    uint64_t v11 = v10 - 1;
    if ((unint64_t)(v10 - 1) <= 0x1000)
    {
      unsigned int v16 = *((_DWORD *)__sz + 6) >> 7;
      if (v16 >= 0x1E) {
        LOBYTE(v16) = 30;
      }
      uint64_t v17 = 4096LL << v16;
      buffer = (char *)__swift::__runtime::llvm::allocate_buffer(4096LL << v16, (std::align_val_t)8uLL);
      uint64_t v19 = *((unsigned int *)__sz + 6);
      if (v19 >= *((_DWORD *)__sz + 7))
      {
        __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(__sz + 2), __sz + 4, v19 + 1, 8LL);
        LODWORD(v19) = *((_DWORD *)__sz + 6);
      }

      *(void *)(__sz[2] + 8LL * v19) = buffer;
      ++*((_DWORD *)__sz + 6);
      uint64_t result = (unint64_t)&buffer[v6] & v8;
      *__sz = result + a2;
      __sz[1] = (uint64_t)&buffer[v17];
    }

    else
    {
      uint64_t v12 = __swift::__runtime::llvm::allocate_buffer(v10 - 1, (std::align_val_t)8uLL);
      uint64_t v13 = *((unsigned int *)__sz + 18);
      if (v13 >= *((_DWORD *)__sz + 19))
      {
        __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(__sz + 8), v5, v13 + 1, 16LL);
        LODWORD(v13) = *((_DWORD *)__sz + 18);
      }

      uint64_t v14 = (void *)(__sz[8] + 16LL * v13);
      void *v14 = v12;
      v14[1] = v11;
      ++*((_DWORD *)__sz + 18);
      return ((unint64_t)v12 + v6) & v8;
    }
  }

  return result;
}

uint64_t _swift_stdlib_isExecutableLinkedOnOrAfter(unsigned int a1)
{
  if (_swift_stdlib_isExecutableLinkedOnOrAfter::getenvToken != -1) {
    dispatch_once_f( &_swift_stdlib_isExecutableLinkedOnOrAfter::getenvToken,  0LL,  (dispatch_function_t)swift::runtime::bincompat::checkBinCompatEnvironmentVariable);
  }
  if (swift::runtime::bincompat::binCompatVersionOverride) {
    return swift::runtime::bincompat::binCompatVersionOverride >= a1;
  }
  if (a1 == 329216 || a1 == 329472) {
    return dyld_program_sdk_at_least();
  }
  return 0LL;
}

void swift::runtime::bincompat::checkBinCompatEnvironmentVariable( swift::runtime::bincompat *this, void *a2, const char *a3, char *a4)
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f( &swift::runtime::environment::initializeToken,  0LL,  (dispatch_function_t)swift::runtime::environment::initialize);
  }
  if (swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable) {
    BOOL v4 = swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable == 329216;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable == 329472) {
    swift::runtime::bincompat::binCompatVersionOverride = swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable;
  }
  else {
    swift::warning( 0LL,  "Warning: ignoring unknown SWIFT_BINARY_COMPATIBILITY_VERSION %x.\n",  a3,  a4,  swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable);
  }
}

uint64_t swift::runtime::bincompat::useLegacyProtocolConformanceReverseIteration( swift::runtime::bincompat *this)
{
  return dyld_program_sdk_at_least() ^ 1;
}

uint64_t swift::runtime::bincompat::useLegacyObjCBoxingInCasting(swift::runtime::bincompat *this)
{
  return dyld_program_sdk_at_least() ^ 1;
}

uint64_t swift::runtime::bincompat::useLegacySwiftObjCHashing(swift::runtime::bincompat *this)
{
  return dyld_program_sdk_at_least() ^ 1;
}

uint64_t swift_bincompat_useLegacyNonCrashingExecutorChecks()
{
  return dyld_program_sdk_at_least() ^ 1;
}

void swift_generic_destroy(uint64_t a1, uint64_t a2)
{
  __asm { BR              X9 }

uint64_t sub_181733B10()
{
  uint64_t v4 = *(void *)(v0 + v3);
  if ((v4 & 0x8000000000000000LL) == 0) {
    swift_errorRelease((id)(v4 & 0xFFFFFFFFFFFFFF8LL));
  }
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733B3C()
{
  uint64_t v4 = swift_release(*(void *)(v0 + v3) & 0xFFFFFFFFFFFFFF8LL);
  return (*(uint64_t (**)(uint64_t))(v1 + 8LL * HIBYTE(*v2)))(v4);
}

uint64_t sub_181733B64()
{
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733B8C()
{
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733BB0()
{
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733BD4()
{
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733BF8()
{
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733C1C()
{
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733C40()
{
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733C64()
{
  uint64_t v4 = *(void *)(v0 + v3);
  if ((v4 & 0x8000000000000000LL) == 0) {

  }
  return (*(uint64_t (**)(void))(v1 + 8LL * HIBYTE(*v2)))();
}

uint64_t sub_181733C90()
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)(*v2 - 8LL) + 8LL))(v0 + v3);
  return (*(uint64_t (**)(uint64_t))(v1 + 8LL * HIBYTE(v2[1])))(v4);
}

uint64_t sub_181733CCC()
{
  uint64_t v4 = *(void *)(*(void *)(v0 + v3 + 24) - 8LL);
  if ((*(_BYTE *)(v4 + 82) & 2) != 0) {
    uint64_t v5 = swift_release(*(void *)(v0 + v3));
  }
  else {
    uint64_t v5 = (*(uint64_t (**)(void))(v4 + 8))();
  }
  return (*(uint64_t (**)(uint64_t))(v1 + 8LL * HIBYTE(*v2)))(v5);
}

uint64_t sub_181733D24(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = (uint64_t (*)(uint64_t *))((char *)v7 + *v7);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v4, a2, a3, a4);
  uint64_t v11 = v9(GenericArgs);
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)(v11 - 8) + 8LL))(v5 + v8);
  return (*(uint64_t (**)(uint64_t))(v6 + 8LL * HIBYTE(*((void *)v7 + 1))))(v12);
}

uint64_t sub_181733D70@<X0>(uint64_t a1@<X8>, void *a2, uint64_t a3)
{
  a2 = v6;
  a3 = v7;
  uint64_t v8 = ((uint64_t (*)(uint64_t, void **, uint64_t *, uint64_t))destroyTable[a1])(v3, &a2, &a3, v4);
  return (*(uint64_t (**)(uint64_t))(v5 + 8LL * HIBYTE(*a2)))(v8);
}

  ;
}

void swift::swift_generic_arrayDestroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2) {
    __asm { BR              X9 }
  }

void swift_generic_initWithCopy(void *__dst, void *__src, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 - 16) + 16LL);
  if ((v3 & 0xFFFFFFFFFFFFFFLL) != 0)
  {
    memcpy(__dst, __src, v3 & 0xFFFFFFFFFFFFFFLL);
    __asm { BR              X9 }
  }

  __asm { BR              X9 }

uint64_t sub_18173416C(id a1)
{
  uint64_t v6 = *(void *)(v2 + v3);
  if ((v6 & 0x8000000000000000LL) == 0)
  {
    *(void *)(v1 + v3) = v6;
    v3 += 8LL;
    a1 = swift_errorRetain((id)(v6 & 0xFFFFFFFFFFFFFF8LL));
  }

  unint64_t v7 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3), (const void *)(v2 + v3), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v4 + 8 * HIBYTE(v7)))(a1);
}

uint64_t sub_1817341B0(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v9 = *(void *)(v5 + v6);
  *(void *)(v4 + v6) = v9;
  uint64_t v10 = swift_retain((unint64_t *)(v9 & 0xFFFFFFFFFFFFFF8LL), a2, a3, a4);
  unint64_t v11 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v10 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v7 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_1817341F0(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = *(void *)(v5 + v6);
  *(void *)(v4 + v6) = v9;
  uint64_t v10 = swift_unownedRetain(v9 & 0xFFFFFFFFFFFFFF8LL, a2, a3, a4);
  unint64_t v11 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v10 = (uint64_t)memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(uint64_t))(v7 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_181734230(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = swift_weakCopyInit((swift *)(v4 + v6), (void *)(v5 + v6), a3, a4);
  unint64_t v10 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v7 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_18173426C(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v9 = *(void **)(v5 + v6);
  *(void *)(v4 + v6) = v9;
  id v10 = swift_unknownObjectRetain(v9, a2, a3, a4);
  unint64_t v11 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    id v10 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v7 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_1817342A8(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = swift_unknownObjectUnownedCopyInit((void *)(v4 + v6), (uint64_t *)(v5 + v6), a3, a4);
  unint64_t v10 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v7 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_1817342E4(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = swift_unknownObjectWeakCopyInit((id *)(v4 + v6), (id *)(v5 + v6), a3, a4);
  unint64_t v10 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v7 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_181734320(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v9 = *(void *)(v5 + v6);
  *(void *)(v4 + v6) = v9;
  unint64_t v10 = swift_bridgeObjectRetain(v9, a2, a3, a4);
  unint64_t v11 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v10 = (unint64_t)memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(unint64_t))(v7 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_18173435C()
{
  uint64_t v5 = _Block_copy(*(const void **)(v1 + v2));
  *(void *)(v0 + v2) = v5;
  unint64_t v6 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_181734398(id a1)
{
  uint64_t v6 = *(void *)(v2 + v3);
  *(void *)(v1 + v3) = v6;
  if ((v6 & 0x8000000000000000LL) == 0) {
    a1 = (id)(v6 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v7 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v4 + 8 * HIBYTE(v7)))(a1);
}

uint64_t sub_1817343DC()
{
  uint64_t v5 = *(void *)(*v4 - 8LL);
  uint64_t v6 = *(void *)(v5 + 64) + v2;
  unint64_t v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v5 + 16))(v0 + v2, v1 + v2);
  unint64_t v8 = v4[1];
  if ((v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v7 = memcpy((void *)(v0 + v6), (const void *)(v1 + v6), v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_181734430()
{
  uint64_t v5 = (void *)(**(uint64_t (***)(uint64_t))(*(void *)(v1 + v2 + 24) - 8LL))(v0 + v2);
  unint64_t v6 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 24), (const void *)(v1 + v2 + 24), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_181734478(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v10 = (uint64_t (*)(uint64_t *))((char *)v9 + *v9);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v4, a2, a3, a4);
  uint64_t v12 = *(void *)(v10(GenericArgs) - 8);
  uint64_t v13 = *(void *)(v12 + 64) + v7;
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v12 + 16))(v5 + v7, v6 + v7);
  unint64_t v15 = *((void *)v9 + 1);
  if ((v15 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v14 = memcpy((void *)(v5 + v13), (const void *)(v6 + v13), v15 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v8 + 8 * HIBYTE(v15)))(v14);
}

uint64_t sub_1817344DC@<X0>(uint64_t a1@<X8>, unint64_t *a2, uint64_t a3)
{
  a2 = v8;
  a3 = v6;
  unint64_t v9 = (void *)((uint64_t (*)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))initWithCopyTable[a1])( v3,  &a2,  &a3,  v4,  v5);
  unint64_t v10 = *a2;
  if ((*a2 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v9 = memcpy((void *)(v4 + a3), (const void *)(v5 + a3), *a2 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v7 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_181734534()
{
  return v0;
}

void *swift::swift_generic_arrayInitWithCopy( void *result, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v5 = *(void *)(*(void *)(a5 - 16) + 16LL);
    if ((v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
      memcpy(result, a2, v5 & 0xFFFFFFFFFFFFFFLL);
    }
    __asm { BR              X9 }
  }

  return result;
}

void *swift_generic_initWithTake(void *__dst, void *__src, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  if ((*(_BYTE *)(v4 + 82) & 0x10) != 0)
  {
    unint64_t v6 = *(void *)(*(void *)(a3 - 16) + 16LL);
    if ((v6 & 0xFFFFFFFFFFFFFFLL) != 0) {
      memcpy(__dst, __src, v6 & 0xFFFFFFFFFFFFFFLL);
    }
    switch(HIBYTE(v6))
    {
      case 0u:
        return __dst;
    }
  }

  else
  {
    memcpy(__dst, __src, *(void *)(v4 + 64));
  }

  return __dst;
}

uint64_t sub_181734A88(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734AC8(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734B08(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734B48(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734B88(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734BC8(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734C08()
{
  uint64_t v5 = swift_unknownObjectWeakTakeInit((id *)(v0 + v2), (id *)(v1 + v2));
  unint64_t v6 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_181734C50(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734C90(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734CD0(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181734D10()
{
  uint64_t v5 = *(void *)(*v4 - 8LL);
  uint64_t v6 = *(void *)(v5 + 64) + v2;
  uint64_t v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v5 + 32))(v0 + v2, v1 + v2);
  unint64_t v8 = v4[1];
  if ((v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v7 = memcpy((void *)(v0 + v6), (const void *)(v1 + v6), v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_181734D6C()
{
  uint64_t v5 = (void *)(v0 + v2);
  uint64_t v6 = *(void *)(*(void *)(v1 + v2 + 24) - 8LL);
  if ((*(_BYTE *)(v6 + 82) & 2) != 0) {
    *uint64_t v5 = *(void *)(v1 + v2);
  }
  else {
    uint64_t v5 = (void *)(*(uint64_t (**)(void *))(v6 + 32))(v5);
  }
  unint64_t v7 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 24), (const void *)(v1 + v2 + 24), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v7)))(v5);
}

uint64_t sub_181734DD4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int *a12)
{
  uint64_t v16 = resilientInitWithTake(v14, &a12, (char *)&a11, v12, v13);
  uint64_t v17 = a11;
  unint64_t v18 = *(void *)a12;
  a12 += 2;
  if ((v18 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v16 = (uint64_t)memcpy(&v12[a11], (const void *)(v13 + a11), v18 & 0xFFFFFFFFFFFFFFLL);
  }
  a11 = v17 + (v18 & 0xFFFFFFFFFFFFFFLL);
  return (*(uint64_t (**)(uint64_t))(v15 + 8 * HIBYTE(v18)))(v16);
}

uint64_t sub_181734E24@<X0>(uint64_t a1@<X8>, unint64_t *a2, uint64_t a3, uint64_t a4, void *a5)
{
  a2 = v10;
  a3 = v8;
  unint64_t v11 = (void *)((uint64_t (*)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))initWithTakeTable[a1])( v7,  &a2,  &a3,  v5,  v6);
  uint64_t v12 = a3;
  unint64_t v13 = *a2;
  a5 = a2 + 1;
  if ((v13 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v11 = memcpy((void *)(v5 + a3), (const void *)(v6 + a3), v13 & 0xFFFFFFFFFFFFFFLL);
  }
  a4 = (v13 & 0xFFFFFFFFFFFFFFLL) + v12;
  return (*(uint64_t (**)(void *))(v9 + 8 * HIBYTE(v13)))(v11);
}

void swift_generic_assignWithCopy(void *__dst, void *__src, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 - 16) + 16LL);
  if ((v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    memcpy(__dst, __src, v3 & 0xFFFFFFFFFFFFFFLL);
  }
  __asm { BR              X9 }

uint64_t sub_181734EE8(id a1)
{
  uint64_t v6 = *(void *)(v1 + v3);
  uint64_t v7 = *(void *)(v2 + v3);
  *(void *)(v1 + v3) = v7;
  if ((v6 & 0x8000000000000000LL) == 0) {
    swift_errorRelease((id)(v6 & 0xFFFFFFFFFFFFFF8LL));
  }
  if ((v7 & 0x8000000000000000LL) == 0) {
    a1 = swift_errorRetain((id)(v7 & 0xFFFFFFFFFFFFFF8LL));
  }
  unint64_t v8 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v5 + 8 * HIBYTE(v8)))(a1);
}

uint64_t sub_181734F44()
{
  uint64_t v5 = *(void *)(v0 + v2);
  uint64_t v6 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  uint64_t v7 = (unint64_t *)(v6 & 0xFFFFFFFFFFFFFF8LL);
  swift_release(v5 & 0xFFFFFFFFFFFFFF8LL);
  unint64_t v11 = swift_retain(v7, v8, v9, v10);
  unint64_t v12 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v11 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v12)))(v11);
}

uint64_t sub_181734F9C()
{
  uint64_t v5 = *(void *)(v0 + v2);
  uint64_t v6 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  uint64_t v7 = v6 & 0xFFFFFFFFFFFFFF8LL;
  swift_unownedRelease(v5 & 0xFFFFFFFFFFFFFF8LL);
  uint64_t v11 = swift_unownedRetain(v7, v8, v9, v10);
  unint64_t v12 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v11 = (uint64_t)memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(uint64_t))(v4 + 8 * HIBYTE(v12)))(v11);
}

uint64_t sub_181734FF4(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = swift_weakCopyAssign((uint64_t *)(v4 + v6), (uint64_t *)(v5 + v6), a3, a4);
  unint64_t v10 = *v7;
  if ((*v7 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v7 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v8 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_181735038()
{
  uint64_t v5 = *(void **)(v0 + v2);
  uint64_t v6 = *(void **)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  swift_unknownObjectRelease(v5);
  id v10 = swift_unknownObjectRetain(v6, v7, v8, v9);
  unint64_t v11 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    id v10 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v4 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_181735088(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = swift_unknownObjectUnownedCopyAssign((uint64_t *)(v4 + v6), (uint64_t *)(v5 + v6), a3, a4);
  unint64_t v10 = *v7;
  if ((*v7 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v7 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v8 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_1817350CC(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = swift_unknownObjectWeakCopyAssign((id *)(v4 + v6), (id *)(v5 + v6), a3, a4);
  unint64_t v10 = *v7;
  if ((*v7 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v7 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v8 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_181735110()
{
  uint64_t v5 = *(void *)(v0 + v2);
  unint64_t v6 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  swift_bridgeObjectRelease(v5);
  unint64_t v10 = swift_bridgeObjectRetain(v6, v7, v8, v9);
  unint64_t v11 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v10 = (unint64_t)memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(unint64_t))(v4 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_181735160()
{
  uint64_t v5 = _Block_copy(*(const void **)(v1 + v2));
  *(void *)(v0 + v2) = v5;
  unint64_t v6 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_1817351AC(id a1)
{
  uint64_t v6 = *(void *)(v1 + v3);
  uint64_t v7 = *(void *)(v2 + v3);
  *(void *)(v1 + v3) = v7;
  if ((v6 & 0x8000000000000000LL) == 0) {

  }
  if ((v7 & 0x8000000000000000LL) == 0) {
    a1 = (id)(v7 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v8 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v5 + 8 * HIBYTE(v8)))(a1);
}

uint64_t sub_181735208()
{
  uint64_t v5 = *(void *)(*v3 - 8LL);
  uint64_t v6 = *(void *)(v5 + 64) + v2;
  uint64_t v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v5 + 24))(v0 + v2, v1 + v2);
  unint64_t v8 = v3[1];
  if ((v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v7 = memcpy((void *)(v0 + v6), (const void *)(v1 + v6), v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_181735260( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, size_t a12)
{
  uint64_t v16 = existentialAssignWithCopy(a1, a2, &a12, v12, v13);
  unint64_t v17 = *v14;
  size_t v18 = a12;
  size_t v19 = *v14 & 0xFFFFFFFFFFFFFFLL;
  if (v19) {
    uint64_t v16 = memcpy((void *)(v12 + a12), (const void *)(v13 + a12), v19);
  }
  a12 = v18 + v19;
  return (*(uint64_t (**)(void *))(v15 + 8 * HIBYTE(v17)))(v16);
}

uint64_t sub_1817352A4(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v10 = (uint64_t (*)(uint64_t *))((char *)v8 + *v8);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v4, a2, a3, a4);
  uint64_t v12 = *(void *)(v10(GenericArgs) - 8);
  uint64_t v13 = *(void *)(v12 + 64) + v7;
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v12 + 24))(v5 + v7, v6 + v7);
  unint64_t v15 = *((void *)v8 + 1);
  if ((v15 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v14 = memcpy((void *)(v5 + v13), (const void *)(v6 + v13), v15 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v9 + 8 * HIBYTE(v15)))(v14);
}

uint64_t sub_18173530C@<X0>(uint64_t a1@<X8>, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  a3 = v9;
  a4 = v8;
  unint64_t v11 = (void *)((uint64_t (*)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))assignWithCopyTable[a1])( v5,  &a3,  &a4,  v6,  v7);
  uint64_t v12 = a4;
  unint64_t v13 = *a3;
  uint64_t v14 = *a3 & 0xFFFFFFFFFFFFFFLL;
  if (v14) {
    unint64_t v11 = memcpy((void *)(v6 + a4), (const void *)(v7 + a4), *a3 & 0xFFFFFFFFFFFFFFLL);
  }
  a5 = v14 + v12;
  return (*(uint64_t (**)(void *))(v10 + 8 * HIBYTE(v13)))(v11);
}

uint64_t sub_181735368()
{
  return v0;
}

void *swift_generic_arrayAssignWithCopy(void *result, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v5 = *(void *)(*(void *)(a5 - 16) + 16LL);
    if ((v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
      memcpy(result, a2, v5 & 0xFFFFFFFFFFFFFFLL);
    }
    __asm { BR              X9 }
  }

  return result;
}

void *swift_generic_assignWithTake(void *a1, void *a2, uint64_t a3)
{
  return swift_generic_initWithTake(a1, a2, a3);
}

uint64_t swift_singletonEnum_getEnumTag()
{
  return 0LL;
}

uint64_t swift_enumSimple_getEnumTag(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 - 16);
  v16[0] = off_189B8AEA8;
  v16[1] = a1;
  v16[3] = v16;
  v15[0] = off_189B8AEF0;
  v15[1] = a1;
  v15[3] = v15;
  unint64_t v3 = v2[3];
  uint64_t v5 = v2[5];
  unint64_t v4 = v2[6];
  if (!(v3 >> 62)) {
    goto LABEL_13;
  }
  unint64_t v6 = v2[4];
  int v7 = (1 << ((v3 >> 62) - 1));
  if (v7 == 4)
  {
    int v8 = *(_DWORD *)&a1[v6];
    if (v8) {
      goto LABEL_8;
    }
LABEL_13:
    uint64_t v11 = (v3 >> 59) & 7;
    if (!(_DWORD)v11) {
      return 0LL;
    }
    switch((1 << (v11 - 1)))
    {
      case 1u:
        uint64_t v12 = a1[v3];
        goto LABEL_19;
      case 2u:
        uint64_t v12 = *(unsigned __int16 *)&a1[v3];
        goto LABEL_19;
      case 4u:
        uint64_t v12 = *(unsigned int *)&a1[v3];
        goto LABEL_19;
      case 8u:
        uint64_t v12 = *(void *)&a1[v3];
LABEL_19:
        unint64_t v13 = v12 - v5;
        if (v13 >= v4) {
          return 0LL;
        }
        uint64_t result = (v13 + 1);
        break;
      default:
        goto LABEL_27;
    }

    return result;
  }

  if (v7 == 2)
  {
    int v8 = *(unsigned __int16 *)&a1[v6];
    if (*(_WORD *)&a1[v6]) {
      goto LABEL_8;
    }
    goto LABEL_13;
  }

  if (v7 != 1) {
LABEL_27:
  }
    abort();
  int v8 = a1[v6];
  if (!a1[v6]) {
    goto LABEL_13;
  }
LABEL_8:
  unint64_t v9 = (unint64_t)(v8 - 1) << (8 * v6);
  if (v6 > 3) {
    LODWORD(v9) = 0;
  }
  int v10 = 0;
  switch(v6)
  {
    case 0uLL:
      return v4 + (v10 | v9) + 1;
    case 1uLL:
      int v10 = *a1;
      break;
    case 2uLL:
      int v10 = *(unsigned __int16 *)a1;
      break;
    case 3uLL:
      int v10 = *(unsigned __int16 *)a1 | (a1[2] << 16);
      break;
    default:
      int v10 = *(_DWORD *)a1;
      break;
  }

  return v4 + (v10 | v9) + 1;
}

void *swift_enumSimple_destructiveInjectEnumTag(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v4 = *(void **)(a3 - 16);
  v29[0] = off_189B8AF38;
  v29[1] = a1;
  v29[2] = a2;
  uint64_t v30 = v29;
  uint64_t v25 = off_189B8AF80;
  uint64_t v26 = a1;
  uint64_t v27 = a2;
  uint64_t v28 = &v25;
  unint64_t v6 = v4[3];
  unint64_t v5 = v4[4];
  unsigned int v7 = (v6 >> 62) - 1;
  int v8 = 1 << ((v6 >> 62) - 1);
  unint64_t v9 = v4[6];
  if (v6 >> 62) {
    BOOL v10 = v9 >= a2;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    uint64_t v11 = (v6 >> 59) & 7;
    if ((_DWORD)v11 && v9 >= a2)
    {
      uint64_t v12 = v4[5];
      if (v7 <= 7)
      {
        unint64_t v13 = &a1[v5];
        switch((1 << ((v6 >> 62) - 1)))
        {
          case 1u:
            *unint64_t v13 = 0;
            break;
          case 2u:
            *(_WORD *)unint64_t v13 = 0;
            break;
          case 3u:
            void v13[2] = 0;
            *(_WORD *)unint64_t v13 = 0;
            break;
          case 4u:
            *(_DWORD *)unint64_t v13 = 0;
            break;
          default:
            *(_DWORD *)unint64_t v13 = 0;
            bzero(v13 + 4, (1 << ((v6 >> 62) - 1)) - 4LL);
            break;
        }

        a2 = v27;
      }

      if (a2)
      {
        size_t v19 = &v26[v6];
        int v20 = v12 + a2 - 1;
        switch(1 << (v11 - 1))
        {
          case 1:
            *size_t v19 = v20;
            break;
          case 2:
            *(_WORD *)size_t v19 = v20;
            break;
          case 3:
            *(_WORD *)size_t v19 = v20;
            v19[2] = BYTE2(v20);
            break;
          case 4:
            *(_DWORD *)size_t v19 = v20;
            break;
          default:
            *(_DWORD *)size_t v19 = v20;
            unint64_t v17 = v19 + 4;
            size_t v18 = (1 << (v11 - 1)) - 4LL;
LABEL_44:
            bzero(v17, v18);
            break;
        }
      }
    }
  }

  else
  {
    unsigned int v14 = ~(_DWORD)v9 + a2;
    if (v5 > 3)
    {
      int v15 = 1;
      goto LABEL_15;
    }

    int v15 = (v14 >> (8 * v5)) + 1;
    if (v5)
    {
      v14 &= ~(-1 << (8 * v5));
LABEL_15:
      switch(v5)
      {
        case 1uLL:
          *a1 = v14;
          if (v7 <= 7) {
            goto LABEL_24;
          }
          break;
        case 2uLL:
          *(_WORD *)a1 = v14;
          if (v7 <= 7) {
            goto LABEL_24;
          }
          break;
        case 3uLL:
          *(_WORD *)a1 = v14;
          a1[2] = BYTE2(v14);
          goto LABEL_23;
        case 4uLL:
          *(_DWORD *)a1 = v14;
          if (v7 <= 7) {
            goto LABEL_24;
          }
          break;
        default:
          *(_DWORD *)a1 = v14;
          bzero(a1 + 4, v5 - 4);
          if (v7 <= 7) {
            goto LABEL_24;
          }
          break;
      }

      goto LABEL_45;
    }

uint64_t swift_enumFn_getEnumTag(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)(void))(*(void *)(a2 - 16) + 24LL + *(int *)(*(void *)(a2 - 16) + 24LL)))();
}

unint64_t swift_multiPayloadEnumGeneric_getEnumTag(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 - 16);
  int v3 = v2[3] - 1;
  unint64_t v5 = v2[4];
  unint64_t v6 = v2[6] - v2[3];
  switch(v3)
  {
    case 0:
      unint64_t result = a1[v6];
      if (v5 > a1[v6]) {
        return result;
      }
      goto LABEL_9;
    case 1:
      unint64_t result = *(unsigned __int16 *)&a1[v6];
      return result;
    case 3:
      unint64_t result = *(unsigned int *)&a1[v6];
      return result;
    case 7:
      unint64_t result = *(void *)&a1[v6];
LABEL_9:
      unint64_t v8 = v6;
      switch(v6)
      {
        case 0uLL:
          goto LABEL_13;
        case 1uLL:
          unint64_t v8 = *a1;
          goto LABEL_13;
        case 2uLL:
          unint64_t v8 = *(unsigned __int16 *)a1;
          goto LABEL_13;
        case 3uLL:
          unint64_t v8 = *(unsigned __int16 *)a1 | ((unint64_t)a1[2] << 16);
LABEL_13:
          unint64_t result = (v8 | ((result - v5) << (8 * v6))) + v5;
          break;
        default:
          unint64_t result = v5 + *(unsigned int *)a1;
          break;
      }

      return result;
    default:
      abort();
  }

void swift_multiPayloadEnumGeneric_destructiveInjectEnumTag(_BYTE *a1, size_t a2, uint64_t a3)
{
  unint64_t v4 = *(void **)(a3 - 16);
  uint64_t v6 = v4[3];
  unint64_t v5 = v4[4];
  unint64_t v7 = v4[6] - v6;
  if (v5 <= a2)
  {
    if (v7 <= 3) {
      int v9 = (a2 - v5) & ~(-1 << (8 * v7));
    }
    else {
      int v9 = a2 - v5;
    }
    if (v7 <= 3) {
      LODWORD(v5) = ((a2 - v5) >> (8 * v7)) + v5;
    }
    BOOL v10 = &a1[v7];
    switch(v6)
    {
      case 0LL:
        goto LABEL_21;
      case 1LL:
        *BOOL v10 = v5;
        a2 = v7 - 4;
        if (v7 > 4) {
          goto LABEL_24;
        }
        goto LABEL_21;
      case 2LL:
        *(_WORD *)BOOL v10 = v5;
        a2 = v7 - 4;
        if (v7 > 4) {
          goto LABEL_24;
        }
        goto LABEL_21;
      case 3LL:
        *(_WORD *)BOOL v10 = v5;
        void v10[2] = BYTE2(v5);
        goto LABEL_21;
      case 4LL:
        *(_DWORD *)BOOL v10 = v5;
        a2 = v7 - 4;
        if (v7 > 4) {
          goto LABEL_24;
        }
        goto LABEL_21;
      default:
        *(_DWORD *)BOOL v10 = v5;
        bzero(v10 + 4, a2);
        a2 = v7 - 4;
        if (v7 <= 4)
        {
LABEL_21:
          switch(v7)
          {
            case 0uLL:
              return;
            case 1uLL:
              *a1 = v9;
              break;
            case 2uLL:
              *(_WORD *)a1 = v9;
              break;
            case 3uLL:
              *(_WORD *)a1 = v9;
              a1[2] = BYTE2(v9);
              break;
            case 4uLL:
              *(_DWORD *)a1 = v9;
              break;
            default:
              goto LABEL_24;
          }
        }

        else
        {
LABEL_24:
          *(_DWORD *)a1 = v9;
          uint64_t v11 = a1 + 4;
LABEL_25:
          bzero(v11, a2);
        }

        break;
    }
  }

  else
  {
    unint64_t v8 = &a1[v7];
    switch(v6)
    {
      case 0LL:
        return;
      case 1LL:
        *unint64_t v8 = a2;
        break;
      case 2LL:
        *(_WORD *)unint64_t v8 = a2;
        break;
      case 3LL:
        *(_WORD *)unint64_t v8 = a2;
        void v8[2] = BYTE2(a2);
        break;
      case 4LL:
        *(_DWORD *)unint64_t v8 = a2;
        break;
      default:
        *(_DWORD *)unint64_t v8 = a2;
        uint64_t v11 = v8 + 4;
        a2 = v5;
        goto LABEL_25;
    }
  }

uint64_t swift_singlePayloadEnumGeneric_getEnumTag(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 - 16);
  v19[0] = off_189B8AFC8;
  v19[1] = a1;
  int v20 = v19;
  v17[0] = off_189B8B010;
  v17[1] = a1;
  size_t v18 = v17;
  unint64_t v3 = v2[3];
  uint64_t v4 = v2[5];
  if (!(v3 >> 62)) {
    goto LABEL_11;
  }
  unint64_t v5 = v2[4];
  int v6 = (1 << ((v3 >> 62) - 1));
  if (v6 == 4)
  {
    int v7 = *(_DWORD *)&a1[v5];
    if (!v7) {
      goto LABEL_11;
    }
    goto LABEL_8;
  }

  if (v6 == 2)
  {
    int v7 = *(unsigned __int16 *)&a1[v5];
    if (!*(_WORD *)&a1[v5]) {
      goto LABEL_11;
    }
LABEL_8:
    if (v4) {
      int v8 = *(_DWORD *)(*(void *)(v4 - 8) + 84LL) + 1;
    }
    else {
      int v8 = 1;
    }
    unint64_t v12 = (unint64_t)(v7 - 1) << (8 * v5);
    if (v5 > 3) {
      LODWORD(v12) = 0;
    }
    int v13 = 0;
    switch(v5)
    {
      case 0uLL:
        break;
      case 1uLL:
        int v13 = *a1;
        break;
      case 2uLL:
        int v13 = *(unsigned __int16 *)a1;
        break;
      case 3uLL:
        int v13 = *(unsigned __int16 *)a1 | (a1[2] << 16);
        break;
      default:
        int v13 = *(_DWORD *)a1;
        break;
    }

    uint64_t v9 = (v13 | v12) + v8;
    BOOL v10 = v17;
    uint64_t v11 = 4LL;
    goto LABEL_26;
  }

  if (v6 != 1) {
    abort();
  }
  int v7 = a1[v5];
  if (a1[v5]) {
    goto LABEL_8;
  }
LABEL_11:
  if (!v4)
  {
    uint64_t v9 = 0LL;
    goto LABEL_16;
  }

  uint64_t v9 = (*(uint64_t (**)(unsigned __int8 *, void))(*(void *)(v4 - 8) + 48LL))( &a1[v3],  *(unsigned int *)(*(void *)(v4 - 8) + 84LL));
  BOOL v10 = v18;
  if (v18 == v17)
  {
LABEL_16:
    uint64_t v11 = 4LL;
    BOOL v10 = v17;
    goto LABEL_26;
  }

  if (!v18) {
    goto LABEL_27;
  }
  uint64_t v11 = 5LL;
LABEL_26:
  (*(void (**)(void *, uint64_t))(*v10 + 8 * v11))(v10, a2);
LABEL_27:
  unsigned int v14 = v20;
  if (v20 == v19)
  {
    uint64_t v15 = 4LL;
    unsigned int v14 = v19;
    goto LABEL_31;
  }

  if (v20)
  {
    uint64_t v15 = 5LL;
LABEL_31:
    (*(void (**)(void *, uint64_t))(*v14 + 8 * v15))(v14, a2);
  }

  return v9;
}

void *swift_singlePayloadEnumGeneric_destructiveInjectEnumTag(_BYTE *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 16);
  v23[0] = off_189B8B058;
  v23[1] = a2;
  v23[2] = a1;
  uint64_t v24 = v23;
  size_t v19 = off_189B8B0A0;
  uint64_t v20 = a2;
  uint64_t v21 = a1;
  uint64_t v22 = &v19;
  unint64_t v6 = *(void *)(v4 + 24);
  unint64_t v5 = *(void *)(v4 + 32);
  unsigned int v7 = (v6 >> 62) - 1;
  uint64_t v8 = *(void *)(v4 + 40);
  if (!(v6 >> 62)) {
    goto LABEL_7;
  }
  if (!v8)
  {
    unsigned int v9 = 0;
    if ((_DWORD)a2) {
      goto LABEL_4;
    }
LABEL_7:
    if (v8)
    {
    }

    else if ((_DWORD)a2)
    {
      goto LABEL_36;
    }

    uint64_t v12 = *(unsigned int *)(v4 + 48);
    if (v7 <= 7)
    {
      int v13 = &a1[v5];
      switch((1 << ((v6 >> 62) - 1)))
      {
        case 1u:
          *int v13 = 0;
          break;
        case 2u:
          *(_WORD *)int v13 = 0;
          break;
        case 3u:
          void v13[2] = 0;
          *(_WORD *)int v13 = 0;
          break;
        case 4u:
          *(_DWORD *)int v13 = 0;
          break;
        default:
          *(_DWORD *)int v13 = 0;
          bzero(v13 + 4, (1 << ((v6 >> 62) - 1)) - 4LL);
          break;
      }

      a2 = v20;
    }

    if ((_DWORD)a2) {
      (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56LL))( &v21[v6],  a2,  v12,  v8);
    }
    goto LABEL_36;
  }

  unsigned int v9 = *(_DWORD *)(*(void *)(v8 - 8) + 84LL);
LABEL_4:
  unsigned int v10 = ~v9 + a2;
  if (v5 > 3)
  {
    int v11 = 1;
    goto LABEL_16;
  }

  int v11 = (v10 >> (8 * v5)) + 1;
  if (v5)
  {
    v10 &= ~(-1 << (8 * v5));
LABEL_16:
    switch(v5)
    {
      case 1uLL:
        *a1 = v10;
        if (v7 <= 7) {
          goto LABEL_25;
        }
        break;
      case 2uLL:
        *(_WORD *)a1 = v10;
        if (v7 <= 7) {
          goto LABEL_25;
        }
        break;
      case 3uLL:
        *(_WORD *)a1 = v10;
        a1[2] = BYTE2(v10);
        if (v7 <= 7) {
          goto LABEL_25;
        }
        break;
      case 4uLL:
        *(_DWORD *)a1 = v10;
        goto LABEL_24;
      default:
        *(_DWORD *)a1 = v10;
        bzero(a1 + 4, v5 - 4);
        if (v7 <= 7) {
          goto LABEL_25;
        }
        break;
    }

    goto LABEL_36;
  }

unint64_t **swift_generic_initializeBufferWithCopyOfBuffer( unint64_t **__dst, unint64_t **a2, uint64_t a3, char *a4)
{
  uint64_t v4 = __dst;
  if ((*(_BYTE *)(*(void *)(a3 - 8) + 82LL) & 2) != 0)
  {
    *__dst = *a2;
    swift_retain(*a2, (uint64_t)a2, a3, a4);
    return (unint64_t **)(*v4 + 2);
  }

  else
  {
    swift_generic_initWithCopy(__dst, a2, a3);
  }

  return v4;
}

uint64_t swift::swift_resolve_resilientAccessors(uint64_t result, uint64_t a2, const char *a3, uint64_t *a4)
{
  uint64_t v7 = result;
  uint64_t v8 = 0LL;
  while (1)
  {
    uint64_t v11 = v8;
    unint64_t v12 = *(void *)&a3[v8];
    v8 += 8LL;
    uint64_t v13 = v12 & 0xFFFFFFFFFFFFFFLL;
    switch(HIBYTE(v12))
    {
      case 0u:
        return result;
      case 0xCu:
        uint64_t v8 = v11 + 16;
        continue;
      case 0xFu:
        unsigned int v14 = &a3[v8];
        uint64_t v15 = *(int *)&a3[v8];
        uint64_t v8 = v11 + 16;
        uint64_t v16 = &v14[v15];
        GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a4, a2, a3, (char *)a4);
        unint64_t result = ((uint64_t (*)(uint64_t *))v16)(GenericArgs);
        uint64_t v18 = (uint64_t *)(v7 + v11 + a2);
        *uint64_t v18 = v13 | 0xC00000000000000LL;
        v18[1] = result;
        continue;
      case 0x10u:
        uint64_t v8 = v11 + 56;
        continue;
      case 0x11u:
        unsigned int v9 = &a3[v8 + *(int *)&a3[v8]];
        unsigned int v10 = (uint64_t *)(v7 + v11 + a2);
        *unsigned int v10 = v13 | 0x1200000000000000LL;
        v10[1] = (uint64_t)v9;
        goto LABEL_3;
      case 0x12u:
LABEL_3:
        uint64_t v8 = v11 + 32;
        break;
      case 0x13u:
        uint64_t v8 = v11 + *(void *)&a3[v11 + 44] + 60;
        break;
      case 0x14u:
        size_t v19 = &a3[v8 + *(int *)&a3[v8]];
        uint64_t v20 = (uint64_t *)(v7 + v11 + a2);
        *uint64_t v20 = v13 | 0x1500000000000000LL;
        v20[1] = (uint64_t)v19;
        uint64_t v22 = *(void *)&a3[v11 + 16];
        uint64_t v21 = *(void *)&a3[v11 + 24];
        uint64_t v23 = v11 + 40;
        if (v22)
        {
          uint64_t v24 = v23 + a2 + 8 * v22;
          uint64_t v25 = (uint64_t)&a3[8 * v22 + v23];
          do
          {
            uint64_t v26 = *(void *)&a3[v23];
            v23 += 8LL;
            unint64_t result = swift::swift_resolve_resilientAccessors(v7, v24 + v26, v25 + v26, a4);
            --v22;
          }

          while (v22);
        }

        uint64_t v8 = v23 + v21;
        break;
      case 0x15u:
      case 0x16u:
        uint64_t v8 = v11 + 8LL * *(void *)&a3[v11 + 16] + *(void *)&a3[v11 + 24] + 40;
        break;
      default:
        continue;
    }
  }

uint64_t swift_generic_instantiateLayoutString(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!(_DWORD)v2 || (_DWORD)v2 == 773 || (_DWORD)v2 == 515) {
    *(a2 - 3) = result;
  }
  else {
    *(a2 - 2) = result;
  }
  return result;
}

void errorDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3);
  if ((v4 & 0x8000000000000000LL) == 0)
  {
    *a3 += 8LL;
    swift_errorRelease((id)(v4 & 0xFFFFFFFFFFFFFF8LL));
  }

uint64_t nativeStrongDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3) & 0xFFFFFFFFFFFFFF8LL;
  *a3 += 8LL;
  return swift_release(v4);
}

void unownedDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3) & 0xFFFFFFFFFFFFFF8LL;
  *a3 += 8LL;
  swift_unownedRelease(v4);
}

void weakDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t *)(a4 + *a3);
  *a3 += 8LL;
  swift_weakDestroy(v4);
}

void unknownDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a4 + *a3);
  *a3 += 8LL;
  swift_unknownObjectRelease(v4);
}

void unknownUnownedDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t *)(a4 + *a3);
  *a3 += 8LL;
  swift_unknownObjectUnownedDestroy(v4);
}

void unknownWeakDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (id *)(a4 + *a3);
  *a3 += 8LL;
  swift_unknownObjectWeakDestroy(v4);
}

void bridgeDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3);
  *a3 += 8LL;
  swift_bridgeObjectRelease(v4);
}

void blockDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (const void *)(a4 + *a3);
  *a3 += 8LL;
  _Block_release(v4);
}

void objcStrongDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3);
  *a3 += 8LL;
  if ((v4 & 0x8000000000000000LL) == 0) {
}
  }

uint64_t metatypeDestroy(uint64_t a1, void **a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(*a2)++;
  uint64_t v5 = a4 + *a3;
  uint64_t v6 = *(void *)(v4 - 8);
  *a3 += *(void *)(v6 + 64);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(v5, v4);
}

uint64_t existentialDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t *)(a4 + *a3);
  uint64_t v5 = v4[3];
  *a3 += 24LL;
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(_BYTE *)(v6 + 82) & 2) != 0) {
    return swift_release(*v4);
  }
  else {
    return (*(uint64_t (**)(void))(v6 + 8))();
  }
}

uint64_t resilientDestroy(uint64_t *a1, int **a2, const char *a3, char *a4)
{
  uint64_t v6 = (uint64_t)*a2;
  uint64_t v7 = **a2;
  *a2 += 2;
  uint64_t v8 = (uint64_t (*)(uint64_t *))(v7 + v6);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1, (uint64_t)a2, a3, a4);
  uint64_t v10 = v8(GenericArgs);
  uint64_t v11 = &a4[*(void *)a3];
  uint64_t v12 = *(void *)(v10 - 8);
  *(void *)a3 += *(void *)(v12 + 64);
  return (*(uint64_t (**)(char *))(v12 + 8))(v11);
}

void singlePayloadEnumSimple(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v4 = *(void *)*a2;
  uint64_t v5 = *a2 + 48;
  uint64_t v6 = (v4 >> 59) & 7;
  if (v4 >> 62)
  {
    uint64_t v12 = *(void *)(*a2 + 8);
    uint64_t v7 = *a3;
    uint64_t v13 = a4 + *a3;
    int v14 = (1 << ((v4 >> 62) - 1));
    switch(v14)
    {
      case 4:
        uint64_t v15 = *(unsigned int *)(v13 + v12);
        break;
      case 2:
        uint64_t v15 = *(unsigned __int16 *)(v13 + v12);
        break;
      case 1:
        uint64_t v15 = *(unsigned __int8 *)(v13 + v12);
        break;
      default:
LABEL_23:
        abort();
    }

    if ((_DWORD)v6) {
      BOOL v16 = v15 == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (v16)
    {
LABEL_3:
      int v8 = (1 << (v6 - 1)) - 1;
      uint64_t v9 = *(void *)*a2;
      uint64_t v10 = a4 + v7;
      switch(v8)
      {
        case 0:
          uint64_t v11 = *(unsigned __int8 *)(v10 + v9);
          goto LABEL_8;
        case 1:
          uint64_t v11 = *(unsigned __int16 *)(v10 + v9);
          goto LABEL_8;
        case 3:
          uint64_t v11 = *(unsigned int *)(v10 + v9);
          goto LABEL_8;
        case 7:
          uint64_t v11 = *(void *)(v10 + v9);
LABEL_8:
          goto LABEL_10;
        default:
          goto LABEL_23;
      }
    }
  }

  else
  {
    uint64_t v7 = *a3;
    if ((_DWORD)v6) {
      goto LABEL_3;
    }
  }

  v5 += *(void *)(*a2 + 32);
  *a3 = v7 + *(void *)(*a2 + 40);
LABEL_10:
  *a2 = v5;
}

uint64_t singlePayloadEnumFN(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t v6 = *a2;
  uint64_t result = ((uint64_t (*)(uint64_t))(*(int *)*a2 + *a2))(a4 + *a3);
  if ((_DWORD)result)
  {
    uint64_t v8 = v6 + *(void *)(v6 + 8) + 24;
    *a3 += *(void *)(v6 + 16);
  }

  else
  {
    uint64_t v8 = v6 + 24;
  }

  *a2 = v8;
  return result;
}

uint64_t singlePayloadEnumFNResolved(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)a2 + 8LL);
  uint64_t v7 = *(void *)(*(void *)a2 + 16LL);
  uint64_t v8 = *(void *)a2 + 24LL;
  uint64_t result = (**(uint64_t (***)(uint64_t))a2)(a4 + *a3);
  if ((_DWORD)result)
  {
    v8 += v6;
    *a3 += v7;
  }

  *(void *)a2 = v8;
  return result;
}

void singlePayloadEnumGeneric(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v6 = *(void *)*a2;
  uint64_t v7 = *(void *)(*a2 + 16);
  uint64_t v8 = *(void *)(*a2 + 28);
  uint64_t v9 = *(void *)(*a2 + 36);
  uint64_t v10 = *a2 + 44;
  if (v6 >> 62)
  {
    uint64_t v12 = *(void *)(*a2 + 8);
    uint64_t v11 = *a3;
    uint64_t v13 = a4 + *a3;
    int v14 = (1 << ((v6 >> 62) - 1));
    switch(v14)
    {
      case 4:
        uint64_t v15 = *(unsigned int *)(v13 + v12);
        break;
      case 2:
        uint64_t v15 = *(unsigned __int16 *)(v13 + v12);
        break;
      case 1:
        uint64_t v15 = *(unsigned __int8 *)(v13 + v12);
        break;
      default:
        abort();
    }

    if (v15) {
      goto LABEL_5;
    }
    if (!v7) {
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v11 = *a3;
    if (!v7)
    {
LABEL_5:
      v10 += v8;
      *a3 = v11 + v9;
      goto LABEL_6;
    }
  }

  if ((*(unsigned int (**)(uint64_t, void))(*(void *)(v7 - 8) + 48LL))( a4 + v11 + *(void *)*a2,  *(unsigned int *)(*(void *)(v7 - 8) + 84LL)))
  {
    uint64_t v11 = *a3;
    goto LABEL_5;
  }

uint64_t multiPayloadEnumFN<&(handleRefCountsDestroy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *))>( uint64_t a1, int **a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = *((void *)*a2 + 1);
  uint64_t v9 = *((void *)*a2 + 2);
  uint64_t v10 = *((void *)*a2 + 3);
  uint64_t v11 = (uint64_t)(*a2 + 8);
  uint64_t v12 = *a3;
  uint64_t result = ((uint64_t (*)(uint64_t))((char *)*a2 + **a2))(a4 + *a3);
  *a2 = (int *)(v11 + v9 + 8 * v8);
  *a3 += v10;
  if (v8 > result)
  {
    int v14 = (unint64_t *)(v11 + 8 * v8 + *(void *)(v11 + 8LL * result));
    unint64_t v15 = *v14;
    unint64_t v17 = v14 + 1;
    for (uint64_t i = v12 + (v15 & 0xFFFFFFFFFFFFFFLL); HIBYTE(v15); i += v15 & 0xFFFFFFFFFFFFFFLL)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                           + ((v15 >> 53) & 0x7F8)))( a1,  &v17,  &i,  a4);
      unint64_t v15 = *v17++;
    }
  }

  return result;
}

uint64_t multiPayloadEnumFNResolved<&(handleRefCountsDestroy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *))>( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(*(void *)a2 + 8LL);
  uint64_t v9 = *(void *)(*(void *)a2 + 16LL);
  uint64_t v10 = *(void *)(*(void *)a2 + 24LL);
  uint64_t v11 = *(void *)a2 + 32LL;
  uint64_t v12 = *a3;
  uint64_t result = (**(uint64_t (***)(uint64_t))a2)(a4 + *a3);
  *(void *)a2 = v11 + v9 + 8 * v8;
  *a3 += v10;
  if (v8 > result)
  {
    int v14 = (unint64_t *)(v11 + 8 * v8 + *(void *)(v11 + 8LL * result));
    unint64_t v15 = *v14;
    unint64_t v17 = v14 + 1;
    for (uint64_t i = v12 + (v15 & 0xFFFFFFFFFFFFFFLL); HIBYTE(v15); i += v15 & 0xFFFFFFFFFFFFFFLL)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                           + ((v15 >> 53) & 0x7F8)))( a1,  &v17,  &i,  a4);
      unint64_t v15 = *v17++;
    }
  }

  return result;
}

uint64_t multiPayloadEnumGeneric<&(handleRefCountsDestroy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *))>( uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*(void *)a2 + 8LL);
  uint64_t v7 = *(void *)(*(void *)a2 + 24LL);
  uint64_t v8 = *a3;
  uint64_t v9 = v7 - **(void **)a2;
  uint64_t v10 = a4 + *a3;
  switch(**(void **)a2)
  {
    case 1u:
      unint64_t v11 = *(unsigned __int8 *)(v10 + v9);
      break;
    case 2u:
      unint64_t v11 = *(unsigned __int16 *)(v10 + v9);
      break;
    case 4u:
      unint64_t v11 = *(unsigned int *)(v10 + v9);
      break;
    case 8u:
      unint64_t v11 = *(void *)(v10 + v9);
      break;
    default:
      abort();
  }

  uint64_t v12 = *(void *)a2 + 32LL;
  *(void *)a2 = v12 + *(void *)(*(void *)a2 + 16LL) + 8 * v6;
  *a3 = v8 + v7;
  if (v11 < v6)
  {
    uint64_t v13 = (unint64_t *)(v12 + 8 * v6 + *(void *)(v12 + 8 * v11));
    unint64_t v14 = *v13;
    unint64_t v15 = v13 + 1;
    for (uint64_t i = (v14 & 0xFFFFFFFFFFFFFFLL) + v8; HIBYTE(v14); i += v14 & 0xFFFFFFFFFFFFFFLL)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                           + ((v14 >> 53) & 0x7F8)))( v5,  &v15,  &i,  a4);
      unint64_t v14 = *v15++;
    }
  }

  return result;
}

uint64_t *swift::TargetMetadata<swift::InProcess>::getGenericArgs( uint64_t *a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t result = 0LL;
  unint64_t v6 = *a1;
  if ((int)v6 > 514)
  {
    if ((_DWORD)v6 != 515 && (_DWORD)v6 != 516) {
      return result;
    }
  }

  else if ((v6 - 512) >= 3)
  {
    if ((_DWORD)v6) {
      return result;
    }
    if ((a1[4] & 2) == 0) {
      return 0LL;
    }
    uint64_t v7 = (int *)a1[8];
    if (!v7) {
      return 0LL;
    }
    goto LABEL_12;
  }

  uint64_t v7 = (int *)a1[1];
  if (!v7) {
    return 0LL;
  }
LABEL_12:
  int v8 = *v7;
  if ((*v7 & 0x80) == 0) {
    return 0LL;
  }
  uint64_t result = 0LL;
  unsigned int v9 = *v7 & 0x1F;
  if (v9 <= 0x12)
  {
    if (((1 << v9) & 0x60000) != 0)
    {
      int ResilientImmediateMembersOffset = 2;
      return &a1[ResilientImmediateMembersOffset];
    }

    if (v9 == 16)
    {
      if ((v8 & 0x20000000) != 0)
      {
        int ResilientImmediateMembersOffset = swift::getResilientImmediateMembersOffset((uint64_t)v7, a2, a3, a4);
      }

      else
      {
        if ((v8 & 0x10000000) != 0)
        {
          int v11 = 0;
          uint64_t v12 = v7 + 6;
        }

        else
        {
          int v11 = v7[7];
          uint64_t v12 = v7 + 8;
        }

        int ResilientImmediateMembersOffset = v11 - *v12;
      }

      return &a1[ResilientImmediateMembersOffset];
    }

    if (((1 << v9) & 0x16) != 0) {
      abort();
    }
  }

  return result;
}

uint64_t handleRefCountsDestroy(uint64_t result, void **a2, void *a3, uint64_t a4)
{
  unint64_t v4 = *(*a2)++;
  *a3 += v4 & 0xFFFFFFFFFFFFFFLL;
  if (HIBYTE(v4))
  {
    uint64_t v8 = result;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void **, void *, uint64_t))((char *)destroyTable
                                                                                + ((v4 >> 53) & 0x7F8)))( v8,  a2,  a3,  a4);
      unint64_t v4 = *(*a2)++;
      *a3 += v4 & 0xFFFFFFFFFFFFFFLL;
    }

    while (HIBYTE(v4));
  }

  return result;
}

id errorRetain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a5 + *a3);
  if ((v6 & 0x8000000000000000LL) == 0)
  {
    *(void *)(a4 + v5) = v6;
    *a3 = v5 + 8;
    return swift_errorRetain((id)(v6 & 0xFFFFFFFFFFFFFF8LL));
  }

  return result;
}

unint64_t *nativeStrongRetain(uint64_t a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a5 + *a3);
  *(void *)&a4[v5] = v6;
  *a3 = v5 + 8;
  return swift_retain((unint64_t *)(v6 & 0xFFFFFFFFFFFFFF8LL), a2, (uint64_t)a3, a4);
}

uint64_t unownedRetain(uint64_t a1, uint64_t a2, char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)a3;
  uint64_t v6 = *(void *)(a5 + *(void *)a3);
  *(void *)&a4[v5] = v6;
  *(void *)a3 = v5 + 8;
  return swift_unownedRetain(v6 & 0xFFFFFFFFFFFFFF8LL, a2, a3, a4);
}

swift *weakCopyInit(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = (swift *)&a4[*(void *)a3];
  uint64_t v6 = (void *)(a5 + *(void *)a3);
  *(void *)a3 += 8LL;
  return swift_weakCopyInit(v5, v6, a3, a4);
}

id unknownRetain(uint64_t a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void **)(a5 + *a3);
  *(void *)&a4[v5] = v6;
  *a3 = v5 + 8;
  return swift_unknownObjectRetain(v6, a2, (uint64_t)a3, a4);
}

void *unknownUnownedCopyInit(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = &a4[*(void *)a3];
  uint64_t v6 = (uint64_t *)(a5 + *(void *)a3);
  *(void *)a3 += 8LL;
  return swift_unknownObjectUnownedCopyInit(v5, v6, a3, a4);
}

id *unknownWeakCopyInit(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = (id *)&a4[*(void *)a3];
  uint64_t v6 = (id *)(a5 + *(void *)a3);
  *(void *)a3 += 8LL;
  return swift_unknownObjectWeakCopyInit(v5, v6, a3, a4);
}

unint64_t bridgeRetain(uint64_t a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  unint64_t v6 = *(void *)(a5 + *a3);
  *(void *)&a4[v5] = v6;
  *a3 = v5 + 8;
  return swift_bridgeObjectRetain(v6, a2, (uint64_t)a3, a4);
}

void *blockCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = *a3;
  id result = _Block_copy(*(const void **)(a5 + *a3));
  *(void *)(a4 + v7) = result;
  *a3 = v7 + 8;
  return result;
}

id objcStrongRetain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v6;
  *a3 = v5 + 8;
  if ((v6 & 0x8000000000000000LL) == 0) {
    return (id)(v6 & 0xFFFFFFFFFFFFFF8LL);
  }
  return result;
}

uint64_t metatypeInitWithCopy(uint64_t a1, uint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = **a2;
  uint64_t v6 = *a3;
  ++*a2;
  uint64_t v7 = *(void *)(v5 - 8);
  *a3 = *(void *)(v7 + 64) + v6;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 16))(a4 + v6, a5 + v6, v5);
}

uint64_t existentialInitWithCopy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a5 + *a3 + 24);
  uint64_t v6 = a4 + *a3;
  *a3 += 24LL;
  return (**(uint64_t (***)(uint64_t))(v5 - 8))(v6);
}

uint64_t resilientInitWithCopy(uint64_t *a1, int **a2, char *a3, char *a4, uint64_t a5)
{
  uint64_t v8 = *(void *)a3;
  uint64_t v9 = (uint64_t)*a2;
  uint64_t v10 = **a2;
  *a2 += 2;
  int v11 = (uint64_t (*)(uint64_t *))(v10 + v9);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1, (uint64_t)a2, a3, a4);
  uint64_t v13 = *(void *)(v11(GenericArgs) - 8);
  *(void *)a3 = *(void *)(v13 + 64) + v8;
  return (*(uint64_t (**)(char *, uint64_t))(v13 + 16))(&a4[v8], a5 + v8);
}

void *singlePayloadEnumSimple(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = *(void *)*a2;
  uint64_t v9 = *(void *)(*a2 + 32);
  size_t v8 = *(void *)(*a2 + 40);
  uint64_t v10 = *a2 + 48;
  uint64_t v11 = (v7 >> 59) & 7;
  if (v7 >> 62)
  {
    uint64_t v18 = *(void *)(*a2 + 8);
    uint64_t v12 = *a3;
    uint64_t v19 = a5 + *a3;
    int v20 = (1 << ((v7 >> 62) - 1));
    switch(v20)
    {
      case 4:
        uint64_t v21 = *(unsigned int *)(v19 + v18);
        break;
      case 2:
        uint64_t v21 = *(unsigned __int16 *)(v19 + v18);
        break;
      case 1:
        uint64_t v21 = *(unsigned __int8 *)(v19 + v18);
        break;
      default:
LABEL_23:
        abort();
    }

    if ((_DWORD)v11) {
      BOOL v22 = v21 == 0;
    }
    else {
      BOOL v22 = 0;
    }
    if (v22)
    {
LABEL_3:
      int v13 = (1 << (v11 - 1)) - 1;
      uint64_t v14 = *(void *)*a2;
      uint64_t v15 = a5 + v12;
      switch(v13)
      {
        case 0:
          uint64_t v16 = *(unsigned __int8 *)(v15 + v14);
          goto LABEL_8;
        case 1:
          uint64_t v16 = *(unsigned __int16 *)(v15 + v14);
          goto LABEL_8;
        case 3:
          uint64_t v16 = *(unsigned int *)(v15 + v14);
          goto LABEL_8;
        case 7:
          uint64_t v16 = *(void *)(v15 + v14);
LABEL_8:
          goto LABEL_10;
        default:
          goto LABEL_23;
      }
    }
  }

  else
  {
    uint64_t v12 = *a3;
    if ((_DWORD)v11) {
      goto LABEL_3;
    }
  }

  id result = memcpy((void *)(a4 + v12), (const void *)(a5 + v12), v8);
  v10 += v9;
  *a3 += v8;
LABEL_10:
  *a2 = v10;
  return result;
}

void *singlePayloadEnumFN(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a2;
  id result = (void *)((uint64_t (*)(uint64_t))(*(int *)*a2 + *a2))(a5 + *a3);
  if ((_DWORD)result)
  {
    size_t v12 = *(void *)(v9 + 16);
    uint64_t v11 = v9 + *(void *)(v9 + 8) + 24;
    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v12);
    *a3 += v12;
  }

  else
  {
    uint64_t v11 = v9 + 24;
  }

  *a2 = v11;
  return result;
}

void *singlePayloadEnumFNResolved(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(*(void *)a2 + 8LL);
  size_t v10 = *(void *)(*(void *)a2 + 16LL);
  uint64_t v11 = *(void *)a2 + 24LL;
  id result = (void *)(**(uint64_t (***)(uint64_t))a2)(a5 + *a3);
  if ((_DWORD)result)
  {
    v11 += v9;
    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v10);
    *a3 += v10;
  }

  *(void *)a2 = v11;
  return result;
}

void singlePayloadEnumGeneric(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9 = *(void *)*a2;
  uint64_t v10 = *(void *)(*a2 + 16);
  uint64_t v11 = *(void *)(*a2 + 28);
  size_t v12 = *(void *)(*a2 + 36);
  uint64_t v13 = *a2 + 44;
  if (v9 >> 62)
  {
    uint64_t v15 = *(void *)(*a2 + 8);
    uint64_t v14 = *a3;
    uint64_t v16 = a5 + *a3;
    int v17 = (1 << ((v9 >> 62) - 1));
    switch(v17)
    {
      case 4:
        uint64_t v18 = *(unsigned int *)(v16 + v15);
        break;
      case 2:
        uint64_t v18 = *(unsigned __int16 *)(v16 + v15);
        break;
      case 1:
        uint64_t v18 = *(unsigned __int8 *)(v16 + v15);
        break;
      default:
        abort();
    }

    if (v18) {
      goto LABEL_5;
    }
    if (!v10) {
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v14 = *a3;
    if (!v10)
    {
LABEL_5:
      v13 += v11;
      memcpy((void *)(a4 + v14), (const void *)(a5 + v14), v12);
      *a3 += v12;
      goto LABEL_6;
    }
  }

  if ((*(unsigned int (**)(uint64_t, void))(*(void *)(v10 - 8) + 48LL))( a5 + v14 + *(void *)*a2,  *(unsigned int *)(*(void *)(v10 - 8) + 84LL)))
  {
    uint64_t v14 = *a3;
    goto LABEL_5;
  }

void *multiPayloadEnumFN<&(handleRefCountsInitWithCopy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>( uint64_t a1, int **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (uint64_t (*)(size_t))((char *)*a2 + **a2);
  unint64_t v11 = *((void *)*a2 + 1);
  uint64_t v12 = *((void *)*a2 + 2);
  size_t v13 = *((void *)*a2 + 3);
  uint64_t v14 = (uint64_t)(*a2 + 8);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (int *)(v14 + v12 + 8 * v11);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v13);
    *a3 += v13;
  }

  else
  {
    *a3 = v17 + v13;
    uint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8LL * result));
    for (i = v18; ; uint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))( a1,  &i,  &v22,  a4,  a5);
      size_t v15 = v22;
    }

    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }

  return result;
}

void *multiPayloadEnumFNResolved<&(handleRefCountsInitWithCopy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>( uint64_t a1, uint64_t (***a2)(size_t), size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = **a2;
  unint64_t v11 = (unint64_t)(*a2)[1];
  size_t v13 = (*a2)[2];
  size_t v12 = (size_t)(*a2)[3];
  uint64_t v14 = (uint64_t)(*a2 + 4);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (uint64_t (**)(size_t))((char *)v13 + 8 * v11 + v14);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v12);
    *a3 += v12;
  }

  else
  {
    *a3 = v17 + v12;
    uint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8LL * result));
    for (i = v18; ; uint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))( a1,  &i,  &v22,  a4,  a5);
      size_t v15 = v22;
    }

    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }

  return result;
}

void *multiPayloadEnumGeneric<&(handleRefCountsInitWithCopy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>( void *result, uint64_t **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = **a2;
  unint64_t v7 = (*a2)[1];
  uint64_t v8 = (*a2)[2];
  size_t v9 = (*a2)[3];
  size_t v10 = *a3;
  size_t v25 = v10;
  int v11 = v6 - 1;
  size_t v15 = result;
  size_t v16 = v9 - v6;
  uint64_t v17 = a5 + v10;
  switch(v11)
  {
    case 0:
      unint64_t v18 = *(unsigned __int8 *)(v17 + v16);
      break;
    case 1:
      unint64_t v18 = *(unsigned __int16 *)(v17 + v16);
      break;
    case 3:
      unint64_t v18 = *(unsigned int *)(v17 + v16);
      break;
    case 7:
      unint64_t v18 = *(void *)(v17 + v16);
      break;
    default:
      abort();
  }

  unint64_t v19 = v5 + 4;
  *a2 = (void *)((char *)&v19[v7] + v8);
  if (v18 >= v7)
  {
    id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v9);
    *a3 += v9;
  }

  else
  {
    *a3 = v10 + v9;
    size_t v20 = (void *)((char *)&v19[v7] + v19[v18]);
    uint64_t v24 = v20;
    while (1)
    {
      unint64_t v21 = *v20;
      uint64_t v24 = v20 + 1;
      size_t v22 = v21 & 0xFFFFFFFFFFFFFFLL;
      if ((v21 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v22);
      }
      size_t v23 = v22 + v10;
      size_t v25 = v22 + v10;
      if (!HIBYTE(v21)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, void **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                + ((v21 >> 53) & 0x7F8)))( v15,  &v24,  &v25,  a4,  a5);
      size_t v20 = v24;
      size_t v10 = v25;
    }

    if (*a3 != v23) {
      return memcpy((void *)(a4 + v23), (const void *)(a5 + v23), *a3 - v23);
    }
  }

  return result;
}

void *handleRefCountsInitWithCopy(void *result, void **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  for (uint64_t i = result;
        ;
        id result = (void *)(*(uint64_t (**)(void *, void **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v11 >> 53) & 0x7F8)))( i,  a2,  a3,  a4,  a5))
  {
    uint64_t v10 = *a3;
    unint64_t v11 = *(*a2)++;
    if ((v11 & 0xFFFFFFFFFFFFFFLL) != 0) {
      id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v11 & 0xFFFFFFFFFFFFFFLL);
    }
    *a3 = (v11 & 0xFFFFFFFFFFFFFFLL) + v10;
    if (!HIBYTE(v11)) {
      break;
    }
  }

  return result;
}

void copyingInitWithTake(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a4 + *a3) = *(void *)(a5 + *a3);
  *a3 += 8LL;
}

id *unknownWeakInitWithTake(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (id *)(a4 + *a3);
  uint64_t v6 = (id *)(a5 + *a3);
  *a3 += 8LL;
  return swift_unknownObjectWeakTakeInit(v5, v6);
}

uint64_t metatypeInitWithTake(uint64_t a1, uint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = **a2;
  uint64_t v6 = *a3;
  ++*a2;
  uint64_t v7 = *(void *)(v5 - 8);
  *a3 = *(void *)(v7 + 64) + v6;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a4 + v6, a5 + v6, v5);
}

void *existentialInitWithTake(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *a3;
  uint64_t v7 = (void *)(a5 + *a3);
  uint64_t v8 = v7[3];
  id result = (void *)(a4 + v6);
  *a3 = v6 + 24;
  uint64_t v10 = *(void *)(v8 - 8);
  if ((*(_BYTE *)(v10 + 82) & 2) == 0) {
    return (void *)(*(uint64_t (**)(void *))(v10 + 32))(result);
  }
  *id result = *v7;
  return result;
}

uint64_t resilientInitWithTake(uint64_t *a1, int **a2, char *a3, char *a4, uint64_t a5)
{
  uint64_t v8 = *(void *)a3;
  uint64_t v9 = (uint64_t)*a2;
  uint64_t v10 = **a2;
  *a2 += 2;
  unint64_t v11 = (uint64_t (*)(uint64_t *))(v10 + v9);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1, (uint64_t)a2, a3, a4);
  uint64_t v13 = *(void *)(v11(GenericArgs) - 8);
  *(void *)a3 = *(void *)(v13 + 64) + v8;
  return (*(uint64_t (**)(char *, uint64_t))(v13 + 32))(&a4[v8], a5 + v8);
}

void *multiPayloadEnumFN<&(handleRefCountsInitWithTake(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>( uint64_t a1, int **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (uint64_t (*)(size_t))((char *)*a2 + **a2);
  unint64_t v11 = *((void *)*a2 + 1);
  uint64_t v12 = *((void *)*a2 + 2);
  size_t v13 = *((void *)*a2 + 3);
  uint64_t v14 = (uint64_t)(*a2 + 8);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (int *)(v14 + v12 + 8 * v11);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v13);
    *a3 += v13;
  }

  else
  {
    *a3 = v17 + v13;
    unint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8LL * result));
    for (i = v18; ; unint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithTakeTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))( a1,  &i,  &v22,  a4,  a5);
      size_t v15 = v22;
    }

    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }

  return result;
}

void *multiPayloadEnumFNResolved<&(handleRefCountsInitWithTake(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>( uint64_t a1, uint64_t (***a2)(size_t), size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = **a2;
  unint64_t v11 = (unint64_t)(*a2)[1];
  size_t v13 = (*a2)[2];
  size_t v12 = (size_t)(*a2)[3];
  uint64_t v14 = (uint64_t)(*a2 + 4);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (uint64_t (**)(size_t))((char *)v13 + 8 * v11 + v14);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v12);
    *a3 += v12;
  }

  else
  {
    *a3 = v17 + v12;
    unint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8LL * result));
    for (i = v18; ; unint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithTakeTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))( a1,  &i,  &v22,  a4,  a5);
      size_t v15 = v22;
    }

    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }

  return result;
}

void *multiPayloadEnumGeneric<&(handleRefCountsInitWithTake(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>( void *result, uint64_t **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = **a2;
  unint64_t v7 = (*a2)[1];
  uint64_t v8 = (*a2)[2];
  size_t v9 = (*a2)[3];
  size_t v10 = *a3;
  size_t v25 = v10;
  int v11 = v6 - 1;
  size_t v15 = result;
  size_t v16 = v9 - v6;
  uint64_t v17 = a5 + v10;
  switch(v11)
  {
    case 0:
      unint64_t v18 = *(unsigned __int8 *)(v17 + v16);
      break;
    case 1:
      unint64_t v18 = *(unsigned __int16 *)(v17 + v16);
      break;
    case 3:
      unint64_t v18 = *(unsigned int *)(v17 + v16);
      break;
    case 7:
      unint64_t v18 = *(void *)(v17 + v16);
      break;
    default:
      abort();
  }

  unint64_t v19 = v5 + 4;
  *a2 = (void *)((char *)&v19[v7] + v8);
  if (v18 >= v7)
  {
    id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v9);
    *a3 += v9;
  }

  else
  {
    *a3 = v10 + v9;
    size_t v20 = (void *)((char *)&v19[v7] + v19[v18]);
    uint64_t v24 = v20;
    while (1)
    {
      unint64_t v21 = *v20;
      uint64_t v24 = v20 + 1;
      size_t v22 = v21 & 0xFFFFFFFFFFFFFFLL;
      if ((v21 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v22);
      }
      size_t v23 = v22 + v10;
      size_t v25 = v22 + v10;
      if (!HIBYTE(v21)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, void **, size_t *, uint64_t, uint64_t))((char *)initWithTakeTable
                                                                                                + ((v21 >> 53) & 0x7F8)))( v15,  &v24,  &v25,  a4,  a5);
      size_t v20 = v24;
      size_t v10 = v25;
    }

    if (*a3 != v23) {
      return memcpy((void *)(a4 + v23), (const void *)(a5 + v23), *a3 - v23);
    }
  }

  return result;
}

void errorAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  if ((v6 & 0x8000000000000000LL) == 0) {
    swift_errorRelease((id)(v6 & 0xFFFFFFFFFFFFFF8LL));
  }
  if ((v7 & 0x8000000000000000LL) == 0) {
    swift_errorRetain((id)(v7 & 0xFFFFFFFFFFFFFF8LL));
  }
}

unint64_t *nativeStrongAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  uint64_t v8 = (unint64_t *)(v7 & 0xFFFFFFFFFFFFFF8LL);
  *a3 = v5 + 8;
  swift_release(v6 & 0xFFFFFFFFFFFFFF8LL);
  return swift_retain(v8, v9, v10, v11);
}

uint64_t unownedAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  uint64_t v8 = v7 & 0xFFFFFFFFFFFFFF8LL;
  *a3 = v5 + 8;
  swift_unownedRelease(v6 & 0xFFFFFFFFFFFFFF8LL);
  return swift_unownedRetain(v8, v9, v10, v11);
}

uint64_t *weakAssignWithCopy(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = (uint64_t *)&a4[*(void *)a3];
  uint64_t v6 = (uint64_t *)(a5 + *(void *)a3);
  *(void *)a3 += 8LL;
  return swift_weakCopyAssign(v5, v6, a3, a4);
}

id unknownAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void **)(a4 + *a3);
  uint64_t v7 = *(void **)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  swift_unknownObjectRelease(v6);
  return swift_unknownObjectRetain(v7, v8, v9, v10);
}

uint64_t *unknownUnownedAssignWithCopy(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = (uint64_t *)&a4[*(void *)a3];
  uint64_t v6 = (uint64_t *)(a5 + *(void *)a3);
  *(void *)a3 += 8LL;
  return swift_unknownObjectUnownedCopyAssign(v5, v6, a3, a4);
}

id *unknownWeakAssignWithCopy(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = (id *)&a4[*(void *)a3];
  uint64_t v6 = (id *)(a5 + *(void *)a3);
  *(void *)a3 += 8LL;
  return swift_unknownObjectWeakCopyAssign(v5, v6, a3, a4);
}

unint64_t bridgeAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  unint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  swift_bridgeObjectRelease(v6);
  return swift_bridgeObjectRetain(v7, v8, v9, v10);
}

void *blockAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *a3;
  _Block_release(*(const void **)(a4 + *a3));
  id result = _Block_copy(*(const void **)(a5 + v8));
  *(void *)(a4 + v8) = result;
  *a3 = v8 + 8;
  return result;
}

void objcStrongAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  if ((v6 & 0x8000000000000000LL) == 0) {

  }
  if ((v7 & 0x8000000000000000LL) == 0) {
    id v8 = (id)(v7 & 0xFFFFFFFFFFFFFF8LL);
  }
}

uint64_t metatypeAssignWithCopy(uint64_t a1, uint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = **a2;
  uint64_t v6 = *a3;
  ++*a2;
  uint64_t v7 = *(void *)(v5 - 8);
  *a3 = *(void *)(v7 + 64) + v6;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 24))(a4 + v6, a5 + v6, v5);
}

unint64_t *existentialAssignWithCopy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (uint64_t *)(a5 + *a3);
  uint64_t v6 = v5[3];
  uint64_t v7 = (uint64_t *)(a4 + *a3);
  uint64_t v8 = v7[3];
  *a3 += 24LL;
  if (v6 == v8)
  {
    uint64_t v13 = *(void *)(v6 - 8);
    if ((*(_BYTE *)(v13 + 82) & 2) == 0)
    {
      uint64_t v14 = *(uint64_t (**)(uint64_t *, uint64_t *, uint64_t))(v13 + 24);
      return (unint64_t *)v14(v7, v5, v6);
    }

    swift_release(*v7);
  }

  else
  {
    uint64_t v9 = *(void *)(v8 - 8);
    if ((*(_BYTE *)(v9 + 82) & 2) != 0) {
      swift_release(*v7);
    }
    else {
      (*(void (**)(uint64_t *))(v9 + 8))(v7);
    }
    uint64_t v15 = *(void *)(v6 - 8);
    if ((*(_BYTE *)(v15 + 82) & 2) == 0)
    {
      uint64_t v14 = *(uint64_t (**)(uint64_t *, uint64_t *, uint64_t))(v15 + 16);
      return (unint64_t *)v14(v7, v5, v6);
    }
  }

  *uint64_t v7 = *v5;
  return swift_retain((unint64_t *)*v5, v10, v11, v12);
}

uint64_t resilientAssignWithCopy(uint64_t *a1, int **a2, char *a3, char *a4, uint64_t a5)
{
  uint64_t v8 = *(void *)a3;
  uint64_t v9 = (uint64_t)*a2;
  uint64_t v10 = **a2;
  *a2 += 2;
  uint64_t v11 = (uint64_t (*)(uint64_t *))(v10 + v9);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1, (uint64_t)a2, a3, a4);
  uint64_t v13 = *(void *)(v11(GenericArgs) - 8);
  *(void *)a3 = *(void *)(v13 + 64) + v8;
  return (*(uint64_t (**)(char *, uint64_t))(v13 + 24))(&a4[v8], a5 + v8);
}

void *singlePayloadEnumSimpleAssignWithCopy( void *result, unint64_t **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = result;
  size_t v10 = *a3;
  size_t v40 = *a3;
  unint64_t v12 = **a2;
  unint64_t v11 = (*a2)[1];
  unint64_t v14 = (*a2)[2];
  unint64_t v13 = (*a2)[3];
  uint64_t v15 = (*a2)[4];
  size_t v16 = (*a2)[5];
  uint64_t v17 = *a2 + 6;
  unint64_t v41 = v17;
  uint64_t v18 = (v12 >> 59) & 7;
  uint64_t v19 = v12;
  unint64_t v20 = v12 >> 62;
  if (v20)
  {
    int v26 = 1 << (v20 - 1);
    uint64_t v27 = a5 + v10;
    switch(v26)
    {
      case 1u:
        unint64_t v25 = *(unsigned __int8 *)(v27 + v11);
        unint64_t v21 = *(unsigned __int8 *)(a4 + v10 + v11);
        if (!(_DWORD)v18) {
          goto LABEL_28;
        }
        break;
      case 2u:
        unint64_t v25 = *(unsigned __int16 *)(v27 + v11);
        unint64_t v21 = *(unsigned __int16 *)(a4 + v10 + v11);
        if (!(_DWORD)v18) {
          goto LABEL_28;
        }
        break;
      case 4u:
        unint64_t v25 = *(unsigned int *)(v27 + v11);
        unint64_t v21 = *(unsigned int *)(a4 + v10 + v11);
        if (!(_DWORD)v18) {
          goto LABEL_28;
        }
        break;
      default:
LABEL_49:
        abort();
    }

    int v22 = 1 << (v18 - 1);
    if (!v25) {
      goto LABEL_4;
    }
    unint64_t v25 = 0LL;
    if (!v21)
    {
LABEL_22:
      uint64_t v28 = a4 + v10;
      switch((char)v22)
      {
        case 1:
          uint64_t v29 = *(unsigned __int8 *)(v28 + v19);
          goto LABEL_27;
        case 2:
          uint64_t v29 = *(unsigned __int16 *)(v28 + v19);
          goto LABEL_27;
        case 4:
          uint64_t v29 = *(unsigned int *)(v28 + v19);
          goto LABEL_27;
        case 8:
          uint64_t v29 = *(void *)(v28 + v19);
LABEL_27:
          unint64_t v21 = v29 - v14;
          goto LABEL_28;
        default:
          goto LABEL_49;
      }
    }

void *singlePayloadEnumFNAssignWithCopy( uint64_t a1, unint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t (*)(uint64_t))((char *)*a2 + *(int *)*a2);
  uint64_t v11 = (*a2)[1];
  size_t v10 = (*a2)[2];
  unint64_t v12 = *a2 + 3;
  uint64_t v23 = v12;
  int v13 = v9(a5 + *a3);
  id result = (void *)v9(a4 + *a3);
  if (v13 | result)
  {
    uint64_t v15 = (unint64_t *)((char *)v12 + v11);
    if (v13)
    {
      if (!(_DWORD)result)
      {
        uint64_t v24 = *a3;
        if (v11 >= 1)
        {
          do
          {
            unint64_t v17 = *v12++;
            unint64_t v16 = v17;
            uint64_t v23 = v12;
            v24 += v17 & 0xFFFFFFFFFFFFFFLL;
            if (HIBYTE(v17))
            {
              (*(void (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                       + ((v16 >> 53) & 0x7F8)))( a1,  &v23,  &v24,  a4);
              unint64_t v12 = v23;
            }
          }

          while (v12 < v15);
        }

        uint64_t v15 = v12;
      }

      id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v10);
      *a3 += v10;
      unint64_t v12 = v15;
    }

    else if (v11 >= 1)
    {
      do
      {
        unint64_t v19 = *v12++;
        unint64_t v18 = v19;
        uint64_t v23 = v12;
        uint64_t v20 = *a3;
        size_t v21 = v19 & 0xFFFFFFFFFFFFFFLL;
        if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
          id result = memcpy((void *)(a4 + v20), (const void *)(a5 + v20), v21);
        }
        *a3 = v20 + v21;
        if (HIBYTE(v18))
        {
          id result = (void *)(*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v18 >> 53) & 0x7F8)))( a1,  &v23,  a3,  a4,  a5);
          unint64_t v12 = v23;
        }
      }

      while (v12 < v15);
    }
  }

  *a2 = v12;
  return result;
}

void *singlePayloadEnumFNResolvedAssignWithCopy( uint64_t a1, unint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t (*)(uint64_t))**a2;
  uint64_t v10 = (*a2)[1];
  size_t v11 = (*a2)[2];
  unint64_t v12 = *a2 + 3;
  uint64_t v23 = v12;
  int v13 = v9(a5 + *a3);
  id result = (void *)v9(a4 + *a3);
  if (v13 | result)
  {
    uint64_t v15 = (unint64_t *)((char *)v12 + v10);
    if (v13)
    {
      if (!(_DWORD)result)
      {
        uint64_t v24 = *a3;
        if (v10 >= 1)
        {
          do
          {
            unint64_t v17 = *v12++;
            unint64_t v16 = v17;
            uint64_t v23 = v12;
            v24 += v17 & 0xFFFFFFFFFFFFFFLL;
            if (HIBYTE(v17))
            {
              (*(void (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                       + ((v16 >> 53) & 0x7F8)))( a1,  &v23,  &v24,  a4);
              unint64_t v12 = v23;
            }
          }

          while (v12 < v15);
        }

        uint64_t v15 = v12;
      }

      id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v11);
      *a3 += v11;
      unint64_t v12 = v15;
    }

    else if (v10 >= 1)
    {
      do
      {
        unint64_t v19 = *v12++;
        unint64_t v18 = v19;
        uint64_t v23 = v12;
        uint64_t v20 = *a3;
        size_t v21 = v19 & 0xFFFFFFFFFFFFFFLL;
        if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
          id result = memcpy((void *)(a4 + v20), (const void *)(a5 + v20), v21);
        }
        *a3 = v20 + v21;
        if (HIBYTE(v18))
        {
          id result = (void *)(*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v18 >> 53) & 0x7F8)))( a1,  &v23,  a3,  a4,  a5);
          unint64_t v12 = v23;
        }
      }

      while (v12 < v15);
    }
  }

  *a2 = v12;
  return result;
}

void *singlePayloadEnumGenericAssignWithCopy(void *result, char **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = result;
  unint64_t v10 = *(void *)*a2;
  uint64_t v9 = *((void *)*a2 + 1);
  uint64_t v11 = *((void *)*a2 + 2);
  uint64_t v12 = *(void *)(*a2 + 28);
  size_t v13 = *(void *)(*a2 + 36);
  unint64_t v14 = *a2 + 44;
  int v31 = v14;
  uint64_t v15 = v10;
  size_t __n = v13;
  if (!(v10 >> 62))
  {
    uint64_t v16 = 0LL;
    if (!v11)
    {
      uint64_t v18 = 0LL;
      goto LABEL_9;
    }

    uint64_t v17 = *a3;
LABEL_4:
    id result = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(v11 - 8) + 48LL))( a5 + v17 + v15,  *(unsigned int *)(*(void *)(v11 - 8) + 84LL),  v11);
    uint64_t v18 = result;
    goto LABEL_5;
  }

  int v27 = 1 << ((v10 >> 62) - 1);
  uint64_t v17 = *a3;
  uint64_t v28 = a5 + *a3;
  switch(v27)
  {
    case 1u:
      uint64_t v18 = *(unsigned __int8 *)(v28 + v9);
      uint64_t v16 = *(unsigned __int8 *)(a4 + v17 + v9);
      if (!v11) {
        goto LABEL_9;
      }
      break;
    case 2u:
      uint64_t v18 = *(unsigned __int16 *)(v28 + v9);
      uint64_t v16 = *(unsigned __int16 *)(a4 + v17 + v9);
      if (!v11) {
        goto LABEL_9;
      }
      break;
    case 4u:
      uint64_t v18 = *(unsigned int *)(v28 + v9);
      uint64_t v16 = *(unsigned int *)(a4 + v17 + v9);
      if (!v11) {
        goto LABEL_9;
      }
      break;
    default:
      abort();
  }

  if (!v18) {
    goto LABEL_4;
  }
LABEL_5:
  if (v16)
  {
    if (!v18) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  id result = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(v11 - 8) + 48LL))( a4 + *a3 + v15,  *(unsigned int *)(*(void *)(v11 - 8) + 84LL),  v11);
  uint64_t v16 = result;
LABEL_9:
  if (!(v18 | v16)) {
    goto LABEL_14;
  }
  if (v18)
  {
    if (!v16)
    {
      uint64_t v32 = *a3;
      if (v12 >= 1)
      {
        uint64_t v24 = &v14[v12];
        do
        {
          unint64_t v26 = *(void *)v14;
          v14 += 8;
          unint64_t v25 = v26;
          int v31 = v14;
          v32 += v26 & 0xFFFFFFFFFFFFFFLL;
          if (HIBYTE(v26))
          {
            (*(void (**)(void *, char **, uint64_t *, uint64_t))((char *)destroyTable + ((v25 >> 53) & 0x7F8)))( v8,  &v31,  &v32,  a4);
            unint64_t v14 = v31;
          }
        }

        while (v14 < v24);
      }

      goto LABEL_13;
    }

void *multiPayloadEnumFNAssignWithCopy(uint64_t *a1, int **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = (uint64_t (*)(void))((char *)*a2 + **a2);
  unint64_t v11 = *((void *)*a2 + 1);
  uint64_t v107 = *((void *)*a2 + 2);
  size_t __n = *((void *)*a2 + 3);
  uint64_t v12 = (uint64_t)(*a2 + 8);
  uint64_t v13 = *a3;
  uint64_t v114 = v13;
  __src = (void *)(a5 + v13);
  unsigned int v14 = v10();
  id result = (void *)((uint64_t (*)(uint64_t))v10)(a4 + *a3);
  uint64_t v19 = 8 * v11;
  *a2 = (int *)(v12 + v107 + 8 * v11);
  if (v11 > v14 && v11 > result)
  {
    *a3 += __n;
    uint64_t v21 = *(void *)(v12 + 8LL * v14);
    if (v14 == (_DWORD)result)
    {
      uint64_t v115 = (unint64_t *)(v12 + v21 + v19);
      size_t v23 = (uint64_t *)(v115 + 1);
      unint64_t v22 = *v115;
      uint64_t v24 = *v115 & 0xFFFFFFFFFFFFFFLL;
      if (v24) {
        id result = memcpy((void *)(a4 + v13), __src, v22 & 0xFFFFFFFFFFFFFFLL);
      }
      uint64_t v25 = v24 + v13;
      uint64_t v113 = v24 + v13;
      switch(HIBYTE(v22))
      {
        case 0u:
          break;
        case 1u:
          uint64_t v35 = *(void *)(a4 + v25);
          uint64_t v36 = *(void *)(a5 + v25);
          *(void *)(a4 + v25) = v36;
          uint64_t v37 = v25 + 8;
          uint64_t v113 = v25 + 8;
          if ((v35 & 0x8000000000000000LL) == 0) {
            swift_errorRelease((id)(v35 & 0xFFFFFFFFFFFFFF8LL));
          }
          if ((v36 & 0x8000000000000000LL) == 0) {
            swift_errorRetain((id)(v36 & 0xFFFFFFFFFFFFFF8LL));
          }
          uint64_t v38 = *v23;
          size_t v39 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v39) {
            memcpy((void *)(a4 + v37), (const void *)(a5 + v37), v39);
          }
          uint64_t v113 = v39 + v37;
          __asm { BR              X9 }

          return result;
        case 2u:
          uint64_t v40 = *(void *)(a4 + v25);
          uint64_t v41 = *(void *)(a5 + v25);
          *(void *)(a4 + v25) = v41;
          size_t v42 = (unint64_t *)(v41 & 0xFFFFFFFFFFFFFF8LL);
          uint64_t v43 = v25 + 8;
          uint64_t v113 = v25 + 8;
          swift_release(v40 & 0xFFFFFFFFFFFFFF8LL);
          swift_retain(v42, v44, v45, v46);
          uint64_t v47 = *v23;
          size_t v48 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v48) {
            memcpy((void *)(a4 + v43), (const void *)(a5 + v43), v48);
          }
          uint64_t v113 = v48 + v43;
          __asm { BR              X9 }

          return result;
        case 3u:
          uint64_t v49 = *(void *)(a4 + v25);
          uint64_t v50 = *(void *)(a5 + v25);
          *(void *)(a4 + v25) = v50;
          uint64_t v51 = v50 & 0xFFFFFFFFFFFFFF8LL;
          uint64_t v52 = v25 + 8;
          uint64_t v113 = v25 + 8;
          swift_unownedRelease(v49 & 0xFFFFFFFFFFFFFF8LL);
          swift_unownedRetain(v51, v53, v54, v55);
          uint64_t v56 = *v23;
          size_t v57 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v57) {
            memcpy((void *)(a4 + v52), (const void *)(a5 + v52), v57);
          }
          uint64_t v113 = v57 + v52;
          __asm { BR              X9 }

          return result;
        case 4u:
          uint64_t v58 = v25 + 8;
          uint64_t v113 = v25 + 8;
          swift_weakCopyAssign((uint64_t *)(a4 + v25), (uint64_t *)(a5 + v25), v17, v18);
          uint64_t v59 = *v23;
          size_t v60 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v60) {
            memcpy((void *)(a4 + v58), (const void *)(a5 + v58), v60);
          }
          uint64_t v113 = v60 + v58;
          __asm { BR              X9 }

          return result;
        case 5u:
          char v61 = *(void **)(a4 + v25);
          char v62 = *(void **)(a5 + v25);
          *(void *)(a4 + v25) = v62;
          uint64_t v63 = v25 + 8;
          uint64_t v113 = v25 + 8;
          swift_unknownObjectRelease(v61);
          swift_unknownObjectRetain(v62, v64, v65, v66);
          uint64_t v67 = *v23;
          size_t v68 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v68) {
            memcpy((void *)(a4 + v63), (const void *)(a5 + v63), v68);
          }
          uint64_t v113 = v68 + v63;
          __asm { BR              X9 }

          return result;
        case 6u:
          uint64_t v69 = v25 + 8;
          uint64_t v113 = v25 + 8;
          swift_unknownObjectUnownedCopyAssign((uint64_t *)(a4 + v25), (uint64_t *)(a5 + v25), v17, v18);
          uint64_t v70 = *v23;
          size_t v71 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v71) {
            memcpy((void *)(a4 + v69), (const void *)(a5 + v69), v71);
          }
          uint64_t v113 = v71 + v69;
          __asm { BR              X9 }

          return result;
        case 7u:
          uint64_t v72 = v25 + 8;
          uint64_t v113 = v25 + 8;
          swift_unknownObjectWeakCopyAssign((id *)(a4 + v25), (id *)(a5 + v25), v17, v18);
          uint64_t v73 = *v23;
          size_t v74 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v74) {
            memcpy((void *)(a4 + v72), (const void *)(a5 + v72), v74);
          }
          uint64_t v113 = v74 + v72;
          __asm { BR              X9 }

          return result;
        case 8u:
          uint64_t v75 = *(void *)(a4 + v25);
          unint64_t v76 = *(void *)(a5 + v25);
          *(void *)(a4 + v25) = v76;
          uint64_t v77 = v25 + 8;
          uint64_t v113 = v25 + 8;
          swift_bridgeObjectRelease(v75);
          swift_bridgeObjectRetain(v76, v78, v79, v80);
          uint64_t v81 = *v23;
          size_t v82 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v82) {
            memcpy((void *)(a4 + v77), (const void *)(a5 + v77), v82);
          }
          uint64_t v113 = v82 + v77;
          __asm { BR              X9 }

          return result;
        case 9u:
          _Block_release(*(const void **)(a4 + v25));
          *(void *)(a4 + v25) = _Block_copy(*(const void **)(a5 + v25));
          uint64_t v83 = v25 + 8;
          uint64_t v113 = v25 + 8;
          uint64_t v84 = *v23;
          size_t v85 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v85) {
            memcpy((void *)(a4 + v83), (const void *)(a5 + v83), v85);
          }
          uint64_t v113 = v85 + v83;
          __asm { BR              X9 }

          return result;
        case 0xAu:
          uint64_t v86 = *(void *)(a4 + v25);
          uint64_t v87 = *(void *)(a5 + v25);
          *(void *)(a4 + v25) = v87;
          uint64_t v88 = v25 + 8;
          uint64_t v113 = v25 + 8;
          if ((v86 & 0x8000000000000000LL) == 0) {

          }
          if ((v87 & 0x8000000000000000LL) == 0) {
            id v89 = (id)(v87 & 0xFFFFFFFFFFFFFF8LL);
          }
          uint64_t v90 = *v23;
          size_t v91 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v91) {
            memcpy((void *)(a4 + v88), (const void *)(a5 + v88), v91);
          }
          uint64_t v113 = v91 + v88;
          __asm { BR              X9 }

          return result;
        case 0xBu:
        case 0xDu:
          abort();
        case 0xCu:
          uint64_t v92 = *(void *)(*v23 - 8);
          uint64_t v93 = *(void *)(v92 + 64) + v25;
          (*(void (**)(uint64_t, uint64_t))(v92 + 24))(a4 + v25, a5 + v25);
          unint64_t v94 = v115[2];
          if ((v94 & 0xFFFFFFFFFFFFFFLL) != 0) {
            memcpy((void *)(a4 + v93), (const void *)(a5 + v93), v94 & 0xFFFFFFFFFFFFFFLL);
          }
          uint64_t v113 = (v94 & 0xFFFFFFFFFFFFFFLL) + v93;
          __asm { BR              X9 }

          return result;
        case 0xEu:
          existentialAssignWithCopy((uint64_t)result, v16, &v113, a4, a5);
          uint64_t v95 = *v23;
          uint64_t v96 = v113;
          size_t v97 = *v23 & 0xFFFFFFFFFFFFFFLL;
          if (v97) {
            memcpy((void *)(a4 + v113), (const void *)(a5 + v113), v97);
          }
          uint64_t v113 = v96 + v97;
          __asm { BR              X9 }

          return result;
        case 0xFu:
          uint64x2_t v98 = (uint64_t (*)(uint64_t *))((char *)v23 + *(int *)v23);
          GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1, v16, v17, v18);
          uint64_t v100 = *(void *)(v98(GenericArgs) - 8);
          uint64_t v101 = *(void *)(v100 + 64) + v25;
          (*(void (**)(uint64_t, uint64_t))(v100 + 24))(a4 + v25, a5 + v25);
          unint64_t v102 = v115[2];
          if ((v102 & 0xFFFFFFFFFFFFFFLL) != 0) {
            memcpy((void *)(a4 + v101), (const void *)(a5 + v101), v102 & 0xFFFFFFFFFFFFFFLL);
          }
          uint64_t v113 = (v102 & 0xFFFFFFFFFFFFFFLL) + v101;
          __asm { BR              X9 }

          return result;
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
          uint64_t v111 = (uint64_t *)(v115 + 1);
          uint64_t v112 = v24 + v13;
          ((void (*)(uint64_t *, uint64_t **, uint64_t *, uint64_t, uint64_t))assignWithCopyTable[HIBYTE(v22)])( a1,  &v111,  &v112,  a4,  a5);
          uint64_t v103 = v112;
          uint64_t v104 = *v111;
          uint64_t v105 = *v111 & 0xFFFFFFFFFFFFFFLL;
          if (v105) {
            memcpy((void *)(a4 + v112), (const void *)(a5 + v112), *v111 & 0xFFFFFFFFFFFFFFLL);
          }
          uint64_t v113 = v105 + v103;
          __asm { BR              X9 }

          return result;
      }
    }

    else
    {
      uint64_t v26 = *(void *)(v12 + 8LL * result);
      uint64_t v115 = (unint64_t *)(v12 + v21 + v19);
      int v27 = (unint64_t *)(v12 + v19 + v26);
      unint64_t v28 = *v27;
      uint64_t v110 = v27 + 1;
      for (uint64_t i = (v28 & 0xFFFFFFFFFFFFFFLL) + v13; HIBYTE(v28); i += v28 & 0xFFFFFFFFFFFFFFLL)
      {
        id result = (void *)(*(uint64_t (**)(uint64_t *, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable + ((v28 >> 53) & 0x7F8)))( a1,  &v110,  &i,  a4);
        unint64_t v28 = *v110++;
      }

      while (1)
      {
        uint64_t v29 = v114;
        unint64_t v30 = *v115++;
        uint64_t v31 = v30 & 0xFFFFFFFFFFFFFFLL;
        if ((v30 & 0xFFFFFFFFFFFFFFLL) != 0) {
          id result = memcpy((void *)(a4 + v114), (const void *)(a5 + v114), v30 & 0xFFFFFFFFFFFFFFLL);
        }
        uint64_t v25 = v31 + v29;
        uint64_t v114 = v31 + v29;
        if (!HIBYTE(v30)) {
          break;
        }
        id result = (void *)(*(uint64_t (**)(uint64_t *, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v30 >> 53) & 0x7F8)))( a1,  &v115,  &v114,  a4,  a5);
      }
    }

    size_t v32 = *a3 - v25;
    if (*a3 != v25)
    {
      unint64_t v33 = (void *)(a4 + v25);
      size_t v34 = (const void *)(a5 + v25);
      return memcpy(v33, v34, v32);
    }
  }

  else
  {
    if (v11 > v14)
    {
      *a3 += __n;
      uint64_t v115 = (unint64_t *)(v12 + v19 + *(void *)(v12 + 8LL * v14));
      id result = handleRefCountsInitWithCopy(a1, &v115, &v114, a4, a5);
      size_t v32 = *a3 - v114;
      if (*a3 == v114) {
        return result;
      }
      unint64_t v33 = (void *)(a4 + v114);
      size_t v34 = (const void *)(a5 + v114);
      return memcpy(v33, v34, v32);
    }

    if (v11 > result)
    {
      uint64_t v115 = (unint64_t *)(v12 + v19 + *(void *)(v12 + 8LL * result));
      handleRefCountsDestroy((uint64_t)a1, &v115, &v114, a4);
    }

    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), __n);
    *a3 += __n;
  }

  return result;
}

void *multiPayloadEnumFNResolvedAssignWithCopy( void *a1, uint64_t (***a2)(uint64_t), uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = **a2;
  unint64_t v11 = (unint64_t)(*a2)[1];
  size_t __n = (size_t)(*a2)[3];
  unint64_t v28 = (*a2)[2];
  uint64_t v12 = (uint64_t)(*a2 + 4);
  uint64_t v13 = *a3;
  uint64_t v31 = v13;
  unsigned int v14 = v10(a5 + v13);
  id result = (void *)v10(a4 + *a3);
  uint64_t v16 = 8 * v11;
  *a2 = (uint64_t (**)(uint64_t))((char *)v28 + 8 * v11 + v12);
  if (v11 > v14 && v11 > result)
  {
    *a3 += __n;
    uint64_t v18 = *(void *)(v12 + 8LL * result);
    uint64_t v19 = v12 + v16;
    size_t v32 = (unint64_t *)(v19 + *(void *)(v12 + 8LL * v14));
    unint64_t v20 = (unint64_t *)(v19 + v18);
    unint64_t v21 = *v20;
    unint64_t v30 = v20 + 1;
    for (uint64_t i = (v21 & 0xFFFFFFFFFFFFFFLL) + v13; HIBYTE(v21); i += v21 & 0xFFFFFFFFFFFFFFLL)
    {
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                                  + ((v21 >> 53) & 0x7F8)))( a1,  &v30,  &i,  a4);
      unint64_t v21 = *v30++;
    }

    while (1)
    {
      uint64_t v22 = v31;
      unint64_t v23 = *v32++;
      uint64_t v24 = v23 & 0xFFFFFFFFFFFFFFLL;
      if ((v23 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v31), (const void *)(a5 + v31), v23 & 0xFFFFFFFFFFFFFFLL);
      }
      uint64_t v25 = v24 + v22;
      uint64_t v31 = v24 + v22;
      if (!HIBYTE(v23)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v23 >> 53) & 0x7F8)))( a1,  &v32,  &v31,  a4,  a5);
    }

    size_t v26 = *a3 - v25;
    if (*a3 != v25) {
      return memcpy((void *)(a4 + v25), (const void *)(a5 + v25), v26);
    }
  }

  else
  {
    if (v11 > v14)
    {
      *a3 += __n;
      size_t v32 = (unint64_t *)(v12 + v16 + *(void *)(v12 + 8LL * v14));
      id result = handleRefCountsInitWithCopy(a1, &v32, &v31, a4, a5);
      uint64_t v25 = v31;
      size_t v26 = *a3 - v31;
      if (*a3 == v31) {
        return result;
      }
      return memcpy((void *)(a4 + v25), (const void *)(a5 + v25), v26);
    }

    if (v11 > result)
    {
      size_t v32 = (unint64_t *)(v12 + v16 + *(void *)(v12 + 8LL * result));
      handleRefCountsDestroy((uint64_t)a1, &v32, &v31, a4);
    }

    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), __n);
    *a3 += __n;
  }

  return result;
}

void *multiPayloadEnumGenericAssignWithCopy(void *result, uint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v7 = **a2;
  unint64_t v6 = (*a2)[1];
  uint64_t v8 = (*a2)[2];
  size_t v9 = (*a2)[3];
  uint64_t v10 = *a3;
  uint64_t v36 = v10;
  int v11 = v7 - 1;
  uint64_t v15 = result;
  size_t v16 = v9 - v7;
  uint64_t v17 = a5 + v10;
  switch(v11)
  {
    case 0:
      unint64_t v18 = *(unsigned __int8 *)(v17 + v16);
      unint64_t v19 = *(unsigned __int8 *)(a4 + v10 + v16);
      break;
    case 1:
      unint64_t v18 = *(unsigned __int16 *)(v17 + v16);
      unint64_t v19 = *(unsigned __int16 *)(a4 + v10 + v16);
      break;
    case 3:
      unint64_t v18 = *(unsigned int *)(v17 + v16);
      unint64_t v19 = *(unsigned int *)(a4 + v10 + v16);
      break;
    case 7:
      unint64_t v18 = *(void *)(v17 + v16);
      unint64_t v19 = *(void *)(a4 + v10 + v16);
      break;
    default:
      abort();
  }

  unint64_t v20 = v5 + 4;
  uint64_t v21 = v6;
  *a2 = (void *)((char *)&v20[v6] + v8);
  if (v18 >= v6 || v19 >= v6)
  {
    if (v18 >= v6)
    {
      if (v19 < v6)
      {
        uint64_t v35 = (void *)((char *)&v20[v21] + v20[v19]);
        handleRefCountsDestroy((uint64_t)result, &v35, &v36, a4);
        uint64_t v10 = *a3;
      }

      id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v9);
      *a3 += v9;
    }

    else
    {
      *a3 = v10 + v9;
      uint64_t v35 = (void *)((char *)&v20[v21] + v20[v18]);
      id result = handleRefCountsInitWithCopy(result, &v35, &v36, a4, a5);
      uint64_t v31 = v36;
      size_t v32 = *a3 - v36;
      if (*a3 != v36) {
        return memcpy((void *)(a4 + v31), (const void *)(a5 + v31), v32);
      }
    }
  }

  else
  {
    *a3 = v10 + v9;
    uint64_t v23 = v20[v18];
    uint64_t v24 = v20[v19];
    uint64_t v25 = &v20[v21];
    uint64_t v35 = (void *)((char *)v25 + v23);
    size_t v26 = (void *)((char *)v25 + v24);
    unint64_t v27 = *v26;
    size_t v34 = v26 + 1;
    for (uint64_t i = (v27 & 0xFFFFFFFFFFFFFFLL) + v10; HIBYTE(v27); i += v27 & 0xFFFFFFFFFFFFFFLL)
    {
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                                  + ((v27 >> 53) & 0x7F8)))( v15,  &v34,  &i,  a4);
      unint64_t v27 = *v34++;
    }

    while (1)
    {
      uint64_t v28 = v36;
      unint64_t v29 = *v35++;
      uint64_t v30 = v29 & 0xFFFFFFFFFFFFFFLL;
      if ((v29 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v36), (const void *)(a5 + v36), v29 & 0xFFFFFFFFFFFFFFLL);
      }
      uint64_t v31 = v30 + v28;
      uint64_t v36 = v30 + v28;
      if (!HIBYTE(v29)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v29 >> 53) & 0x7F8)))( v15,  &v35,  &v36,  a4,  a5);
    }

    size_t v32 = *a3 - v31;
    if (*a3 != v31) {
      return memcpy((void *)(a4 + v31), (const void *)(a5 + v31), v32);
    }
  }

  return result;
}

void *std::__function::__func<swift_enumSimple_getEnumTag::$_0,std::allocator<swift_enumSimple_getEnumTag::$_0>,std::optional<unsigned int> ()(unsigned long,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = off_189B8AEA8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_0,std::allocator<swift_enumSimple_getEnumTag::$_0>,std::optional<unsigned int> ()(unsigned long,unsigned long,unsigned char)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_189B8AEA8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_0,std::allocator<swift_enumSimple_getEnumTag::$_0>,std::optional<unsigned int> ()(unsigned long,unsigned long,unsigned char)>::operator()( uint64_t a1, void *a2, unint64_t *a3, _BYTE *a4)
{
  unint64_t v4 = *a3;
  uint64_t v5 = *(unsigned __int8 **)(a1 + 8);
  switch(*a4)
  {
    case 1:
      LODWORD(v6) = v5[v4];
      if (!v5[v4]) {
        return 0LL;
      }
      goto LABEL_7;
    case 2:
      LODWORD(v6) = *(unsigned __int16 *)&v5[v4];
      if (!*(_WORD *)&v5[v4]) {
        return 0LL;
      }
      goto LABEL_7;
    case 4:
      LODWORD(v6) = *(_DWORD *)&v5[v4];
      if (!(_DWORD)v6) {
        return 0LL;
      }
      goto LABEL_7;
    case 8:
      uint64_t v6 = *(void *)&v5[v4];
      if (!v6) {
        return 0LL;
      }
LABEL_7:
      unint64_t v7 = (unint64_t)(v6 - 1) << (8 * v4);
      if (v4 > 3) {
        LODWORD(v7) = 0;
      }
      int v8 = 0;
      switch(v4)
      {
        case 0uLL:
          return (*a2 + (v8 | v7) + 1) | 0x100000000LL;
        case 1uLL:
          int v8 = *v5;
          break;
        case 2uLL:
          int v8 = *(unsigned __int16 *)v5;
          break;
        case 3uLL:
          int v8 = *(unsigned __int16 *)v5 | (v5[2] << 16);
          break;
        default:
          int v8 = *(_DWORD *)v5;
          break;
      }

      return (*a2 + (v8 | v7) + 1) | 0x100000000LL;
    default:
      abort();
  }

void *std::__function::__func<swift_enumSimple_getEnumTag::$_1,std::allocator<swift_enumSimple_getEnumTag::$_1>,unsigned int ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = off_189B8AEF0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_1,std::allocator<swift_enumSimple_getEnumTag::$_1>,unsigned int ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_189B8AEF0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_1,std::allocator<swift_enumSimple_getEnumTag::$_1>,unsigned int ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::operator()( uint64_t a1, unint64_t *a2, void *a3, _BYTE *a4, unsigned int *a5)
{
  if (!*a4) {
    return 0LL;
  }
  uint64_t v5 = *a5;
  uint64_t v6 = *(void *)(a1 + 8);
  switch((1 << (*a4 - 1)))
  {
    case 1u:
      uint64_t v7 = *(unsigned __int8 *)(v6 + v5);
      break;
    case 2u:
      uint64_t v7 = *(unsigned __int16 *)(v6 + v5);
      break;
    case 4u:
      uint64_t v7 = *(unsigned int *)(v6 + v5);
      break;
    case 8u:
      uint64_t v7 = *(void *)(v6 + v5);
      break;
    default:
      abort();
  }

  unint64_t v8 = v7 - *a3;
  if (v8 < *a2) {
    return (v8 + 1);
  }
  else {
    return 0LL;
  }
}

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_0,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(unsigned long,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_189B8AF38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_0,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(unsigned long,unsigned long,unsigned char)>::__clone( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_189B8AF38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_0,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(unsigned long,unsigned long,unsigned char)>::operator()( uint64_t a1, unint64_t *a2, uint64_t *a3, unsigned __int8 *a4)
{
  unint64_t v4 = *(unsigned int *)(a1 + 16);
  if (*a2 < v4)
  {
    uint64_t v6 = *a3;
    uint64_t v7 = *a4;
    unsigned int v8 = v4 + ~*a2;
    if ((unint64_t)*a3 <= 3)
    {
      int v9 = (v8 >> (8 * v6)) + 1;
      if (!v6)
      {
LABEL_15:
        if ((_DWORD)v7)
        {
LABEL_16:
          uint64_t v12 = (_BYTE *)(*(void *)(a1 + 8) + v6);
          switch((int)v7)
          {
            case 1:
              *uint64_t v12 = v9;
              break;
            case 2:
              *(_WORD *)uint64_t v12 = v9;
              break;
            case 3:
              *(_WORD *)uint64_t v12 = v9;
              _OWORD v12[2] = BYTE2(v9);
              break;
            case 4:
              *(_DWORD *)uint64_t v12 = v9;
              break;
            default:
              *(_DWORD *)uint64_t v12 = v9;
              bzero(v12 + 4, v7 - 4);
              break;
          }
        }

        goto LABEL_24;
      }

      v8 &= ~(-1 << (8 * v6));
    }

    else
    {
      int v9 = 1;
    }

    int v11 = *(_BYTE **)(a1 + 8);
    switch(v6)
    {
      case 1LL:
        *int v11 = v8;
        if ((_DWORD)v7) {
          goto LABEL_16;
        }
        break;
      case 2LL:
        *(_WORD *)int v11 = v8;
        if ((_DWORD)v7) {
          goto LABEL_16;
        }
        break;
      case 3LL:
        *(_WORD *)int v11 = v8;
        v11[2] = BYTE2(v8);
        goto LABEL_15;
      case 4LL:
        *(_DWORD *)int v11 = v8;
        if ((_DWORD)v7) {
          goto LABEL_16;
        }
        break;
      default:
        *(_DWORD *)int v11 = v8;
        bzero(v11 + 4, v6 - 4);
        if ((_DWORD)v7) {
          goto LABEL_16;
        }
        break;
    }

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_1,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_1>,BOOL ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_189B8AF80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_1,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_1>,BOOL ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_189B8AF80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_1,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_1>,BOOL ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::operator()( uint64_t a1, unint64_t *a2, uint64_t *a3, char *a4, unsigned int *a5, void *a6, _BYTE *a7)
{
  char v7 = *a4;
  if (*a4)
  {
    unint64_t v9 = *(unsigned int *)(a1 + 16);
    if (*a2 >= v9)
    {
      uint64_t v10 = *a3;
      uint64_t v11 = *a5;
      uint64_t v12 = *a7;
      if (*a7)
      {
        uint64_t v13 = (_BYTE *)(*(void *)(a1 + 8) + *a6);
        switch(*a7)
        {
          case 1:
            *uint64_t v13 = 0;
            break;
          case 2:
            *(_WORD *)uint64_t v13 = 0;
            break;
          case 3:
            void v13[2] = 0;
            *(_WORD *)uint64_t v13 = 0;
            break;
          case 4:
            *(_DWORD *)uint64_t v13 = 0;
            break;
          default:
            *(_DWORD *)uint64_t v13 = 0;
            bzero(v13 + 4, v12 - 4);
            break;
        }

        LODWORD(v9) = *(_DWORD *)(a1 + 16);
      }

      if ((_DWORD)v9)
      {
        unsigned int v14 = (_BYTE *)(*(void *)(a1 + 8) + v11);
        int v15 = v10 + v9 - 1;
        switch(1 << (v7 - 1))
        {
          case 0:
            return 1LL;
          case 1:
            _BYTE *v14 = v15;
            break;
          case 2:
            *(_WORD *)unsigned int v14 = v15;
            break;
          case 3:
            *(_WORD *)unsigned int v14 = v15;
            void v14[2] = BYTE2(v15);
            break;
          case 4:
            *(_DWORD *)unsigned int v14 = v15;
            break;
          default:
            *(_DWORD *)unsigned int v14 = v15;
            bzero(v14 + 4, (size_t)a2);
            break;
        }
      }
    }
  }

  return 1LL;
}

void *std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_189B8AFC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_189B8AFC8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::operator()( uint64_t a1, uint64_t *a2, unint64_t *a3, _BYTE *a4)
{
  uint64_t v4 = *a2;
  unint64_t v5 = *a3;
  uint64_t v6 = *(unsigned __int8 **)(a1 + 8);
  switch(*a4)
  {
    case 1:
      LODWORD(v7) = v6[v5];
      if (!v6[v5]) {
        return 0LL;
      }
      goto LABEL_7;
    case 2:
      LODWORD(v7) = *(unsigned __int16 *)&v6[v5];
      if (!*(_WORD *)&v6[v5]) {
        return 0LL;
      }
      goto LABEL_7;
    case 4:
      LODWORD(v7) = *(_DWORD *)&v6[v5];
      if (!(_DWORD)v7) {
        return 0LL;
      }
      goto LABEL_7;
    case 8:
      uint64_t v7 = *(void *)&v6[v5];
      if (!v7) {
        return 0LL;
      }
LABEL_7:
      if (v4) {
        int v8 = *(_DWORD *)(*(void *)(v4 - 8) + 84LL) + 1;
      }
      else {
        int v8 = 1;
      }
      unint64_t v10 = (unint64_t)(v7 - 1) << (8 * v5);
      if (v5 > 3) {
        LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
      }
      int v11 = 0;
      switch(v5)
      {
        case 0uLL:
          return ((v11 | v10) + v8) | 0x100000000LL;
        case 1uLL:
          int v11 = *v6;
          break;
        case 2uLL:
          int v11 = *(unsigned __int16 *)v6;
          break;
        case 3uLL:
          int v11 = *(unsigned __int16 *)v6 | (v6[2] << 16);
          break;
        default:
          int v11 = *(_DWORD *)v6;
          break;
      }

      return ((v11 | v10) + v8) | 0x100000000LL;
    default:
      abort();
  }

void *std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_1>,unsigned int ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_189B8B010;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_1>,unsigned int ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_189B8B010;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_1>,unsigned int ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::operator()( uint64_t a1, void *a2, unsigned int *a3)
{
  if (*a2) {
    return (*(uint64_t (**)(void, void))(*(void *)(*a2 - 8LL) + 48LL))( *(void *)(a1 + 8) + *a3,  *(unsigned int *)(*(void *)(*a2 - 8LL) + 84LL));
  }
  else {
    return 0LL;
  }
}

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_189B8B058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_189B8B058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::operator()( uint64_t a1, uint64_t *a2, uint64_t *a3, unsigned __int8 *a4)
{
  uint64_t v5 = *a2;
  if (*a2) {
    LODWORD(v5) = *(_DWORD *)(*(void *)(v5 - 8) + 84LL);
  }
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  if (v6 > v5)
  {
    uint64_t v7 = *a4;
    uint64_t v8 = *a3;
    unsigned int v9 = v6 + ~(_DWORD)v5;
    if ((unint64_t)*a3 <= 3)
    {
      int v10 = (v9 >> (8 * v8)) + 1;
      if (!v8)
      {
LABEL_17:
        if ((_DWORD)v7)
        {
LABEL_18:
          uint64_t v13 = (_BYTE *)(*(void *)(a1 + 16) + v8);
          switch((int)v7)
          {
            case 1:
              *uint64_t v13 = v10;
              break;
            case 2:
              *(_WORD *)uint64_t v13 = v10;
              break;
            case 3:
              *(_WORD *)uint64_t v13 = v10;
              void v13[2] = BYTE2(v10);
              break;
            case 4:
              *(_DWORD *)uint64_t v13 = v10;
              break;
            default:
              *(_DWORD *)uint64_t v13 = v10;
              bzero(v13 + 4, v7 - 4);
              break;
          }
        }

        goto LABEL_26;
      }

      v9 &= ~(-1 << (8 * v8));
    }

    else
    {
      int v10 = 1;
    }

    uint64_t v12 = *(_BYTE **)(a1 + 16);
    switch(v8)
    {
      case 1LL:
        *uint64_t v12 = v9;
        if ((_DWORD)v7) {
          goto LABEL_18;
        }
        break;
      case 2LL:
        *(_WORD *)uint64_t v12 = v9;
        if ((_DWORD)v7) {
          goto LABEL_18;
        }
        break;
      case 3LL:
        *(_WORD *)uint64_t v12 = v9;
        _OWORD v12[2] = BYTE2(v9);
        goto LABEL_17;
      case 4LL:
        *(_DWORD *)uint64_t v12 = v9;
        if ((_DWORD)v7) {
          goto LABEL_18;
        }
        break;
      default:
        *(_DWORD *)uint64_t v12 = v9;
        bzero(v12 + 4, v8 - 4);
        if ((_DWORD)v7) {
          goto LABEL_18;
        }
        break;
    }

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1>,BOOL ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_189B8B0A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1>,BOOL ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_189B8B0A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1>,BOOL ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::operator()( uint64_t a1, uint64_t *a2, unsigned int *a3, unsigned int *a4, void *a5, _BYTE *a6)
{
  uint64_t v7 = *a2;
  if (*a2) {
    unsigned int v8 = *(_DWORD *)(*(void *)(v7 - 8) + 84LL);
  }
  else {
    unsigned int v8 = 0;
  }
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9 <= v8)
  {
    uint64_t v10 = *a6;
    uint64_t v11 = *a3;
    uint64_t v12 = *a4;
    if (*a6)
    {
      uint64_t v13 = (_BYTE *)(*(void *)(a1 + 16) + *a5);
      switch(*a6)
      {
        case 1:
          *uint64_t v13 = 0;
          break;
        case 2:
          *(_WORD *)uint64_t v13 = 0;
          break;
        case 3:
          void v13[2] = 0;
          *(_WORD *)uint64_t v13 = 0;
          break;
        case 4:
          *(_DWORD *)uint64_t v13 = 0;
          break;
        default:
          *(_DWORD *)uint64_t v13 = 0;
          bzero(v13 + 4, v10 - 4);
          break;
      }

      uint64_t v9 = *(unsigned int *)(a1 + 8);
    }

    if ((_DWORD)v9) {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56LL))( *(void *)(a1 + 16) + v11,  v9,  v12,  v7);
    }
  }

  return 1LL;
}

std::string *swift::nameForMetadata@<X0>( std::string *__return_ptr a1@<X8>, uint64_t cls@<X0>, char a3@<W1>, const char *a4@<X2>, char *a5@<X3>)
{
  a1->__r_.__value_.__r.__words[0] = 0LL;
  a1->__r_.__value_.__l.__size_ = 0LL;
  a1->__r_.__value_.__l.__cap_ = 0LL;
  Class v6 = *(Class *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v6 == 773)
  {
    class_getName(*(Class *)(cls + 8));
    JUMPOUT(0x186E0BC88LL);
  }

  if ((_DWORD)v6) {
    goto LABEL_12;
  }
  if ((*(_BYTE *)(cls + 32) & 2) != 0)
  {
    Class isa = (Class)cls;
    while (!isa[8].isa)
    {
      Class isa = isa[1].isa;
    }

std::string *swift::MetadataOrPack::nameForMetadata@<X0>(std::string **this@<X0>, std::string *a2@<X8>)
{
  __n128 result = *this;
  if (result)
  {
    if ((result & 1) != 0)
    {
      a2->__r_.__value_.__s.__size_ = 5;
      strcpy((char *)a2, "Pack{");
      uint64_t v4 = (Class *)((unint64_t)result & 0xFFFFFFFFFFFFFFFELL);
      uint64_t v5 = *(void *)(((unint64_t)result & 0xFFFFFFFFFFFFFFFELL) - 8);
      if (v5)
      {
        swift::nameForMetadata((uint64_t *)&__p, *v4);
        if ((v14 & 0x80u) == 0) {
          p_p = (const std::string::value_type *)&__p;
        }
        else {
          p_p = (const std::string::value_type *)__p;
        }
        if ((v14 & 0x80u) == 0) {
          std::string::size_type v7 = v14;
        }
        else {
          std::string::size_type v7 = v13;
        }
        std::string::append(a2, p_p, v7);
        uint64_t v8 = v5 - 1;
        if (v8)
        {
          uint64_t v9 = v4 + 1;
          do
          {
            std::string::append(a2, ", ");
            swift::nameForMetadata((uint64_t *)&__p, *v9);
            if ((v14 & 0x80u) == 0) {
              uint64_t v10 = (const std::string::value_type *)&__p;
            }
            else {
              uint64_t v10 = (const std::string::value_type *)__p;
            }
            if ((v14 & 0x80u) == 0) {
              std::string::size_type v11 = v14;
            }
            else {
              std::string::size_type v11 = v13;
            }
            std::string::append(a2, v10, v11);
            ++v9;
            --v8;
          }

          while (v8);
        }
      }

      return std::string::append(a2, "}");
    }

    else
    {
      return (std::string *)swift::nameForMetadata((uint64_t *)a2, (Class)result);
    }
  }

  else
  {
    a2->__r_.__value_.__s.__size_ = 11;
    strcpy((char *)a2, "<<nullptr>>");
  }

  return result;
}

void *swift_getTypeName(unint64_t a1, char a2)
{
  uint64_t v4 = 2LL;
  if ((a2 & 1) == 0) {
    uint64_t v4 = 0LL;
  }
  unint64_t v5 = v4 | a1 & 0xFFFFFFFFFFFFFFF9LL;
  if (qword_18C476960 != -1) {
    dispatch_once_f( &qword_18C476960,  &TypeNameCache,  (dispatch_function_t)swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>>::defaultInitCallback);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_18C476958)
  {
    unsigned int v6 = (dword_18C476958 - 1) & (v5 ^ (a1 >> 9));
    std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24LL * v6);
    uint64_t v8 = *v7;
    if (v5 == *v7) {
      goto LABEL_12;
    }
    int v9 = 1;
    while (v8 != -2)
    {
      unsigned int v10 = v6 + v9++;
      unsigned int v6 = v10 & (dword_18C476958 - 1);
      std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24LL * v6);
      uint64_t v8 = *v7;
      if (v5 == *v7) {
        goto LABEL_12;
      }
    }
  }

  std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24LL * dword_18C476958);
LABEL_12:
  if (v7 != (uint64_t *)(TypeNameCache + 24LL * dword_18C476958))
  {
LABEL_21:
    uint64_t v17 = (void *)v7[1];
    goto LABEL_22;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_18C476958)
  {
    unsigned int v13 = (dword_18C476958 - 1) & (v5 ^ (a1 >> 9));
    std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24LL * v13);
    uint64_t v14 = *v7;
    if (v5 == *v7) {
      goto LABEL_20;
    }
    int v15 = 1;
    while (v14 != -2)
    {
      unsigned int v16 = v13 + v15++;
      unsigned int v13 = v16 & (dword_18C476958 - 1);
      std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24LL * v13);
      uint64_t v14 = *v7;
      if (v5 == *v7) {
        goto LABEL_20;
      }
    }
  }

  std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24LL * dword_18C476958);
LABEL_20:
  swift::nameForMetadata(&__src, a1, a2 & 1, v11, v12);
  unsigned __int8 size = __src.__r_.__value_.__s.__size_;
  if ((char)__src.__r_.__value_.__s.__size_ < 0)
  {
    size_t v20 = __src.__r_.__value_.__l.__size_;
    uint64_t v17 = malloc(__src.__r_.__value_.__l.__size_ + 1);
    p_src = (std::string *)__src.__r_.__value_.__r.__words[0];
  }

  else
  {
    size_t v20 = __src.__r_.__value_.__s.__size_;
    uint64_t v17 = malloc(__src.__r_.__value_.__s.__size_ + 1LL);
    p_src = &__src;
  }

  memcpy(v17, p_src, v20);
  *((_BYTE *)v17 + v2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
  unint64_t v30 = v5;
  *(void *)&__int128 v31 = v17;
  *((void *)&v31 + 1) = v20;
  if (dword_18C476958)
  {
    unsigned int v22 = (dword_18C476958 - 1) & (v5 ^ (a1 >> 9));
    uint64_t v23 = (void *)(TypeNameCache + 24LL * v22);
    uint64_t v24 = *v23;
    if (v5 == *v23) {
      goto LABEL_39;
    }
    uint64_t v25 = 0LL;
    int v26 = 1;
    while (v24 != -2)
    {
      if (v25) {
        BOOL v27 = 0;
      }
      else {
        BOOL v27 = v24 == -16;
      }
      if (v27) {
        uint64_t v25 = v23;
      }
      unsigned int v28 = v22 + v26++;
      unsigned int v22 = v28 & (dword_18C476958 - 1);
      uint64_t v23 = (void *)(TypeNameCache + 24LL * v22);
      uint64_t v24 = *v23;
      if (v5 == *v23) {
        goto LABEL_39;
      }
    }

    if (v25) {
      uint64_t v29 = (uint64_t)v25;
    }
    else {
      uint64_t v29 = (uint64_t)v23;
    }
  }

  else
  {
    uint64_t v29 = 0LL;
  }

  __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::InsertIntoBucket<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>( (uint64_t)&TypeNameCache,  v29,  (uint64_t *)&v30,  &v31);
  unsigned __int8 size = __src.__r_.__value_.__s.__size_;
LABEL_39:
  if ((size & 0x80) != 0) {
    operator delete(__src.__r_.__value_.__l.__data_);
  }
LABEL_22:
  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  return v17;
}

uint64_t swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>>::defaultInitCallback( uint64_t result)
{
  *(void *)__n128 result = 0LL;
  *(void *)(result + 8) = 0LL;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

void *swift_getMangledTypeName(unint64_t a1)
{
  unint64_t v2 = a1 & 0xFFFFFFFFFFFFFFF9LL | 4;
  if (qword_18C476960 != -1) {
    dispatch_once_f( &qword_18C476960,  &TypeNameCache,  (dispatch_function_t)swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>>::defaultInitCallback);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_18C476958)
  {
    unsigned int v3 = (dword_18C476958 - 1) & (v2 ^ (a1 >> 9));
    uint64_t v4 = (uint64_t *)(TypeNameCache + 24LL * v3);
    uint64_t v5 = *v4;
    if (v2 == *v4) {
      goto LABEL_10;
    }
    int v6 = 1;
    while (v5 != -2)
    {
      unsigned int v7 = v3 + v6++;
      unsigned int v3 = v7 & (dword_18C476958 - 1);
      uint64_t v4 = (uint64_t *)(TypeNameCache + 24LL * v3);
      uint64_t v5 = *v4;
      if (v2 == *v4) {
        goto LABEL_10;
      }
    }
  }

  uint64_t v4 = (uint64_t *)(TypeNameCache + 24LL * dword_18C476958);
LABEL_10:
  if (v4 != (uint64_t *)(TypeNameCache + 24LL * dword_18C476958))
  {
LABEL_19:
    uint64_t v14 = (void *)v4[1];
    goto LABEL_20;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_18C476958)
  {
    unsigned int v10 = (dword_18C476958 - 1) & (v2 ^ (a1 >> 9));
    uint64_t v4 = (uint64_t *)(TypeNameCache + 24LL * v10);
    uint64_t v11 = *v4;
    if (v2 == *v4) {
      goto LABEL_18;
    }
    int v12 = 1;
    while (v11 != -2)
    {
      unsigned int v13 = v10 + v12++;
      unsigned int v10 = v13 & (dword_18C476958 - 1);
      uint64_t v4 = (uint64_t *)(TypeNameCache + 24LL * v10);
      uint64_t v11 = *v4;
      if (v2 == *v4) {
        goto LABEL_18;
      }
    }
  }

  uint64_t v4 = (uint64_t *)(TypeNameCache + 24LL * dword_18C476958);
LABEL_18:
  v36[2] = 0LL;
  __int128 v37 = 0LL;
  uint64_t v38 = 2400LL;
  uint64_t v39 = 0LL;
  char v40 = 0;
  v36[0] = off_189B8E500;
  v36[1] = 0LL;
  uint64_t v75 = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v43 = 0LL;
  uint64_t v41 = 0LL;
  char v44 = 0;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  __int128 v68 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  int v73 = 0;
  unsigned int v16 = _swift_buildDemanglingForMetadata(a1, (swift::Demangle::__runtime::NodeFactory *)v36, v8, v9);
  if (!v16)
  {
    uint64_t v14 = 0LL;
    goto LABEL_48;
  }

  swift::Demangle::__runtime::mangleNode((swift::Demangle::__runtime *)v16, v17);
  if (!v34)
  {
    else {
      std::string v33 = __p;
    }
    unsigned __int8 size = v33.__r_.__value_.__s.__size_;
    if ((char)v33.__r_.__value_.__s.__size_ < 0)
    {
      size_t v19 = v33.__r_.__value_.__l.__size_;
      uint64_t v14 = malloc(v33.__r_.__value_.__l.__size_ + 1);
      size_t v20 = (std::string *)v33.__r_.__value_.__r.__words[0];
    }

    else
    {
      size_t v19 = v33.__r_.__value_.__s.__size_;
      uint64_t v14 = malloc(v33.__r_.__value_.__s.__size_ + 1LL);
      size_t v20 = &v33;
    }

    memcpy(v14, v20, v19);
    *((_BYTE *)v14 + v19) = 0;
    unint64_t v31 = v2;
    *(void *)&__int128 v32 = v14;
    *((void *)&v32 + 1) = v19;
    if (dword_18C476958)
    {
      unsigned int v21 = (dword_18C476958 - 1) & (v2 ^ (a1 >> 9));
      unsigned int v22 = (void *)(TypeNameCache + 24LL * v21);
      uint64_t v23 = *v22;
      if (v2 == *v22) {
        goto LABEL_44;
      }
      uint64_t v24 = 0LL;
      int v25 = 1;
      while (v23 != -2)
      {
        if (v24) {
          BOOL v26 = 0;
        }
        else {
          BOOL v26 = v23 == -16;
        }
        if (v26) {
          uint64_t v24 = v22;
        }
        unsigned int v27 = v21 + v25++;
        unsigned int v21 = v27 & (dword_18C476958 - 1);
        unsigned int v22 = (void *)(TypeNameCache + 24LL * v21);
        uint64_t v23 = *v22;
        if (v2 == *v22) {
          goto LABEL_44;
        }
      }

      if (v24) {
        uint64_t v28 = (uint64_t)v24;
      }
      else {
        uint64_t v28 = (uint64_t)v22;
      }
    }

    else
    {
      uint64_t v28 = 0LL;
    }

    __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::InsertIntoBucket<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>( (uint64_t)&TypeNameCache,  v28,  (uint64_t *)&v31,  &v32);
    unsigned __int8 size = v33.__r_.__value_.__s.__size_;
LABEL_44:
    if ((size & 0x80) != 0) {
      operator delete(v33.__r_.__value_.__l.__data_);
    }
    goto LABEL_46;
  }

  uint64_t v14 = 0LL;
LABEL_46:
LABEL_48:
  v36[0] = off_189B8E500;
  uint64_t v29 = v75;
  if (v75 == v74)
  {
    uint64_t v30 = 4LL;
    uint64_t v29 = v74;
  }

  else
  {
    if (!v75) {
      goto LABEL_53;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_53:
  v36[0] = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(v37);
  if (v39) {
    *(_BYTE *)(v39 + 48) = 0;
  }
LABEL_20:
  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  return v14;
}

void *swift_getFunctionFullNameFromMangledName(void *a1, size_t a2)
{
  if (qword_18C5757B0 != -1) {
    dispatch_once_f( &qword_18C5757B0,  &MangledToPrettyFunctionNameCache,  (dispatch_function_t)swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>>::defaultInitCallback);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
  int v4 = dword_18C5757A8;
  if (!dword_18C5757A8) {
    goto LABEL_18;
  }
  uint64_t v5 = MangledToPrettyFunctionNameCache;
  int v6 = dword_18C5757A8 - 1;
  unsigned int v7 = (v4 - 1) & __swift::__runtime::llvm::hash_value(a1, a2);
  for (int i = 1; ; ++i)
  {
    uint64_t v9 = v5 + 32LL * v7;
    unsigned int v10 = *(const void **)v9;
    if (*(void *)v9 != -2LL) {
      break;
    }
    if (a1 == (void *)-2LL) {
      goto LABEL_16;
    }
LABEL_14:
    unsigned int v11 = v7 + i;
    unsigned int v7 = v11 & v6;
  }

  if (v10 == (const void *)-1LL)
  {
    if (a1 == (void *)-1LL) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }

uint64_t swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>>::defaultInitCallback( uint64_t result)
{
  *(void *)__n128 result = 0LL;
  *(void *)(result + 8) = 0LL;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t swift::Demangle::__runtime::StackAllocatedDemangler<1024ul>::~StackAllocatedDemangler(uint64_t a1)
{
  *(void *)a1 = off_189B8E500;
  unint64_t v2 = (void *)(a1 + 544);
  unsigned int v3 = *(void **)(a1 + 568);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    unsigned int v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *(void *)a1 = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(*(void **)(a1 + 24));
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5) {
    *(_BYTE *)(v5 + 48) = 0;
  }
  return a1;
}

void swift::swift_dynamicCastFailure( swift *this, const void *a2, const char *a3, char *a4, const char *a5, const char *a6)
{
  int v6 = ": ";
  if (!a5) {
    int v6 = ".";
  }
  unsigned int v7 = "";
  if (a5) {
    unsigned int v7 = a5;
  }
  swift::fatalError(0LL, "Could not cast value of type '%s' (%p) to '%s' (%p)%s%s\n", a3, a4, a2, this, a4, a3, v6, v7);
}

void swift::swift_dynamicCastFailure(swift *a1, const char *a2, const char *a3, char *a4)
{
  if ((v13.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unsigned int v10 = &v13;
  }
  else {
    unsigned int v10 = (std::string *)v13.__r_.__value_.__r.__words[0];
  }
  if ((v12.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unsigned int v11 = &v12;
  }
  else {
    unsigned int v11 = (std::string *)v12.__r_.__value_.__r.__words[0];
  }
  swift::swift_dynamicCastFailure(a1, v10, a2, (char *)v11, a3, v9);
}

uint64_t swift::_conformsToProtocol(swift::runtime::bincompat **a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  if ((a3 & 1) == 0)
  {
    uint64_t v5 = swift_conformsToProtocolCommon(a2, (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL);
    uint64_t result = v5 != 0;
    if (a4)
    {
      if (v5)
      {
        *a4 = v5;
        return 1LL;
      }
    }

    return result;
  }

  uint64_t result = 0LL;
  uint64_t v8 = *(void *)a2;
  if (*(void *)a2 > 0x7FFuLL) {
    LODWORD(v8) = 0;
  }
  if ((int)v8 <= 770)
  {
    if ((v8 - 515) < 2)
    {
      if (!a1) {
        return 0LL;
      }
LABEL_17:
      unint64_t v17 = (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL;
      return swift_dynamicCastObjCProtocolConditional(*a1, 1LL, &v17) != 0LL;
    }

    if ((_DWORD)v8) {
      return result;
    }
    if (a1) {
      goto LABEL_17;
    }
    uint64_t v9 = (void *)a2;
    return swift::objectConformsToObjCProtocol(v9, a3);
  }

  if ((_DWORD)v8 != 771)
  {
    if ((_DWORD)v8 != 773) {
      return result;
    }
    if (a1) {
      goto LABEL_17;
    }
    uint64_t v9 = *(void **)(a2 + 8);
    return swift::objectConformsToObjCProtocol(v9, a3);
  }

  unint64_t v10 = *(unsigned int *)(a2 + 8);
  if ((v10 & 0x80FFFFFF) != 0) {
    return 0LL;
  }
  uint64_t v11 = *(unsigned int *)(a2 + 12);
  if (!(_DWORD)v11) {
    return 0LL;
  }
  std::string v12 = (uint64_t *)(a2 + ((v10 >> 27) & 0x18) + 16);
  std::string v13 = (Protocol *)((unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL);
  uint64_t v14 = 8 * v11 - 8;
  do
  {
    uint64_t v15 = *v12++;
    uint64_t result = protocol_conformsToProtocol((Protocol *)(v15 & 0xFFFFFFFFFFFFFFFELL), v13);
    if ((result & 1) != 0) {
      break;
    }
    uint64_t v16 = v14;
    v14 -= 8LL;
  }

  while (v16);
  return result;
}

unint64_t swift_getDynamicType(swift::SwiftError **a1, uint64_t *a2, int a3)
{
  uint64_t v3 = (uint64_t)a2;
  uint64_t v4 = (unint64_t *)a1;
  uint64_t v5 = *a2;
  switch((int)v5)
  {
    case 771:
      swift::TargetExistentialTypeMetadata<swift::InProcess>::mayTakeValue((uint64_t)a2, a1);
      if (!a3) {
        return v3;
      }
      int Representation = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(v3);
      if (Representation != 2)
      {
        if (Representation == 1) {
          return swift_getObjectType(*v4);
        }
        if (Representation) {
          return swift_getMetatypeMetadata(*v4);
        }
      }

      while (1)
      {
        DynamicType = (uint64_t *)swift::TargetExistentialTypeMetadata<swift::InProcess>::getDynamicType(v3, (uint64_t)v4);
        uint64_t v4 = (unint64_t *)swift::TargetExistentialTypeMetadata<swift::InProcess>::projectValue( v3,  (swift::SwiftError **)v4);
        uint64_t v3 = (uint64_t)DynamicType;
        uint64_t v5 = *DynamicType;
        if ((_DWORD)v5 != 771) {
          break;
        }
        swift::TargetExistentialTypeMetadata<swift::InProcess>::mayTakeValue( (uint64_t)DynamicType,  (swift::SwiftError **)v4);
        int v10 = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation((uint64_t)DynamicType);
        if (v10 && v10 != 2)
        {
          if (v10 == 1) {
            return swift_getObjectType(*v4);
          }
          return swift_getMetatypeMetadata(*v4);
        }
      }

      if ((_DWORD)v5 == 772 || (_DWORD)v5 == 774) {
        return swift_getMetatypeMetadata(*v4);
      }
      if ((_DWORD)v5 == 773) {
        return swift_getObjectType(*v4);
      }
      return v3;
    case 772:
    case 774:
      return swift_getMetatypeMetadata(*v4);
    case 773:
      return swift_getObjectType(*v4);
    default:
LABEL_21:
      if ((_DWORD)v5 && (_DWORD)v5 != 515) {
        return v3;
      }
      else {
        return swift_getObjectType(*v4);
      }
  }

uint64_t *swift_dynamicCastMetatypeToObjectConditional(uint64_t *result)
{
  uint64_t v1 = *result;
  if ((_DWORD)v1)
  {
    if ((_DWORD)v1 == 773) {
      return (uint64_t *)result[1];
    }
    else {
      return 0LL;
    }
  }

  return result;
}

swift *swift_dynamicCastMetatypeToObjectUnconditional(swift *result, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4 = *(void *)result;
  if (*(void *)result > 0x7FFuLL) {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v4)
  {
    if ((_DWORD)v4 != 773)
    {
      uint64_t v5 = result;
      swift::nameForMetadata(&v8, (uint64_t)result, 1, a3, a4);
      if ((v8.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unsigned int v7 = &v8;
      }
      else {
        unsigned int v7 = (std::string *)v8.__r_.__value_.__r.__words[0];
      }
      swift::swift_dynamicCastFailure( v5,  v7,  0LL,  "AnyObject",  "only class metatypes can be converted to AnyObject",  v6);
    }

    return (swift *)*((void *)result + 1);
  }

  return result;
}

char *_bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(id *a1, uint64_t *a2, uint64_t a3, char *a4)
{
  return bridgeAnythingNonVerbatimToObjectiveC(a1, a2, 1LL, a4);
}

char *bridgeAnythingNonVerbatimToObjectiveC(id *a1, uint64_t *a2, uint64_t a3, char *a4)
{
  unsigned int v4 = a3;
  uint64_t v6 = *a2;
  else {
    int v7 = 0;
  }
  if (!v7 || v7 == 773 || v7 == 515)
  {
    std::string v8 = *a1;
    if ((a3 & 1) == 0) {
      swift_unknownObjectRetain(*a1, (uint64_t)a2, a3, a4);
    }
    return (char *)v8;
  }

  if (v6 == 774 || v6 == 772)
  {
    std::string v8 = *a1;
    unint64_t v19 = *(void *)*a1;
    if (v19 > 0x7FF || (v19 != 773 ? (BOOL v20 = *(void *)*a1 == 0LL) : (BOOL v20 = 1), v20))
    {
      if (v19 > 0x7FF) {
        LODWORD(v19) = 0;
      }
      if ((_DWORD)v19)
      {
        if ((_DWORD)v19 == 773) {
          return (char *)v8[1];
        }
        else {
          return 0LL;
        }
      }

      return (char *)v8;
    }

    if (v19 == 771)
    {
      unint64_t v21 = *((unsigned int *)v8 + 2);
      if ((v21 & 0x80FFFFFF) == 0 && *((_DWORD *)v8 + 3) == 1) {
        return (char *)(id)(*(void *)((char *)v8 + ((v21 >> 27) & 0x18) + 16) & 0xFFFFFFFFFFFFFFFELL);
      }
    }

    return swift::bridgeAnythingToSwiftValueObject((uint64_t)a1, (uint64_t)a2, v4);
  }

  if (v6 == 771)
  {
    int Representation = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation((uint64_t)a2);
    if (Representation)
    {
      if (Representation == 2)
      {
        std::string v13 = (swift::SwiftError *)*a1;
        unint64_t Type = swift::SwiftError::getType((swift::SwiftError *)*a1, v12);
        BOOL v16 = 0;
        if (swift::SwiftError::isPureNSError(v13, v15))
        {
          BOOL v17 = 1;
          uint64_t v18 = (uint64_t)a1;
        }

        else
        {
          uint64_t v25 = *(unsigned __int8 *)(*(void *)(*((void *)v13 + 5) - 8LL) + 80LL);
          uint64_t v18 = ((unint64_t)v13 + v25 + 72) & ~v25;
          BOOL v17 = 1;
        }
      }

      else
      {
        unint64_t Type = swift_getObjectType((unint64_t)*a1);
        BOOL v17 = 0;
        BOOL v16 = 1;
        uint64_t v18 = (uint64_t)a1;
      }
    }

    else
    {
      unint64_t Type = (unint64_t)a1[3];
      uint64_t v18 = (uint64_t)swift::TargetExistentialTypeMetadata<swift::InProcess>::projectValue( (uint64_t)a2,  (swift::SwiftError **)a1);
      BOOL v16 = v18 == (void)a1;
      BOOL v17 = v18 != (void)a1;
    }

    if (v16) {
      uint64_t v26 = v4;
    }
    else {
      uint64_t v26 = 0LL;
    }
    std::string v8 = (void *)bridgeAnythingNonVerbatimToObjectiveC(v18, Type, v26);
    if (!v4) {
      return (char *)v8;
    }
    if (v16)
    {
      if (v17) {
        swift::fatalError(0LL, "Attempting to move out of a copy-on-write existential", v27, v28);
      }
      return (char *)v8;
    }

    goto LABEL_51;
  }

  BridgeWitness = findBridgeWitness((uint64_t)a2);
  if (BridgeWitness)
  {
    std::string v8 = (void *)((uint64_t (*)(uint64_t *, _UNKNOWN **))BridgeWitness[2])(a2, BridgeWitness);
    if (!v4) {
      return (char *)v8;
    }
LABEL_51:
    (*(void (**)(id *, uint64_t *))(*(a2 - 1) + 8))(a1, a2);
    return (char *)v8;
  }

  uint64_t ErrorWitness = swift::findErrorWitness((uint64_t)a2);
  if (!ErrorWitness) {
    return swift::bridgeAnythingToSwiftValueObject((uint64_t)a1, (uint64_t)a2, v4);
  }
  if (v4) {
    char v24 = 2;
  }
  else {
    char v24 = 0;
  }
  return (char *)swift::dynamicCastValueToNSError((uint64_t)a1, (uint64_t)a2, ErrorWitness, v24);
}

const char *_getBridgedNonVerbatimObjectiveCType<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t result = (const char *)findBridgeWitness(a2);
  if (result)
  {
    uint64_t v4 = **(int **)result;
    unint64_t v5 = (v4 & 0xFFFFFFFFFFFFFFFELL) + *(void *)result;
    if ((v4 & 1) != 0) {
      unint64_t v5 = *(void *)v5;
    }
    unint64_t v6 = v5 + 12LL * *(unsigned int *)(v5 + 12);
    return (const char *)swift_getAssociatedTypeWitness(0LL, result, a2, v6 + 16, (_DWORD *)(v6 + 24));
  }

  return result;
}

_UNKNOWN **findBridgeWitness(uint64_t a1)
{
  if (*(void *)a1 == 512LL && *(StructDescriptor **)(a1 + 8) == &nominal type descriptor for String)
  {
    uint64_t v4 = &unk_18C476000;
    if ((v3 & 1) == 0)
    {
      uint64_t v4 = (void *)&unk_18C476000;
      if (v7)
      {
        findBridgeWitness(swift::TargetMetadata<swift::InProcess> const*)::Swift_String_ObjectiveCBridgeable = swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
        uint64_t v4 = (void *)&unk_18C476000;
      }
    }

    return (_UNKNOWN **)v4[310];
  }

  else
  {
    uint64_t result = (_UNKNOWN **)swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
    if (result) {
      return result;
    }
    uint64_t v5 = *(void *)a1;
    if (*(void *)a1 > 0x7FFuLL) {
      LODWORD(v5) = 0;
    }
    if ((_DWORD)v5 == 774)
    {
      if ((*(_DWORD *)(a1 + 16) & 0x80FFFFFF) == 0) {
        return &protocol witness table for _BridgeableMetatype;
      }
      return 0LL;
    }

    if ((_DWORD)v5 != 772) {
      return 0LL;
    }
    unint64_t v6 = **(void **)(a1 + 8);
    if (v6 > 0x7FF) {
      LODWORD(v6) = 0;
    }
    uint64_t result = &protocol witness table for _BridgeableMetatype;
    if ((_DWORD)v6)
    {
      if ((_DWORD)v6 != 515 && (_DWORD)v6 != 773) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(swift *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result = tryBridgeNonVerbatimFromObjectiveCUniversal(a1, a2, a3);
  if ((result & 1) == 0)
  {
    BridgeWitness = (const char *)findBridgeWitness(a2);
    if (!BridgeWitness) {
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)();
    }
    std::string v8 = BridgeWitness;
    uint64_t v9 = **(int **)BridgeWitness;
    unint64_t v10 = (v9 & 0xFFFFFFFFFFFFFFFELL) + *(void *)BridgeWitness;
    if ((v9 & 1) != 0) {
      unint64_t v10 = *(void *)v10;
    }
    unint64_t v11 = v10 + 12LL * *(unsigned int *)(v10 + 12);
    unint64_t AssociatedTypeWitness = (const char *)swift_getAssociatedTypeWitness( 0LL,  BridgeWitness,  a2,  v11 + 16,  (_DWORD *)(v11 + 24));
    swift_once( &swift_dynamicCastUnknownClass::Predicate,  (dispatch_function_t)swift_dynamicCastUnknownClass::$_0::__invoke,  0LL);
    if (swift_dynamicCastUnknownClass::Override)
    {
      std::string v13 = (unint64_t *)swift_dynamicCastUnknownClass::Override( a1,  AssociatedTypeWitness,  swift_dynamicCastUnknownClassImpl);
      if (v13) {
        return (*((uint64_t (**)(unint64_t *, uint64_t *, uint64_t, const char *))v8 + 3))( v13,  a3,  a2,  v8);
      }
    }

    else
    {
      std::string v13 = swift_dynamicCastUnknownClassImpl((uint64_t)a1, (uint64_t)AssociatedTypeWitness);
      if (v13) {
        return (*((uint64_t (**)(unint64_t *, uint64_t *, uint64_t, const char *))v8 + 3))( v13,  a3,  a2,  v8);
      }
    }

    Class = (swift *)swift::_swift_getClass((unint64_t)a1, v14);
    swift::swift_dynamicCastFailure(Class, AssociatedTypeWitness, 0LL, v16);
  }

  return result;
}

uint64_t tryBridgeNonVerbatimFromObjectiveCUniversal(swift *this, uint64_t a2, uint64_t *a3)
{
  if (*(void *)a2 == 771LL && !*(_DWORD *)(a2 + 12) && (*(_DWORD *)(a2 + 8) & 0x80000000) != 0)
  {
    _bridgeNonVerbatimFromObjectiveCToAny(this, a3);
  }

  else
  {
    AsSwiftValue = swift::getAsSwiftValue(this, (objc_object *)a2);
    if (!AsSwiftValue || swift::getValueFromSwiftValue(AsSwiftValue, v7) != a2) {
      return swift::tryDynamicCastNSErrorObjectToValue((uint64_t)this, a3, (void *)a2, 0LL);
    }
    _bridgeNonVerbatimBoxedValue(v8, (uint64_t)a3, a2, v9);
  }

  return 1LL;
}

unint64_t *swift_dynamicCastUnknownClass(uint64_t a1, uint64_t a2)
{
  if (swift_dynamicCastUnknownClass::Override) {
    return (unint64_t *)swift_dynamicCastUnknownClass::Override(a1, a2, swift_dynamicCastUnknownClassImpl);
  }
  else {
    return swift_dynamicCastUnknownClassImpl(a1, a2);
  }
}

uint64_t _bridgeNonVerbatimFromObjectiveCConditional<A>(_:_:_:)(swift *a1, uint64_t a2, uint64_t *a3)
{
  if ((tryBridgeNonVerbatimFromObjectiveCUniversal(a1, a2, a3) & 1) != 0) {
    return 1LL;
  }
  uint64_t result = (uint64_t)findBridgeWitness(a2);
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = **(int **)result;
    unint64_t v9 = (v8 & 0xFFFFFFFFFFFFFFFELL) + *(void *)result;
    if ((v8 & 1) != 0) {
      unint64_t v9 = *(void *)v9;
    }
    unint64_t v10 = v9 + 12LL * *(unsigned int *)(v9 + 12);
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)result,  a2,  v10 + 16,  (_DWORD *)(v10 + 24));
    swift_once( &swift_dynamicCastUnknownClass::Predicate,  (dispatch_function_t)swift_dynamicCastUnknownClass::$_0::__invoke,  0LL);
    if (swift_dynamicCastUnknownClass::Override)
    {
      uint64_t result = swift_dynamicCastUnknownClass::Override(a1, AssociatedTypeWitness, swift_dynamicCastUnknownClassImpl);
      if (!result) {
        return result;
      }
    }

    else
    {
      uint64_t result = (uint64_t)swift_dynamicCastUnknownClassImpl((uint64_t)a1, AssociatedTypeWitness);
      if (!result) {
        return result;
      }
    }

    return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v7 + 32))(result, a3, a2, v7) & 1;
  }

  return result;
}

BOOL _isBridgedNonVerbatimToObjectiveC<A>(_:)(uint64_t a1, uint64_t a2)
{
  return findBridgeWitness(a2) != 0LL;
}

BOOL _swift_isClassOrObjCExistentialType(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *a2;
  BOOL result = 1LL;
  if ((int)v2 <= 769)
  {
    if ((_DWORD)v2 && (_DWORD)v2 != 515) {
      return 0LL;
    }
  }

  else
  {
    if ((_DWORD)v2 == 770) {
      return (unint64_t)*((unsigned __int8 *)a2 + 10) << 16 == 0x10000;
    }
    if ((_DWORD)v2 != 773)
    {
      if ((_DWORD)v2 == 771) {
        return (a2[1] & 0x80FFFFFF) == 0;
      }
      return 0LL;
    }
  }

  return result;
}

uint64_t _swift_setClassMetadata(uint64_t result, void *a2)
{
  *a2 = result;
  return result;
}

unint64_t _swift_class_getSuperclass(swift *a1)
{
  uint64_t v2 = *(void *)a1;
  if (*(void *)a1 <= 0x7FFuLL) {
    int v3 = *(void *)a1;
  }
  else {
    int v3 = 0;
  }
  uint64_t v4 = a1;
  if (!v3 || v3 == 773 && (uint64_t v4 = (swift *)*((void *)a1 + 1)) != 0LL)
  {
    uint64_t v5 = *((void *)v4 + 1);
    if (v5)
    {
      if (v5 != swift::getRootSuperclass(a1)) {
        return swift_getObjCClassMetadata(*((void *)v4 + 1));
      }
      uint64_t v2 = *(void *)a1;
    }
  }

  if (v2 != 515) {
    return 0LL;
  }
  unint64_t result = *((void *)a1 + 2);
  if (!result) {
    return 0LL;
  }
  return result;
}

BOOL swift_isClassType(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL result = 1LL;
  if ((_DWORD)v1) {
    return (_DWORD)v1 == 515 || (_DWORD)v1 == 773;
  }
  return result;
}

BOOL swift_isOptionalType(void *a1)
{
  return *a1 == 514LL;
}

uint64_t swift_dynamicCastClass(uint64_t a1, uint64_t a2)
{
  if (swift_dynamicCastClass::Override) {
    return swift_dynamicCastClass::Override(a1, a2, swift_dynamicCastClassImpl);
  }
  if (a1 < 1) {
    return 0LL;
  }
  uint64_t v5 = *(void *)a1 & 0xFFFFFFFF8LL;
  while (v5 != a2)
  {
    uint64_t v5 = *(void *)(v5 + 8);
    if (!v5)
    {
      a2 = 0LL;
      break;
    }
  }

  if (a2) {
    return a1;
  }
  else {
    return 0LL;
  }
}

uint64_t swift_dynamicCastClassImpl(uint64_t result, uint64_t a2)
{
  if (result < 1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)result & 0xFFFFFFFF8LL;
  while (v2 != a2)
  {
    uint64_t v2 = *(void *)(v2 + 8);
    if (!v2)
    {
      a2 = 0LL;
      break;
    }
  }

  if (!a2) {
    return 0LL;
  }
  return result;
}

uint64_t swift_dynamicCastClassUnconditional( int64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (swift_dynamicCastClassUnconditional::Override) {
    return swift_dynamicCastClassUnconditional::Override(a1, a2, a3, a4, a5, swift_dynamicCastClassUnconditionalImpl);
  }
  swift_once(&swift_dynamicCastClass::Predicate, (dispatch_function_t)swift_dynamicCastClass::$_0::__invoke, 0LL);
  if (swift_dynamicCastClass::Override)
  {
    uint64_t result = swift_dynamicCastClass::Override(a1, a2, swift_dynamicCastClassImpl);
  }

  else
  {
    if (a1 < 1) {
      goto LABEL_9;
    }
    uint64_t v12 = *(void *)a1 & 0xFFFFFFFF8LL;
    while ((const char *)v12 != a2)
    {
      uint64_t v12 = *(void *)(v12 + 8);
      if (!v12) {
        goto LABEL_9;
      }
    }

    uint64_t result = a1;
    if (!a2)
    {
LABEL_9:
      Class = (swift *)swift::_swift_getClass(a1, v11);
      swift::swift_dynamicCastFailure(Class, a2, 0LL, v14);
    }
  }

  if (!result) {
    goto LABEL_9;
  }
  return result;
}

uint64_t swift_dynamicCastClassUnconditionalImpl(int64_t a1, const char *a2)
{
  if (swift_dynamicCastClass::Override)
  {
    uint64_t result = swift_dynamicCastClass::Override(a1, a2, swift_dynamicCastClassImpl);
  }

  else
  {
    if (a1 < 1) {
      goto LABEL_7;
    }
    uint64_t v6 = *(void *)a1 & 0xFFFFFFFF8LL;
    while ((const char *)v6 != a2)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6) {
        goto LABEL_7;
      }
    }

    uint64_t result = a1;
    if (!a2)
    {
LABEL_7:
      Class = (swift *)swift::_swift_getClass(a1, v4);
      swift::swift_dynamicCastFailure(Class, a2, 0LL, v8);
    }
  }

  if (!result) {
    goto LABEL_7;
  }
  return result;
}

unint64_t *swift_dynamicCastUnknownClassImpl(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  uint64_t v5 = *(void *)a2;
  if (*(void *)a2 > 0x7FFuLL) {
    LODWORD(v5) = 0;
  }
  if ((int)v5 <= 770)
  {
    if ((_DWORD)v5)
    {
      if ((_DWORD)v5 == 515) {
        return (unint64_t *)swift_dynamicCastForeignClass(a1, a2);
      }
      return result;
    }

    swift_once(&swift_dynamicCastClass::Predicate, (dispatch_function_t)swift_dynamicCastClass::$_0::__invoke, 0LL);
    if (swift_dynamicCastClass::Override) {
      return (unint64_t *)swift_dynamicCastClass::Override(a1, a2, swift_dynamicCastClassImpl);
    }
    if (a1 >= 1)
    {
      uint64_t v9 = *(void *)a1 & 0xFFFFFFFF8LL;
      while (v9 != a2)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        if (!v9) {
          return 0LL;
        }
      }

      return (unint64_t *)a1;
    }

    return 0LL;
  }

  if ((_DWORD)v5 == 771)
  {
    uint64_t v6 = *(unsigned int *)(a2 + 12);
    if (!(_DWORD)v6) {
      return (unint64_t *)a1;
    }
    uint64_t v7 = (const char **)(a2 + 8 * (((unint64_t)*(unsigned int *)(a2 + 8) >> 30) & 1) + 16);
    uint64_t v8 = 8 * v6;
    while ((*v7 & 1) != 0 && (swift::objectConformsToObjCProtocol((void *)a1, *v7) & 1) != 0)
    {
      ++v7;
      v8 -= 8LL;
      if (!v8) {
        return (unint64_t *)a1;
      }
    }

    return 0LL;
  }

  if ((_DWORD)v5 == 773) {
    return swift_dynamicCastObjCClass((void *)a1, *(void *)(a2 + 8));
  }
  return result;
}

unint64_t *swift_dynamicCastUnknownClassUnconditional( swift *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (swift_dynamicCastUnknownClassUnconditional::Override) {
    return (unint64_t *)swift_dynamicCastUnknownClassUnconditional::Override( a1,  a2,  a3,  a4,  a5,  swift_dynamicCastUnknownClassUnconditionalImpl);
  }
  else {
    return swift_dynamicCastUnknownClassUnconditionalImpl(a1, a2, a3, a4, a5);
  }
}

unint64_t *swift_dynamicCastUnknownClassUnconditionalImpl( swift *this, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (const char *)a2;
  uint64_t v6 = this;
  uint64_t v7 = *(void *)a2;
  if (*(void *)a2 > 0x7FFuLL) {
    LODWORD(v7) = 0;
  }
  if ((int)v7 <= 515)
  {
    if ((_DWORD)v7)
    {
      if ((_DWORD)v7 != 515) {
        goto LABEL_20;
      }
      return (unint64_t *)swift_dynamicCastForeignClassUnconditional((uint64_t)this, (uint64_t)a2, a3, a4, a5);
    }

    else
    {
      return (unint64_t *)swift_dynamicCastClassUnconditional((int64_t)this, (const char *)a2, a3, a4, a5);
    }
  }

  else
  {
    if ((_DWORD)v7 == 516) {
      return 0LL;
    }
    if ((_DWORD)v7 != 771)
    {
      if ((_DWORD)v7 == 773) {
        return swift_dynamicCastObjCClassUnconditional(this, *((const char **)a2 + 1), a3, a4, a5);
      }
LABEL_20:
      Class = (swift *)swift::_swift_getClass((unint64_t)v6, a2);
      swift::swift_dynamicCastFailure(Class, v5, 0LL, v13);
    }

    uint64_t v9 = a2[3];
    if ((_DWORD)v9)
    {
      unint64_t v10 = &a2[2 * (((unint64_t)a2[2] >> 30) & 1) + 4];
      uint64_t v11 = 8 * v9;
      do
      {
        a2 = *(unsigned int **)v10;
        v10 += 2;
        v11 -= 8LL;
      }

      while (v11);
    }

    if (!v6) {
      goto LABEL_20;
    }
    return (unint64_t *)v6;
  }

uint64_t *swift_dynamicCastMetatype(uint64_t *a1, uint64_t *a2)
{
  if (swift_dynamicCastMetatype::Override) {
    return (uint64_t *)swift_dynamicCastMetatype::Override(a1, a2, swift_dynamicCastMetatypeImpl);
  }
  else {
    return swift_dynamicCastMetatypeImpl(a1, a2);
  }
}

uint64_t *swift_dynamicCastMetatypeImpl(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = a1;
  if (a1 == a2) {
    return v2;
  }
  uint64_t v3 = *a2;
  if ((_DWORD)v3)
  {
    if ((_DWORD)v3 == 515)
    {
      uint64_t v6 = *a1;
      if ((_DWORD)v6 && (_DWORD)v6 != 515)
      {
        if ((_DWORD)v6 != 773) {
          return 0LL;
        }
        a1 = (uint64_t *)a1[1];
      }

      goto LABEL_22;
    }

    if ((_DWORD)v3 != 773) {
      return 0LL;
    }
    a2 = (uint64_t *)a2[1];
  }

  uint64_t v4 = *a1;
  if (!(_DWORD)v4) {
    goto LABEL_14;
  }
  if ((_DWORD)v4 != 515)
  {
    if ((_DWORD)v4 == 773)
    {
      a1 = (uint64_t *)a1[1];
LABEL_14:
      uint64_t v5 = swift_dynamicCastObjCClassMetatype(a1, (uint64_t)a2);
      goto LABEL_23;
    }

    return 0LL;
  }

uint64_t *swift_dynamicCastMetatypeUnconditional(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  if (swift_dynamicCastMetatypeUnconditional::Override) {
    return (uint64_t *)swift_dynamicCastMetatypeUnconditional::Override( a1,  a2,  a3,  a4,  a5,  swift_dynamicCastMetatypeUnconditionalImpl);
  }
  else {
    return swift_dynamicCastMetatypeUnconditionalImpl(a1, a2, a3, a4, a5);
  }
}

uint64_t *swift_dynamicCastMetatypeUnconditionalImpl( uint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v5 = a1;
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v6 = a2;
    uint64_t v7 = *(void *)a2;
    if (*(void *)a2 > 0x7FFuLL) {
      LODWORD(v7) = 0;
    }
    if ((int)v7 <= 515)
    {
      if ((_DWORD)v7)
      {
        if ((_DWORD)v7 != 515) {
          goto LABEL_42;
        }
        uint64_t v8 = *a1;
        if ((_DWORD)v8 && (_DWORD)v8 != 515)
        {
          if ((_DWORD)v8 != 773) {
            goto LABEL_42;
          }
          a1 = (uint64_t *)a1[1];
        }

        goto LABEL_27;
      }
    }

    else
    {
      if ((_DWORD)v7 == 771)
      {
        unsigned int v10 = *(_DWORD *)(a2 + 8);
        if ((v10 & 0x40000000) != 0)
        {
          uint64_t v11 = *(uint64_t **)(a2 + 16);
          if (v11)
          {
            swift_once( &swift_dynamicCastMetatype::Predicate,  (dispatch_function_t)swift_dynamicCastMetatype::$_0::__invoke,  0LL);
            if (swift_dynamicCastMetatype::Override) {
              uint64_t v12 = (uint64_t *)swift_dynamicCastMetatype::Override(v5, v11, swift_dynamicCastMetatypeImpl);
            }
            else {
              uint64_t v12 = swift_dynamicCastMetatypeImpl(v5, v11);
            }
            if (!v12) {
              goto LABEL_42;
            }
            unsigned int v10 = *(_DWORD *)(v6 + 8);
          }
        }

        if ((v10 & 0x80000000) != 0) {
          goto LABEL_37;
        }
        uint64_t v13 = *v5;
        if (!(_DWORD)v13 || (_DWORD)v13 == 773 || (_DWORD)v13 == 515)
        {
LABEL_37:
          uint64_t v14 = *(unsigned int *)(v6 + 12);
          if (!(_DWORD)v14) {
            return v5;
          }
          uint64_t v15 = (const char **)(v6 + 8LL * ((v10 >> 30) & 1) + 16);
          uint64_t v16 = 8 * v14;
          while ((swift::_conformsToProtocol(0LL, (uint64_t)v5, *v15, 0LL) & 1) != 0)
          {
            ++v15;
            v16 -= 8LL;
            if (!v16) {
              return v5;
            }
          }
        }

void *std::__function::__func<std::string (*)(unsigned long long,unsigned long long),std::allocator<std::string (*)(unsigned long long,unsigned long long)>,std::string ()(unsigned long long,unsigned long long)>::__clone( uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_189B8B0E8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::string (*)(unsigned long long,unsigned long long),std::allocator<std::string (*)(unsigned long long,unsigned long long)>,std::string ()(unsigned long long,unsigned long long)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_189B8B0E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::string (*)(unsigned long long,unsigned long long),std::allocator<std::string (*)(unsigned long long,unsigned long long)>,std::string ()(unsigned long long,unsigned long long)>::operator()( uint64_t a1, void *a2, void *a3)
{
  return (*(uint64_t (**)(void, void))(a1 + 8))(*a2, *a3);
}

void *swift_dynamicCastClass::$_0::__invoke(swift_dynamicCastClass::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastClass(this);
  swift_dynamicCastClass::Override = result;
  return result;
}

void *swift_dynamicCastClassUnconditional::$_0::__invoke( swift_dynamicCastClassUnconditional::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastClassUnconditional(this);
  swift_dynamicCastClassUnconditional::Override = result;
  return result;
}

void *swift_dynamicCastUnknownClass::$_0::__invoke(swift_dynamicCastUnknownClass::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastUnknownClass(this);
  swift_dynamicCastUnknownClass::Override = result;
  return result;
}

void *swift_dynamicCastUnknownClassUnconditional::$_0::__invoke( swift_dynamicCastUnknownClassUnconditional::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastUnknownClassUnconditional(this);
  swift_dynamicCastUnknownClassUnconditional::Override = result;
  return result;
}

void *swift_dynamicCastMetatype::$_0::__invoke(swift_dynamicCastMetatype::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastMetatype(this);
  swift_dynamicCastMetatype::Override = result;
  return result;
}

void *swift_dynamicCastMetatypeUnconditional::$_0::__invoke( swift_dynamicCastMetatypeUnconditional::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastMetatypeUnconditional(this);
  swift_dynamicCastMetatypeUnconditional::Override = result;
  return result;
}

uint64_t __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::InsertIntoBucket<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>( uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4)
{
  int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }

  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
LABEL_3:
    uint64_t v10 = *(void *)a2;
    goto LABEL_4;
  }

  __swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::grow( a1,  v9);
  uint64_t v10 = *a3;
  int v12 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v13 = v12 & (((unint64_t)*a3 >> 9) ^ *a3);
  a2 = *(void *)a1 + 24LL * v13;
  uint64_t v14 = *(void *)a2;
  if (*a3 != *(void *)a2)
  {
    uint64_t v15 = 0LL;
    int v16 = 1;
    while (v14 != -2)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v14 == -16;
      }
      if (v17) {
        uint64_t v15 = a2;
      }
      unsigned int v18 = v13 + v16++;
      unsigned int v13 = v18 & v12;
      a2 = *(void *)a1 + 24LL * (v18 & v12);
      uint64_t v14 = *(void *)a2;
      if (v10 == *(void *)a2) {
        goto LABEL_4;
      }
    }

    if (v15) {
      a2 = v15;
    }
    goto LABEL_3;
  }

void *__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::grow( uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(__swift::__runtime::llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = __swift::__runtime::llvm::allocate_buffer(24LL * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0LL;
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    if (!v10) {
      goto LABEL_16;
    }
    unint64_t v11 = 24LL * v10 - 24;
    if (v11 >= 0x18)
    {
      unint64_t v16 = v11 / 0x18 + 1;
      int v12 = &result[3 * (v16 & 0x1FFFFFFFFFFFFFFELL)];
      uint64_t v17 = v16 & 0x1FFFFFFFFFFFFFFELL;
      unsigned int v18 = result;
      do
      {
        *unsigned int v18 = -2LL;
        v18[3] = -2LL;
        v18 += 6;
        v17 -= 2LL;
      }

      while (v17);
      if (v16 == (v16 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_16:
        if ((_DWORD)v3)
        {
          BOOL v20 = v4;
          do
          {
            unint64_t v26 = *(void *)v20;
            if (*(void *)v20 != -16LL && v26 != -2LL)
            {
              int v28 = *(_DWORD *)(a1 + 16) - 1;
              unsigned int v29 = v28 & ((v26 >> 9) ^ v26);
              uint64_t v25 = *(void *)a1 + 24LL * v29;
              uint64_t v30 = *(void *)v25;
              if (v26 != *(void *)v25)
              {
                uint64_t v31 = 0LL;
                int v32 = 1;
                while (v30 != -2)
                {
                  if (v31) {
                    BOOL v33 = 0;
                  }
                  else {
                    BOOL v33 = v30 == -16;
                  }
                  if (v33) {
                    uint64_t v31 = v25;
                  }
                  unsigned int v34 = v29 + v32++;
                  unsigned int v29 = v34 & v28;
                  uint64_t v25 = *(void *)a1 + 24LL * (v34 & v28);
                  uint64_t v30 = *(void *)v25;
                  if (v26 == *(void *)v25) {
                    goto LABEL_26;
                  }
                }

                if (v31) {
                  uint64_t v25 = v31;
                }
              }

void std::string::__init_copy_ctor_external( std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  unint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    unsigned int v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__l.__cap_ = v7 | 0x8000000000000000LL;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    unint64_t v5 = v8;
  }

  else
  {
    this->__r_.__value_.__s.__size_ = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::LookupBucketFor<__swift::__runtime::llvm::StringRef>( uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = 0LL;
    int v8 = v4 - 1;
    unsigned int v9 = (v4 - 1) & __swift::__runtime::llvm::hash_value(*(void **)a2, *(void *)(a2 + 8));
    unsigned int v10 = *(const void **)a2;
    size_t v11 = *(void *)(a2 + 8);
    for (int i = 1; ; ++i)
    {
      uint64_t v13 = v6 + 32LL * v9;
      unint64_t v14 = *(const void **)v13;
      if (*(void *)v13 == -2LL)
      {
      }

      else if (v14 == (const void *)-1LL)
      {
      }

      else if (v11 == *(void *)(v13 + 8) && (!v11 || !memcmp(v10, *(const void **)v13, v11)))
      {
LABEL_19:
        uint64_t result = 1LL;
        goto LABEL_21;
      }

      if (v7) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v14 == (const void *)-2LL;
      }
      if (v15) {
        uint64_t v7 = v6 + 32LL * v9;
      }
      unsigned int v16 = v9 + i;
      unsigned int v9 = v16 & v8;
    }

    uint64_t result = 0LL;
    if (v7) {
      uint64_t v13 = v7;
    }
  }

  else
  {
    uint64_t v13 = 0LL;
    uint64_t result = 0LL;
  }

void swift::Demangle::__runtime::StackAllocatedDemangler<1024ul>::~StackAllocatedDemangler(void *a1)
{
  *a1 = off_189B8E500;
  uint64_t v2 = a1 + 68;
  uint64_t v3 = (void *)a1[71];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *a1 = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)a1[3]);
  uint64_t v5 = a1[5];
  if (v5) {
    *(_BYTE *)(v5 + 48) = 0;
  }
  operator delete(a1);
}

void *__swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::InsertIntoBucketImpl<__swift::__runtime::llvm::StringRef>( uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }

  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }

  __swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::grow( a1,  v7);
  __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::LookupBucketFor<__swift::__runtime::llvm::StringRef>( (uint64_t *)a1,  a3,  &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1LL) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_OWORD *__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::grow( uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(__swift::__runtime::llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = __swift::__runtime::llvm::allocate_buffer(32LL * v8, (std::align_val_t)8uLL);
  unsigned int v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0LL;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0x7FFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_10;
      }
      uint64_t v12 = ((v11 - 1) & 0x7FFFFFFFFFFFFFFLL) + 1;
      unsigned int v10 = &result[2 * (v12 & 0xFFFFFFFFFFFFFFELL)];
      uint64_t v13 = result + 2;
      uint64_t v14 = v12 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = xmmword_18180BFC0;
        *uint64_t v13 = xmmword_18180BFC0;
        v13 += 4;
        v14 -= 2LL;
      }

      while (v14);
      if (v12 != (v12 & 0xFFFFFFFFFFFFFFELL))
      {
LABEL_10:
        BOOL v15 = &result[2 * v11];
        do
        {
          *unsigned int v10 = xmmword_18180BFC0;
          v10 += 2;
        }

        while (v10 != v15);
      }
    }

    unsigned int v16 = (void *)(32 * v3);
    if ((_DWORD)v3)
    {
      uint64_t v17 = 32 * v3;
      unsigned int v18 = v4;
      do
      {
        if (*(void *)v18 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::LookupBucketFor<__swift::__runtime::llvm::StringRef>( (uint64_t *)a1,  (uint64_t)v18,  &v25);
          unint64_t v19 = v25;
          *uint64_t v25 = *(_OWORD *)v18;
          v19[1] = *((_OWORD *)v18 + 1);
          ++*(_DWORD *)(a1 + 8);
        }

        unsigned int v18 = (__swift::__runtime::llvm *)((char *)v18 + 32);
        v17 -= 32LL;
      }

      while (v17);
    }

    __swift::__runtime::llvm::deallocate_buffer(v4, v16);
  }

  *(void *)(a1 + 8) = 0LL;
  uint64_t v20 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v20)
  {
    if (((v20 - 1) & 0x7FFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_23;
    }
    uint64_t v21 = ((v20 - 1) & 0x7FFFFFFFFFFFFFFLL) + 1;
    unsigned int v10 = &result[2 * (v21 & 0xFFFFFFFFFFFFFFELL)];
    uint64_t v22 = result + 2;
    uint64_t v23 = v21 & 0xFFFFFFFFFFFFFFELL;
    do
    {
      *(v22 - 2) = xmmword_18180BFC0;
      _OWORD *v22 = xmmword_18180BFC0;
      v22 += 4;
      v23 -= 2LL;
    }

    while (v23);
    if (v21 != (v21 & 0xFFFFFFFFFFFFFFELL))
    {
LABEL_23:
      char v24 = &result[2 * v20];
      do
      {
        *unsigned int v10 = xmmword_18180BFC0;
        v10 += 2;
      }

      while (v10 != v24);
    }
  }

  return result;
}

unsigned int *swift::_buildDemanglingForContext( uint64_t **a1, const char *a2, uint64_t a3, swift::Demangle::__runtime::NodeFactory *a4)
{
  unint64_t v133 = v135;
  uint64_t v134 = 0x800000000LL;
  if (a1)
  {
    int v7 = a1;
    unsigned int v8 = 0;
    do
    {
      if (v8 >= HIDWORD(v134))
      {
        __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v133, v135, v8 + 1LL, 8LL);
        unsigned int v8 = v134;
      }

      *(void *)&v133[8 * v8] = v7;
      unsigned int v8 = v134 + 1;
      LODWORD(v134) = v134 + 1;
      uint64_t v11 = *((int *)v7 + 1);
      uint64_t v10 = (uint64_t)v7 + 4;
      uint64_t v9 = v11;
      if (!(_DWORD)v11) {
        break;
      }
      int v7 = (uint64_t **)((v9 & 0xFFFFFFFFFFFFFFFELL) + v10);
      if ((v9 & 1) != 0) {
        int v7 = (uint64_t **)*v7;
      }
    }

    while (v7);
    if (v8)
    {
      std::string v118 = a2;
      uint64_t v119 = a3;
      uint64_t v12 = 0LL;
      unsigned int v120 = 0;
      uint64_t v13 = v133;
      uint64_t v14 = &v133[8 * v8];
      while (1)
      {
        char v24 = (char *)*((void *)v14 - 1);
        v14 -= 8;
        uint64_t v23 = v24;
        int v25 = *(_DWORD *)v24;
        int v26 = *(_DWORD *)v24 & 0x1F;
        if (v26 != 3) {
          break;
        }
        BOOL v15 = &v23[*((int *)v23 + 2) + 8];
        Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 180);
        swift::Demangle::__runtime::Node::addChild(Node, v12, a4, v17, v18);
        unint64_t v19 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 101, v15);
        uint64_t v22 = Node;
LABEL_12:
        swift::Demangle::__runtime::Node::addChild(v22, v19, a4, v20, v21);
LABEL_13:
        uint64_t v12 = (swift::Demangle::__runtime::Node *)Node;
        if (v14 == v13) {
          goto LABEL_155;
        }
      }

      if (v26 != 1)
      {
        if (!v26)
        {
          Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode( a4,  153,  &v23[*((int *)v23 + 2) + 8]);
          goto LABEL_13;
        }

        if ((v25 & 0x10) == 0)
        {
          snprintf(__str, 0x12uLL, "$%lx", v23);
          Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 1);
          v121[0] = 0LL;
          v121[1] = 0LL;
          size_t v35 = strlen(__str);
          swift::Demangle::__runtime::CharVector::append(v121, __str, v35, a4);
          __int128 v36 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( a4,  101,  (uint64_t *)v121);
          swift::Demangle::__runtime::Node::addChild(Node, v36, a4, v37, v38);
          swift::Demangle::__runtime::Node::addChild(Node, v12, a4, v39, v40);
          if (!a3) {
            goto LABEL_143;
          }
          if ((*(_DWORD *)v23 & 0x80) == 0) {
            goto LABEL_143;
          }
          int v41 = *(_DWORD *)v23 & 0x1F;
          if (v41 == 2) {
            goto LABEL_143;
          }
          switch(v41)
          {
            case 1:
              uint64_t v42 = v23 + 8;
              break;
            case 2:
            case 4:
              uint64_t v42 = v23 + 4;
              break;
            case 16:
              uint64_t v42 = v23 + 48;
              break;
            case 17:
            case 18:
              uint64_t v42 = v23 + 32;
              break;
            default:
              goto LABEL_143;
          }

          __int128 v98 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
          unsigned int v99 = *((unsigned __int16 *)v42 + 2);
          unsigned int v100 = v99 - v120;
          if (v99 > v120)
          {
            __int128 v101 = (swift::Demangle::__runtime::Node **)&v118[8 * v120];
            do
            {
              __int128 v102 = *v101++;
              swift::Demangle::__runtime::Node::addChild(v98, v102, a4, v20, v21);
              --v100;
            }

            while (v100);
            unsigned int v120 = v99;
          }

          if (!v98) {
LABEL_143:
          }
            __int128 v98 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
LABEL_144:
          uint64_t v22 = Node;
          unint64_t v19 = (swift::Demangle::__runtime::Node *)v98;
          goto LABEL_12;
        }

        swift::ParsedTypeIdentity::parse((uint64_t)v23, (uint64_t)__str);
        if (v26 == 16)
        {
          __int16 v44 = 24;
          __int16 v43 = 13;
          if (!v130) {
            goto LABEL_55;
          }
        }

        else
        {
          if (v26 == 17)
          {
            __int16 v47 = 219;
            __int16 v43 = 15;
            if (v130 && v127 == 1)
            {
              if (*v126 == 116) {
                __int16 v47 = 234;
              }
              else {
                __int16 v47 = 219;
              }
            }

            goto LABEL_58;
          }

          if (v26 == 18) {
            __int16 v43 = 14;
          }
          else {
            __int16 v43 = 17;
          }
          if (v26 == 18) {
            __int16 v44 = 61;
          }
          else {
            __int16 v44 = 167;
          }
          if (!v130)
          {
LABEL_55:
            else {
              __int16 v47 = v44;
            }
            goto LABEL_58;
          }
        }

        if (v127 != 1) {
          goto LABEL_55;
        }
        __int16 v47 = *v126 == 116 ? 234 : 219;
        if (*v126 != 116) {
          goto LABEL_55;
        }
LABEL_58:
        Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, v47);
        swift::Demangle::__runtime::Node::addChild(Node, v12, a4, v48, v49);
        if (v130) {
          BOOL v50 = v125 == 0;
        }
        else {
          BOOL v50 = 1;
        }
        if (v50) {
          size_t v51 = v123;
        }
        else {
          size_t v51 = v125;
        }
        __int128 v52 = (char *)&v124;
        if (v50) {
          __int128 v52 = __str;
        }
        if (v51)
        {
          int v53 = *(const void **)v52;
          uint64_t v54 = (char *)*((void *)a4 + 1);
          if (!v54 || (unint64_t)&v54[v51] > *((void *)a4 + 2))
          {
            unint64_t v55 = 2LL * *((void *)a4 + 4);
            if (v55 <= v51 + 1) {
              unint64_t v55 = v51 + 1;
            }
            *((void *)a4 + 4) = v55;
            unint64_t v56 = v55 + 8;
            int v57 = malloc(v55 + 8);
            *int v57 = *((void *)a4 + 3);
            uint64_t v54 = (char *)(v57 + 1);
            *((void *)a4 + 2) = (char *)v57 + v56;
            *((void *)a4 + 3) = v57;
          }

          *((void *)a4 + 1) = &v54[v51];
          memmove(v54, v53, v51);
        }

        else
        {
          uint64_t v54 = 0LL;
        }

        NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( a4,  101,  (uint64_t)v54,  v51);
        if (v130)
        {
          size_t v61 = __len;
          if (__len)
          {
            __int128 v62 = __src;
            int v63 = (char *)*((void *)a4 + 1);
            if (!v63 || (unint64_t)&v63[__len] > *((void *)a4 + 2))
            {
              size_t v64 = 2LL * *((void *)a4 + 4);
              if (v64 <= __len + 1) {
                size_t v64 = __len + 1;
              }
              *((void *)a4 + 4) = v64;
              size_t v65 = v64 + 8;
              __int128 v66 = malloc(v64 + 8);
              __int128 v67 = (char *)v66 + v65;
              *__int128 v66 = *((void *)a4 + 3);
              int v63 = (char *)(v66 + 1);
              *((void *)a4 + 2) = v67;
              *((void *)a4 + 3) = v66;
            }

            *((void *)a4 + 1) = &v63[v61];
            memmove(v63, v62, v61);
            unint64_t v68 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( a4,  101,  (uint64_t)v63,  v61);
            unsigned int v69 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 205);
            swift::Demangle::__runtime::Node::addChild(v69, v68, a4, v70, v71);
            swift::Demangle::__runtime::Node::addChild(v69, NodeWithAllocatedText, a4, v72, v73);
            NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)v69;
          }
        }

        a3 = v119;
        swift::Demangle::__runtime::Node::addChild(Node, NodeWithAllocatedText, a4, v58, v59);
        if (!v119) {
          goto LABEL_13;
        }
        if ((*(_DWORD *)v23 & 0x80) == 0) {
          goto LABEL_13;
        }
        int v74 = *(_DWORD *)v23 & 0x1F;
        if (v74 == 2) {
          goto LABEL_13;
        }
        switch(v74)
        {
          case 1:
            __int128 v75 = v23 + 8;
            goto LABEL_147;
          case 2:
          case 4:
            __int128 v75 = v23 + 4;
            goto LABEL_147;
          case 16:
            __int128 v75 = v23 + 48;
            goto LABEL_147;
          case 17:
          case 18:
            __int128 v75 = v23 + 32;
LABEL_147:
            __int128 v98 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
            unsigned int v105 = *((unsigned __int16 *)v75 + 2);
            unsigned int v106 = v105 - v120;
            if (v105 > v120)
            {
              __int128 v107 = (swift::Demangle::__runtime::Node **)&v118[8 * v120];
              do
              {
                __int128 v108 = *v107++;
                swift::Demangle::__runtime::Node::addChild(v98, v108, a4, v103, v104);
                --v106;
              }

              while (v106);
              unsigned int v120 = v105;
            }

            if (!v98) {
              goto LABEL_13;
            }
            __int128 v109 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 232);
            swift::Demangle::__runtime::Node::addChild(v109, (swift::Demangle::__runtime::Node *)Node, a4, v110, v111);
            Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, v43);
            swift::Demangle::__runtime::Node::addChild(Node, (swift::Demangle::__runtime::Node *)v109, a4, v112, v113);
            break;
          default:
            goto LABEL_13;
        }

        goto LABEL_144;
      }

      int v28 = v23 + 8;
      uint64_t v27 = *((int *)v23 + 2);
      if ((_DWORD)v27) {
        unsigned int v29 = &v23[v27 + 8];
      }
      else {
        unsigned int v29 = 0LL;
      }
      SymbolicMangledNameStringRef = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef(v29, a2);
      v131[0] = &unk_189B8B158;
      v131[1] = a4;
      uint64_t v132 = v131;
      unint64_t v32 = swift::Demangle::__runtime::Demangler::demangleType( (uint64_t)a4,  (uint64_t)SymbolicMangledNameStringRef,  v31,  v131);
      BOOL v33 = v132;
      if (v132 == v131)
      {
        BOOL v33 = v131;
        uint64_t v34 = 4LL;
      }

      else
      {
        if (!v132) {
          goto LABEL_42;
        }
        uint64_t v34 = 5LL;
      }

      (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_42:
      if (*(_WORD *)(v32 + 16) == 232)
      {
        int v45 = *(unsigned __int8 *)(v32 + 18);
        if ((v45 - 1) < 2)
        {
LABEL_47:
          unint64_t v32 = *(void *)v32;
          int v46 = 0LL;
          if (!a3) {
            goto LABEL_110;
          }
          goto LABEL_94;
        }

        if (v45 == 5)
        {
          if (!*(_DWORD *)(v32 + 8))
          {
            unint64_t v32 = 0LL;
            int v46 = 0LL;
            if (!a3) {
              goto LABEL_110;
            }
            goto LABEL_94;
          }

          unint64_t v32 = *(void *)v32;
          goto LABEL_47;
        }

        unint64_t v32 = 0LL;
      }

      int v46 = 0LL;
      if (!a3) {
        goto LABEL_110;
      }
LABEL_94:
      if ((*(_DWORD *)v23 & 0x80) != 0)
      {
        int v76 = *(_DWORD *)v23 & 0x1F;
        if (v76 != 2)
        {
          int v46 = 0LL;
          switch(v76)
          {
            case 1:
              goto LABEL_104;
            case 2:
            case 4:
              int v28 = v23 + 4;
              goto LABEL_104;
            case 16:
              int v28 = v23 + 48;
              goto LABEL_104;
            case 17:
            case 18:
              int v28 = v23 + 32;
LABEL_104:
              if (v120 >= *((unsigned __int16 *)v28 + 2))
              {
                int v46 = 0LL;
              }

              else
              {
                int v46 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
                unsigned int v79 = *((unsigned __int16 *)v28 + 2);
                unsigned int v80 = v79 - v120;
                if (v79 > v120)
                {
                  char v81 = (swift::Demangle::__runtime::Node **)&v118[8 * v120];
                  do
                  {
                    uint64_t v82 = *v81++;
                    swift::Demangle::__runtime::Node::addChild(v46, v82, a4, v77, v78);
                    --v80;
                  }

                  while (v80);
                  unsigned int v120 = v79;
                }
              }

              break;
            default:
              break;
          }
        }
      }

unsigned int *_swift_buildDemanglingForMetadata( uint64_t a1, swift::Demangle::__runtime::NodeFactory *a2, const char *a3, char *a4)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)a1;
  if (*(void *)a1 > 0x7FFuLL) {
    LODWORD(v6) = 0;
  }
  if ((int)v6 > 768)
  {
    Node = 0LL;
    switch((int)v6)
    {
      case 769:
        unsigned int v8 = *(const char **)(a1 + 16);
        Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 223);
        uint64_t v9 = *(unsigned int *)(v5 + 8);
        if (!*(_DWORD *)(v5 + 8)) {
          return Node;
        }
        for (int i = (void *)(v5 + 24); ; i += 2)
        {
          char v24 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 224);
          if (v8)
          {
            int v25 = strchr(v8, 32);
            if (v25)
            {
              int v26 = v25;
              if (v8 != v25)
              {
                int64_t v27 = v25 - v8;
                int v28 = (char *)*((void *)a2 + 1);
                if (!v28 || (unint64_t)&v28[v27] > *((void *)a2 + 2))
                {
                  unint64_t v29 = 2LL * *((void *)a2 + 4);
                  if (v29 <= v27 + 1) {
                    unint64_t v29 = v27 + 1;
                  }
                  *((void *)a2 + 4) = v29;
                  unint64_t v30 = v29 + 8;
                  uint64_t v31 = malloc(v29 + 8);
                  unint64_t v32 = (char *)v31 + v30;
                  *uint64_t v31 = *((void *)a2 + 3);
                  int v28 = (char *)(v31 + 1);
                  *((void *)a2 + 2) = v32;
                  *((void *)a2 + 3) = v31;
                }

                *((void *)a2 + 1) = &v28[v27];
                memmove(v28, v8, v26 - v8);
                NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( a2,  225,  (uint64_t)v28,  v26 - v8);
                swift::Demangle::__runtime::Node::addChild(v24, NodeWithAllocatedText, a2, v34, v35);
              }

              unsigned int v8 = v26 + 1;
            }
          }

          uint64_t v36 = _swift_buildDemanglingForMetadata(*i, a2);
          if (!v36) {
            break;
          }
          uint64_t v37 = (swift::Demangle::__runtime::Node *)v36;
          if (*(_WORD *)(v36 + 16) == 232)
          {
            uint64_t v20 = v24;
            uint64_t v21 = v37;
          }

          else
          {
            BOOL v15 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
            swift::Demangle::__runtime::Node::addChild(v15, v37, a2, v16, v17);
            uint64_t v20 = v24;
            uint64_t v21 = (swift::Demangle::__runtime::Node *)v15;
          }

          swift::Demangle::__runtime::Node::addChild(v20, v21, a2, v18, v19);
          swift::Demangle::__runtime::Node::addChild(Node, (swift::Demangle::__runtime::Node *)v24, a2, v22, v23);
          if (!--v9) {
            return Node;
          }
        }

        goto LABEL_349;
      case 770:
        uint64_t v50 = *(void *)(a1 + 8);
        if (BYTE2(v50) == 3)
        {
          __int16 v52 = 22;
        }

        else if (BYTE2(v50) == 2)
        {
          __int16 v52 = 222;
        }

        else
        {
          if ((v50 & 0x4000000) != 0) {
            __int16 v51 = 82;
          }
          else {
            __int16 v51 = 65;
          }
          if (BYTE2(v50)) {
            __int16 v52 = 165;
          }
          else {
            __int16 v52 = v51;
          }
        }

        uint64_t v222 = v224;
        *(void *)uint64_t v223 = 0x800000000LL;
        uint64_t v130 = (unsigned __int16)v50;
        if (!(_WORD)v50) {
          goto LABEL_247;
        }
        uint64_t v131 = 0LL;
        uint64_t v132 = a1 + 24;
        while (2)
        {
          uint64_t v133 = *(void *)(v5 + 8);
          if ((v133 & 0x2000000) != 0) {
            unsigned int v134 = *(_DWORD *)(v132 + 8LL * (unsigned __int16)v133 + 4 * v131);
          }
          else {
            unsigned int v134 = 0;
          }
          uint64_t v135 = _swift_buildDemanglingForMetadata(*(void *)(v132 + 8 * v131), a2);
          if (!v135) {
            goto LABEL_266;
          }
          unint64_t v136 = (swift::Demangle::__runtime::Node *)v135;
          if ((v134 & 0x200) != 0)
          {
            int64_t v137 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 326);
            swift::Demangle::__runtime::Node::addChild(v137, v136, a2, v138, v139);
            unint64_t v136 = (swift::Demangle::__runtime::Node *)v137;
          }

          unsigned int v140 = (v134 & 0x7F) - 1;
          if (v140 > 2)
          {
            if ((v134 & 0x400) != 0)
            {
LABEL_232:
              uint64_t v144 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 127);
              swift::Demangle::__runtime::Node::addChild(v144, v136, a2, v145, v146);
              unint64_t v136 = (swift::Demangle::__runtime::Node *)v144;
              if ((v134 & 0x800) == 0)
              {
LABEL_237:
                uint64_t v150 = v223[0];
                if (v223[0] >= (unint64_t)v223[1])
                {
                  __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod( (uint64_t)&v222,  v224,  v223[0] + 1LL,  16LL);
                  uint64_t v150 = v223[0];
                }

                int8x16_t v151 = (swift::Demangle::__runtime::Node **)((char *)v222 + 16 * v150);
                *int8x16_t v151 = v136;
                v151[1] = (swift::Demangle::__runtime::Node *)((v134 >> 7) & 1);
                int v152 = v223[0]++;
                if (v130 == ++v131)
                {
                  if (v152 || (*((_BYTE *)v222 + 8) & 1) != 0) {
                    goto LABEL_247;
                  }
                  unint64_t v153 = *(void *)v222;
                  int v154 = *(unsigned __int16 *)(*(void *)v222 + 16LL);
                  if (v154 == 232)
                  {
                    unint64_t v155 = *(void *)v222;
                    int v154 = *(unsigned __int16 *)(*(void *)v155 + 16LL);
                  }

                  if (v154 == 223)
                  {
LABEL_247:
                    unint64_t v153 = swift::Demangle::__runtime::NodeFactory::createNode(a2, 223);
                    if (v223[0])
                    {
                      unint64_t v156 = (swift::Demangle::__runtime::Node **)v222;
                      unint64_t v157 = (swift::Demangle::__runtime::Node **)((char *)v222 + 16 * v223[0]);
                      do
                      {
                        char v167 = *v156;
                        int v168 = *((unsigned __int8 *)v156 + 8);
                        char v169 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 224);
                        if (v168)
                        {
                          uint64_t v170 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( a2,  276);
                          swift::Demangle::__runtime::Node::addChild(v169, v170, a2, v171, v172);
                        }

                        if (*((_WORD *)v167 + 8) == 232)
                        {
                          unint64_t v163 = v169;
                          uint64_t v164 = v167;
                        }

                        else
                        {
                          unint64_t v158 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
                          swift::Demangle::__runtime::Node::addChild(v158, v167, a2, v159, v160);
                          unint64_t v163 = v169;
                          uint64_t v164 = (swift::Demangle::__runtime::Node *)v158;
                        }

                        swift::Demangle::__runtime::Node::addChild(v163, v164, a2, v161, v162);
                        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v153,  (swift::Demangle::__runtime::Node *)v169,  a2,  v165,  v166);
                        v156 += 2;
                      }

                      while (v156 != v157);
                    }
                  }

                  uint64_t v173 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 3);
                  int64x2_t v174 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
                  swift::Demangle::__runtime::Node::addChild( v174,  (swift::Demangle::__runtime::Node *)v153,  a2,  v175,  v176);
                  swift::Demangle::__runtime::Node::addChild( v173,  (swift::Demangle::__runtime::Node *)v174,  a2,  v177,  v178);
                  uint64_t v179 = _swift_buildDemanglingForMetadata(*(void *)(v5 + 16), a2);
                  if (!v179) {
                    goto LABEL_266;
                  }
                  uint64_t v180 = (swift::Demangle::__runtime::Node *)v179;
                  uint64_t v181 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 207);
                  swift::Demangle::__runtime::Node::addChild(v181, v180, a2, v182, v183);
                  Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, v52);
                  unint64_t v184 = *(void *)(v5 + 8);
                  if ((v184 & 0x10000000) != 0)
                  {
                    uint64_t v185 = _swift_buildDemanglingForMetadata( *(void *)(((v5 + 8LL * (unsigned __int16)v184 + 4 * ((unsigned __int16)*(void *)(v5 + 8) & (unint64_t)((uint64_t)(*(void *)(v5 + 8) << 38) >> 63))
                                         + 31) & 0xFFFFFFFFFFFFFFF8LL)
                                       + 8 * ((v184 >> 27) & 1)),
                             a2);
                    if (!v185) {
                      goto LABEL_266;
                    }
                    unint64_t v186 = (swift::Demangle::__runtime::Node *)v185;
                    unint64_t v187 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 67);
                    swift::Demangle::__runtime::Node::addChild(v187, v186, a2, v188, v189);
                    swift::Demangle::__runtime::Node::addChild( Node,  (swift::Demangle::__runtime::Node *)v187,  a2,  v190,  v191);
                    unint64_t v184 = *(void *)(v5 + 8);
                  }

                  if ((v184 & 0x8000000) != 0)
                  {
                    unint64_t v192 = *(void *)((v5
                                      + 8LL * (unsigned __int16)v184
                                      + 4 * ((unsigned __int16)v184 & (unint64_t)((uint64_t)(v184 << 38) >> 63))
                                      + 31) & 0xFFFFFFFFFFFFFFF8LL)
                         - 1LL;
                    if (v192 <= 3)
                    {
                      uint64_t v193 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( a2,  68,  qword_18180C068[v192]);
                      swift::Demangle::__runtime::Node::addChild(Node, v193, a2, v194, v195);
                    }
                  }

                  if ((*(_BYTE *)(v5 + 11) & 1) != 0)
                  {
                    uint64_t ThrownError = swift::TargetFunctionTypeMetadata<swift::InProcess>::getThrownError(v5);
                    if (ThrownError)
                    {
                      uint64_t v197 = _swift_buildDemanglingForMetadata(ThrownError, a2);
                      if (!v197) {
                        goto LABEL_266;
                      }
                      size_t v198 = (swift::Demangle::__runtime::Node *)v197;
                      int64x2_t v199 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 273);
                      swift::Demangle::__runtime::Node::addChild(v199, v198, a2, v200, v201);
                    }

                    else
                    {
                      int64x2_t v199 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 272);
                    }

                    swift::Demangle::__runtime::Node::addChild( Node,  (swift::Demangle::__runtime::Node *)v199,  a2,  v202,  v203);
                  }

                  uint64_t v204 = *(void *)(v5 + 8);
                  if ((v204 & 0x40000000) != 0)
                  {
                    uint64_t v205 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( a2,  66);
                    swift::Demangle::__runtime::Node::addChild(Node, v205, a2, v206, v207);
                    uint64_t v204 = *(void *)(v5 + 8);
                  }

                  if ((v204 & 0x20000000) != 0)
                  {
                    uint64_t v208 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( a2,  271);
                    swift::Demangle::__runtime::Node::addChild(Node, v208, a2, v209, v210);
                  }

                  if ((swift::TargetFunctionTypeMetadata<swift::InProcess>::getExtendedFlags(v5) & 0x10) != 0)
                  {
                    uint32x4_t v213 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( a2,  130);
                    swift::Demangle::__runtime::Node::addChild(Node, v213, a2, v214, v215);
                  }

                  swift::Demangle::__runtime::Node::addChild( Node,  (swift::Demangle::__runtime::Node *)v173,  a2,  v211,  v212);
                  swift::Demangle::__runtime::Node::addChild( Node,  (swift::Demangle::__runtime::Node *)v181,  a2,  v216,  v217);
                  goto LABEL_267;
                }

                continue;
              }

uint64_t swift::TargetFunctionTypeMetadata<swift::InProcess>::getThrownError(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 8);
  if ((v1 & 0x80000000) == 0) {
    return 0LL;
  }
  uint64_t v3 = (_BYTE *)(((a1
                 + 8LL * (unsigned __int16)v1
                 + 4 * ((unsigned __int16)v1 & (unint64_t)((uint64_t)(v1 << 38) >> 63))
                 + 31) & 0xFFFFFFFFFFFFFFF8LL)
               + 8 * ((v1 >> 27) & 1)
               + 8 * ((v1 >> 28) & 1));
  if ((*v3 & 1) != 0) {
    return *(void *)((unint64_t)&v3[4 * ((v1 >> 31) & 1) + 7] & 0xFFFFFFFFFFFFFFF8LL);
  }
  else {
    return 0LL;
  }
}

uint64_t swift::TargetFunctionTypeMetadata<swift::InProcess>::getExtendedFlags(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 8);
  if ((v1 & 0x80000000) != 0) {
    return *(unsigned int *)(((a1
  }
                             + 8LL * (unsigned __int16)*(void *)(a1 + 8)
                             + 4
                             * ((unsigned __int16)*(void *)(a1 + 8) & (unint64_t)((uint64_t)(*(void *)(a1 + 8) << 38) >> 63))
                             + 31) & 0xFFFFFFFFFFFFFFF8LL)
                           + 8 * ((v1 >> 27) & 1)
                           + 8 * ((v1 >> 28) & 1));
  else {
    return 0LL;
  }
}

unsigned int *swift::_buildDemanglingForGenericType( uint64_t **a1, uint64_t a2, swift::Demangle::__runtime::NodeFactory *a3)
{
  if ((*(_DWORD *)a1 & 0x1Fu) - 16 > 2) {
    return 0LL;
  }
  int v7 = v9;
  *(void *)unsigned int v8 = 0x800000000LL;
  else {
    uint64_t v5 = 0LL;
  }
  if (v7 != v9) {
    free(v7);
  }
  return v5;
}

uint64_t _buildDemanglingForGenericArgs( unsigned int *a1, uint64_t a2, uint64_t a3, swift::Demangle::__runtime::NodeFactory *a4)
{
  if ((*a1 & 0x80) == 0) {
    return 1LL;
  }
  uint64_t v4 = 1LL;
  switch(*a1 & 0x1F)
  {
    case 1u:
      unsigned int v8 = (unsigned __int16 *)(a1 + 2);
      goto LABEL_8;
    case 2u:
    case 4u:
      unsigned int v8 = (unsigned __int16 *)(a1 + 1);
      goto LABEL_8;
    case 0x10u:
      unsigned int v8 = (unsigned __int16 *)(a1 + 12);
      goto LABEL_8;
    case 0x11u:
    case 0x12u:
      unsigned int v8 = (unsigned __int16 *)(a1 + 8);
LABEL_8:
      unsigned __int16 v9 = v8[5];
      uint64_t v10 = v9 & 1;
      if ((v9 & 1) != 0)
      {
        unint64_t v11 = v8[2];
        unsigned int v12 = (_DWORD *)((((unint64_t)v8 + v11 + 15) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v8[3]);
        unsigned int v13 = HIWORD(*v12);
        uint64_t v14 = &v12[v10];
        else {
          BOOL v15 = 0LL;
        }
      }

      else
      {
        unsigned int v13 = 0;
        BOOL v15 = 0LL;
        unint64_t v11 = v8[2];
      }

      v67[0] = v68;
      v67[1] = (void *)0x600000000LL;
      uint64_t v16 = v8 + 6;
      if (!(_DWORD)v11)
      {
        uint64_t v19 = 0LL;
        goto LABEL_31;
      }

      if (v11 < 8)
      {
        unsigned int v17 = 0;
        uint64_t v18 = (unsigned __int8 *)(v8 + 6);
        goto LABEL_28;
      }

      if (v11 >= 0x20)
      {
        int32x4_t v21 = 0uLL;
        uint64_t v20 = (unsigned __int16)v11 & 0xFFE0;
        int32x4_t v22 = 0uLL;
        uint64_t v23 = (uint8x16_t *)(v8 + 14);
        uint64_t v24 = v20;
        int32x4_t v25 = 0uLL;
        int32x4_t v26 = 0uLL;
        int32x4_t v27 = 0uLL;
        int32x4_t v28 = 0uLL;
        int32x4_t v29 = 0uLL;
        int32x4_t v30 = 0uLL;
        do
        {
          uint8x16_t v31 = vshrq_n_u8(v23[-1], 7uLL);
          uint8x16_t v32 = vshrq_n_u8(*v23, 7uLL);
          uint16x8_t v33 = vmovl_u8(*(uint8x8_t *)v31.i8);
          uint16x8_t v34 = vmovl_high_u8(v31);
          uint16x8_t v35 = vmovl_u8(*(uint8x8_t *)v32.i8);
          uint16x8_t v36 = vmovl_high_u8(v32);
          int32x4_t v26 = (int32x4_t)vaddw_high_u16((uint32x4_t)v26, v34);
          int32x4_t v25 = (int32x4_t)vaddw_u16((uint32x4_t)v25, *(uint16x4_t *)v34.i8);
          int32x4_t v22 = (int32x4_t)vaddw_high_u16((uint32x4_t)v22, v33);
          int32x4_t v21 = (int32x4_t)vaddw_u16((uint32x4_t)v21, *(uint16x4_t *)v33.i8);
          int32x4_t v30 = (int32x4_t)vaddw_high_u16((uint32x4_t)v30, v36);
          int32x4_t v29 = (int32x4_t)vaddw_u16((uint32x4_t)v29, *(uint16x4_t *)v36.i8);
          int32x4_t v28 = (int32x4_t)vaddw_high_u16((uint32x4_t)v28, v35);
          int32x4_t v27 = (int32x4_t)vaddw_u16((uint32x4_t)v27, *(uint16x4_t *)v35.i8);
          v23 += 2;
          v24 -= 32LL;
        }

        while (v24);
        unsigned int v17 = vaddvq_s32( vaddq_s32( vaddq_s32(vaddq_s32(v27, v21), vaddq_s32(v29, v25)),  vaddq_s32(vaddq_s32(v28, v22), vaddq_s32(v30, v26))));
        if (v11 == v20) {
          goto LABEL_30;
        }
        if ((v11 & 0x18) == 0)
        {
          uint64_t v18 = &v16[v20];
LABEL_28:
          __int16 v43 = &v16[v11];
          do
          {
            unsigned int v44 = *v18++;
            v17 += v44 >> 7;
          }

          while (v18 != v43);
          goto LABEL_30;
        }
      }

      else
      {
        unsigned int v17 = 0;
        uint64_t v20 = 0LL;
      }

      uint64_t v18 = &v16[v11 & 0xFFF8];
      int32x4_t v37 = 0uLL;
      int32x4_t v38 = (int32x4_t)v17;
      uint64_t v39 = (uint8x8_t *)((char *)v8 + v20 + 12);
      uint64_t v40 = v20 - ((unsigned __int16)v11 & 0xFFF8);
      do
      {
        uint8x8_t v41 = *v39++;
        uint16x8_t v42 = vmovl_u8(vshr_n_u8(v41, 7uLL));
        int32x4_t v37 = (int32x4_t)vaddw_high_u16((uint32x4_t)v37, v42);
        int32x4_t v38 = (int32x4_t)vaddw_u16((uint32x4_t)v38, *(uint16x4_t *)v42.i8);
        v40 += 8LL;
      }

      while (v40);
      unsigned int v17 = vaddvq_s32(vaddq_s32(v38, v37));
      if (v11 != (v11 & 0xFFF8)) {
        goto LABEL_28;
      }
LABEL_30:
      uint64_t v19 = v17;
LABEL_31:
      if ((swift::_gatherWrittenGenericParameters(a1, a2 + 8LL * v13, v19, (uint64_t)v67, (uint64_t)a4) & 1) != 0)
      {
        uint64_t v47 = v8[2];
        if (v8[2])
        {
          uint64_t v66 = a2;
          uint64_t v48 = 0LL;
          int v49 = 0;
          uint64_t v50 = &v16[v47];
          size_t v65 = (const void *)(a3 + 16);
          do
          {
            uint64_t v51 = *((void *)v67[0] + v48);
            if ((*v16 & 0x3F) == 1)
            {
              if ((v51 & 1) == 0) {
                swift::fatalError(0LL, "Expected a metadata pack but got metadata\n", v45, v46);
              }
              uint64_t v56 = v15;
              unint64_t v57 = *(void *)(v66 + 8LL * LOWORD(v15[2 * v49 + 1]));
              Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 226);
              if (v57)
              {
                __int128 v59 = (void *)(v51 & 0xFFFFFFFFFFFFFFFELL);
                if (v57 <= 1) {
                  unint64_t v57 = 1LL;
                }
                while (1)
                {
                  uint64_t v60 = (swift::Demangle::__runtime::Node *)_swift_buildDemanglingForMetadata(*v59, a4);
                  if (!v60) {
                    break;
                  }
                  swift::Demangle::__runtime::Node::addChild(Node, v60, a4, v61, v62);
                  ++v59;
                  if (!--v57) {
                    goto LABEL_52;
                  }
                }

char *swift_demangle(swift::Demangle::__runtime *this, const char *a2, const char *a3, char *a4, int a5)
{
  if (a5) {
    swift::fatalError(0LL, "Only 'flags' value of '0' is currently supported.", a3, a4);
  }
  uint64_t v6 = (char *)a3;
  if (a3 && !a4) {
    swift::fatalError(0LL, "'outputBuffer' is passed but the size is 'nullptr'.", a3, 0LL);
  }
  if (!swift::Demangle::__runtime::isSwiftSymbol(this, a2)) {
    return 0LL;
  }
  char v21 = 0;
  uint64_t v22 = 0x101010101010101LL;
  char v23 = 1;
  uint64_t v24 = 0x100010100000000LL;
  char v25 = 1;
  __int16 v26 = 256;
  char v27 = 1;
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  v30[0] = &unk_189B8B0E8;
  v30[1] = swift::Demangle::__runtime::genericParameterName;
  uint8x16_t v31 = v30;
  swift::Demangle::__runtime::demangleSymbolAsString(this, (unint64_t)a2, (uint64_t)&v21, &__p);
  if (!v6 || !*(void *)a4)
  {
    int v13 = (char)v20;
    if ((v20 & 0x80u) == 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    uint64_t v6 = strdup(p_p);
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  if ((v20 & 0x80u) == 0) {
    unsigned __int16 v9 = (const char *)&__p;
  }
  else {
    unsigned __int16 v9 = (const char *)__p;
  }
  _swift_strlcpy(v6, v9, *(void *)a4);
  unint64_t v10 = *(void *)a4;
  int v11 = (char)v20;
  if ((char)v20 < 0)
  {
    uint64_t v12 = v19 + 1;
    if (v10 >= v19 + 1)
    {
LABEL_21:
      operator delete(__p);
      goto LABEL_22;
    }
  }

  else
  {
    if (v10 > v20) {
      goto LABEL_22;
    }
    uint64_t v12 = v20 + 1LL;
  }

  *(void *)a4 = v12;
  if (v11 < 0) {
    goto LABEL_21;
  }
LABEL_22:
  BOOL v15 = v31;
  if (v31 == v30)
  {
    uint64_t v16 = 4LL;
    BOOL v15 = v30;
    goto LABEL_26;
  }

  if (v31)
  {
    uint64_t v16 = 5LL;
LABEL_26:
    (*(void (**)(void))(*v15 + 8 * v16))();
  }

  return v6;
}

void *std::__function::__func<swift::ResolveToDemanglingForContext,std::allocator<swift::ResolveToDemanglingForContext>,swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,swift::Demangle::__runtime::Directness,int,void const*)>::__clone( uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_189B8B158;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift::ResolveToDemanglingForContext,std::allocator<swift::ResolveToDemanglingForContext>,swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,swift::Demangle::__runtime::Directness,int,void const*)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_189B8B158;
  a2[1] = v2;
  return result;
}

unsigned int *std::__function::__func<swift::ResolveToDemanglingForContext,std::allocator<swift::ResolveToDemanglingForContext>,swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,swift::Demangle::__runtime::Directness,int,void const*)>::operator()( uint64_t a1, unsigned __int8 *a2, int *a3, int *a4, uint64_t *a5)
{
  return swift::ResolveToDemanglingForContext::operator()( (swift::Demangle::__runtime::NodeFactory **)(a1 + 8),  *a2,  *a3,  *a4,  *a5);
}

uint64_t swift_dynamicCast(char *a1, uint64_t *a2, swift *a3, const char *a4, unint64_t a5)
{
  if (swift_dynamicCast::Override) {
    return swift_dynamicCast::Override(a1, a2, a3, a4, a5, swift_dynamicCastImpl);
  }
  int v13 = a3;
  uint64_t v14 = a4;
  uint64_t result = tryCast(a1, (uint64_t)a4, a2, (uint64_t)a3, (unint64_t *)&v14, &v13, (a5 >> 1) & 1, a5 & 1);
  if ((_DWORD)result == 1)
  {
    uint64_t v12 = 1LL;
    if ((a5 & 2) == 0) {
      return result;
    }
    goto LABEL_9;
  }

  if ((_DWORD)result) {
    return 1LL;
  }
  if ((a5 & 1) != 0) {
    swift::swift_dynamicCastFailure(v13, v14, 0LL, v11);
  }
  uint64_t v12 = 0LL;
  uint64_t result = 0LL;
  if ((a5 & 4) != 0)
  {
LABEL_9:
    (*(void (**)(uint64_t *, swift *))(*((void *)a3 - 1) + 8LL))(a2, a3);
    return v12;
  }

  return result;
}

uint64_t swift_dynamicCastImpl(char *a1, uint64_t *a2, swift *a3, const char *a4, unint64_t a5)
{
  char v5 = a5;
  int v11 = a3;
  uint64_t v12 = a4;
  uint64_t result = tryCast(a1, (uint64_t)a4, a2, (uint64_t)a3, (unint64_t *)&v12, &v11, (a5 >> 1) & 1, a5 & 1);
  if ((_DWORD)result == 1)
  {
    uint64_t v10 = 1LL;
    if ((v5 & 2) == 0) {
      return result;
    }
    goto LABEL_7;
  }

  if ((_DWORD)result) {
    return 1LL;
  }
  if ((v5 & 1) != 0) {
    swift::swift_dynamicCastFailure(v11, v12, 0LL, v9);
  }
  uint64_t v10 = 0LL;
  uint64_t result = 0LL;
  if ((v5 & 4) != 0)
  {
LABEL_7:
    (*(void (**)(uint64_t *, swift *))(*((void *)a3 - 1) + 8LL))(a2, a3);
    return v10;
  }

  return result;
}

void *swift_dynamicCast::$_0::__invoke(swift_dynamicCast::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCast(this);
  swift_dynamicCast::Override = result;
  return result;
}

uint64_t tryCast( char *a1, uint64_t a2, uint64_t *a3, uint64_t a4, unint64_t *a5, void *a6, uint64_t a7, uint64_t a8)
{
  *a5 = a2;
  *a6 = a4;
  if (a4 == a2)
  {
    uint64_t v19 = *(void *)(a4 - 8);
    if ((_DWORD)a7)
    {
      (*(void (**)(char *, uint64_t *, uint64_t))(v19 + 32))(a1, a3, a4);
      return 2LL;
    }

    else
    {
      (*(void (**)(char *, uint64_t *, uint64_t))(v19 + 16))(a1, a3, a4);
      return 1LL;
    }
  }

  if (*(void *)a2 <= 0x7FFuLL) {
    int v16 = *(void *)a2;
  }
  else {
    int v16 = 0;
  }
  v17.int isa = *(Class *)a4;
  if (*(void *)a4 > 0x7FFuLL) {
    LODWORD(v17.isa) = 0;
  }
  int isa = (int)v17.isa;
  if (v16 <= 767)
  {
    switch(v16)
    {
      case 512:
        char v21 = *(StructDescriptor **)(a2 + 8);
        if (v21 == &nominal type descriptor for String)
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToString;
        }

        else if (v21 == &nominal type descriptor for AnyHashable)
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToAnyHashable;
        }

        else if (v21 == &nominal type descriptor for Array)
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToArray;
        }

        else if (v21 == &nominal type descriptor for Dictionary)
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToDictionary;
        }

        else if (v21 == &nominal type descriptor for Set)
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToSet;
        }

        else
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToStruct;
        }

        break;
      case 513:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToEnum;
        break;
      case 514:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToOptional;
        break;
      case 515:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToForeignClass;
        break;
      default:
        if (v16) {
          goto LABEL_141;
        }
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToSwiftClass;
        break;
    }
  }

  else
  {
    switch(v16)
    {
      case 768:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToOpaque;
        break;
      case 769:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToTuple;
        break;
      case 770:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToFunction;
        break;
      case 771:
        int Representation = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a2);
        if (Representation == 2)
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToErrorExistential;
        }

        else if (Representation == 1)
        {
          uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToClassExistential;
        }

        else
        {
          if (Representation) {
LABEL_141:
          }
            abort();
          if (*(_DWORD *)(a2 + 12)) {
            uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToConstrainedOpaqueExistential;
          }
          else {
            uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToUnconstrainedOpaqueExistential;
          }
        }

        break;
      case 772:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToMetatype;
        break;
      case 773:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToObjectiveCClass;
        break;
      case 774:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToExistentialMetatype;
        break;
      case 775:
        uint64_t v18 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t, unint64_t *, void *, uint64_t, uint64_t))tryCastToExtendedExistential;
        break;
      default:
        goto LABEL_141;
    }
  }

  uint64_t v78 = a1;
  uint64_t v20 = v18(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)v20)
  {
    if (isa > 770)
    {
      switch(isa)
      {
        case 771:
          goto LABEL_61;
        case 773:
          goto LABEL_52;
        case 774:
          unint64_t MetatypeMetadata = swift_getMetatypeMetadata(*a3);
          *a6 = MetatypeMetadata;
          uint64_t v28 = v78;
          uint64_t v29 = a2;
          int32x4_t v30 = a3;
          uint8x16_t v31 = a5;
          uint8x16_t v32 = a6;
          uint64_t v33 = a7;
          goto LABEL_86;
        case 775:
          switch(**(_BYTE **)(a4 + 8))
          {
            case 0:
              uint64_t v47 = a3[3];
              int32x4_t v30 = swift::TargetOpaqueExistentialContainer<swift::InProcess>::projectValue(a3);
              goto LABEL_81;
            case 1:
              unint64_t ObjectType = swift_getObjectType(*a3);
              goto LABEL_80;
            case 2:
              unint64_t ObjectType = swift_getMetatypeMetadata(*a3);
LABEL_80:
              uint64_t v47 = ObjectType;
              int32x4_t v30 = a3;
              goto LABEL_81;
            case 3:
              goto LABEL_141;
            default:
              int32x4_t v30 = 0LL;
              uint64_t v47 = 0LL;
LABEL_81:
              *a6 = v47;
              if (v30 == a3) {
                uint64_t v33 = a7;
              }
              else {
                uint64_t v33 = 0LL;
              }
              uint64_t v28 = v78;
              uint64_t v29 = a2;
              unint64_t MetatypeMetadata = v47;
              break;
          }

          goto LABEL_85;
        default:
          goto LABEL_87;
      }
    }

    if (isa)
    {
      if (isa == 512)
      {
        if (*(StructDescriptor **)(a4 + 8) == &nominal type descriptor for AnyHashable
          && (_swift_anyHashableDownCastConditionalIndirect((uint64_t)a3, v78, a2, (uint64_t)v25) & 1) != 0)
        {
          return 1LL;
        }

        goto LABEL_87;
      }

      if (isa != 515) {
        goto LABEL_87;
      }
    }

uint64_t getNonNullSrcObject(uint64_t *a1, Class cls, const char *a3, char *a4)
{
  uint64_t v4 = *a1;
  if (!*a1)
  {
    swift::nameForMetadata(&v17, (uint64_t)cls, 1, a3, a4);
    uint64_t v10 = swift::nameForMetadata(&__p, (uint64_t)a3, 1, v8, v9);
    int v11 = (swift *)swift::runtime::bincompat::useLegacyProtocolConformanceReverseIteration((swift::runtime::bincompat *)v10);
    if ((v17.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v14 = &v17;
    }
    else {
      uint64_t v14 = (std::string *)v17.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (!(_DWORD)v11) {
      swift::fatalError( v11,  "Found a null pointer in a value of type '%s' (%p). Non-Optional values are not allowed to hold null pointers. (D etected while casting to '%s' (%p))%s\n",  v12,  v13,  v14,  cls,  p_p,  a3,  "");
    }
    swift::warning( 0LL,  "Found a null pointer in a value of type '%s' (%p). Non-Optional values are not allowed to hold null pointers. (Det ected while casting to '%s' (%p))%s\n",  v12,  v13,  v14,  cls,  p_p,  a3,  ": Continuing with null object, but expect problems later.");
  }

  return v4;
}

uint64_t tryCastFromClassToObjCBridgeable( uint64_t a1, const char *a2, uint64_t *a3, objc_class *a4, unint64_t *a5, int a6)
{
  uint64_t v12 = (const char *)swift_conformsToProtocolCommon( (uint64_t)a2,  (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
  if (!v12) {
    return 0LL;
  }
  int v13 = v12;
  uint64_t v14 = **(int **)v12;
  unint64_t v15 = (v14 & 0xFFFFFFFFFFFFFFFELL) + *(void *)v12;
  if ((v14 & 1) != 0) {
    unint64_t v15 = *(void *)v15;
  }
  unint64_t v16 = v15 + 12LL * *(unsigned int *)(v15 + 12);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, v12, (uint64_t)a2, v16 + 16, (_DWORD *)(v16 + 24));
  uint64_t NonNullSrcObject = getNonNullSrcObject(a3, a4, a2, v18);
  if (NonNullSrcObject
    && (uint64_t v20 = NonNullSrcObject, swift_dynamicCastUnknownClass(NonNullSrcObject, AssociatedTypeWitness)))
  {
    uint64_t v21 = *((void *)a2 - 1);
    if (*(void *)(v21 + 72) >= 0x19uLL)
    {
      uint64_t v22 = (uint64_t *)swift_slowAlloc(*(void *)(v21 + 64) + 1LL, *(unsigned __int8 *)(v21 + 80));
      uint64_t v21 = *((void *)a2 - 1);
      char v23 = v22;
    }

    else
    {
      uint64_t v22 = 0LL;
      char v23 = &v26;
    }

    (*(void (**)(uint64_t *, uint64_t, uint64_t, const char *))(v21 + 56))(v23, 1LL, 1LL, a2);
    if (a6)
    {
      (*((void (**)(uint64_t, uint64_t *, const char *, const char *))v13 + 3))(v20, v23, a2, v13);
    }

    else if (((*((uint64_t (**)(uint64_t, uint64_t *, const char *, const char *))v13 + 4))(v20, v23, a2, v13) & 1) == 0)
    {
      uint64_t v24 = 0LL;
      if (!v22) {
        return v24;
      }
      goto LABEL_15;
    }

    (*(void (**)(uint64_t, uint64_t *, const char *))(*((void *)a2 - 1) + 32LL))(a1, v23, a2);
    uint64_t v24 = 1LL;
    if (v22) {
LABEL_15:
    }
      swift_slowDealloc(v22);
  }

  else
  {
    uint64_t v24 = 0LL;
    *a5 = AssociatedTypeWitness;
  }

  return v24;
}

uint64_t tryCastFromObjCBridgeableToClass(unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_conformsToProtocolCommon(a4, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
  if (result)
  {
    unsigned int v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(a4, result);
    unsigned __int16 v9 = swift_dynamicCastUnknownClass((uint64_t)v8, a2);
    if (v9)
    {
      *a1 = v9;
      return 1LL;
    }

    else
    {
      swift_unknownObjectRelease(v8);
      return 0LL;
    }
  }

  return result;
}

uint64_t tryCastToClassExistentialViaSwiftValue( char **a1, uint64_t a2, unint64_t **a3, uint64_t *a4, int a5)
{
  uint64_t result = 0LL;
  uint64_t v11 = *a4;
  if ((int)v11 <= 771)
  {
    if (!(_DWORD)v11 || (_DWORD)v11 == 515) {
      return result;
    }
    goto LABEL_14;
  }

  if ((_DWORD)v11 != 773)
  {
    if ((_DWORD)v11 != 772) {
      goto LABEL_14;
    }
    uint64_t result = 0LL;
    unint64_t v12 = **a3;
    if (v12 > 0x7FF) {
      LODWORD(v12) = 0;
    }
    if ((_DWORD)v12 && (_DWORD)v12 != 515 && (_DWORD)v12 != 773)
    {
LABEL_14:
      if (!*(_DWORD *)(a2 + 12)
        || (uint64_t result = swift::runtime::bincompat::useLegacyObjCBoxingInCasting(0LL), (_DWORD)result)
        && (uint64_t result = swift::findSwiftValueConformances(a2), (_DWORD)result))
      {
        *a1 = swift::bridgeAnythingToSwiftValueObject((uint64_t)a3, (uint64_t)a4, a5);
        if (a5) {
          return 2LL;
        }
        else {
          return 1LL;
        }
      }
    }
  }

  return result;
}

uint64_t tryCastToSwiftClass( void *a1, const char *a2, uint64_t *a3, Class cls, const char **a5, void *a6, char a7)
{
  Class isa = cls->isa;
  if (cls->isa > (Class)0x7FF) {
    LODWORD(isa) = 0;
  }
  if ((_DWORD)isa != 773 && (_DWORD)isa != 0) {
    return 0LL;
  }
  uint64_t result = getNonNullSrcObject(a3, cls, a2, (char *)cls);
  if (result)
  {
    uint64_t result = swift_dynamicCastClass(result, (uint64_t)a2);
    if (result)
    {
      *a1 = result;
      if ((a7 & 1) != 0)
      {
        return 2LL;
      }

      else
      {
        swift_unknownObjectRetain((id)result, v15, v16, v17);
        return 1LL;
      }
    }

    else
    {
      *a6 = cls;
      *a5 = a2;
    }
  }

  return result;
}

uint64_t tryCastToString( uint64_t a1, const char *a2, uint64_t *a3, objc_class *a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  v8.Class isa = a4->isa;
  if (a4->isa > (Class)0x7FF) {
    LODWORD(v8.isa) = 0;
  }
  if (LODWORD(v8.isa) == 773 || LODWORD(v8.isa) == 515) {
    return ObjCBridgeMemo::tryBridge( tryCastToString(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::memo,  a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8);
  }
  else {
    return 0LL;
  }
}

uint64_t tryCastToAnyHashable(swift *a1, uint64_t a2, const char *a3, uint64_t (***a4)())
{
  int v7 = *a4;
  if ((_DWORD)v7 != 514)
  {
    if ((_DWORD)v7 == 773 || (_DWORD)v7 == 515)
    {
      uint64_t NSStringMetadata = swift::getNSStringMetadata(a1);
      Superclass = (swift *)a4;
      while (Superclass != (swift *)NSStringMetadata)
      {
        Superclass = (swift *)_swift_class_getSuperclass(Superclass);
        if (!Superclass) {
          goto LABEL_13;
        }
      }

      uint64_t NSStringHashableConformance = swift::hashable_support::getNSStringHashableConformance(Superclass);
      if (NSStringHashableConformance)
      {
LABEL_14:
        _swift_convertToAnyHashableIndirect((uint64_t)a3, (uint64_t)a1, a4, NSStringHashableConformance);
        return 1LL;
      }
    }

uint64_t tryCastToArray( __objc2_class ***a1, uint64_t *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (*(void *)a4 != 512LL || *(StructDescriptor **)(a4 + 8) != &nominal type descriptor for Array) {
    return 0LL;
  }
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a4, (uint64_t)a2, a3, (char *)a4);
  std::string v17 = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2, v14, v15, v16);
  uint64_t v18 = (uint64_t *)*GenericArgs;
  uint64_t v19 = (char *)*v17;
  if (a8)
  {
    _swift_arrayDownCastIndirect((unint64_t *)a3, a1, v18, v19);
  }

  else if (!_swift_arrayDownCastConditionalIndirect((unint64_t *)a3, a1, v18, v19))
  {
    return 0LL;
  }

  return 1LL;
}

uint64_t tryCastToDictionary( uint64_t *a1, uint64_t *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (*(void *)a4 != 512LL || *(StructDescriptor **)(a4 + 8) != &nominal type descriptor for Dictionary) {
    return 0LL;
  }
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a4, (uint64_t)a2, a3, (char *)a4);
  std::string v17 = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2, v14, v15, v16);
  uint64_t v18 = (uint64_t *)*GenericArgs;
  uint64_t v19 = (char *)GenericArgs[1];
  uint64_t v20 = (ValueMetadata *)*v17;
  uint64_t v21 = (uint64_t *)v17[1];
  uint64_t v22 = GenericArgs[2];
  uint64_t v23 = v17[2];
  if (a8)
  {
    _swift_dictionaryDownCastIndirect((unint64_t *)a3, a1, v18, v19, v20, v21, v22, v23);
  }

  else if (!_swift_dictionaryDownCastConditionalIndirect( (unint64_t *)a3,  (__objc2_class ***)a1,  v18,  v19,  (uint64_t)v20,  (uint64_t)v21,  v22,  v23))
  {
    return 0LL;
  }

  return 1LL;
}

uint64_t tryCastToSet( uint64_t *a1, uint64_t *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (*(void *)a4 != 512LL || *(StructDescriptor **)(a4 + 8) != &nominal type descriptor for Set) {
    return 0LL;
  }
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a4, (uint64_t)a2, a3, (char *)a4);
  std::string v17 = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2, v14, v15, v16);
  uint64_t v18 = (uint64_t *)*GenericArgs;
  uint64_t v19 = (void *)GenericArgs[1];
  uint64_t v20 = (char *)*v17;
  uint64_t v21 = v17[1];
  if (a8)
  {
    _swift_setDownCastIndirect((unint64_t *)a3, a1, v18, v20, v19, v21);
  }

  else if (!_swift_setDownCastConditionalIndirect((unint64_t *)a3, a1, v18, v20, (uint64_t)v19, v21))
  {
    return 0LL;
  }

  return 1LL;
}

uint64_t tryCastToStruct()
{
  return 0LL;
}

uint64_t tryCastToEnum()
{
  return 0LL;
}

uint64_t tryCastToOptional()
{
  return 0LL;
}

uint64_t tryCastToForeignClass( void *a1, const char *a2, uint64_t *a3, Class cls, uint64_t a5, uint64_t a6, char a7, int a8)
{
  Class isa = cls->isa;
  if (cls->isa > (Class)0x7FF) {
    LODWORD(isa) = 0;
  }
  if (!(_DWORD)isa || (_DWORD)isa == 773 || (uint64_t result = 0LL, (_DWORD)isa == 515))
  {
    uint64_t NonNullSrcObject = getNonNullSrcObject(a3, cls, a2, (char *)cls);
    if (NonNullSrcObject)
    {
      uint64_t result = swift_dynamicCastForeignClass(NonNullSrcObject, (uint64_t)a2);
      if (!result) {
        return result;
      }
      *a1 = result;
      if ((a7 & 1) != 0) {
        return 2LL;
      }
      id v15 = (id)result;
      return 1LL;
    }

    if (a8)
    {
      *a1 = 0LL;
      return 1LL;
    }

    return 0LL;
  }

  return result;
}

uint64_t tryCastToOpaque()
{
  return 0LL;
}

uint64_t tryCastToTuple( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, int a7, unsigned int a8)
{
  *a6 = a4;
  *a5 = a2;
  if (*a4 != 769LL) {
    return 0LL;
  }
  uint64_t v10 = a4[1];
  if (v10 != *(void *)(a2 + 8)) {
    return 0LL;
  }
  uint64_t v14 = (const char *)a4[2];
  id v15 = *(const char **)(a2 + 16);
  if (v14) {
    BOOL v16 = v15 == 0LL;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16 && v14 != v15)
  {
    do
    {
      uint64_t v22 = strchr(v14, 32);
      uint64_t v23 = strchr(v15, 32);
      if (!v22) {
        break;
      }
      uint64_t v24 = v23;
      if (!v23) {
        break;
      }
      if (v22 != v14
        && v23 != v15
        && ((_DWORD)v22 - (_DWORD)v14 != (_DWORD)v23 - (_DWORD)v15
         || strncmp(v14, v15, ((_DWORD)v22 - (_DWORD)v14))))
      {
        return 0LL;
      }

      uint64_t v14 = v22 + 1;
      id v15 = v24 + 1;
    }

    while (v22 != v24);
  }

  if (v10)
  {
    uint64_t v18 = 0LL;
    unsigned int v19 = 1;
    while (a4[2 * v18 + 3] == *(void *)(a2 + 24 + 16 * v18))
    {
      uint64_t v18 = v19++;
      if (v10 == v18) {
        goto LABEL_15;
      }
    }

    uint64_t v25 = v10;
    if (!(_DWORD)v10) {
      return 1LL;
    }
    uint64_t v26 = 0LL;
    char v27 = a4 + 4;
    uint64_t v28 = (void *)(a2 + 32);
    uint64_t v21 = 1LL;
    while (tryCast(a1 + *v28, *(v28 - 1), a3 + *v27, *(v27 - 1), a5, a6, 0LL, a8))
    {
      ++v26;
      v27 += 2;
      v28 += 2;
      if (v25 == v26) {
        return v21;
      }
    }

    if (v26)
    {
      uint64_t v29 = (void *)(a2 + 32);
      uint64_t v21 = 0LL;
      do
      {
        (*(void (**)(uint64_t))(*(void *)(*(v29 - 1) - 8LL) + 8LL))(a1 + *v29);
        v29 += 2;
        --v26;
      }

      while (v26);
      return v21;
    }

    return 0LL;
  }

uint64_t tryCastToFunction(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (*a4 != 770LL) {
    return 0LL;
  }
  unint64_t v7 = a4[1];
  unint64_t v8 = *(void *)(a2 + 8);
  if (((v8 ^ v7) & 0xFFFFFFFFFEFFFFFFLL) != 0 || (v7 & 0x1000000) != 0 && (v8 & 0x1000000) == 0) {
    return 0LL;
  }
  if (a4[2] != *(void *)(a2 + 16)
    || (unsigned __int16)a4[1] != (unint64_t)(unsigned __int16)v8
    || ((v7 >> 25) & 1) != ((v8 >> 25) & 1))
  {
    return 0LL;
  }

  if ((unsigned __int16)a4[1])
  {
    uint64_t v11 = 0LL;
    unint64_t v12 = a4 + 3;
    uint64_t v13 = a2 + 24;
    uint64_t v14 = 8LL * (unsigned __int16)a4[1];
    do
    {
      if (v12[v11] != *(void *)(v13 + v11 * 8)) {
        return 0LL;
      }
      if ((v7 & 0x2000000) != 0)
      {
        int v15 = *(_DWORD *)((char *)v12 + v14);
        if ((v8 & 0x2000000) == 0)
        {
LABEL_17:
          int v16 = 0;
          goto LABEL_18;
        }
      }

      else
      {
        int v15 = 0;
        if ((v8 & 0x2000000) == 0) {
          goto LABEL_17;
        }
      }

      int v16 = *(_DWORD *)(v13 + v14);
LABEL_18:
      if (v15 != v16) {
        return 0LL;
      }
      ++v11;
      v14 += 4LL;
    }

    while ((unsigned __int16)a4[1] != v11);
  }

  uint64_t v17 = 16LL;
  if (a7)
  {
    uint64_t v17 = 32LL;
    uint64_t v9 = 2LL;
  }

  else
  {
    uint64_t v9 = 1LL;
  }

  (*(void (**)(uint64_t, uint64_t, void *))(*(a4 - 1) + v17))(a1, a3, a4);
  return v9;
}

uint64_t tryCastToUnconstrainedOpaqueExistential( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  a1[3] = a4;
  BoxForExistentialIn = swift::TargetMetadata<swift::InProcess>::allocateBoxForExistentialIn(a4, a1);
  uint64_t v11 = 16LL;
  if (a7)
  {
    uint64_t v11 = 32LL;
    uint64_t v12 = 2LL;
  }

  else
  {
    uint64_t v12 = 1LL;
  }

  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(a4 - 8) + v11))(BoxForExistentialIn, a3, a4);
  return v12;
}

uint64_t tryCastToConstrainedOpaqueExistential( void *a1, uint64_t a2, swift::runtime::bincompat **a3, uint64_t *a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v12 = *(_DWORD *)(a2 + 8);
  if ((v12 & 0x40000000) != 0)
  {
    uint64_t v13 = *(uint64_t **)(a2 + 16);
    if (v13)
    {
      if (!swift_dynamicCastMetatype(a4, v13)) {
        return 0LL;
      }
      unsigned int v12 = *(_DWORD *)(a2 + 8);
    }
  }

  if ((v12 & 0x80000000) != 0) {
    goto LABEL_11;
  }
  uint64_t v14 = *a4;
  if (!(_DWORD)v14 || (_DWORD)v14 == 773 || (uint64_t v15 = 0LL, (_DWORD)v14 == 515))
  {
LABEL_11:
    uint64_t v16 = *(unsigned int *)(a2 + 12);
    if ((_DWORD)v16)
    {
      uint64_t v17 = a1 + 4;
      uint64_t v18 = (const char **)(a2 + 8LL * ((v12 >> 30) & 1) + 16);
      uint64_t v19 = 8 * v16;
      do
      {
        uint64_t v20 = *v18;
        if (v17) {
          v17 += (v20 & 1) == 0;
        }
        else {
          uint64_t v17 = 0LL;
        }
        ++v18;
        v19 -= 8LL;
      }

      while (v19);
    }

    a1[3] = a4;
    BoxForExistentialIn = swift::TargetMetadata<swift::InProcess>::allocateBoxForExistentialIn((uint64_t)a4, a1);
    uint64_t v22 = 16LL;
    if (a7)
    {
      uint64_t v22 = 32LL;
      uint64_t v15 = 2LL;
    }

    else
    {
      uint64_t v15 = 1LL;
    }

    (*(void (**)(void *, swift::runtime::bincompat **, uint64_t *))(*(a4 - 1) + v22))( BoxForExistentialIn,  a3,  a4);
  }

  return v15;
}

uint64_t tryCastToClassExistential( swift::runtime::bincompat **a1, uint64_t a2, uint64_t **a3, Class cls, uint64_t a5, uint64_t a6, char a7, int a8)
{
  uint64_t result = 0LL;
  Class isa = cls->isa;
  if (cls->isa > (Class)0x7FF) {
    LODWORD(isa) = 0;
  }
  if ((int)isa > 771)
  {
    if ((_DWORD)isa != 773)
    {
      if ((_DWORD)isa != 772) {
        return result;
      }
      uint64_t v16 = swift_dynamicCastMetatypeToObjectConditional(*a3);
      int v40 = (swift::runtime::bincompat *)v16;
      if (!v16) {
        return 0LL;
      }
      uint64_t v20 = (swift::runtime::bincompat *)v16;
      unsigned int v21 = *(_DWORD *)(a2 + 8);
      if ((v21 & 0x40000000) != 0)
      {
        uint64_t v17 = *(uint64_t **)(a2 + 16);
        if (v17)
        {
          if (!swift_dynamicCastMetatype(v16, v17)) {
            return 0LL;
          }
          unsigned int v21 = *(_DWORD *)(a2 + 8);
        }
      }

      if ((v21 & 0x80000000) != 0) {
        goto LABEL_20;
      }
      uint64_t v22 = *(void *)v20;
      if (*(void *)v20 > 0x7FFuLL) {
        LODWORD(v22) = 0;
      }
      if (!(_DWORD)v22 || (_DWORD)v22 == 773 || (_DWORD)v22 == 515)
      {
LABEL_20:
        uint64_t v23 = *(unsigned int *)(a2 + 12);
        if (!(_DWORD)v23)
        {
LABEL_28:
          *a1 = v20;
          if ((a7 & 1) != 0) {
            return 2LL;
          }
          uint64_t v28 = v20;
LABEL_56:
          swift_unknownObjectRetain(v28, (uint64_t)v17, v18, v19);
          return 1LL;
        }

        uint64_t v24 = (uint64_t *)(a1 + 1);
        uint64_t v25 = (const char **)(a2 + 8LL * ((v21 >> 30) & 1) + 16);
        uint64_t v26 = 8 * v23;
        while (1)
        {
          char v27 = *v25;
          if (v24) {
            v24 += (v27 & 1) == 0;
          }
          else {
            uint64_t v24 = 0LL;
          }
          ++v25;
          v26 -= 8LL;
          if (!v26)
          {
            uint64_t v20 = v40;
            goto LABEL_28;
          }
        }
      }

      return 0LL;
    }

    uint64_t v29 = *a3;
    if ((swift::runtime::bincompat::useLegacyObjCBoxingInCasting(0LL) & 1) == 0
      && swift::getAsSwiftValue((swift *)v29, v30))
    {
      return 0LL;
    }
  }

  else if ((_DWORD)isa && (_DWORD)isa != 515)
  {
    return result;
  }

  uint64_t NonNullSrcObject = getNonNullSrcObject((uint64_t *)a3, cls, (const char *)a2, (char *)cls);
  if (!NonNullSrcObject)
  {
    if (a8)
    {
      *a1 = 0LL;
      return 1LL;
    }

    return 0LL;
  }

  uint8x16_t v32 = (swift::runtime::bincompat *)NonNullSrcObject;
  unsigned int v33 = *(_DWORD *)(a2 + 8);
  if ((v33 & 0x40000000) != 0)
  {
    uint64_t v17 = *(uint64_t **)(a2 + 16);
    if (v17)
    {
      uint64_t result = (uint64_t)swift_dynamicCastMetatype((uint64_t *)cls, v17);
      if (!result) {
        return result;
      }
      unsigned int v33 = *(_DWORD *)(a2 + 8);
    }
  }

  if ((v33 & 0x80000000) != 0) {
    goto LABEL_43;
  }
  Class v34 = cls->isa;
  if (cls->isa > (Class)0x7FF) {
    LODWORD(v34) = 0;
  }
  if (!(_DWORD)v34 || (_DWORD)v34 == 773 || (uint64_t result = 0LL, (_DWORD)v34 == 515))
  {
LABEL_43:
    uint64_t v35 = *(unsigned int *)(a2 + 12);
    if ((_DWORD)v35)
    {
      uint16x8_t v36 = (uint64_t *)(a1 + 1);
      int32x4_t v37 = (const char **)(a2 + 8LL * ((v33 >> 30) & 1) + 16);
      uint64_t v38 = 8 * v35;
      do
      {
        uint64_t v39 = *v37;
        uint64_t result = swift::_conformsToProtocol((swift::runtime::bincompat **)a3, (uint64_t)cls, *v37, v36);
        if (!(_DWORD)result) {
          return result;
        }
        if (v36) {
          v36 += (v39 & 1) == 0;
        }
        else {
          uint16x8_t v36 = 0LL;
        }
        ++v37;
        v38 -= 8LL;
      }

      while (v38);
    }

    *a1 = v32;
    if ((a7 & 1) != 0) {
      return 2LL;
    }
    uint64_t v28 = v32;
    goto LABEL_56;
  }

  return result;
}

uint64_t tryCastToErrorExistential( void *a1, uint64_t a2, swift::runtime::bincompat **a3, uint64_t *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v12 = *a4;
  unsigned int v15 = *(_DWORD *)(a2 + 8);
  if ((v15 & 0x40000000) != 0)
  {
    uint64_t v16 = *(uint64_t **)(a2 + 16);
    if (v16)
    {
      uint64_t result = (uint64_t)swift_dynamicCastMetatype(a4, v16);
      if (!result) {
        return result;
      }
      unsigned int v15 = *(_DWORD *)(a2 + 8);
    }
  }

  if ((v15 & 0x80000000) != 0) {
    goto LABEL_23;
  }
  uint64_t v17 = *a4;
  if (!(_DWORD)v17 || (_DWORD)v17 == 773 || (uint64_t result = 0LL, (_DWORD)v17 == 515))
  {
LABEL_23:
    uint64_t v18 = (const char **)(a2 + 8LL * ((v15 >> 30) & 1) + 16);
    uint64_t v19 = 8LL * *(unsigned int *)(a2 + 12);
    uint64_t v20 = &v24;
    while (1)
    {
      unsigned int v21 = *v18;
      uint64_t result = swift::_conformsToProtocol(a3, (uint64_t)a4, *v18, v20);
      if (!(_DWORD)result) {
        break;
      }
      if (v20) {
        v20 += (v21 & 1) == 0;
      }
      else {
        uint64_t v20 = 0LL;
      }
      ++v18;
      v19 -= 8LL;
      if (!v19)
      {
        uint64_t v22 = _getErrorEmbeddedNSErrorIndirect<A>(_:)((uint64_t)a3, (uint64_t)a4, v24);
        if (v22)
        {
          *a1 = v22;
          return 1LL;
        }

        else
        {
          *a1 = swift_allocError((uint64_t)a4, v24, (uint64_t)a3, a7);
          if (a7) {
            return 2LL;
          }
          else {
            return 1LL;
          }
        }
      }
    }
  }

  return result;
}

uint64_t tryCastToExtendedExistential( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v12 = *(unsigned int **)(a2 + 8);
  unint64_t v13 = *v12;
  if ((v13 & 0x100) != 0)
  {
    unint64_t v14 = *((unsigned __int16 *)v12 + 10);
    unsigned int v15 = (void *)a4;
    if ((v13 & 0x200) == 0) {
      goto LABEL_60;
    }
  }

  else
  {
    unint64_t v14 = 0LL;
    unsigned int v15 = (void *)a4;
    if ((v13 & 0x200) == 0) {
      goto LABEL_60;
    }
  }

  uint64_t v84 = 0LL;
  uint64_t v85 = 0LL;
  uint64_t v86 = 2400LL;
  uint64_t v87 = 0LL;
  char v88 = 0;
  uint64_t v82 = off_189B8E500;
  uint64_t v83 = 0LL;
  uint64_t v123 = 0LL;
  uint64_t v90 = 0LL;
  uint64_t v91 = 0LL;
  uint64_t v89 = 0LL;
  char v92 = 0;
  __int128 v104 = 0u;
  __int128 v105 = 0u;
  __int128 v106 = 0u;
  __int128 v107 = 0u;
  __int128 v108 = 0u;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  __int128 v113 = 0u;
  __int128 v114 = 0u;
  __int128 v115 = 0u;
  __int128 v116 = 0u;
  __int128 v117 = 0u;
  __int128 v118 = 0u;
  __int128 v119 = 0u;
  __int128 v120 = 0u;
  __int128 v93 = 0u;
  __int128 v94 = 0u;
  __int128 v95 = 0u;
  __int128 v96 = 0u;
  __int128 v97 = 0u;
  __int128 v98 = 0u;
  __int128 v99 = 0u;
  __int128 v100 = 0u;
  __int128 v101 = 0u;
  __int128 v102 = 0u;
  __int128 v103 = 0u;
  int v121 = 0;
  uint64_t v16 = (const char *)(((unint64_t)&v12[2 * ((v13 >> 8) & 1) + 4] + 3) & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v17 = *(int *)v16;
  uint64_t v18 = (uint64_t)&v16[v17];
  if (&v16[v17]) {
    size_t v19 = strlen(&v16[v17]);
  }
  else {
    size_t v19 = 0LL;
  }
  unint64_t v81 = 0LL;
  unint64_t v20 = swift::Demangle::__runtime::Demangler::demangleType((uint64_t)&v82, v18, v19, v80);
  unsigned int v21 = v81;
  if (v81 == v80)
  {
    uint64_t v22 = 4LL;
    unsigned int v21 = v80;
    goto LABEL_12;
  }

  if (v81)
  {
    uint64_t v22 = 5LL;
LABEL_12:
    (*(void (**)(void))(*v21 + 8 * v22))();
  }

  if (!v20)
  {
    unsigned int v15 = (void *)a4;
    goto LABEL_52;
  }

  if (*(_WORD *)(v20 + 16) != 232)
  {
    LODWORD(v2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = 0;
    unsigned int v15 = (void *)a4;
    goto LABEL_52;
  }

  unsigned int v15 = (void *)a4;
  while (1)
  {
    int v24 = *(unsigned __int8 *)(v20 + 18);
    unsigned int v25 = v24 - 1;
    uint64_t v26 = (uint64_t *)v20;
    if ((v24 - 1) >= 2)
    {
      if (v24 != 5) {
        goto LABEL_51;
      }
      if (!*(_DWORD *)(v20 + 8)) {
        goto LABEL_48;
      }
      uint64_t v26 = *(uint64_t **)v20;
    }

    if (*(_WORD *)(*v26 + 16) != 145) {
      break;
    }
    char v27 = (uint64_t *)v20;
    if (v25 >= 2)
    {
      if (v24 != 5 || !*(_DWORD *)(v20 + 8))
      {
        uint64_t v28 = 0LL;
        goto LABEL_31;
      }

      char v27 = *(uint64_t **)v20;
    }

    uint64_t v28 = *v27;
LABEL_31:
    int v29 = *(unsigned __int8 *)(v28 + 18);
    if (*v15 != 772LL) {
      goto LABEL_51;
    }
    if (v25 < 2) {
      goto LABEL_39;
    }
    if (v24 == 5 && *(_DWORD *)(v20 + 8))
    {
      unint64_t v20 = *(void *)v20;
LABEL_39:
      unint64_t v23 = *(void *)v20;
      goto LABEL_41;
    }

    unint64_t v23 = 0LL;
LABEL_41:
    int v30 = *(unsigned __int8 *)(v23 + 18);
    if ((v30 - 1) >= 2)
    {
      if (v30 != 5 || !*(_DWORD *)(v23 + 8))
      {
        unint64_t v20 = 0LL;
        goto LABEL_19;
      }

      unint64_t v23 = *(void *)v23;
    }

    unint64_t v20 = *(void *)v23;
LABEL_19:
    unsigned int v15 = (void *)v15[1];
    if (*(_WORD *)(v20 + 16) != 232) {
      goto LABEL_51;
    }
  }

  if (v25 < 2)
  {
LABEL_50:
    LODWORD(v2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = *(unsigned __int16 *)(*(void *)v20 + 16LL) == 38;
    goto LABEL_52;
  }

  if (v24 == 5)
  {
LABEL_48:
    if (*(_DWORD *)(v20 + 8))
    {
      unint64_t v20 = *(void *)v20;
      goto LABEL_50;
    }
  }

void *tryCastToMetatype( uint64_t **a1, uint64_t a2, uint64_t *a3, Class cls, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  Class isa = cls->isa;
  if (cls->isa > (Class)0x7FF) {
    LODWORD(isa) = 0;
  }
  if (!(_DWORD)isa || (_DWORD)isa == 773)
  {
    uint64_t result = (void *)getNonNullSrcObject(a3, cls, (const char *)a2, (char *)cls);
    if (result)
    {
      unint64_t v17 = (unint64_t)result;
      Class = object_getClass(result);
      if (class_isMetaClass(Class)
        && (ObjCClassMetadata = swift_getObjCClassMetadata(v17), (unint64_t v21 = ObjCClassMetadata) != 0))
      {
        unint64_t MetatypeMetadata = swift_getMetatypeMetadata(ObjCClassMetadata);
        return (void *)tryCast(a1, a2, &v21, MetatypeMetadata, a5, a6, a7, a8);
      }

      else
      {
        return 0LL;
      }
    }
  }

  else
  {
    uint64_t result = 0LL;
    if ((_DWORD)isa == 772)
    {
      uint64_t v16 = swift_dynamicCastMetatype((uint64_t *)*a3, *(uint64_t **)(a2 + 8));
      if (v16) {
        *a1 = v16;
      }
      return (void *)(v16 != 0LL);
    }
  }

  return result;
}

uint64_t tryCastToObjectiveCClass( void *a1, uint64_t a2, uint64_t *a3, Class cls, uint64_t a5, uint64_t a6, char a7, int a8)
{
  Class isa = cls->isa;
  if (cls->isa > (Class)0x7FF) {
    LODWORD(isa) = 0;
  }
  if (!(_DWORD)isa || (_DWORD)isa == 773 || (uint64_t result = 0LL, (_DWORD)isa == 515))
  {
    uint64_t NonNullSrcObject = (void *)getNonNullSrcObject(a3, cls, (const char *)a2, (char *)cls);
    if (NonNullSrcObject)
    {
      uint64_t result = (uint64_t)swift_dynamicCastObjCClass(NonNullSrcObject, *(void *)(a2 + 8));
      if (!result) {
        return result;
      }
      *a1 = result;
      if ((a7 & 1) != 0) {
        return 2LL;
      }
      id v15 = (id)result;
      return 1LL;
    }

    if (a8)
    {
      *a1 = 0LL;
      return 1LL;
    }

    return 0LL;
  }

  return result;
}

uint64_t tryCastToExistentialMetatype(uint64_t **a1, const char *a2, uint64_t *a3, Class cls)
{
  Class isa = cls->isa;
  if (cls->isa > (Class)0x7FF) {
    LODWORD(isa) = 0;
  }
  if ((_DWORD)isa == 773)
  {
    uint64_t NonNullSrcObject = (void *)getNonNullSrcObject(a3, cls, a2, (char *)cls);
    if (NonNullSrcObject)
    {
      unint64_t v10 = (unint64_t)NonNullSrcObject;
      Class = object_getClass(NonNullSrcObject);
      if (class_isMetaClass(Class))
      {
        unint64_t ObjCClassMetadata = swift_getObjCClassMetadata(v10);
        if (ObjCClassMetadata)
        {
          unint64_t v7 = (uint64_t *)ObjCClassMetadata;
          return _dynamicCastMetatypeToExistentialMetatype(a1, (uint64_t)a2, v7);
        }
      }
    }
  }

  else if ((_DWORD)isa == 772)
  {
    unint64_t v7 = (uint64_t *)*a3;
    return _dynamicCastMetatypeToExistentialMetatype(a1, (uint64_t)a2, v7);
  }

  return 0LL;
}

uint64_t ObjCBridgeMemo::tryBridge( uint64_t *a1, uint64_t a2, const char *a3, uint64_t *a4, objc_class *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v24[0] = a3;
  v24[1] = a1;
  swift_once( a1 + 3,  (dispatch_function_t)ObjCBridgeMemo::tryBridge(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::{lambda(void *)#1}::__invoke,  v24);
  if (!a1[2]) {
    return 0LL;
  }
  uint64_t NonNullSrcObject = (void *)getNonNullSrcObject(a4, a5, a3, v14);
  if (!NonNullSrcObject) {
    return 0LL;
  }
  uint64_t v16 = NonNullSrcObject;
  Class = object_getClass(NonNullSrcObject);
  while (Class != (objc_class *)a1[2])
  {
    Class = class_getSuperclass(Class);
    if (!Class) {
      return 0LL;
    }
  }

  uint64_t v20 = *a1;
  uint64_t v21 = *((void *)a3 - 1);
  if (*(void *)(v21 + 72) >= 0x19uLL)
  {
    uint64_t v22 = (char *)swift_slowAlloc(*(void *)(v21 + 64) + 1LL, *(unsigned __int8 *)(v21 + 80));
    uint64_t v21 = *((void *)a3 - 1);
    unint64_t v23 = v22;
  }

  else
  {
    uint64_t v22 = 0LL;
    unint64_t v23 = &v25;
  }

  (*(void (**)(char *, uint64_t, uint64_t, const char *))(v21 + 56))(v23, 1LL, 1LL, a3);
  if (a9)
  {
    (*(void (**)(void *, char *, const char *, uint64_t))(v20 + 24))(v16, v23, a3, v20);
    goto LABEL_14;
  }

  if (((*(uint64_t (**)(void *, char *, const char *, uint64_t))(v20 + 32))(v16, v23, a3, v20) & 1) != 0)
  {
LABEL_14:
    (*(void (**)(uint64_t, char *, const char *))(*((void *)a3 - 1) + 32LL))(a2, v23, a3);
    uint64_t v18 = 1LL;
    if (!v22) {
      return v18;
    }
    goto LABEL_17;
  }

  uint64_t v18 = 0LL;
  if (v22) {
LABEL_17:
  }
    swift_slowDealloc(v22);
  return v18;
}

const char *ObjCBridgeMemo::tryBridge(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::{lambda(void *)#1}::__invoke( uint64_t *a1)
{
  uint64_t v2 = (const char **)a1[1];
  uint64_t result = (const char *)swift_conformsToProtocolCommon(*a1, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
  *uint64_t v2 = result;
  if (result)
  {
    uint64_t v4 = **(int **)result;
    unint64_t v5 = (v4 & 0xFFFFFFFFFFFFFFFELL) + *(void *)result;
    if ((v4 & 1) != 0) {
      unint64_t v5 = *(void *)v5;
    }
    unint64_t v6 = v5 + 12LL * *(unsigned int *)(v5 + 12);
    uint64_t result = (const char *)swift_getAssociatedTypeWitness(0LL, result, *a1, v6 + 16, (_DWORD *)(v6 + 24));
    v2[1] = result;
    uint64_t v7 = *(void *)result;
    if (*(void *)result > 0x7FFuLL) {
      LODWORD(v7) = 0;
    }
    if ((_DWORD)v7)
    {
      if ((_DWORD)v7 == 773) {
        uint64_t result = (const char *)*((void *)result + 1);
      }
      else {
        uint64_t result = 0LL;
      }
    }

    void v2[2] = result;
  }

  else
  {
    v2[1] = 0LL;
    void v2[2] = 0LL;
  }

  return result;
}

void *std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0>,void const* ()(unsigned int,unsigned int)>::__clone( uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_189B8B1A0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0>,void const* ()(unsigned int,unsigned int)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_189B8B1A0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0>,void const* ()(unsigned int,unsigned int)>::operator()( uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return swift::SubstGenericParametersFromMetadata::getMetadata( *(swift::SubstGenericParametersFromMetadata **)(a1 + 8),  *a2,  *a3);
}

void *std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1>,void const* ()(unsigned int,unsigned int)>::__clone( uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_189B8B1E8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1>,void const* ()(unsigned int,unsigned int)>::__clone( uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_189B8B1E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1>,void const* ()(unsigned int,unsigned int)>::operator()( uint64_t a1, uint64_t a2, int *a3)
{
  return swift::SubstGenericParametersFromMetadata::getMetadataKeyArgOrdinal( *(swift::SubstGenericParametersFromMetadata **)(a1 + 8),  *a3);
}

void *std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_189B8B230;
  return result;
}

void std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_189B8B230;
}

void std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::operator()()
{
}

uint64_t _dynamicCastMetatypeToExistentialMetatype(uint64_t **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)v5 != 771LL)
  {
    if (*a3 != 772) {
      return 0LL;
    }
    if (a1) {
      *a1 = a3;
    }
    while (1)
    {
      uint64_t v3 = (uint64_t *)v3[1];
      uint64_t v5 = *(void *)(v5 + 8);
      if (*(void *)v5 == 771LL) {
        break;
      }
      if (*v3 != 772) {
        return 0LL;
      }
    }

    uint64_t v4 = 0LL;
  }

  if (v4) {
    uint64_t v7 = (uint64_t *)(v4 + 1);
  }
  else {
    uint64_t v7 = 0LL;
  }
  unsigned int v8 = *(_DWORD *)(v5 + 8);
  if ((v8 & 0x40000000) != 0)
  {
    uint64_t v9 = *(uint64_t **)(v5 + 16);
    if (v9)
    {
      uint64_t result = (uint64_t)swift_dynamicCastMetatype(v3, v9);
      if (!result) {
        return result;
      }
      unsigned int v8 = *(_DWORD *)(v5 + 8);
    }
  }

  if ((v8 & 0x80000000) != 0) {
    goto LABEL_22;
  }
  uint64_t v10 = *v3;
  if (!(_DWORD)v10 || (_DWORD)v10 == 773 || (uint64_t result = 0LL, (_DWORD)v10 == 515))
  {
LABEL_22:
    uint64_t v11 = *(unsigned int *)(v5 + 12);
    if ((_DWORD)v11)
    {
      uint64_t v12 = (const char **)(v5 + 8LL * ((v8 >> 30) & 1) + 16);
      uint64_t v13 = 8 * v11;
      while (1)
      {
        unint64_t v14 = *v12;
        uint64_t result = swift::_conformsToProtocol(0LL, (uint64_t)v3, *v12, v7);
        if (!(_DWORD)result) {
          break;
        }
        if (v7) {
          v7 += (v14 & 1) == 0;
        }
        else {
          uint64_t v7 = 0LL;
        }
        ++v12;
        v13 -= 8LL;
        if (!v13) {
          goto LABEL_29;
        }
      }
    }

    else
    {
LABEL_29:
      if (v4) {
        __swift::__runtime::llvm *v4 = v3;
      }
      return 1LL;
    }
  }

  return result;
}

uint64_t initializeToNilAtDepth(uint64_t a1, uint64_t *a2, const char *a3, char *a4)
{
  int v4 = (int)a3;
  uint64_t v6 = *swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2, (uint64_t)a2, a3, a4);
  if (v4 <= 0)
  {
    uint64_t v7 = 1LL;
  }

  else
  {
    initializeToNilAtDepth(a1, v6, (v4 - 1));
    uint64_t v7 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56LL))(a1, v7, 1LL, v6);
}

__n128 swift_initEnumMetadataSingleCase(uint64_t a1, __int16 a2, __n128 *a3, char *a4)
{
  uint64_t v5 = *(swift::MetadataAllocator **)(a1 - 8);
  if ((a2 & 0x100) == 0)
  {
    Metadata = swift::allocateMetadata(0x70uLL, (const char *)8, (unint64_t)a3, a4);
    __int128 v9 = *((_OWORD *)v5 + 1);
    __int128 v8 = *((_OWORD *)v5 + 2);
    *(_OWORD *)Metadata = *(_OWORD *)v5;
    *((_OWORD *)Metadata + 1) = v9;
    *((_OWORD *)Metadata + 2) = v8;
    __int128 v10 = *((_OWORD *)v5 + 6);
    __int128 v12 = *((_OWORD *)v5 + 3);
    __int128 v11 = *((_OWORD *)v5 + 4);
    *((_OWORD *)Metadata + 5) = *((_OWORD *)v5 + 5);
    *((_OWORD *)Metadata + 6) = v10;
    *((_OWORD *)Metadata + 3) = v12;
    *((_OWORD *)Metadata + 4) = v11;
    *(void *)(a1 - 8) = Metadata;
    uint64_t v5 = Metadata;
  }

  unsigned __int32 v13 = a3[1].n128_u32[1];
  int v14 = a3[1].n128_u32[0] | 0x200000;
  __n128 result = *a3;
  *((__n128 *)v5 + 4) = *a3;
  *((_DWORD *)v5 + 2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v14;
  *((_DWORD *)v5 + 21) = v13;
  return result;
}

double swift_initEnumMetadataSingleCaseWithLayoutString( uint64_t *a1, __int16 a2, unint64_t *a3, char *a4)
{
  uint64_t v6 = *(a3 - 1);
  uint64_t v7 = *(a1 - 1);
  if ((a2 & 0x100) == 0)
  {
    Metadata = swift::allocateMetadata(0x70uLL, (const char *)8, (unint64_t)a3, a4);
    __int128 v10 = *(_OWORD *)(v7 + 16);
    __int128 v9 = *(_OWORD *)(v7 + 32);
    *(_OWORD *)Metadata = *(_OWORD *)v7;
    *((_OWORD *)Metadata + 1) = v10;
    *((_OWORD *)Metadata + 2) = v9;
    __int128 v11 = *(_OWORD *)(v7 + 96);
    __int128 v13 = *(_OWORD *)(v7 + 48);
    __int128 v12 = *(_OWORD *)(v7 + 64);
    *((_OWORD *)Metadata + 5) = *(_OWORD *)(v7 + 80);
    *((_OWORD *)Metadata + 6) = v11;
    *((_OWORD *)Metadata + 3) = v13;
    *((_OWORD *)Metadata + 4) = v12;
    *(a1 - 1) = (uint64_t)Metadata;
    uint64_t v7 = (uint64_t)Metadata;
  }

  __int128 v26 = *(_OWORD *)(v6 + 64);
  int v14 = *(_DWORD *)(v6 + 84);
  LODWORD(v27) = *(_DWORD *)(v6 + 80) | 0x200000;
  HIDWORD(v27) = v14;
  uint64_t v15 = _swift_refCountBytesForMetatype((uint64_t)a3);
  LOWORD(v24) = 26;
  unint64_t v17 = swift::MetadataAllocator::Allocate( (swift::MetadataAllocator *)&v24,  (v15 + 31) & 0xFFFFFFFFFFFFFFF8LL,  (const char *)1,  v16);
  *((void *)v17 + 1) = v15;
  int v24 = v17;
  uint64_t v25 = 16LL;
  unint64_t v22 = 0LL;
  unint64_t v23 = 0LL;
  uint64_t v21 = 0LL;
  _swift_addRefCountStringForMetatype((uint64_t *)&v24, &v21, a3, &v23, &v22);
  v24[(unint64_t)v25 / 8] = v22;
  uint64_t v25 = 0LL;
  *int v24 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  v25 += 8LL;
  *(void *)(v7 + 8) = swift_generic_destroy;
  *(void *)(v7 + 16) = swift_generic_initWithCopy;
  *(void *)(v7 + 24) = swift_generic_assignWithCopy;
  *(void *)(v7 + 32) = swift_generic_initWithTake;
  *(void *)(v7 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = swift_generic_assignWithTake;
  swift::installCommonValueWitnesses((uint64_t)&v26, v7);
  uint64_t v18 = *a1;
  if (!(_DWORD)v18 || (_DWORD)v18 == 773 || (_DWORD)v18 == 515) {
    size_t v19 = (swift::MetadataAllocator **)(a1 - 3);
  }
  else {
    size_t v19 = (swift::MetadataAllocator **)(a1 - 2);
  }
  *size_t v19 = v17;
  *(_OWORD *)(v7 + 64) = v26;
  double result = v27;
  *(double *)(v7 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v27;
  return result;
}

double swift_initEnumMetadataSinglePayload(uint64_t a1, __int16 a2, unint64_t a3, char *a4)
{
  unint64_t v6 = *(void *)a3;
  unsigned int v7 = *(_DWORD *)(a3 + 20);
  unsigned int v8 = v7 - (_DWORD)a4;
  if (v7 < a4)
  {
    if (v6 <= 3)
    {
      unsigned int v10 = ((a4 - v7 + ~(-1 << (8 * v6))) >> (8 * v6)) + 1;
      if (v10 >= 2)
      {
        uint64_t v11 = 4LL;
        if (v10 < 0x10000) {
          uint64_t v11 = 2LL;
        }
        if (v10 >= 0x100) {
          uint64_t v9 = v11;
        }
        else {
          uint64_t v9 = 1LL;
        }
      }

      else
      {
        uint64_t v9 = 0LL;
      }
    }

    else
    {
      uint64_t v9 = 1LL;
    }

    unsigned int v8 = 0;
    v6 += v9;
  }

  __int128 v12 = *(double **)(a1 - 8);
  if ((a2 & 0x100) == 0)
  {
    Metadata = swift::allocateMetadata(0x70uLL, (const char *)8, a3, a4);
    __int128 v15 = *((_OWORD *)v12 + 1);
    __int128 v14 = *((_OWORD *)v12 + 2);
    *(_OWORD *)Metadata = *(_OWORD *)v12;
    *((_OWORD *)Metadata + 1) = v15;
    *((_OWORD *)Metadata + 2) = v14;
    __int128 v16 = *((_OWORD *)v12 + 6);
    __int128 v18 = *((_OWORD *)v12 + 3);
    __int128 v17 = *((_OWORD *)v12 + 4);
    *((_OWORD *)Metadata + 5) = *((_OWORD *)v12 + 5);
    *((_OWORD *)Metadata + 6) = v16;
    *((_OWORD *)Metadata + 3) = v18;
    *((_OWORD *)Metadata + 4) = v17;
    *(void *)(a1 - 8) = Metadata;
    __int128 v12 = (double *)Metadata;
  }

  int v19 = *(_DWORD *)(a3 + 16);
  unint64_t v20 = v19 + 1LL;
  BOOL v22 = (v19 & 0x100000) != 0 || v6 >= 0x19 || v19 >= 8u;
  unsigned int v23 = v19 & 0xFFFDFFFF;
  if (v22) {
    int v24 = 0x20000;
  }
  else {
    int v24 = 0;
  }
  LODWORD(v28) = v23 | v24 | 0x200000;
  HIDWORD(v28) = v8;
  unint64_t v25 = (v6 + v20 - 1) / v20 * v20;
  if (v25 <= 1) {
    unint64_t v25 = 1LL;
  }
  *(void *)&__int128 v27 = v6;
  *((void *)&v27 + 1) = v25;
  swift::installCommonValueWitnesses((uint64_t)&v27, (uint64_t)v12);
  *((_OWORD *)v12 + 4) = v27;
  double result = v28;
  v12[10] = v28;
  return result;
}

double swift_initEnumMetadataSinglePayloadWithLayoutString( uint64_t *a1, __int16 a2, unint64_t *a3, char *a4)
{
  int v4 = (int)a4;
  uint64_t v7 = *(a3 - 1);
  unint64_t v8 = *(void *)(v7 + 64);
  unsigned int v9 = *(_DWORD *)(v7 + 84);
  unsigned int v10 = v9 - (_DWORD)a4;
  if (v9 >= a4)
  {
    LODWORD(v11) = 0;
    unint64_t v12 = *(void *)(v7 + 64);
    uint64_t v13 = *(a1 - 1);
    if ((a2 & 0x100) == 0)
    {
LABEL_14:
      Metadata = swift::allocateMetadata(0x70uLL, (const char *)8, (unint64_t)a3, a4);
      __int128 v17 = *(_OWORD *)v13;
      __int128 v18 = *(_OWORD *)(v13 + 32);
      *((_OWORD *)Metadata + 1) = *(_OWORD *)(v13 + 16);
      *((_OWORD *)Metadata + 2) = v18;
      *(_OWORD *)Metadata = v17;
      __int128 v19 = *(_OWORD *)(v13 + 48);
      __int128 v20 = *(_OWORD *)(v13 + 64);
      __int128 v21 = *(_OWORD *)(v13 + 96);
      *((_OWORD *)Metadata + 5) = *(_OWORD *)(v13 + 80);
      *((_OWORD *)Metadata + 6) = v21;
      *((_OWORD *)Metadata + 3) = v19;
      *((_OWORD *)Metadata + 4) = v20;
      *(a1 - 1) = (uint64_t)Metadata;
      unsigned int v9 = *(_DWORD *)(*(a3 - 1) + 84);
      uint64_t v13 = (uint64_t)Metadata;
    }
  }

  else
  {
    if (v8 <= 3)
    {
      unsigned int v14 = ((a4 - v9 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (v14 >= 2)
      {
        uint64_t v15 = 4LL;
        if (v14 < 0x10000) {
          uint64_t v15 = 2LL;
        }
        if (v14 >= 0x100) {
          uint64_t v11 = v15;
        }
        else {
          uint64_t v11 = 1LL;
        }
      }

      else
      {
        uint64_t v11 = 0LL;
      }
    }

    else
    {
      uint64_t v11 = 1LL;
    }

    unsigned int v10 = 0;
    unint64_t v12 = v11 + v8;
    uint64_t v13 = *(a1 - 1);
    if ((a2 & 0x100) == 0) {
      goto LABEL_14;
    }
  }

  int v22 = *(_DWORD *)(v7 + 80);
  unint64_t v23 = v22 + 1LL;
  BOOL v25 = (v22 & 0x100000) != 0 || v12 >= 0x19 || v22 >= 8u;
  unsigned int v26 = v22 & 0xFFFDFFFF;
  if (v25) {
    int v27 = 0x20000;
  }
  else {
    int v27 = 0;
  }
  LODWORD(v54) = v26 | v27 | 0x200000;
  HIDWORD(v54) = v10;
  unint64_t v28 = (v12 + v23 - 1) / v23 * v23;
  if (v28 <= 1) {
    unint64_t v28 = 1LL;
  }
  *(void *)&__int128 v53 = v12;
  *((void *)&v53 + 1) = v28;
  uint64_t v47 = a1;
  if (v9)
  {
    if (*a3 == 769)
    {
      int v29 = (uint64_t *)(a3 + 3);
      unint64_t v30 = a3[1];
      int v31 = v4;
      if (v30 < 2)
      {
        int v34 = (unint64_t **)(a3 + 3);
      }

      else
      {
        uint64_t v32 = *v29;
        uint64_t v33 = 1LL;
        int v34 = (unint64_t **)(a3 + 3);
        do
        {
          uint64_t v35 = &v29[2 * v33];
          if (*(_DWORD *)(*(void *)(v32 - 8) + 84LL) < *(_DWORD *)(*(void *)(*v35 - 8) + 84LL))
          {
            uint64_t v32 = *v35;
            int v34 = (unint64_t **)&v29[2 * v33];
          }

          ++v33;
        }

        while (v30 != v33);
      }

      unint64_t v36 = *v34;
      int32x4_t v37 = v34[1];
    }

    else
    {
      int v31 = v4;
      int32x4_t v37 = 0LL;
      unint64_t v36 = a3;
    }
  }

  else
  {
    int v31 = v4;
    unint64_t v36 = 0LL;
    int32x4_t v37 = 0LL;
  }

  uint64_t v38 = _swift_refCountBytesForMetatype((uint64_t)a3);
  LOWORD(v51) = 26;
  uint64_t v40 = swift::MetadataAllocator::Allocate( (swift::MetadataAllocator *)&v51,  (v38 + 83) & 0xFFFFFFFFFFFFFFF8LL,  (const char *)1,  v39);
  unint64_t v41 = v40;
  *((void *)v40 + 1) = v38 + 52;
  *((void *)v40 + 2) = 0x1300000000000000LL;
  else {
    uint64_t v42 = v11;
  }
  *((void *)v40 + 3) = (unint64_t)v37 | (v42 << 62);
  *((void *)v40 + 4) = v8;
  *((void *)v40 + 5) = v36;
  *((_DWORD *)v40 + 12) = v31;
  *(void *)((char *)v40 + 52) = v38;
  uint64_t v51 = v40;
  uint64_t v52 = 68LL;
  unint64_t v49 = 0LL;
  unint64_t v50 = 0LL;
  uint64_t v48 = 0LL;
  _swift_addRefCountStringForMetatype((uint64_t *)&v51, &v48, a3, &v50, &v49);
  *(void *)((char *)v51 + v52) = v49 + v11;
  __int16 v43 = (uint64_t *)v51;
  *(void *)((char *)v51 + 6_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v8 - v49;
  uint64_t v52 = 0LL;
  *__int16 v43 = v48 & 0x7FFFFFFFFFFFFFFFLL;
  v52 += 8LL;
  uint64_t v44 = *v47;
  if (!(_DWORD)v44 || (_DWORD)v44 == 773 || (_DWORD)v44 == 515) {
    uint64_t v45 = (swift::MetadataAllocator **)(v47 - 3);
  }
  else {
    uint64_t v45 = (swift::MetadataAllocator **)(v47 - 2);
  }
  *uint64_t v45 = v41;
  *(void *)(v13 + 8) = swift_generic_destroy;
  *(void *)(v13 + 16) = swift_generic_initWithCopy;
  *(void *)(v13 + 24) = swift_generic_assignWithCopy;
  *(void *)(v13 + 32) = swift_generic_initWithTake;
  *(void *)(v13 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = swift_generic_assignWithTake;
  swift::installCommonValueWitnesses((uint64_t)&v53, v13);
  *(_OWORD *)(v13 + 64) = v53;
  double result = v54;
  *(double *)(v13 + 8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  "Swift/SliceBuffer.swift",  23LL,  2,  0x198uLL, 0) = v54;
  return result;
}

uint64_t swift_getEnumTagSinglePayloadGeneric( unsigned __int8 *a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(void))
{
  uint64_t v5 = *(void *)(a3 - 8);
  unsigned int v6 = *(_DWORD *)(v5 + 84);
  unsigned int v7 = a2 - v6;
  if (a2 <= v6) {
    goto LABEL_11;
  }
  unint64_t v8 = *(void *)(v5 + 64);
  if (v8 > 3) {
    goto LABEL_5;
  }
  unsigned int v9 = ((v7 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
  if (v9 < 2) {
    goto LABEL_11;
  }
  if (v9 >= 0x100)
  {
    if (v9 >= 0x10000) {
      int v10 = *(_DWORD *)&a1[v8];
    }
    else {
      int v10 = *(unsigned __int16 *)&a1[v8];
    }
  }

  else
  {
LABEL_5:
    int v10 = a1[v8];
  }

  if (!v10)
  {
LABEL_11:
    if (v6) {
      return a4();
    }
    else {
      return 0LL;
    }
  }

  int v11 = (v10 - 1) << (8 * v8);
  if (v8 > 3) {
    int v11 = 0;
  }
  int v12 = 0;
  switch(v8)
  {
    case 0uLL:
      return v6 + (v12 | v11) + 1;
    case 1uLL:
      int v12 = *a1;
      break;
    case 2uLL:
      int v12 = *(unsigned __int16 *)a1;
      break;
    case 3uLL:
      int v12 = *(unsigned __int16 *)a1 | (a1[2] << 16);
      break;
    default:
      int v12 = *(_DWORD *)a1;
      break;
  }

  return v6 + (v12 | v11) + 1;
}

void swift_storeEnumTagSinglePayloadGeneric( _BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4, void (*a5)(void, void, void, void))
{
}

void swift::storeEnumTagSinglePayloadImpl( _BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, uint64_t a6, void (*a7)(void, void, void, void))
{
  int v11 = &a1[a5];
  if (a3 <= a6)
  {
    if (a2 > a6)
    {
      unsigned int v12 = 0;
      goto LABEL_17;
    }
  }

  else
  {
    if (a5 > 3)
    {
      unsigned int v12 = 1;
      if (a2 <= a6)
      {
LABEL_23:
        switch(v12)
        {
          case 1u:
            *int v11 = 0;
            if ((_DWORD)a2) {
              goto LABEL_42;
            }
            break;
          case 2u:
            *(_WORD *)int v11 = 0;
            if ((_DWORD)a2) {
              goto LABEL_42;
            }
            break;
          case 3u:
            v11[2] = 0;
            *(_WORD *)int v11 = 0;
            goto LABEL_41;
          case 4u:
            *(_DWORD *)int v11 = 0;
            if ((_DWORD)a2) {
              goto LABEL_42;
            }
            break;
          default:
            *(_DWORD *)int v11 = 0;
            __int128 v17 = a7;
            bzero(v11 + 4, v12 - 4LL);
            a7 = v17;
            if ((_DWORD)a2) {
              goto LABEL_42;
            }
            break;
        }

        return;
      }