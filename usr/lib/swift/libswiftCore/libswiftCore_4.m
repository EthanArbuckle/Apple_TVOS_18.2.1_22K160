uint64_t specialized Sequence._copySequenceContents(initializing:)( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 == 1)
      {
        v5 = 1LL;
      }

      else
      {
        a2[1] = a5;
        v5 = 2LL;
        a3 = 2LL;
      }
    }

    else
    {
      v5 = 0LL;
    }
  }

  else
  {
    v5 = 0LL;
    a3 = 0LL;
  }

  *a1 = a4;
  a1[1] = a5;
  a1[2] = v5;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t result, _WORD *a2, uint64_t a3, unsigned int a4)
{
  if (!a2)
  {
    uint64_t v5 = 0LL;
LABEL_13:
    *(_DWORD *)result = a4;
    *(void *)(result + 8) = v5;
    return v5;
  }

  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  if (!a3)
  {
    uint64_t v5 = 0LL;
    goto LABEL_13;
  }

  LOWORD(v4) = a4;
  if (!HIWORD(a4) || (int v4 = (unsigned __int16)((a4 + 67043328) >> 10) + 55296, (v4 & 0x10000) == 0))
  {
    *a2 = v4;
    uint64_t v5 = 1LL;
    if (a3 != 1 && a4 >= 0x10000)
    {
      a2[1] = a4 & 0x3FF | 0xDC00;
      uint64_t v5 = 2LL;
      if (a3 == 2) {
        uint64_t v5 = 2LL;
      }
    }

    goto LABEL_13;
  }

  __break(1u);
  return result;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, _BYTE *a2, uint64_t a3, unsigned int a4)
{
  if (!a2)
  {
    uint64_t v8 = 0LL;
    uint64_t v6 = 0LL;
    goto LABEL_13;
  }

  uint64_t v6 = a3;
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  if (!a3)
  {
    uint64_t v8 = 0LL;
    goto LABEL_13;
  }

  *a2 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 0LL);
  if (a4 >= 0x80)
  {
    if (v6 == 1)
    {
      uint64_t v8 = 1LL;
      goto LABEL_13;
    }

    a2[1] = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 1uLL);
    if (v6 == 2)
    {
      uint64_t v8 = 2LL;
      goto LABEL_13;
    }

    if (a4 >= 0x800)
    {
      a2[2] = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 2uLL);
      if (v6 == 3)
      {
        uint64_t v8 = 3LL;
        goto LABEL_13;
      }

      uint64_t v8 = 3LL;
      if (a4 >= 0x10000)
      {
        a2[3] = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a4, 3uLL);
        uint64_t v8 = v6;
        if (v6 == 4) {
          goto LABEL_13;
        }
        uint64_t v8 = 4LL;
        if (!HIWORD(a4)) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unicode.Scalar.UTF8View index is out of bounds",  46LL,  2,  "Swift/UnicodeScalar.swift",  25LL,  2,  0x1E9uLL,  0);
        }
      }
    }

    else
    {
      uint64_t v8 = 2LL;
    }

    goto LABEL_6;
  }

  uint64_t v8 = 1LL;
  if (v6 != 1) {
LABEL_6:
  }
    uint64_t v6 = v8;
LABEL_13:
  *(_DWORD *)a1 = a4;
  *(void *)(a1 + 8) = v8;
  return v6;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, void *a2, uint64_t a3, unsigned int a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1LL;
      }
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    a3 = 0LL;
  }

  *(_DWORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, void *a2, uint64_t a3, unsigned __int16 a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1LL;
      }
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    a3 = 0LL;
  }

  *(_WORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, void *a2, uint64_t a3, unsigned __int8 a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1LL;
      }
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    a3 = 0LL;
  }

  *(_BYTE *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, void *a2, uint64_t a3, int a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1LL;
      }
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    a3 = 0LL;
  }

  *(_DWORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, void *a2, uint64_t a3, __int16 a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1LL;
      }
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    a3 = 0LL;
  }

  *(_WORD *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, void *a2, uint64_t a3, char a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1LL;
      }
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    a3 = 0LL;
  }

  *(_BYTE *)a1 = a4;
  *(void *)(a1 + 8) = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( int64x2_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v14.i64[0] = a4;
  v14.i64[1] = a4;
  uint64_t v15 = a5;
  uint64_t v16 = a6;
  uint64_t v17 = a7;
  if (a2)
  {
    uint64_t v8 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v10 = 0LL;
      while (1)
      {
        unint64_t v11 = specialized Unicode._InternalNFD.Iterator.next()();
        if ((v11 & 0x1000000000000LL) != 0) {
          break;
        }
        *(_DWORD *)(a2 + 4 * v10++) = v11;
        if (v8 == v10)
        {
          int64x2_t v12 = v14;
          a5 = v15;
          a6 = v16;
          a7 = v17;
          goto LABEL_10;
        }
      }

      int64x2_t v12 = v14;
      a5 = v15;
      a6 = v16;
      a7 = v17;
      a1->i64[0] = (uint64_t)&_swiftEmptyArrayStorage;
      a1->i8[8] = 0;
      uint64_t v8 = v10;
    }

    else
    {
      int64x2_t v12 = vdupq_n_s64(a4);
LABEL_10:
      a1->i64[0] = (uint64_t)&_swiftEmptyArrayStorage;
      a1->i8[8] = 0;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    a1->i64[0] = (uint64_t)&_swiftEmptyArrayStorage;
    a1->i8[8] = 0;
    int64x2_t v12 = vdupq_n_s64(a4);
  }

  a1[1] = v12;
  a1[2].i64[0] = a5;
  a1[2].i64[1] = a6;
  a1[3].i64[0] = a7;
  return v8;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, _DWORD *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v54 = &_swiftEmptyArrayStorage;
  char v55 = 0;
  int v56 = 0;
  char v57 = 1;
  v58.i64[0] = a4;
  v58.i64[1] = a4;
  uint64_t v59 = a5;
  uint64_t v60 = a6;
  uint64_t v61 = a7;
  if (!a2)
  {
    a3 = 0LL;
    *(void *)a1 = &_swiftEmptyArrayStorage;
    *(_BYTE *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_BYTE *)(a1 + 16) = 1;
    *(void *)(a1 + 24) = &_swiftEmptyArrayStorage;
    *(_BYTE *)(a1 + 32) = 0;
    int64x2_t v15 = vdupq_n_s64(a4);
    goto LABEL_8;
  }

  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  char v8 = 1;
  if (!a3)
  {
    int v16 = 0;
    char v17 = 0;
    int64x2_t v15 = vdupq_n_s64(a4);
    v18 = &_swiftEmptyArrayStorage;
    goto LABEL_7;
  }

  v9 = a2;
  BOOL v10 = 0;
  unint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  v13 = &_swiftEmptyArrayStorage;
  char v14 = 1;
  uint64_t v50 = a3;
  while (2)
  {
    unint64_t v22 = (unint64_t)v13[2];
    BOOL v51 = v22 != 0;
    if (v22)
    {
      if (!v10)
      {
        unint64_t v23 = v22 - 1;
        if (v22 <= 1)
        {
          char v55 = 1;
        }

        else
        {
          unsigned int v53 = v11;
          uint64_t v24 = 0LL;
          uint64_t v25 = 8 * v22 + 24;
          uint64_t v26 = 1LL;
          do
          {
            unint64_t v27 = (unint64_t)v13[2];
            if (v26 - 1 >= v27 || v23 >= v27)
            {
              unint64_t v46 = 675LL;
              goto LABEL_81;
            }

            __int16 v47 = WORD2(v13[v24 + 4]);
            int v48 = (int)v13[v24 + 4];
            int v28 = *(_DWORD *)((char *)v13 + v25);
            __int16 v49 = *(_WORD *)((char *)v13 + v25 + 4);
            unint64_t v29 = (unint64_t)v13[2];
            if (v26 - 1 >= v29 || (v30 = &v13[v24], *((_DWORD *)v30 + 8) = v28, *((_WORD *)v30 + 18) = v49, v23 >= v29))
            {
              unint64_t v46 = 688LL;
LABEL_81:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  v46,  0);
            }

            v31 = (char *)v13 + v25;
            *(_DWORD *)v31 = v48;
            *((_WORD *)v31 + 2) = v47;
            --v23;
            v25 -= 8LL;
            ++v24;
          }

          while (v26++ < (uint64_t)v23);
          char v55 = 1;
          unint64_t v11 = v53;
          if (!v13[2]) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x363uLL,  0);
          }
        }
      }

      if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v13))
      {
        v44 = v13[2];
        if (v44)
        {
LABEL_73:
          v45 = (__objc2_class *)((char *)v44 - 1);
          int v21 = (int)v13[(void)v44 - 1 + 4];
          v13[2] = v45;
          v54 = v13;
          unint64_t v20 = v11;
          goto LABEL_12;
        }
      }

      else
      {
        v13 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v13);
        v44 = v13[2];
        if (v44) {
          goto LABEL_73;
        }
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty Array",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x51CuLL,  0);
    }

    unsigned int v52 = v11;
    char v55 = 0;
    unint64_t v33 = specialized Unicode._InternalNFD.Iterator.next()();
    if ((v33 & 0x1000000000000LL) != 0)
    {
      int v56 = 0;
      char v57 = 1;
      if ((v14 & 1) == 0)
      {
        unint64_t v20 = 0LL;
        int v21 = v11;
        char v14 = 1;
        goto LABEL_12;
      }

      int64x2_t v15 = v58;
      a5 = v59;
      a6 = v60;
      a7 = v61;
      *(void *)a1 = v54;
      *(_BYTE *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_BYTE *)(a1 + 16) = 1;
      *(void *)(a1 + 24) = &_swiftEmptyArrayStorage;
      a3 = v12;
      *(_BYTE *)(a1 + 32) = 0;
      goto LABEL_8;
    }

    unint64_t v20 = v33;
    while (1)
    {
      v34 = (char *)v13 + 36;
      if ((v14 & 1) != 0) {
        break;
      }
      __int16 v37 = WORD2(v20);
      v38 = v13[2];
      if (!v38)
      {
        if ((v20 & 0x600000000LL) != 0 && v20 >= 0x300)
        {
          unint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v52, v20);
          if ((v35 & 0x100000000LL) == 0) {
            goto LABEL_30;
          }
          LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
          if ((_DWORD)v35 != -1) {
            goto LABEL_30;
          }
        }

uint64_t specialized Sequence._copySequenceContents(initializing:)( void *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v8 = type metadata accessor for __CocoaDictionary.Iterator();
  uint64_t v12 = swift_allocObject(v8, 0xE8uLL, 7uLL);
  *((_OWORD *)v12 + 1) = 0u;
  *((_OWORD *)v12 + 5) = 0u;
  v12[27] = 0LL;
  v13 = v12 + 27;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + 3) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  *((_OWORD *)v12 + 6) = 0u;
  *((_OWORD *)v12 + 7) = 0u;
  *((_OWORD *)v12 + 8) = 0u;
  *((_OWORD *)v12 + 9) = 0u;
  *((_OWORD *)v12 + 10) = 0u;
  *((_OWORD *)v12 + 11) = 0u;
  *((_OWORD *)v12 + 12) = 0u;
  v12[28] = 0LL;
  v12[26] = a4;
  unint64_t v23 = a1;
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    uint64_t v14 = 0LL;
    if (a3)
    {
      while (1)
      {
        uint64_t v15 = *v13;
        if (*v13 < 0) {
          break;
        }
        if (v15 == v12[28])
        {
          id v16 = objc_msgSend(a4, sel_countByEnumeratingWithState_objects_count_, v12 + 2, v12 + 10, 16);
          v12[28] = v16;
          if (!v16)
          {
            uint64_t *v13 = -1LL;
            break;
          }

          uint64_t v15 = 0LL;
          uint64_t *v13 = 0LL;
        }

        uint64_t v17 = v12[3];
        if (!v17)
        {
          unint64_t v22 = 773LL;
          goto LABEL_22;
        }

        if ((unint64_t)(v15 - 0x1000000000000000LL) >> 61 != 7)
        {
          __break(1u);
LABEL_18:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
        }

        v18 = (void **)(v17 + 8 * v15);
        v19 = *v18;
        uint64_t *v13 = v15 + 1;
        swift_unknownObjectRetain(v19, v9, v10, v11);
        id v20 = objc_msgSend(a4, sel_objectForKey_, v19);
        if (!v20)
        {
          unint64_t v22 = 784LL;
LABEL_22:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  v22,  0);
        }

        ++v14;
        *a2 = v19;
        a2[1] = v20;
        a2 += 2;
        if (a3 == v14)
        {
          uint64_t v14 = a3;
          break;
        }
      }
    }
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  *unint64_t v23 = v12;
  return v14;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( unsigned int *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v4 = 0LL;
      while (a4)
      {
        *(_BYTE *)(a2 + v4) = a4 - 1;
        a4 >>= 8;
        if (a3 == ++v4) {
          goto LABEL_7;
        }
      }
    }

    else
    {
LABEL_7:
      uint64_t v4 = a3;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *a1 = a4;
  return v4;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( unint64_t **a1, unint64_t *a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  if (a5 >= 1)
  {
    unint64_t v5 = *a4;
    if (a2) {
      goto LABEL_3;
    }
LABEL_20:
    uint64_t v6 = 0LL;
    a3 = 0LL;
    goto LABEL_25;
  }

  unint64_t v5 = 0LL;
  if (!a2) {
    goto LABEL_20;
  }
LABEL_3:
  if (a3 < 0) {
    goto LABEL_28;
  }
  uint64_t v6 = 0LL;
  if (a3)
  {
    for (uint64_t i = 0LL; i != a3; ++i)
    {
      if (v5)
      {
        unint64_t v8 = __clz(__rbit64(v5));
        v5 &= v5 - 1;
        unint64_t v9 = v8 | (v6 << 6);
      }

      else
      {
        uint64_t v10 = v6 + 1;
        if (__OFADD__(v6, 1LL)) {
          goto LABEL_27;
        }
        if (v10 >= a5)
        {
          unint64_t v5 = 0LL;
          goto LABEL_24;
        }

        unint64_t v11 = a4[v10];
        if (!v11)
        {
          uint64_t v12 = v6 + 2;
          if (v10 + 1 >= a5)
          {
            unint64_t v5 = 0LL;
            uint64_t v6 = v10;
LABEL_24:
            a3 = i;
            break;
          }

          unint64_t v11 = a4[v12];
          if (!v11)
          {
            while (1)
            {
              uint64_t v10 = v12 + 1;
              if (__OFADD__(v12, 1LL)) {
                break;
              }
              if (v10 >= a5)
              {
                unint64_t v5 = 0LL;
                uint64_t v6 = a5 - 1;
                goto LABEL_24;
              }

              unint64_t v11 = a4[v10];
              ++v12;
              if (v11) {
                goto LABEL_18;
              }
            }

            __break(1u);
LABEL_27:
            __break(1u);
LABEL_28:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
          }

          ++v10;
        }

uint64_t specialized Sequence._copySequenceContents(initializing:)( unint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v4 = 0LL;
      while (a4)
      {
        *(void *)(a2 + 8 * v4) = __clz(__rbit64(a4));
        a4 &= a4 - 1;
        if (a3 == ++v4) {
          goto LABEL_7;
        }
      }
    }

    else
    {
LABEL_7:
      uint64_t v4 = a3;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *a1 = a4;
  return v4;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( unint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      char v5 = 0;
      unint64_t v6 = 0LL;
      while ((HIBYTE(a5) & 0xF) != v6)
      {
        if (v6 >= 8) {
          unint64_t v7 = a5;
        }
        else {
          unint64_t v7 = a4;
        }
        *(_BYTE *)(a2 + v6) = v7 >> (v5 & 0x38);
        v5 += 8;
        if (a3 == ++v6) {
          goto LABEL_13;
        }
      }

      a3 = HIBYTE(a5) & 0xF;
    }
  }

  else
  {
    a3 = 0LL;
  }

uint64_t specialized Sequence._copySequenceContents(initializing:)( void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = type metadata accessor for __CocoaSet.Iterator();
  uint64_t v12 = swift_allocObject(v8, 0xE8uLL, 7uLL);
  *((_OWORD *)v12 + 1) = 0u;
  *((_OWORD *)v12 + 5) = 0u;
  v12[27] = 0LL;
  unint64_t v13 = v12 + 27;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + 3) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  *((_OWORD *)v12 + 6) = 0u;
  *((_OWORD *)v12 + 7) = 0u;
  *((_OWORD *)v12 + 8) = 0u;
  *((_OWORD *)v12 + 9) = 0u;
  *((_OWORD *)v12 + 10) = 0u;
  *((_OWORD *)v12 + 11) = 0u;
  *((_OWORD *)v12 + 12) = 0u;
  v12[28] = 0LL;
  v12[26] = a4;
  if (!a2) {
    goto LABEL_14;
  }
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  if (a3)
  {
    uint64_t v14 = 0LL;
    while (1)
    {
      uint64_t v15 = *v13;
      if (*v13 < 0) {
        break;
      }
      if (v15 == v12[28])
      {
        id v16 = objc_msgSend(a4, sel_countByEnumeratingWithState_objects_count_, v12 + 2, v12 + 10, 16);
        v12[28] = v16;
        if (!v16)
        {
          uint64_t *v13 = -1LL;
          break;
        }

        uint64_t v15 = 0LL;
        uint64_t *v13 = 0LL;
      }

      uint64_t v17 = v12[3];
      if (!v17) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
      }
      if ((unint64_t)(v15 - 0x1000000000000000LL) >> 61 != 7)
      {
        __break(1u);
LABEL_18:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
      }

      v18 = (void **)(v17 + 8 * v15);
      v19 = *v18;
      uint64_t *v13 = v15 + 1;
      *(void *)(a2 + 8 * v14) = v19;
      swift_unknownObjectRetain(v19, v9, v10, v11);
      if (a3 == ++v14)
      {
        uint64_t v14 = a3;
        break;
      }
    }
  }

  else
  {
LABEL_14:
    uint64_t v14 = 0LL;
  }

  *a1 = v12;
  return v14;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( void *a1, unint64_t *a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (a5 + 1 < 64) {
    uint64_t v5 = ~(-1LL << (a5 + 1));
  }
  else {
    uint64_t v5 = -1LL;
  }
  unint64_t v6 = *a4 & v5;
  if (!a2)
  {
    int64_t v8 = 0LL;
    a3 = 0LL;
    goto LABEL_27;
  }

  if (a3 < 0) {
    goto LABEL_30;
  }
  if (!a3)
  {
    int64_t v8 = 0LL;
    goto LABEL_27;
  }

  uint64_t v7 = 0LL;
  int64_t v8 = 0LL;
  int64_t v9 = (unint64_t)(a5 + 64) >> 6;
  while (v6)
  {
    unint64_t v10 = __clz(__rbit64(v6));
    v6 &= v6 - 1;
    unint64_t v11 = v10 | (v8 << 6);
LABEL_9:
    ++v7;
    *a2++ = v11;
    if (v7 == a3) {
      goto LABEL_27;
    }
  }

  int64_t v12 = v8 + 1;
  if (__OFADD__(v8, 1LL)) {
    goto LABEL_29;
  }
  if (v12 >= v9)
  {
    unint64_t v6 = 0LL;
    goto LABEL_26;
  }

  unint64_t v13 = a4[v12];
  if (v13)
  {
LABEL_20:
    unint64_t v15 = __clz(__rbit64(v13));
    unint64_t v6 = (v13 - 1) & v13;
    unint64_t v11 = v15 + (v12 << 6);
    int64_t v8 = v12;
    goto LABEL_9;
  }

  int64_t v14 = v8 + 2;
  if (v12 + 1 < v9)
  {
    unint64_t v13 = a4[v14];
    if (!v13)
    {
      while (1)
      {
        int64_t v12 = v14 + 1;
        if (__OFADD__(v14, 1LL)) {
          break;
        }
        if (v12 >= v9)
        {
          unint64_t v6 = 0LL;
          int64_t v8 = v9 - 1;
          goto LABEL_26;
        }

        unint64_t v13 = a4[v12];
        ++v14;
        if (v13) {
          goto LABEL_20;
        }
      }

      __break(1u);
LABEL_29:
      __break(1u);
LABEL_30:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }

    ++v12;
    goto LABEL_20;
  }

  unint64_t v6 = 0LL;
  int64_t v8 = v12;
LABEL_26:
  a3 = v7;
LABEL_27:
  *a1 = a4;
  a1[1] = a5;
  a1[2] = v8;
  a1[3] = v6;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( unint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      int64_t v12 = a2;
      v19 = a1;
      uint64_t v13 = 0LL;
      v14._rawBits = a4;
      while ((v14._rawBits ^ a5) >= 0x4000)
      {
        ++v13;
        uint64_t v15 = Substring.subscript.getter(v14._rawBits, a4, a5, a6, a7);
        uint64_t v17 = v16;
        v14._rawBits = Substring.index(after:)(v14)._rawBits;
        *int64_t v12 = v15;
        v12[1] = v17;
        v12 += 2;
        if (a3 == v13)
        {
          uint64_t v13 = a3;
          break;
        }
      }

      a1 = v19;
    }

    else
    {
      v14._rawBits = a4;
      uint64_t v13 = 0LL;
    }
  }

  else
  {
    uint64_t v13 = 0LL;
    v14._rawBits = a4;
  }

  *a1 = a4;
  a1[1] = a5;
  a1[2] = a6;
  a1[3] = a7;
  a1[4] = v14._rawBits;
  return v13;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( Swift::String::Index *a1, uint64_t a2, uint64_t a3, Swift::String::Index a4, Swift::UInt64 a5, uint64_t a6, unint64_t a7)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v12 = 0LL;
      Swift::UInt64 v13 = a5 >> 14;
      uint64_t v14 = ((unint64_t)a6 >> 59) & 1;
      if ((a7 & 0x1000000000000000LL) == 0) {
        LOBYTE(v14) = 1;
      }
      uint64_t v15 = 4LL << v14;
      Swift::UInt64 v16 = a4._rawBits >> 14;
      uint64_t v17 = a7 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v18 = (a7 & 0xFFFFFFFFFFFFFFFLL) + 32;
      if ((a7 & 0x2000000000000000LL) != 0) {
        unint64_t v19 = HIBYTE(a7) & 0xF;
      }
      else {
        unint64_t v19 = a6 & 0xFFFFFFFFFFFFLL;
      }
      if ((a7 & 0x2000000000000000LL) != 0) {
        BOOL v20 = (a7 & 0x4000000000000000LL) != 0;
      }
      else {
        BOOL v20 = a6 < 0;
      }
      Swift::UInt64 rawBits = a4._rawBits;
      while (1)
      {
        Swift::UInt64 v22 = rawBits >> 14;
        if (rawBits >> 14 == v13) {
          goto LABEL_64;
        }
        Swift::UInt64 v23 = rawBits;
        if ((rawBits & 0xC) == v15)
        {
          uint64_t v76 = v15;
          uint64_t v83 = a2;
          BOOL v90 = v20;
          unint64_t v97 = v19;
          Swift::UInt64 v105 = a5;
          Swift::UInt64 v63 = v13;
          uint64_t v69 = v17;
          Swift::UInt64 v27 = v16;
          uint64_t v28 = v18;
          v29._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          BOOL v20 = v90;
          unint64_t v19 = v97;
          a5 = v105;
          uint64_t v18 = v28;
          uint64_t v17 = v69;
          uint64_t v15 = v76;
          Swift::UInt64 v16 = v27;
          Swift::UInt64 v13 = v63;
          a2 = v83;
          Swift::UInt64 v23 = v29._rawBits;
          Swift::UInt64 v22 = v29._rawBits >> 14;
          if (v29._rawBits >> 14 < v27) {
LABEL_61:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/Substring.swift",  21LL,  2,  0x33FuLL,  0);
        }

        else if (v22 < v16)
        {
          goto LABEL_61;
        }

        if (v22 >= v13) {
          goto LABEL_61;
        }
        if ((a7 & 0x1000000000000000LL) != 0)
        {
          v30._Swift::UInt64 rawBits = v23;
          uint64_t v77 = v15;
          uint64_t v84 = a2;
          BOOL v91 = v20;
          unint64_t v98 = v19;
          Swift::UInt64 v106 = a5;
          Swift::UInt64 v64 = v13;
          uint64_t v70 = v17;
          Swift::UInt64 v31 = v16;
          uint64_t v33 = v18;
          Swift::UInt16 v32 = String.UTF16View._foreignSubscript(position:)(v30);
          BOOL v20 = v91;
          unint64_t v19 = v98;
          a5 = v106;
          uint64_t v18 = v33;
          uint64_t v17 = v70;
          uint64_t v15 = v77;
          Swift::UInt64 v16 = v31;
          Swift::UInt64 v13 = v64;
          a2 = v84;
          LOWORD(v33) = v32;
          goto LABEL_36;
        }

        if ((v23 & 1) != 0)
        {
          Swift::UInt64 v24 = v23 >> 16;
          if ((a7 & 0x2000000000000000LL) != 0) {
            goto LABEL_29;
          }
        }

        else
        {
          uint64_t v78 = v15;
          uint64_t v85 = a2;
          BOOL v92 = v20;
          unint64_t v99 = v19;
          Swift::UInt64 v107 = a5;
          Swift::UInt64 v65 = v13;
          uint64_t v71 = v17;
          Swift::UInt64 v34 = v16;
          uint64_t v59 = v18;
          v35._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v23)._rawBits;
          BOOL v20 = v92;
          unint64_t v19 = v99;
          a5 = v107;
          uint64_t v18 = v59;
          Swift::UInt64 v13 = v65;
          uint64_t v17 = v71;
          uint64_t v15 = v78;
          Swift::UInt64 v16 = v34;
          a2 = v85;
          Swift::UInt64 v24 = (v35._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1) >> 16;
          if ((a7 & 0x2000000000000000LL) != 0)
          {
LABEL_29:
            uint64_t v113 = a6;
            uint64_t v114 = v17;
            unsigned int v26 = *((unsigned __int8 *)&v113 + v24);
            if (*((char *)&v113 + v24) < 0) {
              __asm { BR              X10 }
            }

            goto LABEL_30;
          }
        }

        uint64_t v25 = (unsigned __int8 *)v18;
        if ((a6 & 0x1000000000000000LL) == 0)
        {
          uint64_t v80 = v15;
          uint64_t v87 = a2;
          unint64_t v102 = v19;
          Swift::UInt64 v110 = a5;
          Swift::UInt64 v67 = v13;
          uint64_t v73 = v17;
          Swift::UInt64 v58 = v16;
          uint64_t v61 = v18;
          BOOL v95 = v20;
          uint64_t v25 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a6, a7);
          BOOL v20 = v95;
          unint64_t v19 = v102;
          a5 = v110;
          Swift::UInt64 v16 = v58;
          uint64_t v18 = v61;
          uint64_t v17 = v73;
          uint64_t v15 = v80;
          Swift::UInt64 v13 = v67;
          a2 = v87;
        }

        unsigned int v26 = v25[v24];
        if ((char)v25[v24] < 0) {
          __asm { BR              X10 }
        }

uint64_t specialized Sequence._copySequenceContents(initializing:)( Swift::UInt64 *a1, uint64_t a2, uint64_t a3, Swift::String::Index a4, Swift::UInt64 a5, unint64_t a6, unint64_t a7)
{
  uint64_t v7 = a7;
  uint64_t v8 = a6;
  Swift::UInt64 rawBits = a4._rawBits;
  if (a2)
  {
    uint64_t v11 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v12 = a2;
      uint64_t v13 = 0LL;
      Swift::UInt64 v14 = a5 >> 14;
      uint64_t v15 = (a6 >> 59) & 1;
      if ((a7 & 0x1000000000000000LL) == 0) {
        LOBYTE(v15) = 1;
      }
      uint64_t v16 = 4LL << v15;
      Swift::UInt64 v17 = a4._rawBits >> 14;
      uint64_t v18 = a7 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v19 = (a7 & 0xFFFFFFFFFFFFFFFLL) + 32;
      BOOL v20 = &unk_181800152;
      if ((a7 & 0x2000000000000000LL) != 0) {
        unint64_t v21 = HIBYTE(a7) & 0xF;
      }
      else {
        unint64_t v21 = a6 & 0xFFFFFFFFFFFFLL;
      }
      v22._Swift::UInt64 rawBits = a4._rawBits;
      Swift::UInt64 v23 = &unk_18180014E;
      while (1)
      {
        Swift::UInt64 v24 = v22._rawBits >> 14;
        if (v22._rawBits >> 14 == v14) {
          goto LABEL_60;
        }
        uint64_t v25 = v22._rawBits & 0xC;
        BOOL v26 = (v22._rawBits & 1) == 0 || v25 == v16;
        int v27 = v26;
        if (v26)
        {
          Swift::UInt64 v28 = v22._rawBits;
          if (v25 == v16)
          {
            Swift::UInt64 v117 = a5;
            unint64_t v125 = v21;
            Swift::UInt64 v37 = v14;
            uint64_t v82 = v16;
            Swift::UInt64 v95 = v17;
            uint64_t v102 = v19;
            uint64_t v109 = v18;
            int v89 = v27;
            Swift::UInt64 v28 = _StringGuts._slowEnsureMatchingEncoding(_:)(v22)._rawBits;
            int v27 = v89;
            Swift::UInt64 v23 = &unk_18180014E;
            a5 = v117;
            unint64_t v21 = v125;
            BOOL v20 = &unk_181800152;
            uint64_t v19 = v102;
            uint64_t v18 = v109;
            Swift::UInt64 v17 = v95;
            uint64_t v16 = v82;
            Swift::UInt64 v14 = v37;
            Swift::UInt64 v24 = v28 >> 14;
            if (v28 >> 14 < v95)
            {
LABEL_62:
              unint64_t v74 = 43LL;
LABEL_63:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v74,  0);
            }
          }

          else if (v24 < v17)
          {
            goto LABEL_62;
          }

          if (v24 >= v14) {
            goto LABEL_62;
          }
          if ((v28 & 1) == 0)
          {
            Swift::UInt64 v115 = a5;
            unint64_t v123 = v21;
            Swift::UInt64 v29 = v14;
            uint64_t v80 = v16;
            Swift::UInt64 v94 = v17;
            uint64_t v100 = v19;
            uint64_t v107 = v18;
            int v88 = v27;
            v30._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v28)._rawBits;
            int v27 = v88;
            Swift::UInt64 v23 = &unk_18180014E;
            a5 = v115;
            unint64_t v21 = v123;
            BOOL v20 = &unk_181800152;
            uint64_t v19 = v100;
            uint64_t v18 = v107;
            Swift::UInt64 v17 = v94;
            uint64_t v16 = v80;
            Swift::UInt64 v14 = v29;
            Swift::UInt64 v28 = v30._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
          }
        }

        else if (v24 < v17 || (Swift::UInt64 v28 = v22._rawBits, v24 >= v14))
        {
          unint64_t v74 = 143LL;
          goto LABEL_63;
        }

        if ((v7 & 0x1000000000000000LL) != 0)
        {
          Swift::UInt64 v118 = a5;
          unint64_t v126 = v21;
          Swift::UInt64 v38 = v14;
          uint64_t v83 = v16;
          Swift::UInt64 v96 = v17;
          uint64_t v103 = v19;
          uint64_t v110 = v18;
          int v90 = v27;
          Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v28 & 0xFFFFFFFFFFFF0000LL))._0._value;
          Swift::UInt64 v23 = &unk_18180014E;
          a5 = v118;
          unint64_t v21 = v126;
          BOOL v20 = &unk_181800152;
          uint64_t v19 = v103;
          uint64_t v18 = v110;
          Swift::UInt64 v17 = v96;
          uint64_t v16 = v83;
          Swift::UInt64 v14 = v38;
          Swift::UInt32 v33 = value;
          if (v90) {
            goto LABEL_35;
          }
        }

        else
        {
          Swift::UInt64 v31 = v28 >> 16;
          if ((v7 & 0x2000000000000000LL) != 0)
          {
            uint64_t v131 = v8;
            uint64_t v132 = v18;
            Swift::UInt32 v33 = *((unsigned __int8 *)&v131 + v31);
            if (*((char *)&v131 + v31) < 0) {
              __asm { BR              X9 }
            }
          }

          else
          {
            Swift::UInt16 v32 = (unsigned __int8 *)v19;
            if ((v8 & 0x1000000000000000LL) == 0)
            {
              Swift::UInt64 v121 = a5;
              unint64_t v129 = v21;
              Swift::UInt64 v78 = v14;
              uint64_t v86 = v16;
              Swift::UInt64 v98 = v17;
              uint64_t v105 = v19;
              uint64_t v113 = v18;
              int v92 = v27;
              Swift::UInt16 v32 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v8, v7);
              int v27 = v92;
              Swift::UInt64 v23 = &unk_18180014E;
              a5 = v121;
              unint64_t v21 = v129;
              BOOL v20 = &unk_181800152;
              uint64_t v19 = v105;
              uint64_t v18 = v113;
              Swift::UInt64 v17 = v98;
              Swift::UInt64 v14 = v78;
              uint64_t v16 = v86;
            }

            Swift::UInt32 v33 = v32[v31];
            if ((char)v32[v31] < 0) {
              __asm { BR              X9 }
            }
          }

          if (v27)
          {
LABEL_35:
            if (v25 == v16)
            {
              v57._Swift::UInt64 rawBits = v22._rawBits;
              Swift::UInt64 v120 = a5;
              Swift::UInt64 v128 = v21;
              Swift::UInt64 v58 = v14;
              uint64_t v85 = v16;
              Swift::UInt64 v59 = v17;
              uint64_t v112 = v18;
              uint64_t v60 = v19;
              Swift::UInt32 v77 = v33;
              v61._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v57)._rawBits;
              Swift::UInt32 v33 = v77;
              Swift::UInt64 v23 = &unk_18180014E;
              a5 = v120;
              unint64_t v21 = v128;
              BOOL v20 = &unk_181800152;
              uint64_t v19 = v60;
              uint64_t v18 = v112;
              Swift::UInt64 v17 = v59;
              uint64_t v16 = v85;
              Swift::UInt64 v14 = v58;
              v22._Swift::UInt64 rawBits = v61._rawBits;
              if (v128 <= v61._rawBits >> 16)
              {
LABEL_66:
                unint64_t v75 = 31LL;
LABEL_67:
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v75,  0);
              }
            }

            else if (v21 <= v22._rawBits >> 16)
            {
              goto LABEL_66;
            }

            if ((v22._rawBits & 1) == 0)
            {
              Swift::UInt64 v116 = a5;
              unint64_t v124 = v21;
              Swift::UInt64 v34 = v14;
              uint64_t v81 = v16;
              Swift::UInt64 v35 = v17;
              uint64_t v101 = v19;
              uint64_t v108 = v18;
              Swift::UInt32 v76 = v33;
              v36._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v22)._rawBits;
              Swift::UInt32 v33 = v76;
              Swift::UInt64 v23 = &unk_18180014E;
              a5 = v116;
              unint64_t v21 = v124;
              BOOL v20 = &unk_181800152;
              uint64_t v19 = v101;
              uint64_t v18 = v108;
              Swift::UInt64 v17 = v35;
              uint64_t v16 = v81;
              Swift::UInt64 v14 = v34;
              v22._Swift::UInt64 rawBits = v22._rawBits & 0xC | v36._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
            }

            goto LABEL_43;
          }
        }

        if (v21 <= v22._rawBits >> 16)
        {
          unint64_t v75 = 121LL;
          goto LABEL_67;
        }

uint64_t specialized Sequence._copySequenceContents(initializing:)( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      *a2 = a4;
      if (a3 != 1) {
        a3 = 1LL;
      }
      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v4 = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    a3 = 0LL;
  }

  *a1 = a4;
  a1[1] = v4;
  return a3;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( char **a1, uint64_t a2, uint64_t a3, char *a4, char *a5)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v5 = 0LL;
      while (a4)
      {
        if (a5 && a4 == a5) {
          goto LABEL_14;
        }
        if (!a5) {
          goto LABEL_17;
        }
        if (a4 >= a5) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x4BAuLL,  0);
        }
        char v6 = *a4++;
        *(_BYTE *)(a2 + v5++) = v6;
        if (a3 == v5) {
          goto LABEL_11;
        }
      }

      if (a5) {
LABEL_17:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x4BAuLL,  0);
    }

    else
    {
LABEL_11:
      uint64_t v5 = a3;
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

uint64_t specialized Sequence._copySequenceContents(initializing:)( void *a1, Swift::String_optional *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6 = HIBYTE(a5) & 0xF;
  uint64_t v12 = a4;
  unint64_t v13 = a5;
  if ((a5 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = a4 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v14 = v6;
  if (a2)
  {
    uint64_t v7 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v8 = a2;
      uint64_t v9 = 0LL;
      while (1)
      {
        Swift::String_optional v10 = String.Iterator.next()();
        if (!v10.value._object) {
          break;
        }
        ++v9;
        *v8++ = v10;
        if (v7 == v9)
        {
          a4 = v12;
          a5 = v13;
          goto LABEL_13;
        }
      }

      a4 = v12;
      a5 = v13;
      uint64_t v7 = v9;
LABEL_13:
      uint64_t v6 = v14;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  *a1 = a4;
  a1[1] = a5;
  a1[2] = 0LL;
  a1[3] = v6;
  return v7;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0x2000000000000000LL) != 0) {
    uint64_t v8 = HIBYTE(a5) & 0xF;
  }
  else {
    uint64_t v8 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (!a2)
  {
    uint64_t v11 = 0LL;
    __int16 v12 = 0;
    uint64_t v9 = 0LL;
    char v16 = 1;
    goto LABEL_31;
  }

  uint64_t v9 = a3;
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  swift_bridgeObjectRetain_n(a5, 3LL, a3, (char *)a4);
  if (!v9)
  {
    uint64_t v11 = 0LL;
    __int16 v12 = 0;
    char v16 = 1;
    goto LABEL_30;
  }

  uint64_t v29 = a1;
  uint64_t v11 = 0LL;
  __int16 v12 = 0;
  uint64_t v13 = 0LL;
  uint64_t v14 = a5 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v15 = (a5 & 0xFFFFFFFFFFFFFFFLL) + 32;
  char v16 = 1;
  while ((v16 & 1) == 0)
  {
    char v16 = 1;
    LOWORD(v17) = v12;
    __int16 v12 = 0;
LABEL_9:
    *(_WORD *)(a2 + 2 * v13++) = v17;
    if (v9 == v13)
    {
      a1 = v29;
      goto LABEL_30;
    }
  }

  if (v11 < v8)
  {
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      uint64_t v20 = v14;
      uint64_t v21 = v15;
      Swift::tuple_Unicode_Scalar_scalarLength_Int v22 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v11 << 16));
      Swift::Int scalarLength = v22.scalarLength;
      uint64_t v15 = v21;
      uint64_t v14 = v20;
      uint64_t v17 = *(void *)&v22._0._value;
    }

    else
    {
      if ((a5 & 0x2000000000000000LL) == 0)
      {
        uint64_t v18 = (unsigned __int8 *)v15;
        if ((a4 & 0x1000000000000000LL) == 0)
        {
          uint64_t v24 = v14;
          uint64_t v25 = v15;
          uint64_t v18 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a4, a5);
          uint64_t v15 = v25;
          uint64_t v14 = v24;
        }

        LODWORD(v17) = v18[v11];
        if ((char)v18[v11] < 0) {
          __asm { BR              X9 }
        }

        ++v11;
LABEL_23:
        char v16 = 1;
        goto LABEL_9;
      }

      v30[0] = a4;
      v30[1] = v14;
      uint64_t v17 = *((unsigned __int8 *)v30 + v11);
      if (*((char *)v30 + v11) < 0) {
        __asm { BR              X9 }
      }

      Swift::Int scalarLength = 1LL;
    }

    v11 += scalarLength;
    if (v17 >= 0x10000)
    {
      uint64_t v27 = v15;
      uint64_t v28 = v14;
      __int16 v23 = Unicode.Scalar.UTF16View.subscript.getter(1LL, v17);
      LODWORD(v17) = (unsigned __int16)((v17 + 67043328) >> 10) + 55296;
      if ((v17 & 0x10000) != 0)
      {
        __break(1u);
        JUMPOUT(0x1815B42E0LL);
      }

      __int16 v12 = v23;
      char v16 = 0;
      uint64_t v15 = v27;
      uint64_t v14 = v28;
      goto LABEL_9;
    }

    goto LABEL_23;
  }

  char v16 = 1;
  uint64_t v9 = v13;
  a1 = v29;
LABEL_30:
  swift_bridgeObjectRelease_n(a5, 3LL);
LABEL_31:
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = a5;
  *(void *)(a1 + 16) = v11;
  *(void *)(a1 + 24) = v8;
  *(_WORD *)(a1 + 32) = v12;
  *(_BYTE *)(a1 + 34) = v16;
  return v9;
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0x2000000000000000LL) != 0) {
    uint64_t v8 = HIBYTE(a5) & 0xF;
  }
  else {
    uint64_t v8 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (a2)
  {
    uint64_t v9 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
      while (v12 < v8)
      {
        if ((a5 & 0x1000000000000000LL) != 0)
        {
          uint64_t v19 = a1;
          Swift::tuple_Unicode_Scalar_scalarLength_Int v16 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v12 << 16));
          Swift::Int scalarLength = v16.scalarLength;
          v13._Swift::UInt32 value = (Swift::UInt32)v16._0;
          a1 = v19;
        }

        else
        {
          if ((a5 & 0x2000000000000000LL) != 0)
          {
            v21[0] = a4;
            v21[1] = a5 & 0xFFFFFFFFFFFFFFLL;
            v13._Swift::UInt32 value = *((unsigned __int8 *)v21 + v12);
            if (*((char *)v21 + v12) < 0) {
              __asm { BR              X9 }
            }
          }

          else
          {
            uint64_t v15 = (a5 & 0xFFFFFFFFFFFFFFFLL) + 32;
            if ((a4 & 0x1000000000000000LL) == 0)
            {
              uint64_t v20 = a1;
              id v17 = _StringObject.sharedUTF8.getter(a4, a5);
              a1 = v20;
              uint64_t v15 = (uint64_t)v17;
            }

            v13._Swift::UInt32 value = *(unsigned __int8 *)(v15 + v12);
            if (*(char *)(v15 + v12) < 0) {
              __asm { BR              X10 }
            }
          }

          Swift::Int scalarLength = 1LL;
        }

        *(Swift::Unicode::Scalar *)(a2 + 4 * v11) = v13;
        v12 += scalarLength;
        if (v9 == ++v11) {
          goto LABEL_22;
        }
      }

      uint64_t v9 = v11;
    }

    else
    {
      uint64_t v12 = 0LL;
    }
  }

  else
  {
    uint64_t v12 = 0LL;
    uint64_t v9 = 0LL;
  }

uint64_t specialized Sequence._copySequenceContents(initializing:)( void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a4 + 56;
  uint64_t v7 = -1LL << *(_BYTE *)(a4 + 32);
  if (-v7 < 64) {
    uint64_t v8 = ~(-1LL << -(char)v7);
  }
  else {
    uint64_t v8 = -1LL;
  }
  unint64_t v9 = v8 & *(void *)(a4 + 56);
  if (!a2)
  {
    int64_t v12 = 0LL;
    uint64_t v10 = 0LL;
    goto LABEL_33;
  }

  uint64_t v10 = a3;
  if (a3 < 0) {
LABEL_37:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  if (!a3)
  {
    int64_t v12 = 0LL;
    goto LABEL_33;
  }

  uint64_t v11 = (void *)a2;
  int64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  int64_t v14 = (unint64_t)(63 - v7) >> 6;
  while (v9)
  {
    unint64_t v15 = __clz(__rbit64(v9));
    v9 &= v9 - 1;
    unint64_t v16 = v15 | (v12 << 6);
LABEL_9:
    ++v13;
    id v17 = (void *)(*(void *)(a4 + 48) + 16 * v16);
    unint64_t v18 = v17[1];
    *uint64_t v11 = *v17;
    v11[1] = v18;
    v11 += 2;
    swift_bridgeObjectRetain(v18, a2, a3, (char *)a4);
    if (v13 == v10) {
      goto LABEL_33;
    }
  }

  int64_t v19 = v12 + 1;
  if (__OFADD__(v12, 1LL))
  {
    __break(1u);
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }

  if (v19 >= v14) {
    goto LABEL_29;
  }
  unint64_t v20 = *(void *)(v6 + 8 * v19);
  if (v20) {
    goto LABEL_26;
  }
  v12 += 2LL;
  if (v19 + 1 >= v14)
  {
    unint64_t v9 = 0LL;
    int64_t v12 = v19;
    goto LABEL_32;
  }

  unint64_t v20 = *(void *)(v6 + 8 * v12);
  if (v20)
  {
    ++v19;
LABEL_26:
    unint64_t v9 = (v20 - 1) & v20;
    unint64_t v16 = __clz(__rbit64(v20)) + (v19 << 6);
    int64_t v12 = v19;
    goto LABEL_9;
  }

  if (v19 + 2 >= v14)
  {
LABEL_29:
    unint64_t v9 = 0LL;
    goto LABEL_32;
  }

  unint64_t v20 = *(void *)(v6 + 8 * (v19 + 2));
  if (v20)
  {
    v19 += 2LL;
    goto LABEL_26;
  }

  int64_t v21 = v19 + 3;
  if (v19 + 3 >= v14)
  {
    unint64_t v9 = 0LL;
    int64_t v12 = v19 + 2;
    goto LABEL_32;
  }

  unint64_t v20 = *(void *)(v6 + 8 * v21);
  if (v20)
  {
    v19 += 3LL;
    goto LABEL_26;
  }

  while (1)
  {
    int64_t v19 = v21 + 1;
    if (__OFADD__(v21, 1LL)) {
      goto LABEL_36;
    }
    if (v19 >= v14) {
      break;
    }
    unint64_t v20 = *(void *)(v6 + 8 * v19);
    ++v21;
    if (v20) {
      goto LABEL_26;
    }
  }

  unint64_t v9 = 0LL;
  int64_t v12 = v14 - 1;
LABEL_32:
  uint64_t v10 = v13;
LABEL_33:
  *a1 = a4;
  a1[1] = v6;
  a1[2] = ~v7;
  a1[3] = v12;
  a1[4] = v9;
  return v10;
}

{
  uint64_t v6;
  void *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  if (a2)
  {
    uint64_t v6 = a3;
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v7 = (void *)a2;
      uint64_t v8 = 0LL;
      unint64_t v9 = (unint64_t *)(a4 + 40);
      while (1)
      {
        uint64_t v10 = *(void *)(a4 + 16);
        if (v8 == v10) {
          break;
        }
        if (v8 >= v10) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }
        ++v8;
        uint64_t v11 = *v9;
        *uint64_t v7 = *(v9 - 1);
        v7[1] = v11;
        v7 += 2;
        swift_bridgeObjectRetain(v11, a2, a3, (char *)a4);
        v9 += 2;
        if (v6 == v8) {
          goto LABEL_10;
        }
      }

      uint64_t v6 = v8;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

uint64_t Sequence._copySequenceContents(initializing:)( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v35 = a3;
  uint64_t v33 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v29 = *(void *)(v11 - 8);
  uint64_t v30 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  int64_t v14 = (char *)&v28 - v13;
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](v12);
  id v17 = (char *)&v28 - v16;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v19 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858](v18);
  int64_t v21 = (char *)&v28 - v20;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v22 = *(void (**)(uint64_t, uint64_t))(a5 + 32);
  uint64_t v32 = a4;
  v22(a4, a5);
  if (a2)
  {
    uint64_t v31 = v19;
    if (v35 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    unint64_t v34 = v18;
    if (v35)
    {
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  v32,  v34,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      uint64_t v24 = 0LL;
      uint64_t v25 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
      while (1)
      {
        v25(v34, AssociatedConformanceWitness);
        if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v15 + 48))( v14,  1LL,  AssociatedTypeWitness) == 1) {
          break;
        }
        ++v24;
        BOOL v26 = *(void (**)(char *, char *, unint64_t))(v15 + 32);
        v26(v17, v14, AssociatedTypeWitness);
        v26(a2, v17, AssociatedTypeWitness);
        a2 += *(void *)(v15 + 72);
        if (v35 == v24) {
          goto LABEL_7;
        }
      }

      (*(void (**)(char *, uint64_t))(v29 + 8))(v14, v30);
      (*(void (**)(uint64_t, char *, unint64_t))(v31 + 32))(v33, v21, v34);
      return v24;
    }

    else
    {
LABEL_7:
      (*(void (**)(uint64_t, char *, unint64_t))(v31 + 32))(v33, v21, v34);
      return v35;
    }
  }

  else
  {
    (*(void (**)(uint64_t, char *, unint64_t))(v19 + 32))(v33, v21, v18);
    return 0LL;
  }

uint64_t UnsafeBufferPointer.indices.getter(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  return 0LL;
}

uint64_t (*IteratorSequence._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t IteratorSequence.next()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16LL))(*(void *)(a1 + 16));
}

uint64_t Sequence.min(by:)@<X0>( uint64_t (*a1)(char *, char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v49 = a4;
  Swift::UInt64 v52 = a1;
  uint64_t v53 = a2;
  uint64_t v47 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v45 = *(void *)(v11 - 8);
  uint64_t v46 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  int64_t v14 = (char *)&v43 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  Swift::UInt64 v51 = (char *)&v43 - v16;
  uint64_t v54 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v43 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  int v55 = (char *)&v43 - v21;
  uint64_t v22 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v43 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v48 = *(void *)(v25 - 8);
  MEMORY[0x1895F8858](v25);
  uint64_t v27 = (char *)&v43 - v26;
  (*(void (**)(char *, char *, uint64_t))(v22 + 16))(v24, v50, a3);
  uint64_t v28 = (uint64_t)v49;
  (*((void (**)(uint64_t, const char *))v49 + 4))(a3, v49);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v28,  a3,  v25,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = v51;
  uint64_t v49 = *(const char **)(AssociatedConformanceWitness + 16);
  ((void (*)(unint64_t, unint64_t))v49)(v25, AssociatedConformanceWitness);
  uint64_t v31 = v54;
  Swift::UInt64 v44 = *(uint64_t (**)(char *, uint64_t, unint64_t))(v54 + 48);
  if (v44(v30, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, unint64_t))(v48 + 8))(v27, v25);
    (*(void (**)(char *, uint64_t))(v45 + 8))(v51, v46);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v31 + 56))( v47,  1LL,  1LL,  AssociatedTypeWitness);
  }

  else
  {
    uint64_t v33 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
    v33(v55, v51, AssociatedTypeWitness);
    uint64_t v50 = v27;
    Swift::UInt64 v51 = (char *)v25;
    unint64_t v34 = v25;
    uint64_t v35 = v49;
    ((void (*)(unint64_t, unint64_t))v49)(v34, AssociatedConformanceWitness);
    Swift::String::Index v36 = v44;
    for (int i = v44(v14, 1LL, AssociatedTypeWitness); ; int i = v36(v14, 1LL, AssociatedTypeWitness))
    {
      if (i == 1)
      {
        (*(void (**)(char *, char *))(v48 + 8))(v50, v51);
        (*(void (**)(char *, uint64_t))(v45 + 8))(v14, v46);
        Swift::UInt64 v41 = v47;
        v33(v47, v55, AssociatedTypeWitness);
        return (*(uint64_t (**)(char *, void, uint64_t, unint64_t))(v54 + 56))( v41,  0LL,  1LL,  AssociatedTypeWitness);
      }

      v33(v19, v14, AssociatedTypeWitness);
      char v38 = v52(v19, v55);
      if (v5) {
        break;
      }
      uint64_t v39 = *(void (**)(char *, unint64_t))(v54 + 8);
      if ((v38 & 1) != 0)
      {
        Swift::UInt64 v40 = v55;
        v39(v55, AssociatedTypeWitness);
        v33(v40, v19, AssociatedTypeWitness);
      }

      else
      {
        v39(v19, AssociatedTypeWitness);
      }

      ((void (*)(char *, unint64_t))v35)(v51, AssociatedConformanceWitness);
    }

    int v42 = *(void (**)(char *, unint64_t))(v54 + 8);
    v42(v19, AssociatedTypeWitness);
    v42(v55, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, char *))(v48 + 8))(v50, v51);
  }

uint64_t Sequence.max(by:)@<X0>( uint64_t (*a1)(char *, char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v49 = a4;
  Swift::UInt64 v52 = a1;
  uint64_t v53 = a2;
  uint64_t v47 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v45 = *(void *)(v11 - 8);
  uint64_t v46 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  int64_t v14 = (char *)&v43 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  Swift::UInt64 v51 = (char *)&v43 - v16;
  uint64_t v54 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v43 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  int v55 = (char *)&v43 - v21;
  uint64_t v22 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v43 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v48 = *(void *)(v25 - 8);
  MEMORY[0x1895F8858](v25);
  uint64_t v27 = (char *)&v43 - v26;
  (*(void (**)(char *, char *, uint64_t))(v22 + 16))(v24, v50, a3);
  uint64_t v28 = (uint64_t)v49;
  (*((void (**)(uint64_t, const char *))v49 + 4))(a3, v49);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v28,  a3,  v25,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = v51;
  uint64_t v49 = *(const char **)(AssociatedConformanceWitness + 16);
  ((void (*)(unint64_t, unint64_t))v49)(v25, AssociatedConformanceWitness);
  uint64_t v31 = v54;
  Swift::UInt64 v44 = *(uint64_t (**)(char *, uint64_t, unint64_t))(v54 + 48);
  if (v44(v30, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, unint64_t))(v48 + 8))(v27, v25);
    (*(void (**)(char *, uint64_t))(v45 + 8))(v51, v46);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v31 + 56))( v47,  1LL,  1LL,  AssociatedTypeWitness);
  }

  else
  {
    uint64_t v33 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
    v33(v55, v51, AssociatedTypeWitness);
    uint64_t v50 = v27;
    Swift::UInt64 v51 = (char *)v25;
    unint64_t v34 = v25;
    uint64_t v35 = v49;
    ((void (*)(unint64_t, unint64_t))v49)(v34, AssociatedConformanceWitness);
    Swift::String::Index v36 = v44;
    for (int i = v44(v14, 1LL, AssociatedTypeWitness); ; int i = v36(v14, 1LL, AssociatedTypeWitness))
    {
      if (i == 1)
      {
        (*(void (**)(char *, char *))(v48 + 8))(v50, v51);
        (*(void (**)(char *, uint64_t))(v45 + 8))(v14, v46);
        Swift::UInt64 v41 = v47;
        v33(v47, v55, AssociatedTypeWitness);
        return (*(uint64_t (**)(char *, void, uint64_t, unint64_t))(v54 + 56))( v41,  0LL,  1LL,  AssociatedTypeWitness);
      }

      v33(v19, v14, AssociatedTypeWitness);
      char v38 = v52(v55, v19);
      if (v5) {
        break;
      }
      uint64_t v39 = *(void (**)(char *, unint64_t))(v54 + 8);
      if ((v38 & 1) != 0)
      {
        Swift::UInt64 v40 = v55;
        v39(v55, AssociatedTypeWitness);
        v33(v40, v19, AssociatedTypeWitness);
      }

      else
      {
        v39(v19, AssociatedTypeWitness);
      }

      ((void (*)(char *, unint64_t))v35)(v51, AssociatedConformanceWitness);
    }

    int v42 = *(void (**)(char *, unint64_t))(v54 + 8);
    v42(v19, AssociatedTypeWitness);
    v42(v55, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, char *))(v48 + 8))(v50, v51);
  }

uint64_t Sequence<>.min()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v49 = a3;
  uint64_t v47 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v45 = *(void *)(v9 - 8);
  uint64_t v46 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v41 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v43 = (char *)&v41 - v14;
  uint64_t v50 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v41 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v41 - v19;
  uint64_t v21 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v41 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v44 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v26 = (char *)&v41 - v25;
  (*(void (**)(char *, unint64_t, uint64_t))(v21 + 16))(v23, v48, a1);
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  v24,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v28 = v43;
  Swift::UInt64 v41 = *(void (**)(void))(AssociatedConformanceWitness + 16);
  unint64_t v42 = v24;
  ((void (*)(unint64_t, unint64_t))v41)(v24, AssociatedConformanceWitness);
  uint64_t v29 = v28;
  uint64_t v30 = v50;
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v50 + 48);
  if (v31(v29, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, unint64_t))(v44 + 8))(v26, v42);
    (*(void (**)(char *, uint64_t))(v45 + 8))(v29, v46);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v30 + 56))( v47,  1LL,  1LL,  AssociatedTypeWitness);
  }

  else
  {
    uint64_t v33 = *(void (**)(char *, char *, unint64_t))(v30 + 32);
    v33(v20, v29, AssociatedTypeWitness);
    unint64_t v34 = AssociatedConformanceWitness;
    uint64_t v35 = v26;
    Swift::String::Index v36 = v41;
    unint64_t v37 = v42;
    unint64_t v48 = v34;
    while (1)
    {
      v36();
      if (v31(v12, 1LL, AssociatedTypeWitness) == 1) {
        break;
      }
      v33(v17, v12, AssociatedTypeWitness);
      char v38 = (*(uint64_t (**)(char *, char *, unint64_t))(v49 + 16))(v17, v20, AssociatedTypeWitness);
      uint64_t v39 = *(void (**)(char *, unint64_t))(v50 + 8);
      if ((v38 & 1) != 0)
      {
        v39(v20, AssociatedTypeWitness);
        v33(v20, v17, AssociatedTypeWitness);
      }

      else
      {
        v39(v17, AssociatedTypeWitness);
      }
    }

    (*(void (**)(char *, unint64_t))(v44 + 8))(v35, v37);
    (*(void (**)(char *, uint64_t))(v45 + 8))(v12, v46);
    Swift::UInt64 v40 = v47;
    v33(v47, v20, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, void, uint64_t, unint64_t))(v50 + 56))( v40,  0LL,  1LL,  AssociatedTypeWitness);
  }

uint64_t Sequence<>.max()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v49 = a3;
  uint64_t v47 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v45 = *(void *)(v9 - 8);
  uint64_t v46 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v41 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v43 = (char *)&v41 - v14;
  uint64_t v50 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v41 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v41 - v19;
  uint64_t v21 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v41 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v44 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v26 = (char *)&v41 - v25;
  (*(void (**)(char *, unint64_t, uint64_t))(v21 + 16))(v23, v48, a1);
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  v24,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v28 = v43;
  Swift::UInt64 v41 = *(void (**)(void))(AssociatedConformanceWitness + 16);
  unint64_t v42 = v24;
  ((void (*)(unint64_t, unint64_t))v41)(v24, AssociatedConformanceWitness);
  uint64_t v29 = v28;
  uint64_t v30 = v50;
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v50 + 48);
  if (v31(v29, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, unint64_t))(v44 + 8))(v26, v42);
    (*(void (**)(char *, uint64_t))(v45 + 8))(v29, v46);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v30 + 56))( v47,  1LL,  1LL,  AssociatedTypeWitness);
  }

  else
  {
    uint64_t v33 = *(void (**)(char *, char *, unint64_t))(v30 + 32);
    v33(v20, v29, AssociatedTypeWitness);
    unint64_t v34 = AssociatedConformanceWitness;
    uint64_t v35 = v26;
    Swift::String::Index v36 = v41;
    unint64_t v37 = v42;
    unint64_t v48 = v34;
    while (1)
    {
      v36();
      if (v31(v12, 1LL, AssociatedTypeWitness) == 1) {
        break;
      }
      v33(v17, v12, AssociatedTypeWitness);
      char v38 = (*(uint64_t (**)(char *, char *, unint64_t))(v49 + 16))(v20, v17, AssociatedTypeWitness);
      uint64_t v39 = *(void (**)(char *, unint64_t))(v50 + 8);
      if ((v38 & 1) != 0)
      {
        v39(v20, AssociatedTypeWitness);
        v33(v20, v17, AssociatedTypeWitness);
      }

      else
      {
        v39(v17, AssociatedTypeWitness);
      }
    }

    (*(void (**)(char *, unint64_t))(v44 + 8))(v35, v37);
    (*(void (**)(char *, uint64_t))(v45 + 8))(v12, v46);
    Swift::UInt64 v40 = v47;
    v33(v47, v20, AssociatedTypeWitness);
    return (*(uint64_t (**)(char *, void, uint64_t, unint64_t))(v50 + 56))( v40,  0LL,  1LL,  AssociatedTypeWitness);
  }

BOOL Sequence.starts<A>(with:by:)( char *a1, uint64_t (*a2)(char *, char *), BOOL a3, uint64_t a4, uint64_t a5, const char *a6, const char *a7)
{
  uint64_t v73 = a1;
  Swift::UInt64 v78 = a7;
  uint64_t v75 = a5;
  Swift::UInt64 v67 = a2;
  BOOL v68 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a7,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v12 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v59 = *(void *)(v12 - 8);
  uint64_t v60 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  Swift::UInt64 v58 = (char *)&v58 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v58 - v16;
  uint64_t v69 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v70 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v58 - v18;
  uint64_t v66 = a6;
  uint64_t v20 = a4;
  uint64_t v64 = a4;
  unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v22 = *(void *)(v21 - 8);
  MEMORY[0x1895F8858](v21);
  unint64_t v24 = (char *)&v58 - v23;
  uint64_t v27 = type metadata accessor for Optional(0LL, v21, v25, v26);
  uint64_t v28 = MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v58 - v29;
  uint64_t v71 = *(void *)(v20 - 8);
  MEMORY[0x1895F8858](v28);
  Swift::UInt64 v65 = (char *)&v58 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v77 = swift_getAssociatedTypeWitness( 0LL,  a6,  v20,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v61 = *(void *)(v77 - 8);
  uint64_t v32 = MEMORY[0x1895F8858](v77);
  Swift::UInt32 v76 = (char *)&v58 - v33;
  uint64_t v34 = v75;
  uint64_t v63 = *(void *)(v75 - 8);
  MEMORY[0x1895F8858](v32);
  Swift::String::Index v36 = (char *)&v58 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v74 = swift_getAssociatedTypeWitness( 0LL,  v78,  v34,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v62 = *(void *)(v74 - 8);
  MEMORY[0x1895F8858](v74);
  char v38 = (char *)&v58 - v37;
  (*(void (**)(char *, char *, uint64_t))(v63 + 16))(v36, v73, v34);
  uint64_t v39 = (void (*)(uint64_t))*((void *)v78 + 4);
  uint64_t v73 = v38;
  v39(v34);
  uint64_t v40 = v64;
  (*(void (**)(char *, unint64_t, uint64_t))(v71 + 16))(v65, v72, v64);
  uint64_t v41 = (uint64_t)v66;
  (*((void (**)(uint64_t))v66 + 4))(v40);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v41,  v40,  v77,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v71 = *(void *)(AssociatedConformanceWitness + 16);
  unint64_t v72 = AssociatedConformanceWitness;
  unint64_t v43 = v70;
  while (1)
  {
    ((void (*)(unint64_t, unint64_t))v71)(v77, v72);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v22 + 48))(v30, 1LL, v21) == 1)
    {
      (*(void (**)(char *, unint64_t))(v61 + 8))(v76, v77);
      unint64_t v53 = v74;
      unint64_t v54 = swift_getAssociatedConformanceWitness( (uint64_t)v78,  v75,  v74,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      int v55 = v58;
      unsigned int v56 = v73;
      (*(void (**)(unint64_t, unint64_t))(v54 + 16))(v53, v54);
      (*(void (**)(char *, unint64_t))(v62 + 8))(v56, v53);
      BOOL v49 = (*(unsigned int (**)(char *, uint64_t, unint64_t))(v69 + 48))(v55, 1LL, v70) == 1;
      (*(void (**)(char *, uint64_t))(v59 + 8))(v55, v60);
      return v49;
    }

    (*(void (**)(char *, char *, unint64_t))(v22 + 32))(v24, v30, v21);
    unint64_t v44 = v74;
    unint64_t v45 = swift_getAssociatedConformanceWitness( (uint64_t)v78,  v75,  v74,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    (*(void (**)(unint64_t, unint64_t))(v45 + 16))(v44, v45);
    uint64_t v46 = v69;
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v69 + 48))(v17, 1LL, v43) == 1)
    {
      (*(void (**)(char *, unint64_t))(v22 + 8))(v24, v21);
      (*(void (**)(char *, unint64_t))(v61 + 8))(v76, v77);
      (*(void (**)(char *, unint64_t))(v62 + 8))(v73, v74);
      (*(void (**)(char *, uint64_t))(v59 + 8))(v17, v60);
      return 1;
    }

    uint64_t v47 = v17;
    (*(void (**)(char *, char *, unint64_t))(v46 + 32))(v19, v17, v43);
    uint64_t v48 = v46;
    BOOL v49 = v68;
    uint64_t v50 = v79;
    char v51 = v67(v24, v19);
    uint64_t v79 = v50;
    if (v50) {
      break;
    }
    char v52 = v51;
    (*(void (**)(char *, unint64_t))(v48 + 8))(v19, v43);
    (*(void (**)(char *, unint64_t))(v22 + 8))(v24, v21);
    uint64_t v17 = v47;
    if ((v52 & 1) == 0)
    {
      (*(void (**)(char *, unint64_t))(v61 + 8))(v76, v77);
      (*(void (**)(char *, unint64_t))(v62 + 8))(v73, v74);
      return 0;
    }
  }

  (*(void (**)(char *, unint64_t))(v48 + 8))(v19, v43);
  (*(void (**)(char *, unint64_t))(v22 + 8))(v24, v21);
  (*(void (**)(char *, unint64_t))(v61 + 8))(v76, v77);
  (*(void (**)(char *, unint64_t))(v62 + 8))(v73, v74);
  return v49;
}

uint64_t specialized Sequence<>.starts<A>(with:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  void (*v23)(uint64_t *__return_ptr, unint64_t, unint64_t);
  unint64_t i;
  uint64_t v25;
  Swift::String_optional v26;
  char v28;
  void *object;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v9 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v13,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v16 = (char *)&v32 - v15;
  uint64_t v17 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v17 = a1 & 0xFFFFFFFFFFFFLL;
  }
  Swift::String::Index v36 = a1;
  uint64_t v37 = a2;
  char v38 = 0LL;
  uint64_t v39 = v17;
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v4, a3);
  uint64_t v18 = *(void (**)(uint64_t, uint64_t))(a4 + 32);
  swift_bridgeObjectRetain(a2, v19, v20, v21);
  v18(a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v23 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v23(&v34, AssociatedTypeWitness, AssociatedConformanceWitness);
  for (int i = v35; v35; int i = v35)
  {
    uint64_t v25 = v34;
    uint64_t v26 = String.Iterator.next()();
    if (!v26.value._object)
    {
      swift_bridgeObjectRelease(i);
      (*(void (**)(char *, unint64_t))(v33 + 8))(v16, AssociatedTypeWitness);
      swift_bridgeObjectRelease(v37);
      return 1LL;
    }

    if (v25 == v26.value._countAndFlagsBits && (void *)i == v26.value._object)
    {
      swift_bridgeObjectRelease(i);
      swift_bridgeObjectRelease((uint64_t)v26.value._object);
    }

    else
    {
      if ((~(i & (unint64_t)v26.value._object) & 0x6000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(i);
        swift_bridgeObjectRelease((uint64_t)v26.value._object);
LABEL_20:
        (*(void (**)(char *, unint64_t))(v33 + 8))(v16, AssociatedTypeWitness);
        uint64_t v30 = v37;
LABEL_21:
        swift_bridgeObjectRelease(v30);
        return 0LL;
      }

      uint64_t v28 = _stringCompareInternal(_:_:expecting:)( v25,  i,  v26.value._countAndFlagsBits,  (unint64_t)v26.value._object,  0);
      swift_bridgeObjectRelease(i);
      swift_bridgeObjectRelease((uint64_t)v26.value._object);
      if ((v28 & 1) == 0) {
        goto LABEL_20;
      }
    }

    v23(&v34, AssociatedTypeWitness, AssociatedConformanceWitness);
  }

  (*(void (**)(char *, unint64_t))(v33 + 8))(v16, AssociatedTypeWitness);
  object = String.Iterator.next()().value._object;
  swift_bridgeObjectRelease(v37);
  if (object)
  {
    uint64_t v30 = (uint64_t)object;
    goto LABEL_21;
  }

  return 1LL;
}

{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  Swift::UInt64 v18;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(uint64_t *__return_ptr, unint64_t, unint64_t);
  unint64_t v21;
  uint64_t v22;
  Swift::String::Index v23;
  Swift::UInt64 rawBits;
  uint64_t v25;
  char *v26;
  int v27;
  uint64_t v28;
  int v29;
  Swift::String::Index v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  char v37;
  Swift::String::Index v38;
  uint64_t v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void v45[2];
  uint64_t v46;
  unint64_t v47;
  uint64_t v9 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v41 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v41 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v41 - v14;
  uint64_t v16 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v16 = a1;
  }
  uint64_t v17 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v17 = 11LL;
  }
  unint64_t v44 = v17;
  uint64_t v18 = v17 | (v16 << 16);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v4, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v20 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v20(&v46, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v21 = v47;
  if (v47)
  {
    unint64_t v42 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    unint64_t v43 = a2 & 0xFFFFFFFFFFFFFFLL;
    while (1)
    {
      if (v18 < 0x4000)
      {
        swift_bridgeObjectRelease(v21);
        (*(void (**)(char *, unint64_t))(v41 + 8))(v15, AssociatedTypeWitness);
        return 1LL;
      }

      uint64_t v22 = v46;
      v23._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)((Swift::String::Index)v18)._rawBits;
      Swift::UInt64 rawBits = v23._rawBits;
      if (!(v23._rawBits >> 14)) {
        break;
      }
      uint64_t v25 = v23._rawBits >> 16;
      if (v23._rawBits >= 0x20000)
      {
        if ((a2 & 0x1000000000000000LL) == 0)
        {
          if ((a2 & 0x2000000000000000LL) != 0)
          {
            v45[0] = a1;
            v45[1] = v43;
            uint64_t v29 = *(unsigned __int16 *)((char *)v45 + v25 - 2);
            if (v29 != 2573 && (v29 & 0x80808080) == 0) {
              goto LABEL_17;
            }
          }

          else
          {
            uint64_t v26 = (char *)v42;
            if ((a1 & 0x1000000000000000LL) == 0)
            {
              uint64_t v26 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
              if (!v26) {
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
              }
            }

            uint64_t v27 = *(unsigned __int16 *)&v26[v25 - 2];
            if (v27 != 2573 && (v27 & 0x80808080) == 0)
            {
LABEL_17:
              uint64_t v25 = 1LL;
LABEL_18:
              uint64_t v28 = v25 << 8;
              goto LABEL_26;
            }
          }
        }

        uint64_t v25 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
      }

      uint64_t v28 = v25 << 8;
      if (v25 > 63) {
        uint64_t v28 = 0LL;
      }
LABEL_26:
      uint64_t v18 = v28 | v44 | (rawBits - (v25 << 16)) & 0xFFFFFFFFFFFF0000LL;
      v31._Swift::UInt64 rawBits = v18;
      uint64_t v32 = String.subscript.getter(v31, a1, a2);
      uint64_t v34 = v33;
      if (v22 == v32 && v21 == v33)
      {
        swift_bridgeObjectRelease(v21);
        swift_bridgeObjectRelease(v34);
      }

      else
      {
        if ((~v21 & 0x6000000000000000LL) == 0
          && (v33 & 0x2000000000000000LL) != 0
          && (v33 & 0x4000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v21);
          swift_bridgeObjectRelease(v34);
LABEL_44:
          (*(void (**)(char *, unint64_t))(v41 + 8))(v15, AssociatedTypeWitness);
          return 0LL;
        }

        uint64_t v37 = _stringCompareInternal(_:_:expecting:)(v22, v21, v32, v33, 0);
        swift_bridgeObjectRelease(v21);
        swift_bridgeObjectRelease(v34);
        if ((v37 & 1) == 0) {
          goto LABEL_44;
        }
      }

      v20(&v46, AssociatedTypeWitness, AssociatedConformanceWitness);
      unint64_t v21 = v47;
      if (!v47) {
        goto LABEL_42;
      }
    }

    if ((_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u) & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
    }
    uint64_t v25 = 0LL;
    goto LABEL_18;
  }

uint64_t specialized Sequence<>.starts<A>(with:)(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  Swift::String_optional v9 = String.Iterator.next()();
  if (v9.value._object)
  {
    uint64_t countAndFlagsBits = v9.value._countAndFlagsBits;
    unint64_t object = (unint64_t)v9.value._object;
    do
    {
      Swift::String_optional v13 = String.Iterator.next()();
      if (!v13.value._object)
      {
        swift_bridgeObjectRelease(a2);
        swift_bridgeObjectRelease((uint64_t)a4);
        swift_bridgeObjectRelease(object);
        return 1LL;
      }

      if (countAndFlagsBits == v13.value._countAndFlagsBits && (void *)object == v13.value._object)
      {
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease((uint64_t)v13.value._object);
      }

      else
      {
        if ((~(object & (unint64_t)v13.value._object) & 0x6000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(object);
          swift_bridgeObjectRelease((uint64_t)v13.value._object);
LABEL_16:
          swift_bridgeObjectRelease(a2);
          uint64_t v16 = (uint64_t)a4;
LABEL_17:
          swift_bridgeObjectRelease(v16);
          return 0LL;
        }

        char v14 = _stringCompareInternal(_:_:expecting:)( countAndFlagsBits,  object,  v13.value._countAndFlagsBits,  (unint64_t)v13.value._object,  0);
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease((uint64_t)v13.value._object);
        if ((v14 & 1) == 0) {
          goto LABEL_16;
        }
      }

      Swift::String_optional v12 = String.Iterator.next()();
      uint64_t countAndFlagsBits = v12.value._countAndFlagsBits;
      unint64_t object = (unint64_t)v12.value._object;
    }

    while (v12.value._object);
  }

  swift_bridgeObjectRelease((uint64_t)a4);
  uint64_t v15 = String.Iterator.next()().value._object;
  swift_bridgeObjectRelease(a2);
  if (v15)
  {
    uint64_t v16 = (uint64_t)v15;
    goto LABEL_17;
  }

  return 1LL;
}

uint64_t specialized Sequence<>.starts<A>(with:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = a1;
  }
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v7 = 11LL;
  }
  else {
    uint64_t v7 = 7LL;
  }
  uint64_t v47 = v7;
  Swift::UInt64 v8 = v7 | (v6 << 16);
  uint64_t v9 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v9 = a3;
  }
  if (((a4 >> 60) & ((a3 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v10 = 11LL;
  }
  else {
    uint64_t v10 = 7LL;
  }
  Swift::UInt64 v11 = v10 | (v9 << 16);
  if (v11 >= 0x4000)
  {
    uint64_t v45 = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
    uint64_t v46 = a4 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v43 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    uint64_t v44 = a2 & 0xFFFFFFFFFFFFFFLL;
    while (1)
    {
      v14._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)((Swift::String::Index)v11)._rawBits;
      Swift::UInt64 rawBits = v14._rawBits;
      if (!(v14._rawBits >> 14)) {
        break;
      }
      uint64_t v16 = v14._rawBits >> 16;
      if (v14._rawBits >= 0x20000)
      {
        if ((a4 & 0x1000000000000000LL) == 0)
        {
          if ((a4 & 0x2000000000000000LL) != 0)
          {
            uint64_t v48 = a3;
            uint64_t v49 = v46;
            uint64_t v18 = (char *)&v48 + v16;
          }

          else
          {
            uint64_t v17 = (char *)v45;
            if ((a3 & 0x1000000000000000LL) == 0)
            {
              uint64_t v17 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
              if (!v17) {
LABEL_61:
              }
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            }

            uint64_t v18 = &v17[v16];
          }

          int v19 = *((unsigned __int16 *)v18 - 1);
          if (v19 != 2573 && (v19 & 0x80808080) == 0)
          {
            uint64_t v16 = 1LL;
LABEL_28:
            uint64_t v21 = v16 << 8;
            goto LABEL_34;
          }
        }

        uint64_t v16 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
      }

      uint64_t v21 = v16 << 8;
      if (v16 > 63) {
        uint64_t v21 = 0LL;
      }
LABEL_34:
      Swift::UInt64 v11 = v21 | v10 | (rawBits - (v16 << 16)) & 0xFFFFFFFFFFFF0000LL;
      v22._Swift::UInt64 rawBits = v11;
      uint64_t v23 = String.subscript.getter(v22, a3, a4);
      unint64_t v25 = v24;
      if (v8 < 0x4000)
      {
        uint64_t v39 = 1LL;
LABEL_63:
        swift_bridgeObjectRelease(v25);
        return v39;
      }

      uint64_t v26 = v23;
      v27._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)((Swift::String::Index)v8)._rawBits;
      Swift::UInt64 v28 = v27._rawBits;
      if (!(v27._rawBits >> 14))
      {
        if ((_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u) & 1) != 0) {
LABEL_69:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
        uint64_t v29 = 0LL;
        goto LABEL_45;
      }

      uint64_t v29 = v27._rawBits >> 16;
      if (v27._rawBits >= 0x20000)
      {
        if ((a2 & 0x1000000000000000LL) == 0)
        {
          if ((a2 & 0x2000000000000000LL) != 0)
          {
            uint64_t v48 = a1;
            uint64_t v49 = v44;
            uint64_t v31 = (char *)&v48 + v29;
          }

          else
          {
            uint64_t v30 = (char *)v43;
            if ((a1 & 0x1000000000000000LL) == 0)
            {
              uint64_t v30 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
              if (!v30) {
                goto LABEL_61;
              }
            }

            uint64_t v31 = &v30[v29];
          }

          int v32 = *((unsigned __int16 *)v31 - 1);
          if (v32 != 2573 && (v32 & 0x80808080) == 0)
          {
            uint64_t v29 = 1LL;
LABEL_45:
            uint64_t v33 = v29 << 8;
            goto LABEL_51;
          }
        }

        uint64_t v29 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v28 >> 16);
      }

      uint64_t v33 = v29 << 8;
      if (v29 > 63) {
        uint64_t v33 = 0LL;
      }
LABEL_51:
      Swift::UInt64 v8 = v33 | v47 | (v28 - (v29 << 16)) & 0xFFFFFFFFFFFF0000LL;
      v34._Swift::UInt64 rawBits = v8;
      uint64_t v36 = String.subscript.getter(v34, a1, a2);
      uint64_t v37 = v35;
      if (v26 == v36 && v25 == v35)
      {
        swift_bridgeObjectRelease_n(v25, 2LL);
      }

      else
      {
        if ((~v25 & 0x6000000000000000LL) == 0
          && (v35 & 0x2000000000000000LL) != 0
          && (v35 & 0x4000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v25);
          uint64_t v39 = 0LL;
          unint64_t v25 = v37;
          goto LABEL_63;
        }

        char v38 = _stringCompareInternal(_:_:expecting:)(v26, v25, v36, v35, 0);
        swift_bridgeObjectRelease(v25);
        swift_bridgeObjectRelease(v37);
        if ((v38 & 1) == 0) {
          return 0LL;
        }
      }

      if (v11 < 0x4000) {
        goto LABEL_65;
      }
    }

    if ((_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u) & 1) != 0) {
      goto LABEL_69;
    }
    uint64_t v16 = 0LL;
    goto LABEL_28;
  }

uint64_t specialized Sequence<>.starts<A>(with:)( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v11 = a3 ^ a4;
  swift_bridgeObjectRetain(a2, a2, a3, (char *)a4);
  if (v11 >= 0x4000)
  {
    v14._Swift::UInt64 rawBits = a3;
    do
    {
      uint64_t v15 = Substring.subscript.getter(v14._rawBits, a3, a4, a5, a6);
      unint64_t v17 = v16;
      v14._Swift::UInt64 rawBits = Substring.index(after:)(v14)._rawBits;
      Swift::String_optional v18 = String.Iterator.next()();
      if (!v18.value._object)
      {
        swift_bridgeObjectRelease(a2);
        swift_bridgeObjectRelease(v17);
        return 1LL;
      }

      if (v15 == v18.value._countAndFlagsBits && v18.value._object == (void *)v17)
      {
        swift_bridgeObjectRelease(v17);
        swift_bridgeObjectRelease((uint64_t)v18.value._object);
      }

      else
      {
        if ((~(v17 & (unint64_t)v18.value._object) & 0x6000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v17);
          swift_bridgeObjectRelease((uint64_t)v18.value._object);
LABEL_16:
          uint64_t v13 = a2;
LABEL_17:
          swift_bridgeObjectRelease(v13);
          return 0LL;
        }

        char v19 = _stringCompareInternal(_:_:expecting:)( v15,  v17,  v18.value._countAndFlagsBits,  (unint64_t)v18.value._object,  0);
        swift_bridgeObjectRelease(v17);
        swift_bridgeObjectRelease((uint64_t)v18.value._object);
        if ((v19 & 1) == 0) {
          goto LABEL_16;
        }
      }
    }

    while ((v14._rawBits ^ a4) >= 0x4000);
  }

  unint64_t object = String.Iterator.next()().value._object;
  swift_bridgeObjectRelease(a2);
  if (object)
  {
    uint64_t v13 = (uint64_t)object;
    goto LABEL_17;
  }

  return 1LL;
}

uint64_t specialized Sequence<>.starts<A>(with:)( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v7 = a1;
  uint64_t v8 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = a1;
  }
  uint64_t v9 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v9 = 11LL;
  }
  Swift::UInt64 rawBits = v9 | (v8 << 16);
  unint64_t v11 = a3 >> 14;
  if (a3 >> 14 == a4 >> 14)
  {
LABEL_34:
    if (rawBits < 0x4000) {
      return 1LL;
    }
    v43._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)rawBits)._rawBits;
    String.subscript.getter(v43, v7, a2);
    unint64_t v28 = v44;
    uint64_t v41 = 0LL;
  }

  else
  {
    unint64_t v12 = a6;
    unint64_t v13 = a5;
    unint64_t v14 = a4;
    unint64_t v15 = a3;
    uint64_t v16 = 4LL;
    if (((a6 >> 60) & ((a5 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v16 = 8LL;
    }
    uint64_t v48 = a3 & 2 | v16;
    uint64_t v49 = a3 >> 16;
    unint64_t v17 = a4;
    unint64_t v45 = a3 >> 14;
    while (1)
    {
      unint64_t v18 = _StringGuts.validateInclusiveCharacterIndex(_:in:)(v17, v15, v14, v13, v12);
      if (v11 >= v18 >> 14) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/Substring.swift",  21LL,  2,  0x10BuLL,  0);
      }
      unint64_t v20 = v18;
      uint64_t v21 = _StringGuts._opaqueCharacterStride(endingAt:in:)(v18 >> 16, v49, v19, v13, v12);
      uint64_t v22 = v21 << 8;
      if (v21 > 63) {
        uint64_t v22 = 0LL;
      }
      unint64_t v23 = v48 | v22 | (v20 - (v21 << 16)) & 0xFFFFFFFFFFFF0000LL;
      unint64_t v17 = v23 | 1;
      unint64_t v24 = v15;
      unint64_t v25 = v14;
      uint64_t v26 = Substring.subscript.getter(v23 | 1, v24, v14, v13, v12);
      unint64_t v28 = v27;
      if (rawBits < 0x4000) {
        break;
      }
      uint64_t v29 = v26;
      unint64_t v30 = v12;
      v31._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)((Swift::String::Index)rawBits)._rawBits;
      if (!(v31._rawBits >> 14) && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
      }
      v32._Swift::UInt64 rawBits = String._uncheckedIndex(before:)(v31)._rawBits;
      Swift::UInt64 rawBits = v32._rawBits;
      uint64_t v33 = v7;
      uint64_t v34 = String.subscript.getter(v32, v7, a2);
      BOOL v36 = v29 == v34 && v28 == v35;
      if (v36)
      {
        swift_bridgeObjectRelease_n(v28, 2LL);
      }

      else
      {
        uint64_t v37 = v35;
        if ((~v28 & 0x6000000000000000LL) == 0
          && (v35 & 0x2000000000000000LL) != 0
          && (v35 & 0x4000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v28);
          uint64_t v41 = 0LL;
          unint64_t v28 = v37;
          goto LABEL_32;
        }

        char v40 = _stringCompareInternal(_:_:expecting:)(v29, v28, v34, v35, 0);
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(v37);
        if ((v40 & 1) == 0) {
          return 0LL;
        }
      }

      BOOL v36 = v45 == v23 >> 14;
      unint64_t v11 = v45;
      unint64_t v14 = v25;
      uint64_t v7 = v33;
      unint64_t v12 = v30;
      unint64_t v15 = a3;
      unint64_t v13 = a5;
      if (v36) {
        goto LABEL_34;
      }
    }

    uint64_t v41 = 1LL;
  }

uint64_t Sequence<>.starts<A>(with:)( char *a1, uint64_t a2, uint64_t a3, const char *a4, const char *a5, uint64_t a6)
{
  uint64_t v66 = a1;
  uint64_t v62 = a6;
  BOOL v68 = a5;
  uint64_t v59 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v13 = (char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  unint64_t v15 = (char *)&v53 - v14;
  uint64_t v18 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v16, v17);
  uint64_t v55 = *(void *)(v18 - 8);
  uint64_t v56 = v18;
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  unint64_t v54 = (char *)&v53 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v23 = (char *)&v53 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v53 - v25;
  uint64_t v57 = a2;
  uint64_t v64 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v24);
  Swift::UInt64 v58 = (char *)&v53 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v70 = swift_getAssociatedTypeWitness( 0LL,  a4,  v28,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v60 = *(void *)(v70 - 8);
  uint64_t v29 = MEMORY[0x1895F8858](v70);
  uint64_t v69 = (char *)&v53 - v30;
  uint64_t v31 = a3;
  uint64_t v63 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v53 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v34 = v68;
  unint64_t v67 = swift_getAssociatedTypeWitness( 0LL,  v68,  v31,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v61 = *(void *)(v67 - 8);
  MEMORY[0x1895F8858](v67);
  BOOL v36 = (char *)&v53 - v35;
  (*(void (**)(char *, char *, uint64_t))(v63 + 16))(v33, v66, v31);
  uint64_t v37 = (void (*)(uint64_t, const char *))*((void *)v34 + 4);
  uint64_t v66 = v36;
  uint64_t v63 = v31;
  v37(v31, v34);
  uint64_t v38 = v57;
  (*(void (**)(char *, unint64_t, uint64_t))(v64 + 16))(v58, v65, v57);
  uint64_t v39 = (uint64_t)v59;
  (*((void (**)(uint64_t))v59 + 4))(v38);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v39,  v38,  v70,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v64 = *(void *)(AssociatedConformanceWitness + 16);
  unint64_t v65 = AssociatedConformanceWitness;
  uint64_t v41 = v67;
  while (1)
  {
    ((void (*)(unint64_t, unint64_t))v64)(v70, v65);
    unint64_t v42 = (unsigned int (*)(char *, uint64_t, unint64_t))v10[6];
    if (v42(v26, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, unint64_t))(v60 + 8))(v69, v70);
      unint64_t v48 = v67;
      unint64_t v49 = swift_getAssociatedConformanceWitness( (uint64_t)v68,  v63,  v67,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      uint64_t v50 = v54;
      char v51 = v66;
      (*(void (**)(unint64_t, unint64_t))(v49 + 16))(v48, v49);
      (*(void (**)(char *, unint64_t))(v61 + 8))(v51, v48);
      BOOL v47 = v42(v50, 1LL, AssociatedTypeWitness) == 1;
      (*(void (**)(char *, uint64_t))(v55 + 8))(v50, v56);
      return v47;
    }

    Swift::String::Index v43 = (void (*)(char *, char *, unint64_t))v10[4];
    v43(v15, v26, AssociatedTypeWitness);
    unint64_t v44 = swift_getAssociatedConformanceWitness( (uint64_t)v68,  v63,  v41,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    (*(void (**)(uint64_t, unint64_t))(v44 + 16))(v41, v44);
    if (v42(v23, 1LL, AssociatedTypeWitness) == 1) {
      break;
    }
    v43(v13, v23, AssociatedTypeWitness);
    char v45 = (*(uint64_t (**)(char *, char *, unint64_t))(v62 + 8))(v15, v13, AssociatedTypeWitness);
    uint64_t v46 = (void (*)(char *, unint64_t))v10[1];
    v46(v13, AssociatedTypeWitness);
    v46(v15, AssociatedTypeWitness);
    if ((v45 & 1) == 0)
    {
      (*(void (**)(char *, unint64_t))(v60 + 8))(v69, v70);
      (*(void (**)(char *, unint64_t))(v61 + 8))(v66, v67);
      return 0LL;
    }
  }

  ((void (*)(char *, unint64_t))v10[1])(v15, AssociatedTypeWitness);
  (*(void (**)(char *, unint64_t))(v60 + 8))(v69, v70);
  (*(void (**)(char *, unint64_t))(v61 + 8))(v66, v67);
  (*(void (**)(char *, uint64_t))(v55 + 8))(v23, v56);
  return 1LL;
}

uint64_t Sequence.elementsEqual<A>(_:by:)( void (*a1)(unint64_t, const char *), uint64_t (*a2)(char *, char *), uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, const char *a7)
{
  BOOL v68 = a1;
  uint64_t v69 = a6;
  uint64_t v62 = a2;
  uint64_t v63 = a3;
  uint64_t v66 = a7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a7,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v64 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v56 - v13;
  unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v61 = (char *)&v56 - v17;
  uint64_t v20 = type metadata accessor for Optional((const char *)0xFF, v15, v18, v19);
  unint64_t v65 = AssociatedTypeWitness;
  uint64_t v23 = type metadata accessor for Optional((const char *)0xFF, AssociatedTypeWitness, v21, v22);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v20, v23, 0LL, 0LL);
  uint64_t v24 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v81 = (char *)&v56 - v25;
  uint64_t v75 = *(void *)(v23 - 8);
  uint64_t v76 = v23;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v72 = (char *)&v56 - v27;
  uint64_t v74 = v20;
  uint64_t v71 = *(void *)(v20 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  unint64_t v70 = (char *)&v56 - v29;
  uint64_t v59 = a5;
  unint64_t v67 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](v28);
  uint64_t v60 = (char *)&v56 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v80 = swift_getAssociatedTypeWitness( 0LL,  a7,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v58 = *(void *)(v80 - 8);
  uint64_t v31 = MEMORY[0x1895F8858](v80);
  Swift::UInt64 v78 = (char *)&v56 - v32;
  uint64_t v33 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v31);
  uint64_t v35 = (char *)&v56 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  BOOL v36 = v69;
  unint64_t v79 = swift_getAssociatedTypeWitness( 0LL,  v69,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v57 = *(void *)(v79 - 8);
  MEMORY[0x1895F8858](v79);
  uint64_t v38 = (char *)&v56 - v37;
  uint64_t v39 = *(void (**)(char *, char *, uint64_t))(v33 + 16);
  char v40 = v61;
  v39(v35, v77, a4);
  uint64_t v41 = (void (*)(uint64_t, const char *))*((void *)v36 + 4);
  unint64_t v77 = v38;
  v41(a4, v36);
  uint64_t v42 = v59;
  (*(void (**)(char *, void (*)(unint64_t, const char *), uint64_t))(v67 + 16))( v60,  v68,  v59);
  uint64_t v43 = (uint64_t)v66;
  (*((void (**)(uint64_t, const char *))v66 + 4))(v42, v66);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v69,  a4,  v79,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  BOOL v68 = *(void (**)(unint64_t, const char *))(AssociatedConformanceWitness + 16);
  uint64_t v69 = (const char *)AssociatedConformanceWitness;
  unint64_t v45 = swift_getAssociatedConformanceWitness( v43,  v42,  v80,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v66 = *(const char **)(v45 + 16);
  unint64_t v67 = v45;
  uint64_t v46 = v81;
  while (1)
  {
    BOOL v47 = v70;
    v68(v79, v69);
    unint64_t v48 = v72;
    ((void (*)(unint64_t, unint64_t))v66)(v80, v67);
    unint64_t v49 = &v46[*((int *)TupleTypeMetadata2 + 12)];
    (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v46, v47, v74);
    (*(void (**)(char *, char *, uint64_t))(v75 + 32))(v49, v48, v76);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v16 + 48))(v46, 1LL, v15) == 1)
    {
      (*(void (**)(char *, unint64_t))(v58 + 8))(v78, v80);
      (*(void (**)(char *, unint64_t))(v57 + 8))(v77, v79);
      LOBYTE(v40) = 1;
      (*(void (**)(char *, uint64_t))(v75 + 8))(v49, v76);
      goto LABEL_10;
    }

    uint64_t v50 = v16;
    uint64_t v52 = v64;
    unint64_t v51 = v65;
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v64 + 48))(v49, 1LL, v65) == 1)
    {
      (*(void (**)(char *, unint64_t))(v58 + 8))(v78, v80);
      (*(void (**)(char *, unint64_t))(v57 + 8))(v77, v79);
      (*(void (**)(char *, unint64_t))(v50 + 8))(v81, v15);
      goto LABEL_10;
    }

    (*(void (**)(char *, char *, unint64_t))(v50 + 32))(v40, v81, v15);
    (*(void (**)(char *, char *, unint64_t))(v52 + 32))(v14, v49, v51);
    char v53 = v62(v40, v14);
    if (v7) {
      break;
    }
    char v54 = v53;
    (*(void (**)(char *, unint64_t))(v52 + 8))(v14, v51);
    (*(void (**)(char *, unint64_t))(v50 + 8))(v40, v15);
    uint64_t v16 = v50;
    if ((v54 & 1) == 0)
    {
      (*(void (**)(char *, unint64_t))(v58 + 8))(v78, v80);
      (*(void (**)(char *, unint64_t))(v57 + 8))(v77, v79);
LABEL_10:
      LOBYTE(v40) = 0;
      return v40 & 1;
    }
  }

  (*(void (**)(char *, unint64_t))(v52 + 8))(v14, v51);
  (*(void (**)(char *, unint64_t))(v50 + 8))(v40, v15);
  (*(void (**)(char *, unint64_t))(v58 + 8))(v78, v80);
  (*(void (**)(char *, unint64_t))(v57 + 8))(v77, v79);
  return v40 & 1;
}

uint64_t Sequence.lexicographicallyPrecedes<A>(_:by:)( unint64_t a1, uint64_t (*a2)(char *, char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7)
{
  unint64_t v83 = a1;
  uint64_t v85 = a7;
  uint64_t v86 = a2;
  uint64_t v87 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t v69 = *(void *)(v15 - 8);
  uint64_t v70 = v15;
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  BOOL v68 = (char *)&v67 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v74 = (char *)&v67 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v79 = (char *)&v67 - v21;
  uint64_t v73 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v76 = (char *)&v67 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v75 = (char *)&v67 - v25;
  uint64_t v84 = a5;
  unint64_t v80 = *(char **)(a5 - 8);
  MEMORY[0x1895F8858](v24);
  Swift::UInt64 v78 = (char *)&v67 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v81 = swift_getAssociatedTypeWitness( 0LL,  a7,  v27,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v72 = *(void (***)(char *, unint64_t))(v81 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v81);
  uint64_t v30 = (char *)&v67 - v29;
  uint64_t v31 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v28);
  uint64_t v33 = (char *)&v67 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v34 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v71 = *(void *)(v34 - 8);
  MEMORY[0x1895F8858](v34);
  BOOL v36 = (char *)&v67 - v35;
  uint64_t v37 = *(void (**)(char *, char *, uint64_t))(v31 + 16);
  uint64_t v38 = v73;
  v37(v33, v82, a4);
  uint64_t v39 = *(void (**)(uint64_t, uint64_t))(a6 + 32);
  uint64_t v82 = v36;
  v39(a4, a6);
  uint64_t v40 = v84;
  (*((void (**)(char *, unint64_t, uint64_t))v80 + 2))(v78, v83, v84);
  uint64_t v41 = (void (*)(uint64_t))*((void *)v85 + 4);
  unint64_t v80 = v30;
  uint64_t v42 = v74;
  v41(v40);
  unint64_t v83 = v34;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  v34,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v77 = *(void (**)(unint64_t, char *))(AssociatedConformanceWitness + 16);
  Swift::UInt64 v78 = (char *)AssociatedConformanceWitness;
  unint64_t v44 = v75;
  while (1)
  {
    unint64_t v45 = v79;
    v77(v83, v78);
    uint64_t v46 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v38 + 48);
    if (v46(v45, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, unint64_t))(v71 + 8))(v82, v83);
      uint64_t v58 = v70;
      uint64_t v59 = *(void (**)(char *, uint64_t))(v69 + 8);
      v59(v45, v70);
      unint64_t v60 = v81;
      unint64_t v61 = swift_getAssociatedConformanceWitness( (uint64_t)v85,  v84,  v81,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      uint64_t v62 = v68;
      uint64_t v63 = v80;
      (*(void (**)(unint64_t, unint64_t))(v61 + 16))(v60, v61);
      v72[1](v63, v60);
      LOBYTE(v63) = v46(v62, 1LL, AssociatedTypeWitness) != 1;
      v59(v62, v58);
      return v63 & 1;
    }

    uint64_t v47 = v38;
    unint64_t v48 = *(void (**)(char *, char *, unint64_t))(v38 + 32);
    v48(v44, v45, AssociatedTypeWitness);
    unint64_t v49 = v42;
    unint64_t v50 = v81;
    unint64_t v51 = swift_getAssociatedConformanceWitness( (uint64_t)v85,  v84,  v81,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    unint64_t v52 = v50;
    uint64_t v42 = v49;
    (*(void (**)(unint64_t, unint64_t))(v51 + 16))(v52, v51);
    if (v46(v49, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, unint64_t))(v47 + 8))(v44, AssociatedTypeWitness);
      v72[1](v80, v81);
      (*(void (**)(char *, unint64_t))(v71 + 8))(v82, v83);
      (*(void (**)(char *, uint64_t))(v69 + 8))(v49, v70);
      goto LABEL_11;
    }

    char v53 = v76;
    v48(v76, v49, AssociatedTypeWitness);
    char v54 = v86(v44, v53);
    if (v7) {
      break;
    }
    if ((v54 & 1) != 0)
    {
      uint64_t v63 = *(char **)(v47 + 8);
      ((void (*)(char *, unint64_t))v63)(v53, AssociatedTypeWitness);
      ((void (*)(char *, unint64_t))v63)(v44, AssociatedTypeWitness);
      v72[1](v80, v81);
      (*(void (**)(char *, unint64_t))(v71 + 8))(v82, v83);
      LOBYTE(v63) = 1;
      return v63 & 1;
    }

    char v55 = v86(v53, v44);
    uint64_t v56 = v53;
    uint64_t v57 = *(void (**)(char *, unint64_t))(v47 + 8);
    uint64_t v38 = v47;
    v57(v56, AssociatedTypeWitness);
    v57(v44, AssociatedTypeWitness);
    if ((v55 & 1) != 0)
    {
      v72[1](v80, v81);
      (*(void (**)(char *, unint64_t))(v71 + 8))(v82, v83);
LABEL_11:
      LOBYTE(v63) = 0;
      return v63 & 1;
    }
  }

  uint64_t v64 = *(void (**)(char *, unint64_t))(v47 + 8);
  uint64_t v65 = v71;
  uint64_t v63 = (char *)v72;
  v64(v76, AssociatedTypeWitness);
  v64(v44, AssociatedTypeWitness);
  (*((void (**)(char *, unint64_t))v63 + 1))(v80, v81);
  (*(void (**)(char *, unint64_t))(v65 + 8))(v82, v83);
  return v63 & 1;
}

uint64_t Sequence<>.lexicographicallyPrecedes<A>(_:)( unint64_t a1, uint64_t a2, uint64_t a3, const char *a4, const char *a5, uint64_t a6)
{
  unint64_t v72 = a4;
  uint64_t v67 = a6;
  BOOL v68 = (void (*)(const char *, unint64_t))a2;
  uint64_t v74 = a5;
  unint64_t v69 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v60 = *(void *)(v11 - 8);
  uint64_t v61 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v59 = (char *)&v58 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v58 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v58 - v18;
  uint64_t v20 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v21 = MEMORY[0x1895F8858](v17);
  uint64_t v23 = (char *)&v58 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v58 - v25;
  uint64_t v73 = a3;
  uint64_t v66 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v65 = (char *)&v58 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v70 = swift_getAssociatedTypeWitness( 0LL,  a5,  v28,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v63 = *(void *)(v70 - 8);
  uint64_t v29 = MEMORY[0x1895F8858](v70);
  uint64_t v75 = (char *)&v58 - v30;
  uint64_t v31 = (uint64_t)v68;
  uint64_t v64 = *((void *)v68 - 1);
  MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v58 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v34 = (const char *)swift_getAssociatedTypeWitness( 0LL,  v72,  v31,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v62 = *((void *)v34 - 1);
  MEMORY[0x1895F8858](v34);
  BOOL v36 = (char *)&v58 - v35;
  (*(void (**)(char *, char *, uint64_t))(v64 + 16))(v33, v71, v31);
  uint64_t v37 = (void (*)(uint64_t))*((void *)v72 + 4);
  uint64_t v71 = v36;
  v37(v31);
  uint64_t v38 = v73;
  (*(void (**)(char *, unint64_t, uint64_t))(v66 + 16))(v65, v69, v73);
  (*((void (**)(uint64_t))v74 + 4))(v38);
  uint64_t v39 = v72;
  unint64_t v72 = v34;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v39,  v31,  (uint64_t)v34,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  BOOL v68 = *(void (**)(const char *, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v69 = AssociatedConformanceWitness;
  uint64_t v41 = v70;
  while (1)
  {
    v68(v72, v69);
    uint64_t v42 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48);
    if (v42(v19, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, const char *))(v62 + 8))(v71, v72);
      uint64_t v49 = v61;
      unint64_t v50 = *(void (**)(char *, uint64_t))(v60 + 8);
      v50(v19, v61);
      unint64_t v51 = v70;
      unint64_t v52 = swift_getAssociatedConformanceWitness( (uint64_t)v74,  v73,  v70,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      char v53 = v59;
      char v54 = v75;
      (*(void (**)(unint64_t, unint64_t))(v52 + 16))(v51, v52);
      (*(void (**)(char *, unint64_t))(v63 + 8))(v54, v51);
      BOOL v55 = v42(v53, 1LL, AssociatedTypeWitness) != 1;
      v50(v53, v49);
      return v55;
    }

    uint64_t v43 = *(void (**)(char *, char *, unint64_t))(v20 + 32);
    v43(v26, v19, AssociatedTypeWitness);
    unint64_t v44 = swift_getAssociatedConformanceWitness( (uint64_t)v74,  v73,  v41,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    (*(void (**)(uint64_t, unint64_t))(v44 + 16))(v41, v44);
    if (v42(v16, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, unint64_t))(v20 + 8))(v26, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v63 + 8))(v75, v70);
      (*(void (**)(char *, const char *))(v62 + 8))(v71, v72);
      (*(void (**)(char *, uint64_t))(v60 + 8))(v16, v61);
      return 0LL;
    }

    v43(v23, v16, AssociatedTypeWitness);
    uint64_t v45 = v67;
    uint64_t v46 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v67 + 16);
    if ((v46(v26, v23, AssociatedTypeWitness, v67) & 1) != 0) {
      break;
    }
    char v47 = v46(v23, v26, AssociatedTypeWitness, v45);
    unint64_t v48 = *(void (**)(char *, unint64_t))(v20 + 8);
    v48(v23, AssociatedTypeWitness);
    v48(v26, AssociatedTypeWitness);
    if ((v47 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t))(v63 + 8))(v75, v70);
      (*(void (**)(char *, const char *))(v62 + 8))(v71, v72);
      return 0LL;
    }
  }

  uint64_t v56 = *(void (**)(char *, unint64_t))(v20 + 8);
  v56(v23, AssociatedTypeWitness);
  v56(v26, AssociatedTypeWitness);
  (*(void (**)(char *, unint64_t))(v63 + 8))(v75, v70);
  (*(void (**)(char *, const char *))(v62 + 8))(v71, v72);
  return 1LL;
}

uint64_t specialized Sequence.contains(where:)( unsigned int (*a1)(int *), uint64_t a2, unint64_t a3, int a4)
{
  unint64_t v5 = HIDWORD(a3);
  if (HIDWORD(a3) == a4)
  {
    LOBYTE(v6) = 0;
  }

  else
  {
    do
    {
      if (!(_DWORD)v5) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x69uLL,  0);
      }
      int v10 = v5;
      unsigned int v6 = (v4 != 0) | a1(&v10);
      if ((v6 & 1) != 0) {
        break;
      }
      LODWORD(v5) = v5 >> 8;
    }

    while ((_DWORD)v5 != a4);
  }

  return v6 & 1;
}

uint64_t specialized Sequence.contains(where:)( uint64_t (*a1)(void *), uint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v5 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v5 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v5)
  {
    char v13 = 0;
    return v13 & 1;
  }

  if ((a4 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain(a4, a2, a3, (char *)a4);
    __int16 v10 = 0;
    uint64_t v11 = 0LL;
    goto LABEL_17;
  }

  if ((a4 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain(a4, a2, a3, (char *)a4);
    __int16 v10 = 0;
    uint64_t v11 = 0LL;
LABEL_18:
    v22[0] = a3;
    v22[1] = a4 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v12 = v22;
  }

  else
  {
    swift_bridgeObjectRetain(a4, a2, a3, (char *)a4);
    __int16 v10 = 0;
    uint64_t v11 = 0LL;
    if ((a3 & 0x1000000000000000LL) != 0) {
LABEL_16:
    }
      uint64_t v12 = (void *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    else {
LABEL_8:
    }
      uint64_t v12 = _StringObject.sharedUTF8.getter(a3, a4);
  }

  for (uint64_t i = _decodeScalar(_:startingAt:)((uint64_t)v12, v9, v11); ; uint64_t i = *(void *)&v16._0._value)
  {
    unsigned int v17 = i;
    v11 += scalarLength;
    if (i < 0x10000)
    {
      LOWORD(v18) = i;
      goto LABEL_22;
    }

    __int16 v10 = Unicode.Scalar.UTF16View.subscript.getter(1LL, i);
    int v18 = (unsigned __int16)((v17 + 67043328) >> 10) + 55296;
    if ((v18 & 0x10000) != 0) {
      break;
    }
LABEL_22:
    LOWORD(v22[0]) = v18;
    char v19 = a1(v22);
    if (v4)
    {
      swift_bridgeObjectRelease(a4);
      return v13 & 1;
    }

    if ((v19 & 1) != 0)
    {
LABEL_29:
      swift_bridgeObjectRelease(a4);
      char v13 = 1;
      return v13 & 1;
    }

    if (v17 >= 0x10000)
    {
      LOWORD(v22[0]) = v10;
      char v20 = a1(v22);
      if ((v20 & 1) != 0) {
        goto LABEL_29;
      }
      __int16 v10 = 0;
    }

    if (v11 >= v5) {
      goto LABEL_33;
    }
    if ((a4 & 0x1000000000000000LL) == 0)
    {
      if ((a4 & 0x2000000000000000LL) != 0) {
        goto LABEL_18;
      }
      if ((a3 & 0x1000000000000000LL) == 0) {
        goto LABEL_8;
      }
      goto LABEL_16;
    }

BOOL Sequence.contains(where:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v33 = a1;
  uint64_t v34 = a2;
  uint64_t v31 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  __int16 v10 = (char *)&v30 - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  Swift::tuple_Unicode_Scalar_scalarLength_Int v16 = (char *)&v30 - v15;
  uint64_t v35 = *(void (***)(char *, unint64_t, uint64_t))(a3 - 8);
  MEMORY[0x1895F8858](v14);
  int v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v32 = *(void *)(v19 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (void (**)(char *, unint64_t, uint64_t))((char *)&v30 - v20);
  v35[2](v18, v36, a3);
  uint64_t v22 = (void (*)(uint64_t))*((void *)v31 + 4);
  uint64_t v35 = v21;
  uint64_t v23 = (uint64_t)v31;
  v22(a3);
  unint64_t v36 = v19;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v23,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v25 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  do
  {
    v25(v36, AssociatedConformanceWitness);
    int v26 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v8 + 48))(v16, 1LL, AssociatedTypeWitness);
    if (v26 == 1) {
      break;
    }
    (*(void (**)(char *, char *, unint64_t))(v8 + 32))(v10, v16, AssociatedTypeWitness);
    char v27 = v33(v10);
    if (v4)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
      break;
    }

    char v28 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
  }

  while ((v28 & 1) == 0);
  (*(void (**)(void (**)(char *, unint64_t, uint64_t), unint64_t))(v32 + 8))( v35,  v36);
  return v26 != 1;
}

BOOL Sequence.allSatisfy(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v33 = a1;
  uint64_t v34 = a2;
  uint64_t v31 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  __int16 v10 = (char *)&v30 - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  Swift::tuple_Unicode_Scalar_scalarLength_Int v16 = (char *)&v30 - v15;
  uint64_t v35 = *(void (***)(char *, unint64_t, uint64_t))(a3 - 8);
  MEMORY[0x1895F8858](v14);
  int v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v32 = *(void *)(v19 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (void (**)(char *, unint64_t, uint64_t))((char *)&v30 - v20);
  v35[2](v18, v36, a3);
  uint64_t v22 = (void (*)(uint64_t))*((void *)v31 + 4);
  uint64_t v35 = v21;
  uint64_t v23 = (uint64_t)v31;
  v22(a3);
  unint64_t v36 = v19;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v23,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v25 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  do
  {
    v25(v36, AssociatedConformanceWitness);
    int v26 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v8 + 48))(v16, 1LL, AssociatedTypeWitness);
    if (v26 == 1) {
      break;
    }
    (*(void (**)(char *, char *, unint64_t))(v8 + 32))(v10, v16, AssociatedTypeWitness);
    char v27 = v33(v10);
    if (v4)
    {
      (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
      break;
    }

    char v28 = v27;
    (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
  }

  while ((v28 & 1) != 0);
  (*(void (**)(void (**)(char *, unint64_t, uint64_t), unint64_t))(v32 + 8))( v35,  v36);
  return v26 == 1;
}

void Sequence.flatMap<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6)
{
  unint64_t v44 = a6;
  uint64_t v45 = a4;
  uint64_t v40 = a2;
  uint64_t v41 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v47 = (uint64_t)&v36 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = associated type descriptor for Sequence.Element;
  uint64_t v37 = a5;
  uint64_t v10 = v9;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v46 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v36 - v12;
  uint64_t v16 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v14, v15);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  unint64_t v19 = (char *)&v36 - v18;
  uint64_t v20 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v36 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v23 = swift_getAssociatedTypeWitness( 0LL,  a5,  v10,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v38 = *(void *)(v23 - 8);
  MEMORY[0x1895F8858](v23);
  uint64_t v25 = (_DWORD *)((char *)&v36 - v24);
  uint64_t v39 = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  v44,  v45,  (uint64_t)&protocol requirements base descriptor for Sequence,  v42);
  _swift_isClassOrObjCExistentialType((uint64_t)v39, v39);
  unint64_t v48 = &_swiftEmptyArrayStorage;
  (*(void (**)(char *, unint64_t, uint64_t))(v20 + 16))(v22, v43, v10);
  uint64_t v26 = (uint64_t)v37;
  (*((void (**)(uint64_t))v37 + 4))(v10);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v26,  v10,  v23,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  char v28 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v42 = v25;
  unint64_t v43 = v23;
  v28(v23, AssociatedConformanceWitness);
  uint64_t v29 = v28;
  uint64_t v30 = v46;
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v46 + 48);
  if (v31(v19, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_5:
    (*(void (**)(_DWORD *, unint64_t))(v38 + 8))(v42, v43);
  }

  else
  {
    uint64_t v32 = *(void (**)(char *, char *, unint64_t))(v30 + 32);
    while (1)
    {
      v32(v13, v19, AssociatedTypeWitness);
      v41(v13);
      if (v6) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v46 + 8))(v13, AssociatedTypeWitness);
      uint64_t v35 = type metadata accessor for Array(0LL, (uint64_t)v39, v33, v34);
      Array.append<A>(contentsOf:)(v47, v35, v45, (uint64_t)v44);
      v29(v43, AssociatedConformanceWitness);
      if (v31(v19, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_5;
      }
    }

    (*(void (**)(char *, unint64_t))(v46 + 8))(v13, AssociatedTypeWitness);
    (*(void (**)(_DWORD *, unint64_t))(v38 + 8))(v42, v43);
    swift_bridgeObjectRelease((uint64_t)v48);
  }

void Sequence.compactMap<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, const char *a5)
{
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  const char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t AssociatedConformanceWitness;
  void (*v34)(uint64_t, unint64_t);
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  void (*v38)(uint64_t, unint64_t);
  uint64_t v39;
  unsigned int (*v40)(char *, uint64_t, unint64_t);
  void (*v41)(uint64_t, unint64_t);
  uint64_t v42;
  void (*v43)(char *, char *, uint64_t *);
  char *v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int (*v59)(char *, uint64_t, unint64_t);
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(char *);
  uint64_t v64;
  char *v65;
  uint64_t v66;
  char *v67;
  __objc2_class **v68;
  uint64_t v6 = v5;
  uint64_t v64 = a2;
  uint64_t v63 = a1;
  uint64_t v10 = type metadata accessor for Optional(0LL, (uint64_t)a4, a3, (uint64_t)a4);
  uint64_t v56 = *(void *)(v10 - 8);
  uint64_t v57 = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v67 = (char *)&v50 - v12;
  uint64_t v62 = *(a4 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  BOOL v55 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  char v54 = (char *)&v50 - v15;
  uint64_t v66 = (uint64_t)a5;
  uint64_t v16 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v51 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v19 = (char *)&v50 - v18;
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  unint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v50 - v24;
  uint64_t v61 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v23);
  char v27 = (char *)&v50 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v28 = a5;
  uint64_t v29 = v16;
  uint64_t v30 = swift_getAssociatedTypeWitness( 0LL,  v28,  v16,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t v52 = *(void *)(v30 - 8);
  MEMORY[0x1895F8858](v30);
  uint64_t v32 = (char *)&v50 - v31;
  _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
  BOOL v68 = &_swiftEmptyArrayStorage;
  (*(void (**)(char *, char *, uint64_t))(v61 + 16))(v27, v65, v29);
  (*(void (**)(uint64_t))(v66 + 32))(v29);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v66,  v29,  v30,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v34 = *(void (**)(uint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v35 = AssociatedConformanceWitness;
  uint64_t v36 = v30;
  uint64_t v37 = v35;
  uint64_t v65 = v32;
  uint64_t v66 = v36;
  v34(v36, v35);
  uint64_t v38 = v34;
  uint64_t v39 = v51;
  uint64_t v40 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v51 + 48);
  if (v40(v25, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    (*(void (**)(char *, uint64_t))(v52 + 8))(v65, v66);
  }

  else
  {
    uint64_t v59 = v40;
    uint64_t v60 = v37;
    uint64_t v61 = *(void *)(v39 + 32);
    char v53 = v25;
    while (1)
    {
      uint64_t v41 = v38;
      ((void (*)(char *, char *, unint64_t))v61)(v19, v25, AssociatedTypeWitness);
      v63(v19);
      if (v6) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v39 + 8))(v19, AssociatedTypeWitness);
      uint64_t v42 = v62;
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v62 + 48))(v67, 1LL, a4) == 1)
      {
        (*(void (**)(char *, uint64_t))(v56 + 8))(v67, v57);
      }

      else
      {
        unint64_t v43 = *(void (**)(char *, char *, uint64_t *))(v42 + 32);
        unint64_t v44 = v54;
        v43(v54, v67, a4);
        uint64_t v58 = 0LL;
        uint64_t v45 = v44;
        uint64_t v46 = (uint64_t)v55;
        v43(v55, v45, a4);
        uint64_t v49 = type metadata accessor for Array(0LL, (uint64_t)a4, v47, v48);
        uint64_t v25 = v53;
        uint64_t v6 = v58;
        Array.append(_:)(v46, v49);
      }

      v41(v66, v60);
      uint64_t v38 = v41;
      if (v59(v25, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }

    (*(void (**)(char *, unint64_t))(v39 + 8))(v19, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v52 + 8))(v65, v66);
    swift_bridgeObjectRelease((uint64_t)v68);
  }

void Sequence._compactMap<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, const char *a5)
{
  uint64_t v6 = v5;
  uint64_t v64 = a2;
  uint64_t v63 = a1;
  uint64_t v10 = type metadata accessor for Optional(0LL, (uint64_t)a4, a3, (uint64_t)a4);
  uint64_t v56 = *(void *)(v10 - 8);
  uint64_t v57 = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v67 = (char *)&v50 - v12;
  uint64_t v62 = *(a4 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  BOOL v55 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  char v54 = (char *)&v50 - v15;
  uint64_t v66 = (uint64_t)a5;
  uint64_t v16 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v51 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v19 = (char *)&v50 - v18;
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v50 - v24;
  uint64_t v61 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v23);
  char v27 = (char *)&v50 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v28 = a5;
  uint64_t v29 = v16;
  unint64_t v30 = swift_getAssociatedTypeWitness( 0LL,  v28,  v16,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v52 = *(void *)(v30 - 8);
  MEMORY[0x1895F8858](v30);
  uint64_t v32 = (char *)&v50 - v31;
  _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
  BOOL v68 = &_swiftEmptyArrayStorage;
  (*(void (**)(char *, char *, uint64_t))(v61 + 16))(v27, v65, v29);
  (*(void (**)(uint64_t))(v66 + 32))(v29);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v66,  v29,  v30,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v34 = *(void (**)(uint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v35 = AssociatedConformanceWitness;
  uint64_t v36 = v30;
  unint64_t v37 = v35;
  uint64_t v65 = v32;
  uint64_t v66 = v36;
  v34(v36, v35);
  uint64_t v38 = v34;
  uint64_t v39 = v51;
  uint64_t v40 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v51 + 48);
  if (v40(v25, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    (*(void (**)(char *, uint64_t))(v52 + 8))(v65, v66);
  }

  else
  {
    uint64_t v59 = v40;
    unint64_t v60 = v37;
    uint64_t v61 = *(void *)(v39 + 32);
    char v53 = v25;
    while (1)
    {
      unint64_t v48 = v38;
      ((void (*)(char *, char *, unint64_t))v61)(v19, v25, AssociatedTypeWitness);
      v63(v19);
      if (v6) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v39 + 8))(v19, AssociatedTypeWitness);
      uint64_t v49 = v62;
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v62 + 48))(v67, 1LL, a4) == 1)
      {
        (*(void (**)(char *, uint64_t))(v56 + 8))(v67, v57);
      }

      else
      {
        uint64_t v41 = *(void (**)(char *, char *, uint64_t *))(v49 + 32);
        uint64_t v42 = v54;
        v41(v54, v67, a4);
        uint64_t v58 = 0LL;
        unint64_t v43 = v42;
        uint64_t v44 = (uint64_t)v55;
        v41(v55, v43, a4);
        uint64_t v47 = type metadata accessor for Array(0LL, (uint64_t)a4, v45, v46);
        uint64_t v25 = v53;
        uint64_t v6 = v58;
        Array.append(_:)(v44, v47);
      }

      v48(v66, v60);
      uint64_t v38 = v48;
      if (v59(v25, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
    }

    (*(void (**)(char *, unint64_t))(v39 + 8))(v19, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v52 + 8))(v65, v66);
    swift_bridgeObjectRelease((uint64_t)v68);
  }

uint64_t (*Set._variant.modify())()
{
  return EnumeratedSequence._base.modify;
}

__objc2_class **Set.init(minimumCapacity:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptySetSingleton;
  }
  type metadata accessor for _SetStorage(0LL, a2, a3, a4);
  return (__objc2_class **)static _SetStorage.allocate(capacity:)(a1);
}

uint64_t Set.init(_cocoa:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t Set._Variant.init(cocoa:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t Set.init(_immutableCocoaSet:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

__objc2_class **Set.init(arrayLiteral:)(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (Array._getCount()()) {
    uint64_t v6 = specialized Set.init(_nonEmptyArrayLiteral:)(a1, a2, a3);
  }
  else {
    uint64_t v6 = &_swiftEmptySetSingleton;
  }
  swift_bridgeObjectRelease(a1);
  return v6;
}

void protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance Set<A>( uint64_t a1@<X0>, uint64_t a2@<X1>, __objc2_class ***a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)(a2 + 16);
  if (Array._getCount()()) {
    uint64_t v7 = specialized Set.init(_nonEmptyArrayLiteral:)(a1, v6, *(void *)(a2 + 24));
  }
  else {
    uint64_t v7 = &_swiftEmptySetSingleton;
  }
  swift_bridgeObjectRelease(a1);
  *a3 = v7;
}

int64_t Set._Variant.makeIterator()@<X0>(int64_t result@<X0>, int64_t *a2@<X8>)
{
  if ((result & 0xC000000000000001LL) != 0)
  {
    if (result < 0) {
      uint64_t v3 = result;
    }
    else {
      uint64_t v3 = result & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v4 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v5 = (unint64_t)swift_allocObject(v4, 0xE8uLL, 7uLL);
    int64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    *(void *)(v5 + 208) = v3;
    *(void *)(v5 + 216) = 0LL;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(void *)(v5 + 224) = 0LL;
    result = v5 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v9 = -1LL;
    uint64_t v10 = -1LL << *(_BYTE *)(result + 32);
    int64_t v6 = result + 56;
    uint64_t v7 = ~v10;
    uint64_t v11 = -v10;
    if (v11 < 64) {
      uint64_t v9 = ~(-1LL << v11);
    }
    uint64_t v8 = v9 & *(void *)(result + 56);
  }

  *a2 = result;
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = 0LL;
  a2[4] = v8;
  return result;
}

uint64_t Set._Variant.contains(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(a3 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v12 = (void *)a2;
    }
    else {
      uint64_t v12 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v13 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
    id v14 = objc_msgSend(v12, sel_member_, v13);
    swift_unknownObjectRelease(v13);
    if (v14)
    {
      swift_unknownObjectRelease(v14);
      char v15 = 1;
      return v15 & 1;
    }

uint64_t Set._customContainsEquatableElement(_:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  return Set.contains(_:)(a1, a2, a3, a4) & 1;
}

__n128 protocol witness for Sequence.makeIterator() in conformance Set<A>@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *v1;
  if ((v3 & 0xC000000000000001LL) != 0)
  {
    uint64_t v4 = (void *)specialized _ArrayBuffer._nonNative.getter(v3);
    swift_unknownObjectRetain(v4, v5, v6, v7);
    swift_bridgeObjectRelease(v3);
    uint64_t v8 = type metadata accessor for __CocoaSet.Iterator();
    uint64_t v9 = swift_allocObject(v8, 0xE8uLL, 7uLL);
    *((_OWORD *)v9 + 1) = 0u;
    *((_OWORD *)v9 + 2) = 0u;
    *((_OWORD *)v9 + 3) = 0u;
    *((_OWORD *)v9 + 4) = 0u;
    *((_OWORD *)v9 + 5) = 0u;
    *((_OWORD *)v9 + 6) = 0u;
    *((_OWORD *)v9 + 7) = 0u;
    *((_OWORD *)v9 + 8) = 0u;
    *((_OWORD *)v9 + 9) = 0u;
    *((_OWORD *)v9 + 10) = 0u;
    *((_OWORD *)v9 + 11) = 0u;
    *((_OWORD *)v9 + 12) = 0u;
    v9[27] = 0LL;
    v9[28] = 0LL;
    v9[26] = v4;
    uint64_t v10 = v20;
    Set.Iterator.init(_cocoa:)((uint64_t)v9, (uint64_t)v20);
  }

  else
  {
    uint64_t v11 = -1LL << *(_BYTE *)(v3 + 32);
    uint64_t v12 = ~v11;
    uint64_t v13 = *(void *)(v3 + 56);
    uint64_t v14 = -v11;
    if (v14 < 64) {
      uint64_t v15 = ~(-1LL << v14);
    }
    else {
      uint64_t v15 = -1LL;
    }
    v20[0] = v3;
    v20[1] = v3 + 56;
    v20[2] = v12;
    v20[3] = 0LL;
    v20[4] = v15 & v13;
    uint64_t v10 = v19;
    Set.Iterator.init(_native:)((uint64_t)v20, (uint64_t)v19);
  }

  uint64_t v16 = *((void *)v10 + 4);
  __n128 result = *(__n128 *)v10;
  __int128 v18 = *((_OWORD *)v10 + 1);
  *(_OWORD *)a1 = *(_OWORD *)v10;
  *(_OWORD *)(a1 + 16) = v18;
  *(void *)(a1 + 32) = v16;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance Set<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._customContainsEquatableElement(_:) in conformance Set<A>( id *a1, uint64_t a2)
{
  return Set.contains(_:)(a1, *v2, *(uint64_t **)(a2 + 16), *(void *)(a2 + 24)) & 1;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Set<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

void Set.filter(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
}

void Set._Variant.filter(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v8 = a3;
  uint64_t v11 = type metadata accessor for Optional(0LL, (uint64_t)a4, a3, (uint64_t)a4);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v14 = *((void *)a4 - 1);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v56 = (uint64_t)&v47 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v22 = (char *)&v47 - v21;
  if ((v8 & 0xC000000000000001LL) == 0)
  {
    _NativeSet.filter(_:)((uint64_t)a1, a2, v8, (uint64_t)a4, a5);
    return;
  }

  unint64_t v48 = v20;
  uint64_t v49 = v19;
  uint64_t v50 = v17;
  uint64_t v51 = v18;
  uint64_t v59 = &_swiftEmptySetSingleton;
  if (v8 >= 0) {
    v8 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  uint64_t v23 = type metadata accessor for __CocoaSet.Iterator();
  uint64_t v27 = swift_allocObject(v23, 0xE8uLL, 7uLL);
  uint64_t v28 = 0LL;
  *((_OWORD *)v27 + 1) = 0u;
  char v54 = v27 + 2;
  *((_OWORD *)v27 + 5) = 0u;
  char v53 = v27 + 10;
  v27[27] = 0LL;
  uint64_t v57 = v27 + 27;
  *((_OWORD *)v27 + 2) = 0u;
  *((_OWORD *)v27 + 3) = 0u;
  *((_OWORD *)v27 + 4) = 0u;
  *((_OWORD *)v27 + 6) = 0u;
  *((_OWORD *)v27 + 7) = 0u;
  *((_OWORD *)v27 + 8) = 0u;
  *((_OWORD *)v27 + 9) = 0u;
  *((_OWORD *)v27 + 10) = 0u;
  *((_OWORD *)v27 + 11) = 0u;
  *((_OWORD *)v27 + 12) = 0u;
  v27[26] = v8;
  BOOL v55 = (swift *)&unk_189B8D230;
  v27[28] = 0LL;
  uint64_t v52 = v22;
  while (v28 != v27[28])
  {
LABEL_10:
    uint64_t v30 = v27[3];
    if (!v30) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
    }
    if ((unint64_t)(v28 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_27:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    uint64_t v31 = (void **)(v30 + 8 * v28);
    uint64_t v32 = *v31;
    *uint64_t v57 = v28 + 1;
    swift_unknownObjectRetain(v32, v24, v25, v26);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a4, (uint64_t *)a4))
    {
      uint64_t v58 = v32;
      swift_dynamicCast(v22, (uint64_t *)&v58, v55, a4, 7uLL);
    }

    else
    {
      uint64_t v42 = v48;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v14 + 56))(v48, 1LL, 1LL, a4);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v32, (uint64_t)a4, v42);
      swift_unknownObjectRelease(v32);
      uint64_t v43 = v50;
      uint64_t v44 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v51 + 16);
      uint64_t v47 = v14;
      uint64_t v45 = v49;
      v44(v49, v42, v50);
      if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(v47 + 48))(v45, 1LL, a4) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v51 + 8))(v42, v43);
      uint64_t v46 = v47;
      uint64_t v22 = v52;
      (*(void (**)(char *, uint64_t, char *))(v47 + 32))(v52, v45, a4);
      uint64_t v14 = v46;
    }

    char v33 = a1(v22);
    if (v5)
    {
      swift_release((uint64_t)v27);
      (*(void (**)(char *, char *))(v14 + 8))(v22, a4);
      swift_release((uint64_t)v59);
      return;
    }

    if ((v33 & 1) != 0)
    {
      (*(void (**)(uint64_t, char *, char *))(v14 + 32))(v56, v22, a4);
      unint64_t v35 = v59;
      uint64_t v36 = v59[2];
      if (v59[3] <= v36)
      {
        uint64_t v37 = v14;
        uint64_t v38 = a1;
        uint64_t v39 = a2;
        Swift::Int v40 = (Swift::Int)&v36->isa + 1;
        type metadata accessor for _NativeSet(0LL, (uint64_t)a4, a5, v34);
        Swift::Int v41 = v40;
        a2 = v39;
        a1 = v38;
        uint64_t v14 = v37;
        uint64_t v22 = v52;
        _NativeSet.resize(capacity:)(v41);
        unint64_t v35 = v59;
      }

      _NativeSet._unsafeInsertNew(_:)(v56, (uint64_t)v35, (uint64_t)a4, a5);
    }

    else
    {
      (*(void (**)(char *, char *))(v14 + 8))(v22, a4);
    }

    uint64_t v28 = *v57;
    if (*v57 < 0) {
      goto LABEL_25;
    }
  }

  id v29 = objc_msgSend((id)v27[26], sel_countByEnumeratingWithState_objects_count_, v54, v53, 16);
  v27[28] = v29;
  if (v29)
  {
    uint64_t v28 = 0LL;
    *uint64_t v57 = 0LL;
    goto LABEL_10;
  }

  *uint64_t v57 = -1LL;
LABEL_25:
  swift_release((uint64_t)v27);
}

unint64_t Set.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return _NativeSet.startIndex.getter(a1);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      uint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_, v8 + 3);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaSet.Index.Storage();
      uint64_t v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t Set._Variant.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return _NativeSet.startIndex.getter(a1);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      uint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_, v8 + 3);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaSet.Index.Storage();
      uint64_t v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t Set.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return 1LL << *(_BYTE *)(a1 + 32);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      uint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_, v8 + 3);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaSet.Index.Storage();
      uint64_t v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t Set._Variant.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return 1LL << *(_BYTE *)(a1 + 32);
  }
  if (a1 < 0) {
    uint64_t v5 = (void *)a1;
  }
  else {
    uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v6 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v5, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v6 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v6, 24LL))
    {
      uint64_t v8 = swift_bufferAllocate(result, 8 * v6 + 24, 7uLL);
      v8[2] = v6;
      objc_msgSend(v5, sel_getObjects_, v8 + 3);
      swift_bridgeObjectRelease(a1);
      uint64_t v9 = type metadata accessor for __CocoaSet.Index.Storage();
      uint64_t v10 = swift_allocObject(v9, 0x20uLL, 7uLL);
      v10[2] = v5;
      v10[3] = v8;
      swift_bridgeObjectRetain(a1, v11, v12, v13);
      return (unint64_t)v10;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

void Set.subscript.getter( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X5>, char *a6@<X8>)
{
  uint64_t v12 = *((void *)a4 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  if ((v18 & 0xC000000000000001LL) != 0)
  {
    if ((v16 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
    }
    if (a1 >= 0) {
      uint64_t v19 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v19 = a1;
    }
    uint64_t v20 = type metadata accessor for __CocoaSet.Index.Storage();
    if (swift_dynamicCastClass(v19, v20))
    {
      uint64_t v24 = *(void *)(v19 + 24);
      if (*(void *)(v24 + 16) > a2)
      {
        uint64_t v25 = *(void **)(v24 + 8 * a2 + 24);
        id v26 = swift_unknownObjectRetain(v25, v21, v22, v23);
        _forceBridgeFromObjectiveC<A>(_:_:)(v26, a4, v27, a6);
        swift_unknownObjectRelease(v25);
        return;
      }

void Set._Variant.element(at:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X5>, char *a6@<X8>)
{
  uint64_t v12 = *((void *)a4 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  if ((v18 & 0xC000000000000001LL) != 0)
  {
    if ((v16 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
    }
    if (a1 >= 0) {
      uint64_t v19 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v19 = a1;
    }
    uint64_t v20 = type metadata accessor for __CocoaSet.Index.Storage();
    if (swift_dynamicCastClass(v19, v20))
    {
      uint64_t v24 = *(void *)(v19 + 24);
      if (*(void *)(v24 + 16) > a2)
      {
        uint64_t v25 = *(void **)(v24 + 8 * a2 + 24);
        id v26 = swift_unknownObjectRetain(v25, v21, v22, v23);
        _forceBridgeFromObjectiveC<A>(_:_:)(v26, a4, v27, a6);
        swift_unknownObjectRelease(v25);
        return;
      }

int64_t Set.index(after:)(int64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  int64_t v5 = a1;
  int v6 = a3 & 1;
  if ((a4 & 0xC000000000000001LL) == 0) {
    return _NativeSet.index(after:)(a1, a2, v6, a4);
  }
  if (a4 < 0) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = a4 & 0xFFFFFFFFFFFFFF8LL;
  }
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
  }
  if (a1 >= 0) {
    uint64_t v8 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v8 = a1;
  }
  outlined copy of [A : B].Index._Variant<A, B>(a1, a2, 1LL, (char *)a4);
  uint64_t v9 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v8, v9)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v8 + 16) != v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x169uLL,  0);
  }
  if (*(void *)(*(void *)(v8 + 24) + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x16BuLL,  0);
  }
  return v5;
}

int64_t Set._Variant.index(after:)(int64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  int64_t v5 = a1;
  int v6 = a3 & 1;
  if ((a4 & 0xC000000000000001LL) == 0) {
    return _NativeSet.index(after:)(a1, a2, v6, a4);
  }
  if (a4 < 0) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = a4 & 0xFFFFFFFFFFFFFF8LL;
  }
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
  }
  if (a1 >= 0) {
    uint64_t v8 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v8 = a1;
  }
  outlined copy of [A : B].Index._Variant<A, B>(a1, a2, 1LL, (char *)a4);
  uint64_t v9 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v8, v9)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v8 + 16) != v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x169uLL,  0);
  }
  if (*(void *)(*(void *)(v8 + 24) + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x16BuLL,  0);
  }
  return v5;
}

void Set._Variant.formIndex(after:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(a1 + 8);
  char v6 = *(_BYTE *)(a1 + 16);
  unint64_t v7 = a2 & 0xC000000000000001LL;
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    int64_t v17 = _NativeSet.index(after:)(*(void *)a1, v5, v6, a2);
    uint64_t v16 = v18;
    outlined consume of [A : B].Index._Variant<A, B>(v4, v5, v6);
    *(void *)a1 = v17;
    goto LABEL_20;
  }

  if ((*(_BYTE *)(a1 + 16) & 1) == 0)
  {
    unint64_t v19 = 1383LL;
    goto LABEL_26;
  }

  if (v4 >= 0) {
    unint64_t v8 = v4 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    unint64_t v8 = *(void *)a1;
  }
  uint64_t v9 = type metadata accessor for __CocoaSet.Index.Storage();
  swift_bridgeObjectRetain(v4, v10, v11, v12);
  if (!swift_dynamicCastClass(v8, v9)) {
LABEL_23:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  outlined consume of [A : B].Index._Variant<A, B>(v4, v5, 1);
  if (v8) {
    swift_isUniquelyReferenced_nonNull_native(v8);
  }
  if (*(_BYTE *)(a1 + 16) != 1)
  {
    unint64_t v19 = 1391LL;
LABEL_26:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  v19,  0);
  }

  uint64_t v13 = *(void *)(a1 + 8);
  else {
    unint64_t v14 = *(void *)a1;
  }
  if (!swift_dynamicCastClass(v14, v9)) {
    goto LABEL_23;
  }
  uint64_t v15 = a2 & 0xFFFFFFFFFFFFFF8LL;
  if (a2 < 0) {
    uint64_t v15 = a2;
  }
  if (*(void *)(v14 + 16) != v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x169uLL,  0);
  }
  if (v13 >= *(void *)(*(void *)(v14 + 24) + 16LL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x16BuLL,  0);
  }
  uint64_t v16 = v13 + 1;
LABEL_20:
  *(void *)(a1 + 8) = v16;
  *(_BYTE *)(a1 + 16) = v7 != 0;
}

unint64_t Set.firstIndex(of:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(a3 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v44 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 0xC000000000000001LL) != 0)
  {
    uint64_t v12 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
    if (a2 < 0) {
      uint64_t v13 = (void *)a2;
    }
    else {
      uint64_t v13 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v14 = objc_msgSend(v13, sel_member_, v12);
    if (v14)
    {
      swift_unknownObjectRelease(v14);
      unint64_t v18 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v13, v15, v16, v17), sel_count);
      unint64_t v19 = type metadata accessor for __BridgingBufferStorage(0LL);
      if ((v18 - 0x1000000000000000LL) >> 61 == 7)
      {
        if (!__OFADD__(8 * v18, 24LL))
        {
          uint64_t v20 = swift_bufferAllocate(v19, 8 * v18 + 24, 7uLL);
          v20[2] = v18;
          objc_msgSend(v13, sel_getObjects_, v20 + 3);
          swift_bridgeObjectRelease(a2);
          if ((v20[2] & 0x8000000000000000LL) == 0)
          {
            swift_unknownObjectRetain(v20, v21, v22, v23);
            uint64_t v27 = 0LL;
            do
            {
              uint64_t v28 = v27 + 1;
              uint64_t v29 = (void *)v20[v27 + 3];
              swift_unknownObjectRetain(v29, v24, v25, v26);
              char isEqual = swift_stdlib_NSObject_isEqual(v12, v29);
              swift_unknownObjectRelease(v29);
              uint64_t v27 = v28;
            }

            while ((isEqual & 1) == 0);
            swift_unknownObjectRelease(v20);
            uint64_t v31 = type metadata accessor for __CocoaSet.Index.Storage();
            unint64_t v32 = (unint64_t)swift_allocObject(v31, 0x20uLL, 7uLL);
            *(void *)(v32 + 16) = v13;
            *(void *)(v32 + 24) = v20;
            swift_unknownObjectRetain(v13, v33, v34, v35);
            swift_unknownObjectRelease(v12);
            return v32;
          }

unint64_t Set._Variant.index(for:)(id *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(a3 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v44 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 0xC000000000000001LL) != 0)
  {
    uint64_t v12 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
    if (a2 < 0) {
      uint64_t v13 = (void *)a2;
    }
    else {
      uint64_t v13 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v14 = objc_msgSend(v13, sel_member_, v12);
    if (v14)
    {
      swift_unknownObjectRelease(v14);
      unint64_t v18 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v13, v15, v16, v17), sel_count);
      unint64_t v19 = type metadata accessor for __BridgingBufferStorage(0LL);
      if ((v18 - 0x1000000000000000LL) >> 61 == 7)
      {
        if (!__OFADD__(8 * v18, 24LL))
        {
          uint64_t v20 = swift_bufferAllocate(v19, 8 * v18 + 24, 7uLL);
          v20[2] = v18;
          objc_msgSend(v13, sel_getObjects_, v20 + 3);
          swift_bridgeObjectRelease(a2);
          if ((v20[2] & 0x8000000000000000LL) == 0)
          {
            swift_unknownObjectRetain(v20, v21, v22, v23);
            uint64_t v27 = 0LL;
            do
            {
              uint64_t v28 = v27 + 1;
              uint64_t v29 = (void *)v20[v27 + 3];
              swift_unknownObjectRetain(v29, v24, v25, v26);
              char isEqual = swift_stdlib_NSObject_isEqual(v12, v29);
              swift_unknownObjectRelease(v29);
              uint64_t v27 = v28;
            }

            while ((isEqual & 1) == 0);
            swift_unknownObjectRelease(v20);
            uint64_t v31 = type metadata accessor for __CocoaSet.Index.Storage();
            unint64_t v32 = (unint64_t)swift_allocObject(v31, 0x20uLL, 7uLL);
            *(void *)(v32 + 16) = v13;
            *(void *)(v32 + 24) = v20;
            swift_unknownObjectRetain(v13, v33, v34, v35);
            swift_unknownObjectRelease(v12);
            return v32;
          }

id Set.count.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 16);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

id Set._Variant.count.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 16);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

BOOL Set.isEmpty.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 >= 0) {
      a1 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    id v1 = objc_msgSend((id)a1, sel_count);
  }

  else
  {
    id v1 = *(id *)(a1 + 16);
  }

  return v1 == 0LL;
}

uint64_t protocol witness for Collection.startIndex.getter in conformance Set<A>@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance [A : B]( (uint64_t (*)(void))Set.startIndex.getter,  a1);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance Set<A>@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Collection.startIndex.getter in conformance [A : B]( (uint64_t (*)(void))Set.endIndex.getter,  a1);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Set<A>( char ***a1, uint64_t a2, uint64_t a3))()
{
  unint64_t v7 = (char **)malloc(0x28uLL);
  *a1 = v7;
  v7[4] = (char *)Set.subscript.read( v7,  *(void *)a2,  *(void *)(a2 + 8),  *(unsigned __int8 *)(a2 + 16),  *v3,  *(char **)(a3 + 16),  *(void *)(a3 + 24));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*Set.subscript.read( char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7))()
{
  uint64_t v13 = *((void *)a6 - 1);
  *a1 = a6;
  a1[1] = (char *)v13;
  id v14 = (char *)malloc(*(void *)(v13 + 64));
  a1[2] = v14;
  Set.subscript.getter(a2, a3, a5, a6, a7, v14);
  return _ArrayBuffer.subscript.read;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance Set<A>()
{
  return Set.isEmpty.getter(*v0);
}

id protocol witness for Collection.count.getter in conformance Set<A>()
{
  return Set.count.getter(*v0);
}

unint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance Set<A>@<X0>( id *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result = Set.firstIndex(of:)(a1, *v3, *(uint64_t **)(a2 + 16), *(void *)(a2 + 24));
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v6;
  *(_BYTE *)(a3 + 16) = v7;
  return result;
}

int64_t protocol witness for Collection.index(after:) in conformance Set<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int64_t result = Set.index(after:)(*(void *)a1, *(void *)(a1 + 8), *(_BYTE *)(a1 + 16), *v2);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v5;
  *(_BYTE *)(a2 + 16) = v6 & 1;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance Set<A>(uint64_t a1, uint64_t a2)
{
  return Set.formIndex(after:)(a1, *v2, *(void *)(a2 + 16), *(void *)(a2 + 24));
}

uint64_t specialized static Set.== infix(_:_:)(uint64_t result, uint64_t a2)
{
  if (result == a2) {
    return 1LL;
  }
  if (*(void *)(result + 16) != *(void *)(a2 + 16)) {
    return 0LL;
  }
  int64_t v3 = 0LL;
  uint64_t v4 = result + 56;
  uint64_t v5 = 1LL << *(_BYTE *)(result + 32);
  if (v5 < 64) {
    uint64_t v6 = ~(-1LL << v5);
  }
  else {
    uint64_t v6 = -1LL;
  }
  unint64_t v7 = v6 & *(void *)(result + 56);
  int64_t v8 = (unint64_t)(v5 + 63) >> 6;
  uint64_t v9 = a2 + 56;
  uint64_t v32 = result + 56;
  uint64_t v33 = result;
  int64_t v31 = v8;
  if (v7) {
    goto LABEL_7;
  }
LABEL_8:
  int64_t v11 = v3 + 1;
  if (__OFADD__(v3, 1LL))
  {
    __break(1u);
    goto LABEL_32;
  }

  if (v11 >= v8) {
    return 1LL;
  }
  unint64_t v12 = *(void *)(v4 + 8 * v11);
  int64_t v13 = v3 + 1;
  if (!v12)
  {
    int64_t v13 = v11 + 1;
    if (v11 + 1 >= v8) {
      return 1LL;
    }
    unint64_t v12 = *(void *)(v4 + 8 * v13);
    if (!v12)
    {
      int64_t v14 = v11 + 2;
      if (v14 < v8)
      {
        unint64_t v12 = *(void *)(v4 + 8 * v14);
        if (v12)
        {
          int64_t v13 = v14;
          goto LABEL_19;
        }

        while (1)
        {
          int64_t v13 = v14 + 1;
          if (__OFADD__(v14, 1LL)) {
            break;
          }
          if (v13 >= v8) {
            return 1LL;
          }
          unint64_t v12 = *(void *)(v4 + 8 * v13);
          ++v14;
          if (v12) {
            goto LABEL_19;
          }
        }

void static Set.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(a3 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  int64_t v11 = (char *)&v44 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  int64_t v14 = (char *)&v44 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v44 - v16;
  unint64_t v19 = v18 & 0xC000000000000001LL;
  if ((v15 & 0xC000000000000001LL) != 0)
  {
    if (v7 < 0) {
      uint64_t v20 = (void *)v7;
    }
    else {
      uint64_t v20 = (void *)(v7 & 0xFFFFFFFFFFFFFF8LL);
    }
    if (v19)
    {
      if (a2 < 0) {
        uint64_t v21 = (void *)a2;
      }
      else {
        uint64_t v21 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_stdlib_NSObject_isEqual(v20, v21);
      return;
    }

    uint64_t v22 = a2;
LABEL_16:
    _NativeSet.isEqual(to:)(v20, v22, a3);
    return;
  }

  if (v19)
  {
    if (a2 < 0) {
      uint64_t v20 = (void *)a2;
    }
    else {
      uint64_t v20 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v22 = v7;
    goto LABEL_16;
  }

  if (v7 == a2 || *(void *)(v7 + 16) != *(void *)(a2 + 16)) {
    return;
  }
  int64_t v23 = 0LL;
  uint64_t v24 = *(void *)(v7 + 56);
  uint64_t v45 = v7 + 56;
  __int128 v46 = (char *)&v44 - v16;
  uint64_t v25 = 1LL << *(_BYTE *)(v7 + 32);
  if (v25 < 64) {
    uint64_t v26 = ~(-1LL << v25);
  }
  else {
    uint64_t v26 = -1LL;
  }
  unint64_t v27 = v26 & v24;
  uint64_t v48 = a4;
  int64_t v49 = (unint64_t)(v25 + 63) >> 6;
  uint64_t v54 = a2 + 56;
  BOOL v55 = v14;
  uint64_t v47 = v7;
  if (!v27) {
    goto LABEL_25;
  }
LABEL_23:
  uint64_t v50 = (v27 - 1) & v27;
  int64_t v51 = v23;
  for (unint64_t i = __clz(__rbit64(v27)) | (v23 << 6); ; unint64_t i = __clz(__rbit64(v30)) + (v31 << 6))
  {
    uint64_t v33 = *(void *)(v8 + 72);
    unint64_t v34 = *(void *)(v7 + 48) + v33 * i;
    uint64_t v52 = *(void (**)(char *, unint64_t, uint64_t *))(v8 + 16);
    uint64_t v53 = v33;
    v52(v17, v34, a3);
    (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v14, v17, a3);
    uint64_t v35 = (*(uint64_t (**)(void, uint64_t *, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
    uint64_t v36 = -1LL << *(_BYTE *)(a2 + 32);
    unint64_t v37 = v35 & ~v36;
    if (((*(void *)(v54 + ((v37 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v37) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t *))(v8 + 8))(v55, a3);
      return;
    }

    uint64_t v38 = v8;
    uint64_t v39 = ~v36;
    uint64_t v40 = *(void *)(a4 + 8);
    uint64_t v41 = *(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v40 + 8);
    while (1)
    {
      v52(v11, *(void *)(a2 + 48) + v37 * v53, a3);
      char v42 = v41(v11, v55, a3, v40);
      __int128 v43 = *(void (**)(char *, uint64_t *))(v38 + 8);
      v43(v11, a3);
      if ((v42 & 1) != 0) {
        break;
      }
      unint64_t v37 = (v37 + 1) & v39;
      if (((*(void *)(v54 + ((v37 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v37) & 1) == 0)
      {
        v43(v55, a3);
        return;
      }
    }

    int64_t v14 = v55;
    v43(v55, a3);
    uint64_t v8 = v38;
    uint64_t v7 = v47;
    a4 = v48;
    uint64_t v17 = v46;
    unint64_t v27 = v50;
    int64_t v23 = v51;
    if (v50) {
      goto LABEL_23;
    }
LABEL_25:
    int64_t v29 = v23 + 1;
    if (__OFADD__(v23, 1LL))
    {
      __break(1u);
      goto LABEL_46;
    }

    if (v29 >= v49) {
      return;
    }
    unint64_t v30 = *(void *)(v45 + 8 * v29);
    int64_t v31 = v23 + 1;
    if (!v30)
    {
      int64_t v31 = v29 + 1;
      if (v29 + 1 >= v49) {
        return;
      }
      unint64_t v30 = *(void *)(v45 + 8 * v31);
      if (!v30) {
        break;
      }
    }

BOOL Set._Variant.isNative.getter(uint64_t a1)
{
  return (a1 & 0xC000000000000001LL) == 0;
}

id Set._Variant.asCocoa.getter(uint64_t a1)
{
  id v1 = (void *)specialized _ArrayBuffer._nonNative.getter(a1);
  return swift_unknownObjectRetain(v1, v2, v3, v4);
}

uint64_t __CocoaSet.isEqual(to:)(void *a1, void *a2)
{
  return swift_stdlib_NSObject_isEqual(a2, a1);
}

void protocol witness for static Equatable.== infix(_:_:) in conformance Set<A>( uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  static Set.== infix(_:_:)(*a1, *a2, *(uint64_t **)(a3 + 16), *(void *)(a3 + 24));
}

void specialized Set.hash(into:)(__int128 *a1, unint64_t a2)
{
  uint64_t v3 = *((void *)a1 + 8);
  __int128 v4 = a1[1];
  __int128 v40 = *a1;
  __int128 v41 = v4;
  __int128 v5 = a1[3];
  __int128 v42 = a1[2];
  __int128 v43 = v5;
  uint64_t v44 = v3;
  Swift::Int v9 = Hasher._finalize()();
  unint64_t v10 = a2 + 56;
  uint64_t v11 = -1LL;
  uint64_t v12 = -1LL << *(_BYTE *)(a2 + 32);
  if (-v12 < 64) {
    uint64_t v11 = ~(-1LL << -(char)v12);
  }
  unint64_t v13 = v11 & *(void *)(a2 + 56);
  int64_t v31 = (unint64_t)(63 - v12) >> 6;
  swift_bridgeObjectRetain(a2, v6, v7, v8);
  int64_t v17 = 0LL;
  Swift::UInt v18 = 0LL;
  if (!v13) {
    goto LABEL_6;
  }
LABEL_4:
  uint64_t v19 = (v13 - 1) & v13;
  unint64_t v20 = __clz(__rbit64(v13)) | (v17 << 6);
  int64_t v21 = v17;
LABEL_5:
  outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v20, (uint64_t)&v37);
  int64_t v22 = v21;
  while (1)
  {
    uint64_t v25 = swift_retain((unint64_t *)a2, v14, v15, v16);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v25);
    if (!*((void *)&v38 + 1))
    {
      swift_release(a2);
      Hasher._combine(_:)(v18);
      return;
    }

    v35[0] = v37;
    v35[1] = v38;
    uint64_t v26 = v39;
    uint64_t v36 = v39;
    uint64_t v27 = *((void *)&v38 + 1);
    __swift_project_boxed_opaque_existential_0Tm(v35, *((uint64_t *)&v38 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v26 + 8))(v32, v27, v26);
    uint64_t v28 = v33;
    uint64_t v29 = v34;
    __swift_project_boxed_opaque_existential_0Tm(v32, v33);
    uint64_t v30 = (*(uint64_t (**)(Swift::Int, uint64_t, uint64_t))(v29 + 40))(v9, v28, v29);
    __swift_destroy_boxed_opaque_existential_1Tm(v32);
    outlined destroy of AnyHashable((uint64_t *)v35);
    v18 ^= v30;
    int64_t v17 = v22;
    unint64_t v13 = v19;
    if (v19) {
      goto LABEL_4;
    }
LABEL_6:
    int64_t v21 = v17 + 1;
    if (__OFADD__(v17, 1LL))
    {
      __break(1u);
      goto LABEL_27;
    }

    int64_t v22 = v17;
    if (v21 < v31)
    {
      unint64_t v23 = *(void *)(v10 + 8 * v21);
      if (v23) {
        goto LABEL_9;
      }
      int64_t v22 = v17 + 1;
      if (v17 + 2 < v31)
      {
        unint64_t v23 = *(void *)(v10 + 8 * (v17 + 2));
        if (v23)
        {
          int64_t v21 = v17 + 2;
LABEL_9:
          uint64_t v19 = (v23 - 1) & v23;
          unint64_t v20 = __clz(__rbit64(v23)) + (v21 << 6);
          goto LABEL_5;
        }

        int64_t v24 = v17 + 3;
        int64_t v22 = v17 + 2;
        if (v17 + 3 < v31) {
          break;
        }
      }
    }

void Set.hash(into:)(__int128 *a1, int64_t a2, char *a3, uint64_t a4)
{
  uint64_t v68 = a4;
  uint64_t v7 = *((void *)a3 - 1);
  MEMORY[0x1895F8858](a1);
  Swift::Int v9 = (char *)&v54 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v57 = type metadata accessor for Optional(0LL, v10, v10, v11);
  uint64_t v56 = *(void *)(v57 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v57);
  BOOL v55 = (char *)&v54 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v58 = (uint64_t *)((char *)&v54 - v15);
  MEMORY[0x1895F8858](v14);
  int64_t v17 = (char *)&v54 - v16;
  uint64_t v18 = *((void *)a1 + 8);
  __int128 v19 = a1[1];
  __int128 v70 = *a1;
  __int128 v71 = v19;
  __int128 v20 = a1[2];
  __int128 v21 = a1[3];
  unint64_t v60 = a1;
  __int128 v72 = v20;
  __int128 v73 = v21;
  uint64_t v74 = v18;
  Swift::Int v67 = Hasher._finalize()();
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v25 = a2;
    }
    else {
      uint64_t v25 = a2 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v26 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v27 = (unint64_t)swift_allocObject(v26, 0xE8uLL, 7uLL);
    int64_t v63 = 0LL;
    uint64_t v28 = 0LL;
    unint64_t v29 = 0LL;
    *(void *)(v27 + 208) = v25;
    *(void *)(v27 + 216) = 0LL;
    *(_OWORD *)(v27 + 16) = 0u;
    *(_OWORD *)(v27 + 32) = 0u;
    *(_OWORD *)(v27 + 48) = 0u;
    *(_OWORD *)(v27 + 64) = 0u;
    *(_OWORD *)(v27 + 80) = 0u;
    *(_OWORD *)(v27 + 96) = 0u;
    *(_OWORD *)(v27 + 112) = 0u;
    *(_OWORD *)(v27 + 128) = 0u;
    *(_OWORD *)(v27 + 144) = 0u;
    *(_OWORD *)(v27 + 160) = 0u;
    *(_OWORD *)(v27 + 176) = 0u;
    *(_OWORD *)(v27 + 192) = 0u;
    *(void *)(v27 + 224) = 0LL;
    unint64_t v30 = v27 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v31 = -1LL << *(_BYTE *)(a2 + 32);
    uint64_t v28 = ~v31;
    uint64_t v32 = *(void *)(a2 + 56);
    int64_t v63 = a2 + 56;
    uint64_t v33 = -v31;
    if (v33 < 64) {
      uint64_t v34 = ~(-1LL << v33);
    }
    else {
      uint64_t v34 = -1LL;
    }
    unint64_t v29 = v34 & v32;
    unint64_t v30 = a2;
  }

  uint64_t v35 = v30 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v61 = (v30 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v62 = (v30 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v59 = v28;
  int64_t v36 = (unint64_t)(v28 + 64) >> 6;
  swift_bridgeObjectRetain(a2, v22, v23, v24);
  Swift::UInt v40 = 0LL;
  int64_t v65 = 0LL;
  uint64_t v64 = (swift *)&unk_189B8D230;
  unint64_t v66 = v30;
  if ((v30 & 0x8000000000000000LL) != 0) {
    goto LABEL_13;
  }
  while (1)
  {
    if (v29)
    {
      unint64_t v41 = __clz(__rbit64(v29));
      v29 &= v29 - 1;
      unint64_t v42 = v41 | (v65 << 6);
      goto LABEL_29;
    }

    int64_t v48 = v65 + 1;
    if (__OFADD__(v65, 1LL))
    {
      __break(1u);
LABEL_41:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
    }

    if (v48 >= v36) {
      goto LABEL_35;
    }
    unint64_t v49 = *(void *)(v63 + 8 * v48);
    int64_t v50 = v65 + 1;
    if (!v49) {
      break;
    }
LABEL_28:
    unint64_t v29 = (v49 - 1) & v49;
    unint64_t v42 = __clz(__rbit64(v49)) + (v50 << 6);
    int64_t v65 = v50;
LABEL_29:
    (*(void (**)(char *, unint64_t, char *))(v7 + 16))( v17,  *(void *)(v30 + 48) + *(void *)(v7 + 72) * v42,  a3);
LABEL_30:
    int64_t v51 = *(void (**)(char *, uint64_t, uint64_t, char *))(v7 + 56);
    while (1)
    {
      v51(v17, 0LL, 1LL, a3);
      (*(void (**)(char *, char *, char *))(v7 + 32))(v9, v17, a3);
      uint64_t v52 = (*(uint64_t (**)(Swift::Int, char *))(v68 + 32))(v67, a3);
      (*(void (**)(char *, char *))(v7 + 8))(v9, a3);
      v40 ^= v52;
      unint64_t v30 = v66;
      if ((v66 & 0x8000000000000000LL) == 0) {
        break;
      }
LABEL_13:
      uint64_t v43 = *(void *)(v35 + 216);
      if (v43 < 0) {
        goto LABEL_35;
      }
      if (v43 == *(void *)(v35 + 224))
      {
        id v44 = objc_msgSend(*(id *)(v35 + 208), sel_countByEnumeratingWithState_objects_count_, v62, v61, 16);
        *(void *)(v35 + 224) = v44;
        if (!v44)
        {
          *(void *)(v35 + 216) = -1LL;
          goto LABEL_35;
        }

        uint64_t v43 = 0LL;
        *(void *)(v35 + 216) = 0LL;
      }

      uint64_t v45 = *(void *)(v35 + 24);
      if (!v45) {
        goto LABEL_41;
      }
      __int128 v46 = (void **)(v45 + 8 * v43);
      uint64_t v47 = *v46;
      *(void *)(v35 + 216) = v43 + 1;
      swift_unknownObjectRetain(v47, v37, v38, v39);
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
      {
        unint64_t v69 = v47;
        swift_dynamicCast(v17, (uint64_t *)&v69, v64, a3, 7uLL);
        goto LABEL_30;
      }

      int64_t v51 = *(void (**)(char *, uint64_t, uint64_t, char *))(v7 + 56);
      v51((char *)v58, 1LL, 1LL, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v47, (uint64_t)a3, v58);
      swift_unknownObjectRelease(v47);
      uint64_t v53 = v55;
      (*(void (**)(char *, uint64_t *, uint64_t))(v56 + 16))(v55, v58, v57);
      if ((*(unsigned int (**)(char *, uint64_t, char *))(v7 + 48))(v53, 1LL, a3) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v56 + 8))(v58, v57);
      (*(void (**)(char *, char *, char *))(v7 + 32))(v17, v53, a3);
    }
  }

  while (1)
  {
    int64_t v50 = v48 + 1;
    if (__OFADD__(v48, 1LL))
    {
      __break(1u);
LABEL_38:
      __break(1u);
LABEL_39:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    if (v50 >= v36) {
      break;
    }
    unint64_t v49 = *(void *)(v63 + 8 * v50);
    ++v48;
    if (v49) {
      goto LABEL_28;
    }
  }

Swift::Int Set.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Array<A>.hashValue.getter( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t, uint64_t))Set.hash(into:));
}

Swift::Int Array<A>.hashValue.getter( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *, uint64_t, uint64_t, uint64_t))
{
  v5[0] = 0LL;
  v5[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v5[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v5[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  a4(v5, a1, a2, a3);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Set<A>(uint64_t a1)
{
  return Set.hashValue.getter(*v1, *(void *)(a1 + 16), *(void *)(a1 + 24));
}

void protocol witness for Hashable.hash(into:) in conformance Set<A>(__int128 *a1, uint64_t a2)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Set<A>(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v4 = 0LL;
  *((void *)&v4 + 1) = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  uint64_t v5 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v6 = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  uint64_t v7 = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  Set.hash(into:)(&v4, *v2, *(char **)(a2 + 16), *(void *)(a2 + 24));
  return Hasher._finalize()();
}

uint64_t Set._toCustomAnyHashable()@<X0>( int64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, int64_t *a4@<X8>)
{
  __int128 v8 = specialized _setUpCast<A, B>(_:)(a1, a2);
  uint64_t result = type metadata accessor for _SetAnyHashableBox(0LL, (uint64_t)a2, a3, v9);
  a4[3] = result;
  a4[4] = (int64_t)&protocol witness table for _SetAnyHashableBox<A>;
  *a4 = a1;
  a4[1] = (int64_t)v8;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Set<A>@<X0>( uint64_t a1@<X0>, int64_t *a2@<X8>)
{
  return Set._toCustomAnyHashable()(*v2, *(swift **)(a1 + 16), *(void *)(a1 + 24), a2);
}

void specialized _setUpCast<A, B>(_:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5) {
    uint64_t v6 = (unint64_t *)specialized static _SetStorage.allocate(capacity:)(v5);
  }
  else {
    uint64_t v6 = (unint64_t *)&_swiftEmptySetSingleton;
  }
  unint64_t v7 = a1 + 56;
  uint64_t v8 = -1LL;
  uint64_t v9 = -1LL << *(_BYTE *)(a1 + 32);
  if (-v9 < 64) {
    uint64_t v8 = ~(-1LL << -(char)v9);
  }
  unint64_t v10 = v8 & *(void *)(a1 + 56);
  int64_t v11 = (unint64_t)(63 - v9) >> 6;
  swift_retain(v6, a2, a3, a4);
  swift_bridgeObjectRetain(a1, v12, v13, v14);
  int64_t v18 = 0LL;
  if (!v10) {
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v19 = (v10 - 1) & v10;
  unint64_t v20 = __clz(__rbit64(v10)) | (v18 << 6);
  int64_t v21 = v18;
LABEL_8:
  outlined init with copy of AnyHashable(*(void *)(a1 + 48) + 40 * v20, (uint64_t)&v28);
  int64_t v22 = v21;
  while (1)
  {
    uint64_t v25 = swift_retain((unint64_t *)a1, v15, v16, v17);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v25);
    if (!*((void *)&v29 + 1))
    {
      swift_release(a1);
      swift_release((uint64_t)v6);
      return;
    }

    v26[0] = v28;
    v26[1] = v29;
    uint64_t v27 = v30;
    specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)v26, (uint64_t)v6);
    int64_t v18 = v22;
    unint64_t v10 = v19;
    if (v19) {
      goto LABEL_7;
    }
LABEL_9:
    int64_t v21 = v18 + 1;
    if (__OFADD__(v18, 1LL))
    {
      __break(1u);
      goto LABEL_30;
    }

    int64_t v22 = v18;
    if (v21 < v11)
    {
      unint64_t v23 = *(void *)(v7 + 8 * v21);
      if (v23) {
        goto LABEL_12;
      }
      int64_t v22 = v18 + 1;
      if (v18 + 2 < v11)
      {
        unint64_t v23 = *(void *)(v7 + 8 * (v18 + 2));
        if (v23)
        {
          int64_t v21 = v18 + 2;
LABEL_12:
          uint64_t v19 = (v23 - 1) & v23;
          unint64_t v20 = __clz(__rbit64(v23)) + (v21 << 6);
          goto LABEL_8;
        }

        int64_t v24 = v18 + 3;
        int64_t v22 = v18 + 2;
        if (v18 + 3 < v11) {
          break;
        }
      }
    }

unint64_t *specialized _setUpCast<A, B>(_:)(int64_t a1, swift *a2)
{
  uint64_t v4 = *((void *)a2 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (uint64_t *)((char *)&v57 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v10 = type metadata accessor for Optional(0LL, v7, v8, v9);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v57 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64_t v17 = (uint64_t *)((char *)&v57 - v16);
  MEMORY[0x1895F8858](v15);
  int64_t v22 = (char *)&v57 - v21;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      unint64_t v23 = (void *)a1;
    }
    else {
      unint64_t v23 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v24 = objc_msgSend(v23, sel_count);
    if (v24) {
      goto LABEL_6;
    }
LABEL_8:
    uint64_t v68 = (unint64_t *)&_swiftEmptySetSingleton;
    goto LABEL_9;
  }

  id v24 = *(id *)(a1 + 16);
  if (!v24) {
    goto LABEL_8;
  }
LABEL_6:
  uint64_t v68 = (unint64_t *)specialized static _SetStorage.allocate(capacity:)((uint64_t)v24);
LABEL_9:
  uint64_t v61 = v17;
  uint64_t v58 = v10;
  uint64_t v59 = v11;
  unint64_t v60 = v14;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v25 = a1;
    }
    else {
      uint64_t v25 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v26 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v27 = (unint64_t)swift_allocObject(v26, 0xE8uLL, 7uLL);
    int64_t v66 = 0LL;
    uint64_t v28 = 0LL;
    unint64_t v29 = 0LL;
    *(void *)(v27 + 208) = v25;
    *(void *)(v27 + 216) = 0LL;
    *(_OWORD *)(v27 + 16) = 0u;
    *(_OWORD *)(v27 + 32) = 0u;
    *(_OWORD *)(v27 + 48) = 0u;
    *(_OWORD *)(v27 + 64) = 0u;
    *(_OWORD *)(v27 + 80) = 0u;
    *(_OWORD *)(v27 + 96) = 0u;
    *(_OWORD *)(v27 + 112) = 0u;
    *(_OWORD *)(v27 + 128) = 0u;
    *(_OWORD *)(v27 + 144) = 0u;
    *(_OWORD *)(v27 + 160) = 0u;
    *(_OWORD *)(v27 + 176) = 0u;
    *(_OWORD *)(v27 + 192) = 0u;
    *(void *)(v27 + 224) = 0LL;
    unint64_t v30 = v27 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v31 = -1LL << *(_BYTE *)(a1 + 32);
    uint64_t v28 = ~v31;
    uint64_t v32 = *(void *)(a1 + 56);
    int64_t v66 = a1 + 56;
    uint64_t v33 = -v31;
    if (v33 < 64) {
      uint64_t v34 = ~(-1LL << v33);
    }
    else {
      uint64_t v34 = -1LL;
    }
    unint64_t v29 = v34 & v32;
    unint64_t v30 = a1;
  }

  uint64_t v63 = (v30 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v64 = (v30 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v62 = v28;
  int64_t v65 = (unint64_t)(v28 + 64) >> 6;
  uint64_t v35 = v68;
  swift_retain(v68, v18, v19, v20);
  swift_bridgeObjectRetain(a1, v36, v37, v38);
  int64_t v43 = 0LL;
  Swift::Int v67 = (swift *)&unk_189B8D230;
  while ((v30 & 0x8000000000000000LL) == 0)
  {
    if (v29)
    {
      unint64_t v44 = __clz(__rbit64(v29));
      v29 &= v29 - 1;
      unint64_t v45 = v44 | (v43 << 6);
    }

    else
    {
      int64_t v47 = v43 + 1;
      if (__OFADD__(v43, 1LL))
      {
        __break(1u);
LABEL_52:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
      }

      if (v47 >= v65) {
        goto LABEL_46;
      }
      unint64_t v48 = *(void *)(v66 + 8 * v47);
      if (!v48)
      {
        int64_t v49 = v43 + 2;
        if (v43 + 2 >= v65) {
          goto LABEL_46;
        }
        unint64_t v48 = *(void *)(v66 + 8 * v49);
        if (!v48)
        {
          while (1)
          {
            int64_t v47 = v49 + 1;
            if (__OFADD__(v49, 1LL)) {
              break;
            }
            if (v47 >= v65) {
              goto LABEL_46;
            }
            unint64_t v48 = *(void *)(v66 + 8 * v47);
            ++v49;
            if (v48) {
              goto LABEL_33;
            }
          }

          __break(1u);
LABEL_49:
          __break(1u);
LABEL_50:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
        }

        int64_t v47 = v43 + 2;
      }

unint64_t *_setUpCast<A, B>(_:)(uint64_t a1, swift *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v127 = a5;
  uint64_t v8 = *((void *)a2 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  unint64_t v126 = (char *)&v111 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v125 = *(void *)(v11 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v124 = (char *)&v111 - v15;
  uint64_t v113 = type metadata accessor for Optional(0LL, v16, v17, v18);
  uint64_t v19 = *(void *)(v113 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v113);
  uint64_t v112 = (char *)&v111 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::UInt64 v115 = (uint64_t *)((char *)&v111 - v23);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v111 = (char *)&v111 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  Swift::UInt64 v121 = (swift *)((char *)&v111 - v27);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  unint64_t v30 = (char *)&v111 - v29;
  MEMORY[0x1895F8858](v28);
  uint64_t v35 = (char *)&v111 - v34;
  unint64_t v36 = a1 & 0xC000000000000001LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    int64_t v37 = a1;
    if (a1 < 0) {
      uint64_t v38 = (void *)a1;
    }
    else {
      uint64_t v38 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v39 = objc_msgSend(v38, sel_count);
    if (v39) {
      goto LABEL_6;
    }
LABEL_8:
    uint64_t v40 = (unint64_t *)&_swiftEmptySetSingleton;
    goto LABEL_9;
  }

  int64_t v37 = a1;
  id v39 = *(id *)(a1 + 16);
  if (!v39) {
    goto LABEL_8;
  }
LABEL_6:
  type metadata accessor for _SetStorage(0LL, (uint64_t)a3, v127, (uint64_t)v33);
  uint64_t v40 = (unint64_t *)static _SetStorage.allocate(capacity:)((uint64_t)v39);
LABEL_9:
  unint64_t v129 = v40;
  uint64_t v114 = v19;
  if (a3 != (const char *)&type metadata for String)
  {
    unint64_t v123 = (unint64_t)v40;
    unint64_t v41 = v37;
    if (v36)
    {
      if (v37 < 0) {
        uint64_t v42 = v37;
      }
      else {
        uint64_t v42 = v37 & 0xFFFFFFFFFFFFFF8LL;
      }
      uint64_t v43 = type metadata accessor for __CocoaSet.Iterator();
      unint64_t v44 = (unint64_t)swift_allocObject(v43, 0xE8uLL, 7uLL);
      Swift::UInt64 v120 = 0LL;
      uint64_t v45 = 0LL;
      unint64_t v46 = 0LL;
      *(void *)(v44 + 208) = v42;
      *(void *)(v44 + 216) = 0LL;
      uint64_t v40 = (unint64_t *)v123;
      *(_OWORD *)(v44 + 16) = 0u;
      *(_OWORD *)(v44 + 32) = 0u;
      *(_OWORD *)(v44 + 48) = 0u;
      *(_OWORD *)(v44 + 64) = 0u;
      *(_OWORD *)(v44 + 80) = 0u;
      *(_OWORD *)(v44 + 96) = 0u;
      *(_OWORD *)(v44 + 112) = 0u;
      *(_OWORD *)(v44 + 128) = 0u;
      *(_OWORD *)(v44 + 144) = 0u;
      *(_OWORD *)(v44 + 160) = 0u;
      *(_OWORD *)(v44 + 176) = 0u;
      *(_OWORD *)(v44 + 192) = 0u;
      *(void *)(v44 + 224) = 0LL;
      int64_t v37 = v44 | 0x8000000000000000LL;
    }

    else
    {
      uint64_t v54 = -1LL << *(_BYTE *)(v37 + 32);
      uint64_t v45 = ~v54;
      uint64_t v55 = *(void *)(v37 + 56);
      Swift::UInt64 v120 = (swift *)(v37 + 56);
      uint64_t v56 = -v54;
      if (v56 < 64) {
        uint64_t v57 = ~(-1LL << v56);
      }
      else {
        uint64_t v57 = -1LL;
      }
      unint64_t v46 = v57 & v55;
    }

    uint64_t v117 = (v37 & 0x7FFFFFFFFFFFFFFFLL) + 80;
    int64_t v118 = (v37 & 0x7FFFFFFFFFFFFFFFLL) + 16;
    uint64_t v116 = v45;
    int64_t v119 = (unint64_t)(v45 + 64) >> 6;
    swift_bridgeObjectRetain(v41, v31, v32, v33);
    swift_retain(v40, v58, v59, v60);
    int64_t v122 = 0LL;
    Swift::UInt64 v121 = (swift *)&unk_189B8D230;
    if (v37 < 0) {
      goto LABEL_27;
    }
LABEL_25:
    if (v46)
    {
      unint64_t v64 = __clz(__rbit64(v46));
      v46 &= v46 - 1;
      unint64_t v65 = v64 | (v122 << 6);
      goto LABEL_48;
    }

    int64_t v71 = v122 + 1;
    if (__OFADD__(v122, 1LL)) {
      goto LABEL_97;
    }
    if (v71 < v119)
    {
      unint64_t v72 = *((void *)v120 + v71);
      int64_t v73 = v122 + 1;
      if (v72) {
        goto LABEL_47;
      }
      int64_t v73 = v122 + 2;
      if (v122 + 2 >= v119) {
        goto LABEL_91;
      }
      unint64_t v72 = *((void *)v120 + v73);
      if (v72)
      {
LABEL_47:
        unint64_t v46 = (v72 - 1) & v72;
        unint64_t v65 = __clz(__rbit64(v72)) + (v73 << 6);
        int64_t v122 = v73;
LABEL_48:
        (*(void (**)(char *, unint64_t, swift *))(v8 + 16))( v30,  *(void *)(v37 + 48) + *(void *)(v8 + 72) * v65,  a2);
LABEL_49:
        uint64_t v75 = *(void (**)(char *, uint64_t, uint64_t, swift *))(v8 + 56);
        while (1)
        {
          v75(v30, 0LL, 1LL, a2);
          uint64_t v76 = (uint64_t *)v126;
          (*(void (**)(char *, char *, swift *))(v8 + 32))(v126, v30, a2);
          swift_dynamicCast(v14, v76, a2, a3, 7uLL);
          unint64_t v77 = v124;
          Swift::UInt64 v78 = *(void (**)(char *, char *, const char *))(v125 + 32);
          v78(v124, v14, a3);
          v78(v14, v77, a3);
          uint64_t v40 = (unint64_t *)v123;
          _NativeSet._unsafeInsertNew(_:)((uint64_t)v14, v123, (uint64_t)a3, v127);
          if ((v37 & 0x8000000000000000LL) == 0) {
            goto LABEL_25;
          }
LABEL_27:
          uint64_t v66 = *(void *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8);
          if (v66 < 0) {
            goto LABEL_91;
          }
          if (v66 == *(void *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0xE0))
          {
            id v67 = objc_msgSend( *(id *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0xD0),  sel_countByEnumeratingWithState_objects_count_,  v118,  v117,  16);
            *(void *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0xE0) = v67;
            if (!v67)
            {
              *(void *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = -1LL;
              goto LABEL_91;
            }

            uint64_t v66 = 0LL;
            *(void *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = 0LL;
          }

          uint64_t v68 = *(void *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0x18);
          if (!v68) {
            goto LABEL_102;
          }
          if ((unint64_t)(v66 - 0x1000000000000000LL) >> 61 != 7)
          {
            __break(1u);
LABEL_97:
            __break(1u);
LABEL_98:
            __break(1u);
LABEL_99:
            __break(1u);
LABEL_100:
            __break(1u);
LABEL_101:
            __break(1u);
LABEL_102:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
          }

          unint64_t v69 = (void **)(v68 + 8 * v66);
          uint64_t v70 = *v69;
          *(void *)((v37 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = v66 + 1;
          swift_unknownObjectRetain(v70, v61, v62, v63);
          if (_swift_isClassOrObjCExistentialType((uint64_t)a2, (uint64_t *)a2))
          {
            Swift::UInt64 v128 = v70;
            swift_dynamicCast(v30, (uint64_t *)&v128, v121, (const char *)a2, 7uLL);
            goto LABEL_49;
          }

          uint64_t v75 = *(void (**)(char *, uint64_t, uint64_t, swift *))(v8 + 56);
          v75((char *)v115, 1LL, 1LL, a2);
          _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v70, (uint64_t)a2, v115);
          swift_unknownObjectRelease(v70);
          unint64_t v79 = v112;
          (*(void (**)(char *, uint64_t *, uint64_t))(v114 + 16))(v112, v115, v113);
          (*(void (**)(uint64_t *, uint64_t))(v114 + 8))(v115, v113);
          (*(void (**)(char *, char *, swift *))(v8 + 32))(v30, v79, a2);
        }
      }

      int64_t v74 = v122 + 3;
      if (v122 + 3 < v119)
      {
        unint64_t v72 = *((void *)v120 + v74);
        if (v72)
        {
          int64_t v73 = v122 + 3;
          goto LABEL_47;
        }

        while (1)
        {
          int64_t v73 = v74 + 1;
          if (__OFADD__(v74, 1LL)) {
            goto LABEL_99;
          }
          if (v73 >= v119) {
            break;
          }
          unint64_t v72 = *((void *)v120 + v73);
          ++v74;
          if (v72) {
            goto LABEL_47;
          }
        }
      }
    }

unint64_t _SetAnyHashableBox._base.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t *a4@<X8>)
{
  a4[3] = type metadata accessor for Set(0LL, a2, a3, a3);
  *a4 = a1;
  return swift_bridgeObjectRetain(a1, v6, v7, v8);
}

void _SetAnyHashableBox._canonicalBox.getter( unint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, unint64_t *a4@<X8>)
{
  a4[3] = (unint64_t)&unk_189B8A0A8;
  a4[4] = (unint64_t)&protocol witness table for _SetAnyHashableBox<A>;
  *a4 = a1;
  a4[1] = v9;
}

uint64_t _SetAnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  uint64_t v5 = v9[0];
  uint64_t v6 = v9[1];
  char v7 = specialized static Set.== infix(_:_:)(a3, v9[0]);
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(v5);
  return v7 & 1;
}

Swift::Int _SetAnyHashableBox._hashValue.getter(uint64_t a1, unint64_t a2)
{
  *(void *)&__int128 v3 = 0LL;
  *((void *)&v3 + 1) = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  uint64_t v4 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v5 = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  uint64_t v6 = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  specialized Set.hash(into:)(&v3, a2);
  return Hasher._finalize()();
}

void _SetAnyHashableBox._hash(into:)(__int128 *a1, uint64_t a2, unint64_t a3)
{
}

Swift::Int __swiftcall _SetAnyHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  *(void *)&__int128 v3 = 0LL;
  *((void *)&v3 + 1) = _swift_stdlib_Hashing_parameters ^ _seed ^ 0x736F6D6570736575LL;
  uint64_t v4 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v5 = _swift_stdlib_Hashing_parameters ^ _seed ^ 0x6C7967656E657261LL;
  uint64_t v6 = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  specialized Set.hash(into:)(&v3, v1);
  return Hasher._finalize()();
}

uint64_t _SetAnyHashableBox._unbox<A>()@<X0>( unint64_t a1@<X0>, uint64_t a2@<X2>, const char *a3@<X3>, uint64_t a4@<X4>, char *a5@<X8>)
{
  unint64_t v14 = a1;
  __int128 v8 = (swift *)type metadata accessor for Set(0LL, a2, a4, (uint64_t)a3);
  swift_bridgeObjectRetain(a1, v9, v10, v11);
  int v12 = swift_dynamicCast(a5, (uint64_t *)&v14, v8, a3, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a3 - 1) + 56LL))( a5,  v12 ^ 1u,  1LL,  a3);
}

uint64_t _SetAnyHashableBox._downCastConditional<A>(into:)( char *a1, unint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6)
{
  uint64_t v11 = type metadata accessor for Optional(0LL, (uint64_t)a5, a3, a4);
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v28 - v14;
  uint64_t v16 = *((void *)a5 - 1);
  MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v28 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v29 = a2;
  uint64_t v20 = (swift *)type metadata accessor for Set(0LL, a4, a6, v19);
  swift_bridgeObjectRetain(a2, v21, v22, v23);
  uint64_t v24 = swift_dynamicCast(v15, (uint64_t *)&v29, v20, a5, 6uLL);
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v16 + 56);
  if ((_DWORD)v24)
  {
    v25(v15, 0LL, 1LL, a5);
    uint64_t v26 = *(void (**)(char *, char *, const char *))(v16 + 32);
    v26(v18, v15, a5);
    v26(a1, v18, a5);
  }

  else
  {
    v25(v15, 1LL, 1LL, a5);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v15, v11);
  }

  return v24;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _SetAnyHashableBox<A>( uint64_t a1@<X2>, char *a2@<X3>, unint64_t *a3@<X8>)
{
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _SetAnyHashableBox<A>( uint64_t a1, uint64_t a2)
{
  return _SetAnyHashableBox._isEqual(to:)(a1, a2, *(void *)(v2 + 8));
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _SetAnyHashableBox<A>( uint64_t a1)
{
  return _SetAnyHashableBox._hashValue.getter(a1, *(void *)(v1 + 8));
}

void protocol witness for _AnyHashableBox._hash(into:) in conformance _SetAnyHashableBox<A>( __int128 *a1, uint64_t a2)
{
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _SetAnyHashableBox<A>( Swift::Int _seed)
{
  return _SetAnyHashableBox._rawHashValue(_seed:)(_seed);
}

unint64_t protocol witness for _AnyHashableBox._base.getter in conformance _SetAnyHashableBox<A>@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
  return _SetAnyHashableBox._base.getter(*v2, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _SetAnyHashableBox<A>@<X0>( const char *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return _SetAnyHashableBox._unbox<A>()(*v3, *(void *)(a2 + 16), a1, *(void *)(a2 + 24), a3);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _SetAnyHashableBox<A>( char *a1, const char *a2, uint64_t a3)
{
  return _SetAnyHashableBox._downCastConditional<A>(into:)(a1, *v3, a3, *(void *)(a3 + 16), a2, *(void *)(a3 + 24));
}

uint64_t Set.update(with:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Set.update(with:)(a1, a2, (uint64_t (*)(uint64_t, uint64_t))Set._Variant.update(with:), a4);
}

void Set._Variant.update(with:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = *(char **)(a2 + 16);
  if ((v8 & 0xC000000000000001LL) != 0)
  {
    if (v8 < 0) {
      uint64_t v10 = (void *)v8;
    }
    else {
      uint64_t v10 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v11 = objc_msgSend(v10, sel_count);
    if (__OFADD__(v11, 1LL))
    {
      __break(1u);
    }

    else
    {
      uint64_t v12 = *(void *)(a2 + 24);
      uint64_t v19 = _NativeSet.init(_:capacity:)(v10, (uint64_t)v11 + 1, v9, v12);
      uint64_t v14 = type metadata accessor for _NativeSet(0LL, (uint64_t)v9, v12, v13);
      _NativeSet.update(with:isUnique:)(a1, 1, v14, a3);
      *uint64_t v4 = (uint64_t)v19;
    }
  }

  else
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v8);
    uint64_t v20 = *v4;
    *uint64_t v4 = 0x8000000000000000LL;
    uint64_t v17 = type metadata accessor for _NativeSet(0LL, (uint64_t)v9, *(void *)(a2 + 24), v16);
    _NativeSet.update(with:isUnique:)(a1, isUniquelyReferenced_nonNull_native, v17, a3);
    uint64_t v18 = *v4;
    *uint64_t v4 = v20;
    swift_bridgeObjectRelease(v18);
  }

uint64_t Set.remove(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Set.update(with:)(a1, a2, (uint64_t (*)(uint64_t, uint64_t))Set._Variant.remove(_:), a4);
}

uint64_t Set.update(with:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v5 = type metadata accessor for Set._Variant(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  return a3(a1, v5);
}

void Set.remove(at:)(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  char v8 = a3 & 1;
  uint64_t v9 = type metadata accessor for Set._Variant(0LL, *(void *)(a4 + 16), *(void *)(a4 + 24), a4);
  Set._Variant.remove(at:)(a1, a2, v8, v9, a5);
}

void Set._Variant.remove(at:)( uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v7 = a4;
  uint64_t v10 = a1;
  uint64_t v12 = *(char **)(a4 + 16);
  uint64_t v67 = *((void *)v12 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v59 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v59 - v16;
  uint64_t v18 = *v6;
  if ((*v6 & 0xC000000000000001LL) != 0)
  {
    if (v18 < 0) {
      uint64_t v19 = (void *)*v6;
    }
    else {
      uint64_t v19 = (void *)(v18 & 0xFFFFFFFFFFFFFF8LL);
    }
    if ((a3 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
    }
    if (v10 >= 0) {
      uint64_t v20 = v10 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v20 = v10;
    }
    uint64_t v21 = type metadata accessor for __CocoaSet.Index.Storage();
    if (swift_dynamicCastClass(v20, v21))
    {
      uint64_t v25 = *(void *)(v20 + 24);
      if (*(void *)(v25 + 16) > a2)
      {
        uint64_t v26 = *(void **)(v25 + 8 * a2 + 24);
        swift_unknownObjectRetain(v26, v22, v23, v24);
        swift_bridgeObjectRetain(v18, v27, v28, v29);
        _forceBridgeFromObjectiveC<A>(_:_:)(v26, v12, v30, v15);
        swift_unknownObjectRelease(v26);
        Set._Variant._migrateToNative(_:removing:)(v19, v15, v7, a5);
        swift_bridgeObjectRelease(v18);
        (*(void (**)(char *, char *))(v67 + 8))(v15, v12);
        return;
      }

Swift::Void __swiftcall Set.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
}

Swift::Void __swiftcall Set._Variant.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  if (!keepingCapacity)
  {
    swift_bridgeObjectRelease(v5);
    uint64_t *v2 = (uint64_t)&_swiftEmptySetSingleton;
    return;
  }

  uint64_t v6 = v1;
  uint64_t v7 = *(void *)(v1 + 16);
  if ((v5 & 0xC000000000000001LL) == 0)
  {
    goto LABEL_9;
  }

  if (v5 >= 0) {
    v5 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if ((uint64_t)objc_msgSend((id)v5, sel_count) > 0)
  {
LABEL_9:
    uint64_t v8 = *v3;
    if ((*v3 & 0xC000000000000001LL) != 0)
    {
      if (v8 < 0) {
        uint64_t v9 = (void *)*v3;
      }
      else {
        uint64_t v9 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
      }
      id v10 = objc_msgSend(v9, sel_count);
      swift_bridgeObjectRelease(v8);
      if (v10)
      {
        type metadata accessor for _SetStorage(0LL, v7, *(void *)(v6 + 24), v11);
        uint64_t v12 = (__objc2_class **)static _SetStorage.allocate(capacity:)((uint64_t)v10);
      }

      else
      {
        uint64_t v12 = &_swiftEmptySetSingleton;
      }

      *uint64_t v3 = (uint64_t)v12;
    }

    else
    {
      Swift::Bool isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
      uint64_t v16 = *v3;
      *uint64_t v3 = 0x8000000000000000LL;
      type metadata accessor for _NativeSet(0LL, v7, *(void *)(v6 + 24), v14);
      _NativeSet.removeAll(isUnique:)(isUniquelyReferenced_nonNull_native);
      uint64_t v15 = *v3;
      *uint64_t v3 = v16;
      swift_bridgeObjectRelease(v15);
    }
  }

void Set.removeFirst()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8 = *v5;
  if ((*v5 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(v8 + 16)) {
      goto LABEL_6;
    }
LABEL_14:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeFirst from an empty Set",  35LL,  2,  "Swift/Set.swift",  15LL,  2,  0x275uLL,  0);
  }

  if (v8 < 0) {
    uint64_t v9 = (void *)*v5;
  }
  else {
    uint64_t v9 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
  }
  if (!objc_msgSend(v9, sel_count)) {
    goto LABEL_14;
  }
LABEL_6:
  uint64_t v10 = *v5;
  uint64_t v11 = *(void *)(a1 + 16);
  unint64_t v12 = *v5 & 0xC000000000000001LL;
  if (!v12)
  {
    uint64_t v19 = *(void *)(a1 + 24);
    uint64_t v18 = _NativeSet.startIndex.getter(v10);
    uint64_t v24 = v25;
    goto LABEL_16;
  }

  if (v10 < 0) {
    uint64_t v13 = (void *)*v5;
  }
  else {
    uint64_t v13 = (void *)(v10 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v14 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v13, a2, a3, a4), sel_count);
  unint64_t v15 = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v14 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v14, 24LL))
    {
      uint64_t v16 = swift_bufferAllocate(v15, 8 * v14 + 24, 7uLL);
      v16[2] = v14;
      objc_msgSend(v13, sel_getObjects_, v16 + 3);
      swift_bridgeObjectRelease(v10);
      uint64_t v17 = type metadata accessor for __CocoaSet.Index.Storage();
      uint64_t v18 = (uint64_t)swift_allocObject(v17, 0x20uLL, 7uLL);
      *(void *)(v18 + 16) = v13;
      *(void *)(v18 + 24) = v16;
      uint64_t v19 = *(void *)(a1 + 24);
      swift_bridgeObjectRetain(v10, v20, v21, v22);
      uint64_t v24 = 0LL;
LABEL_16:
      uint64_t v26 = type metadata accessor for Set._Variant(0LL, v11, v19, v23);
      Set._Variant.remove(at:)(v18, v24, v12 != 0, v26, a5);
      outlined consume of [A : B].Index._Variant<A, B>(v18, v24, v12 != 0);
      return;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
}

__objc2_class **Set.init<A>(_:)(uint64_t a1, uint64_t a2, swift *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v45 = *(void *)(a2 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  unint64_t v44 = (id *)((char *)&v44 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v10);
  uint64_t v47 = (char *)&v44 - v12;
  uint64_t v16 = type metadata accessor for Optional(0LL, v13, v14, v15);
  MEMORY[0x1895F8858](v16);
  uint64_t v18 = (char *)&v44 - v17;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v46 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v20 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v44 - v21;
  uint64_t v22 = *((void *)a3 - 1);
  MEMORY[0x1895F8858](v20);
  uint64_t v24 = (uint64_t *)((char *)&v44 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *, uint64_t, swift *))(v22 + 16))(v24, a1, a3);
  uint64_t v26 = (const char *)type metadata accessor for Set(0LL, a2, a4, v25);
  if ((swift_dynamicCast((char *)&v51, v24, a3, v26, 6uLL) & 1) != 0)
  {
    (*(void (**)(uint64_t, swift *))(v22 + 8))(a1, a3);
  }

  else
  {
    uint64_t v27 = (*(uint64_t (**)(swift *, uint64_t))(a5 + 40))(a3, a5);
    if (v27)
    {
      uint64_t v29 = v27;
      uint64_t v30 = a4;
      type metadata accessor for _SetStorage(0LL, a2, a4, v28);
      uint64_t v31 = (__objc2_class **)static _SetStorage.allocate(capacity:)(v29);
    }

    else
    {
      uint64_t v30 = a4;
      uint64_t v31 = &_swiftEmptySetSingleton;
    }

    uint64_t v51 = v31;
    (*(void (**)(swift *, uint64_t))(a5 + 32))(a3, a5);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  (uint64_t)a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v33 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
    unint64_t v48 = AssociatedConformanceWitness;
    unint64_t v49 = AssociatedTypeWitness;
    v33(AssociatedTypeWitness);
    uint64_t v34 = v45;
    unint64_t v35 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v45 + 48);
    int v36 = v35(v18, 1LL, a2);
    uint64_t v37 = v44;
    uint64_t v38 = v47;
    if (v36 != 1)
    {
      uint64_t v39 = v30;
      uint64_t v40 = *(void (**)(id *, char *, uint64_t))(v34 + 32);
      do
      {
        v40(v37, v18, a2);
        uint64_t v42 = type metadata accessor for Set._Variant(0LL, a2, v39, v41);
        Set._Variant.insert(_:)(v38, v37, v42);
        (*(void (**)(char *, uint64_t))(v34 + 8))(v38, a2);
        ((void (*)(unint64_t, unint64_t))v33)(v49, v48);
      }

      while (v35(v18, 1LL, a2) != 1);
    }

    (*(void (**)(char *, unint64_t))(v46 + 8))(v50, v49);
  }

  return v51;
}

uint64_t Set.isSubset<A>(of:)(uint64_t a1, uint64_t a2, char *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = a4;
  uint64_t v11 = a1;
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (uint64_t *)((char *)&v44 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v17 = type metadata accessor for Optional(0LL, v15, v15, v16);
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v44 - v19;
  unint64_t v21 = a2 & 0xC000000000000001LL;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    unint64_t v44 = a2 & 0xC000000000000001LL;
    uint64_t v45 = a3;
    uint64_t v22 = v8;
    uint64_t v23 = v11;
    if (a2 < 0) {
      uint64_t v24 = (void *)a2;
    }
    else {
      uint64_t v24 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    if (objc_msgSend(v24, sel_count, v44, v45))
    {
      id v25 = objc_msgSend(v24, sel_count);
      uint64_t v11 = v23;
      uint64_t v8 = v22;
      unint64_t v21 = v44;
      a3 = v45;
      goto LABEL_8;
    }

uint64_t Set.isSubset(of:)(uint64_t a1, int64_t a2, char *a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = a1;
  uint64_t v8 = *((void *)a3 - 1);
  uint64_t v9 = *(void *)(v8 + 64);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v107 = (id *)((char *)&v82 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v10);
  uint64_t v109 = (id *)((char *)&v82 - v11);
  uint64_t v89 = type metadata accessor for Optional(0LL, v12, v12, v13);
  uint64_t v14 = *(void *)(v89 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v89);
  int64_t v96 = (char *)&v82 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v90 = (uint64_t *)((char *)&v82 - v18);
  MEMORY[0x1895F8858](v17);
  int64_t v98 = (char *)&v82 - v22;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v23 = (void *)a2;
    }
    else {
      uint64_t v23 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v24 = objc_msgSend(v23, sel_count);
  }

  else
  {
    id v24 = *(id *)(a2 + 16);
  }

  unint64_t v97 = v7 & 0xC000000000000001LL;
  if ((v7 & 0xC000000000000001LL) != 0)
  {
    if (v7 < 0) {
      id v25 = (void *)v7;
    }
    else {
      id v25 = (void *)(v7 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v26 = objc_msgSend(v25, sel_count);
  }

  else
  {
    id v26 = *(id *)(v7 + 16);
  }

  uint64_t v27 = v96;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v29 = a2;
    }
    else {
      uint64_t v29 = a2 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v30 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v31 = (unint64_t)swift_allocObject(v30, 0xE8uLL, 7uLL);
    int64_t v93 = 0LL;
    uint64_t v32 = 0LL;
    unint64_t v33 = 0LL;
    *(void *)(v31 + 208) = v29;
    *(void *)(v31 + 216) = 0LL;
    *(_OWORD *)(v31 + 16) = 0u;
    *(_OWORD *)(v31 + 32) = 0u;
    *(_OWORD *)(v31 + 48) = 0u;
    *(_OWORD *)(v31 + 64) = 0u;
    *(_OWORD *)(v31 + 80) = 0u;
    *(_OWORD *)(v31 + 96) = 0u;
    *(_OWORD *)(v31 + 112) = 0u;
    *(_OWORD *)(v31 + 128) = 0u;
    *(_OWORD *)(v31 + 144) = 0u;
    *(_OWORD *)(v31 + 160) = 0u;
    *(_OWORD *)(v31 + 176) = 0u;
    *(_OWORD *)(v31 + 192) = 0u;
    *(void *)(v31 + 224) = 0LL;
    unint64_t v34 = v31 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v35 = -1LL << *(_BYTE *)(a2 + 32);
    uint64_t v32 = ~v35;
    uint64_t v36 = *(void *)(a2 + 56);
    int64_t v93 = a2 + 56;
    uint64_t v37 = -v35;
    if (v37 < 64) {
      uint64_t v38 = ~(-1LL << v37);
    }
    else {
      uint64_t v38 = -1LL;
    }
    unint64_t v33 = v38 & v36;
    unint64_t v34 = a2;
  }

  uint64_t v39 = v98;
  unint64_t v102 = v34;
  uint64_t v40 = v34 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v87 = v40 + 16;
  uint64_t v92 = v40;
  uint64_t v86 = v40 + 80;
  uint64_t v88 = v32;
  uint64_t v41 = (void *)(v7 & 0xFFFFFFFFFFFFFF8LL);
  if (v7 < 0) {
    uint64_t v41 = (void *)v7;
  }
  id v94 = v41;
  int64_t v95 = (unint64_t)(v32 + 64) >> 6;
  uint64_t v106 = v7 + 56;
  swift_bridgeObjectRetain(a2, v19, v20, v21);
  int64_t v103 = 0LL;
  uint64_t v91 = (swift *)&unk_189B8D230;
  unint64_t v45 = v33;
  uint64_t v85 = a4;
  uint64_t v108 = v5;
  uint64_t v105 = v7;
  uint64_t v84 = v9;
  uint64_t v83 = v14;
  while (1)
  {
    uint64_t v46 = v102;
    unint64_t v99 = v45;
    if ((v102 & 0x8000000000000000LL) == 0)
    {
      if (v45)
      {
        uint64_t v100 = (v45 - 1) & v45;
        unint64_t v47 = __clz(__rbit64(v45)) | (v103 << 6);
        int64_t v101 = v103;
      }

      else
      {
        int64_t v55 = v103 + 1;
        if (__OFADD__(v103, 1LL))
        {
          __break(1u);
LABEL_81:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
        }

        if (v55 >= v95)
        {
LABEL_67:
          uint64_t v28 = 1LL;
          (*(void (**)(char *, uint64_t, uint64_t, char *))(v8 + 56))(v39, 1LL, 1LL, v5);
          unint64_t v99 = 0LL;
          goto LABEL_72;
        }

        unint64_t v56 = *(void *)(v93 + 8 * v55);
        if (!v56)
        {
          uint64_t v57 = v103 + 2;
          if (v103 + 2 >= v95) {
            goto LABEL_67;
          }
          unint64_t v56 = *(void *)(v93 + 8 * v57);
          if (!v56)
          {
            while (1)
            {
              int64_t v55 = v57 + 1;
              if (__OFADD__(v57, 1LL)) {
                break;
              }
              if (v55 >= v95) {
                goto LABEL_67;
              }
              unint64_t v56 = *(void *)(v93 + 8 * v55);
              ++v57;
              if (v56) {
                goto LABEL_49;
              }
            }

            __break(1u);
LABEL_78:
            __break(1u);
LABEL_79:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
          }

          int64_t v55 = v103 + 2;
        }

uint64_t Set.isStrictSubset<A>(of:)(uint64_t a1, uint64_t a2, char *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v13 = (uint64_t *)((char *)&v25 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *, uint64_t, uint64_t))(v14 + 16))(v13, a1, v15);
  uint64_t v17 = (const char *)type metadata accessor for Set(0LL, (uint64_t)a3, a5, v16);
  if (swift_dynamicCast((char *)&v26, v13, a4, v17, 6uLL))
  {
    uint64_t v21 = v26;
    char v22 = Set.isStrictSubset(of:)(v26, a2, a3, a5);
    swift_bridgeObjectRelease(v21);
  }

  else
  {
    if ((a2 & 0xC000000000000001LL) != 0)
    {
      if (a2 < 0) {
        uint64_t v23 = (void *)a2;
      }
      else {
        uint64_t v23 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_bridgeObjectRetain(a2, v18, v19, v20);
      a2 = (uint64_t)_NativeSet.init(_:capacity:)(v23, (uint64_t)objc_msgSend(v23, sel_count), a3, a5);
    }

    else
    {
      swift_bridgeObjectRetain(a2, v18, v19, v20);
    }

    char v22 = _NativeSet.isSubset<A>(of:)( a1,  a2,  (uint64_t)a3,  (uint64_t)a4,  a5,  a6,  (void (*)(unsigned __int8 *__return_ptr, int64x2_t *, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))closure #1 in _NativeSet.isStrictSubset<A>(of:));
    swift_release(a2);
  }

  return v22 & 1;
}

uint64_t Set.isStrictSubset(of:)(uint64_t a1, int64_t a2, char *a3, uint64_t a4)
{
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v8 = (void *)a2;
    }
    else {
      uint64_t v8 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v9 = objc_msgSend(v8, sel_count);
    if ((a1 & 0xC000000000000001LL) != 0)
    {
LABEL_6:
      if (a1 < 0) {
        uint64_t v10 = (void *)a1;
      }
      else {
        uint64_t v10 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
      }
      return 0LL;
    }
  }

  else
  {
    id v9 = *(id *)(a2 + 16);
    if ((a1 & 0xC000000000000001LL) != 0) {
      goto LABEL_6;
    }
  }

  return 0LL;
}

uint64_t Set.isSuperset<A>(of:)(uint64_t a1, uint64_t a2, char *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v76 = a2;
  uint64_t v73 = *((void *)a3 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  char v75 = (id *)((char *)&v61 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v71 = v12;
  MEMORY[0x1895F8858](v11);
  unint64_t v77 = (id *)((char *)&v61 - v13);
  uint64_t v16 = type metadata accessor for Optional(0LL, v14, v14, v15);
  MEMORY[0x1895F8858](v16);
  uint64_t v18 = (char *)&v61 - v17;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v70 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v20 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v22 = (char *)&v61 - v21;
  uint64_t v23 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](v20);
  uint64_t v25 = (uint64_t *)((char *)&v61 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *, uint64_t, swift *))(v23 + 16))(v25, a1, a4);
  uint64_t v72 = a5;
  uint64_t v27 = (const char *)type metadata accessor for Set(0LL, (uint64_t)a3, a5, v26);
  if (swift_dynamicCast((char *)&v78, v25, a4, v27, 6uLL))
  {
    (*(void (**)(uint64_t, swift *))(v23 + 8))(a1, a4);
    uint64_t v28 = v78;
    char v29 = Set.isSubset(of:)(v76, v78, a3, v72);
    swift_bridgeObjectRelease(v28);
    return v29 & 1;
  }

  (*(void (**)(swift *, uint64_t))(a6 + 32))(a4, a6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  (uint64_t)a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v31 = v22;
  unint64_t v69 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v69(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v32 = v73;
  uint64_t v68 = *(uint64_t (**)(char *, uint64_t, char *))(v73 + 48);
  int v33 = v68(v18, 1LL, a3);
  unint64_t v34 = AssociatedTypeWitness;
  uint64_t v35 = v72;
  uint64_t v36 = v76;
  if (v33 == 1)
  {
LABEL_4:
    (*(void (**)(char *, unint64_t))(v70 + 8))(v31, v34);
    char v29 = 1;
    return v29 & 1;
  }

  uint64_t v37 = v18;
  uint64_t v38 = v32;
  uint64_t v39 = *(void (**)(id *, char *, char *))(v32 + 32);
  unint64_t v66 = v76 & 0xC000000000000001LL;
  unint64_t v67 = v39;
  uint64_t v40 = (void *)(v76 & 0xFFFFFFFFFFFFFF8LL);
  if (v76 < 0) {
    uint64_t v40 = (void *)v76;
  }
  unint64_t v64 = v34;
  id v65 = v40;
  uint64_t v74 = v76 + 56;
  uint64_t v62 = v37;
  BOOL v63 = v31;
  unint64_t v61 = AssociatedConformanceWitness;
  while (1)
  {
    v67(v77, v37, a3);
    if (!v66) {
      break;
    }
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      if (v71 != 8) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
      unint64_t v44 = v77;
      unint64_t v45 = *v77;
      swift_unknownObjectRetain(*v77, v41, v42, v43);
      (*(void (**)(id *, char *))(v38 + 8))(v44, a3);
    }

    else
    {
      uint64_t v57 = v75;
      v67(v75, (char *)v77, a3);
      unint64_t v45 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v57, (uint64_t *)a3, v58, v59);
    }

    id v46 = objc_msgSend(v65, sel_member_, v45, v61, v62);
    swift_unknownObjectRelease(v45);
    if (!v46) {
      goto LABEL_26;
    }
    swift_unknownObjectRelease(v46);
LABEL_21:
    v69(v34, AssociatedConformanceWitness);
  }

  if (*(void *)(v36 + 16))
  {
    uint64_t v47 = (*(uint64_t (**)(void, char *, uint64_t))(v35 + 32))(*(void *)(v36 + 40), a3, v35);
    uint64_t v48 = -1LL << *(_BYTE *)(v36 + 32);
    unint64_t v49 = v47 & ~v48;
    if (((*(void *)(v74 + ((v49 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v49) & 1) != 0)
    {
      uint64_t v73 = ~v48;
      uint64_t v50 = *(void *)(v35 + 8);
      uint64_t v51 = *(uint64_t (**)(id *, id *, char *, uint64_t))(v50 + 8);
      uint64_t v52 = *(void *)(v38 + 72);
      uint64_t v53 = *(void (**)(id *, unint64_t, char *))(v38 + 16);
      while (1)
      {
        uint64_t v54 = v75;
        v53(v75, *(void *)(v76 + 48) + v52 * v49, a3);
        char v55 = v51(v54, v77, a3, v50);
        unint64_t v56 = *(void (**)(id *, char *))(v38 + 8);
        v56(v54, a3);
        if ((v55 & 1) != 0) {
          break;
        }
        unint64_t v49 = (v49 + 1) & v73;
        if (((*(void *)(v74 + ((v49 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v49) & 1) == 0) {
          goto LABEL_25;
        }
      }

      v56(v77, a3);
      uint64_t v35 = v72;
      uint64_t v36 = v76;
      unint64_t v31 = v63;
      unint64_t v34 = v64;
      unint64_t AssociatedConformanceWitness = v61;
      uint64_t v37 = v62;
      goto LABEL_21;
    }
  }

  unint64_t v56 = *(void (**)(id *, char *))(v38 + 8);
LABEL_25:
  v56(v77, a3);
  unint64_t v31 = v63;
  unint64_t v34 = v64;
LABEL_26:
  (*(void (**)(char *, unint64_t))(v70 + 8))(v31, v34);
  char v29 = 0;
  return v29 & 1;
}

uint64_t Set.isSuperset(of:)(int64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  return Set.isSubset(of:)(a2, a1, a3, a4);
}

uint64_t Set.isStrictSuperset<A>(of:)(uint64_t a1, uint64_t a2, char *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (uint64_t *)((char *)&v27 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  unint64_t v16 = v15 & 0xC000000000000001LL;
  if ((v15 & 0xC000000000000001LL) == 0)
  {
    if (*(void *)(a2 + 16)) {
      goto LABEL_6;
    }
LABEL_9:
    char v24 = 0;
    return v24 & 1;
  }

  if (a2 < 0) {
    uint64_t v17 = (void *)a2;
  }
  else {
    uint64_t v17 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  if (!objc_msgSend(v17, sel_count)) {
    goto LABEL_9;
  }
LABEL_6:
  (*(void (**)(uint64_t *, uint64_t, swift *))(v12 + 16))(v14, a1, a4);
  uint64_t v19 = (const char *)type metadata accessor for Set(0LL, (uint64_t)a3, a5, v18);
  if (swift_dynamicCast((char *)&v28, v14, a4, v19, 6uLL))
  {
    uint64_t v23 = v28;
    char v24 = Set.isStrictSuperset(of:)(v28, a2, a3, a5);
    swift_bridgeObjectRelease(v23);
  }

  else
  {
    if (v16)
    {
      if (a2 < 0) {
        uint64_t v25 = (void *)a2;
      }
      else {
        uint64_t v25 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_bridgeObjectRetain(a2, v20, v21, v22);
      a2 = (uint64_t)_NativeSet.init(_:capacity:)(v25, (uint64_t)objc_msgSend(v25, sel_count), a3, a5);
    }

    else
    {
      swift_bridgeObjectRetain(a2, v20, v21, v22);
    }

    char v24 = _NativeSet.isSubset<A>(of:)( a1,  a2,  (uint64_t)a3,  (uint64_t)a4,  a5,  a6,  (void (*)(unsigned __int8 *__return_ptr, int64x2_t *, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))closure #1 in _NativeSet.isStrictSuperset<A>(of:));
    swift_release(a2);
  }

  return v24 & 1;
}

uint64_t Set.isStrictSuperset(of:)(int64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v8 = (void *)a2;
    }
    else {
      uint64_t v8 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v9 = objc_msgSend(v8, sel_count);
    if ((a1 & 0xC000000000000001LL) != 0)
    {
LABEL_6:
      if (a1 < 0) {
        uint64_t v10 = (void *)a1;
      }
      else {
        uint64_t v10 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
      }
      return 0LL;
    }
  }

  else
  {
    id v9 = *(id *)(a2 + 16);
    if ((a1 & 0xC000000000000001LL) != 0) {
      goto LABEL_6;
    }
  }

  return 0LL;
}

uint64_t Set.isDisjoint<A>(with:)(uint64_t a1, uint64_t a2, char *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v13 = (uint64_t *)((char *)&v21 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *, uint64_t, uint64_t))(v14 + 16))(v13, a1, v15);
  uint64_t v17 = (const char *)type metadata accessor for Set(0LL, (uint64_t)a3, a5, v16);
  if (swift_dynamicCast((char *)&v22, v13, a4, v17, 6uLL))
  {
    uint64_t v18 = v22;
    char v19 = Set.isDisjoint(with:)(v22, a2, a3, a5);
    swift_bridgeObjectRelease(v18);
  }

  else
  {
    char v19 = Set._isDisjoint<A>(with:)(a1, a2, (uint64_t *)a3, (uint64_t)a4, a5, a6);
  }

  return v19 & 1;
}

uint64_t Set.isDisjoint(with:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v8 = *((void *)a3 - 1);
  uint64_t v9 = *(void *)(v8 + 64);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  int64_t v118 = (id *)((char *)&v93 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v10);
  int64_t v119 = (id *)((char *)&v93 - v11);
  uint64_t v102 = type metadata accessor for Optional(0LL, v12, v12, v13);
  uint64_t v14 = *(void *)(v102 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v102);
  int64_t v101 = (char *)&v93 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64_t v103 = (uint64_t *)((char *)&v93 - v18);
  MEMORY[0x1895F8858](v17);
  uint64_t v23 = (char *)&v93 - v22;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      char v24 = (void *)a2;
    }
    else {
      char v24 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    if (!objc_msgSend(v24, sel_count)) {
      return 1LL;
    }
  }

  else if (!*(void *)(a2 + 16))
  {
    return 1LL;
  }

  uint64_t v104 = v14;
  unint64_t v25 = a1 & 0xC000000000000001LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v26 = (void *)a1;
    }
    else {
      uint64_t v26 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    if (objc_msgSend(v26, sel_count))
    {
LABEL_13:
      if ((a2 & 0xC000000000000001LL) != 0)
      {
        if (a2 < 0) {
          uint64_t v27 = (void *)a2;
        }
        else {
          uint64_t v27 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
        }
        id v28 = objc_msgSend(v27, sel_count);
        if (v25) {
          goto LABEL_18;
        }
      }

      else
      {
        id v28 = *(id *)(a2 + 16);
        if (v25)
        {
LABEL_18:
          if (a1 < 0) {
            char v29 = (void *)a1;
          }
          else {
            char v29 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
          }
          id v30 = objc_msgSend(v29, sel_count);
          goto LABEL_26;
        }
      }

      id v30 = *(id *)(a1 + 16);
LABEL_26:
      else {
        int64_t v32 = a2;
      }
      else {
        uint64_t v33 = a1;
      }
      uint64_t v120 = v33;
      if ((v32 & 0xC000000000000001LL) != 0)
      {
        if (v32 < 0) {
          uint64_t v34 = v32;
        }
        else {
          uint64_t v34 = v32 & 0xFFFFFFFFFFFFFF8LL;
        }
        uint64_t v35 = type metadata accessor for __CocoaSet.Iterator();
        unint64_t v36 = (unint64_t)swift_allocObject(v35, 0xE8uLL, 7uLL);
        int64_t v106 = 0LL;
        uint64_t v37 = 0LL;
        unint64_t v38 = 0LL;
        *(void *)(v36 + 208) = v34;
        *(void *)(v36 + 216) = 0LL;
        *(_OWORD *)(v36 + 16) = 0u;
        *(_OWORD *)(v36 + 32) = 0u;
        *(_OWORD *)(v36 + 48) = 0u;
        *(_OWORD *)(v36 + 64) = 0u;
        *(_OWORD *)(v36 + 80) = 0u;
        *(_OWORD *)(v36 + 96) = 0u;
        *(_OWORD *)(v36 + 112) = 0u;
        *(_OWORD *)(v36 + 128) = 0u;
        *(_OWORD *)(v36 + 144) = 0u;
        *(_OWORD *)(v36 + 160) = 0u;
        *(_OWORD *)(v36 + 176) = 0u;
        *(_OWORD *)(v36 + 192) = 0u;
        *(void *)(v36 + 224) = 0LL;
        unint64_t v39 = v36 | 0x8000000000000000LL;
      }

      else
      {
        uint64_t v40 = -1LL << *(_BYTE *)(v32 + 32);
        uint64_t v37 = ~v40;
        uint64_t v41 = *(void *)(v32 + 56);
        int64_t v106 = v32 + 56;
        uint64_t v42 = -v40;
        if (v42 < 64) {
          uint64_t v43 = ~(-1LL << v42);
        }
        else {
          uint64_t v43 = -1LL;
        }
        unint64_t v38 = v43 & v41;
        unint64_t v39 = v32;
      }

      unint64_t v44 = v119;
      uint64_t v100 = (v39 & 0x7FFFFFFFFFFFFFFFLL) + 16;
      uint64_t v107 = v39 & 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v99 = (v39 & 0x7FFFFFFFFFFFFFFFLL) + 80;
      uint64_t v97 = v37;
      unint64_t v45 = v120;
      int64_t v109 = (unint64_t)(v37 + 64) >> 6;
      unint64_t v110 = v120 & 0xC000000000000001LL;
      id v46 = (void *)(v120 & 0xFFFFFFFFFFFFFF8LL);
      if (v120 < 0) {
        id v46 = (void *)v120;
      }
      id v108 = v46;
      uint64_t v117 = v120 + 56;
      swift_bridgeObjectRetain(v32, v19, v20, v21);
      swift_bridgeObjectRetain(v45, v47, v48, v49);
      uint64_t v105 = (swift *)&unk_189B8D230;
      int64_t v96 = v23;
      uint64_t v53 = v104;
      unint64_t v111 = v39;
      unint64_t v54 = v38;
      int64_t v55 = 0LL;
      uint64_t v95 = a4;
      uint64_t v94 = v9;
      uint64_t v116 = v5;
LABEL_45:
      while (2)
      {
        unint64_t v112 = v54;
        if ((v39 & 0x8000000000000000LL) != 0)
        {
          uint64_t v57 = v107;
          uint64_t v58 = *(void *)(v107 + 216);
          if (v58 < 0) {
            goto LABEL_86;
          }
          if (v58 == *(void *)(v107 + 224))
          {
            id v59 = objc_msgSend(*(id *)(v107 + 208), sel_countByEnumeratingWithState_objects_count_, v100, v99, 16);
            uint64_t v57 = v107;
            *(void *)(v107 + 224) = v59;
            if (!v59)
            {
              *(void *)(v57 + 216) = -1LL;
              goto LABEL_86;
            }

            uint64_t v58 = 0LL;
            *(void *)(v57 + 216) = 0LL;
          }

          uint64_t v60 = *(void *)(v57 + 24);
          if (v60)
          {
            if ((unint64_t)(v58 - 0x1000000000000000LL) >> 61 == 7)
            {
              unint64_t v61 = (void **)(v60 + 8 * v58);
              if ((v61 & 7) == 0)
              {
                uint64_t v62 = *v61;
                *(void *)(v57 + 216) = v58 + 1;
                swift_unknownObjectRetain(v62, v50, v51, v52);
                if (_swift_isClassOrObjCExistentialType((uint64_t)v5, (uint64_t *)v5))
                {
                  Swift::UInt64 v121 = v62;
                  swift_dynamicCast(v23, (uint64_t *)&v121, v105, v5, 7uLL);
                  BOOL v63 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
                }

                else
                {
                  BOOL v63 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
                  v63(v103, 1LL, 1LL, v5);
                  _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v62, (uint64_t)v5, v103);
                  swift_unknownObjectRelease(v62);
                  uint64_t v90 = v101;
                  (*(void (**)(char *, uint64_t *, uint64_t))(v53 + 16))(v101, v103, v102);
                  if ((*(unsigned int (**)(char *, uint64_t, char *))(v8 + 48))(v90, 1LL, v5) == 1) {
                    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
                  }
                  (*(void (**)(uint64_t *, uint64_t))(v53 + 8))(v103, v102);
                  (*(void (**)(char *, char *, char *))(v8 + 32))(v23, v90, v5);
                }

                uint64_t v113 = v112;
                int64_t v114 = v55;
LABEL_69:
                v63((uint64_t *)v23, 0LL, 1LL, v5);
                unint64_t v67 = *(void (**)(id *, char *, char *))(v8 + 32);
                v67(v44, v23, v5);
                if (v110)
                {
                  if (_swift_isClassOrObjCExistentialType((uint64_t)v5, (uint64_t *)v5))
                  {
                    if (v9 != 8) {
                      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
                    }
                    uint64_t v71 = *v44;
                    swift_unknownObjectRetain(*v44, v68, v69, v70);
                    (*(void (**)(id *, char *))(v8 + 8))(v44, v5);
                  }

                  else
                  {
                    uint64_t v86 = v118;
                    v67(v118, (char *)v44, v5);
                    uint64_t v87 = v86;
                    uint64_t v23 = v96;
                    uint64_t v71 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v87, (uint64_t *)v5, v88, v89);
                  }

                  id v72 = objc_msgSend(v108, sel_member_, v71);
                  if (!v72)
                  {
                    swift_unknownObjectRelease(v71);
                    unint64_t v54 = v113;
                    int64_t v55 = v114;
                    unint64_t v39 = v111;
                    continue;
                  }

                  uint64_t v91 = v72;
                  swift_bridgeObjectRelease(v120);
                  swift_unknownObjectRelease(v71);
                  swift_unknownObjectRelease(v91);
                  uint64_t v31 = 0LL;
                  unint64_t v39 = v111;
                }

                else
                {
                  unint64_t v39 = v111;
                  if (!*(void *)(v120 + 16)
                    || (uint64_t v98 = v55,
                        uint64_t v73 = (*(uint64_t (**)(void, char *, uint64_t))(a4 + 32))( *(void *)(v120 + 40),  v5,  a4),  v74 = v120,  v75 = -1LL << *(_BYTE *)(v120 + 32),  v76 = v73 & ~v75,  ((*(void *)(v117 + ((v76 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v76) & 1) == 0))
                  {
                    (*(void (**)(id *, char *))(v8 + 8))(v44, v5);
                    unint64_t v54 = v113;
                    int64_t v55 = v114;
                    continue;
                  }

                  uint64_t v115 = ~v75;
                  uint64_t v77 = *(void *)(a4 + 8);
                  int64_t v78 = *(uint64_t (**)(id *, id *, char *, uint64_t))(v77 + 8);
                  uint64_t v79 = *(void *)(v8 + 72);
                  uint64_t v80 = v8;
                  uint64_t v81 = *(void (**)(id *, unint64_t, char *))(v8 + 16);
                  while (1)
                  {
                    uint64_t v82 = v118;
                    uint64_t v83 = v116;
                    v81(v118, *(void *)(v74 + 48) + v79 * v76, v116);
                    char v84 = v78(v82, v119, v83, v77);
                    uint64_t v85 = *(void (**)(id *, char *))(v80 + 8);
                    v85(v82, v83);
                    if ((v84 & 1) != 0) {
                      break;
                    }
                    unint64_t v76 = (v76 + 1) & v115;
                    uint64_t v74 = v120;
                    if (((*(void *)(v117 + ((v76 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v76) & 1) == 0)
                    {
                      unint64_t v44 = v119;
                      uint64_t v5 = v116;
                      v85(v119, v116);
                      unint64_t v54 = v113;
                      int64_t v55 = v114;
                      uint64_t v8 = v80;
                      a4 = v95;
                      uint64_t v9 = v94;
                      uint64_t v23 = v96;
                      uint64_t v53 = v104;
                      unint64_t v39 = v111;
                      goto LABEL_45;
                    }
                  }

                  swift_bridgeObjectRelease(v120);
                  v85(v119, v116);
                  uint64_t v31 = 0LL;
                  unint64_t v39 = v111;
                }

                goto LABEL_88;
              }

uint64_t Set._isDisjoint<A>(with:)(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v67 = a1;
  uint64_t v11 = *(a3 - 1);
  uint64_t v12 = *(void *)(v11 + 64);
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (id *)((char *)&v53 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v13);
  uint64_t v68 = (id *)((char *)&v53 - v15);
  uint64_t v18 = type metadata accessor for Optional(0LL, v16, v16, v17);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  BOOL v63 = (char *)&v53 - v20;
  uint64_t v21 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v53 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v55 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64_t v64 = (char *)&v53 - v24;
  unint64_t v62 = a2 & 0xC000000000000001LL;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      unint64_t v25 = (void *)a2;
    }
    else {
      unint64_t v25 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    if (objc_msgSend(v25, sel_count)) {
      goto LABEL_6;
    }
    return 1LL;
  }

  if (!*(void *)(a2 + 16)) {
    return 1LL;
  }
LABEL_6:
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v23, v67, a4);
  uint64_t v26 = v64;
  (*(void (**)(uint64_t, uint64_t))(a6 + 32))(a4, a6);
  uint64_t v27 = v26;
  unint64_t v28 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  id v30 = v63;
  uint64_t v60 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v61 = AssociatedConformanceWitness;
  v60(v28);
  uint64_t v31 = 1LL;
  id v59 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v11 + 48);
  if (v59(v30, 1LL, a3) == 1) {
    goto LABEL_30;
  }
  int64_t v32 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  uint64_t v58 = *(void (**)(id *, char *, uint64_t *))(v11 + 32);
  if (a2 < 0) {
    int64_t v32 = (void *)a2;
  }
  id v56 = v32;
  uint64_t v65 = a2 + 56;
  uint64_t v66 = v11;
  uint64_t v53 = v12;
  uint64_t v54 = a5;
  uint64_t v67 = a2;
  while (1)
  {
    v58(v68, v30, a3);
    if (!v62) {
      break;
    }
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
    {
      if (v12 != 8) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
      uint64_t v37 = v68;
      unint64_t v38 = *v68;
      swift_unknownObjectRetain(*v68, v34, v35, v36);
      (*(void (**)(id *, uint64_t *))(v11 + 8))(v37, a3);
    }

    else
    {
      v58(v14, (char *)v68, a3);
      unint64_t v38 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v14, a3, v50, v51);
    }

    id v39 = objc_msgSend(v56, sel_member_, v38, v53, v54);
    swift_unknownObjectRelease(v38);
    if (v39)
    {
      swift_unknownObjectRelease(v39);
      uint64_t v31 = 0LL;
      goto LABEL_29;
    }

uint64_t Set.union<A>(_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v35 = a5;
  uint64_t v37 = a1;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (id *)((char *)&v33 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v33 - v14;
  uint64_t v18 = type metadata accessor for Optional(0LL, v16, v16, v17);
  MEMORY[0x1895F8858](v18);
  uint64_t v20 = (char *)&v33 - v19;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v34 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v23 = (char *)&v33 - v22;
  uint64_t v38 = a2;
  (*(void (**)(uint64_t, uint64_t))(a6 + 32))(a4, a6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v25 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v36 = AssociatedTypeWitness;
  uint64_t v37 = v23;
  v25(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v26 = v25;
  uint64_t v27 = v10;
  unint64_t v28 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v10 + 48);
  if (v28(v20, 1LL, a3) != 1)
  {
    char v29 = *(void (**)(id *, char *, uint64_t))(v10 + 32);
    do
    {
      v29(v13, v20, a3);
      uint64_t v31 = type metadata accessor for Set._Variant(0LL, a3, v35, v30);
      Set._Variant.insert(_:)(v15, v13, v31);
      (*(void (**)(char *, uint64_t))(v27 + 8))(v15, a3);
      v26(v36, AssociatedConformanceWitness);
    }

    while (v28(v20, 1LL, a3) != 1);
  }

  (*(void (**)(char *, unint64_t))(v34 + 8))(v37, v36);
  return v38;
}

uint64_t Set.formUnion<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = a2;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (id *)((char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v30 - v11;
  uint64_t v15 = type metadata accessor for Optional(0LL, v6, v13, v14);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v30 - v16;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v31 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v20 = (char *)&v30 - v19;
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v22 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v33 = AssociatedTypeWitness;
  uint64_t v34 = v20;
  v22(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v23 = v22;
  uint64_t v24 = v7;
  unint64_t v25 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v7 + 48);
  if (v25(v17, 1LL, v6) != 1)
  {
    uint64_t v26 = *(void (**)(id *, char *, uint64_t))(v24 + 32);
    do
    {
      v26(v10, v17, v6);
      uint64_t v28 = type metadata accessor for Set._Variant(0LL, v6, *(void *)(v32 + 24), v27);
      Set._Variant.insert(_:)(v12, v10, v28);
      (*(void (**)(char *, uint64_t))(v24 + 8))(v12, v6);
      v23(v33, AssociatedConformanceWitness);
    }

    while (v25(v17, 1LL, v6) != 1);
  }

  return (*(uint64_t (**)(char *, unint64_t))(v31 + 8))(v34, v33);
}

__objc2_class **Set.subtracting<A>(_:)(uint64_t a1, uint64_t a2, char *a3, char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = (__objc2_class **)a2;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v12 = (void *)a2;
    }
    else {
      uint64_t v12 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(a2, a2, (uint64_t)a3, a4);
    uint64_t v13 = _NativeSet.init(_:capacity:)(v12, (uint64_t)objc_msgSend(v12, sel_count), a3, a5);
    swift_bridgeObjectRelease((uint64_t)v10);
    uint64_t v10 = v13;
  }

  return _NativeSet.subtracting<A>(_:)(a1, v10, (uint64_t)a3, (uint64_t)a4, a5, a6);
}

__objc2_class **Set._subtracting<A>(_:)(uint64_t a1, uint64_t a2, char *a3, char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = (__objc2_class **)a2;
  if ((a2 & 0xC000000000000001LL) != 0)
  {
    if (a2 < 0) {
      uint64_t v12 = (void *)a2;
    }
    else {
      uint64_t v12 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(a2, a2, (uint64_t)a3, a4);
    uint64_t v13 = _NativeSet.init(_:capacity:)(v12, (uint64_t)objc_msgSend(v12, sel_count), a3, a5);
    swift_bridgeObjectRelease((uint64_t)v10);
    uint64_t v10 = v13;
  }

  return _NativeSet.subtracting<A>(_:)(a1, v10, (uint64_t)a3, (uint64_t)a4, a5, a6);
}

id Set._subtract<A>(_:)(char *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v5 = v4;
  uint64_t v42 = a2;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = *(void *)(v8 - 8);
  char v49 = a1;
  uint64_t v50 = v9;
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (id *)((char *)&v42 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v47 = type metadata accessor for Optional(0LL, v8, v12, v13);
  uint64_t v45 = *(void *)(v47 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v47);
  uint64_t v44 = (char *)&v42 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v42 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v42 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = (uint64_t)a4;
  uint64_t v23 = a4;
  uint64_t v24 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v23,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v43 = *(void *)(AssociatedTypeWitness - 8);
  id result = (id)MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v27 = (char *)&v42 - v26;
  uint64_t v48 = v5;
  uint64_t v28 = *v5;
  if ((*v5 & 0xC000000000000001LL) != 0)
  {
    if (v28 < 0) {
      char v29 = (void *)*v5;
    }
    else {
      char v29 = (void *)(v28 & 0xFFFFFFFFFFFFFF8LL);
    }
    id result = objc_msgSend(v29, sel_count, v42);
    if (!result) {
      return result;
    }
  }

  else if (!*(void *)(v28 + 16))
  {
    return result;
  }

  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v21, v49, v24);
  (*(void (**)(uint64_t, uint64_t))(v22 + 32))(v24, v22);
  unint64_t v30 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v22,  v24,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v32 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
  char v49 = v27;
  unint64_t v46 = AssociatedConformanceWitness;
  v32(v30);
  unint64_t v33 = (void (*)(unint64_t, unint64_t))v32;
  uint64_t v34 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v50 + 48);
  int v35 = v34(v18, 1LL, v8);
  uint64_t v36 = v42;
  uint64_t v37 = (uint64_t)v44;
  uint64_t v38 = v45;
  if (v35 != 1)
  {
    id v39 = *(void (**)(id *, char *, uint64_t))(v50 + 32);
    do
    {
      v39(v11, v18, v8);
      uint64_t v41 = type metadata accessor for Set._Variant(0LL, v8, *(void *)(v36 + 24), v40);
      Set._Variant.remove(_:)(v11, v41, v37);
      (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v37, v47);
      (*(void (**)(id *, uint64_t))(v50 + 8))(v11, v8);
      v33(AssociatedTypeWitness, v46);
    }

    while (v34(v18, 1LL, v8) != 1);
  }

  return (id)(*(uint64_t (**)(char *, unint64_t))(v43 + 8))(v49, AssociatedTypeWitness);
}

__objc2_class **Set.intersection<A>(_:)(uint64_t a1, uint64_t a2, char *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v13 = (uint64_t *)((char *)&v26 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *, uint64_t, uint64_t))(v14 + 16))(v13, a1, v15);
  uint64_t v17 = (const char *)type metadata accessor for Set(0LL, (uint64_t)a3, a5, v16);
  if (swift_dynamicCast((char *)&v27, v13, a4, v17, 6uLL))
  {
    uint64_t v21 = v27;
    uint64_t v22 = Set._Variant.intersection(_:)(v27, a2, a3, a5);
    swift_bridgeObjectRelease(v21);
  }

  else
  {
    if ((a2 & 0xC000000000000001LL) != 0)
    {
      if (a2 < 0) {
        uint64_t v23 = (void *)a2;
      }
      else {
        uint64_t v23 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_bridgeObjectRetain(a2, v18, v19, v20);
      uint64_t v24 = _NativeSet.init(_:capacity:)(v23, (uint64_t)objc_msgSend(v23, sel_count), a3, a5);
      swift_bridgeObjectRelease(a2);
      a2 = (uint64_t)v24;
    }

    return _NativeSet.genericIntersection<A>(_:)(a1, a2, (uint64_t)a3, (uint64_t)a4, a5, a6);
  }

  return v22;
}

__objc2_class **Set.formIntersection<A>(_:)(uint64_t a1, uint64_t a2, swift *a3, uint64_t a4)
{
  id result = Set.intersection<A>(_:)(a1, *v4, *(char **)(a2 + 16), a3, *(void *)(a2 + 24), a4);
  *uint64_t v4 = (uint64_t)result;
  return result;
}

uint64_t Set.symmetricDifference<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, swift *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = Set.init<A>(_:)(a1, a3, a4, a5, a6);
  uint64_t v10 = type metadata accessor for Set(0LL, a3, a5, v9);
  Set.formSymmetricDifference(_:)((int64_t)v8, v10);
  return a2;
}

uint64_t Set.formSymmetricDifference<A>(_:)(uint64_t a1, uint64_t a2, swift *a3, uint64_t a4)
{
  uint64_t v5 = Set.init<A>(_:)(a1, *(void *)(a2 + 16), a3, *(void *)(a2 + 24), a4);
  return Set.formSymmetricDifference(_:)((int64_t)v5, a2);
}

uint64_t Set.formSymmetricDifference(_:)(int64_t a1, uint64_t a2)
{
  int64_t v3 = a1;
  uint64_t v70 = a2;
  uint64_t v4 = *(char **)(a2 + 16);
  uint64_t v5 = *((void *)v4 - 1);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v66 = (char *)&v56 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v9 = (id *)((char *)&v56 - v8);
  uint64_t v12 = type metadata accessor for Optional(0LL, (uint64_t)v4, v10, v11);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v65 = (uint64_t)&v56 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v22 = (char *)&v56 - v21;
  uint64_t v67 = v17;
  uint64_t v68 = v23;
  uint64_t v57 = v24;
  uint64_t v58 = v25;
  if ((v3 & 0xC000000000000001LL) != 0)
  {
    if (v3 < 0) {
      uint64_t v26 = v3;
    }
    else {
      uint64_t v26 = v3 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v27 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v28 = (unint64_t)swift_allocObject(v27, 0xE8uLL, 7uLL);
    int64_t v63 = 0LL;
    uint64_t v29 = 0LL;
    unint64_t v30 = 0LL;
    *(void *)(v28 + 208) = v26;
    *(void *)(v28 + 216) = 0LL;
    *(_OWORD *)(v28 + 16) = 0u;
    *(_OWORD *)(v28 + 32) = 0u;
    *(_OWORD *)(v28 + 48) = 0u;
    *(_OWORD *)(v28 + 64) = 0u;
    *(_OWORD *)(v28 + 80) = 0u;
    *(_OWORD *)(v28 + 96) = 0u;
    *(_OWORD *)(v28 + 112) = 0u;
    *(_OWORD *)(v28 + 128) = 0u;
    *(_OWORD *)(v28 + 144) = 0u;
    *(_OWORD *)(v28 + 160) = 0u;
    *(_OWORD *)(v28 + 176) = 0u;
    *(_OWORD *)(v28 + 192) = 0u;
    *(void *)(v28 + 224) = 0LL;
    int64_t v3 = v28 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v31 = -1LL << *(_BYTE *)(v3 + 32);
    uint64_t v32 = *(void *)(v3 + 56);
    int64_t v63 = v3 + 56;
    uint64_t v33 = ~v31;
    uint64_t v34 = -v31;
    if (v34 < 64) {
      uint64_t v35 = ~(-1LL << v34);
    }
    else {
      uint64_t v35 = -1LL;
    }
    unint64_t v30 = v35 & v32;
    uint64_t v29 = v33;
  }

  int64_t v69 = 0LL;
  uint64_t v60 = (v3 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v61 = (v3 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v59 = v29;
  int64_t v62 = (unint64_t)(v29 + 64) >> 6;
  int64_t v64 = (swift *)&unk_189B8D230;
  while (1)
  {
    if ((v3 & 0x8000000000000000LL) == 0)
    {
      if (v30)
      {
        unint64_t v38 = __clz(__rbit64(v30));
        v30 &= v30 - 1;
        unint64_t v39 = v38 | (v69 << 6);
      }

      else
      {
        int64_t v45 = v69 + 1;
        if (__OFADD__(v69, 1LL))
        {
          __break(1u);
LABEL_47:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
        }

        if (v45 >= v62) {
          goto LABEL_41;
        }
        unint64_t v46 = *(void *)(v63 + 8 * v45);
        if (!v46)
        {
          int64_t v47 = v69 + 2;
          if (v69 + 2 >= v62) {
            goto LABEL_41;
          }
          unint64_t v46 = *(void *)(v63 + 8 * v47);
          if (!v46)
          {
            while (1)
            {
              int64_t v45 = v47 + 1;
              if (__OFADD__(v47, 1LL)) {
                break;
              }
              if (v45 >= v62) {
                goto LABEL_41;
              }
              unint64_t v46 = *(void *)(v63 + 8 * v45);
              ++v47;
              if (v46) {
                goto LABEL_34;
              }
            }

            __break(1u);
LABEL_44:
            __break(1u);
LABEL_45:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
          }

          int64_t v45 = v69 + 2;
        }

void protocol witness for SetAlgebra.init() in conformance Set<A>(void *a1@<X8>)
{
  *a1 = &_swiftEmptySetSingleton;
}

uint64_t protocol witness for SetAlgebra.contains(_:) in conformance Set<A>(id *a1, uint64_t a2)
{
  return Set.contains(_:)(a1, *v2, *(uint64_t **)(a2 + 16), *(void *)(a2 + 24));
}

uint64_t protocol witness for SetAlgebra.union(_:) in conformance Set<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for SetAlgebra.union(_:) in conformance Set<A>( a1,  a2,  a3,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))Set.union<A>(_:),  a4);
}

uint64_t protocol witness for SetAlgebra.intersection(_:) in conformance Set<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = Set.intersection(_:)(*a1, *v3, *(void *)(a2 + 16), *(void *)(a2 + 24));
  *a3 = result;
  return result;
}

uint64_t protocol witness for SetAlgebra.symmetricDifference(_:) in conformance Set<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for SetAlgebra.union(_:) in conformance Set<A>( a1,  a2,  a3,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))Set.symmetricDifference<A>(_:),  a4);
}

uint64_t protocol witness for SetAlgebra.union(_:) in conformance Set<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t)@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10 = *v5;
  uint64_t v11 = *(void *)(a2 + 16);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  uint64_t result = a4(a1, v10, v11, a2, v12, WitnessTable);
  *a5 = result;
  return result;
}

uint64_t protocol witness for SetAlgebra.formUnion(_:) in conformance Set<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  return Set.formUnion<A>(_:)(a1, a2, a2, WitnessTable);
}

__objc2_class **protocol witness for SetAlgebra.formIntersection(_:) in conformance Set<A>( uint64_t a1, swift *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  return Set.formIntersection<A>(_:)(a1, (uint64_t)a2, a2, WitnessTable);
}

uint64_t protocol witness for SetAlgebra.formSymmetricDifference(_:) in conformance Set<A>( int64_t *a1, uint64_t a2)
{
  return Set.formSymmetricDifference(_:)(*a1, a2);
}

__objc2_class **protocol witness for SetAlgebra.subtracting(_:) in conformance Set<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, __objc2_class ***a3@<X8>)
{
  uint64_t result = Set.subtracting(_:)(*a1, *v3, *(char **)(a2 + 16), *(char **)(a2 + 24));
  *a3 = result;
  return result;
}

__objc2_class **Set.subtracting(_:)(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = a1;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 >= 0) {
      a1 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    uint64_t v8 = (uint64_t)objc_msgSend((id)a1, sel_count);
    if ((v6 & 0xC000000000000001LL) != 0)
    {
LABEL_5:
      if (v6 < 0) {
        uint64_t v9 = (void *)v6;
      }
      else {
        uint64_t v9 = (void *)(v6 & 0xFFFFFFFFFFFFFF8LL);
      }
      if (v8 > (uint64_t)objc_msgSend(v9, sel_count) / 8)
      {
        uint64_t v21 = v7;
        swift_bridgeObjectRetain(v6, v10, v11, a4);
        uint64_t v12 = _NativeSet.init(_:capacity:)(v9, (uint64_t)objc_msgSend(v9, sel_count), a3, (uint64_t)a4);
        swift_bridgeObjectRelease(v6);
        uint64_t v6 = (uint64_t)v12;
LABEL_13:
        uint64_t v13 = type metadata accessor for Set(0LL, (uint64_t)a3, (uint64_t)a4, (uint64_t)a4);
        uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, v13, v14);
        return _NativeSet.subtracting<A>(_:)( (uint64_t)&v21,  (__objc2_class **)v6,  (uint64_t)a3,  v13,  (uint64_t)a4,  WitnessTable);
      }

      goto LABEL_14;
    }
  }

  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    if ((a2 & 0xC000000000000001LL) != 0) {
      goto LABEL_5;
    }
  }

  if (v8 > *(void *)(v6 + 16) >> 3)
  {
    uint64_t v21 = v7;
    goto LABEL_13;
  }

uint64_t protocol witness for SetAlgebra.isSubset(of:) in conformance Set<A>(uint64_t *a1, uint64_t a2)
{
  return Set.isSubset(of:)(*a1, *v2, *(char **)(a2 + 16), *(void *)(a2 + 24));
}

uint64_t protocol witness for SetAlgebra.isDisjoint(with:) in conformance Set<A>(uint64_t *a1, uint64_t a2)
{
  return Set.isDisjoint(with:)(*a1, *v2, *(char **)(a2 + 16), *(void *)(a2 + 24));
}

uint64_t protocol witness for SetAlgebra.isSuperset(of:) in conformance Set<A>( int64_t *a1, uint64_t a2)
{
  return Set.isSuperset(of:)(*a1, *v2, *(char **)(a2 + 16), *(void *)(a2 + 24));
}

__objc2_class **protocol witness for SetAlgebra.init<A>(_:) in conformance Set<A>@<X0>( uint64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, __objc2_class ***a5@<X8>)
{
  uint64_t result = Set.init<A>(_:)(a1, *(void *)(a4 + 16), a2, *(void *)(a4 + 24), a3);
  *a5 = result;
  return result;
}

id protocol witness for SetAlgebra.subtract(_:) in conformance Set<A>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return Set.subtract(_:)(*a1, a2, a3);
}

id Set.subtract(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1;
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  return Set._subtract<A>(_:)((char *)&v6, a2, a2, WitnessTable);
}

uint64_t Set.description.getter(int64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v115 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = type metadata accessor for Optional(0LL, v7, v8, v9);
  MEMORY[0x1895F8858](v10);
  uint64_t v12 = (char *)&v115 - v11;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v127 = 91LL;
  unint64_t v128 = 0xE100000000000000LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v16 = a1;
    }
    else {
      uint64_t v16 = a1 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v17 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v18 = (unint64_t)swift_allocObject(v17, 0xE8uLL, 7uLL);
    uint64_t v119 = 0LL;
    uint64_t v19 = 0LL;
    unint64_t v20 = 0LL;
    *(void *)(v18 + 208) = v16;
    *(void *)(v18 + 216) = 0LL;
    *(_OWORD *)(v18 + 16) = 0u;
    *(_OWORD *)(v18 + 32) = 0u;
    *(_OWORD *)(v18 + 48) = 0u;
    *(_OWORD *)(v18 + 64) = 0u;
    *(_OWORD *)(v18 + 80) = 0u;
    *(_OWORD *)(v18 + 96) = 0u;
    *(_OWORD *)(v18 + 112) = 0u;
    *(_OWORD *)(v18 + 128) = 0u;
    *(_OWORD *)(v18 + 144) = 0u;
    *(_OWORD *)(v18 + 160) = 0u;
    *(_OWORD *)(v18 + 176) = 0u;
    *(_OWORD *)(v18 + 192) = 0u;
    *(void *)(v18 + 224) = 0LL;
    unint64_t v21 = v18 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v22 = -1LL << *(_BYTE *)(a1 + 32);
    uint64_t v19 = ~v22;
    uint64_t v23 = *(void *)(a1 + 56);
    uint64_t v119 = a1 + 56;
    uint64_t v24 = -v22;
    if (v24 < 64) {
      uint64_t v25 = ~(-1LL << v24);
    }
    else {
      uint64_t v25 = -1LL;
    }
    unint64_t v20 = v25 & v23;
    unint64_t v21 = a1;
  }

  uint64_t v121 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v115 = v19;
  int64_t v118 = (unint64_t)(v19 + 64) >> 6;
  unint64_t v26 = swift_bridgeObjectRetain(a1, v13, v14, v15);
  int64_t v122 = 0LL;
  unint64_t v30 = 1LL;
  __int128 v124 = xmmword_1817FFC60;
  __int128 v117 = xmmword_1817FFC70;
  unint64_t v120 = v21;
  uint64_t v116 = v6;
  while ((v21 & 0x8000000000000000LL) != 0)
  {
    id v38 = __CocoaSet.Iterator.next()(v26, v27, v28, v29);
    if (!v38) {
      goto LABEL_70;
    }
    uint64_t v40 = v38;
    _forceBridgeFromObjectiveC<A>(_:_:)(v38, (char *)v2, v39, v12);
    swift_unknownObjectRelease(v40);
LABEL_30:
    (*(void (**)(char *, void, uint64_t, uint64_t))(v4 + 56))(v12, 0LL, 1LL, v2);
    int64_t v45 = *(void (**)(char *, char *, uint64_t))(v4 + 32);
    v45(v6, v12, v2);
    if ((v30 & 1) != 0) {
      goto LABEL_13;
    }
    unint64_t v123 = v20;
    uint64_t v49 = v127;
    uint64_t v48 = v128;
    unint64_t v50 = HIBYTE(v128) & 0xF;
    if ((v128 & 0x2000000000000000LL) != 0) {
      unint64_t v51 = HIBYTE(v128) & 0xF;
    }
    else {
      unint64_t v51 = v127 & 0xFFFFFFFFFFFFLL;
    }
    if (!v51 && (v127 & ~v128 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v128);
      uint64_t v127 = 8236LL;
      unint64_t v128 = 0xE200000000000000LL;
      goto LABEL_12;
    }

    if ((v128 & 0x2000000000000000LL) == 0 || v50 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v46, v47);
      if ((v48 & 0x1000000000000000LL) == 0)
      {
        BOOL v57 = __OFADD__(v51, 2LL);
        int64_t v58 = v51 + 2;
        if (v57) {
          goto LABEL_69;
        }
LABEL_43:
        if ((v49 & ~v48 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v48 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v59 = _StringGuts.nativeUnusedCapacity.getter(v49, v48);
          if ((v60 & 1) != 0) {
            goto LABEL_115;
          }
          BOOL v62 = (v48 & 0x2000000000000000LL) == 0 && v59 > 1;
          if (v58 > 15 || v62) {
            goto LABEL_11;
          }
        }

        else if (v58 > 15)
        {
LABEL_11:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v58, 2LL);
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
          __int128 v126 = v117;
          uint64_t v31 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v126, 2LL);
          _StringGuts.appendInPlace(_:isASCII:)(v31, v32, 1);
          swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_12:
          unint64_t v20 = v123;
          goto LABEL_13;
        }

        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        swift_bridgeObjectRetain(v48, v63, v64, v65);
        unint64_t v66 = _StringGuts._convertedToSmall()(v49, v48);
        unint64_t v68 = v67;
        swift_bridgeObjectRelease(v48);
        v69._Swift::UInt64 rawBits = 131073LL;
        v70._Swift::UInt64 rawBits = 1LL;
        v71._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v70, v69, 0x202CuLL, 0xE200000000000000LL);
        if (v71._rawBits < 0x10000) {
          v71._rawBits |= 3;
        }
        unint64_t v73 = specialized String.init(_:)(v71, v72, 0x202CuLL, 0xE200000000000000LL);
        unint64_t v75 = v74;
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v76 = _StringGuts._convertedToSmall()(v73, v75);
        unint64_t v78 = v77;
        swift_bridgeObjectRelease(v75);
        unint64_t v79 = specialized _SmallString.init(_:appending:)(v66, v68, v76, v78);
        if ((v81 & 1) != 0) {
          goto LABEL_114;
        }
        uint64_t v82 = v79;
        unint64_t v83 = v80;
        swift_bridgeObjectRelease(v48);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        uint64_t v127 = v82;
        unint64_t v128 = v83;
        uint64_t v6 = v116;
        unint64_t v21 = v120;
        goto LABEL_12;
      }

      Swift::Int v86 = String.UTF8View._foreignCount()();
      int64_t v58 = v86 + 2;
      if (!__OFADD__(v86, 2LL)) {
        goto LABEL_43;
      }
LABEL_69:
      __break(1u);
LABEL_70:
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v4 + 56))(v12, 1LL, 1LL, v2);
      outlined consume of [A : B].Iterator._Variant<A, B>(v21);
      uint64_t v42 = v127;
      uint64_t v2 = v128;
      unint64_t v30 = HIBYTE(v128) & 0xF;
      uint64_t v12 = (char *)(v127 & 0xFFFFFFFFFFFFLL);
      if ((v128 & 0x2000000000000000LL) != 0) {
        unint64_t v89 = HIBYTE(v128) & 0xF;
      }
      else {
        unint64_t v89 = v127 & 0xFFFFFFFFFFFFLL;
      }
      if (!v89 && (v127 & ~v128 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v128);
        return 93LL;
      }

      if ((v128 & 0x2000000000000000LL) != 0 && v30 != 15)
      {
        if (v30 < 8) {
          uint64_t v42 = (93LL << (8 * (HIBYTE(v128) & 7u))) | ((-255LL << (8 * (HIBYTE(v128) & 7u))) - 1) & v127;
        }
        swift_bridgeObjectRelease(v128);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        return v42;
      }

      swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v87, v88);
      if ((v2 & 0x1000000000000000LL) != 0) {
        goto LABEL_103;
      }
      BOOL v57 = __OFADD__(v89, 1LL);
      uint64_t v90 = v89 + 1;
      if (!v57) {
        goto LABEL_82;
      }
LABEL_105:
      __break(1u);
      goto LABEL_106;
    }

    unint64_t v52 = 8 * (HIBYTE(v128) & 7);
    uint64_t v53 = (-255LL << v52) - 1;
    uint64_t v54 = 44LL << v52;
    char v55 = v50 + 1;
    if (v50 >= 8)
    {
      uint64_t v56 = v54 | v53 & v128;
      unint64_t v20 = v123;
    }

    else
    {
      uint64_t v49 = v54 | v53 & v127;
      unint64_t v20 = v123;
      if (v50 != 7)
      {
        uint64_t v49 = (32LL << (8 * (v55 & 7u))) | ((-255LL << (8 * (v55 & 7u))) - 1) & v49;
        uint64_t v84 = v128;
        goto LABEL_64;
      }

      char v55 = 8;
      uint64_t v56 = v128;
    }

    uint64_t v84 = (32LL << (8 * (v55 & 7u))) | ((-255LL << (8 * (v55 & 7u))) - 1) & v56;
LABEL_64:
    swift_bridgeObjectRelease(v128);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    unint64_t v85 = 0xE000000000000000LL;
    if (v49 & 0x8080808080808080LL | v84 & 0x80808080808080LL) {
      unint64_t v85 = 0xA000000000000000LL;
    }
    uint64_t v127 = v49;
    unint64_t v128 = (v85 & 0xFF00000000000000LL | (v50 << 56) | v84 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
    unint64_t v21 = v120;
LABEL_13:
    uint64_t v33 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v33, v125);
    *((_OWORD *)inited + 1) = v124;
    inited[7] = v2;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v45(boxed_opaque_existential_0Tm, v6, v2);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v127);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    unint64_t v30 = 0LL;
  }

  if (v20)
  {
    unint64_t v36 = __clz(__rbit64(v20));
    v20 &= v20 - 1;
    unint64_t v37 = v36 | (v122 << 6);
LABEL_29:
    (*(void (**)(char *, unint64_t, uint64_t))(v4 + 16))( v12,  *(void *)(v21 + 48) + *(void *)(v4 + 72) * v37,  v2);
    goto LABEL_30;
  }

  int64_t v41 = v122 + 1;
  uint64_t v42 = v119;
  if (__OFADD__(v122, 1LL)) {
    goto LABEL_102;
  }
  if (v41 >= v118) {
    goto LABEL_70;
  }
  unint64_t v43 = *(void *)(v119 + 8 * v41);
  if (v43)
  {
LABEL_28:
    unint64_t v20 = (v43 - 1) & v43;
    unint64_t v37 = __clz(__rbit64(v43)) + (v41 << 6);
    int64_t v122 = v41;
    goto LABEL_29;
  }

  int64_t v44 = v122 + 2;
  if (v122 + 2 >= v118) {
    goto LABEL_70;
  }
  unint64_t v43 = *(void *)(v119 + 8 * v44);
  if (v43)
  {
    int64_t v41 = v122 + 2;
    goto LABEL_28;
  }

  while (1)
  {
    int64_t v41 = v44 + 1;
    if (__OFADD__(v44, 1LL)) {
      break;
    }
    if (v41 >= v118) {
      goto LABEL_70;
    }
    unint64_t v43 = *(void *)(v119 + 8 * v41);
    ++v44;
    if (v43) {
      goto LABEL_28;
    }
  }

  __break(1u);
LABEL_102:
  __break(1u);
LABEL_103:
  Swift::Int v106 = String.UTF8View._foreignCount()();
  uint64_t v90 = v106 + 1;
  if (__OFADD__(v106, 1LL)) {
    goto LABEL_105;
  }
LABEL_82:
  if ((v42 & ~v2 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v91 = _StringGuts.nativeUnusedCapacity.getter(v42, v2);
    if ((v92 & 1) != 0)
    {
LABEL_115:
      unint64_t v111 = 258LL;
    }

    else
    {
      if (v90 > 15) {
        goto LABEL_88;
      }
      if ((v2 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        goto LABEL_91;
      }

      if (v91 > 0) {
        goto LABEL_88;
      }
LABEL_90:
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
      if ((v2 & 0x2000000000000000LL) != 0)
      {
LABEL_91:
        uint64_t v12 = (char *)v2;
      }

      else if ((v2 & 0x1000000000000000LL) != 0)
      {
        uint64_t v42 = _StringGuts._foreignConvertedToSmall()(v42, v2);
        uint64_t v12 = v114;
      }

      else
      {
        if ((v42 & 0x1000000000000000LL) != 0)
        {
          unint64_t v110 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          unint64_t v110 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v42, v2);
          uint64_t v12 = (char *)v95;
        }

        swift_bridgeObjectRetain(v2, v95, v96, v97);
        closure #1 in _StringGuts._convertedToSmall()(v110, (uint64_t)v12, &v126);
        swift_bridgeObjectRelease(v2);
        uint64_t v12 = (char *)*((void *)&v126 + 1);
        uint64_t v42 = v126;
      }

      v98._Swift::UInt64 rawBits = 1LL;
      v99._Swift::UInt64 rawBits = 65537LL;
      v100._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v98, v99, 0x5DuLL, 0xE100000000000000LL);
      if (v100._rawBits < 0x10000) {
        v100._rawBits |= 3;
      }
      unint64_t v30 = specialized String.init(_:)(v100, v101, 0x5DuLL, 0xE100000000000000LL);
      uint64_t v90 = v102;
      swift_bridgeObjectRelease(0xE100000000000000LL);
      if ((v90 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v90);
        goto LABEL_96;
      }

uint64_t Set.debugDescription.getter(int64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int64_t v3 = a1;
  uint64_t v212 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v5 = (char *)v210 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for Optional(0LL, v6, v7, v8);
  MEMORY[0x1895F8858](v9);
  v215 = (char *)v210 - v10;
  unint64_t v223 = 0LL;
  unint64_t v224 = 0xE000000000000000LL;
  uint64_t v11 = specialized static String._createEmpty(withInitialCapacity:)(4LL);
  uint64_t v15 = v11;
  unint64_t v16 = v12;
  *(void *)&__int128 v222 = v11;
  *((void *)&v222 + 1) = v12;
  uint64_t v17 = HIBYTE(v12) & 0xF;
  int64_t v18 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v12 & 0x2000000000000000LL) != 0) {
    uint64_t v19 = HIBYTE(v12) & 0xF;
  }
  else {
    uint64_t v19 = v11 & 0xFFFFFFFFFFFFLL;
  }
  if (!v19 && (v11 & ~v12 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v12);
    uint64_t v15 = 0LL;
    unint64_t v42 = 0xE000000000000000LL;
    *(void *)&__int128 v222 = 0LL;
LABEL_21:
    *((void *)&v222 + 1) = v42;
    goto LABEL_25;
  }

  if ((v12 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v12);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v46 = 0xA000000000000000LL;
    if (!(v16 & 0x80808080808080LL | v15 & 0x8080808080808080LL)) {
      unint64_t v46 = 0xE000000000000000LL;
    }
    unint64_t v42 = v46 & 0xFF00000000000000LL | (v17 << 56) | v16 & 0xFFFFFFFFFFFFFFLL;
    *(void *)&__int128 v222 = v15;
    goto LABEL_21;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v13, v14);
  if ((v16 & 0x1000000000000000LL) != 0)
  {
    int64_t v18 = String.UTF8View._foreignCount()();
    if ((v15 & ~v16 & 0x2000000000000000LL) == 0) {
      goto LABEL_23;
    }
  }

  else if ((v15 & ~v16 & 0x2000000000000000LL) == 0)
  {
    goto LABEL_23;
  }

  if (swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v15, v16);
    if ((v21 & 1) != 0) {
      goto LABEL_201;
    }
    if (v18 <= 15 && (v20 & 0x8000000000000000LL) != 0) {
      goto LABEL_13;
    }
LABEL_24:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v18, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    __int128 v220 = 0uLL;
    int64_t v47 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v220, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v47, v48, 1);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v42 = *((void *)&v222 + 1);
    uint64_t v15 = v222;
    goto LABEL_25;
  }

LABEL_199:
            __break(1u);
            goto LABEL_200;
          }

          int64_t v133 = v218 + 2;
        }

        v22.partialValue.low = 0LL;
        goto LABEL_193;
      }
    }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v7, 1LL);
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          unint64_t v198 = xmmword_1817FFDA0;
          unint64_t v169 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v198, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v169, v170, 1);
          swift_bridgeObjectRelease(0xE100000000000000LL);
          return v199;
        }

  v297 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    v297 = v450 & 0xFFFFFFFFFFFFLL;
  }
  v298 = v441;
  if (v297 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236LL;
    v451 = 0xE200000000000000LL;
  }

  v159(6LL, v199, v203);
  v445 = (uint64_t *)v1;
  v299 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v299, v298, v2);
  v300 = v445;
  v301 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v302 = (void *)swift_getDynamicType(v301, v300, 1);
  LODWORD(v300) = swift_isOptionalType(v302);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v300)
  {
    memcpy(v150, v298, v2);
    v303 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v303, 7uLL);
LABEL_206:
    v304 = (uint64_t)v445;
    v305 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v306 = (*(uint64_t (**)(uint64_t, uint64_t))(v305 + 8))(v304, v305);
    v308 = v307;
    specialized String.write<A>(to:)(&v450, v306, v307, v309);
    swift_bridgeObjectRelease(v308);
LABEL_207:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_210;
  }

  v310 = v433;
  memcpy(v433, v298, v2);
  if ((swift_dynamicCast((char *)&v444, v310, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v311 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v311);
  }

  else
  {
    v345 = v426;
    memcpy(v426, v298, v2);
    v346 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v345, v1, v346, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v347 = (uint64_t)v445;
      v348 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v348 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v347,  v348);
      goto LABEL_207;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v369 = v418;
    memcpy(v418, v298, v2);
    v370 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v369, v1, v370, 6uLL)
      || (v449 = 0LL,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?),  v371 = v410,  memcpy(v410, v298, v2),  v372 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v447, v371, v1, v372, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_206;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v448 + 1) = v1;
    v396 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v396, v298, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v397 = v444._object;
    v398 = v298;
    v399 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v398,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v399);
    swift_release((uint64_t)v397);
  }

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Set<A>(uint64_t a1)
{
  return Set.description.getter(*v1, *(void *)(a1 + 16));
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Set<A>( uint64_t a1)
{
  return Set.debugDescription.getter(*v1, *(void *)(a1 + 16));
}

__objc2_class **Set._Variant.intersection(_:)(unint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v70 = a4;
  uint64_t v7 = type metadata accessor for Optional(0LL, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v8 = MEMORY[0x1895F8858](v7);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  unint64_t v12 = (char *)&v60 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  unint64_t v20 = (char *)&v60 - v19;
  Swift::String::Index v73 = (__objc2_class **)a1;
  unint64_t v21 = a1 & 0xC000000000000001LL;
  if ((a2 & 0xC000000000000001LL) == 0)
  {
    if (!v21) {
      return _NativeSet.intersection(_:)((uint64_t)v73, a2, (uint64_t)a3, v70);
    }
    unint64_t v75 = v73;
    uint64_t v24 = (uint64_t)a3;
    uint64_t v23 = v70;
LABEL_8:
    uint64_t v25 = type metadata accessor for Set(0LL, v24, v23, v15);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, v25, v26);
    return _NativeSet.genericIntersection<A>(_:)((uint64_t)&v75, a2, (uint64_t)a3, v25, v23, WitnessTable);
  }

  if (v21)
  {
    if (a2 >= 0) {
      a2 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    id v22 = objc_msgSend((id)a2, sel_count);
    uint64_t v23 = v70;
    a2 = (uint64_t)_NativeSet.init(_:capacity:)((void *)a2, (uint64_t)v22, a3, v70);
    unint64_t v75 = v73;
    uint64_t v24 = (uint64_t)a3;
    goto LABEL_8;
  }

  uint64_t v72 = v14;
  uint64_t v61 = v18;
  uint64_t v62 = v17;
  uint64_t v63 = v16;
  uint64_t v64 = v13;
  unint64_t v75 = &_swiftEmptySetSingleton;
  if (a2 < 0) {
    uint64_t v29 = a2;
  }
  else {
    uint64_t v29 = a2 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v30 = type metadata accessor for __CocoaSet.Iterator();
  unint64_t v34 = swift_allocObject(v30, 0xE8uLL, 7uLL);
  uint64_t v35 = 0LL;
  *((_OWORD *)v34 + 1) = 0u;
  unint64_t v66 = v34 + 2;
  *((_OWORD *)v34 + 5) = 0u;
  uint64_t v65 = v34 + 10;
  v34[27] = 0LL;
  unint64_t v36 = v34 + 27;
  *((_OWORD *)v34 + 2) = 0u;
  *((_OWORD *)v34 + 3) = 0u;
  *((_OWORD *)v34 + 4) = 0u;
  *((_OWORD *)v34 + 6) = 0u;
  *((_OWORD *)v34 + 7) = 0u;
  *((_OWORD *)v34 + 8) = 0u;
  *((_OWORD *)v34 + 9) = 0u;
  *((_OWORD *)v34 + 10) = 0u;
  *((_OWORD *)v34 + 11) = 0u;
  *((_OWORD *)v34 + 12) = 0u;
  Swift::String::Index v71 = v73 + 7;
  v34[26] = v29;
  unint64_t v67 = (swift *)&unk_189B8D230;
  unint64_t v68 = v34 + 27;
  v34[28] = 0LL;
  unint64_t v69 = v34;
  while (v35 != v34[28])
  {
LABEL_17:
    uint64_t v38 = v34[3];
    if (!v38) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
    }
    if ((unint64_t)(v35 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_39:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    unint64_t v39 = (void **)(v38 + 8 * v35);
    unint64_t v40 = *v39;
    *unint64_t v36 = v35 + 1;
    swift_unknownObjectRetain(v40, v31, v32, v33);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      unint64_t v74 = v40;
      swift_dynamicCast(v20, (uint64_t *)&v74, v67, a3, 7uLL);
    }

    else
    {
      uint64_t v55 = v72;
      unint64_t v56 = v61;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v72 + 56))(v61, 1LL, 1LL, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v40, (uint64_t)a3, v56);
      swift_unknownObjectRelease(v40);
      uint64_t v58 = v62;
      uint64_t v57 = v63;
      uint64_t v59 = v64;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(v63 + 16))(v62, v56, v64);
      if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(v55 + 48))(v58, 1LL, a3) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v57 + 8))(v56, v59);
      (*(void (**)(char *, uint64_t, char *))(v55 + 32))(v20, v58, a3);
    }

    if (v73[2]
      && (char v41 = v73,
          uint64_t v42 = (*(uint64_t (**)(__objc2_class *, char *))(v70 + 32))(v73[5], a3),
          uint64_t v43 = -1LL << *((_BYTE *)v41 + 32),
          unint64_t v44 = v42 & ~v43,
          ((*(void *)((char *)v71 + ((v44 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v44) & 1) != 0))
    {
      uint64_t v45 = ~v43;
      uint64_t v46 = *(void *)(v70 + 8);
      int64_t v47 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v46 + 8);
      uint64_t v48 = *(void *)(v72 + 72);
      uint64_t v49 = *(void (**)(char *, char *, char *))(v72 + 16);
      while (1)
      {
        v49(v12, (char *)v73[6] + v48 * v44, a3);
        char v50 = v47(v12, v20, a3, v46);
        (*(void (**)(char *, char *))(v72 + 8))(v12, a3);
        if ((v50 & 1) != 0) {
          break;
        }
        unint64_t v44 = (v44 + 1) & v45;
      }

      uint64_t v52 = (uint64_t)v75;
      uint64_t v53 = v75[2];
      unint64_t v36 = v68;
      unint64_t v34 = v69;
      if (v75[3] <= v53)
      {
        Swift::Int v54 = (Swift::Int)&v53->isa + 1;
        type metadata accessor for _NativeSet(0LL, (uint64_t)a3, v70, v51);
        _NativeSet.resize(capacity:)(v54);
        uint64_t v52 = (uint64_t)v75;
      }

      _NativeSet._unsafeInsertNew(_:)((uint64_t)v20, v52, (uint64_t)a3, v70);
      uint64_t v35 = *v36;
      if (*v36 < 0) {
        goto LABEL_36;
      }
    }

    else
    {
LABEL_13:
      (*(void (**)(char *, char *))(v72 + 8))(v20, a3);
      unint64_t v36 = v68;
      unint64_t v34 = v69;
      uint64_t v35 = *v68;
      if (*v68 < 0) {
        goto LABEL_36;
      }
    }
  }

  id v37 = objc_msgSend((id)v34[26], sel_countByEnumeratingWithState_objects_count_, v66, v65, 16);
  v34[28] = v37;
  if (v37)
  {
    uint64_t v35 = 0LL;
    *unint64_t v36 = 0LL;
    goto LABEL_17;
  }

  *unint64_t v36 = -1LL;
LABEL_36:
  swift_release((uint64_t)v34);
  return v75;
}

unint64_t Set.Index._variant.getter(unint64_t a1, uint64_t a2, char a3, char *a4)
{
  return a1;
}

uint64_t Set.Index._variant.setter(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  return Dictionary.Index._variant.setter( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void))outlined consume of Set<A>.Index._Variant<A>);
}

uint64_t Dictionary.Index._variant.setter( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t (*a5)(void, void, void))
{
  uint64_t result = a5(*(void *)v5, *(void *)(v5 + 8), *(unsigned __int8 *)(v5 + 16));
  *(void *)uint64_t v5 = a1;
  *(void *)(v5 + 8) = a2;
  *(_BYTE *)(v5 + 16) = a3 & 1;
  return result;
}

uint64_t (*Set.Index._variant.modify())()
{
  return EnumeratedSequence._base.modify;
}

  ;
}

  ;
}

uint64_t Set.Index._guaranteedNative.getter()
{
  return 0LL;
}

Swift::Bool __swiftcall Set.Index._isUniquelyReferenced()()
{
  if ((*(_BYTE *)(v0 + 16) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
  }
  uint64_t v2 = *(void *)v0;
  uint64_t v1 = *(void *)(v0 + 8);
  else {
    uint64_t v3 = *(void *)v0;
  }
  uint64_t v4 = type metadata accessor for __CocoaSet.Index.Storage();
  swift_bridgeObjectRetain(v2, v5, v6, v7);
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  Swift::Bool v8 = 1;
  outlined consume of [A : B].Index._Variant<A, B>(v2, v1, 1);
  if (v3) {
    return swift_isUniquelyReferenced_nonNull_native(v3);
  }
  return v8;
}

uint64_t __CocoaSet.Index.handleBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return __CocoaDictionary.Index.handleBitPattern.getter(a1, a2, type metadata accessor for __CocoaSet.Index.Storage);
}

uint64_t __CocoaDictionary.Index.handleBitPattern.getter(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v4 = a3();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  return v3;
}

unint64_t key path getter for Set.Index._asCocoa : <A>Set<A>.Index@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, unint64_t *a5@<X8>)
{
  if ((*(_BYTE *)(a1 + 16) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
  }
  unint64_t v5 = *(void *)a1;
  unint64_t v6 = *(void *)(a1 + 8);
  *a5 = v5;
  a5[1] = v6;
  return swift_bridgeObjectRetain(v5, a2, a3, a4);
}

uint64_t key path setter for Set.Index._asCocoa : <A>Set<A>.Index( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  swift_bridgeObjectRetain(*a1, a2, a3, a4);
  unint64_t v6 = Set.Index._asCocoa.modify(v10);
  uint64_t v8 = *v7;
  *uint64_t v7 = v4;
  v7[1] = v5;
  swift_bridgeObjectRelease(v8);
  return ((uint64_t (*)(void *, void))v6)(v10, 0LL);
}

uint64_t (*Set.Index._asCocoa.modify(void *a1))(void)
{
  a1[2] = v1;
  if (*(_BYTE *)(v1 + 16) != 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x56FuLL,  0);
  }
  uint64_t v2 = *(void *)(v1 + 8);
  *a1 = *(void *)v1;
  a1[1] = v2;
  *(_BYTE *)(v1 + 16) = 0;
  *(void *)uint64_t v1 = 0LL;
  *(void *)(v1 + 8) = 0LL;
  return Set.Index._asCocoa.modify;
}

void *Dictionary.Index._asCocoa.modify(void *result)
{
  uint64_t v2 = result[1];
  uint64_t v1 = result[2];
  *(void *)uint64_t v1 = *result;
  *(void *)(v1 + 8) = v2;
  *(_BYTE *)(v1 + 16) = 1;
  return result;
}

void Set.Index._asCocoa.setter(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(v2 + 16) != 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x56FuLL,  0);
  }
  outlined consume of [A : B].Index._Variant<A, B>(*(void *)v2, *(void *)(v2 + 8), 1);
  *(void *)uint64_t v2 = a1;
  *(void *)(v2 + 8) = a2;
  *(_BYTE *)(v2 + 16) = 1;
}

BOOL static Set.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v7 = a4;
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0)
    {
      if ((_DWORD)a2 != (_DWORD)a5) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xD5uLL,  0);
      }
      return a1 == a4;
    }

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Set<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Equatable.== infix(_:_:) in conformance Set<A>.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void, void, void))static Set.Index.== infix(_:_:));
}

BOOL static Set.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v7 = a4;
  if ((a3 & 1) == 0)
  {
    if ((a6 & 1) == 0)
    {
      if ((_DWORD)a2 != (_DWORD)a5) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xE2uLL,  0);
      }
      return a1 < a4;
    }

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance Set<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Equatable.== infix(_:_:) in conformance Set<A>.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void, void, void))static Set.Index.< infix(_:_:));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Set<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void, void, void, void))
{
  return a5( *(void *)a1,  *(void *)(a1 + 8),  *(unsigned __int8 *)(a1 + 16),  *(void *)a2,  *(void *)(a2 + 8),  *(unsigned __int8 *)(a2 + 16));
}

void Set.Index.hash(into:)(uint64_t a1, Swift::UInt a2, Swift::UInt a3, char a4)
{
  if ((a4 & 1) != 0) {
    a2 = a3;
  }
  Hasher._combine(_:)(a4 & 1);
  Hasher._combine(_:)(a2);
}

Swift::Int Set.Index.hashValue.getter(Swift::UInt a1, Swift::UInt a2, char a3)
{
  if ((a3 & 1) != 0) {
    a1 = a2;
  }
  Hasher._combine(_:)(a3 & 1);
  Hasher._combine(_:)(a1);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Set<A>.Index()
{
  return Set.Index.hashValue.getter(*(void *)v0, *(void *)(v0 + 8), *(_BYTE *)(v0 + 16));
}

void protocol witness for Hashable.hash(into:) in conformance Set<A>.Index(uint64_t a1)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Set<A>.Index(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  Set.Index.hash(into:)((uint64_t)v3, *(void *)v1, *(void *)(v1 + 8), *(_BYTE *)(v1 + 16));
  return Hasher._finalize()();
}

uint64_t Set.Iterator._variant.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v5 = type metadata accessor for Set.Iterator._Variant(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a3, v3, v5);
}

__n128 Set.Iterator._variant.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for Set.Iterator._Variant(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  (*(void (**)(_OWORD *, uint64_t, uint64_t))(*(void *)(v6 - 8) + 32LL))(v11, a1, v6);
  __n128 v9 = (__n128)v11[1];
  __n128 v10 = (__n128)v11[0];
  unint64_t v7 = v12;
  outlined consume of [A : B].Iterator._Variant<A, B>(v4->n128_u64[0]);
  __n128 result = v9;
  *__int128 v4 = v10;
  v4[1] = v9;
  v4[2].n128_u64[0] = v7;
  return result;
}

uint64_t (*Set.Iterator._variant.modify())()
{
  return EnumeratedSequence._base.modify;
}

double Set.Iterator.init(_variant:)@<D0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = type metadata accessor for Set.Iterator._Variant(0LL, a2, a3, a4);
  (*(void (**)(_OWORD *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(v11, a1, v7);
  uint64_t v8 = v12;
  double result = *(double *)v11;
  __int128 v10 = v11[1];
  *(_OWORD *)a5 = v11[0];
  *(_OWORD *)(a5 + 16) = v10;
  *(void *)(a5 + 32) = v8;
  return result;
}

__n128 Set.Iterator.init(_native:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __n128 result = *(__n128 *)a1;
  __int128 v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = v2;
  return result;
}

double Set.Iterator.init(_cocoa:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = a1 | 0x8000000000000000LL;
  double result = 0.0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  return result;
}

uint64_t Set.Iterator._guaranteedNative.getter()
{
  return 0LL;
}

BOOL Set.Iterator._isNative.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for Set.Iterator._Variant(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  uint64_t v6 = *(void (**)(_BYTE *, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32LL);
  v6(v8, v4, v5);
  v6(v9, (uint64_t)v8, v5);
  return v9[0] >= 0LL;
}

unint64_t *Dictionary.Iterator._asNative.getter@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = *((void *)v4 + 4);
  __int128 v6 = *v4;
  __int128 v7 = v4[1];
  *(_OWORD *)a4 = *v4;
  *(_OWORD *)(a4 + 16) = v7;
  *(void *)(a4 + 32) = v5;
  return swift_retain((unint64_t *)v6, a1, a2, a3);
}

double Set.Iterator._asNative.setter(__n128 *a1, uint64_t a2)
{
  *(void *)&double result = Dictionary.Iterator._asNative.setter( a1,  a2,  (void (*)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t))outlined consume of Set<String>.Iterator._Variant).n128_u64[0];
  return result;
}

__n128 Dictionary.Iterator._asNative.setter( __n128 *a1, uint64_t a2, void (*a3)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t))
{
  __n128 v6 = a1[1];
  __n128 v7 = *a1;
  unint64_t v4 = a1[2].n128_u64[0];
  a3(v3->n128_u64[0], v3->n128_u64[1], v3[1].n128_u64[0], v3[1].n128_u64[1], v3[2].n128_u64[0]);
  __n128 result = v6;
  *uint64_t v3 = v7;
  v3[1] = v6;
  v3[2].n128_u64[0] = v4;
  return result;
}

void (*Set.Iterator._asNative.modify( void *a1))(unint64_t ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v3 = malloc(0x30uLL);
  *a1 = v3;
  uint64_t v4 = *((void *)v1 + 4);
  __int128 v5 = *v1;
  __int128 v6 = v1[1];
  *uint64_t v3 = *v1;
  v3[1] = v6;
  *((void *)v3 + 4) = v4;
  *((void *)v3 + 5) = v1;
  swift_retain((unint64_t *)v5, v7, v8, v9);
  return Set.Iterator._asNative.modify;
}

void Set.Iterator._asNative.modify(unint64_t ***a1, uint64_t a2, uint64_t a3, char *a4)
{
}

void Dictionary.Iterator._asNative.modify( unint64_t ***a1, uint64_t a2, void (*a3)(unint64_t *, unint64_t *, unint64_t *, unint64_t *, unint64_t *), char *a4)
{
  uint64_t v4 = *a1;
  __int128 v6 = **a1;
  __int128 v5 = (*a1)[1];
  uint64_t v7 = (*a1)[2];
  uint64_t v8 = (unint64_t **)(*a1)[5];
  uint64_t v15 = (*a1)[3];
  uint64_t v16 = (*a1)[4];
  __n128 v9 = *v8;
  __int128 v10 = v8[1];
  uint64_t v11 = v8[2];
  uint64_t v12 = v8[3];
  uint64_t v13 = v8[4];
  if ((a2 & 1) != 0)
  {
    swift_retain(v6, a2, (uint64_t)a3, a4);
    a3(v9, v10, v11, v12, v13);
    *uint64_t v8 = v6;
    v8[1] = v5;
    v8[2] = v7;
    v8[3] = v15;
    v8[4] = v16;
    swift_release((uint64_t)*v4);
  }

  else
  {
    a3(*v8, v8[1], v8[2], v8[3], v8[4]);
    *uint64_t v8 = v6;
    v8[1] = v5;
    v8[2] = v7;
    v8[3] = v15;
    v8[4] = v16;
  }

  free(v4);
}

uint64_t protocol witness for IteratorProtocol.next() in conformance Set<A>.Iterator@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v7 = *v5;
  if (*v5 < 0)
  {
    uint64_t v17 = *(char **)(result + 16);
    id v18 = __CocoaSet.Iterator.next()(result, a2, a3, a4);
    if (v18)
    {
      unint64_t v20 = v18;
      _forceBridgeFromObjectiveC<A>(_:_:)(v18, v17, v19, a5);
      swift_unknownObjectRelease(v20);
      unint64_t v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v17 - 1) + 56LL);
      id v22 = a5;
      uint64_t v23 = 0LL;
    }

    else
    {
      unint64_t v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *))(*((void *)v17 - 1) + 56LL);
      id v22 = a5;
      uint64_t v23 = 1LL;
    }

    return v21(v22, v23, 1LL, v17);
  }

  else
  {
    uint64_t v8 = v5[1];
    uint64_t v9 = v5[2];
    int64_t v11 = v5[3];
    unint64_t v10 = v5[4];
    if (v10)
    {
      uint64_t v12 = (v10 - 1) & v10;
      unint64_t v13 = __clz(__rbit64(v10)) | (v11 << 6);
LABEL_4:
      uint64_t v14 = *(void *)(result + 16);
      uint64_t v15 = *(void *)(v14 - 8);
      (*(void (**)(char *, unint64_t, uint64_t))(v15 + 16))( a5,  *(void *)(v7 + 48) + *(void *)(v15 + 72) * v13,  v14);
      __n128 result = (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(a5, 0LL, 1LL, v14);
      int64_t v16 = v11;
LABEL_20:
      *__int128 v5 = v7;
      v5[1] = v8;
      v5[2] = v9;
      v5[3] = v16;
      v5[4] = v12;
      return result;
    }

    int64_t v24 = v11 + 1;
    if (!__OFADD__(v11, 1LL))
    {
      int64_t v25 = (unint64_t)(v9 + 64) >> 6;
      int64_t v16 = v5[3];
      if (v24 < v25)
      {
        unint64_t v26 = *(void *)(v8 + 8 * v24);
        if (v26)
        {
LABEL_10:
          uint64_t v12 = (v26 - 1) & v26;
          unint64_t v13 = __clz(__rbit64(v26)) + (v24 << 6);
          int64_t v11 = v24;
          goto LABEL_4;
        }

        int64_t v16 = v11 + 1;
        if (v11 + 2 < v25)
        {
          unint64_t v26 = *(void *)(v8 + 8 * (v11 + 2));
          int64_t v24 = v11 + 2;
          if (v26) {
            goto LABEL_10;
          }
          int64_t v16 = v25 - 1;
          int64_t v27 = v11 + 3;
          while (v25 != v27)
          {
            unint64_t v26 = *(void *)(v8 + 8 * v27++);
            if (v26)
            {
              int64_t v24 = v27 - 1;
              goto LABEL_10;
            }
          }
        }
      }

      __n128 result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(result + 16) - 8LL) + 56LL))( a5,  1LL,  1LL);
      uint64_t v12 = 0LL;
      goto LABEL_20;
    }

    __break(1u);
  }

  return result;
}

uint64_t Set.Iterator.customMirror.getter@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  __int128 v6 = *(_OWORD *)(v3 + 16);
  v9[0] = *(_OWORD *)v3;
  v9[1] = v6;
  uint64_t v10 = *(void *)(v3 + 32);
  uint64_t v7 = type metadata accessor for Set.Iterator._Variant(0LL, a1[2], a1[3], a2);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(v11, v3, v7);
  outlined retain of [A : B].Iterator._Variant( v11,  (void (*)(void, void, void, void, void))outlined copy of Set<A>.Iterator._Variant<A>);
  return specialized Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)( (uint64_t)v9,  8,  0LL,  0LL,  (swift *)a1,  a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Set<A>.Iterator@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  return Set.Iterator.customMirror.getter(a1, a2, a3);
}

uint64_t Set.customMirror.getter@<X0>( int64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v67 = a1;
  uint64_t v9 = (swift *)type metadata accessor for Set(0LL, a2, a3, a4);
  v64[0] = 0LL;
  v64[1] = 0LL;
  swift_bridgeObjectRetain(a1, v10, v11, v12);
  unint64_t v13 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v67, (uint64_t)v64, v9);
  uint64_t v15 = v14;
  int64_t v16 = swift_allocObject((uint64_t)&unk_189B78398, 0x28uLL, 7uLL);
  v16[2] = v9;
  v16[3] = v9;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, v9, v17);
  v16[4] = WitnessTable;
  uint64_t v19 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for (label: String?, value: Any));
  uint64_t v21 = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, v9, v20);
  uint64_t v22 = type metadata accessor for LazyMapSequence(255LL, (uint64_t)v9, v19, v21);
  uint64_t v66 = WitnessTable;
  uint64_t v23 = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v22, &v66);
  uint64_t v25 = type metadata accessor for _CollectionBox(0LL, v22, v23, v24);
  uint64_t v29 = swift_allocObject(v25, 0x48uLL, 7uLL);
  v29[6] = a1;
  v29[7] = closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)partial apply;
  v29[8] = v16;
  uint64_t v62 = v13;
  unint64_t v63 = a1 & 0xC000000000000001LL;
  uint64_t v61 = v15;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    if (a1 < 0) {
      uint64_t v30 = (void *)a1;
    }
    else {
      uint64_t v30 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(a1, v26, v27, v28);
    unint64_t v31 = (unint64_t)objc_msgSend(v30, sel_count);
    uint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
    if ((v31 - 0x1000000000000000LL) >> 61 == 7)
    {
      if (!__OFADD__(8 * v31, 24LL))
      {
        unint64_t v33 = swift_bufferAllocate(result, 8 * v31 + 24, 7uLL);
        v33[2] = v31;
        objc_msgSend(v30, sel_getObjects_, v33 + 3);
        uint64_t v34 = type metadata accessor for __CocoaSet.Index.Storage();
        uint64_t v35 = swift_allocObject(v34, 0x20uLL, 7uLL);
        uint64_t v36 = 0LL;
        _OWORD v35[2] = v30;
        v35[3] = v33;
        goto LABEL_15;
      }
    }

    else
    {
      __break(1u);
    }

    __break(1u);
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }

  unint64_t v37 = *(void *)(a1 + 56);
  if (v37)
  {
    uint64_t v38 = 0LL;
LABEL_13:
    uint64_t v35 = (void *)(__clz(__rbit64(v37)) + v38);
  }

  else
  {
    uint64_t v38 = 0LL;
    uint64_t v35 = (void *)(1LL << *(_BYTE *)(a1 + 32));
    unint64_t v39 = (((unint64_t)v35 + 63) >> 6) - 1;
    unint64_t v40 = (unint64_t *)(a1 + 64);
    while (v39)
    {
      unint64_t v41 = *v40++;
      unint64_t v37 = v41;
      --v39;
      v38 += 64LL;
      if (v41) {
        goto LABEL_13;
      }
    }
  }

  uint64_t v36 = *(unsigned int *)(a1 + 36);
LABEL_15:
  uint64_t v42 = type metadata accessor for Set.Index(255LL, a2, a3, (uint64_t)v28);
  uint64_t v44 = type metadata accessor for _IndexBox(0LL, v42, (uint64_t)&protocol witness table for Set<A>.Index, v43);
  uint64_t v48 = swift_allocObject(v44, 0x21uLL, 7uLL);
  v48[2] = v35;
  v48[3] = v36;
  *((_BYTE *)v48 + 32) = v63 != 0;
  if (!v63)
  {
    uint64_t v53 = (void *)(1LL << *(_BYTE *)(a1 + 32));
    uint64_t v54 = *(unsigned int *)(a1 + 36);
    goto LABEL_23;
  }

  if (a1 < 0) {
    uint64_t v49 = (void *)a1;
  }
  else {
    uint64_t v49 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
  }
  swift_bridgeObjectRetain(a1, v45, v46, v47);
  unint64_t v50 = (unint64_t)objc_msgSend(v49, sel_count);
  uint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v50 - 0x1000000000000000LL) >> 61 != 7) {
    goto LABEL_28;
  }
  if (__OFADD__(8 * v50, 24LL))
  {
LABEL_29:
    __break(1u);
    return result;
  }

  uint64_t v51 = swift_bufferAllocate(result, 8 * v50 + 24, 7uLL);
  v51[2] = v50;
  objc_msgSend(v49, sel_getObjects_, v51 + 3);
  uint64_t v52 = type metadata accessor for __CocoaSet.Index.Storage();
  uint64_t v53 = swift_allocObject(v52, 0x20uLL, 7uLL);
  v53[2] = v49;
  v53[3] = v51;
  uint64_t v54 = v51[2];
LABEL_23:
  uint64_t v55 = swift_allocObject(v44, 0x21uLL, 7uLL);
  v55[2] = v53;
  v55[3] = v54;
  *((_BYTE *)v55 + 32) = v63 != 0;
  v29[2] = v48;
  v29[3] = &protocol witness table for _IndexBox<A>;
  v29[4] = v55;
  v29[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v65 = v67;
  swift_bridgeObjectRetain(a1, v56, v57, v58);
  uint64_t v59 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v64, &v65, v9, v59, 6uLL);
  char v60 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v64);
  }
  *(void *)a5 = v9;
  *(void *)(a5 + 8) = v29;
  *(_BYTE *)(a5 + 16) = 7;
  *(void *)(a5 + 24) = v62;
  *(void *)(a5 + 32) = v61;
  *(_BYTE *)(a5 + 40) = v60;
  return result;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Set<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  return Set.customMirror.getter(*v3, *(void *)(a1 + 16), *(void *)(a1 + 24), a2, a3);
}

unint64_t Set.popFirst()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = *v2 & 0xC000000000000001LL;
  if (!v7)
  {
    if (*(void *)(v5 + 16))
    {
      uint64_t v17 = *(void *)(a1 + 24);
      uint64_t v16 = _NativeSet.startIndex.getter(*v2);
      uint64_t v22 = v23;
      goto LABEL_11;
    }

id Set.capacity.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 24);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

id Set._Variant.capacity.getter(uint64_t a1)
{
  if ((a1 & 0xC000000000000001LL) == 0) {
    return *(id *)(a1 + 24);
  }
  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  return objc_msgSend((id)a1, sel_count);
}

Swift::Void __swiftcall Set.reserveCapacity(_:)(Swift::Int a1)
{
}

Swift::Void __swiftcall Set._Variant.reserveCapacity(_:)(Swift::Int a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v6 = *v2;
  unint64_t v7 = *(char **)(v1 + 16);
  if ((v6 & 0xC000000000000001LL) != 0)
  {
    if (v6 < 0) {
      uint64_t v8 = (void *)v6;
    }
    else {
      uint64_t v8 = (void *)(v6 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v9 = objc_msgSend(v8, sel_count);
    else {
      Swift::Int v10 = (Swift::Int)v9;
    }
    *uint64_t v3 = (uint64_t)_NativeSet.init(_:capacity:)(v8, v10, v7, *(void *)(v4 + 24));
  }

  else
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v6);
    BOOL v13 = isUniquelyReferenced_nonNull_native;
    uint64_t v16 = *v3;
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    if (*(void *)(v14 + 24) >= a1)
    {
      if (!isUniquelyReferenced_nonNull_native)
      {
        type metadata accessor for _NativeSet(0LL, (uint64_t)v7, *(void *)(v4 + 24), v12);
        _NativeSet.copy()();
      }
    }

    else
    {
      type metadata accessor for _NativeSet(0LL, (uint64_t)v7, *(void *)(v4 + 24), v12);
      if (v13) {
        _NativeSet.resize(capacity:)(a1);
      }
      else {
        _NativeSet.copyAndResize(capacity:)(a1);
      }
    }

    uint64_t v15 = *v3;
    *uint64_t v3 = v16;
    swift_bridgeObjectRelease(v15);
  }

uint64_t SetAlgebra.init<A>(_:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return SetAlgebra.init<A>(_:)(a1, a4, a2, a5, a3, a6);
}

uint64_t SetAlgebra.isStrictSuperset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  Swift::Int v10 = (char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  BOOL v13 = (char *)&v20 - v12;
  char v15 = (*(uint64_t (**)(uint64_t))(v14 + 144))(v11);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  v16(v13, v3, a2);
  v16(v10, a1, a2);
  if ((v15 & 1) != 0) {
    char v17 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3 + 8) + 8LL))(v13, v10, a2) ^ 1;
  }
  else {
    char v17 = 0;
  }
  uint64_t v18 = *(void (**)(char *, uint64_t))(v7 + 8);
  v18(v10, a2);
  v18(v13, a2);
  return v17 & 1;
}

uint64_t SetAlgebra.isStrictSubset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  BOOL v13 = (char *)&v20 - v12;
  char v15 = (*(uint64_t (**)(uint64_t))(v14 + 144))(v4);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v16(v13, a1, a2);
  v16(v11, v4, a2);
  if ((v15 & 1) != 0) {
    char v17 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3 + 8) + 8LL))(v13, v11, a2) ^ 1;
  }
  else {
    char v17 = 0;
  }
  uint64_t v18 = *(void (**)(char *, uint64_t))(v8 + 8);
  v18(v11, a2);
  v18(v13, a2);
  return v17 & 1;
}

uint64_t Set<>.insert<A>(_:)(char *a1, uint64_t a2, uint64_t (***a3)(), uint64_t a4)
{
  char v6 = specialized Set._Variant.insert(_:)((uint64_t)v11, (uint64_t)v10);
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 48))(v10, v7, v8);
  outlined destroy of AnyHashable(v11);
  swift_dynamicCast(a1, v10, (swift *)byte_189B8D218, (const char *)a3, 7uLL);
  return v6 & 1;
}

uint64_t Set<>.update<A>(with:)@<X0>( uint64_t a1@<X0>, uint64_t (***a2)()@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
  *(void *)&v13[0] = *v4;
  *uint64_t v4 = 0x8000000000000000LL;
  specialized _NativeSet.update(with:isUnique:)(&v15, isUniquelyReferenced_nonNull_native, (uint64_t)v18);
  uint64_t v8 = *v4;
  *uint64_t v4 = *(void *)&v13[0];
  swift_bridgeObjectRelease(v8);
  outlined init with take of AnyHashable?((uint64_t)v18, (uint64_t)&v15);
  if (!*((void *)&v16 + 1)) {
    return ((uint64_t (*)(char *, uint64_t, uint64_t, uint64_t (***)()))(*(a2 - 1))[7])( a4,  1LL,  1LL,  a2);
  }
  v13[0] = v15;
  v13[1] = v16;
  uint64_t v9 = v17;
  uint64_t v14 = v17;
  uint64_t v10 = *((void *)&v16 + 1);
  __swift_project_boxed_opaque_existential_0Tm(v13, *((uint64_t *)&v16 + 1));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v9 + 48))(v12, v10, v9);
  outlined destroy of AnyHashable((uint64_t *)v13);
  swift_dynamicCast(a4, v12, (swift *)byte_189B8D218, (const char *)a2, 7uLL);
  return ((uint64_t (*)(char *, void, uint64_t, uint64_t (***)()))(*(a2 - 1))[7])(a4, 0LL, 1LL, a2);
}

uint64_t Set<>.remove<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t (***a2)()@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v7 = (uint64_t)*(a2 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v7 + 16))(v9);
  AnyHashable.init<A>(_:)((uint64_t)v9, a2, a3, (uint64_t)&v16);
  specialized Set._Variant.remove(_:)(&v16, (uint64_t)v19);
  outlined destroy of AnyHashable((uint64_t *)&v16);
  outlined init with take of AnyHashable?((uint64_t)v19, (uint64_t)&v16);
  if (!*((void *)&v17 + 1)) {
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t (***)()))(v7 + 56))(a4, 1LL, 1LL, a2);
  }
  v14[0] = v16;
  v14[1] = v17;
  uint64_t v10 = v18;
  uint64_t v15 = v18;
  uint64_t v11 = *((void *)&v17 + 1);
  __swift_project_boxed_opaque_existential_0Tm(v14, *((uint64_t *)&v17 + 1));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v10 + 48))(v13, v11, v10);
  outlined destroy of AnyHashable((uint64_t *)v14);
  swift_dynamicCast(a4, v13, (swift *)byte_189B8D218, (const char *)a2, 7uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, uint64_t (***)()))(v7 + 56))(a4, 0LL, 1LL, a2);
}

__objc2_class **_NativeSet.bridged()(__objc2_class **a1, uint64_t *a2, void *a3)
{
  if (one-time initialization token for _bridgeInitializedSuccessfully != -1) {
    swift_once( &one-time initialization token for _bridgeInitializedSuccessfully,  (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully,  a3);
  }
  if (!_bridgeInitializedSuccessfully) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0x82uLL,  0);
  }
  _orphanedFoundationSubclassesReparented = 1;
  if (a1 == &_swiftEmptySetSingleton)
  {
    a1 = &_swiftEmptySetSingleton;
    swift_release((uint64_t)&_swiftEmptySetSingleton);
  }

  else if (a1[2])
  {
    if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
    {
      uint64_t v7 = type metadata accessor for _SetStorage(0LL, (uint64_t)a2, (uint64_t)a3, v6);
      if (!swift_dynamicCastClass((uint64_t)a1, v7)) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
      }
    }

    else
    {
      uint64_t v8 = type metadata accessor for _SwiftDeferredNSSet(0LL, (uint64_t)a2, (uint64_t)a3, v6);
      uint64_t v9 = swift_allocObject(v8, 0x20uLL, 7uLL);
      _OWORD v9[2] = 0LL;
      v9[3] = a1;
      return (__objc2_class **)v9;
    }
  }

  else
  {
    swift_release((uint64_t)a1);
    return &_swiftEmptySetSingleton;
  }

  return a1;
}

void _SwiftSetNSEnumerator.init()()
{
  *(void *)(v0 + 24) = 0LL;
  swift_release(v0);
  __break(1u);
}

void @objc _SwiftSetNSEnumerator.init()()
{
}

void *_SwiftSetNSEnumerator.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = v4;
  v5[3] = 0LL;
  uint64_t v7 = *(unint64_t **)(a1 + 24);
  v5[2] = v7;
  uint64_t v8 = swift_retain(v7, a2, a3, a4);
  uint64_t v9 = _SwiftDeferredNSSet.bridgeElements()((uint64_t)v8);
  swift_release(a1);
  uint64_t v10 = v5[3];
  v5[3] = v9;
  swift_release(v10);
  uint64_t v11 = v5[2];
  uint64_t v12 = -1LL << *(_BYTE *)(v11 + 32);
  v5[4] = _HashTable.startBucket.getter((unint64_t *)(v11 + 56), ~v12);
  void v5[5] = -v12;
  return v5;
}

void *_SwiftDeferredNSSet.bridgeElements()(uint64_t a1)
{
  uint64_t v2 = v1 + 2;
  uint64_t v3 = *(uint64_t **)(*v1 + 96);
  uint64_t v4 = *(v3 - 1);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  MEMORY[0x1895F8858](v5);
  uint64_t v9 = (id *)((char *)&v53 - v8);
  uint64_t v10 = (void *)atomic_load(v1 + 2);
  if (v10)
  {
    unint64_t v11 = type metadata accessor for __BridgingHashBuffer(0LL);
    id v15 = swift_unknownObjectRetain(v10, v12, v13, v14);
    return v10;
  }

  uint64_t v54 = v7;
  uint64_t v59 = v6;
  uint64_t v16 = v1[3];
  uint64_t v17 = -1LL << *(_BYTE *)(v16 + 32);
  uint64_t v18 = ~v17;
  unint64_t v19 = type metadata accessor for __BridgingHashBuffer(0LL);
  uint64_t v60 = v17;
  uint64_t v20 = swift_allocObject(v19, 40 - 8 * v17, 7uLL);
  v20[2] = v16;
  v20[3] = v16 + 56;
  uint64_t v58 = v16 + 56;
  v20[4] = v18;
  swift_retain((unint64_t *)v16, v21, v22, v23);
  unint64_t v55 = v19;
  if (-v60 < 64) {
    uint64_t v26 = ~(-1LL << -(char)v60);
  }
  else {
    uint64_t v26 = -1LL;
  }
  unint64_t v27 = *(void *)(v16 + 56) & v26;
  int64_t v28 = (unint64_t)(63 - v60) >> 6;
  uint64_t v56 = v20;
  uint64_t v57 = v16;
  uint64_t v60 = (uint64_t)(v20 + 5);
  swift_retain_n(v16, 2LL, v24, v25);
  int64_t v29 = 0LL;
  while (1)
  {
    if (v27)
    {
      unint64_t v30 = __clz(__rbit64(v27));
      v27 &= v27 - 1;
      unint64_t v31 = v30 | (v29 << 6);
      goto LABEL_21;
    }

    if (__OFADD__(v29++, 1LL)) {
      goto LABEL_35;
    }
    if (v29 >= v28) {
      break;
    }
    unint64_t v33 = *(void *)(v58 + 8 * v29);
    if (!v33)
    {
      int64_t v34 = v29 + 1;
      if (v29 + 1 >= v28) {
        break;
      }
      unint64_t v33 = *(void *)(v58 + 8 * v34);
      if (!v33)
      {
        while (1)
        {
          int64_t v29 = v34 + 1;
          if (__OFADD__(v34, 1LL)) {
            break;
          }
          if (v29 >= v28) {
            goto LABEL_25;
          }
          unint64_t v33 = *(void *)(v58 + 8 * v29);
          ++v34;
          if (v33) {
            goto LABEL_20;
          }
        }

        __break(1u);
LABEL_35:
        __break(1u);
LABEL_36:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
      }

      ++v29;
    }

char *_SwiftDictionaryNSEnumerator.bridgedKey(at:)(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(*v1 + 96LL);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (id *)((char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v10 = v1[3];
  if (v10)
  {
    unint64_t v11 = *(char **)(v10 + 8 * v4 + 40);
    swift_unknownObjectRetain(v11, v5, v6, v7);
  }

  else
  {
    (*(void (**)(id *, uint64_t, uint64_t *))(v3 + 16))( v9,  *(void *)(v1[2] + 48LL) + *(void *)(v3 + 72) * v4,  v2);
    unint64_t v11 = _bridgeAnythingToObjectiveC<A>(_:)(v9, v2);
    (*(void (**)(id *, uint64_t *))(v3 + 8))(v9, v2);
  }

  return v11;
}

char *_SwiftSetNSEnumerator.nextObject()()
{
  uint64_t offset = v0[4].offset;
  if (offset == v0[5].offset) {
    return 0LL;
  }
  v0[4].uint64_t offset = _HashTable.occupiedBucket(after:)(v0[4]).offset;
  return _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
}

id @objc _SwiftSetNSEnumerator.nextObject()(unint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return @objc _SwiftDictionaryNSEnumerator.nextObject()( a1,  a2,  (uint64_t (*)(unint64_t *))_SwiftSetNSEnumerator.nextObject(),  a4);
}

id @objc _SwiftDictionaryNSEnumerator.nextObject()( unint64_t *a1, uint64_t a2, uint64_t (*a3)(unint64_t *), char *a4)
{
  uint64_t v6 = swift_retain(a1, a2, (uint64_t)a3, a4);
  uint64_t v7 = (void *)a3(v6);
  swift_release((uint64_t)a1);
  return v7;
}

uint64_t @objc _SwiftSetNSEnumerator.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, char *))specialized _SwiftSetNSEnumerator.countByEnumerating(with:objects:count:));
}

uint64_t @objc _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t (*a6)(uint64_t, char *))
{
  uint64_t v10 = a6(a3, a4);
  swift_release((uint64_t)a1);
  return v10;
}

uint64_t @objc _SwiftSetNSEnumerator.init(coder:)(uint64_t a1, uint64_t a2, void *a3)
{
  return @objc _SwiftSetNSEnumerator.init(coder:)(a1, a2, a3, (char *)specialized _SwiftSetNSEnumerator.init(coder:));
}

uint64_t _SwiftDictionaryNSEnumerator.__ivar_destroyer()
{
  return swift_release(*(void *)(v0 + 24));
}

void _SwiftDictionaryNSEnumerator.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = v4[2];
  swift_retain(v4, a2, a3, a4);
  swift_release(v5);
  uint64_t v6 = v4[3];
  swift_release((uint64_t)v4);
  swift_release(v6);
  swift_deallocClassInstance((uint64_t)v4);
}

void @objc _SwiftDeferredNSSet.init(objects:count:)()
{
}

  ;
}

void *_SwiftDeferredNSSet.member(_:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = *v4;
  uint64_t v8 = *(char **)(*v4 + 96);
  uint64_t v9 = type metadata accessor for Optional(0LL, (uint64_t)v8, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)v46 - v12;
  uint64_t v14 = *((void *)v8 - 1);
  uint64_t v15 = MEMORY[0x1895F8858](v11);
  uint64_t v17 = (char *)v46 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)v46 - v18;
  _conditionallyBridgeFromObjectiveC<A>(_:_:)(a1, v8, v20, v13);
  if ((*(unsigned int (**)(char *, uint64_t, char *))(v14 + 48))(v13, 1LL, v8) == 1)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, v9);
    return 0LL;
  }

  (*(void (**)(char *, char *, char *))(v14 + 32))(v19, v13, v8);
  uint64_t v21 = v5[3];
  uint64_t v22 = *(void *)(v21 + 40);
  uint64_t v23 = *(void *)(v7 + 104);
  uint64_t v24 = *(uint64_t (**)(uint64_t, char *, uint64_t))(v23 + 32);
  swift_retain((unint64_t *)v21, v25, v26, v27);
  uint64_t v28 = v24(v22, v8, v23);
  uint64_t v29 = -1LL << *(_BYTE *)(v21 + 32);
  unint64_t v30 = v28 & ~v29;
  uint64_t v31 = v21;
  uint64_t v49 = v21 + 56;
  if (((*(void *)(v21 + 56 + ((v30 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v30) & 1) == 0)
  {
    swift_release(v21);
    id v38 = *(void (**)(char *, char *))(v14 + 8);
LABEL_9:
    v38(v19, v8);
    return 0LL;
  }

  unint64_t v50 = v19;
  v46[1] = v5;
  uint64_t v47 = ~v29;
  uint64_t v32 = *(void *)(v23 + 8);
  uint64_t v48 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v32 + 8);
  uint64_t v33 = *(void *)(v14 + 72);
  uint64_t v34 = v14;
  uint64_t v35 = *(void (**)(char *, unint64_t, char *))(v14 + 16);
  while (1)
  {
    uint64_t v36 = v31;
    v35(v17, *(void *)(v31 + 48) + v33 * v30, v8);
    char v37 = v48(v17, v50, v8, v32);
    id v38 = *(void (**)(char *, char *))(v34 + 8);
    v38(v17, v8);
    if ((v37 & 1) != 0) {
      break;
    }
    unint64_t v30 = (v30 + 1) & v47;
    uint64_t v31 = v36;
    if (((*(void *)(v49 + ((v30 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v30) & 1) == 0)
    {
      swift_release(v36);
      unint64_t v19 = v50;
      goto LABEL_9;
    }
  }

  swift_release(v36);
  uint64_t v41 = ((uint64_t (*)(char *, char *))v38)(v50, v8);
  uint64_t v42 = _SwiftDeferredNSSet.bridgeElements()(v41);
  unint64_t v39 = (void *)v42[v30 + 5];
  swift_unknownObjectRetain(v39, v43, v44, v45);
  swift_release((uint64_t)v42);
  return v39;
}

id @objc _SwiftDeferredNSSet.member(_:)(unint64_t *a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDeferredNSDictionary.object(forKey:)(a1, a2, a3, (char *)_SwiftDeferredNSSet.member(_:));
}

void *_SwiftDeferredNSSet.objectEnumerator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for _SwiftSetNSEnumerator(0LL, *(void *)(*v4 + 96), *(void *)(*v4 + 104), a4);
  uint64_t v6 = swift_allocObject(v5, 0x30uLL, 7uLL);
  uint64_t v10 = swift_retain(v4, v7, v8, v9);
  _SwiftSetNSEnumerator.init(_:)((uint64_t)v10, v11, v12, v13);
  return v6;
}

id @objc _SwiftDeferredNSSet.objectEnumerator()(unint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return @objc _SwiftDictionaryNSEnumerator.nextObject()( a1,  a2,  (uint64_t (*)(unint64_t *))_SwiftDeferredNSSet.objectEnumerator(),  a4);
}

uint64_t @objc _SwiftDeferredNSSet.count.getter()
{
  return _SwiftDeferredNSSet.count.getter();
}

uint64_t _SwiftDeferredNSSet.count.getter()
{
  return *(void *)(*(void *)(v0 + 24) + 16LL);
}

uint64_t _SwiftDeferredNSSet.countByEnumerating(with:objects:count:)( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a3;
  uint64_t v8 = *(void *)(v4 + 24);
  uint64_t v9 = v8 + 56;
  uint64_t v10 = -1LL << *(_BYTE *)(v8 + 32);
  uint64_t v11 = *(void *)a1;
  __int128 v27 = *(_OWORD *)(a1 + 48);
  __int128 v28 = *(_OWORD *)(a1 + 32);
  if (*(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 8);
    uint64_t v12 = *(Swift::UInt **)(a1 + 16);
    unint64_t v14 = *(void *)(a1 + 24);
    if (a2) {
      goto LABEL_3;
    }
    return 0LL;
  }

  unint64_t v23 = _HashTable.startBucket.getter((unint64_t *)(v8 + 56), ~v10);
  if ((v23 & 0x8000000000000000LL) != 0) {
    goto LABEL_32;
  }
  unint64_t v14 = v23;
  uint64_t v12 = &_fastEnumerationStorageMutationsTarget;
  uint64_t v11 = 1LL;
  uint64_t v13 = a2;
  if (!a2) {
    return 0LL;
  }
LABEL_3:
  if ((v14 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  uint64_t v15 = -v10;
  if (!(v14 + v10)) {
    goto LABEL_7;
  }
  if ((uint64_t)v14 >= v15)
  {
    swift_retain((unint64_t *)v8, a2, a3, a4);
LABEL_36:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid fast enumeration state",  30LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x10EuLL,  0);
  }

  if (((*(void *)(v9 + ((v14 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v14) & 1) == 0) {
    goto LABEL_36;
  }
LABEL_7:
  uint64_t v25 = v13;
  uint64_t v26 = v12;
  uint64_t v16 = swift_retain((unint64_t *)v8, a2, a3, a4);
  uint64_t v17 = _SwiftDeferredNSSet.bridgeElements()((uint64_t)v16);
  if (v5 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v5)
  {
    uint64_t v18 = 0LL;
    unint64_t v19 = (unint64_t)(63 - v10) >> 6;
    do
    {
      if (v14 == v15)
      {
        unint64_t v14 = -v10;
        uint64_t v5 = v18;
        break;
      }

      if (v18 == 0x1000000000000000LL)
      {
        __break(1u);
LABEL_32:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
      }

      *(void *)(a2 + 8 * v18) = v17[v14 + 5];
      unint64_t v20 = v14 >> 6;
      if ((*(void *)(v9 + 8 * (v14 >> 6)) & (-2LL << v14)) != 0)
      {
        unint64_t v14 = __clz(__rbit64(*(void *)(v9 + 8 * (v14 >> 6)) & (-2LL << v14))) | v14 & 0xFFFFFFFFFFFFFFC0LL;
      }

      else
      {
        unint64_t v21 = v20 + 1;
        unint64_t v14 = -v10;
        if (v20 + 1 < v19)
        {
          unint64_t v22 = *(void *)(v9 + 8 * v21);
          if (!v22)
          {
            unint64_t v21 = v20 + 2;
            unint64_t v14 = -v10;
            if (v20 + 2 >= v19) {
              goto LABEL_11;
            }
            unint64_t v22 = *(void *)(v9 + 8 * v21);
            if (!v22)
            {
              while (v19 - 3 != v20)
              {
                unint64_t v22 = *(void *)(v8 + 80 + 8 * v20++);
                if (v22)
                {
                  unint64_t v21 = v20 + 2;
                  goto LABEL_17;
                }
              }

              unint64_t v14 = -v10;
              goto LABEL_11;
            }
          }

uint64_t @objc _SwiftDeferredNSSet.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, char *, uint64_t))_SwiftDeferredNSSet.countByEnumerating(with:objects:count:));
}

void _SwiftDeferredNSSet.__allocating_init(coder:)()
{
}

uint64_t @objc _SwiftDeferredNSSet.init(coder:)(uint64_t a1, uint64_t a2, void *a3)
{
  return @objc _SwiftSetNSEnumerator.init(coder:)(a1, a2, a3, (char *)_SwiftDeferredNSSet.__allocating_init(coder:));
}

uint64_t @objc _SwiftSetNSEnumerator.init(coder:)(uint64_t a1, uint64_t a2, void *a3, char *a4)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 96LL);
  uint64_t v5 = *(void *)(*(void *)a1 + 104LL);
  swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
  return ((uint64_t (*)(uint64_t, uint64_t))a4)(v4, v5);
}

void _SwiftDeferredNSSet.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (void *)v4[2];
  swift_retain(v4, a2, a3, a4);
  swift_unknownObjectRelease(v5);
  uint64_t v6 = v4[3];
  swift_release((uint64_t)v4);
  swift_release(v6);
  swift_deallocClassInstance((uint64_t)v4);
}

id __CocoaSet.member(for:)(uint64_t a1, id a2)
{
  return objc_msgSend(a2, sel_member_, a1);
}

unint64_t __CocoaSet.startIndex.getter(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(a1, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v5 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v5, 24LL))
    {
      uint64_t v7 = swift_bufferAllocate(result, 8 * v5 + 24, 7uLL);
      v7[2] = v5;
      objc_msgSend(a1, sel_getObjects_, v7 + 3);
      swift_unknownObjectRelease(a1);
      uint64_t v8 = type metadata accessor for __CocoaSet.Index.Storage();
      uint64_t v9 = swift_allocObject(v8, 0x20uLL, 7uLL);
      _OWORD v9[2] = a1;
      v9[3] = v7;
      swift_unknownObjectRetain(a1, v10, v11, v12);
      return (unint64_t)v9;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t __CocoaSet.endIndex.getter(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(a1, a2, a3, a4), sel_count);
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v5 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v5, 24LL))
    {
      uint64_t v7 = swift_bufferAllocate(result, 8 * v5 + 24, 7uLL);
      v7[2] = v5;
      objc_msgSend(a1, sel_getObjects_, v7 + 3);
      swift_unknownObjectRelease(a1);
      uint64_t v8 = type metadata accessor for __CocoaSet.Index.Storage();
      uint64_t v9 = swift_allocObject(v8, 0x20uLL, 7uLL);
      _OWORD v9[2] = a1;
      v9[3] = v7;
      swift_unknownObjectRetain(a1, v10, v11, v12);
      return (unint64_t)v9;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t __CocoaSet.index(after:)(int64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v7 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v6, v7)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v6 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x169uLL,  0);
  }
  if (*(void *)(*(void *)(v6 + 24) + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x16BuLL,  0);
  }
  return swift_bridgeObjectRetain(a1, v8, v9, v10);
}

uint64_t __CocoaSet.formIndex(after:isUnique:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  if (*a1 < 0) {
    uint64_t v6 = *a1;
  }
  else {
    uint64_t v6 = *a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v7 = type metadata accessor for __CocoaSet.Index.Storage();
  uint64_t result = swift_dynamicCastClass(v6, v7);
  if (!result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (*(void *)(v6 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index",  13LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x169uLL,  0);
  }
  if (v5 >= *(void *)(*(void *)(v6 + 24) + 16LL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to access endIndex",  26LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x16BuLL,  0);
  }
  a1[1] = v5 + 1;
  return result;
}

void *__CocoaSet.index(for:)(void *a1, id a2)
{
  id v4 = objc_msgSend(a2, sel_member_, a1);
  if (!v4) {
    return 0LL;
  }
  swift_unknownObjectRelease(v4);
  unint64_t v8 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(a2, v5, v6, v7), sel_count);
  unint64_t v9 = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v8 - 0x1000000000000000LL) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_11;
  }

  if (__OFADD__(8 * v8, 24LL))
  {
LABEL_11:
    __break(1u);
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v10 = swift_bufferAllocate(v9, 8 * v8 + 24, 7uLL);
  v10[2] = v8;
  objc_msgSend(a2, sel_getObjects_, v10 + 3);
  swift_unknownObjectRelease(a2);
  if ((v10[2] & 0x8000000000000000LL) != 0) {
    goto LABEL_12;
  }
  swift_unknownObjectRetain(v10, v11, v12, v13);
  uint64_t v17 = 0LL;
  do
  {
    uint64_t v18 = v17 + 1;
    unint64_t v19 = (void *)v10[v17 + 3];
    swift_unknownObjectRetain(v19, v14, v15, v16);
    char isEqual = swift_stdlib_NSObject_isEqual(a1, v19);
    swift_unknownObjectRelease(v19);
    uint64_t v17 = v18;
  }

  while ((isEqual & 1) == 0);
  swift_unknownObjectRelease(v10);
  uint64_t v21 = type metadata accessor for __CocoaSet.Index.Storage();
  unint64_t v22 = swift_allocObject(v21, 0x20uLL, 7uLL);
  void v22[2] = a2;
  v22[3] = v10;
  swift_unknownObjectRetain(a2, v23, v24, v25);
  return v22;
}

id __CocoaSet.member(for:)(uint64_t a1, uint64_t a2)
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v4 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  uint64_t v8 = *(void *)(v3 + 24);
  if (*(void *)(v8 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1E1uLL,  0);
  }
  return swift_unknownObjectRetain(*(id *)(v8 + 8 * a2 + 24), v5, v6, v7);
}

void __CocoaDictionary.Index.Storage.__deallocating_deinit()
{
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance __CocoaSet.Index( uint64_t *a1, uint64_t *a2)
{
  return specialized static __CocoaSet.Index.== infix(_:_:)(*a1, a1[1], *a2, a2[1]);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance __CocoaSet.Index( uint64_t *a1, uint64_t *a2)
{
  return specialized static __CocoaSet.Index.< infix(_:_:)(*a1, a1[1], *a2, a2[1]);
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaSet.Index( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.<= infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))specialized static __CocoaSet.Index.< infix(_:_:));
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaSet.Index( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.>= infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))specialized static __CocoaSet.Index.< infix(_:_:));
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance __CocoaSet.Index( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Comparable.> infix(_:_:) in conformance __CocoaDictionary.Index( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void))specialized static __CocoaSet.Index.< infix(_:_:));
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance __CocoaDictionary.Index( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void, void))
{
  return a5(*a2, a2[1], *a1, a1[1]);
}

uint64_t __CocoaSet.Iterator.deinit()
{
  return v0;
}

void __CocoaDictionary.Iterator.__deallocating_deinit()
{
}

double protocol witness for Sequence.makeIterator() in conformance __CocoaSet@<D0>(void *a1@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance __CocoaDictionary( type metadata accessor for __CocoaSet.Iterator,  a1);
}

double protocol witness for Sequence.makeIterator() in conformance __CocoaDictionary@<D0>( uint64_t (*a1)(void)@<X2>, void *a2@<X8>)
{
  uint64_t v4 = *v2;
  uint64_t v5 = a1();
  uint64_t v6 = swift_allocObject(v5, 0xE8uLL, 7uLL);
  double result = 0.0;
  *((_OWORD *)v6 + 1) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 10) = 0u;
  *((_OWORD *)v6 + 11) = 0u;
  *((_OWORD *)v6 + 12) = 0u;
  v6[27] = 0LL;
  v6[28] = 0LL;
  v6[26] = v4;
  *a2 = v6;
  return result;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance __CocoaSet()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized _copySequenceToContiguousArray<A>(_:)(*v0);
  swift_unknownObjectRelease(v1);
  return v2;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance __CocoaSet( void *a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

id protocol witness for IteratorProtocol.next() in conformance __CocoaSet.Iterator@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, void *a5@<X8>)
{
  id result = __CocoaSet.Iterator.next()(a1, a2, a3, a4);
  *a5 = result;
  return result;
}

int64_t Set._bridgeToObjectiveCImpl()(int64_t result, uint64_t *a2, void *a3)
{
  if ((result & 0xC000000000000001LL) == 0) {
    return (int64_t)_NativeSet.bridged()((__objc2_class **)result, a2, a3);
  }
  if (result >= 0) {
    return result & 0xFFFFFFFFFFFFFF8LL;
  }
  return result;
}

__objc2_class **static Set._bridgeFromObjectiveCAdoptingNativeStorageOf(_:)( __objc2_class **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for _SwiftDeferredNSSet(0LL, a2, a3, a4);
  id v11 = swift_unknownObjectRetain(a1, v8, v9, v10);
  uint64_t v12 = swift_dynamicCastClass((uint64_t)v11, v7);
  if (v12)
  {
    uint64_t v14 = v12;
    swift_unknownObjectRelease(a1);
    uint64_t v15 = *(unint64_t **)(v14 + 24);
    swift_retain(v15, v16, v17, v18);
    swift_unknownObjectRelease(a1);
  }

  else
  {
    uint64_t v19 = type metadata accessor for _SetStorage(0LL, a2, a3, v13);
    uint64_t v15 = (unint64_t *)swift_dynamicCastClass((uint64_t)a1, v19);
    swift_unknownObjectRelease(a1);
    if (!v15)
    {
      swift_unknownObjectRelease(a1);
      if (a1 == &_swiftEmptySetSingleton) {
        return &_swiftEmptySetSingleton;
      }
      else {
        return 0LL;
      }
    }
  }

  return (__objc2_class **)v15;
}

uint64_t _SetBuilder._target.setter(uint64_t a1)
{
  uint64_t result = swift_release(*v1);
  uint64_t *v1 = a1;
  return result;
}

uint64_t (*_SetBuilder._target.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SetBuilder._requestedCount.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

__objc2_class **_SetBuilder.init(count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptySetSingleton;
  }
  type metadata accessor for _SetStorage(0LL, a2, a3, a4);
  return (__objc2_class **)static _SetStorage.allocate(capacity:)(a1);
}

uint64_t _SetBuilder.add(member:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *v2;
  if (*(void *)(*v2 + 16) >= v2[1]) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't add more members than promised",  36LL,  2,  "Swift/SetBuilder.swift",  22LL,  2,  0x22uLL,  0);
  }
  (*(void (**)(char *))(v5 + 16))(v7);
  return _NativeSet._unsafeInsertNew(_:)((uint64_t)v7, v8, v4, *(void *)(a2 + 24));
}

uint64_t _SetBuilder.take()(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 16) != a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "The number of members added does not match the promised count",  61LL,  2,  "Swift/SetBuilder.swift",  22LL,  2,  0x29uLL,  0);
  }
  return result;
}

void _swift_setDownCastIndirect( unint64_t *a1, uint64_t *a2, uint64_t *a3, char *a4, void *a5, uint64_t a6)
{
  uint64_t v11 = *a1;
  unint64_t v12 = swift_bridgeObjectRetain(*a1, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v13 = _setDownCast<A, B>(_:)(v12, a3, (ValueMetadata *)a4, a5, a6);
  swift_bridgeObjectRelease(v11);
  *a2 = v13;
}

uint64_t _setDownCast<A, B>(_:)(int64_t a1, uint64_t *a2, ValueMetadata *a3, void *a4, uint64_t a5)
{
  uint64_t v131 = a5;
  int64_t v126 = a1;
  uint64_t v8 = *(a2 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  id v130 = (char *)&v116 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v129 = *(void *)(v11 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v116 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v128 = (char *)&v116 - v15;
  uint64_t v19 = type metadata accessor for Optional(0LL, v16, v17, v18);
  uint64_t v20 = *(void *)(v19 - 8);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v116 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v120 = (uint64_t *)((char *)&v116 - v25);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v119 = (char *)&v116 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v125 = (uint64_t *)((char *)&v116 - v29);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v32 = (char *)&v116 - v31;
  MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v116 - v33;
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a2, a2)
    || !_swift_isClassOrObjCExistentialType((uint64_t)a3, &a3->Kind))
  {
    uint64_t v116 = v23;
    unint64_t v40 = v126 & 0xC000000000000001LL;
    if ((v126 & 0xC000000000000001LL) != 0)
    {
      if (v126 < 0) {
        uint64_t v41 = (void *)v126;
      }
      else {
        uint64_t v41 = (void *)(v126 & 0xFFFFFFFFFFFFFF8LL);
      }
      id v42 = objc_msgSend(v41, sel_count, v116);
      if (v42) {
        goto LABEL_12;
      }
    }

    else
    {
      id v42 = *(id *)(v126 + 16);
      if (v42)
      {
LABEL_12:
        type metadata accessor for _SetStorage(0LL, (uint64_t)a3, v131, (uint64_t)v37);
        uint64_t v43 = (unint64_t *)static _SetStorage.allocate(capacity:)((uint64_t)v42);
        goto LABEL_15;
      }
    }

    uint64_t v43 = (unint64_t *)&_swiftEmptySetSingleton;
LABEL_15:
    unint64_t v44 = v126;
    int64_t v133 = v43;
    uint64_t v117 = v19;
    uint64_t v118 = v20;
    if (a3 == &type metadata for String)
    {
      if (v40)
      {
        if (v126 < 0) {
          unint64_t v51 = v126;
        }
        else {
          unint64_t v51 = v126 & 0xFFFFFFFFFFFFFF8LL;
        }
        uint64_t v52 = type metadata accessor for __CocoaSet.Iterator();
        unint64_t v53 = (unint64_t)swift_allocObject(v52, 0xE8uLL, 7uLL);
        int64_t v123 = 0LL;
        uint64_t v54 = 0LL;
        unint64_t v55 = 0LL;
        *(void *)(v53 + 208) = v51;
        *(void *)(v53 + 216) = 0LL;
        *(_OWORD *)(v53 + 16) = 0u;
        *(_OWORD *)(v53 + 32) = 0u;
        *(_OWORD *)(v53 + 48) = 0u;
        *(_OWORD *)(v53 + 64) = 0u;
        *(_OWORD *)(v53 + 80) = 0u;
        *(_OWORD *)(v53 + 96) = 0u;
        *(_OWORD *)(v53 + 112) = 0u;
        *(_OWORD *)(v53 + 128) = 0u;
        *(_OWORD *)(v53 + 144) = 0u;
        *(_OWORD *)(v53 + 160) = 0u;
        *(_OWORD *)(v53 + 176) = 0u;
        *(_OWORD *)(v53 + 192) = 0u;
        *(void *)(v53 + 224) = 0LL;
        unint64_t v56 = v53 | 0x8000000000000000LL;
        unint64_t v44 = v126;
      }

      else
      {
        uint64_t v83 = -1LL << *(_BYTE *)(v126 + 32);
        uint64_t v54 = ~v83;
        uint64_t v84 = *(void *)(v126 + 56);
        int64_t v123 = v126 + 56;
        uint64_t v85 = -v83;
        if (v85 < 64) {
          uint64_t v86 = ~(-1LL << v85);
        }
        else {
          uint64_t v86 = -1LL;
        }
        unint64_t v55 = v86 & v84;
        unint64_t v56 = v126;
      }

      uint64_t v87 = v56 & 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v120 = (uint64_t *)((v56 & 0x7FFFFFFFFFFFFFFFLL) + 80);
      uint64_t v121 = (v56 & 0x7FFFFFFFFFFFFFFFLL) + 16;
      uint64_t v116 = (char *)v54;
      int64_t v122 = (unint64_t)(v54 + 64) >> 6;
      swift_bridgeObjectRetain(v44, v35, v36, v37);
      int64_t v126 = 0LL;
      size_t v124 = &unk_189B8D230;
      unint64_t v127 = v56;
      if ((v56 & 0x8000000000000000LL) == 0) {
        goto LABEL_77;
      }
LABEL_66:
      uint64_t v91 = *(void *)(v87 + 216);
      if ((v91 & 0x8000000000000000LL) == 0)
      {
        unint64_t v92 = v125;
        if (v91 == *(void *)(v87 + 224))
        {
          id v93 = objc_msgSend(*(id *)(v87 + 208), sel_countByEnumeratingWithState_objects_count_, v121, v120, 16);
          *(void *)(v87 + 224) = v93;
          if (!v93)
          {
            *(void *)(v87 + 216) = -1LL;
            goto LABEL_100;
          }

          uint64_t v91 = 0LL;
          *(void *)(v87 + 216) = 0LL;
        }

        uint64_t v94 = *(void *)(v87 + 24);
        if (!v94) {
          goto LABEL_110;
        }
        if ((unint64_t)(v91 - 0x1000000000000000LL) >> 61 == 7)
        {
          unint64_t v95 = (void **)(v94 + 8 * v91);
          if ((v95 & 7) == 0)
          {
            unint64_t v96 = *v95;
            *(void *)(v87 + 216) = v91 + 1;
            swift_unknownObjectRetain(v96, v88, v89, v90);
            if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
            {
              uint64_t v132 = v96;
              swift_dynamicCast(v34, &v132, v124, a2, 7LL);
              goto LABEL_92;
            }

            uint64_t v97 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
            v97(v92, 1LL, 1LL, a2);
            _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v96, (uint64_t)a2, v92);
            swift_unknownObjectRelease(v96);
            uint64_t v98 = v117;
            Swift::String::Index v99 = v92;
            uint64_t v100 = v119;
            (*(void (**)(char *, uint64_t *, uint64_t))(v118 + 16))(v119, v99, v117);
            if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v8 + 48))(v100, 1LL, a2) != 1)
            {
              (*(void (**)(uint64_t *, uint64_t))(v118 + 8))(v125, v98);
              (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v34, v100, a2);
              while (1)
              {
                v97((uint64_t *)v34, 0LL, 1LL, a2);
                uint64_t v107 = v130;
                (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v130, v34, a2);
                swift_dynamicCast(v14, v107, a2, &type metadata for String, 7LL);
                id v108 = v128;
                uint64_t v109 = *(void (**)(char *, char *, ValueMetadata *))(v129 + 32);
                v109(v128, v14, &type metadata for String);
                v109(v14, v108, &type metadata for String);
                uint64_t v111 = type metadata accessor for _NativeSet(0LL, (uint64_t)&type metadata for String, v131, v110);
                _NativeSet._unsafeUpdate(with:)((uint64_t)v14, v111);
                unint64_t v56 = v127;
                if ((v127 & 0x8000000000000000LL) != 0) {
                  goto LABEL_66;
                }
LABEL_77:
                if (v55)
                {
                  unint64_t v101 = __clz(__rbit64(v55));
                  v55 &= v55 - 1;
                  unint64_t v102 = v101 | (v126 << 6);
                }

                else
                {
                  int64_t v103 = v126 + 1;
                  if (__OFADD__(v126, 1LL)) {
                    goto LABEL_108;
                  }
                  if (v103 >= v122) {
                    goto LABEL_100;
                  }
                  unint64_t v104 = *(void *)(v123 + 8 * v103);
                  int64_t v105 = v126 + 1;
                  if (!v104)
                  {
                    int64_t v105 = v126 + 2;
                    if (v126 + 2 >= v122) {
                      goto LABEL_100;
                    }
                    unint64_t v104 = *(void *)(v123 + 8 * v105);
                    if (!v104)
                    {
                      int64_t v106 = v126 + 3;
                      if (v126 + 3 >= v122) {
                        goto LABEL_100;
                      }
                      unint64_t v104 = *(void *)(v123 + 8 * v106);
                      if (!v104)
                      {
                        while (1)
                        {
                          int64_t v105 = v106 + 1;
                          if (__OFADD__(v106, 1LL)) {
                            goto LABEL_109;
                          }
                          if (v105 >= v122) {
                            goto LABEL_100;
                          }
                          unint64_t v104 = *(void *)(v123 + 8 * v105);
                          ++v106;
                          if (v104) {
                            goto LABEL_90;
                          }
                        }
                      }

                      int64_t v105 = v126 + 3;
                    }
                  }

BOOL _swift_setDownCastConditionalIndirect( unint64_t *a1, uint64_t *a2, uint64_t *a3, char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  unint64_t v11 = swift_bridgeObjectRetain(*a1, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v13 = _setDownCastConditional<A, B>(_:)(v11, a3, (ValueMetadata *)a4, v12, a6);
  swift_bridgeObjectRelease(v10);
  if (v13) {
    *a2 = v13;
  }
  return v13 != 0;
}

uint64_t _setDownCastConditional<A, B>(_:)( uint64_t a1, uint64_t *a2, ValueMetadata *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v160 = a5;
  uint64_t v8 = *(a2 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  v155 = (char *)&v138 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  char v150 = (char *)&v138 - v11;
  uint64_t v14 = type metadata accessor for Optional(0LL, v12, v12, v13);
  uint64_t v143 = *(void *)(v14 - 8);
  uint64_t v144 = v14;
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  uint64_t v154 = (char *)&v138 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v138 - v18;
  Description = (void (**)(char *, void, uint64_t, ValueMetadata *))a3[-1].Description;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  BOOL v152 = (char *)&v138 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v158 = (char *)&v138 - v23;
  MEMORY[0x1895F8858](v22);
  int64_t v149 = (char *)&v138 - v24;
  uint64_t v141 = type metadata accessor for Optional(0LL, (uint64_t)a2, v25, v26);
  uint64_t v140 = *(void *)(v141 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v141);
  uint64_t v29 = (char *)&v138 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v27);
  unint64_t v156 = (char *)&v138 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v138 - v33;
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  uint64_t v153 = (uint64_t *)((char *)&v138 - v36);
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v39 = (char *)&v138 - v38;
  MEMORY[0x1895F8858](v37);
  v151 = (char *)&v138 - v43;
  unint64_t v44 = a1 & 0xC000000000000001LL;
  if ((a1 & 0xC000000000000001LL) != 0)
  {
    int64_t v45 = a1;
    if (a1 < 0) {
      uint64_t v46 = (void *)a1;
    }
    else {
      uint64_t v46 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v47 = objc_msgSend(v46, sel_count);
    if (v47) {
      goto LABEL_6;
    }
  }

  else
  {
    int64_t v45 = a1;
    id v47 = *(id *)(a1 + 16);
    if (v47)
    {
LABEL_6:
      type metadata accessor for _SetStorage(0LL, (uint64_t)a3, v160, (uint64_t)v42);
      uint64_t v48 = (unint64_t *)static _SetStorage.allocate(capacity:)((uint64_t)v47);
      goto LABEL_9;
    }
  }

  uint64_t v48 = (unint64_t *)&_swiftEmptySetSingleton;
LABEL_9:
  Swift::String::Index v162 = v48;
  if (a3 != &type metadata for String)
  {
    if (v44)
    {
      unint64_t v49 = v48;
      if (v45 < 0) {
        uint64_t v50 = v45;
      }
      else {
        uint64_t v50 = v45 & 0xFFFFFFFFFFFFFF8LL;
      }
      uint64_t v51 = type metadata accessor for __CocoaSet.Iterator();
      unint64_t v52 = (unint64_t)swift_allocObject(v51, 0xE8uLL, 7uLL);
      uint64_t v148 = 0LL;
      uint64_t v53 = 0LL;
      unint64_t v54 = 0LL;
      *(void *)(v52 + 208) = v50;
      *(void *)(v52 + 216) = 0LL;
      uint64_t v48 = v49;
      *(_OWORD *)(v52 + 16) = 0u;
      *(_OWORD *)(v52 + 32) = 0u;
      *(_OWORD *)(v52 + 48) = 0u;
      *(_OWORD *)(v52 + 64) = 0u;
      *(_OWORD *)(v52 + 80) = 0u;
      *(_OWORD *)(v52 + 96) = 0u;
      *(_OWORD *)(v52 + 112) = 0u;
      *(_OWORD *)(v52 + 128) = 0u;
      *(_OWORD *)(v52 + 144) = 0u;
      *(_OWORD *)(v52 + 160) = 0u;
      *(_OWORD *)(v52 + 176) = 0u;
      *(_OWORD *)(v52 + 192) = 0u;
      *(void *)(v52 + 224) = 0LL;
      unint64_t v55 = v52 | 0x8000000000000000LL;
    }

    else
    {
      uint64_t v62 = -1LL << *(_BYTE *)(v45 + 32);
      uint64_t v53 = ~v62;
      uint64_t v63 = *(void *)(v45 + 56);
      uint64_t v148 = v45 + 56;
      uint64_t v64 = -v62;
      if (v64 < 64) {
        uint64_t v65 = ~(-1LL << v64);
      }
      else {
        uint64_t v65 = -1LL;
      }
      unint64_t v54 = v65 & v63;
      unint64_t v55 = v45;
    }

    uint64_t v66 = (uint64_t *)v156;
    char v150 = (char *)(v55 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v145 = (v55 & 0x7FFFFFFFFFFFFFFFLL) + 80;
    uint64_t v146 = (v55 & 0x7FFFFFFFFFFFFFFFLL) + 16;
    uint64_t v142 = v53;
    int64_t v147 = (unint64_t)(v53 + 64) >> 6;
    swift_bridgeObjectRetain(v45, v40, v41, v42);
    uint64_t v153 = (uint64_t *)v48;
    swift_retain(v48, v67, v68, v69);
    int64_t v73 = 0LL;
    int64_t v149 = (char *)&unk_189B8D230;
    v151 = v29;
    unint64_t v157 = v55;
    if ((v55 & 0x8000000000000000LL) == 0) {
      goto LABEL_39;
    }
LABEL_27:
    unint64_t v77 = v150;
    uint64_t v78 = *((void *)v150 + 27);
    if ((v78 & 0x8000000000000000LL) == 0)
    {
      if (v78 != *((void *)v150 + 28))
      {
LABEL_31:
        uint64_t v80 = *((void *)v77 + 3);
        if (!v80) {
          goto LABEL_108;
        }
        if ((unint64_t)(v78 - 0x1000000000000000LL) >> 61 == 7)
        {
          unint64_t v81 = (void **)(v80 + 8 * v78);
          if ((v81 & 7) == 0)
          {
            char v82 = *v81;
            *((void *)v77 + 27) = v78 + 1;
            swift_unknownObjectRetain(v82, v70, v71, v72);
            if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
            {
              Swift::String::Index v161 = v82;
              swift_dynamicCast(v39, &v161, v149, a2, 7LL);
              uint64_t v83 = v39;
              uint64_t v84 = *(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
LABEL_36:
              int64_t v85 = v73;
              uint64_t v86 = v54;
              while (1)
              {
                v84(v83, 0LL, 1LL, a2);
                uint64_t v94 = v155;
                unint64_t v95 = v83;
                (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v155, v83, a2);
                unint64_t v96 = v154;
                int v97 = swift_dynamicCast(v154, v94, a2, a3, 6LL);
                uint64_t v98 = Description;
                Description[7](v96, v97 ^ 1u, 1LL, a3);
                unint64_t v74 = (void (*)(char *, char *, ValueMetadata *))v98[4];
                unint64_t v75 = v152;
                v74(v152, v96, a3);
                uint64_t v76 = (uint64_t)v158;
                v74(v158, v75, a3);
                _NativeSet._unsafeInsertNew(_:)(v76, (uint64_t)v153, (uint64_t)a3, v160);
                int64_t v73 = v85;
                unint64_t v54 = v86;
                uint64_t v39 = v95;
                uint64_t v29 = v151;
                uint64_t v66 = (uint64_t *)v156;
                unint64_t v55 = v157;
                if ((v157 & 0x8000000000000000LL) != 0) {
                  goto LABEL_27;
                }
LABEL_39:
                if (v54)
                {
                  uint64_t v86 = (v54 - 1) & v54;
                  unint64_t v90 = __clz(__rbit64(v54)) | (v73 << 6);
                  int64_t v85 = v73;
                }

                else
                {
                  int64_t v91 = v73 + 1;
                  if (__OFADD__(v73, 1LL)) {
                    goto LABEL_103;
                  }
                  if (v91 >= v147) {
                    goto LABEL_97;
                  }
                  unint64_t v92 = *(void *)(v148 + 8 * v91);
                  int64_t v85 = v73 + 1;
                  if (!v92)
                  {
                    int64_t v85 = v73 + 2;
                    if (v73 + 2 >= v147) {
                      goto LABEL_97;
                    }
                    unint64_t v92 = *(void *)(v148 + 8 * v85);
                    if (!v92)
                    {
                      int64_t v93 = v73 + 3;
                      if (v73 + 3 >= v147) {
                        goto LABEL_97;
                      }
                      unint64_t v92 = *(void *)(v148 + 8 * v93);
                      if (!v92)
                      {
                        while (1)
                        {
                          int64_t v85 = v93 + 1;
                          if (__OFADD__(v93, 1LL)) {
                            break;
                          }
                          if (v85 >= v147) {
                            goto LABEL_97;
                          }
                          unint64_t v92 = *(void *)(v148 + 8 * v85);
                          ++v93;
                          if (v92) {
                            goto LABEL_52;
                          }
                        }

LABEL_105:
                        __break(1u);
LABEL_106:
                        __break(1u);
LABEL_107:
                        __break(1u);
LABEL_108:
                        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
                      }

                      int64_t v85 = v73 + 3;
                    }
                  }

    unint64_t v96 = _StringGuts.nativeUnusedCapacity.getter(v93, v11);
    uint64_t v63 = (v97 & 1) == 0 && v96 >= a2;
    if ((v93 & ~v11 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v63 & 1) != 0) {
        goto LABEL_123;
      }
LABEL_116:
      uint64_t v99 = _StringGuts.nativeCapacity.getter(v93, v11);
      if ((v100 & 1) != 0) {
        uint64_t v101 = 0LL;
      }
      else {
        uint64_t v101 = v99;
      }
      if (v101 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_320;
      }

      uint64_t v102 = 2 * v101;
      if (v102 > v92) {
        unint64_t v92 = v102;
      }
      goto LABEL_122;
    }

    if ((v63 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v92);
LABEL_123:
    swift_bridgeObjectRelease_n(a3, 4LL);
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0LL, v295);
    }

    else
    {
      if (v10)
      {
        swift_bridgeObjectRelease_n(a3, 2LL);
        *(void *)&v297 = a1;
        *((void *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v103 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(a3) & 0xF,  (uint64_t)&v297,  HIBYTE(a3) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v103, v104, (a3 & 0x4000000000000000LL) != 0);
        swift_bridgeObjectRelease(a3);
        goto LABEL_170;
      }

      if ((a1 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(a3);
        uint64_t v118 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v119 = a1 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v118 = _StringObject.sharedUTF8.getter(a1, a3);
        unint64_t v119 = v288;
        swift_bridgeObjectRelease(a3);
        if (v119 < v61) {
          goto LABEL_332;
        }
      }

      uint64_t v120 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, a1 & 0xFFFFFFFFFFFFLL, (uint64_t)v118, v119);
      _StringGuts.appendInPlace(_:isASCII:)(v120, v121, a1 < 0);
    }

    swift_bridgeObjectRelease_n(a3, 2LL);
LABEL_170:
    int64_t v147 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    a1 = v147._countAndFlagsBits;
    a3 = (unint64_t)v147._object;
    uint64_t v148 = v298._countAndFlagsBits;
    uint64_t v11 = (unint64_t)v298._object;
    int64_t v149 = ((unint64_t)v298._object >> 56) & 0xF;
    char v150 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v150 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298 = v147;
      goto LABEL_204;
    }

    a2 = (uint64_t)v147._object & 0x2000000000000000LL;
    uint64_t v10 = ((unint64_t)v147._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000LL) != 0 && a2)
    {
      v151 = v149 + v10;
      if (v149 + v10 <= 0xF)
      {
        unint64_t v180 = v296;
        if (v10)
        {
          __int128 v222 = 0;
          unint64_t v223 = 0LL;
          unint64_t v224 = (unint64_t)v298._object;
          do
          {
            v225 = v149 + v223;
            v226 = v223 + 1;
            if (v223 >= 8) {
              v227 = (unint64_t)v147._object;
            }
            else {
              v227 = v147._countAndFlagsBits;
            }
            v228 = v227 >> (v222 & 0x38);
            v229 = (8 * v149 + v222) & 0x38;
            v230 = (-255LL << v229) - 1;
            v231 = (unint64_t)v228 << v229;
            v232 = v231 | v230 & v224;
            v233 = v231 | v230 & v148;
            if (v225 < 8) {
              uint64_t v148 = v233;
            }
            else {
              unint64_t v224 = v232;
            }
            v222 += 8;
            unint64_t v223 = v226;
          }

          while (v10 != v226);
        }

        else
        {
          unint64_t v224 = (unint64_t)v298._object;
        }

        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease((uint64_t)v147._object);
        v254 = 0xA000000000000000LL;
        if (!(v148 & 0x8080808080808080LL | v224 & 0x80808080808080LL)) {
          v254 = 0xE000000000000000LL;
        }
        v298._uint64_t countAndFlagsBits = v148;
        v298._unint64_t object = (void *)(v254 & 0xFF00000000000000LL | (v151 << 56) | v224 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_205;
      }

      a2 = 1LL;
    }

    uint64_t v13 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a2) {
      unint64_t v61 = ((unint64_t)v147._object >> 56) & 0xF;
    }
    else {
      unint64_t v61 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 2LL, v145, v146);
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 4LL, v89, v90);
    uint64_t v154 = v61;
    if ((v11 & 0x1000000000000000LL) != 0) {
      goto LABEL_299;
    }
LABEL_183:
    if ((v11 & 0x2000000000000000LL) != 0)
    {
      unint64_t v156 = HIBYTE(v11) & 0xF;
      v155 = v156 + v154;
      if (__OFADD__(v156, v154)) {
        goto LABEL_301;
      }
    }

    else
    {
      v155 = (v148 & 0xFFFFFFFFFFFFLL) + v154;
      if (__OFADD__(v148 & 0xFFFFFFFFFFFFLL, v154)) {
        goto LABEL_301;
      }
    }

    unint64_t v96 = _StringGuts.nativeUnusedCapacity.getter(v93, v11);
    uint64_t v63 = (v97 & 1) == 0 && v96 >= a2;
    if ((v93 & ~v11 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v63 & 1) != 0) {
        goto LABEL_123;
      }
LABEL_116:
      uint64_t v99 = _StringGuts.nativeCapacity.getter(v93, v11);
      if ((v100 & 1) != 0) {
        uint64_t v101 = 0LL;
      }
      else {
        uint64_t v101 = v99;
      }
      if (v101 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_320;
      }

      uint64_t v102 = 2 * v101;
      if (v102 > v92) {
        unint64_t v92 = v102;
      }
      goto LABEL_122;
    }

    if ((v63 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v92);
LABEL_123:
    swift_bridgeObjectRelease_n(a3, 4LL);
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0LL, v295);
    }

    else
    {
      if (v10)
      {
        swift_bridgeObjectRelease_n(a3, 2LL);
        *(void *)&v297 = a1;
        *((void *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v103 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(a3) & 0xF,  (uint64_t)&v297,  HIBYTE(a3) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v103, v104, (a3 & 0x4000000000000000LL) != 0);
        swift_bridgeObjectRelease(a3);
        goto LABEL_170;
      }

      if ((a1 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(a3);
        uint64_t v118 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v119 = a1 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v118 = _StringObject.sharedUTF8.getter(a1, a3);
        unint64_t v119 = v288;
        swift_bridgeObjectRelease(a3);
        if (v119 < v61) {
          goto LABEL_332;
        }
      }

      uint64_t v120 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, a1 & 0xFFFFFFFFFFFFLL, (uint64_t)v118, v119);
      _StringGuts.appendInPlace(_:isASCII:)(v120, v121, a1 < 0);
    }

    swift_bridgeObjectRelease_n(a3, 2LL);
LABEL_170:
    int64_t v147 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    a1 = v147._countAndFlagsBits;
    a3 = (unint64_t)v147._object;
    uint64_t v148 = v298._countAndFlagsBits;
    uint64_t v11 = (unint64_t)v298._object;
    int64_t v149 = ((unint64_t)v298._object >> 56) & 0xF;
    char v150 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v150 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298 = v147;
      goto LABEL_204;
    }

    a2 = (uint64_t)v147._object & 0x2000000000000000LL;
    uint64_t v10 = ((unint64_t)v147._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000LL) != 0 && a2)
    {
      v151 = v149 + v10;
      if (v149 + v10 <= 0xF)
      {
        unint64_t v180 = v296;
        if (v10)
        {
          __int128 v222 = 0;
          unint64_t v223 = 0LL;
          unint64_t v224 = (unint64_t)v298._object;
          do
          {
            v225 = v149 + v223;
            v226 = v223 + 1;
            if (v223 >= 8) {
              v227 = (unint64_t)v147._object;
            }
            else {
              v227 = v147._countAndFlagsBits;
            }
            v228 = v227 >> (v222 & 0x38);
            v229 = (8 * v149 + v222) & 0x38;
            v230 = (-255LL << v229) - 1;
            v231 = (unint64_t)v228 << v229;
            v232 = v231 | v230 & v224;
            v233 = v231 | v230 & v148;
            if (v225 < 8) {
              uint64_t v148 = v233;
            }
            else {
              unint64_t v224 = v232;
            }
            v222 += 8;
            unint64_t v223 = v226;
          }

          while (v10 != v226);
        }

        else
        {
          unint64_t v224 = (unint64_t)v298._object;
        }

        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease((uint64_t)v147._object);
        v254 = 0xA000000000000000LL;
        if (!(v148 & 0x8080808080808080LL | v224 & 0x80808080808080LL)) {
          v254 = 0xE000000000000000LL;
        }
        v298._uint64_t countAndFlagsBits = v148;
        v298._unint64_t object = (void *)(v254 & 0xFF00000000000000LL | (v151 << 56) | v224 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_205;
      }

      a2 = 1LL;
    }

    uint64_t v13 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a2) {
      unint64_t v61 = ((unint64_t)v147._object >> 56) & 0xF;
    }
    else {
      unint64_t v61 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 2LL, v145, v146);
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 4LL, v89, v90);
    uint64_t v154 = v61;
    if ((v11 & 0x1000000000000000LL) != 0) {
      goto LABEL_299;
    }
LABEL_183:
    if ((v11 & 0x2000000000000000LL) != 0)
    {
      unint64_t v156 = HIBYTE(v11) & 0xF;
      v155 = v156 + v154;
      if (__OFADD__(v156, v154)) {
        goto LABEL_301;
      }
    }

    else
    {
      v155 = (v148 & 0xFFFFFFFFFFFFLL) + v154;
      if (__OFADD__(v148 & 0xFFFFFFFFFFFFLL, v154)) {
        goto LABEL_301;
      }
    }

    unint64_t v92 = _StringGuts.nativeUnusedCapacity.getter(v89, countAndFlagsBits);
    unint64_t v61 = (v93 & 1) == 0 && v92 >= v82;
    if ((v89 & ~countAndFlagsBits & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v61 & 1) != 0) {
        goto LABEL_123;
      }
LABEL_116:
      unint64_t v95 = _StringGuts.nativeCapacity.getter(v89, countAndFlagsBits);
      if ((v96 & 1) != 0) {
        int v97 = 0LL;
      }
      else {
        int v97 = v95;
      }
      if (v97 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_291;
      }

      uint64_t v98 = 2 * v97;
      if (v98 > v88) {
        uint64_t v88 = v98;
      }
      goto LABEL_122;
    }

    if ((v61 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v88);
LABEL_123:
    swift_bridgeObjectRelease_n(v9, 4LL);
    if ((v9 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v9);
      _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0LL, v250);
    }

    else
    {
      if (v80)
      {
        swift_bridgeObjectRelease_n(v9, 2LL);
        *(void *)&v253 = v12;
        *((void *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v99 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v9) & 0xF,  (uint64_t)&v253,  HIBYTE(v9) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v99, v100, (v9 & 0x4000000000000000LL) != 0);
        swift_bridgeObjectRelease(v9);
        goto LABEL_170;
      }

      if ((v12 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v9);
        uint64_t v114 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v115 = v12 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v114 = _StringObject.sharedUTF8.getter(v12, v9);
        uint64_t v115 = v243;
        swift_bridgeObjectRelease(v9);
        if (v115 < a1) {
          goto LABEL_301;
        }
      }

      uint64_t v116 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v12 & 0xFFFFFFFFFFFFLL, (uint64_t)v114, v115);
      _StringGuts.appendInPlace(_:isASCII:)(v116, v117, v12 < 0);
    }

    swift_bridgeObjectRelease_n(v9, 2LL);
LABEL_170:
    uint64_t v143 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    uint64_t v12 = v143._countAndFlagsBits;
    uint64_t v9 = (unint64_t)v143._object;
    uint64_t countAndFlagsBits = v254._countAndFlagsBits;
    uint64_t v2 = (unint64_t)v254._object;
    uint64_t v144 = ((unint64_t)v254._object >> 56) & 0xF;
    else {
      uint64_t v88 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v88 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254 = v143;
LABEL_203:
      char v171 = v252;
      goto LABEL_204;
    }

    a1 = (uint64_t)v143._object & 0x2000000000000000LL;
    char v82 = ((unint64_t)v143._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000LL) != 0 && a1)
    {
      uint64_t v145 = v144 + v82;
      if (v144 + v82 <= 0xF)
      {
        char v171 = v252;
        if (v82)
        {
          size_t v205 = 0;
          v206 = 0LL;
          Swift::Int v207 = (unint64_t)v254._object;
          do
          {
            Swift::Int v208 = v144 + v206;
            unint64_t v209 = v206 + 1;
            if (v206 >= 8) {
              v210 = (unint64_t)v143._object;
            }
            else {
              v210 = v143._countAndFlagsBits;
            }
            __int128 v211 = v210 >> (v205 & 0x38);
            uint64_t v212 = (8 * v144 + v205) & 0x38;
            int64_t v213 = (-255LL << v212) - 1;
            uint64_t v214 = (unint64_t)v211 << v212;
            v215 = v214 | v213 & v207;
            uint64_t v216 = v214 | v213 & countAndFlagsBits;
            if (v208 < 8) {
              uint64_t countAndFlagsBits = v216;
            }
            else {
              Swift::Int v207 = v215;
            }
            v205 += 8;
            v206 = v209;
          }

          while (v82 != v209);
        }

        else
        {
          Swift::Int v207 = (unint64_t)v254._object;
        }

        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease((uint64_t)v143._object);
        __int128 v222 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | v207 & 0x80808080808080LL)) {
          __int128 v222 = 0xE000000000000000LL;
        }
        v254._uint64_t countAndFlagsBits = countAndFlagsBits;
        v254._unint64_t object = (void *)(v222 & 0xFF00000000000000LL | (v145 << 56) | v207 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_204;
      }

      a1 = 1LL;
    }

    v250 = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a1) {
      unint64_t object = ((unint64_t)v143._object >> 56) & 0xF;
    }
    else {
      unint64_t object = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 2LL, v141, v142);
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 4LL, v85, v86);
    uint64_t v11 = object;
    if ((v2 & 0x1000000000000000LL) != 0) {
      goto LABEL_276;
    }
LABEL_184:
    uint64_t v146 = v88 + v11;
    if (!__OFADD__(v88, v11)) {
      goto LABEL_185;
    }
LABEL_278:
    __break(1u);
LABEL_279:
    v234 = String.UTF8View._foreignCount()();
    uint64_t v24 = v234 + 8;
    if (__OFADD__(v234, 8LL))
    {
LABEL_281:
      __break(1u);
      goto LABEL_282;
    }

    unint64_t v92 = _StringGuts.nativeUnusedCapacity.getter(v89, countAndFlagsBits);
    unint64_t v61 = (v93 & 1) == 0 && v92 >= v82;
    if ((v89 & ~countAndFlagsBits & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v61 & 1) != 0) {
        goto LABEL_123;
      }
LABEL_116:
      unint64_t v95 = _StringGuts.nativeCapacity.getter(v89, countAndFlagsBits);
      if ((v96 & 1) != 0) {
        int v97 = 0LL;
      }
      else {
        int v97 = v95;
      }
      if (v97 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_291;
      }

      uint64_t v98 = 2 * v97;
      if (v98 > v88) {
        uint64_t v88 = v98;
      }
      goto LABEL_122;
    }

    if ((v61 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v88);
LABEL_123:
    swift_bridgeObjectRelease_n(v9, 4LL);
    if ((v9 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v9);
      _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0LL, v250);
    }

    else
    {
      if (v80)
      {
        swift_bridgeObjectRelease_n(v9, 2LL);
        *(void *)&v253 = v12;
        *((void *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v99 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v9) & 0xF,  (uint64_t)&v253,  HIBYTE(v9) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v99, v100, (v9 & 0x4000000000000000LL) != 0);
        swift_bridgeObjectRelease(v9);
        goto LABEL_170;
      }

      if ((v12 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v9);
        uint64_t v114 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v115 = v12 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v114 = _StringObject.sharedUTF8.getter(v12, v9);
        uint64_t v115 = v243;
        swift_bridgeObjectRelease(v9);
        if (v115 < a1) {
          goto LABEL_301;
        }
      }

      uint64_t v116 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v12 & 0xFFFFFFFFFFFFLL, (uint64_t)v114, v115);
      _StringGuts.appendInPlace(_:isASCII:)(v116, v117, v12 < 0);
    }

    swift_bridgeObjectRelease_n(v9, 2LL);
LABEL_170:
    uint64_t v143 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    uint64_t v12 = v143._countAndFlagsBits;
    uint64_t v9 = (unint64_t)v143._object;
    uint64_t countAndFlagsBits = v254._countAndFlagsBits;
    uint64_t v2 = (unint64_t)v254._object;
    uint64_t v144 = ((unint64_t)v254._object >> 56) & 0xF;
    else {
      uint64_t v88 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v88 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254 = v143;
LABEL_203:
      char v171 = v252;
      goto LABEL_204;
    }

    a1 = (uint64_t)v143._object & 0x2000000000000000LL;
    char v82 = ((unint64_t)v143._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000LL) != 0 && a1)
    {
      uint64_t v145 = v144 + v82;
      if (v144 + v82 <= 0xF)
      {
        char v171 = v252;
        if (v82)
        {
          size_t v205 = 0;
          v206 = 0LL;
          Swift::Int v207 = (unint64_t)v254._object;
          do
          {
            Swift::Int v208 = v144 + v206;
            unint64_t v209 = v206 + 1;
            if (v206 >= 8) {
              v210 = (unint64_t)v143._object;
            }
            else {
              v210 = v143._countAndFlagsBits;
            }
            __int128 v211 = v210 >> (v205 & 0x38);
            uint64_t v212 = (8 * v144 + v205) & 0x38;
            int64_t v213 = (-255LL << v212) - 1;
            uint64_t v214 = (unint64_t)v211 << v212;
            v215 = v214 | v213 & v207;
            uint64_t v216 = v214 | v213 & countAndFlagsBits;
            if (v208 < 8) {
              uint64_t countAndFlagsBits = v216;
            }
            else {
              Swift::Int v207 = v215;
            }
            v205 += 8;
            v206 = v209;
          }

          while (v82 != v209);
        }

        else
        {
          Swift::Int v207 = (unint64_t)v254._object;
        }

        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease((uint64_t)v143._object);
        __int128 v222 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | v207 & 0x80808080808080LL)) {
          __int128 v222 = 0xE000000000000000LL;
        }
        v254._uint64_t countAndFlagsBits = countAndFlagsBits;
        v254._unint64_t object = (void *)(v222 & 0xFF00000000000000LL | (v145 << 56) | v207 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_204;
      }

      a1 = 1LL;
    }

    v250 = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a1) {
      unint64_t object = ((unint64_t)v143._object >> 56) & 0xF;
    }
    else {
      unint64_t object = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 2LL, v141, v142);
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 4LL, v85, v86);
    uint64_t v11 = object;
    if ((v2 & 0x1000000000000000LL) != 0) {
      goto LABEL_276;
    }
LABEL_184:
    uint64_t v146 = v88 + v11;
    if (!__OFADD__(v88, v11)) {
      goto LABEL_185;
    }
LABEL_278:
    __break(1u);
LABEL_279:
    v234 = String.UTF8View._foreignCount()();
    uint64_t v24 = v234 + 8;
    if (__OFADD__(v234, 8LL))
    {
LABEL_281:
      __break(1u);
      goto LABEL_282;
    }

  v338 = v2;
  uint64_t v101 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v101);
  uint64_t v102 = specialized Collection.subscript.getter(v92, (uint64_t)v85, v84);
  uint64_t v107 = findInvalidRange #1 (_:) in validateUTF8(_:)(v102, v103, v104, v105);
  v350._uint64_t countAndFlagsBits = 0LL;
  v350._unint64_t object = (void *)0xE000000000000000LL;
  if (__OFADD__(v84, 15LL))
  {
LABEL_253:
    __break(1u);
    goto LABEL_254;
  }

  id v108 = v106;
  v336 = v1;
  v337 = v3;
  _StringGuts.reserveCapacity(_:)(v84 + 15);
  while (1)
  {
    uint64_t v109 = specialized Collection.subscript.getter(v107, (uint64_t)v85, v84);
    uint64_t v113 = v350._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    uint64_t v39 = __OFADD__(v113, v84);
    uint64_t v114 = v113 + v84;
    if (v39)
    {
      __break(1u);
LABEL_248:
      __break(1u);
LABEL_249:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }

    uint64_t v115 = v109;
    if (__OFADD__(v114, 3LL)) {
      goto LABEL_248;
    }
    uint64_t v116 = v110;
    id v117 = v111;
    uint64_t v118 = v112;
    _StringGuts.reserveCapacity(_:)(v114 + 3);
    unint64_t v119 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v115, v116, v117, v118);
    _StringGuts.appendInPlace(_:isASCII:)(v119, v120, 0);
    v358[0] = 3LL;
    *(void *)&v353 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v353, v358, &v350);
    uint64_t v121 = specialized Collection.subscript.getter(v108, (uint64_t)v85, v84);
    int64_t v85 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v121, v122, v123, v124);
    uint64_t v84 = v125;
    uint64_t v126 = validateUTF8(_:)(v85, v125);
    if ((v82 & 1) == 0) {
      break;
    }
    uint64_t v107 = v126;
    id v108 = v81;
    if (!v84) {
      goto LABEL_120;
    }
  }

  _StringGuts.appendInPlace(_:isASCII:)((char *)v85, v84, 0);
LABEL_120:
  unint64_t object = (unint64_t)v350._object;
  uint64_t countAndFlagsBits = v350._countAndFlagsBits;
  uint64_t v2 = v338;
  uint64_t v3 = v337;
  uint64_t v37 = v349;
  uint64_t v1 = v336;
LABEL_157:
  v236 = v356;
  v237 = HIBYTE(v357) & 0xF;
  v238 = v356 & 0xFFFFFFFFFFFFLL;
  if ((v357 & 0x2000000000000000LL) != 0) {
    v238 = HIBYTE(v357) & 0xF;
  }
  if (v238 || (v356 & ~v357 & 0x2000000000000000LL) != 0)
  {
    if ((v357 & 0x2000000000000000LL) == 0)
    {
      if ((object & 0x2000000000000000LL) != 0)
      {
        v239 = HIBYTE(object) & 0xF;
        goto LABEL_167;
      }

LABEL_101:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
        }

        __break(1u);
LABEL_103:
        __break(1u);
LABEL_104:
        __break(1u);
        goto LABEL_105;
      }

      id v79 = objc_msgSend(*((id *)v150 + 26), sel_countByEnumeratingWithState_objects_count_, v146, v145, 16);
      *((void *)v77 + 28) = v79;
      if (v79)
      {
        uint64_t v78 = 0LL;
        *((void *)v77 + 27) = 0LL;
        goto LABEL_31;
      }

      *((void *)v77 + 27) = -1LL;
    }

        uint64_t v113 = _StringGuts.nativeUnusedCapacity.getter(v37, v36);
        uint64_t v116 = (v114 & 1) == 0 && v113 >= v45;
        if ((v50 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v36 & 0xFFFFFFFFFFFFFFFLL))
        {
          uint64_t v43 = v302;
          if (v116) {
            goto LABEL_129;
          }
        }

        else
        {
          uint64_t v43 = v302;
          if (v116)
          {
LABEL_128:
            _StringGuts.grow(_:)(v49);
LABEL_129:
            swift_bridgeObjectRelease_n(v34, 4LL);
            if ((v34 & 0x1000000000000000LL) == 0)
            {
              uint64_t v132 = v301;
              if (v41)
              {
                swift_bridgeObjectRelease_n(v34, 2LL);
                v305 = v35;
                v306 = v34 & 0xFFFFFFFFFFFFFFLL;
                v278 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v292, (uint64_t)&v305, v292);
                _StringGuts.appendInPlace(_:isASCII:)(v278, v279, (v34 & 0x4000000000000000LL) != 0);
                swift_bridgeObjectRelease(v34);
                uint64_t v41 = AssociatedTypeWitness;
              }

              else
              {
                if ((v35 & 0x1000000000000000LL) != 0)
                {
                  swift_bridgeObjectRelease(v34);
                  int64_t v133 = (id)((v34 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  int v134 = v293;
                  int64_t v135 = v293;
                }

                else
                {
                  int64_t v133 = _StringObject.sharedUTF8.getter(v35, v34);
                  int64_t v135 = v288;
                  swift_bridgeObjectRelease(v34);
                  if (v135 < v293) {
LABEL_284:
                  }
                    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
                  a2 = (unint64_t)v300;
                  uint64_t v132 = v301;
                  uint64_t v43 = v302;
                  int v134 = v293;
                }

                v136 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v134, (uint64_t)v133, v135);
                _StringGuts.appendInPlace(_:isASCII:)(v136, v137, v35 < 0);
                swift_bridgeObjectRelease_n(v34, 2LL);
                uint64_t v41 = AssociatedTypeWitness;
              }

              goto LABEL_166;
            }

            swift_bridgeObjectRelease(v34);
            _StringGuts._foreignAppendInPlace(_:)(v35, v34, 0LL, v296);
            swift_bridgeObjectRelease_n(v34, 2LL);
            goto LABEL_164;
          }
        }

        uint64_t v128 = _StringGuts.nativeCapacity.getter(v37, v36);
        if ((v129 & 1) != 0) {
          uint64_t v130 = 0LL;
        }
        else {
          uint64_t v130 = v128;
        }
        if (v130 + 0x4000000000000000LL < 0)
        {
          __break(1u);
LABEL_304:
          uint64_t v37 = _StringGuts._foreignConvertedToSmall()(v37, v36);
          uint64_t v39 = v287;
          goto LABEL_141;
        }

        unint64_t v131 = 2 * v130;
        if (v131 > v49) {
          unint64_t v49 = v131;
        }
        goto LABEL_128;
      }
    }

    else
    {
      if (v49 > 15) {
        goto LABEL_101;
      }
      if ((v36 & 0x2000000000000000LL) == 0) {
        goto LABEL_135;
      }
    }

    swift_bridgeObjectRelease_n(v34, 5LL);
    uint64_t v39 = v36;
LABEL_141:
    uint64_t v43 = v302;
    goto LABEL_142;
  }

  v28(a3, v12);
  unint64_t v54 = AssociatedTypeWitness;
  unint64_t v55 = swift_getAssociatedConformanceWitness( v12,  (uint64_t)a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v301 = *(char **)(v55 + 16);
  v302 = v55;
  ((void (*)(uint64_t *__return_ptr, unint64_t))v301)(&v305, v54);
  unint64_t v58 = v306;
  while (v306)
  {
    uint64_t v40 = v305;
    uint64_t v39 = v307;
    uint64_t v36 = v308;
    uint64_t v59 = HIBYTE(v308) & 0xF;
    if ((v308 & 0x2000000000000000LL) != 0) {
      unint64_t v60 = HIBYTE(v308) & 0xF;
    }
    else {
      unint64_t v60 = v307 & 0xFFFFFFFFFFFFLL;
    }
    if (!v60 && (v307 & ~v308 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v308);
      v307 = v40;
      v308 = v58;
      goto LABEL_40;
    }

    a2 = v58 & 0x2000000000000000LL;
    uint64_t v37 = HIBYTE(v58) & 0xF;
    unint64_t v61 = v59 + v37;
    if ((v58 & 0x2000000000000000LL & v308) != 0 && v61 <= 0xF)
    {
      if (v37)
      {
        int64_t v93 = 0LL;
        uint64_t v94 = 0LL;
        unint64_t v95 = v308;
        do
        {
          unint64_t v96 = v59 + v94;
          int v97 = v94++ >= 8;
          if (v97) {
            uint64_t v98 = v58;
          }
          else {
            uint64_t v98 = v305;
          }
          uint64_t v99 = (8 * v59 + v93) & 0x38;
          uint64_t v100 = (-255LL << v99) - 1;
          uint64_t v101 = (unint64_t)(v98 >> (v93 & 0x38)) << v99;
          uint64_t v102 = v101 | v100 & v95;
          uint64_t v103 = v101 | v100 & v39;
          if (v96 < 8) {
            uint64_t v39 = v103;
          }
          else {
            unint64_t v95 = v102;
          }
          v93 += 8LL;
        }

        while (8 * v37 != v93);
      }

      else
      {
        unint64_t v95 = v308;
      }

      swift_bridgeObjectRelease(v308);
      swift_bridgeObjectRelease(v58);
      unint64_t v104 = 0xA000000000000000LL;
      if (!(v39 & 0x8080808080808080LL | v95 & 0x80808080808080LL)) {
        unint64_t v104 = 0xE000000000000000LL;
      }
      v307 = v39;
      v308 = v104 & 0xFF00000000000000LL | (v61 << 56) | v95 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_40;
    }

    uint64_t v34 = v305 & 0xFFFFFFFFFFFFLL;
    if (a2) {
      uint64_t v41 = HIBYTE(v58) & 0xF;
    }
    else {
      uint64_t v41 = v305 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v58, 2LL, v56, v57);
    if ((v58 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v58, 5LL, v63, v64);
      v107._Swift::UInt64 rawBits = 1LL;
      v108._Swift::UInt64 rawBits = (v41 << 16) | 1;
      v109._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v107, v108, v40, v58);
      if (v109._rawBits < 0x10000) {
        v109._rawBits |= 3;
      }
      uint64_t v35 = specialized Collection.count.getter(v109, v110, v40, v58);
      swift_bridgeObjectRelease(v58);
      if ((v36 & 0x1000000000000000LL) == 0)
      {
LABEL_56:
        uint64_t v48 = __OFADD__(v60, v35);
        int64_t v45 = v60 + v35;
        if (v48) {
          goto LABEL_291;
        }
        goto LABEL_57;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(v58, 4LL, v63, v64);
      uint64_t v35 = v41;
      if ((v36 & 0x1000000000000000LL) == 0) {
        goto LABEL_56;
      }
    }

    uint64_t v111 = String.UTF8View._foreignCount()();
    int64_t v45 = v111 + v35;
    if (__OFADD__(v111, v35)) {
      goto LABEL_291;
    }
LABEL_57:
    if ((v39 & ~v36 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v36 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v65 = _StringGuts.nativeUnusedCapacity.getter(v39, v36);
      if ((v66 & 1) != 0) {
        goto LABEL_309;
      }
      uint64_t v67 = (v36 >> 61) & 1;
      if (v65 < v35) {
        LOBYTE(v67) = 1;
      }
      if (v45 > 15 || (v67 & 1) == 0)
      {
LABEL_69:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v45, v35);
        swift_bridgeObjectRelease_n(v58, 4LL);
        if ((v58 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v58);
          _StringGuts._foreignAppendInPlace(_:)(v40, v58, 0LL, v41);
          swift_bridgeObjectRelease_n(v58, 2LL);
          unint64_t v54 = AssociatedTypeWitness;
        }

        else
        {
          unint64_t v54 = AssociatedTypeWitness;
          if (a2)
          {
            swift_bridgeObjectRelease_n(v58, 2LL);
            v304[0] = v40;
            v304[1] = v58 & 0xFFFFFFFFFFFFFFLL;
            int64_t v105 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v58) & 0xF,  (uint64_t)v304,  HIBYTE(v58) & 0xF);
            _StringGuts.appendInPlace(_:isASCII:)(v105, v106, (v58 & 0x4000000000000000LL) != 0);
            swift_bridgeObjectRelease(v58);
          }

          else
          {
            if ((v40 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v58);
              uint64_t v89 = (id)((v58 & 0xFFFFFFFFFFFFFFFLL) + 32);
              unint64_t v90 = v40 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              uint64_t v89 = _StringObject.sharedUTF8.getter(v40, v58);
              unint64_t v90 = v112;
              swift_bridgeObjectRelease(v58);
            }

            int64_t v91 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v40 & 0xFFFFFFFFFFFFLL,  (uint64_t)v89,  v90);
            _StringGuts.appendInPlace(_:isASCII:)(v91, v92, v40 < 0);
            swift_bridgeObjectRelease_n(v58, 2LL);
          }
        }

        goto LABEL_40;
      }
    }

    else if (v45 > 15)
    {
      goto LABEL_69;
    }

    swift_bridgeObjectRelease_n(v58, 5LL);
    swift_bridgeObjectRetain(v36, v68, v69, v70);
    uint64_t v71 = _StringGuts._convertedToSmall()(v39, v36);
    int64_t v73 = v72;
    swift_bridgeObjectRelease(v36);
    v74._Swift::UInt64 rawBits = (v41 << 16) | 1;
    v75._Swift::UInt64 rawBits = 1LL;
    v76._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v75, v74, v40, v58);
    if (v76._rawBits < 0x10000) {
      v76._rawBits |= 3;
    }
    uint64_t v78 = specialized String.init(_:)(v76, v77, v40, v58);
    uint64_t v80 = v79;
    swift_bridgeObjectRelease(v58);
    unint64_t v81 = _StringGuts._convertedToSmall()(v78, v80);
    uint64_t v83 = v82;
    swift_bridgeObjectRelease(v80);
    uint64_t v84 = specialized _SmallString.init(_:appending:)(v71, v73, v81, v83);
    unint64_t v54 = AssociatedTypeWitness;
    if ((v86 & 1) != 0) {
      goto LABEL_308;
    }
    uint64_t v87 = v84;
    uint64_t v88 = v85;
    swift_bridgeObjectRelease(v36);
    swift_bridgeObjectRelease(v58);
    v307 = v87;
    v308 = v88;
LABEL_40:
    ((void (*)(uint64_t *__return_ptr, unint64_t, unint64_t))v301)(&v305, v54, v302);
    unint64_t v58 = v306;
  }

  (*(void (**)(char *, unint64_t))(v294 + 8))(v300, v54);
  return v307;
}

            uint64_t v143 = v173;
            uint64_t v144 = v174;
            swift_bridgeObjectRelease(v127[1]);
            *unint64_t v127 = v143;
            v127[1] = v144;
            return v169;
          }

    unint64_t v197 = v5;
    int64_t v85 = v12;
    uint64_t v86 = v7 & ~v13;
    if ((v86 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v84 > 15) {
        goto LABEL_107;
      }
LABEL_118:
      swift_bridgeObjectRelease_n(v4, 5LL);
      if ((v13 & 0x2000000000000000LL) != 0)
      {
LABEL_119:
        uint64_t v2 = v13;
      }

      else if ((v13 & 0x1000000000000000LL) != 0)
      {
        uint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, v13);
        uint64_t v2 = v195;
      }

      else
      {
        if ((v7 & 0x1000000000000000LL) != 0)
        {
          uint64_t v187 = (unsigned __int8 *)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          uint64_t v187 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v13);
          uint64_t v16 = v93;
        }

        swift_bridgeObjectRetain(v13, v93, v94, v95);
        closure #1 in _StringGuts._convertedToSmall()(v187, v16, &v198);
        swift_bridgeObjectRelease(v13);
        uint64_t v2 = *((void *)&v198 + 1);
        uint64_t v7 = v198;
      }

      v96._Swift::UInt64 rawBits = (v85 << 16) | 1;
      v97._Swift::UInt64 rawBits = 1LL;
      uint64_t v98 = v197;
      v99._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v97, v96, v197, v4);
      if (v99._rawBits < 0x10000) {
        v99._rawBits |= 3;
      }
      uint64_t v12 = specialized String.init(_:)(v99, v100, v98, v4);
      uint64_t v5 = v101;
      swift_bridgeObjectRelease(v4);
      if ((v5 & 0x2000000000000000LL) == 0) {
        goto LABEL_217;
      }
      swift_bridgeObjectRelease(v5);
      goto LABEL_124;
    }

    uint64_t v87 = _StringGuts.nativeUnusedCapacity.getter(v7, v13);
    if ((v88 & 1) != 0) {
      goto LABEL_236;
    }
    if (v84 > 15) {
      goto LABEL_107;
    }
    if ((v13 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease_n(v4, 5LL);
      goto LABEL_119;
    }

LABEL_97:
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56))(v39, 1LL, 1LL, a2);
    swift_release((uint64_t)v153);
    uint64_t v137 = v157;
    goto LABEL_100;
  }

  uint64_t v145 = (uint64_t)v34;
  if (v44)
  {
    if (v45 < 0) {
      uint64_t v56 = v45;
    }
    else {
      uint64_t v56 = v45 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v57 = type metadata accessor for __CocoaSet.Iterator();
    unint64_t v58 = (unint64_t)swift_allocObject(v57, 0xE8uLL, 7uLL);
    uint64_t v154 = 0LL;
    uint64_t v59 = 0LL;
    unint64_t v60 = 0LL;
    *(void *)(v58 + 208) = v56;
    *(void *)(v58 + 216) = 0LL;
    *(_OWORD *)(v58 + 16) = 0u;
    *(_OWORD *)(v58 + 32) = 0u;
    *(_OWORD *)(v58 + 48) = 0u;
    *(_OWORD *)(v58 + 64) = 0u;
    *(_OWORD *)(v58 + 80) = 0u;
    *(_OWORD *)(v58 + 96) = 0u;
    *(_OWORD *)(v58 + 112) = 0u;
    *(_OWORD *)(v58 + 128) = 0u;
    *(_OWORD *)(v58 + 144) = 0u;
    *(_OWORD *)(v58 + 160) = 0u;
    *(_OWORD *)(v58 + 176) = 0u;
    *(_OWORD *)(v58 + 192) = 0u;
    *(void *)(v58 + 224) = 0LL;
    unint64_t v61 = v58 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v100 = -1LL << *(_BYTE *)(v45 + 32);
    uint64_t v59 = ~v100;
    uint64_t v101 = *(void *)(v45 + 56);
    uint64_t v154 = (char *)(v45 + 56);
    uint64_t v102 = -v100;
    if (v102 < 64) {
      uint64_t v103 = ~(-1LL << v102);
    }
    else {
      uint64_t v103 = -1LL;
    }
    unint64_t v60 = v103 & v101;
    unint64_t v61 = v45;
  }

  unint64_t v104 = v153;
  int64_t v105 = v151;
  unint64_t v156 = (char *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
  int64_t v147 = (v61 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  uint64_t v148 = (v61 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v146 = v59;
  BOOL v152 = (char *)((unint64_t)(v59 + 64) >> 6);
  swift_bridgeObjectRetain(v45, v40, v41, v42);
  uint64_t v109 = 0LL;
  v155 = (char *)&unk_189B8D230;
  unint64_t v157 = v61;
  if ((v61 & 0x8000000000000000LL) == 0) {
    goto LABEL_75;
  }
LABEL_63:
  uint64_t v115 = v156;
  uint64_t v116 = *((void *)v156 + 27);
  if (v116 < 0) {
    goto LABEL_99;
  }
  if (v116 == *((void *)v156 + 28))
  {
    id v117 = objc_msgSend(*((id *)v156 + 26), sel_countByEnumeratingWithState_objects_count_, v148, v147, 16);
    uint64_t v115 = v156;
    *((void *)v156 + 28) = v117;
    if (v117)
    {
      uint64_t v116 = 0LL;
      *((void *)v115 + 27) = 0LL;
      goto LABEL_67;
    }

    *((void *)v115 + 27) = -1LL;
LABEL_99:
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56))(v105, 1LL, 1LL, a2);
    uint64_t v137 = v61;
    goto LABEL_100;
  }

    uint64_t v8 = v221;
    id v117 = v222;
    swift_bridgeObjectRelease(v17[3]);
    v17[2] = v8;
    v17[3] = v117;
LABEL_98:
    unint64_t v74 = startingAt;
LABEL_99:
    if (!__OFSUB__(v74, v39)) {
      break;
    }
    __break(1u);
  }

  uint64_t v118 = *v17;
  unint64_t v119 = (unint64_t)*v17 >> 16;
  uint64_t v120 = v74 - v39 + v18 - v12;
  uint64_t v121 = v120 + ((unint64_t)v17[1] >> 16);
  int64_t v122 = ((unint64_t)*v17 >> 8) & 0x3F;
  if (v122)
  {
    if (v122 + v119 < v18) {
      goto LABEL_124;
    }
  }

  else if (v119 < v18)
  {
    goto LABEL_124;
  }

  if (v119 == v121)
  {
    uint64_t v123 = 0LL;
    uint64_t v124 = v118 & 0xFFFFFFFFFFFF0000LL;
    goto LABEL_118;
  }

  uint64_t v125 = v17[2];
  uint64_t v126 = v17[3];
  if ((v126 & 0x1000000000000000LL) != 0) {
    goto LABEL_164;
  }
  if ((v126 & 0x2000000000000000LL) != 0)
  {
    v214[0] = v17[2];
    v214[1] = v126 & 0xFFFFFFFFFFFFFFLL;
    if (v119 + 1 != (HIBYTE(v126) & 0xF))
    {
      unint64_t v129 = *(unsigned __int16 *)((char *)v214 + v119);
      goto LABEL_115;
    }

      if (a3)
      {
        switch(a2)
        {
          case 4uLL:
            uint64_t result = (void *)memcmp(v6, "Task", a2);
            if ((_DWORD)result) {
              goto LABEL_150;
            }
            uint64_t v17 = "cT";
            goto LABEL_171;
          case 5uLL:
            if (*(_DWORD *)v6 != 1869898561 || *((_BYTE *)v6 + 4) != 114) {
              goto LABEL_150;
            }
            uint64_t v17 = "cA";
            goto LABEL_171;
          case 8uLL:
            uint64_t result = (void *)memcmp(v6, "Executor", a2);
            if ((_DWORD)result) {
              goto LABEL_150;
            }
            uint64_t v17 = "cF";
            goto LABEL_171;
          case 9uLL:
            uint64_t result = (void *)memcmp(v6, "TaskGroup", a2);
            if ((_DWORD)result)
            {
              uint64_t result = (void *)memcmp(v6, "MainActor", a2);
              if ((_DWORD)result) {
                goto LABEL_150;
              }
              uint64_t v17 = "cM";
            }

            else
            {
              uint64_t v17 = "cG";
            }

            goto LABEL_171;
          case 0xAuLL:
            uint64_t result = (void *)memcmp(v6, "UnownedJob", a2);
            if ((_DWORD)result) {
              goto LABEL_150;
            }
            uint64_t v17 = "cJ";
            goto LABEL_171;
          case 0xBuLL:
            uint64_t result = (void *)memcmp(v6, "AsyncStream", a2);
            if ((_DWORD)result) {
              goto LABEL_150;
            }
            uint64_t v17 = "cS";
            goto LABEL_171;
          case 0xCuLL:
            uint64_t result = (void *)memcmp(v6, "TaskExecutor", a2);
            if ((_DWORD)result)
            {
              uint64_t result = (void *)memcmp(v6, "TaskPriority", a2);
              if ((_DWORD)result) {
                goto LABEL_150;
              }
              uint64_t v17 = "cP";
            }

            else
            {
              uint64_t v17 = "ch";
            }

            goto LABEL_171;
          case 0xDuLL:
            uint64_t result = (void *)memcmp(v6, "AsyncSequence", a2);
            if ((_DWORD)result) {
              goto LABEL_150;
            }
            uint64_t v17 = "ci";
            goto LABEL_171;
          case 0xEuLL:
            uint64_t result = (void *)memcmp(v6, "SerialExecutor", a2);
            if ((_DWORD)result) {
              goto LABEL_150;
            }
            uint64_t v17 = "cf";
            goto LABEL_171;
          case 0x11uLL:
            uint64_t result = (void *)memcmp(v6, "CancellationError", a2);
            if ((_DWORD)result)
            {
              uint64_t result = (void *)memcmp(v6, "ThrowingTaskGroup", a2);
              if ((_DWORD)result)
              {
                uint64_t result = (void *)memcmp(v6, "UnsafeCurrentTask", a2);
                if ((_DWORD)result) {
                  goto LABEL_150;
                }
                uint64_t v17 = "ct";
              }

              else
              {
                uint64_t v17 = "cg";
              }
            }

            else
            {
              uint64_t v17 = "cE";
            }

            goto LABEL_171;
          case 0x12uLL:
            uint64_t result = (void *)memcmp(v6, "UnsafeContinuation", a2);
            if ((_DWORD)result) {
              goto LABEL_150;
            }
            uint64_t v17 = "cc";
            goto LABEL_171;
          case 0x13uLL:
            uint64_t result = (void *)memcmp(v6, "CheckedContinuation", a2);
            if ((_DWORD)result)
            {
              uint64_t result = (void *)memcmp(v6, "AsyncThrowingStream", a2);
              if ((_DWORD)result) {
                goto LABEL_150;
              }
              uint64_t v17 = "cs";
            }

            else
            {
              uint64_t v17 = "cC";
            }

            goto LABEL_171;
          case 0x15uLL:
            uint64_t result = (void *)memcmp(v6, "UnownedSerialExecutor", a2);
            if ((_DWORD)result)
            {
              uint64_t result = (void *)memcmp(v6, "AsyncIteratorProtocol", a2);
              if ((_DWORD)result) {
                goto LABEL_150;
              }
              uint64_t v17 = "cI";
            }

            else
            {
              uint64_t v17 = "ce";
            }

uint64_t __RawSetStorage._count.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*__RawSetStorage._count.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawSetStorage._capacity.getter()
{
  return *(void *)(v0 + 24);
}

uint64_t __RawSetStorage._capacity.setter(uint64_t result)
{
  *(void *)(v1 + 24) = result;
  return result;
}

uint64_t (*__RawSetStorage._capacity.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawSetStorage._scale.getter()
{
  return *(unsigned __int8 *)(v0 + 32);
}

uint64_t __RawSetStorage._scale.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 32) = result;
  return result;
}

uint64_t (*__RawSetStorage._scale.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawSetStorage._reservedScale.getter()
{
  return *(unsigned __int8 *)(v0 + 33);
}

uint64_t __RawSetStorage._reservedScale.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 33) = result;
  return result;
}

uint64_t (*__RawSetStorage._reservedScale.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawSetStorage._age.getter()
{
  return *(unsigned int *)(v0 + 36);
}

uint64_t __RawSetStorage._age.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 36) = result;
  return result;
}

uint64_t (*__RawSetStorage._age.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawSetStorage._seed.getter()
{
  return *(void *)(v0 + 40);
}

uint64_t __RawSetStorage._seed.setter(uint64_t result)
{
  *(void *)(v1 + 40) = result;
  return result;
}

uint64_t (*__RawSetStorage._seed.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawSetStorage._rawElements.setter(uint64_t result)
{
  *(void *)(v1 + 48) = result;
  return result;
}

uint64_t (*__RawSetStorage._rawElements.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __RawSetStorage._metadata.getter()
{
  return v0 + 56;
}

void __RawSetStorage.__allocating_init(coder:)()
{
}

void __RawSetStorage.init(coder:)()
{
}

uint64_t __RawSetStorage.deinit()
{
  return v0;
}

void __RawSetStorage.__deallocating_deinit()
{
}

uint64_t __EmptySetSingleton.deinit()
{
  return v0;
}

uint64_t @objc __EmptyDictionarySingleton.countByEnumerating(with:objects:count:)( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  unint64_t v4 = *a3;
  unint64_t v5 = a3[1];
  uint64_t v6 = (Swift::UInt *)a3[2];
  if (!*a3)
  {
    uint64_t v6 = &_fastEnumerationStorageMutationsTarget;
    unint64_t v5 = a4;
  }

  if (v4 <= 1) {
    unint64_t v4 = 1LL;
  }
  *a3 = v4;
  a3[1] = v5;
  a3[2] = (unint64_t)v6;
  return 0LL;
}

void _SetStorage.deinit()
{
  uint64_t v1 = *(void *)(*(void *)v0 + 168LL);
  uint64_t v2 = *(void *)(v1 - 8);
  if ((*(_BYTE *)(v2 + 82) & 1) == 0) {
    return;
  }
  int64_t v3 = 0LL;
  uint64_t v4 = v0 + 56;
  uint64_t v5 = *(void *)(v0 + 48);
  uint64_t v6 = 1LL << *(_BYTE *)(v0 + 32);
  uint64_t v7 = -1LL;
  if (v6 < 64) {
    uint64_t v7 = ~(-1LL << v6);
  }
  unint64_t v8 = v7 & *(void *)(v0 + 56);
  int64_t v9 = (unint64_t)(v6 + 63) >> 6;
  while (1)
  {
    if (v8)
    {
      unint64_t v10 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v11 = v10 | (v3 << 6);
      goto LABEL_8;
    }

    if (__OFADD__(v3++, 1LL)) {
      goto LABEL_21;
    }
    if (v3 >= v9) {
      return;
    }
    unint64_t v13 = *(void *)(v4 + 8 * v3);
    if (!v13) {
      break;
    }
LABEL_19:
    unint64_t v8 = (v13 - 1) & v13;
    unint64_t v11 = __clz(__rbit64(v13)) + (v3 << 6);
LABEL_8:
    swift_arrayDestroy(v5 + *(void *)(v2 + 72) * v11, 1LL, v1);
  }

  int64_t v14 = v3 + 1;
  if (v3 + 1 >= v9) {
    return;
  }
  unint64_t v13 = *(void *)(v4 + 8 * v14);
  if (v13)
  {
    ++v3;
    goto LABEL_19;
  }

  while (1)
  {
    int64_t v3 = v14 + 1;
    if (__OFADD__(v14, 1LL)) {
      break;
    }
    if (v3 >= v9) {
      return;
    }
    unint64_t v13 = *(void *)(v4 + 8 * v3);
    ++v14;
    if (v13) {
      goto LABEL_19;
    }
  }

  __break(1u);
LABEL_21:
  __break(1u);
}

uint64_t _SetStorage._elements.getter()
{
  return *(void *)(v0 + 48);
}

void _SetStorage.__deallocating_deinit()
{
}

void @objc _SetStorage.init(objects:count:)()
{
}

  ;
}

id @objc _SetStorage.copy(with:)()
{
  uint64_t v0 = (void *)specialized _SetStorage.copy(with:)();
  return swift_unknownObjectRetain(v0, v1, v2, v3);
}

uint64_t @objc _SetStorage.count.getter()
{
  return _ContiguousArrayStorage.count.getter();
}

void *_SetStorage.objectEnumerator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for _SwiftSetNSEnumerator(0LL, *(void *)(*v4 + 168), *(void *)(*v4 + 176), a4);
  uint64_t v6 = swift_allocObject(v5, 0x30uLL, 7uLL);
  v6[2] = v4;
  v6[3] = 0LL;
  uint64_t v7 = -1LL << *((_BYTE *)v4 + 32);
  v6[4] = _HashTable.startBucket.getter(v4 + 7, ~v7);
  v6[5] = -v7;
  swift_retain(v4, v8, v9, v10);
  return v6;
}

void *@objc _SetStorage.objectEnumerator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SetStorage.objectEnumerator()(a1, a2, a3, a4);
}

uint64_t _SetStorage.countByEnumerating(with:objects:count:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *(uint64_t **)(*(void *)v2 + 168LL);
  uint64_t v6 = *(v5 - 1);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v43 = (id *)((char *)&v37 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (id *)((char *)&v37 - v11);
  uint64_t v13 = v2 + 56;
  uint64_t v14 = -1LL << *(_BYTE *)(v2 + 32);
  uint64_t v15 = *(void *)v9;
  __int128 v16 = *(_OWORD *)(v9 + 32);
  __int128 v45 = *(_OWORD *)(v9 + 48);
  __int128 v46 = v16;
  uint64_t v49 = v10;
  if (!v15)
  {
    unint64_t v33 = _HashTable.startBucket.getter((unint64_t *)(v2 + 56), ~v14);
    if ((v33 & 0x8000000000000000LL) != 0) {
      goto LABEL_39;
    }
    unint64_t v19 = v33;
    uint64_t v17 = &_fastEnumerationStorageMutationsTarget;
    uint64_t v15 = 1LL;
    uint64_t v18 = a2;
    uint64_t v10 = v49;
    if (a2) {
      goto LABEL_3;
    }
    return 0LL;
  }

  uint64_t v18 = a1[1];
  uint64_t v17 = (Swift::UInt *)a1[2];
  unint64_t v19 = a1[3];
  if (!a2) {
    return 0LL;
  }
LABEL_3:
  if ((v19 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  uint64_t v48 = a2;
  uint64_t v20 = -v14;
  if (v19 + v14 && ((uint64_t)v19 >= v20 || ((*(void *)(v13 + ((v19 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v19) & 1) == 0)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid fast enumeration state",  30LL,  2,  "Swift/SetStorage.swift",  22LL,  2,  0x124uLL,  0);
  }
  if (v10 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v44 = a1;
  if (!v10)
  {
    uint64_t v21 = 0LL;
    goto LABEL_35;
  }

  uint64_t v40 = v18;
  uint64_t v41 = v17;
  uint64_t v42 = v15;
  uint64_t v21 = 0LL;
  unint64_t v47 = (unint64_t)(63 - v14) >> 6;
  uint64_t v38 = v2 + 80;
  unint64_t v39 = v47 - 3;
  do
  {
    if (v19 == v20)
    {
      unint64_t v19 = v20;
      goto LABEL_34;
    }

    (*(void (**)(id *, unint64_t, uint64_t *))(v6 + 16))( v12,  *(void *)(v2 + 48) + *(void *)(v6 + 72) * v19,  v5);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v5, v5))
    {
      if (v7 != 8) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
      uint64_t v26 = *v12;
      swift_unknownObjectRetain(*v12, v23, v24, v25);
      (*(void (**)(id *, uint64_t *))(v6 + 8))(v12, v5);
    }

    else
    {
      uint64_t v30 = v43;
      (*(void (**)(id *, id *, uint64_t *))(v6 + 32))(v43, v12, v5);
      uint64_t v26 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v30, v5, v31, v32);
    }

    if (v21 == 0x1000000000000000LL)
    {
      __break(1u);
LABEL_39:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }

    *(void *)(v48 + 8 * v21) = v26;
    swift_unknownObjectRelease(v26);
    unint64_t v27 = v19 >> 6;
    if ((*(void *)(v13 + 8 * (v19 >> 6)) & (-2LL << v19)) != 0)
    {
      unint64_t v19 = __clz(__rbit64(*(void *)(v13 + 8 * (v19 >> 6)) & (-2LL << v19))) | v19 & 0xFFFFFFFFFFFFFFC0LL;
      uint64_t v22 = v49;
      goto LABEL_11;
    }

    unint64_t v28 = v27 + 1;
    unint64_t v19 = v20;
    uint64_t v22 = v49;
    if (v27 + 1 < v47)
    {
      unint64_t v29 = *(void *)(v13 + 8 * v28);
      if (v29) {
        goto LABEL_20;
      }
      unint64_t v28 = v27 + 2;
      unint64_t v19 = v20;
      if (v27 + 2 < v47)
      {
        unint64_t v29 = *(void *)(v13 + 8 * v28);
        if (v29)
        {
LABEL_20:
          unint64_t v19 = __clz(__rbit64(v29)) + (v28 << 6);
          goto LABEL_11;
        }

        while (v39 != v27)
        {
          unint64_t v29 = *(void *)(v38 + 8 * v27++);
          if (v29)
          {
            unint64_t v28 = v27 + 2;
            goto LABEL_20;
          }
        }

        unint64_t v19 = v20;
      }
    }

uint64_t @objc _SetStorage.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, char *, uint64_t))_SetStorage.countByEnumerating(with:objects:count:));
}

uint64_t @objc _SwiftDeferredNSDictionary.countByEnumerating(with:objects:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t (*a6)(uint64_t, char *, uint64_t))
{
  uint64_t v11 = a6(a3, a4, a5);
  swift_release((uint64_t)a1);
  return v11;
}

char *_SetStorage.member(_:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = *v4;
  uint64_t v8 = *(char **)(*v4 + 168);
  uint64_t v9 = type metadata accessor for Optional(0LL, (uint64_t)v8, a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v32 - v12;
  uint64_t v14 = *((void *)v8 - 1);
  uint64_t v15 = MEMORY[0x1895F8858](v11);
  uint64_t v17 = (id *)((char *)&v32 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)&v32 - v18;
  _conditionallyBridgeFromObjectiveC<A>(_:_:)(a1, v8, v20, v13);
  if ((*(unsigned int (**)(char *, uint64_t, char *))(v14 + 48))(v13, 1LL, v8) == 1)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, v9);
    return 0LL;
  }

  (*(void (**)(char *, char *, char *))(v14 + 32))(v19, v13, v8);
  uint64_t v21 = *(void *)(v7 + 176);
  uint64_t v22 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(v21 + 32))(v5[5], v8, v21);
  uint64_t v23 = -1LL << *((_BYTE *)v5 + 32);
  unint64_t v24 = v22 & ~v23;
  __int128 v35 = v5 + 7;
  unint64_t v25 = *(unint64_t *)((char *)v5 + ((v24 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> v24;
  uint64_t v37 = v19;
  if ((v25 & 1) == 0)
  {
    unint64_t v29 = *(void (**)(char *, char *))(v14 + 8);
LABEL_9:
    v29(v37, v8);
    return 0LL;
  }

  uint64_t v33 = ~v23;
  uint64_t v26 = *(void *)(v21 + 8);
  uint64_t v34 = *(uint64_t (**)(id *, char *, char *, uint64_t))(v26 + 8);
  uint64_t v27 = *(void *)(v14 + 72);
  uint64_t v36 = *(void (**)(id *, unint64_t, char *))(v14 + 16);
  while (1)
  {
    v36(v17, v5[6] + v27 * v24, v8);
    char v28 = v34(v17, v37, v8, v26);
    unint64_t v29 = *(void (**)(char *, char *))(v14 + 8);
    v29((char *)v17, v8);
    if ((v28 & 1) != 0) {
      break;
    }
    unint64_t v24 = (v24 + 1) & v33;
  }

  v29(v37, v8);
  v36(v17, v5[6] + v27 * v24, v8);
  uint64_t v30 = _bridgeAnythingToObjectiveC<A>(_:)(v17, (uint64_t *)v8);
  v29((char *)v17, v8);
  return v30;
}

id @objc _SetStorage.member(_:)(unint64_t *a1, uint64_t a2, void *a3)
{
  return @objc _SwiftDeferredNSDictionary.object(forKey:)(a1, a2, a3, (char *)_SetStorage.member(_:));
}

id @objc _SwiftDeferredNSDictionary.object(forKey:)(unint64_t *a1, uint64_t a2, void *a3, char *a4)
{
  uint64_t v10 = (void *)((uint64_t (*)(void *))a4)(a3);
  swift_unknownObjectRelease(a3);
  swift_release((uint64_t)a1);
  return v10;
}

uint64_t (*Set._Variant.object.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t Set._Variant.init(dummy:)()
{
  return 0x8000000000000000LL;
}

uint64_t Set._Variant.guaranteedNative.getter()
{
  return 0LL;
}

uint64_t (*Set._Variant.asNative.modify(void *a1))()
{
  *a1 = *v1;
  a1[1] = v1;
  void *v1 = 0x8000000000000000LL;
  return _SmallString.leadingRawBits.modify;
}

uint64_t Set._Variant._migrateToNative(_:removing:)@<X0>( void *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v52 = a4;
  uint64_t v8 = *(char **)(a3 + 16);
  uint64_t v9 = (void *)*((void *)v8 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v53 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v48 - v15;
  uint64_t v51 = v4;
  swift_bridgeObjectRelease(*v4);
  id v17 = objc_msgSend(a1, sel_count);
  uint64_t v18 = *(void *)(a3 + 24);
  id v22 = swift_unknownObjectRetain(a1, v19, v20, v21);
  uint64_t v23 = _NativeSet.init(_:capacity:)(v22, (uint64_t)v17, v8, v18);
  uint64_t v59 = v23;
  unint64_t v24 = v23[5];
  unint64_t v25 = *(uint64_t (**)(__objc2_class *, char *, uint64_t))(v18 + 32);
  swift_retain((unint64_t *)v23, v26, v27, v28);
  uint64_t v57 = a2;
  uint64_t v29 = v25(v24, v8, v18);
  uint64_t v30 = -1LL << *((_BYTE *)v23 + 32);
  unint64_t v31 = v29 & ~v30;
  unint64_t v58 = v23;
  uint64_t v32 = v23 + 7;
  if (((*(unint64_t *)((char *)v23 + ((v31 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> v31) & 1) == 0)
  {
LABEL_5:
    swift_release((uint64_t)v58);
    unint64_t v40 = 338LL;
    goto LABEL_6;
  }

  uint64_t v49 = v18;
  uint64_t v50 = v14;
  uint64_t v33 = ~v30;
  uint64_t v56 = *(void *)(v18 + 8);
  uint64_t v34 = *(uint64_t (**)(char *, uint64_t, char *, uint64_t))(v56 + 8);
  uint64_t v35 = v9[9];
  unint64_t v54 = (void (*)(char *, char *, char *))v9[2];
  unint64_t v55 = v34;
  while (1)
  {
    unint64_t v36 = v35 * v31;
    v54(v16, (char *)v58[6] + v35 * v31, v8);
    char v37 = v55(v16, (uint64_t)v57, v8, v56);
    uint64_t v38 = v9;
    unint64_t v39 = (void (*)(char *, char *))v9[1];
    v39(v16, v8);
    if ((v37 & 1) != 0) {
      break;
    }
    unint64_t v31 = (v31 + 1) & v33;
    uint64_t v9 = v38;
  }

  uint64_t v41 = (uint64_t)v58;
  swift_release((uint64_t)v58);
  uint64_t v42 = v52;
  ((void (*)(uint64_t, unint64_t, char *))v38[4])(v52, *(void *)(v41 + 48) + v36, v8);
  type metadata accessor for _NativeSet(0LL, (uint64_t)v8, v49, v43);
  _NativeSet._delete(at:)((Swift::_HashTable::Bucket)v31);
  unint64_t v44 = v50;
  __int128 v45 = (void (*)(char *, uint64_t, char *))v54;
  v54(v50, v57, v8);
  __int128 v46 = v53;
  v45(v53, v42, v8);
  if ((v55(v44, (uint64_t)v46, v8, v56) & 1) == 0)
  {
    unint64_t v40 = 340LL;
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Bridging did not preserve equality",  34LL,  2,  "Swift/SetVariant.swift",  22LL,  2,  v40,  0);
  }

  v39(v46, v8);
  uint64_t result = ((uint64_t (*)(char *, char *))v39)(v44, v8);
  *uint64_t v51 = v41;
  return result;
}

Swift::UInt _fastEnumerationStorageMutationsTarget.getter()
{
  return _fastEnumerationStorageMutationsTarget;
}

Swift::UInt _fastEnumerationStorageMutationsTarget.setter(Swift::UInt result)
{
  _fastEnumerationStorageMutationsTarget = result;
  return result;
}

uint64_t (*_fastEnumerationStorageMutationsTarget.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt *_fastEnumerationStorageMutationsPtr.getter()
{
  return &_fastEnumerationStorageMutationsTarget;
}

uint64_t Slice._startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index,  a2);
}

uint64_t Slice._startIndex.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
}

uint64_t (*Slice._startIndex.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Slice._endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter( a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index,  a2);
}

uint64_t IndexingIterator._position.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = v4 + *(int *)(a1 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a1 + 24), *(void *)(a1 + 16), a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a4,  v6,  AssociatedTypeWitness);
}

uint64_t Slice._endIndex.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
}

uint64_t IndexingIterator._position.setter(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v6 = v4 + *(int *)(a2 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a2 + 24), *(void *)(a2 + 16), a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( v6,  a1,  AssociatedTypeWitness);
}

uint64_t (*Slice._endIndex.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Slice._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))( a2,  v2 + *(int *)(a1 + 40));
}

uint64_t Slice._base.setter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 40LL))( v2 + *(int *)(a2 + 40),  a1);
}

uint64_t (*Slice._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Slice.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))( a2,  v2 + *(int *)(a1 + 40));
}

uint64_t Slice.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index,  a2);
}

uint64_t LazyFilterSequence.Iterator.base.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a1 + 24), *(void *)(a1 + 16), a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a4,  v4,  AssociatedTypeWitness);
}

uint64_t Slice._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 160LL))( a1,  a2,  *(void *)(a3 + 16));
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 176LL))( a1,  a2,  *(void *)(a3 + 16));
}

uint64_t Slice.indices.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v48 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v39 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v16 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  uint64_t v17 = *(void *)(v16 - 8);
  uint64_t v45 = v16;
  uint64_t v46 = v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v39 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  unint64_t v44 = (char *)&v39 - v21;
  uint64_t v41 = v5;
  unint64_t v43 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Indices);
  uint64_t v47 = *(void *)(v43 - 8);
  MEMORY[0x1895F8858](v43);
  uint64_t v42 = (char *)&v39 - v22;
  uint64_t v40 = v6;
  (*(void (**)(uint64_t, uint64_t))(v6 + 96))(v5, v6);
  uint64_t v23 = v3 + *(int *)(a1 + 36);
  unint64_t v24 = &v13[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v25 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v26 = (void (*)(char *, uint64_t, unint64_t))v25[2];
  v26(v13, v3, AssociatedTypeWitness);
  v26(v24, v23, AssociatedTypeWitness);
  uint64_t v27 = TupleTypeMetadata2;
  char v28 = &v11[*((int *)TupleTypeMetadata2 + 12)];
  v26(v11, (uint64_t)v13, AssociatedTypeWitness);
  v26(v28, (uint64_t)v24, AssociatedTypeWitness);
  uint64_t v29 = (void (*)(char *, char *, unint64_t))v25[4];
  v29(v20, v11, AssociatedTypeWitness);
  uint64_t v30 = (void (*)(char *, unint64_t))v25[1];
  v30(v28, AssociatedTypeWitness);
  unint64_t v31 = &v11[*((int *)v27 + 12)];
  v29(v11, v13, AssociatedTypeWitness);
  v29(v31, v24, AssociatedTypeWitness);
  uint64_t v32 = v45;
  v29(&v20[*(int *)(v45 + 36)], v31, AssociatedTypeWitness);
  v30(v11, AssociatedTypeWitness);
  uint64_t v33 = v46;
  uint64_t v34 = v44;
  (*(void (**)(char *, char *, uint64_t))(v46 + 32))(v44, v20, v32);
  unint64_t v35 = v43;
  unint64_t v36 = swift_getAssociatedConformanceWitness( v40,  v41,  v43,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Indices: Collection);
  char v37 = v42;
  (*(void (**)(char *, unint64_t, unint64_t))(v36 + 88))(v34, v35, v36);
  (*(void (**)(char *, uint64_t))(v33 + 8))(v34, v32);
  return (*(uint64_t (**)(char *, unint64_t))(v47 + 8))(v37, v35);
}

uint64_t Slice.index(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 184LL))(a1, *(void *)(a2 + 16));
}

uint64_t Slice.formIndex(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 192LL))(a1, *(void *)(a2 + 16));
}

uint64_t Slice.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 136LL))( a1,  a2,  *(void *)(a3 + 16));
}

uint64_t Slice.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a4 + 24) + 144LL))( a1,  a2,  a3,  *(void *)(a4 + 16));
}

uint64_t Slice.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 152LL))( a1,  a2,  *(void *)(a3 + 16));
}

uint64_t _ss5SliceV32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys5UInt8Vqd__Isgyrzo_ABySS8UTF8ViewVGADsAI_pAMRszr__lIetMggrzo_Tpq5@<X0>( uint64_t (*a1)(uint64_t)@<X0>, Swift::UInt64 a2@<X2>, Swift::UInt64 a3@<X3>, uint64_t a4@<X4>, unint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  if ((a5 & 0x1000000000000000LL) != 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a6 - 8) + 56LL))( a7,  1LL,  1LL,  a6);
  }
  if ((a5 & 0x2000000000000000LL) != 0)
  {
    uint64_t v16 = HIBYTE(a5) & 0xF;
    v20[0] = a4;
    v20[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v15 = v20;
  }

  else if ((a4 & 0x1000000000000000LL) != 0)
  {
    uint64_t v15 = (void *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v16 = a4 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v15 = _StringObject.sharedUTF8.getter(a4, a5);
  }

  v17._Swift::UInt64 rawBits = a2;
  v18._Swift::UInt64 rawBits = a3;
  uint64_t result = _ss5SliceV32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFqd__AGKXEfU_SRys5UInt8VGABySS8UTF8ViewVGSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyAIqd__Isgyrzo_qd__sAO_pALRszr__lIetyggrzo_Tpq5( (uint64_t)v15,  v16,  v17,  v18,  a4,  a5,  a1);
  if (!v7) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a6 - 8) + 56LL))(a7, 0LL, 1LL, a6);
  }
  return result;
}

uint64_t Slice.withContiguousStorageIfAvailable<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = &v15[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v10 + 16))(v12, v4 + *(int *)(v13 + 40), v9);
  uint64_t v16 = v9;
  uint64_t v17 = a4;
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = v4;
  uint64_t v20 = a1;
  uint64_t v21 = a2;
  (*(void (**)(uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, uint64_t@<X8>), _BYTE *, uint64_t, uint64_t))(*(void *)(v18 + 8) + 72LL))( partial apply for closure #1 in Slice.withContiguousStorageIfAvailable<A>(_:),  v15,  a4,  v9);
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v10 + 8))(v12, v9);
}

uint64_t _ss5SliceV32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFqd__AGKXEfU_SRys5UInt8VGABySS8UTF8ViewVGSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyAIqd__Isgyrzo_qd__sAO_pALRszr__lIetyggrzo_Tpq5( uint64_t a1, uint64_t a2, Swift::String::Index from, Swift::String::Index to, uint64_t a5, unint64_t a6, uint64_t (*a7)(uint64_t))
{
  Swift::UInt64 rawBits = from._rawBits;
  char v13 = (a6 & 0x1000000000000000LL) == 0 || (a5 & 0x800000000000000LL) != 0;
  uint64_t v14 = 4LL << v13;
  uint64_t v15 = from._rawBits & 0xC;
  Swift::UInt64 v16 = from._rawBits;
  if (v15 == 4LL << v13)
  {
    Swift::UInt64 v16 = _StringGuts._slowEnsureMatchingEncoding(_:)(from)._rawBits;
    if ((a6 & 0x1000000000000000LL) == 0)
    {
LABEL_6:
      uint64_t v17 = v16 >> 16;
      if (v15 != v14) {
        goto LABEL_7;
      }
      goto LABEL_19;
    }
  }

  else if ((a6 & 0x1000000000000000LL) == 0)
  {
    goto LABEL_6;
  }

  unint64_t v22 = a5 & 0xFFFFFFFFFFFFLL;
  if ((a6 & 0x2000000000000000LL) != 0) {
    unint64_t v22 = HIBYTE(a6) & 0xF;
  }
  if (v22 < v16 >> 16) {
    goto LABEL_28;
  }
  uint64_t v17 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)v16);
  if (v15 != v14) {
    goto LABEL_7;
  }
LABEL_19:
  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
LABEL_7:
  if ((to._rawBits & 0xC) == v14)
  {
    to._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
    if ((a6 & 0x1000000000000000LL) == 0)
    {
LABEL_9:
      Swift::UInt64 v18 = (to._rawBits >> 16) - (rawBits >> 16);
      uint64_t v19 = v17 + v18;
      if (!__OFADD__(v17, v18)) {
        goto LABEL_10;
      }
      goto LABEL_27;
    }
  }

  else if ((a6 & 0x1000000000000000LL) == 0)
  {
    goto LABEL_9;
  }

  unint64_t v23 = HIBYTE(a6) & 0xF;
  if ((a6 & 0x2000000000000000LL) == 0) {
    unint64_t v23 = a5 & 0xFFFFFFFFFFFFLL;
  }
  if (v23 < rawBits >> 16 || v23 < to._rawBits >> 16) {
LABEL_28:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  Swift::Int v24 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, to);
  uint64_t v19 = v17 + v24;
  if (__OFADD__(v17, v24))
  {
LABEL_27:
    __break(1u);
    goto LABEL_28;
  }

uint64_t closure #1 in Slice.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, uint64_t (*a4)(uint64_t)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  unint64_t v25 = a4;
  v24[1] = a8;
  v24[2] = a5;
  uint64_t v26 = a2;
  v24[0] = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a7,  a6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v13 = (char *)v24 - v12;
  uint64_t v15 = type metadata accessor for Slice(0LL, a6, a7, v14);
  (*(void (**)(uint64_t, uint64_t))(a7 + 64))(a6, a7);
  Swift::UInt64 v16 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(a7 + 152);
  uint64_t v17 = v16(v13, (uint64_t)a3, a6, a7);
  (*(void (**)(char *, unint64_t))(v11 + 8))(v13, AssociatedTypeWitness);
  uint64_t v18 = v16(a3, (uint64_t)&a3[*(int *)(v15 + 36)], a6, a7);
  uint64_t v19 = v17 + v18;
  if (__OFADD__(v17, v18))
  {
    __break(1u);
LABEL_7:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (v19 < v17) {
    goto LABEL_7;
  }
  if (v17 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x744uLL,  0);
  }
  uint64_t v20 = v26;
  if (v19 > v26) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }
  unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a7 + 8),  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v22 = UnsafeBufferPointer.init(rebasing:)(v17, v19, v24[0], v20, v21);
  return v25(v22);
}

uint64_t UnsafeBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnsafeBufferPointer.subscript.getter(a1, a2, a3, a4, a5, 0x744uLL, 0x745uLL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Slice<A>( unint64_t **a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = (unint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (unint64_t)Slice.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*Slice.subscript.read(unint64_t *a1, uint64_t a2, uint64_t a3))()
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a3 + 24) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  *a1 = AssociatedTypeWitness;
  unint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  a1[1] = v7;
  uint64_t v8 = malloc(*(void *)(v7 + 64));
  a1[2] = (unint64_t)v8;
  Slice.subscript.getter(a2, a3, (uint64_t)v8);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance DefaultIndices<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v4, v5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56LL))(a2, 1LL, 1LL, v6);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Slice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance DefaultIndices<A>( a1,  (void (*)(uint64_t))Slice.startIndex.getter,  (uint64_t)&protocol conformance descriptor for Slice<A>,  a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance DefaultIndices<A>@<X0>( uint64_t a1@<X0>, void (*a2)(uint64_t)@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v19 - v11;
  uint64_t v13 = *(void *)(a1 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16))(a4, v4, a1);
  a2(a1);
  (*(void (**)(uint64_t, uint64_t))(v13 + 8))(v4, a1);
  uint64_t WitnessTable = swift_getWitnessTable(a3, a1, v14);
  uint64_t v17 = type metadata accessor for IndexingIterator(0LL, a1, WitnessTable, v16);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v10 + 32))( a4 + *(int *)(v17 + 36),  v12,  AssociatedTypeWitness);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t Slice._copyContents(initializing:)(char *a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v126 = a2;
  uint64_t v100 = a1;
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v6 = *(void *)(a4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v116 = (char *)&v97 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v115 = (char *)&v97 - v11;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v114 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v113 = *(void *)(v114 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v114);
  uint64_t v112 = (char *)&v97 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v111 = (char *)&v97 - v15;
  uint64_t v16 = *(void *)(v6 + 8);
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v16,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v109 = *(void *)(v17 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  id v108 = (char *)&v97 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v107 = (char *)&v97 - v21;
  uint64_t v22 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v20);
  unint64_t v119 = (char *)&v97 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a4, v24);
  uint64_t v123 = type metadata accessor for IndexingIterator(0LL, a4, WitnessTable, v26);
  uint64_t v99 = *(void (**)(uint64_t, char *, uint64_t))(v123 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v123);
  uint64_t v98 = (char *)&v97 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v31 = (char *)&v97 - v30;
  unint64_t v128 = AssociatedTypeWitness;
  uint64_t v122 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v32 = MEMORY[0x1895F8858](v29);
  uint64_t v106 = (char *)&v97 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v121 = (char *)&v97 - v35;
  uint64_t v36 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v34);
  uint64_t v38 = (char *)&v97 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v137 = v7;
  uint64_t v138 = v6;
  v139 = v126;
  uint64_t v140 = a3;
  uint64_t v124 = a4;
  uint64_t v39 = *(int *)(a4 + 40);
  uint64_t v40 = v125;
  uint64_t v41 = (void (*)(char *, char *, uint64_t))(v125 + v39);
  uint64_t v42 = *(void (**)(char *))(v36 + 16);
  int64_t v105 = v41;
  v42(v38);
  uint64_t v130 = v7;
  unint64_t v110 = v17;
  uint64_t v45 = type metadata accessor for UnsafeBufferPointer.Iterator(255LL, v17, v43, v44);
  unint64_t v131 = swift_getTupleTypeMetadata2(0LL, v45, (uint64_t)&type metadata for Int, 0LL, 0LL);
  uint64_t v132 = v6;
  uint64_t v120 = v6;
  uint64_t v46 = v40;
  uint64_t v133 = v40;
  int v134 = partial apply for closure #1 in Slice._copyContents(initializing:);
  int64_t v135 = &v136;
  (*(void (**)(void *__return_ptr, uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, uint64_t@<X8>), char *, unint64_t *, uint64_t, uint64_t))(v16 + 72))( v141,  partial apply for closure #1 in Slice.withContiguousStorageIfAvailable<A>(_:),  v129,  v131,  v7,  v16);
  (*(void (**)(char *, uint64_t))(v36 + 8))(v38, v7);
  if ((v142 & 1) != 0)
  {
    uint64_t v106 = (char *)v7;
    uint64_t v47 = v119;
    uint64_t v48 = v124;
    (*(void (**)(char *, uint64_t, uint64_t))(v22 + 32))(v119, v46, v124);
    uint64_t v49 = v98;
    int64_t v105 = *(void (**)(char *, char *, uint64_t))(v22 + 16);
    v105(v98, v47, v48);
    uint64_t v50 = v122;
    uint64_t v51 = *(void (**)(char *, char *, unint64_t))(v122 + 16);
    uint64_t v52 = v121;
    unint64_t v53 = v128;
    v51(v121, v47, v128);
    unint64_t v104 = *(void (**)(char *, uint64_t))(v22 + 8);
    v104(v47, v48);
    uint64_t v54 = v123;
    unint64_t v55 = &v49[*(int *)(v123 + 36)];
    uint64_t v103 = *(void (**)(char *, char *, unint64_t))(v50 + 32);
    v103(v55, v52, v53);
    uint64_t v56 = (void (*)(char *, char *, uint64_t))*((void *)v99 + 4);
    v56(v31, v49, v54);
    if (v126)
    {
      if (a3 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
      }
      uint64_t v99 = (void (*)(uint64_t, char *, uint64_t))v56;
      if (a3)
      {
        uint64_t v57 = 0LL;
        uint64_t v102 = a3;
        unint64_t v127 = v31;
        uint64_t v101 = v51;
        while (1)
        {
          unint64_t v58 = &v31[*(int *)(v123 + 36)];
          uint64_t v59 = v121;
          v51(v121, v58, v53);
          unint64_t v60 = &v31[*(int *)(v48 + 36)];
          char v61 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness
                                                                                        + 8)
                                                                            + 8LL))( v59,  v60,  v53);
          uint64_t v62 = *(void (**)(char *, unint64_t))(v122 + 8);
          v62(v59, v53);
          if ((v61 & 1) != 0) {
            break;
          }
          uint64_t v125 = v57 + 1;
          uint64_t v63 = TupleTypeMetadata2;
          uint64_t v64 = *((int *)TupleTypeMetadata2 + 12);
          uint64_t v124 = (uint64_t)v58;
          uint64_t v65 = v115;
          uint64_t v66 = &v115[v64];
          v51(v115, v31, v53);
          v51(v66, v60, v53);
          uint64_t v67 = v116;
          uint64_t v68 = &v116[*((int *)v63 + 12)];
          v51(v116, v65, v128);
          v51(v68, v66, v128);
          uint64_t v69 = v112;
          uint64_t v70 = v103;
          v103(v112, v67, v128);
          v62(v68, v128);
          uint64_t v71 = &v67[*((int *)v63 + 12)];
          v70(v67, v65, v128);
          v70(v71, v66, v128);
          uint64_t v72 = v114;
          v70(&v69[*(int *)(v114 + 36)], v71, v128);
          int64_t v73 = v67;
          unint64_t v53 = v128;
          v62(v73, v128);
          uint64_t v74 = v113;
          unint64_t v75 = v111;
          (*(void (**)(char *, char *, uint64_t))(v113 + 32))(v111, v69, v72);
          uint64_t v76 = v120;
          uint64_t v77 = v124;
          uint64_t v78 = v106;
          (*(void (**)(uint64_t, char *, char *, uint64_t))(v120 + 160))(v124, v75, v106, v120);
          (*(void (**)(char *, uint64_t))(v74 + 8))(v75, v72);
          id v79 = (void (*)(void *, void))(*(uint64_t (**)(void *, uint64_t, char *, uint64_t))(v76 + 80))( v141,  v77,  v78,  v76);
          uint64_t v80 = v109;
          unint64_t v81 = v108;
          unint64_t v82 = v110;
          (*(void (**)(char *))(v109 + 16))(v108);
          v79(v141, 0LL);
          uint64_t v83 = v119;
          v105(v119, v127, v48);
          (*(void (**)(uint64_t, char *, uint64_t))(v76 + 192))(v77, v78, v76);
          v104(v83, v48);
          uint64_t v84 = *(void (**)(char *, char *, unint64_t))(v80 + 32);
          int64_t v85 = v107;
          uint64_t v86 = v81;
          unint64_t v31 = v127;
          v84(v107, v86, v82);
          uint64_t v87 = v126;
          uint64_t v88 = v85;
          uint64_t v57 = v125;
          unint64_t v89 = v82;
          uint64_t v51 = v101;
          v84(v126, v88, v89);
          uint64_t v126 = &v87[*(void *)(v80 + 72)];
          a3 = v102;
          if (v102 == v57) {
            goto LABEL_8;
          }
        }

        v99((uint64_t)v100, v31, v123);
        return v57;
      }

      else
      {
LABEL_8:
        v99((uint64_t)v100, v31, v123);
      }
    }

    else
    {
      v56(v100, v31, v123);
      return 0LL;
    }
  }

  else
  {
    a3 = v141[2];
    uint64_t v90 = v122;
    int64_t v91 = v106;
    unint64_t v92 = v128;
    (*(void (**)(char *, uint64_t, unint64_t))(v122 + 16))(v106, v46, v128);
    int64_t v93 = v121;
    (*(void (**)(char *, uint64_t, uint64_t))(v120 + 136))(v91, a3, v7);
    (*(void (**)(char *, unint64_t))(v90 + 8))(v91, v92);
    uint64_t v94 = *(void (**)(uint64_t, uint64_t, uint64_t))(v22 + 32);
    unint64_t v95 = v100;
    v94((uint64_t)v100, v46, v124);
    (*(void (**)(char *, char *, unint64_t))(v90 + 32))(&v95[*(int *)(v123 + 36)], v93, v92);
  }

  return a3;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Slice.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a4, a3);
}

unint64_t closure #1 in Slice._copyContents(initializing:)@<X0>( unint64_t result@<X0>, uint64_t a2@<X1>, char *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, char **a7@<X8>)
{
  uint64_t v8 = (char *)result;
  if (a2 && a4)
  {
    if (a2 >= a4) {
      uint64_t v11 = a4;
    }
    else {
      uint64_t v11 = a2;
    }
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a6 + 8),  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t result = (unint64_t)UnsafeMutablePointer.initialize(from:count:)(v8, v11, a3, AssociatedTypeWitness);
    uint64_t v13 = *(void *)(*(void *)(AssociatedTypeWitness - 8) + 72LL);
    uint64_t v14 = &v8[v13 * a2];
    v8 += v13 * v11;
  }

  else if (result)
  {
    uint64_t result = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a6 + 8),  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v11 = 0LL;
    uint64_t v14 = &v8[*(void *)(*(void *)(result - 8) + 72LL) * a2];
  }

  else
  {
    uint64_t v14 = 0LL;
    uint64_t v11 = 0LL;
  }

  *a7 = v8;
  a7[1] = v14;
  a7[2] = (char *)v11;
  return result;
}

char *UnsafeBufferPointer._copyContents(initializing:)( char *__dst, uint64_t a2, char *__src, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = __src;
  if (a4 && a2)
  {
    if (a4 >= a2) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = a4;
    }
    UnsafeMutablePointer.initialize(from:count:)(__src, v7, __dst, a5);
    v6 += *(void *)(*(void *)(a5 - 8) + 72LL) * v7;
  }

  return v6;
}

uint64_t Slice<>.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 32))(a1, *(void *)(a2 + 16));
}

uint64_t Slice<>.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 40))(a1, *(void *)(a2 + 16));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Slice<>.index(before:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Slice<>.formIndex(before:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t Slice<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v50 = a1;
  uint64_t v51 = a4;
  uint64_t v6 = *(const char **)(a3 + 8);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v46 = a2;
  uint64_t v48 = v6;
  uint64_t v49 = v7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v11 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v44 - v14;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v45 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v17);
  uint64_t v47 = *(void *)(v45 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v45);
  uint64_t v20 = (char *)&v44 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v44 - v21;
  uint64_t v23 = *(int *)(a2 + 36);
  uint64_t v24 = v5;
  uint64_t v44 = v5;
  uint64_t v25 = v5 + v23;
  uint64_t v26 = &v15[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v27 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v28 = (void (*)(char *, uint64_t, unint64_t))v27[2];
  v28(v15, v24, AssociatedTypeWitness);
  v28(v26, v25, AssociatedTypeWitness);
  uint64_t v29 = &v13[*((int *)TupleTypeMetadata2 + 12)];
  v28(v13, (uint64_t)v15, AssociatedTypeWitness);
  v28(v29, (uint64_t)v26, AssociatedTypeWitness);
  uint64_t v30 = (void (*)(char *, char *, unint64_t))v27[4];
  v30(v20, v13, AssociatedTypeWitness);
  unint64_t v31 = (void (*)(char *, unint64_t))v27[1];
  v31(v29, AssociatedTypeWitness);
  uint64_t v32 = &v13[*((int *)TupleTypeMetadata2 + 12)];
  v30(v13, v15, AssociatedTypeWitness);
  v30(v32, v26, AssociatedTypeWitness);
  uint64_t v33 = v45;
  v30(&v20[*(int *)(v45 + 36)], v32, AssociatedTypeWitness);
  v31(v13, AssociatedTypeWitness);
  uint64_t v34 = v47;
  uint64_t v35 = v33;
  (*(void (**)(char *, char *, uint64_t))(v47 + 32))(v22, v20, v33);
  uint64_t v37 = v48;
  uint64_t v36 = v49;
  uint64_t v38 = v50;
  (*((void (**)(uint64_t, char *, uint64_t, const char *))v48 + 20))(v50, v22, v49, v48);
  (*(void (**)(char *, uint64_t))(v34 + 8))(v22, v35);
  uint64_t v39 = (uint64_t (*)(_BYTE *, void))(*((uint64_t (**)(_BYTE *, uint64_t, uint64_t, const char *))v37
                                                  + 10))( v52,  v38,  v36,  v37);
  uint64_t v41 = v40;
  unint64_t v42 = swift_getAssociatedTypeWitness( 0LL,  *((const char **)v37 + 1),  v36,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v42 - 8) + 16LL))(v51, v41, v42);
  return v39(v52, 0LL);
}

uint64_t key path getter for Slice<>.subscript(_:) : <A>Slice<A>A(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for Slice,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))Slice<>.subscript.getter);
}

{
  return key path getter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A( a1,  a2,  a3,  (uint64_t (*)(void, void, void))type metadata accessor for Slice,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))Slice<>.subscript.getter);
}

uint64_t key path setter for Slice<>.subscript(_:) : <A>Slice<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + a3 - 16);
  uint64_t v6 = *(void *)(a4 + a3 - 8);
  uint64_t v8 = *(void *)(v6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v20 - v11;
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  MEMORY[0x1895F8858](v13);
  uint64_t v15 = (char *)&v20 - v14;
  (*(void (**)(char *, uint64_t))(v16 + 16))((char *)&v20 - v14, a3);
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))(v12, a1, AssociatedTypeWitness);
  uint64_t v18 = type metadata accessor for Slice(0LL, v7, v8, v17);
  return Slice<>.subscript.setter((uint64_t)v12, (uint64_t)v15, v18, v6);
}

uint64_t Slice<>.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v44 = a2;
  uint64_t v45 = a4;
  uint64_t v46 = a1;
  uint64_t v5 = *(const char **)(a4 + 8);
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v40 = a3;
  unint64_t v42 = v5;
  uint64_t v43 = v6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v12 = (char *)&v37 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v37 - v13;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v39 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v41 = *(void *)(v39 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v39);
  uint64_t v19 = (char *)&v37 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v38 = (char *)&v37 - v20;
  uint64_t v21 = v4 + *(int *)(a3 + 36);
  uint64_t v22 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v23 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v24 = (void (*)(char *))v23[2];
  v24(v14);
  ((void (*)(char *, uint64_t, unint64_t))v24)(v22, v21, AssociatedTypeWitness);
  uint64_t v25 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, unint64_t))v24)(v12, v14, AssociatedTypeWitness);
  ((void (*)(char *, char *, unint64_t))v24)(v25, v22, AssociatedTypeWitness);
  uint64_t v26 = (void (*)(char *, char *, unint64_t))v23[4];
  v26(v19, v12, AssociatedTypeWitness);
  uint64_t v27 = (void (*)(char *, unint64_t))v23[1];
  v27(v25, AssociatedTypeWitness);
  uint64_t v28 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  v26(v12, v14, AssociatedTypeWitness);
  v26(v28, v22, AssociatedTypeWitness);
  uint64_t v29 = v39;
  v26(&v19[*(int *)(v39 + 36)], v28, AssociatedTypeWitness);
  v27(v12, AssociatedTypeWitness);
  uint64_t v30 = v41;
  unint64_t v31 = v38;
  uint64_t v32 = v19;
  uint64_t v33 = v29;
  (*(void (**)(char *, char *, uint64_t))(v41 + 32))(v38, v32, v29);
  uint64_t v34 = v43;
  uint64_t v35 = v44;
  (*((void (**)(uint64_t, char *, uint64_t))v42 + 20))(v44, v31, v43);
  (*(void (**)(char *, uint64_t))(v30 + 8))(v31, v33);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v45 + 24))(v46, v35, v34);
}

void (*Slice<>.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x58uLL);
  *a1 = v9;
  v9[1] = a4;
  _OWORD v9[2] = v4;
  void *v9 = a3;
  uint64_t v10 = *(void *)(a4 + 8);
  uint64_t v11 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v10 + 8),  v11,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  v9[3] = AssociatedTypeWitness;
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  v9[4] = v13;
  size_t v14 = *(void *)(v13 + 64);
  void v9[5] = malloc(v14);
  uint64_t v15 = malloc(v14);
  v9[6] = v15;
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  v9[7] = v16;
  uint64_t v17 = *(void *)(v16 - 8);
  v9[8] = v17;
  size_t v18 = *(void *)(v17 + 64);
  v9[9] = malloc(v18);
  v9[10] = malloc(v18);
  (*(void (**)(void))(v17 + 16))();
  Slice<>.subscript.getter(a2, a3, a4, (uint64_t)v15);
  return Slice<>.subscript.modify;
}

void Slice<>.subscript.modify(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)(*a1)[9];
  uint64_t v4 = (void *)(*a1)[10];
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = v2[8];
    uint64_t v7 = (void *)v2[5];
    uint64_t v6 = (void *)v2[6];
    uint64_t v8 = v2[3];
    uint64_t v9 = v2[4];
    uint64_t v10 = v2[1];
    uint64_t v12 = v2[7];
    uint64_t v11 = *v2;
    (*(void (**)(void *, void *, uint64_t))(v9 + 16))(v7, v6, v8);
    (*(void (**)(void *, void *, uint64_t))(v5 + 32))(v3, v4, v12);
    Slice<>.subscript.setter((uint64_t)v7, (uint64_t)v3, v11, v10);
    (*(void (**)(void *, uint64_t))(v9 + 8))(v6, v8);
  }

  else
  {
    uint64_t v7 = (void *)v2[5];
    uint64_t v6 = (void *)v2[6];
    Slice<>.subscript.setter((uint64_t)v6, (uint64_t)v4, *v2, v2[1]);
  }

  free(v4);
  free(v3);
  free(v6);
  free(v7);
  free(v2);
}

uint64_t Slice<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v49 = a4;
  uint64_t v48 = a1;
  uint64_t v4 = *(const char **)(a3 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v44 = a2;
  uint64_t v46 = v4;
  uint64_t v47 = v5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v41 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v41 - v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v43 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  uint64_t v45 = *(void *)(v43 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v43);
  size_t v18 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v41 - v19;
  uint64_t v21 = v50 + *(int *)(a2 + 36);
  unint64_t v42 = TupleTypeMetadata2;
  uint64_t v22 = &v13[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v23 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v24 = (void (*)(char *))v23[2];
  v24(v13);
  ((void (*)(char *, uint64_t, unint64_t))v24)(v22, v21, AssociatedTypeWitness);
  uint64_t v25 = &v11[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, unint64_t))v24)(v11, v13, AssociatedTypeWitness);
  ((void (*)(char *, char *, unint64_t))v24)(v25, v22, AssociatedTypeWitness);
  uint64_t v26 = (void (*)(char *, char *, unint64_t))v23[4];
  v26(v18, v11, AssociatedTypeWitness);
  uint64_t v27 = (void (*)(char *, unint64_t))v23[1];
  v27(v25, AssociatedTypeWitness);
  uint64_t v28 = &v11[*((int *)v42 + 12)];
  v26(v11, v13, AssociatedTypeWitness);
  v26(v28, v22, AssociatedTypeWitness);
  uint64_t v29 = v43;
  v26(&v18[*(int *)(v43 + 36)], v28, AssociatedTypeWitness);
  v27(v11, AssociatedTypeWitness);
  uint64_t v30 = v45;
  uint64_t v31 = v29;
  (*(void (**)(char *, char *, uint64_t))(v45 + 32))(v20, v18, v29);
  uint64_t v32 = v44;
  uint64_t v33 = v50 + *(int *)(v44 + 40);
  uint64_t v34 = v47;
  uint64_t v35 = v48;
  (*((void (**)(uint64_t, char *, uint64_t))v46 + 22))(v48, v20, v47);
  uint64_t v36 = v30;
  (*(void (**)(char *, uint64_t))(v30 + 8))(v20, v31);
  uint64_t v37 = *(int *)(v32 + 40);
  uint64_t v38 = v32;
  uint64_t v39 = v49;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v34 - 8) + 16LL))(&v49[v37], v33, v34);
  (*(void (**)(char *, uint64_t, uint64_t))(v36 + 16))(v20, v35, v31);
  v26(v39, v20, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, unint64_t))v26)( &v39[*(int *)(v38 + 36)],  &v20[*(int *)(v31 + 36)],  AssociatedTypeWitness);
}

uint64_t key path getter for DiscontiguousSlice<>.subscript(_:) : <A>DiscontiguousSlice<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void, void), uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *(void *)(a3 + a2 - 8);
  uint64_t v8 = a4(0LL, *(void *)(a3 + a2 - 16), *(void *)(v7 + 8));
  return a5(a2, v8, v7);
}

uint64_t key path setter for Slice<>.subscript(_:) : <A>Slice<A>A( uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)&a3[a4 - 8];
  uint64_t v7 = type metadata accessor for Slice(0LL, *(void *)&a3[a4 - 16], *(void *)(v6 + 8), a4);
  return specialized Slice<>.subscript.setter(a1, a3, v7, v6);
}

uint64_t Slice<>.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(const char **)(a4 + 8);
  uint64_t v9 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  (*(void (**)(char *, uint64_t))(*(void *)(v13 - 8) + 8LL))(a2, v13);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
}

void (*Slice<>.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(void **a1, char a2)
{
  uint64_t v9 = malloc(0x60uLL);
  *a1 = v9;
  _OWORD v9[2] = a3;
  v9[3] = a4;
  uint64_t v10 = *(void *)(a3 - 8);
  v9[4] = v4;
  void v9[5] = v10;
  size_t v11 = *(void *)(v10 + 64);
  v9[6] = malloc(v11);
  uint64_t v12 = (char *)malloc(v11);
  v9[7] = v12;
  uint64_t v13 = *(const char **)(a4 + 8);
  uint64_t v14 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v13,  v14,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v18 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v17);
  v9[8] = v18;
  uint64_t v19 = *(void *)(v18 - 8);
  v9[9] = v19;
  size_t v20 = *(void *)(v19 + 64);
  v9[10] = malloc(v20);
  v9[11] = malloc(v20);
  (*(void (**)(void))(v19 + 16))();
  Slice<>.subscript.getter(a2, a3, a4, v12);
  return Slice<>.subscript.modify;
}

void Slice<>.subscript.modify(void **a1, char a2)
{
  uint64_t v2 = *a1;
  if ((a2 & 1) != 0)
  {
    uint64_t v4 = (char *)v2[10];
    uint64_t v3 = (char *)v2[11];
    uint64_t v5 = v2[8];
    uint64_t v6 = v2[9];
    uint64_t v8 = (void *)v2[6];
    uint64_t v7 = (void *)v2[7];
    uint64_t v9 = v2[5];
    uint64_t v23 = v2[4];
    uint64_t v10 = v2[2];
    uint64_t v11 = v2[3];
    (*(void (**)(void *, void *, uint64_t))(v9 + 16))(v8, v7, v10);
    (*(void (**)(char *, char *, uint64_t))(v6 + 32))(v4, v3, v5);
    void *v2 = v11;
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, v10, v2);
    uint64_t v14 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v10, v13);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v23, v4, (uint64_t)v8, v10, v10, WitnessTable, v14);
    (*(void (**)(char *, uint64_t))(v6 + 8))(v4, v5);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v9 + 8);
    v15(v8, v10);
    v15(v7, v10);
  }

  else
  {
    v2[1] = v2[3];
    uint64_t v4 = (char *)v2[10];
    uint64_t v3 = (char *)v2[11];
    uint64_t v16 = v2[9];
    uint64_t v24 = v2[8];
    uint64_t v8 = (void *)v2[6];
    uint64_t v7 = (void *)v2[7];
    uint64_t v18 = v2[4];
    uint64_t v17 = v2[5];
    uint64_t v19 = v2[2];
    uint64_t v20 = swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, v19, v2 + 1);
    uint64_t v22 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v19, v21);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v18, v3, (uint64_t)v7, v19, v19, v20, v22);
    (*(void (**)(char *, uint64_t))(v16 + 8))(v3, v24);
    (*(void (**)(void *, uint64_t))(v17 + 8))(v7, v19);
  }

  free(v3);
  free(v4);
  free(v7);
  free(v8);
  free(v2);
}

uint64_t Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  void (*v26)(uint64_t *__return_ptr, uint64_t (*)(), char *, void *, uint64_t, uint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30[16];
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v27 = a1;
  uint64_t v28 = a2;
  uint64_t v29 = a6;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v24 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v25 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v22 - v13;
  uint64_t v31 = v11;
  uint64_t v32 = a4;
  uint64_t v33 = a5;
  uint64_t v26 = *(void (**)(uint64_t *__return_ptr, uint64_t (*)(), char *, void *, uint64_t, uint64_t))(a5 + 80);
  v26(&v34, EnumeratedSequence._base.modify, v30, &unk_189B8D178, v11, a5);
  if (v34 == 1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))( v29,  1LL,  1LL,  a4);
  }
  (*(void (**)(uint64_t, uint64_t))(v10 + 64))(v11, v10);
  uint64_t v23 = a4;
  uint64_t v16 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 152);
  uint64_t v22 = v16(v14, (uint64_t)v6, v11, v10);
  (*(void (**)(char *, unint64_t))(v24 + 8))(v14, v25);
  uint64_t v17 = v16(v6, (uint64_t)&v6[*(int *)(a3 + 36)], v11, v10);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v20 = v22;
  uint64_t v19 = v23;
  *(&v22 - 8) = v11;
  *(&v22 - 7) = v19;
  *(&v22 - 6) = a5;
  *(&v22 - 5) = v20;
  uint64_t v21 = v27;
  *(&v22 - 4) = v18;
  *(&v22 - 3) = v21;
  *(&v22 - 2) = v28;
  return ((uint64_t (*)(void))v26)(partial apply for closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:));
}

void *closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)( uint64_t *a1, uint64_t a2, uint64_t a3, void (*a4)(void *), uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2 + a3;
  if (__OFADD__(a2, a3))
  {
    __break(1u);
LABEL_7:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (v8 < a2) {
    goto LABEL_7;
  }
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x265uLL,  0);
  }
  if (a1[1] < v8) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x266uLL,  0);
  }
  v18[3] = a7;
  uint64_t v11 = *a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a8 + 8) + 8LL),  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v14 = UnsafeMutableBufferPointer.init(rebasing:)(a2, v8, v11, v13, AssociatedTypeWitness);
  uint64_t v16 = v15;
  v18[0] = v14;
  v18[1] = v15;
  a4(v18);
  return $defer #1 <A><A1>() in closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)(v18, v14, v16);
}

uint64_t UnsafeMutableBufferPointer.subscript.getter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnsafeBufferPointer.subscript.getter(a1, a2, a3, a4, a5, 0x265uLL, 0x266uLL);
}

uint64_t UnsafeBufferPointer.subscript.getter( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  if (result < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a6,  0);
  }
  if (a4 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a7,  0);
  }
  return result;
}

uint64_t UnsafeMutableBufferPointer.init(rebasing:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t result = a3 + *(void *)(*(void *)(a5 - 8) + 72LL) * a1;
    uint64_t v8 = a2 - a1;
    BOOL v7 = v8 == 0;
    if (v8 >= 0) {
      goto LABEL_3;
    }
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  uint64_t result = 0LL;
  uint64_t v9 = a2 - a1;
  BOOL v7 = v9 == 0;
  if (v9 < 0) {
    goto LABEL_7;
  }
LABEL_3:
  if (!v7 && !result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
  }
  return result;
}

void *$defer #1 <A><A1>() in closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)( void *result, uint64_t a2, uint64_t a3)
{
  if (*result)
  {
    if (!a2 || *result != a2) {
LABEL_7:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Slice.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed",  82LL,  2,  "Swift/Slice.swift",  17LL,  2,  0x13AuLL,  0);
  }

  else if (a2)
  {
    goto LABEL_7;
  }

  if (result[1] != a3) {
    goto LABEL_7;
  }
  return result;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Slice<>.subscript.setter(a1, a2, a3, *(void *)(a4 - 8));
}

void (*protocol witness for MutableCollection.subscript.modify in conformance <> Slice<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x58uLL);
  *a1 = v9;
  void *v9 = v4;
  v9[1] = a3;
  uint64_t v10 = *(void *)(a4 - 8);
  _OWORD v9[2] = v10;
  uint64_t v11 = *(void *)(v10 + 8);
  uint64_t v12 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 8),  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  v9[3] = AssociatedTypeWitness;
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  v9[4] = v14;
  size_t v15 = *(void *)(v14 + 64);
  void v9[5] = malloc(v15);
  uint64_t v16 = malloc(v15);
  v9[6] = v16;
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  v9[7] = v17;
  uint64_t v18 = *(void *)(v17 - 8);
  v9[8] = v18;
  size_t v19 = *(void *)(v18 + 64);
  v9[9] = malloc(v19);
  v9[10] = malloc(v19);
  (*(void (**)(void))(v18 + 16))();
  Slice<>.subscript.getter(a2, a3, v10, (uint64_t)v16);
  return protocol witness for MutableCollection.subscript.modify in conformance <> Slice<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance <> Slice<A>( uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)(*a1)[9];
  uint64_t v4 = (void *)(*a1)[10];
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = v2[8];
    BOOL v7 = (void *)v2[5];
    uint64_t v6 = (void *)v2[6];
    uint64_t v8 = v2[3];
    uint64_t v9 = v2[4];
    uint64_t v10 = v2[1];
    uint64_t v11 = v2[2];
    uint64_t v12 = v2[7];
    (*(void (**)(void *, void *, uint64_t))(v9 + 16))(v7, v6, v8);
    (*(void (**)(void *, void *, uint64_t))(v5 + 32))(v3, v4, v12);
    Slice<>.subscript.setter((uint64_t)v7, (uint64_t)v3, v10, v11);
    (*(void (**)(void *, uint64_t))(v9 + 8))(v6, v8);
  }

  else
  {
    BOOL v7 = (void *)v2[5];
    uint64_t v6 = (void *)v2[6];
    Slice<>.subscript.setter((uint64_t)v6, (uint64_t)v4, v2[1], v2[2]);
  }

  free(v4);
  free(v3);
  free(v6);
  free(v7);
  free(v2);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance <> Slice<A>( uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 - 8);
  specialized Slice<>.subscript.setter(a1, a2, a3, v7);
  uint64_t v8 = *(const char **)(v7 + 8);
  uint64_t v9 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  (*(void (**)(char *, uint64_t))(*(void *)(v13 - 8) + 8LL))(a2, v13);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance <> Slice<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2, uint64_t a3)
{
  uint64_t v9 = malloc(0x50uLL);
  *a1 = v9;
  void *v9 = v4;
  v9[1] = a3;
  uint64_t v10 = *(void *)(a4 - 8);
  uint64_t v11 = *(void *)(a3 - 8);
  _OWORD v9[2] = a4;
  v9[3] = v11;
  size_t v12 = *(void *)(v11 + 64);
  v9[4] = malloc(v12);
  uint64_t v13 = (char *)malloc(v12);
  void v9[5] = v13;
  uint64_t v14 = *(const char **)(v10 + 8);
  uint64_t v15 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v14,  v15,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v14,  v15,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v19 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v18);
  v9[6] = v19;
  uint64_t v20 = *(void *)(v19 - 8);
  v9[7] = v20;
  size_t v21 = *(void *)(v20 + 64);
  v9[8] = malloc(v21);
  v9[9] = malloc(v21);
  (*(void (**)(void))(v20 + 16))();
  Slice<>.subscript.getter(a2, a3, v10, v13);
  return protocol witness for MutableCollection.subscript.modify in conformance <> Slice<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance <> Slice<A>( uint64_t **a1, char a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (char *)(*a1)[8];
  uint64_t v5 = (char *)(*a1)[9];
  uint64_t v6 = (*a1)[6];
  uint64_t v7 = (*a1)[7];
  uint64_t v8 = (void *)(*a1)[4];
  uint64_t v9 = (void *)(*a1)[5];
  uint64_t v10 = (*a1)[2];
  uint64_t v12 = **a1;
  uint64_t v11 = (*a1)[1];
  uint64_t v17 = (*a1)[3];
  if ((a2 & 1) != 0)
  {
    (*(void (**)(void *, void *, uint64_t))((*a1)[3] + 16))(v8, v9, v11);
    (*(void (**)(char *, char *, uint64_t))(v7 + 32))(v4, v5, v6);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v11, v13);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v12, v4, (uint64_t)v8, v11, v11, v10, WitnessTable);
    (*(void (**)(char *, uint64_t))(v7 + 8))(v4, v6);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v17 + 8);
    v15(v8, v11);
  }

  else
  {
    uint64_t v16 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v11, a3);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v12, v5, (uint64_t)v9, v11, v11, v10, v16);
    (*(void (**)(char *, uint64_t))(v7 + 8))(v5, v6);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v17 + 8);
  }

  v15(v9, v11);
  free(v5);
  free(v4);
  free(v9);
  free(v8);
  free(v3);
}

uint64_t protocol witness for MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:) in conformance <> Slice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a2, a4, a3, *(void *)(a5 - 8), a6);
}

uint64_t Slice<>.init()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void (**)(uint64_t, uint64_t))(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  type metadata accessor for Slice(0LL, a1, v7, a4);
  v6(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v7 + 64))(a1, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 72))(a1, v7);
}

uint64_t Slice<>.init(repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 48);
  uint64_t v9 = *(void *)(a4 + 8);
  type metadata accessor for Slice(0LL, a3, v9, a4);
  v8(a1, a2, a3, a4);
  (*(void (**)(uint64_t, uint64_t))(v9 + 64))(a3, v9);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 72))(a3, v9);
}

uint64_t Slice<>.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 56);
  uint64_t v11 = *(void *)(a4 + 8);
  type metadata accessor for Slice(0LL, a2, v11, a4);
  v10(a1, a3, a5, a2, a4);
  (*(void (**)(uint64_t, uint64_t))(v11 + 64))(a2, v11);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 72))(a2, v11);
}

uint64_t Slice<>.replaceSubrange<A>(_:with:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v47 = a6;
  uint64_t v49 = a2;
  uint64_t v50 = a4;
  uint64_t v41 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v42 = (char *)&v37 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v46 = v9;
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v48 = (char *)v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v43 = (char *)&v37 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v37 - v17;
  uint64_t v40 = *(void (**)(uint64_t, uint64_t))(v10 + 64);
  v40(v12, v10);
  uint64_t v19 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 152);
  uint64_t v38 = v19(v18, (uint64_t)v6, v12, v10);
  uint64_t v45 = v14;
  uint64_t v39 = *(void (**)(char *, unint64_t))(v14 + 8);
  v39(v18, AssociatedTypeWitness);
  uint64_t v20 = v19(v6, a1, v12, v10);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v10,  v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v23 = *(int *)(type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v22) + 36);
  uint64_t v44 = a1;
  uint64_t v24 = (char *)(a1 + v23);
  unint64_t v25 = v6;
  uint64_t v26 = &v6[*((int *)v48 + 9)];
  uint64_t result = v19(v24, (uint64_t)v26, v12, v10);
  BOOL v28 = __OFADD__(v20, result);
  uint64_t v29 = v20 + result;
  if (v28)
  {
    __break(1u);
  }

  else
  {
    uint64_t v48 = v26;
    uint64_t v30 = v47;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v47 + 112))(v50, v47);
    uint64_t v31 = v29 + result;
    if (!__OFADD__(v29, result))
    {
      uint64_t v32 = v42;
      uint64_t v33 = v50;
      (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v42, v49, v50);
      (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(v46 + 32))(v44, v32, v33, v30, v12);
      uint64_t v34 = v43;
      v40(v12, v10);
      uint64_t v35 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 136);
      v35(v34, v38, v12, v10);
      v39(v34, AssociatedTypeWitness);
      uint64_t v36 = *(void (**)(uint64_t, char *, unint64_t))(v45 + 40);
      v36((uint64_t)v25, v18, AssociatedTypeWitness);
      v35(v25, v31, v12, v10);
      return ((uint64_t (*)(char *, char *, unint64_t))v36)(v48, v18, AssociatedTypeWitness);
    }
  }

  __break(1u);
  return result;
}

uint64_t Slice<>.insert(_:at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v34 = a1;
  uint64_t v35 = a2;
  uint64_t v36 = a4;
  uint64_t v37 = a3;
  uint64_t v5 = *(void *)(a4 + 8);
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v5 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v30 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v31 = (char *)&v26 - v7;
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v26 - v13;
  uint64_t v29 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  v29(v6, v5);
  uint64_t v15 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v5 + 152);
  uint64_t v28 = v15(v14, v4, v6, v5);
  uint64_t v16 = *(void (**)(char *, unint64_t))(v9 + 8);
  v16(v14, v8);
  uint64_t v33 = v9;
  uint64_t v17 = *(void (**)(char *, uint64_t, unint64_t))(v9 + 16);
  v17(v14, v4, v8);
  uint64_t v18 = *(int *)(v37 + 36);
  uint64_t v37 = v4;
  uint64_t v27 = v4 + v18;
  ((void (*)(char *))v17)(v12);
  uint64_t v19 = v15(v14, (uint64_t)v12, v6, v5);
  v16(v12, v8);
  uint64_t result = ((uint64_t (*)(char *, unint64_t))v16)(v14, v8);
  uint64_t v21 = v19 + 1;
  if (__OFADD__(v19, 1LL))
  {
    __break(1u);
  }

  else
  {
    uint64_t v22 = v31;
    (*(void (**)(char *, uint64_t, unint64_t))(v30 + 16))(v31, v34, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v36 + 80))(v22, v35, v6);
    v29(v6, v5);
    uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v5 + 136);
    v23(v12, v28, v6, v5);
    v16(v12, v8);
    uint64_t v24 = *(void (**)(uint64_t, char *, unint64_t))(v33 + 40);
    unint64_t v25 = (char *)v37;
    v24(v37, v14, v8);
    v23(v25, v21, v6, v5);
    return ((uint64_t (*)(uint64_t, char *, unint64_t))v24)(v27, v14, v8);
  }

  return result;
}

uint64_t Slice<>.insert<A>(contentsOf:at:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = v6;
  uint64_t v47 = a4;
  uint64_t v48 = a6;
  uint64_t v42 = a2;
  uint64_t v49 = a1;
  uint64_t v40 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v41 = (char *)&v36 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v44 = v9;
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v46 = v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v36 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v36 - v18;
  uint64_t v38 = *(void (**)(uint64_t, uint64_t))(v10 + 64);
  v38(v12, v10);
  uint64_t v45 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 152);
  uint64_t v36 = v45(v19, v6, v12, v10);
  uint64_t v20 = *(void (**)(char *, unint64_t))(v14 + 8);
  v20(v19, AssociatedTypeWitness);
  uint64_t v43 = v14;
  uint64_t v21 = *(void (**)(char *, uint64_t, unint64_t))(v14 + 16);
  v21(v19, v7, AssociatedTypeWitness);
  uint64_t v22 = *(int *)(v46 + 36);
  uint64_t v46 = v7;
  uint64_t v23 = v7 + v22;
  uint64_t v24 = v47;
  uint64_t v39 = v23;
  ((void (*)(char *))v21)(v17);
  uint64_t v37 = v12;
  uint64_t v25 = v45(v19, (uint64_t)v17, v12, v10);
  uint64_t v26 = v48;
  uint64_t v27 = v25;
  v20(v17, AssociatedTypeWitness);
  uint64_t v45 = (uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v20;
  v20(v19, AssociatedTypeWitness);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 112))(v24, v26);
  BOOL v29 = __OFADD__(v27, result);
  uint64_t v30 = v27 + result;
  if (v29)
  {
    __break(1u);
  }

  else
  {
    uint64_t v31 = v41;
    (*(void (**)(char *, uint64_t, uint64_t))(v40 + 16))(v41, v49, v24);
    uint64_t v32 = v37;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v44 + 88))(v31, v42, v24, v26, v37);
    v38(v32, v10);
    uint64_t v33 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 136);
    v33(v17, v36, v32, v10);
    ((void (*)(char *, unint64_t))v45)(v17, AssociatedTypeWitness);
    uint64_t v34 = *(void (**)(uint64_t, char *, unint64_t))(v43 + 40);
    uint64_t v35 = (char *)v46;
    v34(v46, v19, AssociatedTypeWitness);
    v33(v35, v30, v32, v10);
    return ((uint64_t (*)(uint64_t, char *, unint64_t))v34)(v39, v19, AssociatedTypeWitness);
  }

  return result;
}

uint64_t Slice<>.remove(at:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v29 = a4;
  uint64_t v30 = a1;
  uint64_t v31 = a3;
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v6 = *((void *)a2 + 2);
  uint64_t v33 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v26 - v12;
  uint64_t v28 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  v28(v6, v5);
  uint64_t v14 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v5 + 152);
  uint64_t v27 = v14(v13, v4, v6, v5);
  uint64_t v15 = *(void (**)(char *, unint64_t))(v8 + 8);
  v15(v13, AssociatedTypeWitness);
  uint64_t v32 = v8;
  uint64_t v16 = *(void (**)(char *, char *, unint64_t))(v8 + 16);
  v16(v13, v4, AssociatedTypeWitness);
  uint64_t v17 = *((int *)v33 + 9);
  uint64_t v33 = v4;
  uint64_t v18 = &v4[v17];
  v16(v11, &v4[v17], AssociatedTypeWitness);
  uint64_t v19 = v14(v13, v11, v6, v5);
  v15(v11, AssociatedTypeWitness);
  uint64_t result = ((uint64_t (*)(char *, unint64_t))v15)(v13, AssociatedTypeWitness);
  BOOL v21 = __OFSUB__(v19, 1LL);
  uint64_t v22 = v19 - 1;
  if (v21)
  {
    __break(1u);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t))(v31 + 96))(v30, v6);
    v28(v6, v5);
    uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v5 + 136);
    v23(v11, v27, v6, v5);
    v15(v11, AssociatedTypeWitness);
    uint64_t v24 = v33;
    uint64_t v25 = *(void (**)(char *, char *, unint64_t))(v32 + 40);
    v25(v33, v13, AssociatedTypeWitness);
    v23(v24, v22, v6, v5);
    return ((uint64_t (*)(char *, char *, unint64_t))v25)(v18, v13, AssociatedTypeWitness);
  }

  return result;
}

uint64_t Slice<>.removeSubrange(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v38 = a1;
  uint64_t v34 = a3;
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v29 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v29 - v12;
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  v33(v6, v5);
  uint64_t v37 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v5 + 152);
  uint64_t v31 = v37(v13, v3, v6, v5);
  uint64_t v14 = *(void (**)(char *, unint64_t))(v8 + 8);
  v14(v13, AssociatedTypeWitness);
  uint64_t v35 = v8;
  uint64_t v15 = *(void (**)(char *, char *, unint64_t))(v8 + 16);
  v15(v13, v3, AssociatedTypeWitness);
  uint64_t v16 = *(int *)(a2 + 36);
  uint64_t v36 = v3;
  uint64_t v30 = &v3[v16];
  ((void (*)(char *))v15)(v11);
  uint64_t v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v37;
  uint64_t v17 = v38;
  uint64_t v19 = v37(v13, v11, v6, v5);
  v14(v11, AssociatedTypeWitness);
  uint64_t v32 = v14;
  v14(v13, AssociatedTypeWitness);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v22 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v21);
  uint64_t result = v18(v17, v17 + *(int *)(v22 + 36), v6, v5);
  BOOL v24 = __OFSUB__(v19, result);
  uint64_t v25 = v19 - result;
  if (v24)
  {
    __break(1u);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t))(v34 + 104))(v17, v6);
    v33(v6, v5);
    uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v5 + 136);
    v26(v11, v31, v6, v5);
    v32(v11, AssociatedTypeWitness);
    uint64_t v27 = v36;
    uint64_t v28 = *(void (**)(char *, char *, unint64_t))(v35 + 40);
    v28(v36, v13, AssociatedTypeWitness);
    v26(v27, v25, v6, v5);
    return ((uint64_t (*)(char *, char *, unint64_t))v28)(v30, v13, AssociatedTypeWitness);
  }

  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init() in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Slice<>.init()(*(void *)(a1 + 16), *(void *)(a2 - 8), a3, a4);
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Slice<>.init(repeating:count:)(a1, a2, *(void *)(a3 + 16), *(void *)(a4 - 8));
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return Slice<>.init<A>(_:)(a1, *(void *)(a4 + 16), a2, *(void *)(a5 - 8), a3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a4 - 8);
  Slice<>.insert(_:at:)(a1, a2, a3, v6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(v6 + 8) + 8LL),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( a1,  AssociatedTypeWitness);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance <> Slice<A>@<X0>( uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Slice<>.remove(at:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance <> Slice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Slice<>.removeSubrange(_:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t Slice<>.replaceSubrange<A>(_:with:)( _BYTE *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v76 = a4;
  uint64_t v77 = a7;
  uint64_t v72 = a6;
  uint64_t v75 = a2;
  uint64_t v69 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v70 = &v65[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v79 = v11;
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v13 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v74 = &v65[-((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = &v65[-v19];
  uint64_t v78 = a3;
  uint64_t v80 = v7;
  uint64_t v67 = *(void (**)(uint64_t, uint64_t))(v12 + 64);
  v67(v14, v12);
  uint64_t v68 = v12;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v12,  v14,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v22 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v23 = *(uint64_t (**)(_BYTE *, _BYTE *, unint64_t, uint64_t))(v22 + 8);
  char v24 = v23(a1, v20, AssociatedTypeWitness, v22);
  uint64_t v73 = v16;
  uint64_t v25 = *(void (**)(uint64_t, uint64_t))(v16 + 8);
  uint64_t v71 = v20;
  v25((uint64_t)v20, AssociatedTypeWitness);
  if ((v24 & 1) != 0)
  {
    uint64_t v26 = v79;
    uint64_t v27 = v80;
    uint64_t v28 = *(uint64_t (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(v79 + 64);
    uint64_t v29 = v28((uint64_t)v80, a1, v14, v79);
    uint64_t v31 = *(int *)(type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v30) + 36);
    uint64_t v74 = a1;
    uint64_t v32 = &v27[*((int *)v78 + 9)];
    uint64_t v33 = v14;
    uint64_t result = v28((uint64_t)&a1[v31], v32, v14, v26);
    uint64_t v35 = v29 + result;
    if (__OFADD__(v29, result))
    {
      __break(1u);
    }

    else
    {
      uint64_t v78 = v32;
      uint64_t v36 = v76;
      uint64_t v37 = v77;
      uint64_t v38 = v75;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v77 + 112))(v76, v77);
      uint64_t v39 = v35 + result;
      if (!__OFADD__(v35, result))
      {
        uint64_t v40 = v70;
        (*(void (**)(_BYTE *, uint64_t, uint64_t))(v69 + 16))(v70, v38, v36);
        uint64_t v41 = v40;
        uint64_t v42 = v33;
        (*(void (**)(_BYTE *, _BYTE *, uint64_t, uint64_t, uint64_t))(v72 + 32))(v74, v41, v36, v37, v33);
        uint64_t v43 = v71;
        v67(v33, v68);
        uint64_t v44 = *(void (**)(uint64_t, _BYTE *, unint64_t))(v73 + 40);
        uint64_t v45 = v80;
        v44((uint64_t)v80, v43, AssociatedTypeWitness);
        (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v26 + 48))(v45, v39, v42, v26);
        return ((uint64_t (*)(_BYTE *, _BYTE *, unint64_t))v44)(v78, v43, AssociatedTypeWitness);
      }
    }

    __break(1u);
    goto LABEL_13;
  }

  uint64_t v67 = v25;
  uint64_t v46 = v80;
  int v66 = v23(a1, v80, AssociatedTypeWitness, v22);
  uint64_t v47 = v79;
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v79 + 32))(a1, v14, v79);
  uint64_t v49 = &a1[*(int *)(type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v48) + 36)];
  uint64_t v50 = *(uint64_t (**)(_BYTE *))(v47 + 64);
  uint64_t v78 = &v46[*((int *)v78 + 9)];
  uint64_t v51 = v14;
  uint64_t v52 = v50(v49);
  uint64_t v54 = v76;
  uint64_t v53 = v77;
  uint64_t v55 = v75;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v77 + 112))(v76, v77);
  uint64_t v56 = v52 + result;
  if (__OFADD__(v52, result))
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v57 = v56 + 1;
  if (__OFADD__(v56, 1LL))
  {
LABEL_14:
    __break(1u);
    return result;
  }

  uint64_t v58 = v53;
  uint64_t v59 = v70;
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v69 + 16))(v70, v55, v54);
  uint64_t v60 = v58;
  uint64_t v61 = v51;
  (*(void (**)(_BYTE *, _BYTE *, uint64_t, uint64_t, uint64_t))(v72 + 32))(a1, v59, v54, v60, v51);
  uint64_t v63 = v73;
  uint64_t v62 = v74;
  uint64_t v64 = v71;
  if ((v66 & 1) != 0)
  {
    (*(void (**)(_BYTE *, uint64_t))(v68 + 184))(v74, v61);
    (*(void (**)(_BYTE *, _BYTE *, unint64_t))(v63 + 40))(v80, v64, AssociatedTypeWitness);
  }

  (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v47 + 48))(v62, v57, v61, v47);
  v67((uint64_t)v62, AssociatedTypeWitness);
  return (*(uint64_t (**)(_BYTE *, _BYTE *, unint64_t))(v63 + 40))(v78, v64, AssociatedTypeWitness);
}

uint64_t Slice<>.insert(_:at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = a1;
  uint64_t v47 = a5;
  uint64_t v52 = a2;
  uint64_t v48 = a4;
  uint64_t v7 = *(void *)(a4 + 8);
  uint64_t v8 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v43 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v44 = (char *)&v40 - v9;
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v40 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v40 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v40 - v18;
  uint64_t v49 = a3;
  uint64_t v50 = v5;
  uint64_t v20 = *(void (**)(uint64_t, uint64_t))(v7 + 64);
  uint64_t v53 = &v5[*(int *)(a3 + 40)];
  uint64_t v42 = v20;
  v20(v8, v7);
  uint64_t v21 = *(void *)(swift_getAssociatedConformanceWitness( v7,  v8,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v22 = *(uint64_t (**)(uint64_t, char *, unint64_t, uint64_t))(v21 + 8);
  char v23 = v22(v52, v19, v10, v21);
  uint64_t v51 = v11;
  char v24 = *(void (**)(char *, unint64_t))(v11 + 8);
  v24(v19, v10);
  if ((v23 & 1) != 0)
  {
    uint64_t v25 = v50;
    uint64_t v26 = *(void (**)(char *, uint64_t, unint64_t))(v51 + 16);
    v26(v19, (uint64_t)v50, v10);
    uint64_t v27 = &v25[*(int *)(v49 + 36)];
    v26(v17, (uint64_t)v27, v10);
    uint64_t v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v7 + 152))(v19, v17, v8, v7);
    v24(v17, v10);
    uint64_t result = ((uint64_t (*)(char *, unint64_t))v24)(v19, v10);
    uint64_t v30 = v28 + 1;
    if (!__OFADD__(v28, 1LL))
    {
      uint64_t v31 = v44;
      (*(void (**)(char *, uint64_t, unint64_t))(v43 + 16))(v44, v46, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t))(v47 + 80))(v31, v52, v8);
      v42(v8, v7);
      uint64_t v32 = v50;
      uint64_t v33 = *(void (**)(uint64_t, char *, unint64_t))(v51 + 40);
      v33((uint64_t)v50, v19, v10);
      (*(void (**)(char *, uint64_t, uint64_t))(v48 + 48))(v32, v30, v8);
      return ((uint64_t (*)(char *, char *, unint64_t))v33)(v27, v19, v10);
    }

    __break(1u);
    goto LABEL_10;
  }

  uint64_t v42 = (void (*)(uint64_t, uint64_t))v24;
  uint64_t v40 = v7;
  uint64_t v34 = v52;
  uint64_t v35 = v50;
  int v41 = v22(v52, v50, v10, v21);
  uint64_t v36 = v48;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v48 + 32))(v34, v8, v48);
  uint64_t v37 = &v35[*(int *)(v49 + 36)];
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v36 + 64))(v34, v37, v8, v36);
  uint64_t v38 = result + 2;
  if (__OFADD__(result, 2LL))
  {
LABEL_10:
    __break(1u);
    return result;
  }

  uint64_t v39 = v44;
  (*(void (**)(char *, uint64_t, unint64_t))(v43 + 16))(v44, v46, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 80))(v39, v52, v8);
  if ((v41 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v40 + 184))(v14, v8);
    (*(void (**)(char *, char *, unint64_t))(v51 + 40))(v35, v19, v10);
  }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v36 + 48))(v14, v38, v8, v36);
  v42((uint64_t)v14, v10);
  return (*(uint64_t (**)(char *, char *, unint64_t))(v51 + 40))(v37, v19, v10);
}

uint64_t Slice<>.insert<A>(contentsOf:at:)( uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v77 = a4;
  uint64_t v78 = a7;
  uint64_t v69 = a6;
  uint64_t v73 = a1;
  uint64_t v67 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v68 = (char *)&v63 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v71 = v11;
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v13 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v70 = (char *)&v63 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v63 - v20;
  MEMORY[0x1895F8858](v19);
  char v23 = (char *)&v63 - v22;
  uint64_t v72 = a3;
  uint64_t v24 = *((int *)a3 + 10);
  uint64_t v74 = v7;
  uint64_t v25 = *(void (**)(uint64_t, uint64_t))(v12 + 64);
  uint64_t v75 = &v7[v24];
  int v66 = v25;
  v25(v14, v12);
  uint64_t v76 = v14;
  uint64_t v26 = *(void *)(swift_getAssociatedConformanceWitness( v12,  v14,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  uint64_t v27 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v26 + 8);
  uint64_t v28 = a2;
  char v29 = v27(a2, v23, AssociatedTypeWitness, v26);
  uint64_t v30 = v16;
  uint64_t v31 = *(void (**)(char *, unint64_t))(v16 + 8);
  v31(v23, AssociatedTypeWitness);
  if ((v29 & 1) != 0)
  {
    uint64_t v70 = v28;
    uint64_t v32 = v30;
    uint64_t v33 = *(void (**)(char *, uint64_t, unint64_t))(v30 + 16);
    uint64_t v34 = v74;
    v33(v23, (uint64_t)v74, AssociatedTypeWitness);
    uint64_t v72 = &v34[*((int *)v72 + 9)];
    ((void (*)(char *))v33)(v21);
    uint64_t v35 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v12 + 152))(v23, v21, v76, v12);
    v31(v21, AssociatedTypeWitness);
    v31(v23, AssociatedTypeWitness);
    uint64_t v36 = v73;
    uint64_t result = (*(uint64_t (**)(uint64_t))(v78 + 112))(v77);
    uint64_t v38 = v35 + result;
    if (!__OFADD__(v35, result))
    {
      uint64_t v39 = v34;
      uint64_t v40 = v32;
      int v41 = v68;
      uint64_t v42 = v77;
      (*(void (**)(char *, uint64_t, uint64_t))(v67 + 16))(v68, v36, v77);
      uint64_t v43 = v41;
      uint64_t v44 = v76;
      (*(void (**)(char *, char *, uint64_t, uint64_t, uint64_t))(v69 + 88))(v43, v70, v42, v78, v76);
      v66(v44, v12);
      uint64_t v45 = *(void (**)(uint64_t, char *, unint64_t))(v40 + 40);
      v45((uint64_t)v39, v23, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t))(v71 + 48))(v39, v38, v44);
      return ((uint64_t (*)(char *, char *, unint64_t))v45)(v72, v23, AssociatedTypeWitness);
    }

    __break(1u);
    goto LABEL_11;
  }

  uint64_t v65 = v31;
  int v66 = (void (*)(uint64_t, uint64_t))v30;
  uint64_t v63 = v12;
  uint64_t v46 = v74;
  int v64 = v27(v28, v74, AssociatedTypeWitness, v26);
  uint64_t v47 = v71;
  uint64_t v48 = v76;
  (*(void (**)(char *, uint64_t, uint64_t))(v71 + 32))(v28, v76, v71);
  uint64_t v49 = *(uint64_t (**)(char *))(v47 + 64);
  uint64_t v50 = v28;
  uint64_t v72 = &v46[*((int *)v72 + 9)];
  uint64_t v51 = v48;
  uint64_t v52 = v49(v28);
  uint64_t v53 = v77;
  uint64_t v54 = v78;
  uint64_t v55 = v73;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v78 + 112))(v77, v78);
  uint64_t v56 = v52 + result;
  if (__OFADD__(v52, result))
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }

  uint64_t v57 = v56 + 1;
  if (__OFADD__(v56, 1LL))
  {
LABEL_12:
    __break(1u);
    return result;
  }

  uint64_t v58 = v54;
  uint64_t v59 = v53;
  uint64_t v60 = v68;
  (*(void (**)(char *, uint64_t, uint64_t))(v67 + 16))(v68, v55, v59);
  (*(void (**)(char *, char *, uint64_t, uint64_t, uint64_t))(v69 + 88))(v60, v50, v59, v58, v51);
  uint64_t v61 = v66;
  uint64_t v62 = v70;
  if ((v64 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v63 + 184))(v70, v51);
    (*((void (**)(char *, char *, unint64_t))v61 + 5))(v74, v23, AssociatedTypeWitness);
  }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v47 + 48))(v62, v57, v51, v47);
  v65(v62, AssociatedTypeWitness);
  return (*((uint64_t (**)(char *, char *, unint64_t))v61 + 5))(v72, v23, AssociatedTypeWitness);
}

uint64_t Slice<>.remove(at:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v54 = a4;
  uint64_t v50 = a3;
  uint64_t v51 = a5;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v48 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v49 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v55 = (char *)&v44 - v11;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = *(char **)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v56 = (char *)&v44 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v47 = (char *)&v44 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v44 - v18;
  uint64_t v20 = *(int *)(a2 + 40);
  uint64_t v57 = v5;
  uint64_t v21 = *(void (**)(uint64_t, uint64_t))(v8 + 64);
  uint64_t v52 = a2;
  uint64_t v53 = &v5[v20];
  uint64_t v46 = v21;
  v21(v9, v8);
  uint64_t v22 = *(void *)(swift_getAssociatedConformanceWitness( v8,  v9,  v12,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                  + 8);
  char v23 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v22 + 8);
  uint64_t v24 = a1;
  char v25 = v23(a1, v19, v12, v22);
  uint64_t v26 = v13;
  uint64_t v27 = (void (*)(char *, unint64_t))*((void *)v13 + 1);
  v27(v19, v12);
  if ((v25 & 1) != 0)
  {
    uint64_t v56 = v24;
    uint64_t v28 = v54;
    char v29 = v26;
    uint64_t v30 = (void (*)(char *, uint64_t, unint64_t))*((void *)v26 + 2);
    uint64_t v31 = v57;
    v30(v19, (uint64_t)v57, v12);
    uint64_t v32 = v47;
    uint64_t v55 = &v31[*(int *)(v52 + 36)];
    ((void (*)(char *))v30)(v47);
    uint64_t v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v8 + 152))(v19, v32, v9, v8);
    v27(v32, v12);
    uint64_t result = ((uint64_t (*)(char *, unint64_t))v27)(v19, v12);
    uint64_t v35 = v33 - 1;
    if (__OFSUB__(v33, 1LL))
    {
      __break(1u);
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v28 + 96))(v56, v9, v28);
      v46(v9, v8);
      uint64_t v36 = (void (*)(uint64_t, char *, unint64_t))*((void *)v29 + 5);
      uint64_t v37 = v57;
      v36((uint64_t)v57, v19, v12);
      (*(void (**)(char *, uint64_t, uint64_t))(v50 + 48))(v37, v35, v9);
      return ((uint64_t (*)(char *, char *, unint64_t))v36)(v55, v19, v12);
    }
  }

  else
  {
    uint64_t v45 = v8;
    uint64_t v46 = (void (*)(uint64_t, uint64_t))v27;
    uint64_t v47 = v26;
    uint64_t v38 = v57;
    char v39 = v23(v24, v57, v12, v22);
    uint64_t v40 = v50;
    (*(void (**)(char *, uint64_t, uint64_t))(v50 + 32))(v24, v9, v50);
    int v41 = &v38[*(int *)(v52 + 36)];
    uint64_t v42 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v40 + 64))(v24, v41, v9, v40);
    (*(void (**)(char *, uint64_t))(v54 + 96))(v24, v9);
    if ((v39 & 1) != 0)
    {
      (*(void (**)(char *, uint64_t))(v45 + 184))(v56, v9);
      (*((void (**)(char *, char *, unint64_t))v47 + 5))(v57, v19, v12);
    }

    uint64_t v43 = v56;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v40 + 48))(v56, v42, v9, v40);
    v46((uint64_t)v43, v12);
    (*((void (**)(char *, char *, unint64_t))v47 + 5))(v41, v19, v12);
    return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v48 + 32))(v51, v55, v49);
  }

  return result;
}

uint64_t Slice<>.removeSubrange(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v49 = a4;
  uint64_t v54 = a3;
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v46 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v46 - v14;
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v46 - v16;
  uint64_t v18 = *(int *)(a2 + 40);
  uint64_t v55 = v4;
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v7 + 64);
  uint64_t v52 = (char *)a2;
  uint64_t v53 = &v4[v18];
  uint64_t v48 = v19;
  v19(v8, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v20 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v21 = *(uint64_t (**)(uint64_t, char *, unint64_t, uint64_t))(v20 + 8);
  uint64_t v57 = a1;
  char v22 = v21(a1, v17, AssociatedTypeWitness, v20);
  uint64_t v56 = v10;
  char v23 = *(void (**)(char *, unint64_t))(v10 + 8);
  v23(v17, AssociatedTypeWitness);
  if ((v22 & 1) != 0)
  {
    uint64_t v24 = v55;
    char v25 = *(void (**)(char *, uint64_t, unint64_t))(v56 + 16);
    v25(v17, (uint64_t)v55, AssociatedTypeWitness);
    uint64_t v26 = &v24[*((int *)v52 + 9)];
    v25(v15, (uint64_t)v26, AssociatedTypeWitness);
    uint64_t v27 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v7 + 152))(v17, v15, v8, v7);
    v23(v15, AssociatedTypeWitness);
    v23(v17, AssociatedTypeWitness);
    uint64_t v29 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v28);
    uint64_t v30 = v54;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v54 + 64))( v57,  v57 + *(int *)(v29 + 36),  v8,  v54);
    uint64_t v32 = v27 - result;
    if (!__OFSUB__(v27, result))
    {
      (*(void (**)(uint64_t, uint64_t))(v49 + 104))(v57, v8);
      v48(v8, v7);
      uint64_t v33 = *(void (**)(uint64_t, char *, unint64_t))(v56 + 40);
      v33((uint64_t)v24, v17, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v30 + 48))(v24, v32, v8, v30);
      return ((uint64_t (*)(char *, char *, unint64_t))v33)(v26, v17, AssociatedTypeWitness);
    }

    __break(1u);
    goto LABEL_11;
  }

  uint64_t v48 = (void (*)(uint64_t, uint64_t))v23;
  uint64_t v46 = v7;
  uint64_t v34 = v57;
  uint64_t v35 = v55;
  int v47 = v21(v57, v55, AssociatedTypeWitness, v20);
  uint64_t v36 = v54;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v54 + 32))(v34, v8, v54);
  uint64_t v37 = *(uint64_t (**)(uint64_t))(v36 + 64);
  uint64_t v52 = &v35[*((int *)v52 + 9)];
  uint64_t v38 = v37(v34);
  uint64_t v40 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v39);
  uint64_t v41 = v36;
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v37)(v34, v34 + *(int *)(v40 + 36), v8, v36);
  uint64_t v42 = v38 - result;
  if (__OFSUB__(v38, result))
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }

  uint64_t v43 = v42 + 1;
  if (__OFADD__(v42, 1LL))
  {
LABEL_12:
    __break(1u);
    return result;
  }

  (*(void (**)(uint64_t, uint64_t))(v49 + 104))(v34, v8);
  uint64_t v44 = v56;
  uint64_t v45 = v50;
  if ((v47 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v46 + 184))(v50, v8);
    (*(void (**)(char *, char *, unint64_t))(v44 + 40))(v55, v17, AssociatedTypeWitness);
  }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v41 + 48))(v45, v43, v8, v41);
  v48((uint64_t)v45, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, char *, unint64_t))(v44 + 40))(v52, v17, AssociatedTypeWitness);
}

uint64_t (*_SmallString._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*_SmallString.leadingRawBits.modify(void *a1))()
{
  *a1 = *v1;
  a1[1] = v1;
  return _SmallString.leadingRawBits.modify;
}

uint64_t (*_SmallString.trailingRawBits.modify(void *a1))()
{
  *a1 = *(void *)(v1 + 8);
  a1[1] = v1;
  return _SmallString.trailingRawBits.modify;
}

uint64_t _SmallString.init(_:)(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t _StringObject.isSmall.getter(uint64_t a1, unint64_t a2)
{
  return (a2 >> 61) & 1;
}

uint64_t _SmallString.init()()
{
  return 0LL;
}

uint64_t _StringObject.init(empty:)()
{
  return 0LL;
}

uint64_t static _SmallString.capacity.getter()
{
  return 15LL;
}

uint64_t _SmallString.capacity.getter()
{
  return 15LL;
}

uint64_t _SmallString.count.getter(uint64_t a1, unint64_t a2)
{
  return HIBYTE(a2) & 0xF;
}

uint64_t static _StringObject.getSmallCount(fromRaw:)(unint64_t a1)
{
  return HIBYTE(a1) & 0xF;
}

uint64_t _SmallString.unusedCapacity.getter(uint64_t a1, unint64_t a2)
{
  return ~HIBYTE(a2) & 0xF;
}

uint64_t _SmallString.isASCII.getter(uint64_t a1, unint64_t a2)
{
  return (a2 >> 62) & 1;
}

uint64_t static _StringObject.getSmallIsASCII(fromRaw:)(unint64_t a1)
{
  return (a1 >> 62) & 1;
}

  ;
}

uint64_t _SmallString.endIndex.getter(uint64_t a1, unint64_t a2)
{
  return HIBYTE(a2) & 0xF;
}

unint64_t _SmallString.subscript.getter(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a1 >= 8) {
    a2 = a3;
  }
  return a2 >> (8 * (a1 & 7u));
}

uint64_t key path getter for _SmallString.subscript(_:) : _SmallString@<X0>( uint64_t result@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *(void *)(result + 8LL * (*a2 > 7LL)) >> (8 * (*a2 & 7u));
  return result;
}

unsigned __int8 *key path setter for _SmallString.subscript(_:) : _SmallString( unsigned __int8 *result, uint64_t a2, void *a3)
{
  *(void *)(a2 + 8LL * (*a3 > 7LL)) = *(void *)(a2 + 8LL * (*a3 > 7LL)) & ((-255LL << (8
  return result;
}

uint64_t _SmallString.subscript.setter(uint64_t result, uint64_t a2)
{
  *(void *)(v2 + 8LL * (a2 > 7)) = *(void *)(v2 + 8LL * (a2 > 7)) & ((-255LL << (8 * (a2 & 7u))) - 1) | ((unint64_t)result << (8 * (a2 & 7u)));
  return result;
}

Swift::UInt8 __swiftcall UInt64._uncheckedGetByte(at:)(Swift::Int at)
{
  return v1 >> (8 * (at & 7u));
}

Swift::Void __swiftcall UInt64._uncheckedSetByte(at:to:)(Swift::Int at, Swift::UInt8 to)
{
  unint64_t *v2 = *v2 & ((-255LL << (8 * (at & 7u))) - 1) | ((unint64_t)to << (8
                                                                                           * (at & 7u)));
}

uint64_t (*_SmallString.subscript.modify(uint64_t a1, uint64_t a2))(uint64_t result)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  if (a2 >= 8) {
    uint64_t result = _SmallString.subscript.modify;
  }
  else {
    uint64_t result = _SmallString.subscript.modify;
  }
  *(_BYTE *)(a1 + 16) = *(void *)(v2 + 8LL * (a2 > 7)) >> (8 * (a2 & 7u));
  return result;
}

uint64_t _SmallString.subscript.modify(uint64_t result)
{
  **(void **)(result + 8) = ((-255LL << (8 * (*(_DWORD *)result & 7u))) - 1) & **(void **)(result + 8) | ((unint64_t)*(unsigned __int8 *)(result + 16) << (8 * (*(_DWORD *)result & 7u)));
  return result;
}

{
  *(void *)(*(void *)(result + 8) + 8LL) = ((-255LL << (8 * (*(_DWORD *)result & 7u))) - 1) & *(void *)(*(void *)(result + 8) + 8LL) | ((unint64_t)*(unsigned __int8 *)(result + 16) << (8 * (*(_DWORD *)result & 7u)));
  return result;
}

uint64_t _SmallString.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v41[0] = a3;
  v41[1] = a4 & 0xFFFFFFFFFFFFFFLL;
  if (a1 < 0)
  {
    unint64_t v40 = 1860LL;
    goto LABEL_26;
  }

  if ((uint64_t)(HIBYTE(a4) & 0xF) < a2)
  {
    unint64_t v40 = 1861LL;
LABEL_26:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v40,  0);
  }

  uint64_t v4 = a2 - a1;
  if (a2 - a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (a2 == a1) {
    return 0LL;
  }
  uint64_t v6 = v4 - 8;
  if (v4 >= 8) {
    unint64_t v7 = 8LL;
  }
  else {
    unint64_t v7 = a2 - a1;
  }
  if (!v7)
  {
    int8x8_t v5 = 0LL;
    goto LABEL_18;
  }

  if (v7 < 8)
  {
    unint64_t v8 = 0LL;
    int8x8_t v5 = 0LL;
    uint64_t v9 = 0LL;
LABEL_16:
    uint64_t v31 = (unsigned __int8 *)v41 + v8 + a1;
    unint64_t v32 = v7 - v8;
    do
    {
      unsigned int v33 = *v31++;
      *(void *)&v5 |= (unint64_t)v33 << (v9 & 0x38);
      v9 += 8LL;
      --v32;
    }

    while (v32);
    goto LABEL_18;
  }

  unint64_t v8 = v7 & 8;
  int64x2_t v10 = (int64x2_t)xmmword_1817FFCC0;
  int64x2_t v11 = (int64x2_t)xmmword_1817FFCE0;
  int64x2_t v12 = (int64x2_t)xmmword_1817FFCB0;
  uint64_t v9 = 8 * v8;
  int8x16_t v13 = 0uLL;
  int8x16_t v14 = (int8x16_t)vdupq_n_s64(0x38uLL);
  int64x2_t v15 = vdupq_n_s64(0x40uLL);
  int64x2_t v16 = (int64x2_t)xmmword_1817FFCD0;
  unint64_t v17 = v8;
  uint64_t v18 = (uint8x8_t *)((char *)v41 + a1);
  int8x16_t v19 = 0uLL;
  int8x16_t v20 = 0uLL;
  int8x16_t v21 = 0uLL;
  do
  {
    uint8x8_t v22 = *v18++;
    uint16x8_t v23 = vmovl_u8(v22);
    uint32x4_t v24 = vmovl_high_u16(v23);
    v25.i64[0] = v24.u32[2];
    v25.i64[1] = v24.u32[3];
    uint64x2_t v26 = v25;
    v25.i64[0] = v24.u32[0];
    v25.i64[1] = v24.u32[1];
    uint64x2_t v27 = v25;
    uint32x4_t v28 = vmovl_u16(*(uint16x4_t *)v23.i8);
    v25.i64[0] = v28.u32[2];
    v25.i64[1] = v28.u32[3];
    uint64x2_t v29 = v25;
    v25.i64[0] = v28.u32[0];
    v25.i64[1] = v28.u32[1];
    int8x16_t v21 = vorrq_s8((int8x16_t)vshlq_u64(v26, (uint64x2_t)vandq_s8((int8x16_t)v10, v14)), v21);
    int8x16_t v20 = vorrq_s8((int8x16_t)vshlq_u64(v27, (uint64x2_t)vandq_s8((int8x16_t)v11, v14)), v20);
    int8x16_t v19 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)vandq_s8((int8x16_t)v12, v14)), v19);
    int8x16_t v13 = vorrq_s8((int8x16_t)vshlq_u64(v25, (uint64x2_t)vandq_s8((int8x16_t)v16, v14)), v13);
    int64x2_t v11 = vaddq_s64(v11, v15);
    int64x2_t v12 = vaddq_s64(v12, v15);
    int64x2_t v16 = vaddq_s64(v16, v15);
    int64x2_t v10 = vaddq_s64(v10, v15);
    v17 -= 8LL;
  }

  while (v17);
  int8x16_t v30 = vorrq_s8(vorrq_s8(v13, v20), vorrq_s8(v19, v21));
  int8x8_t v5 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
  if (v7 != v8) {
    goto LABEL_16;
  }
LABEL_18:
  if ((unint64_t)v4 >= 9)
  {
    uint64_t v34 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v36 = (unsigned __int8 *)&v41[1] + a1;
    unint64_t v37 = v6 & ~(v6 >> 63);
    do
    {
      if (v37 <= a2 - a1 - 9) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
      }
      unsigned int v38 = *v36++;
      v34 |= (unint64_t)v38 << (v35 & 0x38);
      v35 += 8LL;
      --v6;
    }

    while (v6);
  }

  return (uint64_t)v5;
}

unsigned __int8 *key path getter for _SmallString.subscript(_:) : _SmallString@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X1>, int8x8_t *a3@<X8>)
{
  uint64_t v5 = *a1;
  unint64_t v4 = a1[1];
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  v80[0] = v5;
  v80[1] = v4 & 0xFFFFFFFFFFFFFFLL;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x744uLL,  0);
  }
  uint64_t v8 = HIBYTE(v4) & 0xF;
  if (v8 < v7) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }
  uint64_t result = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v6, v7, (uint64_t)v80, v8);
  if (!v10)
  {
    int8x8_t v12 = 0LL;
    unint64_t v13 = 0xE000000000000000LL;
    goto LABEL_34;
  }

  if (v10 <= 8)
  {
    unint64_t v11 = v10;
    if (v10 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  else
  {
    unint64_t v11 = 8LL;
  }

  if (v11 >= 8)
  {
    if (v11 >= 0x10)
    {
      unint64_t v14 = v11 & 0xFFFFFFFFFFFFFFF0LL;
      int64x2_t v39 = (int64x2_t)xmmword_1817FFD60;
      int64x2_t v40 = (int64x2_t)xmmword_1817FFD70;
      int64x2_t v41 = (int64x2_t)xmmword_1817FFD80;
      int64x2_t v42 = (int64x2_t)xmmword_1817FFD90;
      unint64_t v15 = 8 * (v11 & 0xFFFFFFFFFFFFFFF0LL);
      int8x16_t v43 = 0uLL;
      int8x16_t v44 = (int8x16_t)vdupq_n_s64(0x38uLL);
      int64x2_t v45 = vdupq_n_s64(0x80uLL);
      unint64_t v46 = v11 & 0xFFFFFFFFFFFFFFF0LL;
      int v47 = (uint8x16_t *)result;
      int64x2_t v48 = (int64x2_t)xmmword_1817FFCC0;
      int8x16_t v49 = 0uLL;
      int8x16_t v50 = 0uLL;
      int64x2_t v51 = (int64x2_t)xmmword_1817FFCE0;
      int8x16_t v52 = 0uLL;
      int8x16_t v53 = 0uLL;
      int64x2_t v54 = (int64x2_t)xmmword_1817FFCB0;
      int8x16_t v55 = 0uLL;
      int8x16_t v56 = 0uLL;
      int64x2_t v57 = (int64x2_t)xmmword_1817FFCD0;
      int8x16_t v58 = 0uLL;
      do
      {
        uint8x16_t v59 = *v47++;
        uint16x8_t v60 = vmovl_u8(*(uint8x8_t *)v59.i8);
        uint32x4_t v61 = vmovl_high_u16(v60);
        v62.i64[0] = v61.u32[2];
        v62.i64[1] = v61.u32[3];
        uint64x2_t v63 = v62;
        uint16x8_t v64 = vmovl_high_u8(v59);
        uint32x4_t v65 = vmovl_u16(*(uint16x4_t *)v64.i8);
        v62.i64[0] = v65.u32[2];
        v62.i64[1] = v65.u32[3];
        uint64x2_t v66 = v62;
        v62.i64[0] = v65.u32[0];
        v62.i64[1] = v65.u32[1];
        uint64x2_t v67 = v62;
        v62.i64[0] = v61.u32[0];
        v62.i64[1] = v61.u32[1];
        uint64x2_t v68 = v62;
        uint32x4_t v69 = vmovl_u16(*(uint16x4_t *)v60.i8);
        v62.i64[0] = v69.u32[2];
        v62.i64[1] = v69.u32[3];
        uint64x2_t v70 = v62;
        uint32x4_t v71 = vmovl_high_u16(v64);
        v62.i64[0] = v71.u32[0];
        v62.i64[1] = v71.u32[1];
        uint64x2_t v72 = v62;
        v62.i64[0] = v69.u32[0];
        v62.i64[1] = v69.u32[1];
        uint64x2_t v73 = v62;
        v62.i64[0] = v71.u32[2];
        v62.i64[1] = v71.u32[3];
        int8x16_t v52 = vorrq_s8((int8x16_t)vshlq_u64(v63, (uint64x2_t)vandq_s8((int8x16_t)v48, v44)), v52);
        int8x16_t v55 = vorrq_s8((int8x16_t)vshlq_u64(v66, (uint64x2_t)vandq_s8((int8x16_t)v41, v44)), v55);
        int8x16_t v53 = vorrq_s8((int8x16_t)vshlq_u64(v67, (uint64x2_t)vandq_s8((int8x16_t)v42, v44)), v53);
        int8x16_t v50 = vorrq_s8((int8x16_t)vshlq_u64(v68, (uint64x2_t)vandq_s8((int8x16_t)v51, v44)), v50);
        int8x16_t v49 = vorrq_s8((int8x16_t)vshlq_u64(v70, (uint64x2_t)vandq_s8((int8x16_t)v54, v44)), v49);
        int8x16_t v56 = vorrq_s8((int8x16_t)vshlq_u64(v72, (uint64x2_t)vandq_s8((int8x16_t)v40, v44)), v56);
        int8x16_t v43 = vorrq_s8((int8x16_t)vshlq_u64(v73, (uint64x2_t)vandq_s8((int8x16_t)v57, v44)), v43);
        int8x16_t v58 = vorrq_s8((int8x16_t)vshlq_u64(v62, (uint64x2_t)vandq_s8((int8x16_t)v39, v44)), v58);
        int64x2_t v51 = vaddq_s64(v51, v45);
        int64x2_t v54 = vaddq_s64(v54, v45);
        int64x2_t v57 = vaddq_s64(v57, v45);
        int64x2_t v48 = vaddq_s64(v48, v45);
        int64x2_t v42 = vaddq_s64(v42, v45);
        int64x2_t v41 = vaddq_s64(v41, v45);
        int64x2_t v40 = vaddq_s64(v40, v45);
        int64x2_t v39 = vaddq_s64(v39, v45);
        v46 -= 16LL;
      }

      while (v46);
      int8x16_t v74 = vorrq_s8(vorrq_s8(vorrq_s8(v43, v53), vorrq_s8(v50, v56)), vorrq_s8(vorrq_s8(v49, v55), vorrq_s8(v52, v58)));
      int8x8_t v12 = vorr_s8(*(int8x8_t *)v74.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL));
      if (v11 == v14) {
        goto LABEL_22;
      }
      if ((v11 & 8) == 0) {
        goto LABEL_20;
      }
    }

    else
    {
      int8x8_t v12 = 0LL;
      unint64_t v15 = 0LL;
      unint64_t v14 = 0LL;
    }

    unint64_t v16 = v14;
    int64x2_t v17 = vdupq_n_s64(v15);
    unint64_t v14 = v11 & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v15 = 8 * (v11 & 0xFFFFFFFFFFFFFFF8LL);
    int8x16_t v18 = 0uLL;
    int8x16_t v19 = (int8x16_t)(unint64_t)v12;
    int64x2_t v20 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCC0);
    int64x2_t v21 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCE0);
    int64x2_t v22 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCB0);
    int64x2_t v23 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCD0);
    uint32x4_t v24 = (uint8x8_t *)&result[v16];
    int8x16_t v25 = (int8x16_t)vdupq_n_s64(0x38uLL);
    unint64_t v26 = v16 - (v11 & 0xFFFFFFFFFFFFFFF8LL);
    int64x2_t v27 = vdupq_n_s64(0x40uLL);
    int8x16_t v28 = 0uLL;
    int8x16_t v29 = 0uLL;
    do
    {
      uint8x8_t v30 = *v24++;
      uint16x8_t v31 = vmovl_u8(v30);
      uint32x4_t v32 = vmovl_high_u16(v31);
      v33.i64[0] = v32.u32[2];
      v33.i64[1] = v32.u32[3];
      uint64x2_t v34 = v33;
      v33.i64[0] = v32.u32[0];
      v33.i64[1] = v32.u32[1];
      uint64x2_t v35 = v33;
      uint32x4_t v36 = vmovl_u16(*(uint16x4_t *)v31.i8);
      v33.i64[0] = v36.u32[2];
      v33.i64[1] = v36.u32[3];
      uint64x2_t v37 = v33;
      v33.i64[0] = v36.u32[0];
      v33.i64[1] = v36.u32[1];
      int8x16_t v29 = vorrq_s8((int8x16_t)vshlq_u64(v34, (uint64x2_t)vandq_s8((int8x16_t)v20, v25)), v29);
      int8x16_t v28 = vorrq_s8((int8x16_t)vshlq_u64(v35, (uint64x2_t)vandq_s8((int8x16_t)v21, v25)), v28);
      int8x16_t v18 = vorrq_s8((int8x16_t)vshlq_u64(v37, (uint64x2_t)vandq_s8((int8x16_t)v22, v25)), v18);
      int8x16_t v19 = vorrq_s8((int8x16_t)vshlq_u64(v33, (uint64x2_t)vandq_s8((int8x16_t)v23, v25)), v19);
      int64x2_t v21 = vaddq_s64(v21, v27);
      int64x2_t v22 = vaddq_s64(v22, v27);
      int64x2_t v23 = vaddq_s64(v23, v27);
      int64x2_t v20 = vaddq_s64(v20, v27);
      v26 += 8LL;
    }

    while (v26);
    int8x16_t v38 = vorrq_s8(vorrq_s8(v19, v28), vorrq_s8(v18, v29));
    int8x8_t v12 = vorr_s8(*(int8x8_t *)v38.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
    if (v11 == v14) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }

  unint64_t v14 = 0LL;
  int8x8_t v12 = 0LL;
  unint64_t v15 = 0LL;
LABEL_20:
  unint64_t v75 = v11 - v14;
  uint64_t v76 = &result[v14];
  do
  {
    unsigned int v77 = *v76++;
    *(void *)&v12 |= (unint64_t)v77 << (v15 & 0x38);
    v15 += 8LL;
    --v75;
  }

  while (v75);
LABEL_22:
  if (v10 <= 8)
  {
    uint64_t v78 = 0LL;
  }

  else
  {
    uint64_t v78 = result[8];
    if (v10 != 9)
    {
      v78 |= (unint64_t)result[9] << 8;
      if (v10 != 10)
      {
        v78 |= (unint64_t)result[10] << 16;
        if (v10 != 11)
        {
          v78 |= (unint64_t)result[11] << 24;
          if (v10 != 12)
          {
            v78 |= (unint64_t)result[12] << 32;
            if (v10 != 13)
            {
              v78 |= (unint64_t)result[13] << 40;
              if (v10 != 14) {
                v78 |= (unint64_t)result[14] << 48;
              }
            }
          }
        }
      }
    }
  }

  unint64_t v79 = 0xA000000000000000LL;
  if (((v78 | *(void *)&v12) & 0x8080808080808080LL) == 0) {
    unint64_t v79 = 0xE000000000000000LL;
  }
  unint64_t v13 = v79 | (v10 << 56) | v78;
LABEL_34:
  *a3 = v12;
  a3[1] = (int8x8_t)v13;
  return result;
}

void key path setter for _SmallString.subscript(_:) : _SmallString()
{
}

uint64_t _SmallString.init(_:)(uint8x16_t *a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 > 15) {
    return 0LL;
  }
  if (a2 >= 8) {
    unint64_t v3 = 8LL;
  }
  else {
    unint64_t v3 = a2;
  }
  if ((v3 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v3 < 8)
  {
    unint64_t v4 = 0LL;
    int8x8_t v2 = 0LL;
    unint64_t v5 = 0LL;
    goto LABEL_19;
  }

  if (v3 >= 0x10)
  {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFF0LL;
    uint16x8_t v29 = vmovl_high_u8(*a1);
    int8x16_t v30 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v29.i8);
    uint16x8_t v31 = vmovl_u8(*(uint8x8_t *)a1->i8);
    int8x16_t v32 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v31.i8);
    int8x16_t v33 = (int8x16_t)vmovl_high_u16(v29);
    int8x8_t v34 = (int8x8_t)vextq_s8(v33, v33, 8uLL).u64[0];
    int8x16_t v35 = (int8x16_t)vmovl_high_u16(v31);
    int8x8_t v36 = (int8x8_t)vextq_s8(v35, v35, 8uLL).u64[0];
    *(int8x8_t *)v35.i8 = vorr_s8(*(int8x8_t *)v35.i8, *(int8x8_t *)v33.i8);
    v37.i64[0] = v35.u32[0];
    v37.i64[1] = v35.u32[1];
    int8x16_t v38 = (int8x16_t)vshlq_u64(v37, (uint64x2_t)xmmword_1817FFCE0);
    *(int8x8_t *)v33.i8 = vorr_s8(*(int8x8_t *)v32.i8, *(int8x8_t *)v30.i8);
    v37.i64[0] = v33.u32[0];
    v37.i64[1] = v33.u32[1];
    int8x16_t v39 = vorrq_s8((int8x16_t)vshlq_u64(v37, (uint64x2_t)xmmword_1817FFCD0), v38);
    *(int8x8_t *)v33.i8 = vorr_s8(v36, v34);
    v37.i64[0] = v33.u32[0];
    v37.i64[1] = v33.u32[1];
    int8x16_t v40 = (int8x16_t)vshlq_u64(v37, (uint64x2_t)xmmword_1817FFCC0);
    *(int8x8_t *)v30.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
    v37.i64[0] = v30.u32[0];
    v37.i64[1] = v30.u32[1];
    int8x16_t v41 = vorrq_s8(v39, vorrq_s8((int8x16_t)vshlq_u64(v37, (uint64x2_t)xmmword_1817FFCB0), v40));
    int8x8_t v2 = vorr_s8(*(int8x8_t *)v41.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
    if (v3 == (v3 & 0xFFFFFFFFFFFFFFF0LL)) {
      goto LABEL_21;
    }
    unint64_t v5 = 8 * v4;
    if ((v3 & 8) == 0) {
      goto LABEL_19;
    }
  }

  else
  {
    int8x8_t v2 = 0LL;
    unint64_t v5 = 0LL;
    unint64_t v4 = 0LL;
  }

  unint64_t v6 = v4;
  int64x2_t v7 = vdupq_n_s64(v5);
  unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v5 = 8 * (v3 & 0xFFFFFFFFFFFFFFF8LL);
  int8x16_t v8 = 0uLL;
  int8x16_t v9 = (int8x16_t)(unint64_t)v2;
  int64x2_t v10 = vaddq_s64(v7, (int64x2_t)xmmword_1817FFCC0);
  int64x2_t v11 = vaddq_s64(v7, (int64x2_t)xmmword_1817FFCE0);
  int64x2_t v12 = vaddq_s64(v7, (int64x2_t)xmmword_1817FFCB0);
  int64x2_t v13 = vaddq_s64(v7, (int64x2_t)xmmword_1817FFCD0);
  unint64_t v14 = (uint8x8_t *)&a1->i8[v6];
  int8x16_t v15 = (int8x16_t)vdupq_n_s64(0x38uLL);
  unint64_t v16 = v6 - (v3 & 0xFFFFFFFFFFFFFFF8LL);
  int64x2_t v17 = vdupq_n_s64(0x40uLL);
  int8x16_t v18 = 0uLL;
  int8x16_t v19 = 0uLL;
  do
  {
    uint8x8_t v20 = *v14++;
    uint16x8_t v21 = vmovl_u8(v20);
    uint32x4_t v22 = vmovl_high_u16(v21);
    v23.i64[0] = v22.u32[2];
    v23.i64[1] = v22.u32[3];
    uint64x2_t v24 = v23;
    v23.i64[0] = v22.u32[0];
    v23.i64[1] = v22.u32[1];
    uint64x2_t v25 = v23;
    uint32x4_t v26 = vmovl_u16(*(uint16x4_t *)v21.i8);
    v23.i64[0] = v26.u32[2];
    v23.i64[1] = v26.u32[3];
    uint64x2_t v27 = v23;
    v23.i64[0] = v26.u32[0];
    v23.i64[1] = v26.u32[1];
    int8x16_t v19 = vorrq_s8((int8x16_t)vshlq_u64(v24, (uint64x2_t)vandq_s8((int8x16_t)v10, v15)), v19);
    int8x16_t v18 = vorrq_s8((int8x16_t)vshlq_u64(v25, (uint64x2_t)vandq_s8((int8x16_t)v11, v15)), v18);
    int8x16_t v8 = vorrq_s8((int8x16_t)vshlq_u64(v27, (uint64x2_t)vandq_s8((int8x16_t)v12, v15)), v8);
    int8x16_t v9 = vorrq_s8((int8x16_t)vshlq_u64(v23, (uint64x2_t)vandq_s8((int8x16_t)v13, v15)), v9);
    int64x2_t v11 = vaddq_s64(v11, v17);
    int64x2_t v12 = vaddq_s64(v12, v17);
    int64x2_t v13 = vaddq_s64(v13, v17);
    int64x2_t v10 = vaddq_s64(v10, v17);
    v16 += 8LL;
  }

  while (v16);
  int8x16_t v28 = vorrq_s8(vorrq_s8(v9, v18), vorrq_s8(v8, v19));
  int8x8_t v2 = vorr_s8(*(int8x8_t *)v28.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
  if (v3 != v4)
  {
LABEL_19:
    unint64_t v42 = v3 - v4;
    int8x16_t v43 = &a1->u8[v4];
    do
    {
      unsigned int v44 = *v43++;
      *(void *)&v2 |= (unint64_t)v44 << (v5 & 0x38);
      v5 += 8LL;
      --v42;
    }

    while (v42);
  }

uint64_t _SmallString.withUTF8<A>(_:)( uint64_t (*a1)(void *, uint64_t), uint64_t a2, uint64_t a3, unint64_t a4)
{
  v5[0] = a3;
  v5[1] = a4 & 0xFFFFFFFFFFFFFFLL;
  return a1(v5, HIBYTE(a4) & 0xF);
}

unsigned __int8 *protocol witness for MutableCollection.subscript.setter in conformance _SmallString( unsigned __int8 *result, void *a2)
{
  *(void *)(v2 + 8LL * (*a2 > 7LL)) = *(void *)(v2 + 8LL * (*a2 > 7LL)) & ((-255LL << (8
  return result;
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance _SmallString( uint64_t a1, uint64_t *a2))(uint64_t result)
{
  uint64_t v4 = *a2;
  BOOL v5 = *a2 > 7;
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v4;
  if (v4 >= 8) {
    uint64_t result = protocol witness for MutableCollection.subscript.modify in conformance _SmallString;
  }
  else {
    uint64_t result = protocol witness for MutableCollection.subscript.modify in conformance _SmallString;
  }
  *(_BYTE *)(a1 + 16) = *(void *)(v2 + 8LL * v5) >> (8 * (v4 & 7u));
  return result;
}

uint64_t protocol witness for MutableCollection.subscript.modify in conformance _SmallString(uint64_t result)
{
  char v1 = 8 * (*(_DWORD *)(result + 8) & 7);
  **(void **)uint64_t result = ((-255LL << v1) - 1) & **(void **)result | ((unint64_t)*(unsigned __int8 *)(result + 16) << v1);
  return result;
}

{
  char v1;
  char v1 = 8 * (*(_DWORD *)(result + 8) & 7);
  *(void *)(*(void *)result + 8LL) = ((-255LL << v1) - 1) & *(void *)(*(void *)result + 8LL) | ((unint64_t)*(unsigned __int8 *)(result + 16) << v1);
  return result;
}

void protocol witness for MutableCollection.subscript.modify in conformance _SmallString()
{
}

unint64_t protocol witness for MutableCollection.partition(by:) in conformance _SmallString@<X0>( uint64_t (*a1)(char *)@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized MutableCollection<>._partitionImpl(by:)(a1);
  if (!v2) {
    *a2 = result;
  }
  return result;
}

uint64_t protocol witness for MutableCollection.swapAt(_:_:) in conformance _SmallString( uint64_t *a1, uint64_t *a2)
{
  return specialized MutableCollection.swapAt(_:_:)(*a1, *a2);
}

uint64_t protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance _SmallString@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSMsE39withContiguousMutableStorageIfAvailableyqd__Sgqd__Sry7ElementQzGzKXEKlFSryxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys5UInt8Vqd__Isglrzo_s12_SmallStringVABsAG_pAKRszr__lIetMglrzo_Tpq5( a1,  a2);
}

unint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _SmallString@<X0>( uint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *(void *)v2, *(void *)(v2 + 8));
  *a2 = result;
  return result;
}

unint64_t *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SmallString( unint64_t *result)
{
  unint64_t v2 = *result - 1;
  if (__OFSUB__(*result, 1LL))
  {
    __break(1u);
  }

  else
  {
    if (v2 >= (*(_BYTE *)(v1 + 15) & 0xFu)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
    }
    *unint64_t result = v2;
  }

  return result;
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _SmallString@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *(void *)v3, *(void *)(v3 + 8));
  *a3 = result;
  return result;
}

unint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance _SmallString@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *v4;
  unint64_t v9 = v4[1];
  int64_t v10 = specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a3, *v4, v9);
  if (a2 < 1)
  {
    if (v10 <= 0 && v10 > a2) {
      goto LABEL_4;
    }
LABEL_10:
    unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(v7, a2, v8, v9);
    char v12 = 0;
    goto LABEL_11;
  }

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _SmallString( unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *(void *)v2, *(void *)(v2 + 8));
}

void protocol witness for Collection.endIndex.getter in conformance _SmallString(void *a1@<X8>)
{
  *a1 = *(_BYTE *)(v1 + 15) & 0xF;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _SmallString( _BYTE *a1, void *a2))()
{
  *a1 = *(void *)(v2 + 8LL * (*a2 > 7LL)) >> (8 * (*a2 & 7u));
  return EnumeratedSequence._base.modify;
}

unsigned __int8 *protocol witness for Collection.subscript.getter in conformance _SmallString@<X0>( uint64_t *a1@<X0>, int8x8_t *a2@<X8>)
{
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  unint64_t v7 = v2[1];
  v80[0] = *v2;
  v80[1] = v7 & 0xFFFFFFFFFFFFFFLL;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x744uLL,  0);
  }
  uint64_t v8 = HIBYTE(v7) & 0xF;
  if (v8 < v6) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }
  unint64_t result = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v5, v6, (uint64_t)v80, v8);
  if (!v10)
  {
    int8x8_t v12 = 0LL;
    unint64_t v13 = 0xE000000000000000LL;
    goto LABEL_34;
  }

  if (v10 <= 8)
  {
    unint64_t v11 = v10;
    if (v10 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  else
  {
    unint64_t v11 = 8LL;
  }

  if (v11 >= 8)
  {
    if (v11 >= 0x10)
    {
      unint64_t v14 = v11 & 0xFFFFFFFFFFFFFFF0LL;
      int64x2_t v39 = (int64x2_t)xmmword_1817FFD60;
      int64x2_t v40 = (int64x2_t)xmmword_1817FFD70;
      int64x2_t v41 = (int64x2_t)xmmword_1817FFD80;
      int64x2_t v42 = (int64x2_t)xmmword_1817FFD90;
      unint64_t v15 = 8 * (v11 & 0xFFFFFFFFFFFFFFF0LL);
      int8x16_t v43 = 0uLL;
      int8x16_t v44 = (int8x16_t)vdupq_n_s64(0x38uLL);
      int64x2_t v45 = vdupq_n_s64(0x80uLL);
      unint64_t v46 = v11 & 0xFFFFFFFFFFFFFFF0LL;
      uint64_t v47 = (uint8x16_t *)result;
      int64x2_t v48 = (int64x2_t)xmmword_1817FFCC0;
      int8x16_t v49 = 0uLL;
      int8x16_t v50 = 0uLL;
      int64x2_t v51 = (int64x2_t)xmmword_1817FFCE0;
      int8x16_t v52 = 0uLL;
      int8x16_t v53 = 0uLL;
      int64x2_t v54 = (int64x2_t)xmmword_1817FFCB0;
      int8x16_t v55 = 0uLL;
      int8x16_t v56 = 0uLL;
      int64x2_t v57 = (int64x2_t)xmmword_1817FFCD0;
      int8x16_t v58 = 0uLL;
      do
      {
        uint8x16_t v59 = *v47++;
        uint16x8_t v60 = vmovl_u8(*(uint8x8_t *)v59.i8);
        uint32x4_t v61 = vmovl_high_u16(v60);
        v62.i64[0] = v61.u32[2];
        v62.i64[1] = v61.u32[3];
        uint64x2_t v63 = v62;
        uint16x8_t v64 = vmovl_high_u8(v59);
        uint32x4_t v65 = vmovl_u16(*(uint16x4_t *)v64.i8);
        v62.i64[0] = v65.u32[2];
        v62.i64[1] = v65.u32[3];
        uint64x2_t v66 = v62;
        v62.i64[0] = v65.u32[0];
        v62.i64[1] = v65.u32[1];
        uint64x2_t v67 = v62;
        v62.i64[0] = v61.u32[0];
        v62.i64[1] = v61.u32[1];
        uint64x2_t v68 = v62;
        uint32x4_t v69 = vmovl_u16(*(uint16x4_t *)v60.i8);
        v62.i64[0] = v69.u32[2];
        v62.i64[1] = v69.u32[3];
        uint64x2_t v70 = v62;
        uint32x4_t v71 = vmovl_high_u16(v64);
        v62.i64[0] = v71.u32[0];
        v62.i64[1] = v71.u32[1];
        uint64x2_t v72 = v62;
        v62.i64[0] = v69.u32[0];
        v62.i64[1] = v69.u32[1];
        uint64x2_t v73 = v62;
        v62.i64[0] = v71.u32[2];
        v62.i64[1] = v71.u32[3];
        int8x16_t v52 = vorrq_s8((int8x16_t)vshlq_u64(v63, (uint64x2_t)vandq_s8((int8x16_t)v48, v44)), v52);
        int8x16_t v55 = vorrq_s8((int8x16_t)vshlq_u64(v66, (uint64x2_t)vandq_s8((int8x16_t)v41, v44)), v55);
        int8x16_t v53 = vorrq_s8((int8x16_t)vshlq_u64(v67, (uint64x2_t)vandq_s8((int8x16_t)v42, v44)), v53);
        int8x16_t v50 = vorrq_s8((int8x16_t)vshlq_u64(v68, (uint64x2_t)vandq_s8((int8x16_t)v51, v44)), v50);
        int8x16_t v49 = vorrq_s8((int8x16_t)vshlq_u64(v70, (uint64x2_t)vandq_s8((int8x16_t)v54, v44)), v49);
        int8x16_t v56 = vorrq_s8((int8x16_t)vshlq_u64(v72, (uint64x2_t)vandq_s8((int8x16_t)v40, v44)), v56);
        int8x16_t v43 = vorrq_s8((int8x16_t)vshlq_u64(v73, (uint64x2_t)vandq_s8((int8x16_t)v57, v44)), v43);
        int8x16_t v58 = vorrq_s8((int8x16_t)vshlq_u64(v62, (uint64x2_t)vandq_s8((int8x16_t)v39, v44)), v58);
        int64x2_t v51 = vaddq_s64(v51, v45);
        int64x2_t v54 = vaddq_s64(v54, v45);
        int64x2_t v57 = vaddq_s64(v57, v45);
        int64x2_t v48 = vaddq_s64(v48, v45);
        int64x2_t v42 = vaddq_s64(v42, v45);
        int64x2_t v41 = vaddq_s64(v41, v45);
        int64x2_t v40 = vaddq_s64(v40, v45);
        int64x2_t v39 = vaddq_s64(v39, v45);
        v46 -= 16LL;
      }

      while (v46);
      int8x16_t v74 = vorrq_s8(vorrq_s8(vorrq_s8(v43, v53), vorrq_s8(v50, v56)), vorrq_s8(vorrq_s8(v49, v55), vorrq_s8(v52, v58)));
      int8x8_t v12 = vorr_s8(*(int8x8_t *)v74.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL));
      if (v11 == v14) {
        goto LABEL_22;
      }
      if ((v11 & 8) == 0) {
        goto LABEL_20;
      }
    }

    else
    {
      int8x8_t v12 = 0LL;
      unint64_t v15 = 0LL;
      unint64_t v14 = 0LL;
    }

    unint64_t v16 = v14;
    int64x2_t v17 = vdupq_n_s64(v15);
    unint64_t v14 = v11 & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v15 = 8 * (v11 & 0xFFFFFFFFFFFFFFF8LL);
    int8x16_t v18 = 0uLL;
    int8x16_t v19 = (int8x16_t)(unint64_t)v12;
    int64x2_t v20 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCC0);
    int64x2_t v21 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCE0);
    int64x2_t v22 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCB0);
    int64x2_t v23 = vaddq_s64(v17, (int64x2_t)xmmword_1817FFCD0);
    uint64x2_t v24 = (uint8x8_t *)&result[v16];
    int8x16_t v25 = (int8x16_t)vdupq_n_s64(0x38uLL);
    unint64_t v26 = v16 - (v11 & 0xFFFFFFFFFFFFFFF8LL);
    int64x2_t v27 = vdupq_n_s64(0x40uLL);
    int8x16_t v28 = 0uLL;
    int8x16_t v29 = 0uLL;
    do
    {
      uint8x8_t v30 = *v24++;
      uint16x8_t v31 = vmovl_u8(v30);
      uint32x4_t v32 = vmovl_high_u16(v31);
      v33.i64[0] = v32.u32[2];
      v33.i64[1] = v32.u32[3];
      uint64x2_t v34 = v33;
      v33.i64[0] = v32.u32[0];
      v33.i64[1] = v32.u32[1];
      uint64x2_t v35 = v33;
      uint32x4_t v36 = vmovl_u16(*(uint16x4_t *)v31.i8);
      v33.i64[0] = v36.u32[2];
      v33.i64[1] = v36.u32[3];
      uint64x2_t v37 = v33;
      v33.i64[0] = v36.u32[0];
      v33.i64[1] = v36.u32[1];
      int8x16_t v29 = vorrq_s8((int8x16_t)vshlq_u64(v34, (uint64x2_t)vandq_s8((int8x16_t)v20, v25)), v29);
      int8x16_t v28 = vorrq_s8((int8x16_t)vshlq_u64(v35, (uint64x2_t)vandq_s8((int8x16_t)v21, v25)), v28);
      int8x16_t v18 = vorrq_s8((int8x16_t)vshlq_u64(v37, (uint64x2_t)vandq_s8((int8x16_t)v22, v25)), v18);
      int8x16_t v19 = vorrq_s8((int8x16_t)vshlq_u64(v33, (uint64x2_t)vandq_s8((int8x16_t)v23, v25)), v19);
      int64x2_t v21 = vaddq_s64(v21, v27);
      int64x2_t v22 = vaddq_s64(v22, v27);
      int64x2_t v23 = vaddq_s64(v23, v27);
      int64x2_t v20 = vaddq_s64(v20, v27);
      v26 += 8LL;
    }

    while (v26);
    int8x16_t v38 = vorrq_s8(vorrq_s8(v19, v28), vorrq_s8(v18, v29));
    int8x8_t v12 = vorr_s8(*(int8x8_t *)v38.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
    if (v11 == v14) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }

  unint64_t v14 = 0LL;
  int8x8_t v12 = 0LL;
  unint64_t v15 = 0LL;
LABEL_20:
  unint64_t v75 = v11 - v14;
  uint64_t v76 = &result[v14];
  do
  {
    unsigned int v77 = *v76++;
    *(void *)&v12 |= (unint64_t)v77 << (v15 & 0x38);
    v15 += 8LL;
    --v75;
  }

  while (v75);
LABEL_22:
  if (v10 <= 8)
  {
    uint64_t v78 = 0LL;
  }

  else
  {
    uint64_t v78 = result[8];
    if (v10 != 9)
    {
      v78 |= (unint64_t)result[9] << 8;
      if (v10 != 10)
      {
        v78 |= (unint64_t)result[10] << 16;
        if (v10 != 11)
        {
          v78 |= (unint64_t)result[11] << 24;
          if (v10 != 12)
          {
            v78 |= (unint64_t)result[12] << 32;
            if (v10 != 13)
            {
              v78 |= (unint64_t)result[13] << 40;
              if (v10 != 14) {
                v78 |= (unint64_t)result[14] << 48;
              }
            }
          }
        }
      }
    }
  }

  unint64_t v79 = 0xA000000000000000LL;
  if (((v78 | *(void *)&v12) & 0x8080808080808080LL) == 0) {
    unint64_t v79 = 0xE000000000000000LL;
  }
  unint64_t v13 = v79 | (v10 << 56) | v78;
LABEL_34:
  *a2 = v12;
  a2[1] = (int8x8_t)v13;
  return result;
}

void protocol witness for Collection.indices.getter in conformance _SmallString(void *a1@<X8>)
{
  uint64_t v2 = *(_BYTE *)(v1 + 15) & 0xF;
  *a1 = 0LL;
  a1[1] = v2;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance _SmallString()
{
  return (*(_BYTE *)(v0 + 15) & 0xF) == 0;
}

unint64_t protocol witness for Collection.index(after:) in conformance _SmallString@<X0>( unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *(void *)v2, *(void *)(v2 + 8));
  *a2 = result;
  return result;
}

void *protocol witness for Collection.formIndex(after:) in conformance _SmallString(void *result)
{
  if (*result >= (unint64_t)(*(_BYTE *)(v1 + 15) & 0xF)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  ++*result;
  return result;
}

__n128 protocol witness for Sequence.makeIterator() in conformance _SmallString@<Q0>(__n128 *a1@<X8>)
{
  __n128 result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = 0LL;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _SmallString()
{
  return *(_BYTE *)(v0 + 15) & 0xF;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance _SmallString()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _SmallString( unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

  ;
}

unint64_t static _StringObject.Nibbles.small(withCount:isASCII:)(uint64_t a1, char a2)
{
  unint64_t v2 = 0xA000000000000000LL;
  if ((a2 & 1) != 0) {
    unint64_t v2 = 0xE000000000000000LL;
  }
  return v2 | (a1 << 56);
}

uint64_t _bytesToUInt64(_:_:)(uint8x16_t *a1, unint64_t a2)
{
  if ((a2 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (!a2) {
    return 0LL;
  }
  if (a2 < 8)
  {
    unint64_t v2 = 0LL;
    int8x8_t v3 = 0LL;
    unint64_t v4 = 0LL;
    goto LABEL_16;
  }

  if (a2 >= 0x10)
  {
    unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF0LL;
    int64x2_t v28 = (int64x2_t)xmmword_1817FFD60;
    int64x2_t v29 = (int64x2_t)xmmword_1817FFD70;
    int64x2_t v30 = (int64x2_t)xmmword_1817FFD80;
    int64x2_t v31 = (int64x2_t)xmmword_1817FFD90;
    unint64_t v4 = 8 * (a2 & 0xFFFFFFFFFFFFFFF0LL);
    int8x16_t v32 = 0uLL;
    int8x16_t v33 = (int8x16_t)vdupq_n_s64(0x38uLL);
    int64x2_t v34 = vdupq_n_s64(0x80uLL);
    unint64_t v35 = a2 & 0xFFFFFFFFFFFFFFF0LL;
    uint32x4_t v36 = a1;
    int64x2_t v37 = (int64x2_t)xmmword_1817FFCC0;
    int8x16_t v38 = 0uLL;
    int8x16_t v39 = 0uLL;
    int64x2_t v40 = (int64x2_t)xmmword_1817FFCE0;
    int8x16_t v41 = 0uLL;
    int8x16_t v42 = 0uLL;
    int64x2_t v43 = (int64x2_t)xmmword_1817FFCB0;
    int8x16_t v44 = 0uLL;
    int8x16_t v45 = 0uLL;
    int64x2_t v46 = (int64x2_t)xmmword_1817FFCD0;
    int8x16_t v47 = 0uLL;
    do
    {
      uint8x16_t v48 = *v36++;
      uint16x8_t v49 = vmovl_u8(*(uint8x8_t *)v48.i8);
      uint32x4_t v50 = vmovl_high_u16(v49);
      v51.i64[0] = v50.u32[2];
      v51.i64[1] = v50.u32[3];
      uint64x2_t v52 = v51;
      uint16x8_t v53 = vmovl_high_u8(v48);
      uint32x4_t v54 = vmovl_u16(*(uint16x4_t *)v53.i8);
      v51.i64[0] = v54.u32[2];
      v51.i64[1] = v54.u32[3];
      uint64x2_t v55 = v51;
      v51.i64[0] = v54.u32[0];
      v51.i64[1] = v54.u32[1];
      uint64x2_t v56 = v51;
      v51.i64[0] = v50.u32[0];
      v51.i64[1] = v50.u32[1];
      uint64x2_t v57 = v51;
      uint32x4_t v58 = vmovl_u16(*(uint16x4_t *)v49.i8);
      v51.i64[0] = v58.u32[2];
      v51.i64[1] = v58.u32[3];
      uint64x2_t v59 = v51;
      uint32x4_t v60 = vmovl_high_u16(v53);
      v51.i64[0] = v60.u32[0];
      v51.i64[1] = v60.u32[1];
      uint64x2_t v61 = v51;
      v51.i64[0] = v58.u32[0];
      v51.i64[1] = v58.u32[1];
      uint64x2_t v62 = v51;
      v51.i64[0] = v60.u32[2];
      v51.i64[1] = v60.u32[3];
      int8x16_t v41 = vorrq_s8((int8x16_t)vshlq_u64(v52, (uint64x2_t)vandq_s8((int8x16_t)v37, v33)), v41);
      int8x16_t v44 = vorrq_s8((int8x16_t)vshlq_u64(v55, (uint64x2_t)vandq_s8((int8x16_t)v30, v33)), v44);
      int8x16_t v42 = vorrq_s8((int8x16_t)vshlq_u64(v56, (uint64x2_t)vandq_s8((int8x16_t)v31, v33)), v42);
      int8x16_t v39 = vorrq_s8((int8x16_t)vshlq_u64(v57, (uint64x2_t)vandq_s8((int8x16_t)v40, v33)), v39);
      int8x16_t v38 = vorrq_s8((int8x16_t)vshlq_u64(v59, (uint64x2_t)vandq_s8((int8x16_t)v43, v33)), v38);
      int8x16_t v45 = vorrq_s8((int8x16_t)vshlq_u64(v61, (uint64x2_t)vandq_s8((int8x16_t)v29, v33)), v45);
      int8x16_t v32 = vorrq_s8((int8x16_t)vshlq_u64(v62, (uint64x2_t)vandq_s8((int8x16_t)v46, v33)), v32);
      int8x16_t v47 = vorrq_s8((int8x16_t)vshlq_u64(v51, (uint64x2_t)vandq_s8((int8x16_t)v28, v33)), v47);
      int64x2_t v40 = vaddq_s64(v40, v34);
      int64x2_t v43 = vaddq_s64(v43, v34);
      int64x2_t v46 = vaddq_s64(v46, v34);
      int64x2_t v37 = vaddq_s64(v37, v34);
      int64x2_t v31 = vaddq_s64(v31, v34);
      int64x2_t v30 = vaddq_s64(v30, v34);
      int64x2_t v29 = vaddq_s64(v29, v34);
      int64x2_t v28 = vaddq_s64(v28, v34);
      v35 -= 16LL;
    }

    while (v35);
    int8x16_t v63 = vorrq_s8(vorrq_s8(vorrq_s8(v32, v42), vorrq_s8(v39, v45)), vorrq_s8(vorrq_s8(v38, v44), vorrq_s8(v41, v47)));
    int8x8_t v3 = vorr_s8(*(int8x8_t *)v63.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL));
    if (v2 == a2) {
      return (uint64_t)v3;
    }
    if ((a2 & 8) == 0)
    {
LABEL_16:
      uint16x8_t v64 = &a1->u8[v2];
      unint64_t v65 = a2 - v2;
      do
      {
        unsigned int v66 = *v64++;
        *(void *)&v3 |= (unint64_t)v66 << (v4 & 0x38);
        v4 += 8LL;
        --v65;
      }

      while (v65);
      return (uint64_t)v3;
    }
  }

  else
  {
    int8x8_t v3 = 0LL;
    unint64_t v4 = 0LL;
    unint64_t v2 = 0LL;
  }

  unint64_t v5 = v2;
  int64x2_t v6 = vdupq_n_s64(v4);
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v4 = 8 * (a2 & 0xFFFFFFFFFFFFFFF8LL);
  int8x16_t v7 = 0uLL;
  int8x16_t v8 = (int8x16_t)(unint64_t)v3;
  int64x2_t v9 = vaddq_s64(v6, (int64x2_t)xmmword_1817FFCC0);
  int64x2_t v10 = vaddq_s64(v6, (int64x2_t)xmmword_1817FFCE0);
  int64x2_t v11 = vaddq_s64(v6, (int64x2_t)xmmword_1817FFCB0);
  int64x2_t v12 = vaddq_s64(v6, (int64x2_t)xmmword_1817FFCD0);
  unint64_t v13 = (uint8x8_t *)&a1->i8[v5];
  int8x16_t v14 = (int8x16_t)vdupq_n_s64(0x38uLL);
  unint64_t v15 = v5 - (a2 & 0xFFFFFFFFFFFFFFF8LL);
  int64x2_t v16 = vdupq_n_s64(0x40uLL);
  int8x16_t v17 = 0uLL;
  int8x16_t v18 = 0uLL;
  do
  {
    uint8x8_t v19 = *v13++;
    uint16x8_t v20 = vmovl_u8(v19);
    uint32x4_t v21 = vmovl_high_u16(v20);
    v22.i64[0] = v21.u32[2];
    v22.i64[1] = v21.u32[3];
    uint64x2_t v23 = v22;
    v22.i64[0] = v21.u32[0];
    v22.i64[1] = v21.u32[1];
    uint64x2_t v24 = v22;
    uint32x4_t v25 = vmovl_u16(*(uint16x4_t *)v20.i8);
    v22.i64[0] = v25.u32[2];
    v22.i64[1] = v25.u32[3];
    uint64x2_t v26 = v22;
    v22.i64[0] = v25.u32[0];
    v22.i64[1] = v25.u32[1];
    int8x16_t v18 = vorrq_s8((int8x16_t)vshlq_u64(v23, (uint64x2_t)vandq_s8((int8x16_t)v9, v14)), v18);
    int8x16_t v17 = vorrq_s8((int8x16_t)vshlq_u64(v24, (uint64x2_t)vandq_s8((int8x16_t)v10, v14)), v17);
    int8x16_t v7 = vorrq_s8((int8x16_t)vshlq_u64(v26, (uint64x2_t)vandq_s8((int8x16_t)v11, v14)), v7);
    int8x16_t v8 = vorrq_s8((int8x16_t)vshlq_u64(v22, (uint64x2_t)vandq_s8((int8x16_t)v12, v14)), v8);
    int64x2_t v10 = vaddq_s64(v10, v16);
    int64x2_t v11 = vaddq_s64(v11, v16);
    int64x2_t v12 = vaddq_s64(v12, v16);
    int64x2_t v9 = vaddq_s64(v9, v16);
    v15 += 8LL;
  }

  while (v15);
  int8x16_t v27 = vorrq_s8(vorrq_s8(v8, v17), vorrq_s8(v7, v18));
  int8x8_t v3 = vorr_s8(*(int8x8_t *)v27.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
  if (v2 != a2) {
    goto LABEL_16;
  }
  return (uint64_t)v3;
}

void *_sSw17withMemoryRebound2to_q0_xm_q0_SryxGq_YKXEtq_YKs5ErrorR_Ri_zRi_0_r1_lFACq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys5UInt8VsAD_pq0_Isgyrzr_Swq0_sAD_pAFRszsAD_pRs_Ri_0_r1_lIetMgyrzo_Tpq5SiSg_Tgq5055_sSw39withContiguousMutableStorageIfAvailableyxSgxSrys5F25VGzKXEKlFAbEKXEfU_Si_TGq5SryAFGxsAD_pRi_zRi0_zlySiIsglrzo_Tf1cn_n( uint64_t a1, uint64_t a2, void *(*a3)(uint64_t *__return_ptr, uint64_t *))
{
  if (!a1) {
    return specialized closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)( 0LL,  0LL,  a3);
  }
  uint64_t v3 = a2 - a1;
  if (v3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  return specialized closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)( a1,  v3,  a3);
}

unint64_t _SmallString.init(_:appending:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return specialized _SmallString.init(_:appending:)(a1, a2, a3, a4);
}

unint64_t _SmallString.init(taggedCocoa:)(void *a1)
{
  return specialized _SmallString.init(taggedCocoa:)(a1, 4LL);
}

uint64_t Sequence<>.sorted()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](a1);
  int64x2_t v9 = &v20[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v10,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v21 = a1;
  uint64_t v22 = a2;
  uint64_t v23 = a3;
  unint64_t v24 = AssociatedTypeWitness;
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v7 + 16))(v9, v3, a1);
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, a2);
  uint64_t v14 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v12, v13);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v14, v15);
  int8x16_t v18 = (void *)swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v14, v17);
  MutableCollection<>.sort(by:)( partial apply for implicit closure #1 in Sequence<>.sorted(),  (uint64_t)v20,  v14,  WitnessTable,  v18);
  return v25;
}

uint64_t Sequence.sorted(by:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v15 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v15, v16);
  uint8x8_t v19 = (void *)swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v15, v18);
  MutableCollection<>.sort(by:)(a1, a2, v15, WitnessTable, v19);
  uint64_t v20 = v23;
  if (v5) {
    swift_release(v23);
  }
  return v20;
}

void *MutableCollection<>.sort()(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a2 + 8) + 8LL),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  v10[2] = a1;
  v10[3] = a2;
  void v10[4] = a3;
  uint64_t v10[5] = a4;
  v10[6] = AssociatedTypeWitness;
  return MutableCollection<>.sort(by:)( partial apply for implicit closure #1 in MutableCollection<>.sort(),  (uint64_t)v10,  a1,  a2,  a3);
}

void closure #1 in MutableCollection<>.sort(by:)( uint64_t a1, uint64_t (*a2)(char *, char *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(*(void *)(a5 + 8) + 8LL),  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for UnsafeMutableBufferPointer(0LL, AssociatedTypeWitness, v8, v9);
  UnsafeMutableBufferPointer._stableSortImpl(by:)(a2, a3, v10);
}

void UnsafeMutableBufferPointer._stableSortImpl(by:)( uint64_t (*a1)(char *, char *), uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v106 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int64_t v13 = v3[1];
  if (v13 >= 64)
  {
    char v14 = 58 - __clz(v13);
    uint64_t v15 = -1LL << v14;
    unint64_t v16 = (unint64_t)v13 >> v14;
    if ((v13 & ~v15) != 0) {
      ++v16;
    }
    if (v16 >= v13)
    {
      unint64_t v127 = 0LL;
      unint64_t v128 = v13;
LABEL_88:
      uint64_t v122 = 1LL;
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a3, v9);
      uint64_t v95 = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a3, v94);
      MutableCollection<>._insertionSort(within:sortedEnd:by:)( (uint64_t)&v127,  (void (*)(char *))&v122,  v7,  a2,  a3,  WitnessTable,  v95);
      return;
    }

    int64_t v111 = v16;
    uint64_t v113 = v12;
    uint64_t v114 = v10;
    uint64_t v119 = a3;
    uint64_t v120 = v3;
    id v117 = v8;
    uint64_t v17 = 0LL;
    uint64_t v129 = static Array._allocateUninitialized(_:)((unint64_t)v13 >> 1, v8);
    uint64_t v125 = 0LL;
    uint64_t v126 = v19;
    uint64_t v112 = v19;
    unint64_t v127 = v19;
    unint64_t v128 = (unint64_t)v13 >> 1;
    unint64_t v110 = (unint64_t)v13 >> 1;
    uint64_t v20 = &_swiftEmptyArrayStorage;
    uint64_t v115 = v7;
    uint64_t v116 = a2;
    do
    {
      uint64_t v21 = v119;
      uint64_t v22 = *v120;
      uint64_t v122 = *v120;
      int64_t v123 = v13;
      uint64_t v121 = v17;
      swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v119, v18);
      char v23 = _findNextRun<A>(in:from:by:)((uint64_t)&v124, (uint64_t)&v122, (uint64_t)&v121, v7, a2, v21);
      if (v4) {
        goto LABEL_90;
      }
      uint64_t v118 = v20;
      int64_t v25 = v124;
      if ((v23 & 1) != 0)
      {
        if (v124 < v17) {
          goto LABEL_106;
        }
        if (v17 < v124)
        {
          int64_t v26 = v124;
          int64_t v27 = v17;
          do
          {
            int64_t v29 = v26 - 1;
            if (v27 != v26 - 1)
            {
              if (v26 > v13 || v27 >= v13) {
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x17BuLL,  0);
              }
              if (!v22) {
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x17CuLL,  0);
              }
              uint64_t v30 = *(void *)(v114 + 72);
              int64_t v108 = v30 * v27;
              uint64_t v106 = (char *)(v22 + v30 * v27);
              int64_t v31 = v30 * v29;
              uint64_t v107 = (char *)(v22 + v30 * v29);
              uint64_t v109 = *(void (**)(char *))(v114 + 32);
              v109(v113);
              int8x16_t v32 = &v107[v30];
              int8x16_t v33 = v107;
              if (v108 < v31 || v106 >= v32)
              {
                int64x2_t v28 = v117;
                swift_arrayInitWithTakeFrontToBack(v106, v107, 1LL, (uint64_t)v117);
              }

              else
              {
                BOOL v35 = v108 == v31;
                int64x2_t v28 = v117;
                if (!v35) {
                  swift_arrayInitWithTakeBackToFront(v106, v107, 1LL, (uint64_t)v117);
                }
              }

              ((void (*)(char *, char *, uint64_t *))v109)(v33, v113, v28);
            }

            ++v27;
            int64_t v26 = v29;
          }

          while (v27 < v29);
        }
      }

      if (v25 >= v13) {
        goto LABEL_36;
      }
      if (__OFSUB__(v25, v17))
      {
        __break(1u);
LABEL_121:
        __break(1u);
LABEL_122:
        __break(1u);
LABEL_123:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Sort.swift",  16LL,  2,  0x21BuLL,  0);
      }

      if (v25 - v17 >= v111)
      {
LABEL_36:
        uint64_t v36 = v25;
      }

      else
      {
        if (__OFADD__(v17, v111)) {
          goto LABEL_122;
        }
        if (v17 + v111 >= v13) {
          uint64_t v36 = v13;
        }
        else {
          uint64_t v36 = v17 + v111;
        }
        if (v36 < v17) {
          goto LABEL_106;
        }
        uint64_t v122 = v17;
        int64_t v123 = v36;
        int64_t v124 = v25;
        uint64_t v37 = v119;
        uint64_t v38 = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v119, v24);
        uint64_t v40 = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v37, v39);
        MutableCollection<>._insertionSort(within:sortedEnd:by:)( (uint64_t)&v122,  (void (*)(char *))&v124,  v115,  v116,  v37,  v38,  v40);
      }

      uint64_t v20 = v118;
      if (v36 < v17) {
        goto LABEL_106;
      }
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v118)) {
        uint64_t v20 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v20[2]->isa + 1,  1,  (uint64_t)v20);
      }
      unint64_t v42 = (unint64_t)v20[2];
      unint64_t v41 = (unint64_t)v20[3];
      unint64_t v43 = v42 + 1;
      if (v42 >= v41 >> 1) {
        uint64_t v20 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v41 > 1),  v42 + 1,  1,  (uint64_t)v20);
      }
      void v20[2] = (__objc2_class *)v43;
      int8x16_t v44 = v20 + 4;
      int8x16_t v45 = &v20[2 * v42 + 4];
      char *v45 = (__objc2_class *)v17;
      v45[1] = (__objc2_class *)v36;
      if (v42)
      {
        while (1)
        {
          unint64_t v46 = v43 - 1;
          if (v43 >= 4)
          {
            uint64x2_t v51 = &v44[2 * v43];
            uint64_t v52 = (uint64_t)*(v51 - 8);
            uint64_t v53 = (uint64_t)*(v51 - 7);
            BOOL v57 = __OFSUB__(v53, v52);
            uint64_t v54 = v53 - v52;
            if (v57)
            {
              __break(1u);
LABEL_108:
              __break(1u);
LABEL_109:
              __break(1u);
LABEL_110:
              __break(1u);
LABEL_111:
              __break(1u);
LABEL_112:
              __break(1u);
LABEL_113:
              __break(1u);
LABEL_114:
              __break(1u);
LABEL_115:
              __break(1u);
LABEL_116:
              __break(1u);
LABEL_117:
              unint64_t v105 = 688LL;
LABEL_104:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  v105,  0);
            }

            uint64_t v56 = (uint64_t)*(v51 - 6);
            uint64_t v55 = (uint64_t)*(v51 - 5);
            BOOL v57 = __OFSUB__(v55, v56);
            int64_t v49 = v55 - v56;
            char v50 = v57;
            if (v57) {
              goto LABEL_108;
            }
            unint64_t v58 = v43 - 2;
            uint64x2_t v59 = &v44[2 * v43 - 4];
            uint64x2_t v61 = *v59;
            uint32x4_t v60 = v59[1];
            BOOL v57 = __OFSUB__(v60, v61);
            uint64_t v62 = (char *)v60 - (char *)v61;
            if (v57) {
              goto LABEL_109;
            }
            BOOL v57 = __OFADD__(v49, v62);
            uint64_t v63 = v49 + v62;
            if (v57) {
              goto LABEL_111;
            }
            if (v63 >= v54)
            {
              unint64_t v81 = &v44[2 * v46];
              uint64_t v83 = *v81;
              unint64_t v82 = v81[1];
              BOOL v57 = __OFSUB__(v82, v83);
              int64_t v84 = (char *)v82 - (char *)v83;
              if (v57) {
                goto LABEL_121;
              }
              BOOL v74 = v49 < v84;
              goto LABEL_74;
            }
          }

          else
          {
            if (v43 != 3)
            {
              unint64_t v75 = v20[4];
              uint64_t v76 = v20[5];
              BOOL v57 = __OFSUB__(v76, v75);
              int64_t v68 = (char *)v76 - (char *)v75;
              char v69 = v57;
              goto LABEL_68;
            }

            uint8x16_t v48 = v20[4];
            int8x16_t v47 = v20[5];
            BOOL v57 = __OFSUB__(v47, v48);
            int64_t v49 = (char *)v47 - (char *)v48;
            char v50 = v57;
          }

          if ((v50 & 1) != 0) {
            goto LABEL_110;
          }
          unint64_t v58 = v43 - 2;
          uint16x8_t v64 = &v44[2 * v43 - 4];
          unsigned int v66 = *v64;
          unint64_t v65 = v64[1];
          BOOL v67 = __OFSUB__(v65, v66);
          int64_t v68 = (char *)v65 - (char *)v66;
          char v69 = v67;
          if (v67) {
            goto LABEL_112;
          }
          uint64x2_t v70 = &v44[2 * v46];
          uint64x2_t v72 = *v70;
          uint32x4_t v71 = v70[1];
          BOOL v57 = __OFSUB__(v71, v72);
          int64_t v73 = (char *)v71 - (char *)v72;
          if (v57) {
            goto LABEL_114;
          }
          if (__OFADD__(v68, v73)) {
            goto LABEL_116;
          }
          if (v68 + v73 >= v49)
          {
            BOOL v74 = v49 < v73;
LABEL_74:
            if (v74) {
              unint64_t v46 = v58;
            }
            goto LABEL_76;
          }

uint64_t zip<A, B>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  v15[0] = a3;
  v15[1] = a4;
  v15[2] = a5;
  v15[3] = a6;
  uint64_t v13 = type metadata accessor for Zip2Sequence(0LL, (uint64_t)v15);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 16LL))( a7 + *(int *)(v13 + 52),  a2,  a4);
}

uint64_t Zip2Sequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)v18 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v7 + 16);
  MEMORY[0x1895F8858](v7);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 32))( (char *)v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v2,  v10);
  uint64_t v13 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t, uint64_t))(v13 + 32))(v10, v13);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 32))(v9, v2 + *(int *)(a1 + 52), v5);
  uint64_t v14 = *(void *)(a1 + 40);
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v14 + 32);
  v18[0] = v10;
  v18[1] = v5;
  v18[2] = v13;
  v18[3] = v14;
  uint64_t v16 = type metadata accessor for Zip2Sequence.Iterator(0LL, (uint64_t)v18);
  uint64_t result = v15(v5, v14);
  *(_BYTE *)(a2 + *(int *)(v16 + 56)) = 0;
  return result;
}

uint64_t Zip2Sequence.Iterator.next()@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v3 = v2;
  uint16x8_t v64 = a2;
  uint64_t v5 = *(const char **)(a1 + 40);
  uint64_t v59 = *(void *)(a1 + 24);
  uint32x4_t v60 = v5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v59,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v58 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v56 = *(void *)(v58 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v58);
  uint64_t v62 = (char *)&v49 - v10;
  uint64_t v61 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](v9);
  BOOL v57 = (char *)&v49 - v11;
  uint64_t v12 = *(const char **)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 16);
  unint64_t v14 = swift_getAssociatedTypeWitness( 255LL,  v12,  v13,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v17 = type metadata accessor for Optional(0LL, v14, v15, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v49 - v20;
  uint64_t v63 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = *(int *)(a1 + 56);
  if (*(_BYTE *)(v3 + v23) == 1)
  {
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v14, AssociatedTypeWitness, 0LL, 0LL);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 56))( v64,  1LL,  1LL,  TupleTypeMetadata2);
  }

  uint64_t v26 = v3;
  uint64_t v53 = (char *)&v49 - v22;
  uint64_t v54 = v23;
  unint64_t v55 = AssociatedTypeWitness;
  uint64_t v52 = associated type descriptor for Sequence.Iterator;
  unint64_t v27 = swift_getAssociatedTypeWitness( 255LL,  v12,  v13,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64x2_t v51 = &associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v12,  v13,  v27,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int64_t v29 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v30 = swift_checkMetadataState(0LL, v27);
  uint64_t v31 = v26;
  v29(v30, AssociatedConformanceWitness);
  uint64_t v32 = v63;
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v63 + 48))(v21, 1LL, v14) == 1)
  {
    (*(void (**)(char *, uint64_t))(v18 + 8))(v21, v17);
    uint64_t v33 = v55;
LABEL_7:
    *(_BYTE *)(v31 + v54) = 1;
    unint64_t v43 = swift_getTupleTypeMetadata2(0LL, v14, v33, 0LL, 0LL);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t *))(*(v43 - 1) + 56))( v64,  1LL,  1LL,  v43);
  }

  int64x2_t v34 = v53;
  char v50 = *(void (**)(char *, char *, unint64_t))(v32 + 32);
  v50(v53, v21, v14);
  uint64_t v36 = v59;
  BOOL v35 = v60;
  unint64_t v37 = swift_getAssociatedTypeWitness( 255LL,  v60,  v59,  (uint64_t)&protocol requirements base descriptor for Sequence,  v52);
  unint64_t v38 = swift_getAssociatedConformanceWitness( (uint64_t)v35,  v36,  v37,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)v51);
  uint64_t v39 = *(void (**)(unint64_t *, unint64_t))(v38 + 16);
  uint64_t v40 = swift_checkMetadataState(0LL, v37);
  unint64_t v41 = v62;
  v39(v40, v38);
  uint64_t v42 = v61;
  uint64_t v33 = v55;
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v61 + 48))(v41, 1LL, v55) == 1)
  {
    (*(void (**)(char *, unint64_t))(v32 + 8))(v34, v14);
    (*(void (**)(char *, uint64_t))(v56 + 8))(v41, v58);
    goto LABEL_7;
  }

  int8x16_t v44 = *(void (**)(char *, char *, uint64_t))(v42 + 32);
  int8x16_t v45 = v57;
  v44(v57, v41, v33);
  unint64_t v46 = swift_getTupleTypeMetadata2(0LL, v14, v33, 0LL, 0LL);
  int8x16_t v47 = v64;
  uint8x16_t v48 = &v64[*((int *)v46 + 12)];
  v50(v64, v34, v14);
  v44(v48, v45, v33);
  return (*(uint64_t (**)(char *, void, uint64_t, unint64_t *))(*(v46 - 1) + 56))(v47, 0LL, 1LL, v46);
}

uint64_t MutableCollection<>._insertionSort(within:sortedEnd:by:)( uint64_t a1, void (*a2)(char *), uint64_t (*a3)(char *, char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v68 = a7;
  uint64_t v8 = a5;
  unint64_t v79 = a3;
  uint64_t v80 = a4;
  uint64_t v88 = a2;
  uint64_t v10 = *(void *)(a6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v10 + 8),  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v78 = (char *)&v64 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unsigned int v77 = (char *)&v64 - v15;
  uint64_t v87 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v14);
  int64_t v84 = (char *)&v64 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unsigned int v66 = (char *)&v64 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v86 = (char *)&v64 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v83 = (char *)&v64 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v26 = (char *)&v64 - v25;
  unint64_t v81 = *(void (**)(char *, void (*)(void), unint64_t))(v18 + 16);
  v81((char *)&v64 - v25, (void (*)(void))v88, v17);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v10,  v8,  v17,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v29 = *(int *)(type metadata accessor for Range(0LL, v17, AssociatedConformanceWitness, v28) + 36);
  uint64_t v67 = a1;
  uint64_t v30 = a1 + v29;
  uint64_t v31 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v32 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v31 + 8);
  unint64_t v65 = v26;
  uint64_t v64 = v30;
  unint64_t v75 = v32;
  uint64_t v76 = v31;
  if ((((uint64_t (*)(char *))v32)(v26) & 1) != 0)
  {
    uint64_t v33 = *(void (**)(char *, unint64_t))(v18 + 8);
    int64x2_t v34 = v65;
  }

  else
  {
    uint64_t v72 = a6;
    uint32x4_t v71 = *(void (**)(char *, uint64_t, uint64_t))(a6 + 32);
    uint64_t v82 = v10;
    uint64x2_t v70 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v10 + 80);
    int64x2_t v34 = v65;
    uint64_t v36 = v83;
    unint64_t v74 = v17;
    uint64_t v69 = v18;
    while (2)
    {
      v81(v36, (void (*)(void))v34, v17);
      unint64_t v37 = v86;
      unint64_t v85 = *(void (**)(char *, uint64_t, uint64_t))(v87 + 16);
      while (1)
      {
        unint64_t v38 = v84;
        v85(v84, v92, v8);
        v71(v36, v8, v72);
        int64_t v73 = *(void (**)(char *, uint64_t))(v87 + 8);
        v73(v38, v8);
        uint64_t v39 = v82;
        uint64_t v40 = v70;
        unint64_t v41 = (void (*)(_BYTE *, void))v70(v91, v36, v8, v82);
        uint64_t v88 = *(void (**)(char *))(v11 + 16);
        uint64_t v42 = v77;
        v88(v77);
        v41(v91, 0LL);
        uint64_t v43 = v8;
        int8x16_t v44 = (void (*)(_BYTE *, void))v40(v91, v37, v8, v39);
        int8x16_t v45 = v78;
        v88(v78);
        v44(v91, 0LL);
        uint64_t v46 = v90;
        char v47 = v79(v42, v45);
        uint64_t v90 = v46;
        if (v46)
        {
          uint32x4_t v60 = *(void (**)(char *, unint64_t))(v11 + 8);
          unint64_t v61 = AssociatedTypeWitness;
          v60(v45, AssociatedTypeWitness);
          v60(v42, v61);
          uint64_t v62 = *(void (**)(char *, unint64_t))(v69 + 8);
          unint64_t v63 = v74;
          v62(v86, v74);
          v62(v83, v63);
          return ((uint64_t (*)(char *, unint64_t))v62)(v65, v63);
        }

        char v48 = v47;
        uint64_t v49 = v11;
        char v50 = *(void (**)(char *, unint64_t))(v11 + 8);
        unint64_t v51 = AssociatedTypeWitness;
        v50(v45, AssociatedTypeWitness);
        v50(v42, v51);
        if ((v48 & 1) == 0) {
          break;
        }
        uint64_t v52 = v69;
        uint64_t v53 = *(void (**)(char *, char *, unint64_t))(v69 + 32);
        uint64_t v54 = v66;
        uint64_t v36 = v83;
        unint64_t v55 = v74;
        v53(v66, v83, v74);
        unint64_t v37 = v86;
        (*(void (**)(char *, char *, uint64_t))(v68 + 64))(v54, v86, v43);
        uint64_t v33 = *(void (**)(char *, unint64_t))(v52 + 8);
        v33(v54, v55);
        v53(v36, v37, v55);
        v81(v54, (void (*)(void))v36, v55);
        char v56 = v75(v54, v67, v55, v76);
        BOOL v57 = v54;
        uint64_t v8 = v43;
        v33(v57, v55);
        uint64_t v11 = v49;
        if ((v56 & 1) != 0)
        {
          unint64_t v58 = v74;
          goto LABEL_11;
        }
      }

      uint64_t v33 = *(void (**)(char *, unint64_t))(v69 + 8);
      unint64_t v58 = v74;
      v33(v86, v74);
      uint64_t v8 = v43;
LABEL_11:
      uint64_t v36 = v83;
      v33(v83, v58);
      uint64_t v59 = v84;
      v85(v84, v92, v8);
      int64x2_t v34 = v65;
      (*(void (**)(char *, uint64_t))(v82 + 192))(v65, v8);
      v73(v59, v8);
      unint64_t v17 = v58;
      if ((v75(v34, v64, v58, v76) & 1) == 0) {
        continue;
      }
      break;
    }
  }

  return ((uint64_t (*)(char *, unint64_t))v33)(v34, v17);
}

uint64_t MutableCollection<>._insertionSort(within:by:)( uint64_t a1, uint64_t (*a2)(char *, char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = a3;
  uint64_t v21 = a6;
  uint64_t v19 = a2;
  uint64_t v9 = *(void *)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (void (*)(char *))((char *)&v18 - v12);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v16 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                         + 8LL))( a1,  a1 + *(int *)(v16 + 36),  AssociatedTypeWitness);
  if ((result & 1) == 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 184))(a1, a4, v9);
    MutableCollection<>._insertionSort(within:sortedEnd:by:)(a1, v13, v19, v20, a4, a5, v21);
    return (*(uint64_t (**)(void (*)(char *), unint64_t))(v11 + 8))( v13,  AssociatedTypeWitness);
  }

  return result;
}

uint64_t MutableCollection<>._reverse(within:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = a3;
  uint64_t v29 = a4;
  uint64_t v6 = *(const char **)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v24 - v11;
  uint64_t v25 = v13;
  uint64_t v14 = *(void (**)(char *, uint64_t, unint64_t))(v13 + 16);
  v14((char *)&v24 - v11, a1, AssociatedTypeWitness);
  unint64_t v27 = v6;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v17 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  v14(v10, a1 + *(int *)(v17 + 36), AssociatedTypeWitness);
  uint64_t v18 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v26 = AssociatedConformanceWitness;
  if ((v18(v12, v10, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) != 0)
  {
    uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(v28 + 40);
    uint64_t v20 = *(void (**)(char *, char *, uint64_t, uint64_t))(v29 + 64);
    uint64_t v21 = (void (*)(char *, uint64_t, const char *))*((void *)v27 + 24);
    do
    {
      v19(v10, a2, v28);
      v20(v12, v10, a2, v29);
      v21(v12, a2, v27);
    }

    while ((v18(v12, v10, AssociatedTypeWitness, v26) & 1) != 0);
  }

  uint64_t v22 = *(void (**)(char *, unint64_t))(v25 + 8);
  v22(v10, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, unint64_t))v22)(v12, AssociatedTypeWitness);
}

uint64_t _merge<A>(low:mid:high:buffer:by:)( char *a1, char *a2, unint64_t a3, char *a4, uint64_t (*a5)(uint64_t, uint64_t), uint64_t a6, uint64_t a7)
{
  uint64_t v71 = a6;
  uint64_t v72 = a5;
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = MEMORY[0x1895F8858]((char *)&v63 - v15);
  uint64_t v20 = (char *)&v63 - v19;
  uint64_t v73 = v21;
  uint64_t v70 = *(void *)(v21 + 72);
  if (!v70) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  int64_t v22 = a2 - a1;
  if (a2 - a1 == 0x8000000000000000LL && v70 == -1
    || (int64_t v23 = a3 - (void)a2, a3 - (void)a2 == 0x8000000000000000LL) && v70 == -1)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }

  uint64_t v74 = v7;
  uint64_t v64 = v18;
  uint64_t v24 = v70;
  uint64_t v25 = v22 / v70;
  unsigned int v77 = a1;
  uint64_t v76 = a4;
  uint64_t v26 = v23 / v70;
  if (v22 / v24 >= v23 / v24)
  {
    uint64_t v69 = v17;
    UnsafeMutablePointer.moveInitialize(from:count:)(a2, v23 / v70, a4, a7);
    uint64_t v28 = &a4[v26 * v24];
    unint64_t v75 = v28;
    unsigned int v77 = a2;
    BOOL v29 = v26 * v24 < 1 || a1 >= a2;
    uint64_t v30 = v74;
    if (!v29)
    {
      uint64_t v42 = -v24;
      uint64_t v43 = *(char **)(v73 + 16);
      uint64_t v67 = a1;
      uint64_t v68 = v43;
      uint64_t v44 = v64;
      uint64_t v65 = v42;
      unsigned int v66 = a4;
      while (1)
      {
        int8x16_t v45 = v68;
        ((void (*)(uint64_t, char *, uint64_t))v68)(v44, &v28[v42], a7);
        uint64_t v70 = (uint64_t)a2;
        uint64_t v46 = &a2[v42];
        uint64_t v47 = v44;
        uint64_t v48 = v42;
        uint64_t v49 = v69;
        ((void (*)(uint64_t, char *, uint64_t))v45)(v69, v46, a7);
        char v50 = v72(v44, v49);
        uint64_t v74 = v30;
        if (v30) {
          break;
        }
        char v51 = v50;
        uint64_t v52 = (char *)(a3 + v48);
        uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v73 + 8);
        v53(v49, a7);
        v53(v47, a7);
        uint64_t v44 = v47;
        if ((v51 & 1) != 0)
        {
          unint64_t v54 = a3;
          BOOL v27 = a3 >= v70;
          a3 += v48;
          if (v27 && (unint64_t)v52 < v70)
          {
            uint64_t v30 = v74;
            if (v54 != v70) {
              swift_arrayInitWithTakeBackToFront(v52, v46, 1LL, a7);
            }
          }

          else
          {
            swift_arrayInitWithTakeFrontToBack(v52, v46, 1LL, a7);
            uint64_t v30 = v74;
          }

          uint64_t v42 = v65;
          unint64_t v58 = v66;
          v77 += v65;
          uint64_t v59 = v67;
        }

        else
        {
          unint64_t v55 = (unint64_t)v75;
          char v56 = &v75[v48];
          v75 += v48;
          unint64_t v57 = a3;
          BOOL v27 = a3 >= v55;
          a3 += v48;
          if (v27 && (unint64_t)v52 < v55)
          {
            uint64_t v30 = v74;
            uint64_t v46 = (char *)v70;
            if (v57 != v55) {
              swift_arrayInitWithTakeBackToFront(v52, v56, 1LL, a7);
            }
          }

          else
          {
            swift_arrayInitWithTakeFrontToBack(v52, v56, 1LL, a7);
            uint64_t v46 = (char *)v70;
            uint64_t v30 = v74;
          }

          unint64_t v58 = v66;
          uint64_t v59 = v67;
          uint64_t v42 = v65;
        }

        uint64_t v28 = v75;
        if (v75 > v58)
        {
          a2 = v46;
          if (v46 > v59) {
            continue;
          }
        }

        goto LABEL_58;
      }

      unint64_t v61 = *(void (**)(uint64_t, uint64_t))(v73 + 8);
      v61(v49, a7);
      v61(v47, a7);
    }
  }

  else
  {
    uint64_t v69 = v16;
    UnsafeMutablePointer.moveInitialize(from:count:)(a1, v22 / v70, a4, a7);
    uint64_t v68 = &a4[v25 * v24];
    unint64_t v75 = v68;
    BOOL v27 = v25 * v24 < 1 || (unint64_t)a2 >= a3;
    if (!v27)
    {
      uint64_t v31 = v74;
      uint64_t v67 = *(char **)(v73 + 16);
      uint64_t v32 = v69;
      while (1)
      {
        uint64_t v33 = v67;
        ((void (*)(char *, char *, uint64_t))v67)(v20, a2, a7);
        ((void (*)(uint64_t, char *, uint64_t))v33)(v32, a4, a7);
        char v34 = v72((uint64_t)v20, v32);
        uint64_t v74 = v31;
        if (v31) {
          break;
        }
        char v35 = v34;
        unint64_t v36 = a3;
        unint64_t v37 = *(void (**)(uint64_t, uint64_t))(v73 + 8);
        v37(v32, a7);
        v37((uint64_t)v20, a7);
        unint64_t v38 = v77;
        if ((v35 & 1) != 0)
        {
          uint64_t v39 = v70;
          unint64_t v40 = (unint64_t)&a2[v70];
          if (v77 < a2 || (unint64_t)v77 >= v40)
          {
            swift_arrayInitWithTakeFrontToBack(v77, a2, 1LL, a7);
          }

          else if (v77 == a2)
          {
            unint64_t v38 = a2;
          }

          else
          {
            swift_arrayInitWithTakeBackToFront(v77, a2, 1LL, a7);
          }
        }

        else
        {
          uint64_t v39 = v70;
          unint64_t v41 = &v76[v70];
          if (v77 < v76 || v77 >= v41)
          {
            swift_arrayInitWithTakeFrontToBack(v77, v76, 1LL, a7);
          }

          else if (v77 != v76)
          {
            swift_arrayInitWithTakeBackToFront(v77, v76, 1LL, a7);
          }

          uint64_t v76 = v41;
          unint64_t v40 = (unint64_t)a2;
        }

        unsigned int v77 = &v38[v39];
        a4 = v76;
        if (v76 < v68)
        {
          a2 = (char *)v40;
          BOOL v27 = v40 >= v36;
          a3 = v36;
          uint64_t v31 = v74;
          if (!v27) {
            continue;
          }
        }

        goto LABEL_58;
      }

      uint32x4_t v60 = *(void (**)(uint64_t, uint64_t))(v73 + 8);
      v60(v32, a7);
      v60((uint64_t)v20, a7);
    }
  }

char *$defer #1 <A>() in _merge<A>(low:mid:high:buffer:by:)(char **a1, char **a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a4 - 8) + 72LL);
  if (!v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  uint64_t v5 = *a3 - (void)*a2;
  if (v4 == -1 && v5 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  return UnsafeMutablePointer.moveInitialize(from:count:)(*a2, v5 / v4, *a1, a4);
}

Swift::Int __swiftcall _minimumMergeRunLength(_:)(Swift::Int result)
{
  if (result >= 64)
  {
    char v1 = 58 - __clz(result);
    uint64_t v2 = -1LL << v1;
    unint64_t v3 = (unint64_t)result >> v1;
    BOOL v4 = (result & ~v2) != 0;
    uint64_t result = v3 + v4;
    if (__OFADD__(v3, v4)) {
      __break(1u);
    }
  }

  return result;
}

unint64_t Int.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

uint64_t _findNextRun<A>(in:from:by:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, char *), uint64_t a5, uint64_t a6)
{
  unint64_t v104 = a4;
  uint64_t v105 = a5;
  uint64_t v86 = a1;
  uint64_t v113 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v97 = (char *)&v86 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(*(void *)(v10 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 8),  v12,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v88 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v96 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v95 = (char *)&v86 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v87 = (char *)&v86 - v18;
  MEMORY[0x1895F8858](v17);
  int64_t v91 = (char *)&v86 - v19;
  unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  a6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v21 = *(void *)(v20 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v94 = (char *)&v86 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int64_t v93 = (char *)&v86 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v103 = (char *)&v86 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v86 - v29;
  uint64_t v31 = MEMORY[0x1895F8858](v28);
  uint64_t v33 = (char *)&v86 - v32;
  MEMORY[0x1895F8858](v31);
  char v35 = (char *)&v86 - v34;
  uint64_t v101 = *(void (**)(char *, uint64_t, unint64_t))(v21 + 16);
  v101((char *)&v86 - v34, a3, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 184))(a3, a6, v11);
  unint64_t v36 = *(void (**)(uint64_t, uint64_t))(v11 + 72);
  uint64_t v106 = a2;
  uint64_t v100 = v36;
  v36(a6, v11);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  a6,  v20,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v38 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  int64_t v111 = v33;
  unint64_t v98 = v38;
  unint64_t v99 = AssociatedConformanceWitness;
  LOBYTE(a2) = ((uint64_t (*)(char *, char *, unint64_t))v38)(v33, v30, v20);
  uint64_t v39 = *(void (**)(char *, unint64_t))(v21 + 8);
  uint64_t v102 = v30;
  unint64_t v40 = v30;
  unint64_t v41 = v39;
  v39(v40, v20);
  if ((a2 & 1) != 0)
  {
    uint64_t v92 = v21;
    uint64_t v42 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v11 + 80);
    uint64_t v112 = (uint64_t (*)(_BYTE *, char *, uint64_t, uint64_t))v42(v115, v111, a6, v11);
    uint64_t v43 = (void (*)(char *))*((void *)v88 + 2);
    v43(v91);
    ((void (*)(_BYTE *, void))v112)(v115, 0LL);
    uint64_t v112 = v42;
    uint64_t v44 = (void (*)(_BYTE *, void))v42(v115, v35, a6, v11);
    int8x16_t v45 = v87;
    uint64_t v46 = v43;
    v43(v87);
    v44(v115, 0LL);
    v41(v35, v20);
    uint64_t v47 = v116;
    int v48 = v104(v91, v45);
    uint64_t v49 = v41;
    char v50 = v35;
    if (v47)
    {
      char v51 = (void (*)(char *, unint64_t))*((void *)v88 + 1);
      unint64_t v52 = AssociatedTypeWitness;
      v51(v45, AssociatedTypeWitness);
      v51(v91, v52);
      v49(v111, v20);
    }

    else
    {
      int v89 = v48;
      uint64_t v109 = v46;
      unint64_t v110 = v49;
      uint64_t v90 = a6;
      uint64_t v116 = 0LL;
      unint64_t v55 = (void (*)(char *, unint64_t))*((void *)v88 + 1);
      unint64_t v56 = AssociatedTypeWitness;
      v55(v45, AssociatedTypeWitness);
      uint64_t v88 = v55;
      v55(v91, v56);
      uint64_t v114 = v11;
      int64_t v91 = *(char **)(v11 + 192);
      unint64_t v57 = v111;
      int64_t v108 = v35;
      while (1)
      {
        unint64_t v58 = (void (*)(char *, char *, unint64_t))v101;
        v101(v50, (uint64_t)v57, v20);
        uint64_t v59 = v106;
        uint64_t v60 = v90;
        uint64_t v61 = v114;
        ((void (*)(char *, uint64_t, uint64_t))v91)(v57, v90, v114);
        uint64_t v62 = v102;
        v58(v102, v57, v20);
        uint64_t v63 = v103;
        v100(v60, v61);
        char v64 = v98(v62, v63, v20, v99);
        uint64_t v65 = v63;
        unsigned int v66 = v110;
        v110(v65, v20);
        uint64_t v67 = v62;
        uint64_t v68 = v60;
        v66(v67, v20);
        uint64_t v69 = v97;
        uint64_t v70 = v113;
        (*(void (**)(char *, uint64_t, uint64_t))(v113 + 16))(v97, v59, v68);
        if ((v64 & 1) == 0)
        {
          (*(void (**)(char *, uint64_t))(v70 + 8))(v69, v68);
          v66(v108, v20);
          (*(void (**)(uint64_t, char *, unint64_t))(v92 + 32))(v86, v57, v20);
          goto LABEL_12;
        }

        uint64_t v71 = v93;
        v58(v93, v57, v20);
        uint64_t v72 = v68;
        uint64_t v73 = (void (*)(_BYTE *, void))v112(v115, v71, v68, v114);
        uint64_t v74 = v95;
        unint64_t v75 = AssociatedTypeWitness;
        v109(v95);
        v73(v115, 0LL);
        v66(v71, v20);
        uint64_t v76 = v94;
        uint64_t v87 = *(char **)(v92 + 32);
        ((void (*)(char *, char *, unint64_t))v87)(v94, v108, v20);
        unsigned int v77 = (void (*)(_BYTE *, void))v112(v115, v76, v72, v114);
        uint64_t v78 = v96;
        v109(v96);
        v77(v115, 0LL);
        v110(v76, v20);
        (*(void (**)(char *, uint64_t))(v113 + 8))(v69, v72);
        uint64_t v79 = v116;
        int v80 = v104(v74, v78);
        uint64_t v116 = v79;
        if (v79) {
          break;
        }
        int v81 = v80;
        uint64_t v82 = v78;
        uint64_t v83 = v88;
        v88(v82, v75);
        v83(v74, v75);
        unint64_t v57 = v111;
        char v50 = v108;
        if (((v89 ^ v81) & 1) != 0)
        {
          ((void (*)(uint64_t, char *, unint64_t))v87)(v86, v111, v20);
LABEL_12:
          char v53 = v89;
          return v53 & 1;
        }
      }

      int64_t v84 = v78;
      unint64_t v85 = v88;
      v88(v84, v75);
      v85(v74, v75);
      v110(v111, v20);
    }
  }

  else
  {
    v41(v35, v20);
    (*(void (**)(uint64_t, char *, unint64_t))(v21 + 32))(v86, v111, v20);
    char v53 = 0;
  }

  return v53 & 1;
}

uint64_t UnsafeMutableBufferPointer._mergeRuns(_:at:buffer:by:)( uint64_t *a1, unint64_t a2, char *a3, uint64_t (*a4)(uint64_t, uint64_t), uint64_t a5, uint64_t a6)
{
  unint64_t v8 = a2 - 1;
  if (__OFSUB__(a2, 1LL))
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v24 = v7;
  uint64_t v13 = *a1;
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(a2 - 1, 1, *a1);
  uint64_t v14 = v13 + 32;
  uint64_t v15 = *(void *)(v13 + 32 + 16 * v8);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(a2, 1, v13);
  uint64_t v16 = *v6;
  if (!*v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Sort.swift",  16LL,  2,  0x21BuLL,  0);
  }
  uint64_t v17 = *(void *)(v14 + 16 * a2 + 8);
  _merge<A>(low:mid:high:buffer:by:)( (char *)(v16 + *(void *)(*(void *)(*(void *)(a6 + 16) - 8LL) + 72LL) * v15),  (char *)(v16 + *(void *)(*(void *)(*(void *)(a6 + 16) - 8LL) + 72LL) * *(void *)(v14 + 16 * a2)),  v16 + *(void *)(*(void *)(*(void *)(a6 + 16) - 8LL) + 72LL) * v17,  a3,  a4,  a5,  *(void *)(a6 + 16));
  if (!v24)
  {
    if (v17 >= v15)
    {
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v13);
      *a1 = v13;
      if (!isUniquelyReferenced_nonNull_native)
      {
        uint64_t v13 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew()(v13);
        *a1 = v13;
      }

      specialized Array._checkSubscript_mutating(_:)(v8, v13);
      unint64_t v19 = v13 + 16 * v8;
      *(void *)(v19 + 32) = v15;
      *(void *)(v19 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = v17;
      *a1 = v13;
      Array.remove(at:)(a2, (uint64_t)&unk_189B86CB0, (uint64_t)v23);
      return 1LL;
    }

Swift::Int UnsafeMutableBufferPointer._mergeTopRuns(_:buffer:by:)( uint64_t *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *a1;
  if (*(void *)(*a1 + 16) < 2uLL) {
    return 1LL;
  }
  while (1)
  {
    Swift::Int result = Array._getCount()();
    unint64_t v13 = result - 1;
    if (__OFSUB__(result, 1LL)) {
      break;
    }
    unint64_t v14 = result - 4;
    if ((uint64_t)v13 < 3)
    {
      if (result == 3)
      {
        unint64_t v15 = 0LL;
        unint64_t v16 = *(void *)(v6 + 16);
LABEL_14:
        if (v15 >= v16) {
          goto LABEL_40;
        }
        uint64_t v32 = v6 + 32;
        uint64_t v33 = (uint64_t *)(v6 + 32 + 16 * v15);
        uint64_t v35 = *v33;
        uint64_t v34 = v33[1];
        BOOL v25 = __OFSUB__(v34, v35);
        uint64_t v36 = v34 - v35;
        if (v25) {
          goto LABEL_46;
        }
        if (result - 2 >= v16) {
          goto LABEL_40;
        }
        unint64_t v37 = (uint64_t *)(v32 + 16 * (result - 2));
        uint64_t v39 = *v37;
        uint64_t v38 = v37[1];
        BOOL v25 = __OFSUB__(v38, v39);
        uint64_t v40 = v38 - v39;
        if (v25) {
          goto LABEL_47;
        }
        if (v13 >= v16) {
          goto LABEL_40;
        }
        unint64_t v41 = (uint64_t *)(v32 + 16 * v13);
        uint64_t v43 = *v41;
        uint64_t v42 = v41[1];
        BOOL v25 = __OFSUB__(v42, v43);
        uint64_t v44 = v42 - v43;
        if (v25) {
          goto LABEL_48;
        }
        if (__OFADD__(v40, v44)) {
          goto LABEL_51;
        }
        if (v40 + v44 >= v36)
        {
          if (v36 < v44) {
            unint64_t v13 = result - 2;
          }
          goto LABEL_37;
        }
      }

      unint64_t v45 = result - 2;
      if (__OFSUB__(v13, 1LL)) {
        goto LABEL_49;
      }
      if ((v45 & 0x8000000000000000LL) != 0) {
        goto LABEL_40;
      }
      unint64_t v46 = *(void *)(v6 + 16);
      if (v45 >= v46) {
        goto LABEL_40;
      }
      uint64_t v47 = (uint64_t *)(v6 + 32 + 16 * v45);
      uint64_t v49 = *v47;
      uint64_t v48 = v47[1];
      BOOL v25 = __OFSUB__(v48, v49);
      uint64_t v50 = v48 - v49;
      if (v25) {
        goto LABEL_50;
      }
      if (v13 >= v46) {
LABEL_40:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      char v51 = (uint64_t *)(v6 + 32 + 16 * v13);
      uint64_t v53 = *v51;
      uint64_t v52 = v51[1];
      BOOL v25 = __OFSUB__(v52, v53);
      uint64_t v54 = v52 - v53;
      if (v25) {
        goto LABEL_52;
      }
      if (v54 < v50) {
        return 1LL;
      }
      goto LABEL_37;
    }

    unint64_t v16 = *(void *)(v6 + 16);
    if (v14 >= v16) {
      goto LABEL_40;
    }
    uint64_t v17 = v6 + 32;
    uint64_t v18 = (uint64_t *)(v6 + 32 + 16 * v14);
    uint64_t v20 = *v18;
    uint64_t v19 = v18[1];
    uint64_t v21 = v19 - v20;
    if (__OFSUB__(v19, v20)) {
      goto LABEL_42;
    }
    unint64_t v15 = result - 3;
    if (result - 3 >= v16) {
      goto LABEL_40;
    }
    uint64_t v22 = (uint64_t *)(v17 + 16 * v15);
    uint64_t v24 = *v22;
    uint64_t v23 = v22[1];
    BOOL v25 = __OFSUB__(v23, v24);
    uint64_t v26 = v23 - v24;
    if (v25) {
      goto LABEL_43;
    }
    if (result - 2 >= v16) {
      goto LABEL_40;
    }
    uint64_t v27 = (uint64_t *)(v17 + 16 * (result - 2));
    uint64_t v29 = *v27;
    uint64_t v28 = v27[1];
    BOOL v25 = __OFSUB__(v28, v29);
    uint64_t v30 = v28 - v29;
    if (v25) {
      goto LABEL_44;
    }
    BOOL v25 = __OFADD__(v26, v30);
    uint64_t v31 = v26 + v30;
    if (v25) {
      goto LABEL_45;
    }
    if (v31 < v21) {
      goto LABEL_14;
    }
    if (v13 >= v16) {
      goto LABEL_40;
    }
    unint64_t v55 = (uint64_t *)(v17 + 16 * v13);
    uint64_t v57 = *v55;
    uint64_t v56 = v55[1];
    BOOL v25 = __OFSUB__(v56, v57);
    uint64_t v58 = v56 - v57;
    if (v25) {
      goto LABEL_53;
    }
    if (v26 < v58) {
      unint64_t v13 = result - 2;
    }
LABEL_37:
    UnsafeMutableBufferPointer._mergeRuns(_:at:buffer:by:)(a1, v13, a2, a3, a4, a5);
    if (!v5)
    {
      uint64_t v6 = *a1;
      if (Array._getCount()() > 1) {
        continue;
      }
    }

    return 1LL;
  }

  __break(1u);
LABEL_42:
  __break(1u);
LABEL_43:
  __break(1u);
LABEL_44:
  __break(1u);
LABEL_45:
  __break(1u);
LABEL_46:
  __break(1u);
LABEL_47:
  __break(1u);
LABEL_48:
  __break(1u);
LABEL_49:
  __break(1u);
LABEL_50:
  __break(1u);
LABEL_51:
  __break(1u);
LABEL_52:
  __break(1u);
LABEL_53:
  __break(1u);
  return result;
}

Swift::Int UnsafeMutableBufferPointer._finalizeRuns(_:buffer:by:)( uint64_t *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, uint64_t a5)
{
  if (*(void *)(*a1 + 16) < 2uLL) {
    return 1LL;
  }
  while (1)
  {
    Swift::Int result = Array._getCount()();
    if (__OFSUB__(result, 1LL)) {
      break;
    }
    UnsafeMutableBufferPointer._mergeRuns(_:at:buffer:by:)(a1, result - 1, a2, a3, a4, a5);
    if (v5 || Array._getCount()() <= 1) {
      return 1LL;
    }
  }

  __break(1u);
  return result;
}

uint64_t StaticString._startPtrOrData.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*StaticString._startPtrOrData.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t StaticString._utf8CodeUnitCount.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t StaticString._utf8CodeUnitCount.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*StaticString._utf8CodeUnitCount.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t StaticString._flags.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t StaticString._flags.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 16) = result;
  return result;
}

uint64_t (*StaticString._flags.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t StaticString.init(unicodeScalar:)(uint64_t result)
{
  return result;
}

BOOL StaticString.hasPointerRepresentation.getter(uint64_t a1, uint64_t a2, char a3)
{
  return (a3 & 1) == 0;
}

unint64_t StaticString.unicodeScalar.getter(unint64_t result, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "StaticString should have Unicode scalar representation",  54LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x91uLL,  0);
  }
  if (HIDWORD(result)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  if (WORD1(result) > 0x10u || (result & 0xFFFFF800) == 0xD800) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x94uLL,  0);
  }
  return result;
}

uint64_t StaticString.utf8CodeUnitCount.getter(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "StaticString should have pointer representation",  47LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x9DuLL,  0);
  }
  return a2;
}

uint64_t static UInt8.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

uint64_t StaticString.isASCII.getter(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (a3 >> 1) & 1;
}

uint64_t protocol witness for _ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:) in conformance StaticString@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  else {
    char v2 = 3;
  }
  *(void *)a2 = result;
  *(void *)(a2 + 8) = 0LL;
  *(_BYTE *)(a2 + 16) = v2;
  return result;
}

uint64_t protocol witness for _ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) in conformance StaticString@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  if ((a3 & 1) != 0) {
    char v4 = 2;
  }
  else {
    char v4 = 0;
  }
  *(void *)a4 = result;
  *(void *)(a4 + 8) = a2;
  *(_BYTE *)(a4 + 16) = v4;
  return result;
}

__n128 protocol witness for ExpressibleByStringLiteral.init(stringLiteral:) in conformance StaticString@<Q0>( __n128 *a1@<X0>, __n128 *a2@<X8>)
{
  unsigned __int8 v2 = a1[1].n128_u8[0];
  __n128 result = *a1;
  *a2 = *a1;
  a2[1].n128_u8[0] = v2;
  return result;
}

uint64_t StaticString.description.getter(uint8x16_t *a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0)
  {
    if ((unint64_t)a1 >> 32) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    }
    unint64_t v4 = 148LL;
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v4,  0);
  }

  if (!a1)
  {
    unint64_t v4 = 136LL;
    goto LABEL_13;
  }

  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return specialized static String._uncheckedFromUTF8(_:)(a1, a2);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance StaticString()
{
  return StaticString.description.getter(*(uint8x16_t **)v0, *(void *)(v0 + 8), *(_BYTE *)(v0 + 16));
}

uint64_t StaticString.debugDescription.getter(uint8x16_t *a1, uint64_t x1_0, char a3)
{
  uint64_t v3 = StaticString.description.getter(a1, x1_0, a3);
  uint64_t v7 = v4;
  *(void *)&unsigned __int128 v244 = 34LL;
  *((void *)&v244 + 1) = 0xE100000000000000LL;
  uint64_t v8 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = v3 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v237 = v8;
  uint64_t v238 = v3;
  if (!v8)
  {
    swift_bridgeObjectRelease(v4);
LABEL_201:
    uint64_t v184 = 0xE100000000000000LL;
    uint64_t v242 = 34LL;
    uint64_t v243 = 0xE100000000000000LL;
    uint64_t v185 = v244;
    uint64_t v186 = (void *)*((void *)&v244 + 1);
    unint64_t v187 = HIBYTE(*((void *)&v244 + 1)) & 0xFLL;
    if ((*((void *)&v244 + 1) & 0x2000000000000000LL) == 0) {
      unint64_t v187 = v244 & 0xFFFFFFFFFFFFLL;
    }
    if (!v187)
    {
LABEL_256:
      swift_bridgeObjectRelease(v184);
      return v185;
    }

    while (1)
    {
      uint64_t v192 = v242;
      uint64_t v193 = v243;
      swift_bridgeObjectRetain(v243, v181, v182, v183);
      unint64_t v194 = specialized Collection.first.getter(v192, v193);
      swift_bridgeObjectRelease(v193);
      if ((v194 & 0x100000000LL) != 0)
      {
        unint64_t v232 = 839LL;
LABEL_267:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  v232,  0);
      }

      *(void *)&unsigned __int128 v241 = v185;
      *((void *)&v241 + 1) = v186;
      *(void *)&unsigned __int128 v244 = 0LL;
      *((void *)&v244 + 1) = 0xE000000000000000LL;
      unint64_t v195 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v194);
      uint64_t v197 = v196;
      _StringGuts.append(_:)(v195, v196);
      swift_bridgeObjectRelease(v197);
      unint64_t v18 = *((void *)&v241 + 1);
      uint64_t v30 = v241;
      swift_bridgeObjectRetain(*((unint64_t *)&v241 + 1), v198, v199, v200);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unsigned __int128 v244 = __PAIR128__(v18, v30);
      uint64_t v204 = HIBYTE(v18) & 0xF;
      if ((v18 & 0x2000000000000000LL) == 0) {
        uint64_t v204 = v30;
      }
      uint64_t v205 = 7LL;
      if (((v18 >> 60) & ((v30 & 0x800000000000000LL) == 0)) != 0) {
        uint64_t v205 = 11LL;
      }
      v206._Swift::UInt64 rawBits = v205 | (v204 << 16);
      swift_bridgeObjectRetain(v18, v201, v202, v203);
      v207._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(v206)._rawBits;
      Swift::UInt64 rawBits = v207._rawBits;
      if (v207._rawBits >> 14)
      {
        uint64_t v209 = v207._rawBits >> 16;
        if (v207._rawBits < 0x20000) {
          goto LABEL_232;
        }
        if ((v18 & 0x1000000000000000LL) != 0) {
          goto LABEL_231;
        }
        if ((v18 & 0x2000000000000000LL) != 0)
        {
          *(void *)&unsigned __int128 v241 = v30;
          *((void *)&v241 + 1) = v18 & 0xFFFFFFFFFFFFFFLL;
          __int128 v211 = (char *)&v241 + v209;
        }

        else
        {
          if ((v30 & 0x1000000000000000LL) != 0)
          {
            v210 = (char *)((v18 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            v210 = (char *)_StringObject.sharedUTF8.getter(v30, v18);
            if (!v210) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            }
          }

          __int128 v211 = &v210[v209];
        }

        int v212 = *((unsigned __int16 *)v211 - 1);
        if (v212 == 2573 || (v212 & 0x80808080) != 0)
        {
LABEL_231:
          uint64_t v209 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
LABEL_232:
          if (v209 <= 63) {
            uint64_t v214 = v209 << 8;
          }
          else {
            uint64_t v214 = 63LL;
          }
          goto LABEL_235;
        }

        uint64_t v209 = 1LL;
      }

      else
      {
        if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
        }
        uint64_t v209 = 0LL;
      }

      uint64_t v214 = v209 << 8;
LABEL_235:
      v215._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v206)._rawBits;
      if (!(v215._rawBits >> 14)) {
        goto LABEL_261;
      }
      Swift::UInt64 v216 = v215._rawBits;
      swift_bridgeObjectRelease(v18);
      if ((v18 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v221 = String.UnicodeScalarView._foreignIndex(before:)((Swift::String::Index)v216)._rawBits;
        swift_bridgeObjectRelease(v18);
      }

      else
      {
        if ((v18 & 0x2000000000000000LL) != 0)
        {
          uint64_t v218 = 0LL;
          *(void *)&unsigned __int128 v241 = v30;
          *((void *)&v241 + 1) = v18 & 0xFFFFFFFFFFFFFFLL;
          do
            int v220 = *(&v240 + (v216 >> 16) + v218--) & 0xC0;
          while (v220 == 128);
        }

        else
        {
          if ((v30 & 0x1000000000000000LL) != 0) {
            unint64_t v217 = (char *)((v18 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            unint64_t v217 = (char *)_StringObject.sharedUTF8.getter(v30, v18);
          }
          uint64_t v218 = 0LL;
          do
            int v219 = v217[(v216 >> 16) - 1 + v218--] & 0xC0;
          while (v219 == 128);
        }

        swift_bridgeObjectRelease(v18);
        Swift::UInt64 v221 = (v216 - -65536 * v218) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (((rawBits - (v209 << 16)) & 0xFFFFFFFFFFFF0000LL | v214) >> 14 >= v221 >> 14) {
        goto LABEL_254;
      }
      *(void *)&unsigned __int128 v241 = v30;
      *((void *)&v241 + 1) = v18;
      specialized RangeReplaceableCollection<>.removeLast()();
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unsigned int v222 = specialized RangeReplaceableCollection<>.removeLast()();
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unsigned __int128 v244 = v241;
      Swift::String_optional v224 = Unicode.Scalar._escaped(asASCII:)(1);
      unint64_t object = v224.value._object;
      if (v224.value._object) {
        uint64_t countAndFlagsBits = v224.value._countAndFlagsBits;
      }
      else {
        uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v222);
      }
      unint64_t v225 = (unint64_t)object;
      v189._Swift::UInt64 rawBits = 15LL;
      v190._Swift::UInt64 rawBits = 15LL;
      specialized String.UnicodeScalarView.replaceSubrange<A>(_:with:)(v189, v190, countAndFlagsBits, v225);
      swift_bridgeObjectRelease(v225);
      uint64_t v185 = v244;
      uint64_t v186 = (void *)*((void *)&v244 + 1);
      unint64_t v191 = HIBYTE(*((void *)&v244 + 1)) & 0xFLL;
      if ((*((void *)&v244 + 1) & 0x2000000000000000LL) == 0) {
        unint64_t v191 = v244 & 0xFFFFFFFFFFFFLL;
      }
      if (!v191)
      {
        uint64_t v184 = v243;
        goto LABEL_256;
      }
    }
  }

  uint64_t v233 = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
  uint64_t v234 = v4 & 0xFFFFFFFFFFFFFFLL;
  swift_bridgeObjectRetain_n(v4, 3LL, v5, v6);
  uint64_t v9 = 0LL;
  char v10 = 1;
  uint64_t v236 = v7;
  while (1)
  {
    if ((v7 & 0x1000000000000000LL) != 0)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v14 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v9 << 16));
      Swift::Int scalarLength = v14.scalarLength;
      Swift::UInt32 value = v14._0._value;
    }

    else
    {
      if ((v7 & 0x2000000000000000LL) != 0)
      {
        uint64_t v242 = v238;
        uint64_t v243 = v234;
        Swift::UInt32 value = *((unsigned __int8 *)&v242 + v9);
        if (*((char *)&v242 + v9) < 0) {
          __asm { BR              X9 }
        }
      }

      else
      {
        uint64_t v11 = (unsigned __int8 *)v233;
        if ((v238 & 0x1000000000000000LL) == 0) {
          uint64_t v11 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v238, v7);
        }
        Swift::UInt32 value = v11[v9];
        if ((char)v11[v9] < 0) {
          __asm { BR              X9 }
        }
      }

      Swift::Int scalarLength = 1LL;
    }

    v9 += scalarLength;
    unsigned __int128 v17 = (unsigned __int128)Unicode.Scalar._escaped(asASCII:)(0);
    if (*((void *)&v17 + 1)) {
      break;
    }
    uint64_t v239 = v9;
    uint64_t v56 = v244;
    unint64_t v55 = *((void *)&v244 + 1);
    if ((v10 & 1) == 0) {
      goto LABEL_46;
    }
    LODWORD(v242) = 0;
    swift_bridgeObjectRetain(*((unint64_t *)&v244 + 1), 0LL, v15, v16);
    unint64_t v57 = specialized BidirectionalCollection.last.getter(v56, v55);
    swift_bridgeObjectRelease(v55);
    if ((v57 & 0x100000000LL) != 0)
    {
      unint64_t v232 = 816LL;
      goto LABEL_267;
    }

    if (_GraphemeBreakingState.shouldBreak(between:and:)((Swift::Unicode::Scalar)v57, (Swift::Unicode::Scalar)value))
    {
LABEL_46:
      uint64_t v242 = v56;
      uint64_t v243 = v55;
      *(void *)&unsigned __int128 v244 = 0LL;
      *((void *)&v244 + 1) = 0xE000000000000000LL;
      uint64_t v61 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
      unint64_t v62 = v58;
      uint64_t v63 = v58 & 0x2000000000000000LL;
      uint64_t v64 = HIBYTE(v58) & 0xF;
      uint64_t v65 = HIBYTE(v55) & 0xF;
      if ((v55 & 0x2000000000000000LL) == 0 || !v63) {
        goto LABEL_50;
      }
      if ((unint64_t)(v64 + v65) > 0xF)
      {
        uint64_t v63 = 1LL;
LABEL_50:
        if (v63) {
          uint64_t v66 = HIBYTE(v58) & 0xF;
        }
        else {
          uint64_t v66 = v61 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain(v58, v58, v59, v60);
        uint64_t v235 = v66;
        if ((v62 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRetain_n(v62, 5LL, v67, v68);
          v167._Swift::UInt64 rawBits = 1LL;
          v168._Swift::UInt64 rawBits = (v66 << 16) | 1;
          v169._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v167, v168, v61, v62);
          if (v169._rawBits < 0x10000) {
            v169._rawBits |= 3;
          }
          uint64_t v66 = specialized Collection.count.getter(v169, v170, v61, v62);
          swift_bridgeObjectRelease(v62);
          if ((v55 & 0x1000000000000000LL) == 0) {
            goto LABEL_55;
          }
        }

        else
        {
          swift_bridgeObjectRetain_n(v62, 4LL, v67, v68);
          if ((v55 & 0x1000000000000000LL) == 0)
          {
LABEL_55:
            if ((v55 & 0x2000000000000000LL) != 0) {
              uint64_t v69 = HIBYTE(v55) & 0xF;
            }
            else {
              uint64_t v69 = v56 & 0xFFFFFFFFFFFFLL;
            }
            Swift::Int v70 = v69 + v66;
            if (__OFADD__(v69, v66))
            {
LABEL_258:
              __break(1u);
LABEL_259:
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
            }

LABEL_170:
                uint64_t v160 = v242;
                Swift::String::Index v161 = (void *)v243;
                swift_bridgeObjectRelease(*((uint64_t *)&v244 + 1));
                char v10 = 0;
                *(void *)&unsigned __int128 v244 = v160;
                *((void *)&v244 + 1) = v161;
                goto LABEL_8;
              }

              int v108 = 0;
              unint64_t v75 = v71;
            }

            else
            {
              if (v70 >= 16)
              {
                uint64_t v72 = v242;
                uint64_t v71 = v243;
                goto LABEL_74;
              }

              unint64_t v75 = v243;
              if ((v243 & 0x2000000000000000LL) == 0)
              {
                uint64_t v71 = v243;
                goto LABEL_111;
              }

              int v108 = 0;
              uint64_t v71 = v243;
            }

LABEL_147:
            uint64_t v7 = v236;
            swift_bridgeObjectRelease_n(v62, 5LL);
            unint64_t v136 = v242;
            if (v108)
            {
              if ((v75 & 0x1000000000000000LL) != 0)
              {
                unint64_t v136 = _StringGuts._foreignConvertedToSmall()(v242, v71);
                unint64_t v75 = v178;
              }

              else
              {
                if ((v242 & 0x1000000000000000LL) != 0)
                {
                  unint64_t v172 = (unsigned __int8 *)((v75 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v173 = v242 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  unint64_t v172 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v242, v71);
                  uint64_t v173 = v133;
                }

                swift_bridgeObjectRetain(v71, v133, v134, v135);
                closure #1 in _StringGuts._convertedToSmall()(v172, v173, &v241);
                swift_bridgeObjectRelease(v71);
                unint64_t v75 = *((void *)&v241 + 1);
                unint64_t v136 = v241;
              }
            }

            v137._Swift::UInt64 rawBits = (v235 << 16) | 1;
            v138._Swift::UInt64 rawBits = 1LL;
            v139._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v138, v137, v61, v62);
            if (v139._rawBits < 0x10000) {
              v139._rawBits |= 3;
            }
            unint64_t v141 = specialized String.init(_:)(v139, v140, v61, v62);
            unint64_t v143 = v142;
            swift_bridgeObjectRelease(v62);
            if ((v143 & 0x2000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v143);
            }

            else if ((v143 & 0x1000000000000000LL) != 0)
            {
              unint64_t v141 = _StringGuts._foreignConvertedToSmall()(v141, v143);
              unint64_t v180 = v179;
              swift_bridgeObjectRelease(v143);
              unint64_t v143 = v180;
            }

            else
            {
              if ((v141 & 0x1000000000000000LL) != 0)
              {
                uint64_t v174 = (unsigned __int8 *)((v143 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v175 = v141 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                uint64_t v174 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v141, v143);
              }

              closure #1 in _StringGuts._convertedToSmall()(v174, v175, &v241);
              swift_bridgeObjectRelease(v143);
              unint64_t v143 = *((void *)&v241 + 1);
              unint64_t v141 = v241;
            }

            uint64_t v144 = HIBYTE(v75) & 0xF;
            uint64_t v145 = HIBYTE(v143) & 0xF;
            uint64_t v146 = v145 + v144;
            if ((unint64_t)(v145 + v144) > 0xF)
            {
LABEL_263:
              unint64_t v231 = 266LL;
              goto LABEL_265;
            }

            if (v145)
            {
              char v147 = 0;
              unint64_t v148 = 0LL;
              do
              {
                unint64_t v149 = v144 + v148;
                unint64_t v150 = v148 + 1;
                if (v148 >= 8) {
                  unint64_t v151 = v143;
                }
                else {
                  unint64_t v151 = v141;
                }
                unint64_t v152 = v151 >> (v147 & 0x38);
                char v153 = (8 * v144 + v147) & 0x38;
                uint64_t v154 = (-255LL << v153) - 1;
                unint64_t v155 = (unint64_t)v152 << v153;
                unint64_t v156 = v155 | v154 & v75;
                unint64_t v157 = v155 | v154 & v136;
                if (v149 < 8) {
                  unint64_t v136 = v157;
                }
                else {
                  unint64_t v75 = v156;
                }
                v147 += 8;
                unint64_t v148 = v150;
              }

              while (v145 != v150);
            }

            swift_bridgeObjectRelease(v71);
            unint64_t v158 = 0xE000000000000000LL;
            if (v136 & 0x8080808080808080LL | v75 & 0x80808080808080LL) {
              unint64_t v158 = 0xA000000000000000LL;
            }
            uint64_t v242 = v136;
            uint64_t v243 = v158 & 0xFF00000000000000LL | (v146 << 56) | v75 & 0xFFFFFFFFFFFFFFLL;
LABEL_169:
            uint64_t v9 = v239;
            goto LABEL_170;
          }
        }

        Swift::Int v171 = String.UTF8View._foreignCount()();
        Swift::Int v70 = v171 + v66;
        if (__OFADD__(v171, v66)) {
          goto LABEL_258;
        }
        goto LABEL_59;
      }

      swift_bridgeObjectRelease(v58);
      if (v64)
      {
        char v112 = 0;
        unint64_t v113 = 0LL;
        unint64_t v114 = v55;
        do
        {
          unint64_t v115 = v65 + v113;
          unint64_t v116 = v113 + 1;
          if (v113 >= 8) {
            unint64_t v117 = v62;
          }
          else {
            unint64_t v117 = v61;
          }
          unint64_t v118 = v117 >> (v112 & 0x38);
          char v119 = (8 * v65 + v112) & 0x38;
          uint64_t v120 = (-255LL << v119) - 1;
          unint64_t v121 = (unint64_t)v118 << v119;
          unint64_t v122 = v121 | v120 & v114;
          unint64_t v123 = v121 | v120 & v56;
          if (v115 < 8) {
            uint64_t v56 = v123;
          }
          else {
            unint64_t v114 = v122;
          }
          v112 += 8;
          unint64_t v113 = v116;
        }

        while (v64 != v116);
      }

      else
      {
        unint64_t v114 = v55;
      }

      swift_bridgeObjectRelease(v55);
      unint64_t v159 = 0xE000000000000000LL;
      if (v56 & 0x8080808080808080LL | v114 & 0x80808080808080LL) {
        unint64_t v159 = 0xA000000000000000LL;
      }
      uint64_t v242 = v56;
      uint64_t v243 = v159 & 0xFF00000000000000LL | ((v64 + v65) << 56) | v114 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v7 = v236;
      goto LABEL_169;
    }

    Swift::String_optional v99 = Unicode.Scalar._escaped(asASCII:)(1);
    unint64_t v96 = (unint64_t)v99.value._object;
    if (v99.value._object) {
      uint64_t v100 = v99.value._countAndFlagsBits;
    }
    else {
      uint64_t v100 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
    }
    unint64_t v101 = v96;
    uint64_t v124 = HIBYTE(v55) & 0xF;
    if ((v55 & 0x2000000000000000LL) == 0) {
      uint64_t v124 = v56 & 0xFFFFFFFFFFFFLL;
    }
    if (!v124 && (v56 & ~v55 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v55);
      *(void *)&unsigned __int128 v244 = v100;
      *((void *)&v244 + 1) = v101;
      goto LABEL_6;
    }

    if ((v55 & 0x2000000000000000LL) == 0)
    {
      if ((v96 & 0x2000000000000000LL) != 0) {
LABEL_144:
      }
        uint64_t v125 = HIBYTE(v101) & 0xF;
      else {
LABEL_138:
      }
        uint64_t v125 = v100 & 0xFFFFFFFFFFFFLL;
      swift_bridgeObjectRetain(v101, v96, v97, v98);
      _StringGuts.append(_:)(v100, v101, 0LL, v125);
      swift_bridgeObjectRelease_n(v101, 2LL);
      goto LABEL_6;
    }

    if ((v96 & 0x2000000000000000LL) == 0) {
      goto LABEL_138;
    }
    unint64_t v130 = specialized _SmallString.init(_:appending:)(v56, v55, v100, v96);
    if ((v97 & 1) != 0) {
      goto LABEL_144;
    }
    uint64_t v131 = v130;
    unint64_t v132 = v96;
    swift_bridgeObjectRelease(v55);
    swift_bridgeObjectRelease(v101);
    *(void *)&unsigned __int128 v244 = v131;
    *((void *)&v244 + 1) = v132;
LABEL_6:
    uint64_t v9 = v239;
LABEL_7:
    char v10 = 1;
LABEL_8:
    if (v9 >= v237)
    {
      swift_bridgeObjectRelease_n(v7, 4LL);
      goto LABEL_201;
    }
  }

  uint64_t v19 = v244;
  unint64_t v18 = *((void *)&v244 + 1);
  unint64_t v20 = HIBYTE(*((void *)&v244 + 1)) & 0xFLL;
  if ((*((void *)&v244 + 1) & 0x2000000000000000LL) != 0) {
    unint64_t v21 = HIBYTE(*((void *)&v244 + 1)) & 0xFLL;
  }
  else {
    unint64_t v21 = v244 & 0xFFFFFFFFFFFFLL;
  }
  if (!v21 && ((unint64_t)v244 & ~*((void *)&v244 + 1) & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(*((uint64_t *)&v244 + 1));
    unsigned __int128 v244 = v17;
    goto LABEL_7;
  }

  uint64_t v22 = *((void *)&v17 + 1) & 0x2000000000000000LL;
  unint64_t v23 = HIBYTE(*((void *)&v17 + 1)) & 0xFLL;
  if ((*((void *)&v17 + 1) & 0x2000000000000000LL & *((void *)&v244 + 1)) != 0)
  {
    unint64_t v24 = v20 + v23;
    if (v20 + v23 <= 0xF)
    {
      if (v23)
      {
        char v84 = 0;
        unint64_t v85 = 0LL;
        unint64_t v86 = *((void *)&v244 + 1);
        do
        {
          unint64_t v87 = v20 + v85;
          unint64_t v88 = v85 + 1;
          if (v85 >= 8) {
            unint64_t v89 = *((void *)&v17 + 1);
          }
          else {
            unint64_t v89 = v17;
          }
          unint64_t v90 = v89 >> (v84 & 0x38);
          char v91 = (8 * v20 + v84) & 0x38;
          uint64_t v92 = (-255LL << v91) - 1;
          unint64_t v93 = (unint64_t)v90 << v91;
          unint64_t v94 = v93 | v92 & v86;
          unint64_t v95 = v93 | v92 & v19;
          if (v87 < 8) {
            uint64_t v19 = v95;
          }
          else {
            unint64_t v86 = v94;
          }
          v84 += 8;
          unint64_t v85 = v88;
        }

        while (v23 != v88);
      }

      else
      {
        unint64_t v86 = *((void *)&v244 + 1);
      }

      swift_bridgeObjectRelease(*((uint64_t *)&v244 + 1));
      swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
      unint64_t v109 = 0xE000000000000000LL;
      if (v19 & 0x8080808080808080LL | v86 & 0x80808080808080LL) {
        unint64_t v109 = 0xA000000000000000LL;
      }
      *(void *)&unsigned __int128 v244 = v19;
      *((void *)&v244 + 1) = v109 & 0xFF00000000000000LL | (v24 << 56) | v86 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_7;
    }
  }

  uint64_t v239 = v9;
  if (v22) {
    uint64_t v25 = HIBYTE(*((void *)&v17 + 1)) & 0xFLL;
  }
  else {
    uint64_t v25 = v17 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v17 + 1), 2LL, v15, v16);
  if ((*((void *)&v17 + 1) & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain_n(*((uint64_t *)&v17 + 1), 5LL, v26, v27);
    v162._Swift::UInt64 rawBits = 1LL;
    v163._Swift::UInt64 rawBits = (v25 << 16) | 1;
    v164._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v162, v163, v17, *((unint64_t *)&v17 + 1));
    if (v164._rawBits < 0x10000) {
      v164._rawBits |= 3;
    }
    Swift::Int v28 = specialized Collection.count.getter(v164, v165, v17, *((unint64_t *)&v17 + 1));
    swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
    if ((v18 & 0x1000000000000000LL) == 0)
    {
LABEL_31:
      BOOL v29 = __OFADD__(v21, v28);
      uint64_t v30 = v21 + v28;
      if (v29) {
        goto LABEL_253;
      }
      goto LABEL_32;
    }
  }

  else
  {
    swift_bridgeObjectRetain_n(*((uint64_t *)&v17 + 1), 4LL, v26, v27);
    Swift::Int v28 = v25;
    if ((v18 & 0x1000000000000000LL) == 0) {
      goto LABEL_31;
    }
  }

  Swift::Int v166 = String.UTF8View._foreignCount()();
  uint64_t v30 = v166 + v28;
  if (!__OFADD__(v166, v28))
  {
LABEL_32:
    if ((v19 & ~v18 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v18 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v31 = _StringGuts.nativeUnusedCapacity.getter(v19, v18);
      if ((v32 & 1) != 0) {
        goto LABEL_264;
      }
      uint64_t v33 = (v18 >> 61) & 1;
      if (v31 < v28) {
        LODWORD(v33) = 1;
      }
      if (v30 > 15 || !(_DWORD)v33)
      {
LABEL_67:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v30, v28);
        swift_bridgeObjectRelease_n(*((uint64_t *)&v17 + 1), 4LL);
        if ((*((void *)&v17 + 1) & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
          _StringGuts._foreignAppendInPlace(_:)(v17, *((unint64_t *)&v17 + 1), 0LL, v25);
          swift_bridgeObjectRelease_n(*((uint64_t *)&v17 + 1), 2LL);
          uint64_t v7 = v236;
        }

        else
        {
          if (!v22)
          {
            if ((v17 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
              id v76 = (id)((*((void *)&v17 + 1) & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v77 = v17 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v76 = _StringObject.sharedUTF8.getter(v17, *((uint64_t *)&v17 + 1));
              uint64_t v77 = v176;
              swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
            }

            uint64_t v9 = v239;
            uint64_t v78 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v17 & 0xFFFFFFFFFFFFLL,  (uint64_t)v76,  v77);
            _StringGuts.appendInPlace(_:isASCII:)(v78, v79, (v17 & 0x8000000000000000LL) != 0LL);
            swift_bridgeObjectRelease_n(*((uint64_t *)&v17 + 1), 2LL);
            uint64_t v7 = v236;
            goto LABEL_7;
          }

          swift_bridgeObjectRelease_n(*((uint64_t *)&v17 + 1), 2LL);
          uint64_t v242 = v17;
          uint64_t v243 = *((void *)&v17 + 1) & 0xFFFFFFFFFFFFFFLL;
          unint64_t v110 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(*((void *)&v17 + 1)) & 0xFLL,  (uint64_t)&v242,  HIBYTE(*((void *)&v17 + 1)) & 0xFLL);
          _StringGuts.appendInPlace(_:isASCII:)(v110, v111, (*((void *)&v17 + 1) & 0x4000000000000000LL) != 0);
          uint64_t v7 = v236;
          swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
        }

        goto LABEL_6;
      }
    }

    else if (v30 > 15)
    {
      goto LABEL_67;
    }

    swift_bridgeObjectRelease_n(*((uint64_t *)&v17 + 1), 5LL);
    swift_bridgeObjectRetain(v18, v34, v35, v36);
    unint64_t v37 = _StringGuts._convertedToSmall()(v19, v18);
    unint64_t v39 = v38;
    swift_bridgeObjectRelease(v18);
    v40._Swift::UInt64 rawBits = (v25 << 16) | 1;
    v41._Swift::UInt64 rawBits = 1LL;
    v42._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v41, v40, v17, *((unint64_t *)&v17 + 1));
    if (v42._rawBits < 0x10000) {
      v42._rawBits |= 3;
    }
    unint64_t v44 = specialized String.init(_:)(v42, v43, v17, *((unint64_t *)&v17 + 1));
    unint64_t v46 = v45;
    swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
    unint64_t v47 = _StringGuts._convertedToSmall()(v44, v46);
    unint64_t v49 = v48;
    swift_bridgeObjectRelease(v46);
    unint64_t v50 = specialized _SmallString.init(_:appending:)(v37, v39, v47, v49);
    uint64_t v7 = v236;
    if ((v52 & 1) != 0) {
      goto LABEL_263;
    }
    uint64_t v53 = v50;
    uint64_t v54 = v51;
    swift_bridgeObjectRelease(v18);
    swift_bridgeObjectRelease(*((uint64_t *)&v17 + 1));
    *(void *)&unsigned __int128 v244 = v53;
    *((void *)&v244 + 1) = v54;
    goto LABEL_6;
  }

    unint64_t v96 = 201LL;
    goto LABEL_149;
  }

          uint64_t v145 = &TypeName->u8[v107];
          uint64_t v146 = v106 - v107;
          do
          {
            char v147 = *v145++;
            v4 |= (unint64_t)v147 << (v108 & 0x38);
            v108 += 8LL;
            --v146;
          }

          while (v146);
          goto LABEL_149;
        }

      swift_bridgeObjectRelease_n(a3, 5LL);
      unint64_t v13 = v298._countAndFlagsBits;
      if (v105)
      {
LABEL_311:
        if ((v25 & 0x1000000000000000LL) != 0)
        {
          unint64_t v13 = _StringGuts._foreignConvertedToSmall()(v13, v11);
          uint64_t v25 = v290;
        }

        else
        {
          if ((v13 & 0x1000000000000000LL) != 0)
          {
            v279 = (unsigned __int8 *)((v25 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v280 = v13 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            v279 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v13, v11);
            v280 = v22;
          }

          swift_bridgeObjectRetain(v11, v22, v23, v24);
          closure #1 in _StringGuts._convertedToSmall()(v279, v280, &v297);
          swift_bridgeObjectRelease(v11);
          uint64_t v25 = *((void *)&v297 + 1);
          unint64_t v13 = v297;
        }
      }

      v122._Swift::UInt64 rawBits = (v295 << 16) | 1;
      v123._Swift::UInt64 rawBits = 1LL;
      v124._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v123, v122, a1, a3);
      if (v124._rawBits < 0x10000) {
        v124._rawBits |= 3;
      }
      id v126 = specialized String.init(_:)(v124, v125, a1, a3);
      unint64_t v128 = v127;
      swift_bridgeObjectRelease(a3);
      if ((v128 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v128);
      }

      else if ((v128 & 0x1000000000000000LL) != 0)
      {
        id v126 = _StringGuts._foreignConvertedToSmall()(v126, v128);
        v292 = v291;
        swift_bridgeObjectRelease(v128);
        unint64_t v128 = v292;
      }

      else
      {
        if ((v126 & 0x1000000000000000LL) != 0)
        {
          v281 = (unsigned __int8 *)((v128 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v282 = v126 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v281 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v126, v128);
        }

        closure #1 in _StringGuts._convertedToSmall()(v281, v282, &v297);
        swift_bridgeObjectRelease(v128);
        unint64_t v128 = *((void *)&v297 + 1);
        id v126 = v297;
      }

      size_t v129 = HIBYTE(v25) & 0xF;
      unint64_t v130 = HIBYTE(v128) & 0xF;
      uint64_t v131 = v130 + v129;
      if (v130)
      {
        unint64_t v132 = 0;
        uint64_t v133 = 0LL;
        do
        {
          uint64_t v134 = v129 + v133;
          int64_t v135 = v133 + 1;
          if (v133 >= 8) {
            unint64_t v136 = v128;
          }
          else {
            unint64_t v136 = v126;
          }
          Swift::String::Index v137 = v136 >> (v132 & 0x38);
          Swift::String::Index v138 = (8 * v129 + v132) & 0x38;
          Swift::String::Index v139 = (-255LL << v138) - 1;
          Swift::String::Index v140 = (unint64_t)v137 << v138;
          unint64_t v141 = v140 | v139 & v25;
          unint64_t v142 = v140 | v139 & v13;
          if (v134 < 8) {
            unint64_t v13 = v142;
          }
          else {
            uint64_t v25 = v141;
          }
          v132 += 8;
          uint64_t v133 = v135;
        }

        while (v130 != v135);
      }

      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(a3);
      unint64_t v143 = 0xA000000000000000LL;
      if (!(v13 & 0x8080808080808080LL | v25 & 0x80808080808080LL)) {
        unint64_t v143 = 0xE000000000000000LL;
      }
      v298._uint64_t countAndFlagsBits = v13;
      v298._unint64_t object = (void *)(v143 & 0xFF00000000000000LL | (v131 << 56) | v25 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }

    unint64_t v93 = v298._countAndFlagsBits;
    uint64_t v11 = (unint64_t)v298._object;
    unint64_t v94 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v95 & 1) != 0) {
      goto LABEL_334;
    }
    if (v92 <= 15)
    {
      if ((v11 & 0x2000000000000000LL) != 0)
      {
        uint64_t v105 = 0;
        uint64_t v25 = v11;
        goto LABEL_147;
      }

      uint64_t v25 = v11;
      if (v94 < a2) {
        goto LABEL_128;
      }
    }

      swift_bridgeObjectRelease_n(a3, 5LL);
      unint64_t v13 = v298._countAndFlagsBits;
      if (v105)
      {
LABEL_311:
        if ((v25 & 0x1000000000000000LL) != 0)
        {
          unint64_t v13 = _StringGuts._foreignConvertedToSmall()(v13, v11);
          uint64_t v25 = v290;
        }

        else
        {
          if ((v13 & 0x1000000000000000LL) != 0)
          {
            v279 = (unsigned __int8 *)((v25 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v280 = v13 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            v279 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v13, v11);
            v280 = v22;
          }

          swift_bridgeObjectRetain(v11, v22, v23, v24);
          closure #1 in _StringGuts._convertedToSmall()(v279, v280, &v297);
          swift_bridgeObjectRelease(v11);
          uint64_t v25 = *((void *)&v297 + 1);
          unint64_t v13 = v297;
        }
      }

      v122._Swift::UInt64 rawBits = (v295 << 16) | 1;
      v123._Swift::UInt64 rawBits = 1LL;
      v124._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v123, v122, a1, a3);
      if (v124._rawBits < 0x10000) {
        v124._rawBits |= 3;
      }
      id v126 = specialized String.init(_:)(v124, v125, a1, a3);
      unint64_t v128 = v127;
      swift_bridgeObjectRelease(a3);
      if ((v128 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v128);
      }

      else if ((v128 & 0x1000000000000000LL) != 0)
      {
        id v126 = _StringGuts._foreignConvertedToSmall()(v126, v128);
        v292 = v291;
        swift_bridgeObjectRelease(v128);
        unint64_t v128 = v292;
      }

      else
      {
        if ((v126 & 0x1000000000000000LL) != 0)
        {
          v281 = (unsigned __int8 *)((v128 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v282 = v126 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v281 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v126, v128);
        }

        closure #1 in _StringGuts._convertedToSmall()(v281, v282, &v297);
        swift_bridgeObjectRelease(v128);
        unint64_t v128 = *((void *)&v297 + 1);
        id v126 = v297;
      }

      size_t v129 = HIBYTE(v25) & 0xF;
      unint64_t v130 = HIBYTE(v128) & 0xF;
      uint64_t v131 = v130 + v129;
      if (v130)
      {
        unint64_t v132 = 0;
        uint64_t v133 = 0LL;
        do
        {
          uint64_t v134 = v129 + v133;
          int64_t v135 = v133 + 1;
          if (v133 >= 8) {
            unint64_t v136 = v128;
          }
          else {
            unint64_t v136 = v126;
          }
          Swift::String::Index v137 = v136 >> (v132 & 0x38);
          Swift::String::Index v138 = (8 * v129 + v132) & 0x38;
          Swift::String::Index v139 = (-255LL << v138) - 1;
          Swift::String::Index v140 = (unint64_t)v137 << v138;
          unint64_t v141 = v140 | v139 & v25;
          unint64_t v142 = v140 | v139 & v13;
          if (v134 < 8) {
            unint64_t v13 = v142;
          }
          else {
            uint64_t v25 = v141;
          }
          v132 += 8;
          uint64_t v133 = v135;
        }

        while (v130 != v135);
      }

      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(a3);
      unint64_t v143 = 0xA000000000000000LL;
      if (!(v13 & 0x8080808080808080LL | v25 & 0x80808080808080LL)) {
        unint64_t v143 = 0xE000000000000000LL;
      }
      v298._uint64_t countAndFlagsBits = v13;
      v298._unint64_t object = (void *)(v143 & 0xFF00000000000000LL | (v131 << 56) | v25 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }

    unint64_t v93 = v298._countAndFlagsBits;
    uint64_t v11 = (unint64_t)v298._object;
    unint64_t v94 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v95 & 1) != 0) {
      goto LABEL_334;
    }
    if (v92 <= 15)
    {
      if ((v11 & 0x2000000000000000LL) != 0)
      {
        uint64_t v105 = 0;
        uint64_t v25 = v11;
        goto LABEL_147;
      }

      uint64_t v25 = v11;
      if (v94 < a2) {
        goto LABEL_128;
      }
    }

      uint64_t v11 = v250;
      swift_bridgeObjectRelease_n(v9, 5LL);
      unsigned __int8 v2 = v254._countAndFlagsBits;
      if (v101)
      {
LABEL_282:
        if ((object & 0x1000000000000000LL) != 0)
        {
          unsigned __int8 v2 = _StringGuts._foreignConvertedToSmall()(v2, countAndFlagsBits);
          unint64_t object = v245;
        }

        else
        {
          if ((v2 & 0x1000000000000000LL) != 0)
          {
            uint64_t v235 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v236 = v2 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v235 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, countAndFlagsBits);
            uint64_t v236 = v21;
          }

          swift_bridgeObjectRetain(countAndFlagsBits, v21, v22, v23);
          closure #1 in _StringGuts._convertedToSmall()(v235, v236, &v253);
          swift_bridgeObjectRelease(countAndFlagsBits);
          unint64_t object = *((void *)&v253 + 1);
          unsigned __int8 v2 = v253;
        }
      }

      v118._Swift::UInt64 rawBits = (v11 << 16) | 1;
      v119._Swift::UInt64 rawBits = 1LL;
      v120._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v119, v118, v12, v9);
      if (v120._rawBits < 0x10000) {
        v120._rawBits |= 3;
      }
      unint64_t v122 = specialized String.init(_:)(v120, v121, v12, v9);
      uint64_t v124 = v123;
      swift_bridgeObjectRelease(v9);
      if ((v124 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v124);
      }

      else if ((v124 & 0x1000000000000000LL) != 0)
      {
        unint64_t v122 = _StringGuts._foreignConvertedToSmall()(v122, v124);
        v247 = v246;
        swift_bridgeObjectRelease(v124);
        uint64_t v124 = v247;
      }

      else
      {
        if ((v122 & 0x1000000000000000LL) != 0)
        {
          uint64_t v237 = (unsigned __int8 *)((v124 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v238 = v122 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v237 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v122, v124);
        }

        closure #1 in _StringGuts._convertedToSmall()(v237, v238, &v253);
        swift_bridgeObjectRelease(v124);
        uint64_t v124 = *((void *)&v253 + 1);
        unint64_t v122 = v253;
      }

      uint64_t v125 = HIBYTE(object) & 0xF;
      id v126 = HIBYTE(v124) & 0xF;
      uint64_t v127 = v126 + v125;
      if (v126)
      {
        unint64_t v128 = 0;
        size_t v129 = 0LL;
        do
        {
          unint64_t v130 = v125 + v129;
          uint64_t v131 = v129 + 1;
          if (v129 >= 8) {
            unint64_t v132 = v124;
          }
          else {
            unint64_t v132 = v122;
          }
          uint64_t v133 = v132 >> (v128 & 0x38);
          uint64_t v134 = (8 * v125 + v128) & 0x38;
          int64_t v135 = (-255LL << v134) - 1;
          unint64_t v136 = (unint64_t)v133 << v134;
          Swift::String::Index v137 = v136 | v135 & object;
          Swift::String::Index v138 = v136 | v135 & v2;
          if (v130 < 8) {
            unsigned __int8 v2 = v138;
          }
          else {
            unint64_t object = v137;
          }
          v128 += 8;
          size_t v129 = v131;
        }

        while (v126 != v131);
      }

      swift_bridgeObjectRelease(countAndFlagsBits);
      swift_bridgeObjectRelease(v9);
      Swift::String::Index v139 = 0xA000000000000000LL;
      if (!(v2 & 0x8080808080808080LL | object & 0x80808080808080LL)) {
        Swift::String::Index v139 = 0xE000000000000000LL;
      }
      v254._uint64_t countAndFlagsBits = v2;
      v254._unint64_t object = (void *)(v139 & 0xFF00000000000000LL | (v127 << 56) | object & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }

    unint64_t v89 = v254._countAndFlagsBits;
    uint64_t countAndFlagsBits = (uint64_t)v254._object;
    unint64_t v90 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v91 & 1) != 0) {
      goto LABEL_303;
    }
    if (v88 <= 15)
    {
      if ((countAndFlagsBits & 0x2000000000000000LL) != 0)
      {
        unint64_t v101 = 0;
        unint64_t object = countAndFlagsBits;
        goto LABEL_147;
      }

      unint64_t object = countAndFlagsBits;
      if (v90 < v82) {
        goto LABEL_128;
      }
    }

      uint64_t v11 = v250;
      swift_bridgeObjectRelease_n(v9, 5LL);
      unsigned __int8 v2 = v254._countAndFlagsBits;
      if (v101)
      {
LABEL_282:
        if ((object & 0x1000000000000000LL) != 0)
        {
          unsigned __int8 v2 = _StringGuts._foreignConvertedToSmall()(v2, countAndFlagsBits);
          unint64_t object = v245;
        }

        else
        {
          if ((v2 & 0x1000000000000000LL) != 0)
          {
            uint64_t v235 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v236 = v2 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v235 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, countAndFlagsBits);
            uint64_t v236 = v21;
          }

          swift_bridgeObjectRetain(countAndFlagsBits, v21, v22, v23);
          closure #1 in _StringGuts._convertedToSmall()(v235, v236, &v253);
          swift_bridgeObjectRelease(countAndFlagsBits);
          unint64_t object = *((void *)&v253 + 1);
          unsigned __int8 v2 = v253;
        }
      }

      v118._Swift::UInt64 rawBits = (v11 << 16) | 1;
      v119._Swift::UInt64 rawBits = 1LL;
      v120._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v119, v118, v12, v9);
      if (v120._rawBits < 0x10000) {
        v120._rawBits |= 3;
      }
      unint64_t v122 = specialized String.init(_:)(v120, v121, v12, v9);
      uint64_t v124 = v123;
      swift_bridgeObjectRelease(v9);
      if ((v124 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v124);
      }

      else if ((v124 & 0x1000000000000000LL) != 0)
      {
        unint64_t v122 = _StringGuts._foreignConvertedToSmall()(v122, v124);
        v247 = v246;
        swift_bridgeObjectRelease(v124);
        uint64_t v124 = v247;
      }

      else
      {
        if ((v122 & 0x1000000000000000LL) != 0)
        {
          uint64_t v237 = (unsigned __int8 *)((v124 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v238 = v122 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v237 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v122, v124);
        }

        closure #1 in _StringGuts._convertedToSmall()(v237, v238, &v253);
        swift_bridgeObjectRelease(v124);
        uint64_t v124 = *((void *)&v253 + 1);
        unint64_t v122 = v253;
      }

      uint64_t v125 = HIBYTE(object) & 0xF;
      id v126 = HIBYTE(v124) & 0xF;
      uint64_t v127 = v126 + v125;
      if (v126)
      {
        unint64_t v128 = 0;
        size_t v129 = 0LL;
        do
        {
          unint64_t v130 = v125 + v129;
          uint64_t v131 = v129 + 1;
          if (v129 >= 8) {
            unint64_t v132 = v124;
          }
          else {
            unint64_t v132 = v122;
          }
          uint64_t v133 = v132 >> (v128 & 0x38);
          uint64_t v134 = (8 * v125 + v128) & 0x38;
          int64_t v135 = (-255LL << v134) - 1;
          unint64_t v136 = (unint64_t)v133 << v134;
          Swift::String::Index v137 = v136 | v135 & object;
          Swift::String::Index v138 = v136 | v135 & v2;
          if (v130 < 8) {
            unsigned __int8 v2 = v138;
          }
          else {
            unint64_t object = v137;
          }
          v128 += 8;
          size_t v129 = v131;
        }

        while (v126 != v131);
      }

      swift_bridgeObjectRelease(countAndFlagsBits);
      swift_bridgeObjectRelease(v9);
      Swift::String::Index v139 = 0xA000000000000000LL;
      if (!(v2 & 0x8080808080808080LL | object & 0x80808080808080LL)) {
        Swift::String::Index v139 = 0xE000000000000000LL;
      }
      v254._uint64_t countAndFlagsBits = v2;
      v254._unint64_t object = (void *)(v139 & 0xFF00000000000000LL | (v127 << 56) | object & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }

    unint64_t v89 = v254._countAndFlagsBits;
    uint64_t countAndFlagsBits = (uint64_t)v254._object;
    unint64_t v90 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v91 & 1) != 0) {
      goto LABEL_303;
    }
    if (v88 <= 15)
    {
      if ((countAndFlagsBits & 0x2000000000000000LL) != 0)
      {
        unint64_t v101 = 0;
        unint64_t object = countAndFlagsBits;
        goto LABEL_147;
      }

      unint64_t object = countAndFlagsBits;
      if (v90 < v82) {
        goto LABEL_128;
      }
    }

  uint64_t v54 = 0LL;
LABEL_148:
}

LABEL_253:
  __break(1u);
LABEL_254:
  v226._Swift::UInt64 rawBits = specialized Collection.dropFirst(_:)(1LL, v242, v243);
  uint64_t v228 = v227;
  *(void *)&unsigned __int128 v241 = v30;
  *((void *)&v241 + 1) = v18;
  *(void *)&unsigned __int128 v244 = 0LL;
  *((void *)&v244 + 1) = 0xE000000000000000LL;
  specialized String.UnicodeScalarView.append<A>(contentsOf:)(v226, v245, v229, v227);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRelease(v228);
  return v241;
}

          __n128 result = 0LL;
          goto LABEL_248;
        }

        uint64_t v8 = 1;
        unint64_t v57 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
        uint64_t v61 = specialized UnsafeBufferPointer.init(rebasing:)(v57, v58, v59, v60);
        if (v62)
        {
          uint64_t v63 = (unsigned __int8 *)v61;
          uint64_t v64 = a3 + 48;
          uint64_t v65 = a3 + 55;
          uint64_t v66 = a3 + 87;
          if (a3 > 10)
          {
            uint64_t v64 = 58;
          }

          else
          {
            uint64_t v66 = 97;
            uint64_t v65 = 65;
          }

          if (v61)
          {
            uint64_t v67 = v62;
            uint64_t v68 = 0LL;
            uint64_t v69 = 0LL;
            Swift::Int v70 = a3 >> 63;
            while (1)
            {
              unint64_t v118 = *v63;
              if (v118 < 0x30 || v118 >= v64)
              {
                if (v118 < 0x41 || v118 >= v65)
                {
                  __n128 result = 0LL;
                  uint64_t v8 = 1;
                  if (v118 < 0x61 || v118 >= v66) {
                    goto LABEL_248;
                  }
                  char v119 = -87;
                }

                else
                {
                  char v119 = -55;
                }
              }

              else
              {
                char v119 = -48;
              }

              __n128 result = 0LL;
              uint64_t v120 = !is_mul_ok(v69, a3);
              unint64_t v121 = !is_mul_ok(v68, v70);
              unint64_t v122 = __CFADD__(v69 * a3, v68 * v70);
              unint64_t v123 = (a3 * __PAIR128__(v69, v68)) >> 64;
              uint64_t v124 = __CFADD__(v69 * a3 + v68 * v70, (v68 * (unsigned __int128)(unint64_t)a3) >> 64);
              uint64_t v125 = a3 >= 0 || v69 == 0;
              uint64_t v8 = 1;
              if (!v125 || v120 || v121 || v122) {
                goto LABEL_248;
              }
              id v126 = v68 * a3;
              unint64_t v86 = __CFADD__(v126, (v118 + v119));
              uint64_t v68 = v126 + (v118 + v119);
              uint64_t v127 = v86;
              if (v123 == -1LL)
              {
                if (((v127 | v124) & 1) != 0) {
                  goto LABEL_244;
                }
                uint64_t v69 = -1LL;
              }

              else if (v127)
              {
                if (v124) {
                  goto LABEL_244;
                }
                uint64_t v69 = v123 + 1;
              }

              else
              {
                uint64_t v69 = v123;
                if (v124) {
                  goto LABEL_244;
                }
              }

              ++v63;
              if (!--v67) {
                goto LABEL_245;
              }
            }
          }

          goto LABEL_136;
        }

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance StaticString()
{
  return StaticString.debugDescription.getter(*(uint8x16_t **)v0, *(void *)(v0 + 8), *(_BYTE *)(v0 + 16));
}

uint64_t StaticString.customMirror.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  if ((a3 & 1) != 0)
  {
    if (HIDWORD(a1)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    }
    if (WORD1(a1) <= 0x10u && (a1 & 0xFFFFF800) != 0xD800)
    {
      uint64_t v11 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a1);
      int64_t v13 = v12;
      goto LABEL_34;
    }

    unint64_t v90 = 148LL;
LABEL_64:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v90,  0);
  }

  if (!a1)
  {
    unint64_t v90 = 136LL;
    goto LABEL_64;
  }

  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (!a2)
  {
    uint64_t v11 = 0LL;
    int64_t v13 = 0xE000000000000000LL;
    goto LABEL_34;
  }

  if ((a2 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    unint64_t v7 = a2;
    if (((*(void *)(a1 + 8) | *(void *)a1) & 0x8080808080808080LL) != 0)
    {
LABEL_31:
      uint64_t v14 = v7 | 0x3000000000000000LL;
      int64_t v13 = _allocateStringStorage(codeUnitCapacity:)(a2);
      *(void *)(v13 + 16) = v15;
      *(void *)(v13 + 24) = v14;
      if (v15 < 0)
      {
        *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
        uint64_t v14 = *(void *)(v13 + 24);
      }

      *(_BYTE *)(v13 + 32 + (v14 & 0xFFFFFFFFFFFFLL)) = 0;
      specialized UnsafeMutablePointer.initialize(from:count:)((char *)a1, a2, (char *)(v13 + 32));
      uint64_t v11 = *(void *)(v13 + 24);
      goto LABEL_34;
    }

    uint64_t v8 = (unsigned __int8 *)(a1 + 16);
    while ((unint64_t)v8 < a1 + (a2 & 0xFFFFFFFFFFFFFFF0LL))
    {
      uint64_t v9 = *(void *)v8;
      uint64_t v10 = *((void *)v8 + 1);
      v8 += 16;
      if (((v10 | v9) & 0x8080808080808080LL) != 0) {
        goto LABEL_30;
      }
    }
  }

  else
  {
    uint64_t v8 = (unsigned __int8 *)a1;
  }

  if ((unint64_t)v8 < a1 + (a2 & 0xFFFFFFFFFFFFFFF8LL))
  {
    if ((*(void *)v8 & 0x8080808080808080LL) != 0) {
      goto LABEL_30;
    }
    v8 += 8;
  }

  if ((unint64_t)v8 < a1 + (a2 & 0xFFFFFFFFFFFFFFFCLL))
  {
    if ((*(_DWORD *)v8 & 0x80808080) != 0) {
      goto LABEL_30;
    }
    v8 += 4;
  }

  if ((unint64_t)v8 < a1 + (a2 & 0xFFFFFFFFFFFFFFFELL))
  {
    if ((*(_WORD *)v8 & 0x8080) != 0) {
      goto LABEL_30;
    }
    v8 += 2;
  }

  if ((unint64_t)v8 < a1 + a2 && (char)*v8 < 0)
  {
LABEL_30:
    unint64_t v7 = a2;
    if (a2 > 15) {
      goto LABEL_31;
    }
    goto LABEL_35;
  }

  if (a2 >= 16)
  {
    unint64_t v7 = a2 | 0xC000000000000000LL;
    goto LABEL_31;
  }

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance StaticString@<X0>( uint64_t a1@<X8>)
{
  return StaticString.customMirror.getter(*(void *)v1, *(void *)(v1 + 8), *(_BYTE *)(v1 + 16), a1);
}

uint64_t static Strideable.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v21 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v7 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                             + 8)
                 + 16LL);
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v8);
  uint64_t v10 = (char *)&v21 - v9;
  uint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v22 = *(v11 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v16 = (char *)&v21 - v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 40))(v21, v5, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  (uint64_t)v11,  v8,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v8,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t *, uint64_t))(v7 + 24))(v10, v11, v7);
  unint64_t v18 = swift_getAssociatedConformanceWitness( a4,  v5,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  LOBYTE(v5) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v18 + 40))( v16,  v14,  v11,  v18);
  uint64_t v19 = *(void (**)(char *, unint64_t *))(v22 + 8);
  v19(v14, v11);
  v19(v16, v11);
  return v5 & 1;
}

uint64_t static Strideable.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v21 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v7 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                             + 8)
                 + 16LL);
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v8);
  uint64_t v10 = (char *)&v21 - v9;
  uint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v22 = *(v11 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v16 = (char *)&v21 - v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 40))(v21, v5, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  (uint64_t)v11,  v8,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v8,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t *, uint64_t))(v7 + 24))(v10, v11, v7);
  unint64_t v18 = swift_getAssociatedConformanceWitness( a4,  v5,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  LOBYTE(v5) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v18 + 8) + 8LL))( v16,  v14,  v11);
  uint64_t v19 = *(void (**)(char *, unint64_t *))(v22 + 8);
  v19(v14, v11);
  v19(v16, v11);
  return v5 & 1;
}

unint64_t specialized static Strideable<>._step(after:from:by:)( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a4 + a8;
  BOOL v9 = __CFADD__(a4, a8);
  uint64_t v10 = a5 + (a8 >> 63);
  if (__OFADD__(a5, a8 >> 63)) {
    goto LABEL_6;
  }
  if (v10 != 0x7FFFFFFFFFFFFFFFLL)
  {
    unint64_t v12 = 0LL;
    uint64_t v11 = v10 + v9;
    goto LABEL_11;
  }

  if (v9)
  {
LABEL_6:
    uint64_t v11 = (a8 >> 63) ^ 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v8 = ~(a8 >> 63);
    unint64_t v12 = 0x8000000000000000LL;
  }

  else
  {
    unint64_t v12 = 0LL;
    uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
  }

unint64_t specialized static Strideable<>._step(after:from:by:)( uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = 0x8000000000000000LL;
  if (__OFADD__(__CFADD__(a4, a8), a5) | __OFADD__(a8 >> 63, __CFADD__(a4, a8) + a5))
  {
    uint64_t v9 = ~(a8 >> 63);
  }

  else
  {
    unint64_t v8 = 0LL;
    uint64_t v9 = a4 + a8;
  }

  if (__OFADD__(__CFADD__(a4, a8), a5) | __OFADD__(a8 >> 63, __CFADD__(a4, a8) + a5)) {
    uint64_t v10 = (a8 >> 63) ^ 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v10 = (__PAIR128__(a5, a4) + a8) >> 64;
  }
  *a1 = v9;
  a1[1] = v10;
  return v8;
}

{
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  if (a8 < 0)
  {
    uint64_t v11 = -a8;
    if (__OFSUB__(0LL, a8))
    {
      __break(1u);
    }

    else if ((v11 & 0x8000000000000000LL) == 0)
    {
      uint64_t v9 = (__PAIR128__(a5, a4) - (unint64_t)v11) >> 64;
      unint64_t v8 = a4 + a8;
      uint64_t v10 = __PAIR128__(a5, a4) < (unint64_t)v11;
      goto LABEL_8;
    }

    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000052LL,  0x80000001818BAB80LL,  "Swift/UInt128.swift",  19LL,  2,  0x96uLL,  0);
  }

  unint64_t v8 = a4 + a8;
  uint64_t v9 = __CFADD__(a4, a8) + a5;
  uint64_t v10 = __CFADD__(__CFADD__(a4, a8), a5);
LABEL_8:
  unint64_t v12 = 0x8000000000000000LL;
  if (!v10) {
    unint64_t v12 = 0LL;
  }
  uint64_t v13 = a8 >> 63;
  if (v10)
  {
    unint64_t v8 = ~v13;
    uint64_t v9 = ~v13;
  }

  *a1 = v8;
  a1[1] = v9;
  return v12;
}

_DWORD *specialized static Strideable<>._step(after:from:by:)( _DWORD *result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  if (a4 >= 0 != a6 < 0)
  {
    if (a6 > (uint64_t)0xFFFFFFFF7FFFFFFFLL)
    {
      if (a6 < 0x80000000LL)
      {
        LODWORD(v6) = a4 + a6;
        BOOL v7 = __OFADD__(a4, (_DWORD)a6);
        BOOL v8 = !v7;
        if (v7) {
          unint64_t v9 = 0x8000000000000000LL;
        }
        else {
          unint64_t v9 = 0LL;
        }
        if (!v8) {
          LODWORD(v6) = (a6 >> 63) ^ 0x7FFFFFFF;
        }
        goto LABEL_17;
      }

      goto LABEL_19;
    }

    goto LABEL_18;
  }

  uint64_t v6 = a6 + a4;
  if (!__OFADD__(a6, a4))
  {
    if (v6 > (uint64_t)0xFFFFFFFF7FFFFFFFLL)
    {
      if (v6 < 0x80000000LL)
      {
        unint64_t v9 = 0LL;
LABEL_17:
        *__n128 result = v6;
        return (_DWORD *)v9;
      }

_WORD *specialized static Strideable<>._step(after:from:by:)( _WORD *result, uint64_t a2, uint64_t a3, __int16 a4, uint64_t a5, uint64_t a6)
{
  if (a4 >= 0 != a6 < 0)
  {
    if (a6 > -32769)
    {
      if (a6 < 0x8000)
      {
        LODWORD(v6) = a4 + (__int16)a6;
        unint64_t v7 = 0x8000000000000000LL;
        else {
          LOWORD(v6) = (a6 >> 63) ^ 0x7FFF;
        }
        goto LABEL_11;
      }

      goto LABEL_13;
    }

    goto LABEL_12;
  }

  uint64_t v6 = a6 + a4;
  if (!__OFADD__(a6, a4))
  {
    if (v6 > -32769)
    {
      if (v6 < 0x8000)
      {
        unint64_t v7 = 0LL;
LABEL_11:
        *__n128 result = v6;
        return (_WORD *)v7;
      }

_BYTE *specialized static Strideable<>._step(after:from:by:)( _BYTE *result, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  if (a4 >= 0 != a6 < 0)
  {
    if (a6 > -129)
    {
      if (a6 < 128)
      {
        LODWORD(v6) = a4 + (char)a6;
        unint64_t v7 = 0x8000000000000000LL;
        else {
          LOBYTE(v6) = (a6 >> 63) ^ 0x7F;
        }
        goto LABEL_11;
      }

      goto LABEL_13;
    }

    goto LABEL_12;
  }

  uint64_t v6 = a6 + a4;
  if (!__OFADD__(a6, a4))
  {
    if (v6 > -129)
    {
      if (v6 < 128)
      {
        unint64_t v7 = 0LL;
LABEL_11:
        *__n128 result = v6;
        return (_BYTE *)v7;
      }

unint64_t specialized static Strideable<>._step(after:from:by:)( uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a8 & 0x8000000000000000LL) == 0)
  {
    BOOL v8 = a5 == -1;
    uint64_t v9 = a4 + a8;
    uint64_t v10 = __CFADD__(a4, a8);
    if (!__CFADD__(a4, a8)) {
      BOOL v8 = 0;
    }
    goto LABEL_12;
  }

  unint64_t v11 = -a8;
  if (__OFSUB__(0LL, a8))
  {
    __break(1u);
LABEL_19:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000028LL,  0x80000001818B7CB0LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x85uLL,  0);
  }

  if ((v11 & 0x8000000000000000LL) != 0) {
    goto LABEL_19;
  }
  BOOL v8 = a5 == 0;
  BOOL v12 = a4 >= v11;
  uint64_t v9 = a4 + a8;
  uint64_t v10 = (uint64_t)((unint64_t)(a4 < v11) << 63) >> 63;
  if (v12) {
    BOOL v8 = 0;
  }
LABEL_12:
  uint64_t v13 = v10 + a5;
  unint64_t v14 = 0x8000000000000000LL;
  if (v8) {
    uint64_t v13 = ~a8 >> 63;
  }
  else {
    unint64_t v14 = 0LL;
  }
  if (v8) {
    uint64_t v9 = ~a8 >> 63;
  }
  *a1 = v9;
  a1[1] = v13;
  return v14;
}

unint64_t specialized static Strideable<>._step(after:from:by:)( unsigned int *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  if ((a6 & 0x8000000000000000LL) == 0)
  {
    if (!HIDWORD(a6))
    {
      unsigned int v6 = a4 + a6;
      BOOL v7 = __CFADD__(a4, (_DWORD)a6);
      goto LABEL_10;
    }

unint64_t specialized static Strideable<>._step(after:from:by:)( _WORD *a1, uint64_t a2, uint64_t a3, unsigned __int16 a4, uint64_t a5, uint64_t a6)
{
  if ((a6 & 0x8000000000000000LL) == 0)
  {
    if ((unint64_t)a6 < 0x10000)
    {
      unsigned int v6 = a4 + (unsigned __int16)a6;
      unsigned int v7 = HIWORD(v6);
      goto LABEL_8;
    }

unint64_t specialized static Strideable<>._step(after:from:by:)( _BYTE *a1, uint64_t a2, uint64_t a3, unsigned __int8 a4, uint64_t a5, uint64_t a6)
{
  if ((a6 & 0x8000000000000000LL) == 0)
  {
    if ((unint64_t)a6 < 0x100)
    {
      unsigned int v6 = a4 + a6;
      unsigned int v7 = v6 >> 8;
      goto LABEL_8;
    }

unint64_t specialized static Strideable<>._step(after:from:by:)( uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((a6 & 0x8000000000000000LL) == 0)
  {
    uint64_t v6 = a4 + a6;
    BOOL v7 = __CFADD__(a4, a6);
    goto LABEL_8;
  }

  unint64_t v8 = -a6;
  if (__OFSUB__(0LL, a6))
  {
    __break(1u);
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  if ((v8 & 0x8000000000000000LL) != 0) {
    goto LABEL_13;
  }
  uint64_t v6 = a4 + a6;
  BOOL v7 = a4 < v8;
LABEL_8:
  unint64_t v9 = 0x8000000000000000LL;
  if (v7) {
    uint64_t v6 = ~a6 >> 63;
  }
  else {
    unint64_t v9 = 0LL;
  }
  *a1 = v6;
  return v9;
}

uint64_t static Strideable<>._step(after:from:by:)( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const char *a8, uint64_t a9)
{
  uint64_t v40 = a5;
  uint64_t v41 = a6;
  int v44 = a3;
  uint64_t v42 = a1;
  char v12 = a3 & 1;
  uint64x2_t v45 = a8;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a8,  a7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v37 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v36 = (char *)&v35 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  int64x2_t v38 = (char *)&v35 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, a7, "index value ", 0LL);
  uint64_t v43 = *(TupleTypeMetadata2 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v19 = (char *)&v35 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v35 - v21;
  unsigned int v23 = (char *)&v35 + *(int *)(v20 + 48) - v21;
  *(void *)uint64_t v22 = a2;
  v22[8] = v12;
  uint64_t v24 = *(void *)(a7 - 8);
  int8x8_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
  v25(v23, a4, a7);
  unint64_t v26 = &v19[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v46 = a2;
  *(void *)uint64_t v19 = a2;
  v19[8] = v12;
  v25(v26, (uint64_t)v23, a7);
  if ((v44 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v24 + 8))(v26, a7);
    (*((void (**)(uint64_t, uint64_t))v45 + 6))(v41, a7);
    (*(void (**)(char *, unint64_t *))(v43 + 8))(v22, TupleTypeMetadata2);
    return v46;
  }

  uint64_t v28 = (uint64_t)v45;
  (*(void (**)(char *, unint64_t *))(v43 + 8))(v22, TupleTypeMetadata2);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v24 + 8))(v26, a7);
  uint64_t v27 = v46 + 1;
  if (!__OFADD__(v46, 1LL))
  {
    int8x16_t v30 = v36;
    uint64_t v31 = AssociatedTypeWitness;
    (*(void (**)(uint64_t, unint64_t))(a9 + 64))(v27, AssociatedTypeWitness);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v28,  a7,  v31,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric);
    int64x2_t v33 = v38;
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 64LL))( v30,  v41,  v31);
    int64x2_t v34 = *(void (**)(char *, uint64_t))(v37 + 8);
    v34(v30, v31);
    (*(void (**)(char *, uint64_t, uint64_t))(v28 + 48))(v33, a7, v28);
    v34(v33, v31);
    return v27;
  }

  __break(1u);
  return result;
}

uint64_t static Strideable<>._step(after:from:by:)( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = a1;
  uint64_t v37 = a8;
  uint64_t v32 = a5;
  uint64_t v33 = a6;
  int v35 = a3;
  char v11 = a3 & 1;
  uint64_t v12 = *(void *)(a7 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v31 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v14, "index value ", 0LL);
  uint64_t v34 = *(TupleTypeMetadata2 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v30 - v20;
  uint64_t v22 = (char *)&v30 + *(int *)(v19 + 48) - v20;
  *(void *)uint64_t v21 = a2;
  v21[8] = v11;
  unsigned int v23 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v23(v22, a4, a7);
  uint64_t v24 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  *(void *)uint64_t v18 = a2;
  v18[8] = v11;
  v23(v24, (uint64_t)v22, a7);
  if ((v35 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v12 + 8))(v24, a7);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v37 + 24) + 48LL))(v33, a7);
    (*(void (**)(char *, unint64_t *))(v34 + 8))(v21, TupleTypeMetadata2);
    return a2;
  }

  uint64_t v25 = v37;
  (*(void (**)(char *, unint64_t *))(v34 + 8))(v21, TupleTypeMetadata2);
  unint64_t v26 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v26(v24, a7);
  if (!__OFADD__(a2++, 1LL))
  {
    int8x16_t v29 = v31;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v25 + 64))(a2, a7, v25);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 256))(v29, v33, a7, v25);
    v26(v29, a7);
    return a2;
  }

  __break(1u);
  return result;
}

uint64_t StrideToIterator._stride.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return DefaultIndices._endIndex.getter( a1,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride,  a2);
}

uint64_t (*StrideToIterator._current.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t StrideToIterator.init(_start:end:stride:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = *(void *)(a4 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a6, a1, a4);
  uint64_t v14 = (int *)type metadata accessor for StrideToIterator(0LL, a4, (uint64_t)a5, v13);
  uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 32);
  v20(a6 + v14[9], a2, a4);
  uint64_t v15 = a6 + v14[10];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( v15,  a3,  AssociatedTypeWitness);
  uint64_t v17 = a6 + v14[11];
  *(void *)uint64_t v17 = 0LL;
  *(_BYTE *)(v17 + 8) = 0;
  uint64_t v18 = v17 + *((int *)swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, a4, "index value ", 0LL) + 12);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v20)(v18, a1, a4);
}

uint64_t StrideTo._stride.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return DefaultIndices._endIndex.getter( a1,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride,  a2);
}

uint64_t StrideTo.init(_start:end:stride:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  return StrideTo.init(_start:end:stride:)( a1,  a2,  a3,  a4,  a5,  0x15CuLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for StrideTo,  a6);
}

uint64_t StrideTo.underestimatedCount.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v1, "index value ", 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint32x4_t v72 = (uint64_t *)((char *)&v65 - v3);
  unint64_t v4 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v1,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v87 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64x2_t v81 = (char *)&v65 - v6;
  uint64_t v7 = (uint64_t)v4;
  char v91 = v4;
  uint64_t v86 = *(const char **)(*(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v4,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                                   + 8)
                       + 16LL);
  unint64_t v85 = swift_getAssociatedTypeWitness( 0LL,  v86,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](v85);
  uint64x2_t v84 = (char *)&v65 - v9;
  uint64_t v10 = *(void *)(v1 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint16x8_t v71 = (char *)&v65 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v65 - v13;
  uint64_t v17 = type metadata accessor for Optional(0LL, v1, v15, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v82 = v17;
  uint64_t v83 = v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v65 - v20;
  uint64_t v22 = a1;
  uint64_t v23 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v25 = (char *)&v65 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = (int *)type metadata accessor for StrideToIterator(0LL, v1, v7, v26);
  uint64_t v65 = *((void *)v27 - 1);
  MEMORY[0x1895F8858](v27);
  int8x16_t v29 = (char *)&v65 - v28;
  uint64_t v30 = *(void (**)(char *, char *, uint64_t))(v23 + 16);
  uint64_t v31 = v10;
  uint64_t v32 = v21;
  v30(v25, v90, v22);
  uint64x2_t v74 = &v29[v27[11]];
  unint64_t v90 = &v74[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v33 = *(void (**)(void))(v31 + 32);
  v33();
  uint32x4_t v80 = &v29[v27[9]];
  int64x2_t v68 = v33;
  v33();
  int8x16_t v66 = v27;
  uint64_t v34 = *(void (**)(void))(v87 + 32);
  unint64_t v89 = &v29[v27[10]];
  v34();
  int v35 = *(void (**)(char *, char *, uint64_t))(v31 + 16);
  uint64x2_t v73 = v29;
  unsigned int v88 = v35;
  v35(v29, v90, v1);
  uint64_t v36 = v74;
  *(void *)uint64x2_t v74 = 0LL;
  v36[8] = 0;
  uint64_t v37 = v86;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v86,  AssociatedTypeWitness,  v85,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int8x16_t v39 = *(void (**)(void *, uint64_t))(AssociatedConformanceWitness + 8);
  uint64x2_t v78 = (void (*)(char *, unint64_t, const char *))*((void *)v37 + 3);
  uint64x2_t v79 = v39;
  unint64_t v40 = swift_getAssociatedConformanceWitness( (uint64_t)v91,  v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  uint64_t v41 = 0LL;
  uint32x4_t v76 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v40 + 40);
  unint64_t v77 = v40;
  unint64_t v70 = AssociatedTypeWitness;
  int8x16_t v69 = v32;
  unint64_t v67 = AssociatedConformanceWitness;
  while (1)
  {
    v88(v14, v90, v1);
    uint64_t v42 = v84;
    v79(&unk_18180BE68, 256LL);
    uint64_t v43 = v81;
    v78(v42, AssociatedTypeWitness, v86);
    char v44 = v76(v89, v43, AssociatedTypeWitness, v77);
    (*(void (**)(char *, unint64_t))(v87 + 8))(v43, AssociatedTypeWitness);
    uint64_t v45 = *((void *)v91 + 1);
    char v46 = (v44 & 1) != 0
    if ((v46 & 1) != 0)
    {
      (*(void (**)(char *, uint64_t))(v31 + 8))(v14, v1);
      uint64_t v47 = 1LL;
    }

    else
    {
      uint64x2_t v48 = v74;
      int8x16_t v49 = v72;
      uint64_t v50 = v31;
      int64x2_t v51 = (char *)v72 + *((int *)TupleTypeMetadata2 + 12);
      uint64_t v52 = *(void *)v74;
      uint64_t v53 = v74[8];
      *uint32x4_t v72 = *(void *)v74;
      *((_BYTE *)v49 + 8) = v53;
      int64x2_t v54 = v90;
      v88(v51, v90, v1);
      int8x16_t v55 = v14;
      int8x16_t v56 = v71;
      uint64_t v57 = (*((uint64_t (**)(char *, uint64_t, uint64_t, char *, char *, char *, uint64_t))v91 + 7))( v71,  v52,  v53,  v51,  v73,  v89,  v1);
      LOBYTE(v53) = v58;
      int64x2_t v59 = *(void (**)(char *, uint64_t))(v50 + 8);
      int8x16_t v60 = v51;
      uint64_t v31 = v50;
      unint64_t AssociatedTypeWitness = v70;
      v59(v60, v1);
      *(void *)uint64x2_t v48 = v57;
      v48[8] = v53 & 1;
      int8x16_t v61 = v56;
      uint64_t v14 = v55;
      uint64_t v32 = v69;
      (*(void (**)(char *, char *, uint64_t))(v31 + 40))(v54, v61, v1);
      ((void (*)(char *, char *, uint64_t))v68)(v32, v14, v1);
      uint64_t v47 = 0LL;
    }

    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v31 + 56))(v32, v47, 1LL, v1);
    int v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v31 + 48))(v32, 1LL, v1);
    (*(void (**)(char *, uint64_t))(v83 + 8))(v32, v82);
    if (v62 == 1) {
      break;
    }
    if (__OFADD__(v41++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  (*(void (**)(char *, int *))(v65 + 8))(v73, v66);
  return v41;
}

uint64_t StrideTo._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v47 = a1;
  uint64_t v48 = v4;
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v45 = (char *)&v42 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  char v44 = (char *)&v42 - v8;
  uint64_t v49 = *(void *)(v9 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v43 = (char *)&v42 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v42 = (char *)&v42 - v12;
  uint64_t v14 = *(void *)(v13 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  v3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v46 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v42 - v16;
  uint64_t v18 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( v14,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v18,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (char *)&v42 - v20;
  uint64_t v50 = a2;
  uint64_t v22 = v51 + *(int *)(a2 + 40);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v18,  AssociatedTypeWitness,  v19,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v19,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t, uint64_t))(v18 + 24))(v21, AssociatedTypeWitness, v18);
  unint64_t v24 = swift_getAssociatedConformanceWitness( v14,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  LOBYTE(v22) = (*(uint64_t (**)(uint64_t, char *, unint64_t, unint64_t))(v24 + 16))( v22,  v17,  AssociatedTypeWitness,  v24);
  (*(void (**)(char *, unint64_t))(v46 + 8))(v17, AssociatedTypeWitness);
  if ((v22 & 1) != 0)
  {
    uint64_t v25 = v50;
    uint64_t v26 = v51;
    uint64_t v27 = *(void *)(v14 + 8);
    uint64_t v28 = v47;
    char v29 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v27 + 24))( v47,  v51 + *(int *)(v50 + 36),  v3,  v27);
    uint64_t v30 = v49;
    uint64_t v31 = v42;
    (*(void (**)(char *, uint64_t, uint64_t))(v49 + 16))(v42, v26, v25);
    uint64_t v32 = v48;
    uint64_t v33 = v44;
    (*(void (**)(char *, uint64_t, uint64_t))(v48 + 16))(v44, v28, v3);
    if ((v29 & 1) == 0)
    {
      char v34 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 16))(v31, v33, v3, v27);
      goto LABEL_7;
    }

uint64_t StrideTo.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return StrideTo.customMirror.getter(a1, 28532LL, 0xE200000000000000LL, a2);
}

uint64_t StrideThroughIterator._stride.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return DefaultIndices._endIndex.getter( a1,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride,  a2);
}

uint64_t StrideToIterator._current.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v5, "index value ", 0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v9 = (char *)(v2 + *(int *)(a2 + 44));
  uint64_t v10 = *(int *)(v7 + 48);
  uint64_t v11 = (char *)&v15 + v10 - v8;
  uint64_t v12 = *(void *)v9;
  uint64_t v13 = *(void *)(v5 - 8);
  (*(void (**)(char *, char *, uint64_t))(v13 + 16))(v11, &v9[v10], v5);
  (*(void (**)(uint64_t, char *, uint64_t))(v13 + 32))(a1, v11, v5);
  return v12;
}

uint64_t StrideToIterator._current.setter(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v8, "index value ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v12 = (char *)v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)v22 - v14;
  uint64_t v16 = (char *)v22 + *(int *)(v13 + 48) - v14;
  *(void *)uint64_t v15 = a1;
  a2 &= 1u;
  v15[8] = a2;
  uint64_t v17 = *(void *)(v8 - 8);
  uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 32);
  v18(v16, a3, v8);
  unint64_t v19 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  *(void *)uint64_t v12 = a1;
  v12[8] = a2;
  v18(v19, (uint64_t)v16, v8);
  uint64_t v20 = v22[1] + *(int *)(a4 + 44);
  *(void *)uint64_t v20 = a1;
  *(_BYTE *)(v20 + 8) = a2;
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v17 + 40))( v20 + *((int *)TupleTypeMetadata2 + 12),  v19,  v8);
}

uint64_t (*StrideThroughIterator._current.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t StrideThroughIterator._didReturnEnd.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 48));
}

uint64_t StrideThroughIterator._didReturnEnd.setter(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(v2 + *(int *)(a2 + 48)) = result;
  return result;
}

uint64_t (*StrideThroughIterator._didReturnEnd.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t StrideThroughIterator.init(_start:end:stride:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = (int *)type metadata accessor for StrideThroughIterator(0LL, a4, (uint64_t)a5, a4);
  *(_BYTE *)(a6 + v12[12]) = 0;
  uint64_t v13 = *(void *)(a4 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16))(a6, a1, a4);
  unint64_t v19 = *(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 32);
  v19(a6 + v12[9], a2, a4);
  uint64_t v14 = a6 + v12[10];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( v14,  a3,  AssociatedTypeWitness);
  uint64_t v16 = a6 + v12[11];
  *(void *)uint64_t v16 = 0LL;
  *(_BYTE *)(v16 + 8) = 0;
  uint64_t v17 = v16 + *((int *)swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, a4, "index value ", 0LL) + 12);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v19)(v17, a1, a4);
}

uint64_t StrideThroughIterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v59 = a2;
  uint64_t v3 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v3, "index value ", 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  int8x16_t v55 = (uint64_t *)((char *)&v50 - v6);
  uint64_t v7 = *(void *)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v63 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v62 = (char *)&v50 - v9;
  uint64_t v10 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v50 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v54 = (char *)&v50 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  int8x16_t v60 = (char *)&v50 - v17;
  uint64_t v61 = a1;
  uint64_t v18 = (uint64_t *)(v2 + *(int *)(a1 + 44));
  int8x16_t v56 = TupleTypeMetadata2;
  uint64_t v57 = v18;
  uint64_t v19 = (uint64_t)v18 + *((int *)TupleTypeMetadata2 + 12);
  uint64_t v58 = v20;
  uint64_t v21 = *(void (**)(void))(v20 + 16);
  uint64_t v53 = v19;
  uint64_t v51 = v21;
  v21();
  uint64_t v22 = v2;
  uint64_t v23 = v2 + *(int *)(a1 + 40);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v10,  AssociatedTypeWitness,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v11,  AssociatedConformanceWitness);
  uint64_t v25 = v62;
  uint64_t v26 = v14;
  uint64_t v27 = v61;
  (*(void (**)(char *, unint64_t, uint64_t))(v10 + 24))(v26, AssociatedTypeWitness, v10);
  unint64_t v28 = swift_getAssociatedConformanceWitness( v7,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  char v29 = *(uint64_t (**)(uint64_t, char *, unint64_t, unint64_t))(v28 + 40);
  uint64_t v52 = v23;
  char v30 = v29(v23, v25, AssociatedTypeWitness, v28);
  (*(void (**)(char *, unint64_t))(v63 + 8))(v25, AssociatedTypeWitness);
  uint64_t v31 = *(void **)(v7 + 8);
  if ((v30 & 1) != 0) {
    uint64_t v32 = (uint64_t (*)(char *, uint64_t, uint64_t, void))v31[4];
  }
  else {
    uint64_t v32 = (uint64_t (*)(char *, uint64_t, uint64_t, void))v31[3];
  }
  uint64_t v33 = v60;
  if ((v32(v60, v22 + *(int *)(v27 + 36), v3, *(void *)(v7 + 8)) & 1) == 0)
  {
    char v38 = v55;
    uint64_t v39 = (char *)v55 + *((int *)v56 + 12);
    unint64_t v40 = v57;
    uint64_t v41 = *v57;
    uint64_t v42 = *((unsigned __int8 *)v57 + 8);
    *int8x16_t v55 = *v57;
    *((_BYTE *)v38 + 8) = v42;
    uint64_t v43 = v53;
    ((void (*)(char *, uint64_t, uint64_t))v51)(v39, v53, v3);
    uint64_t v44 = v7;
    uint64_t v45 = *(uint64_t (**)(char *, uint64_t, uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v46 = v54;
    uint64_t v47 = v45(v54, v41, v42, v39, v22, v52, v3, v44);
    LOBYTE(v42) = v48;
    uint64_t v35 = v58;
    (*(void (**)(char *, uint64_t))(v58 + 8))(v39, v3);
    *unint64_t v40 = v47;
    *((_BYTE *)v40 + 8) = v42 & 1;
    (*(void (**)(uint64_t, char *, uint64_t))(v35 + 40))(v43, v46, v3);
LABEL_11:
    uint64_t v37 = v59;
    (*(void (**)(uint64_t, char *, uint64_t))(v35 + 32))(v59, v33, v3);
    uint64_t v36 = 0LL;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v35 + 56))(v37, v36, 1LL, v3);
  }

  if (((*(uint64_t (**)(char *, uint64_t, uint64_t))(v31[1] + 8LL))(v33, v22 + *(int *)(v27 + 36), v3) & 1) != 0)
  {
    uint64_t v34 = *(int *)(v27 + 48);
    if ((*(_BYTE *)(v22 + v34) & 1) == 0 && ((v57[1] & 1) != 0 || *v57 != 0x8000000000000000LL))
    {
      *(_BYTE *)(v22 + v34) = 1;
      uint64_t v35 = v58;
      goto LABEL_11;
    }
  }

  uint64_t v35 = v58;
  (*(void (**)(char *, uint64_t))(v58 + 8))(v33, v3);
  uint64_t v36 = 1LL;
  uint64_t v37 = v59;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v35 + 56))(v37, v36, 1LL, v3);
}

uint64_t ClosedRange.upperBound.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))( a2,  v2 + *(int *)(a1 + 36));
}

uint64_t StrideThrough._stride.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return DefaultIndices._endIndex.getter( a1,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride,  a2);
}

uint64_t DefaultIndices._endIndex.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = v4 + *(int *)(a1 + 40);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(0LL, *(const char **)(a1 + 24), *(void *)(a1 + 16), a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a4,  v6,  AssociatedTypeWitness);
}

uint64_t StrideThrough.init(_start:end:stride:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  return StrideTo.init(_start:end:stride:)( a1,  a2,  a3,  a4,  a5,  0x237uLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for StrideThrough,  a6);
}

uint64_t StrideTo.init(_start:end:stride:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, unint64_t a6@<X5>, uint64_t (*a7)(void, uint64_t, uint64_t)@<X6>, uint64_t a8@<X8>)
{
  uint64_t v37 = a7;
  uint64_t v38 = a2;
  unint64_t v35 = a6;
  uint64_t v36 = a1;
  uint64_t v41 = a5;
  uint64_t v39 = a8;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v12 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( (uint64_t)a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v13);
  uint64_t v15 = (char *)&v34 - v14;
  uint64_t v16 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v17 = *(v16 - 1);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v23 = *(void (**)(char *, uint64_t, unint64_t *))(v17 + 16);
  uint64_t v40 = a3;
  v23((char *)&v34 - v21, a3, v16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v12,  (uint64_t)v16,  v13,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v13,  AssociatedConformanceWitness);
  uint64_t v25 = *(void (**)(char *, unint64_t *, uint64_t))(v12 + 24);
  uint64_t v26 = v12;
  uint64_t v27 = (uint64_t)v41;
  v25(v15, v16, v26);
  unint64_t v28 = swift_getAssociatedConformanceWitness( v27,  a4,  (uint64_t)v16,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  LOBYTE(v15) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v28 + 8) + 8LL))( v22,  v20,  v16);
  char v29 = *(void (**)(char *, unint64_t *))(v17 + 8);
  v29(v20, v16);
  if ((v15 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Stride size must not be zero",  28LL,  2,  "Swift/Stride.swift",  18LL,  2,  v35,  0);
  }
  v29(v22, v16);
  char v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32LL);
  uint64_t v31 = v39;
  v30(v39, v36, a4);
  uint64_t v32 = v37(0LL, a4, v27);
  v30(v31 + *(int *)(v32 + 36), v38, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t *))(v17 + 32))( v31 + *(int *)(v32 + 40),  v40,  v16);
}

uint64_t StrideThrough.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *(const char **)(a1 + 24);
  uint64_t v9 = (int *)type metadata accessor for StrideThroughIterator(0LL, v7, (uint64_t)v8, a2);
  uint64_t v10 = a3 + v9[11];
  uint64_t v11 = v10 + *((int *)swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v7, "index value ", 0LL) + 12);
  uint64_t v12 = *(void *)(v7 - 8);
  unint64_t v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 32);
  v13(v11, v4, v7);
  v13(a3 + v9[9], v4 + *(int *)(a1 + 36), v7);
  uint64_t v14 = v4 + *(int *)(a1 + 40);
  uint64_t v15 = a3 + v9[10];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v8,  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( v15,  v14,  AssociatedTypeWitness);
  *(_BYTE *)(a3 + v9[12]) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a3, v11, v7);
  *(void *)uint64_t v10 = 0LL;
  *(_BYTE *)(v10 + 8) = 0;
  return result;
}

uint64_t StrideThrough.underestimatedCount.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = type metadata accessor for Optional(0LL, v7, a3, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v30 - v11;
  uint64_t v13 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v30 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v33 = *(const char **)(a1 + 24);
  uint64_t v17 = (int *)type metadata accessor for StrideThroughIterator(0LL, v7, (uint64_t)v33, v16);
  uint64_t v30 = *((void *)v17 - 1);
  MEMORY[0x1895F8858](v17);
  uint64_t v19 = (char *)&v30 - v18;
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, v5, a1);
  uint64_t v32 = &v19[v17[11]];
  uint64_t v20 = v32;
  uint64_t v31 = &v20[*((int *)swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v7, "index value ", 0LL) + 12)];
  uint64_t v21 = *(void *)(v7 - 8);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  v22();
  ((void (*)(char *, char *, uint64_t))v22)(&v19[v17[9]], &v15[*(int *)(a1 + 36)], v7);
  uint64_t v23 = &v15[*(int *)(a1 + 40)];
  unint64_t v24 = &v19[v17[10]];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v33,  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  (*(void (**)(char *, char *, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( v24,  v23,  AssociatedTypeWitness);
  v19[v17[12]] = 0;
  (*(void (**)(char *, char *, uint64_t))(v21 + 16))(v19, v31, v7);
  uint64_t v26 = 0LL;
  uint64_t v27 = v32;
  *(void *)uint64_t v32 = 0LL;
  v27[8] = 0;
  while (1)
  {
    StrideThroughIterator.next()((uint64_t)v17, (uint64_t)v12);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
    if (__OFADD__(v26++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  (*(void (**)(char *, int *))(v30 + 8))(v19, v17);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  return v26;
}

uint64_t StrideThrough._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v47 = a1;
  uint64_t v48 = v4;
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v45 = (char *)&v42 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v44 = (char *)&v42 - v8;
  uint64_t v49 = *(void *)(v9 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v43 = (char *)&v42 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v42 = (char *)&v42 - v12;
  uint64_t v14 = *(void *)(v13 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  v3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v46 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v42 - v16;
  uint64_t v18 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( v14,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v18,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (char *)&v42 - v20;
  uint64_t v50 = a2;
  uint64_t v22 = v51 + *(int *)(a2 + 40);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v18,  AssociatedTypeWitness,  v19,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v19,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t, uint64_t))(v18 + 24))(v21, AssociatedTypeWitness, v18);
  unint64_t v24 = swift_getAssociatedConformanceWitness( v14,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  LOBYTE(v22) = (*(uint64_t (**)(uint64_t, char *, unint64_t, unint64_t))(v24 + 16))( v22,  v17,  AssociatedTypeWitness,  v24);
  (*(void (**)(char *, unint64_t))(v46 + 8))(v17, AssociatedTypeWitness);
  if ((v22 & 1) != 0)
  {
    uint64_t v25 = v50;
    uint64_t v26 = v51;
    uint64_t v27 = *(void *)(v14 + 8);
    unint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v27 + 16);
    uint64_t v29 = v47;
    char v30 = v28(v47, v51 + *(int *)(v50 + 36), v3, v27);
    uint64_t v31 = v49;
    uint64_t v32 = v42;
    (*(void (**)(char *, uint64_t, uint64_t))(v49 + 16))(v42, v26, v25);
    uint64_t v33 = v48;
    uint64_t v34 = v44;
    (*(void (**)(char *, uint64_t, uint64_t))(v48 + 16))(v44, v29, v3);
    if ((v30 & 1) == 0)
    {
      unint64_t v35 = v32;
      goto LABEL_7;
    }

uint64_t StrideThrough.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return StrideTo.customMirror.getter(a1, 0x6867756F726874LL, 0xE700000000000000LL, a2);
}

uint64_t StrideTo.customMirror.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = v4;
  uint64_t v10 = *(void *)(a1 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v39 = (uint64_t *)((char *)&v40[-1] - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v40[-1] - v13;
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))((char *)&v40[-1] - v13, v7, a1);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  uint64_t v16 = swift_allocObject(v15, 0xB0uLL, 7uLL);
  *((_OWORD *)v16 + 1) = xmmword_1817FFDE0;
  v16[4] = 1836020326LL;
  v16[5] = 0xE400000000000000LL;
  uint64_t v17 = *(void *)(a1 + 16);
  v16[9] = v17;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v16 + 6);
  unint64_t v19 = *(void (**)(void *, uint64_t, uint64_t))(*(void *)(v17 - 8) + 16LL);
  v19(boxed_opaque_existential_0Tm, v7, v17);
  v16[10] = a2;
  v16[11] = a3;
  uint64_t v20 = v7 + *(int *)(a1 + 36);
  v16[15] = v17;
  uint64_t v21 = __swift_allocate_boxed_opaque_existential_0Tm(v16 + 12);
  v19(v21, v20, v17);
  v16[16] = 31074LL;
  v16[17] = 0xE200000000000000LL;
  uint64_t v22 = v7 + *(int *)(a1 + 40);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 24),  v17,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  v16[21] = AssociatedTypeWitness;
  unint64_t v24 = __swift_allocate_boxed_opaque_existential_0Tm(v16 + 18);
  (*(void (**)(void *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( v24,  v22,  AssociatedTypeWitness);
  v40[0] = 0LL;
  v40[1] = 0LL;
  uint64_t v25 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v14, (uint64_t)v40, (swift *)a1);
  uint64_t v27 = v26;
  uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  uint64_t v29 = swift_allocObject(v28, 0x48uLL, 7uLL);
  v29[6] = v16;
  v29[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v29[8] = 0LL;
  uint64_t v30 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v31 = swift_allocObject(v30, 0x18uLL, 7uLL);
  v31[2] = 0LL;
  uint64_t v32 = v16[2];
  uint64_t v33 = swift_allocObject(v30, 0x18uLL, 7uLL);
  v33[2] = v32;
  v29[2] = v31;
  v29[3] = &protocol witness table for _IndexBox<A>;
  v29[4] = v33;
  v29[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v34 = *(void (**)(uint64_t *, char *, uint64_t))(v10 + 32);
  unint64_t v35 = v39;
  v34(v39, v14, a1);
  uint64_t v36 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v40, v35, (swift *)a1, v36, 6uLL);
  char v38 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v40);
  }
  *(void *)a4 = a1;
  *(void *)(a4 + 8) = v29;
  *(_BYTE *)(a4 + 16) = 8;
  *(void *)(a4 + 24) = v25;
  *(void *)(a4 + 32) = v27;
  *(_BYTE *)(a4 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = v38;
  return result;
}

uint64_t stride<A>(from:through:by:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  return stride<A>(from:to:by:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(char *, char *, char *, uint64_t, const char *))StrideThrough.init(_start:end:stride:),  a6);
}

uint64_t stride<A>(from:to:by:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t (*a6)(char *, char *, char *, uint64_t, const char *)@<X5>, uint64_t a7@<X8>)
{
  uint64_t v26 = a7;
  uint64_t v27 = a6;
  uint64_t v25 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v24 - v14;
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v24 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v24 - v19;
  uint64_t v22 = *(void (**)(char *, uint64_t, uint64_t))(v21 + 16);
  v22((char *)&v24 - v19, a1, a4);
  v22(v18, a2, a4);
  (*(void (**)(char *, uint64_t, unint64_t))(v12 + 16))(v15, v25, AssociatedTypeWitness);
  return v27(v20, v18, v15, a4, a5);
}

uint64_t _StringGuts.withFastUTF8<A>(_:)( uint64_t (*a1)(void *, uint64_t), uint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a4 & 0x2000000000000000LL) != 0)
  {
    uint64_t v6 = HIBYTE(a4) & 0xF;
    v8[0] = a3;
    v8[1] = a4 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v5 = v8;
  }

  else if ((a3 & 0x1000000000000000LL) != 0)
  {
    uint64_t v5 = (void *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v5 = _StringObject.sharedUTF8.getter(a3, a4);
  }

  return a1(v5, v6);
}

void _StringGutsSlice._normalizedHash(into:)( unint64_t *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((a3 & 0x2000000000000000LL) != 0) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = a2;
  }
  if ((a3 & 0x1000000000000000LL) == 0 && (v5 & 0x4000000000000000LL) != 0)
  {
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      v17[0] = a2;
      v17[1] = a3 & 0xFFFFFFFFFFFFFFLL;
      if ((a4 & 0x8000000000000000LL) == 0)
      {
        if ((uint64_t)(HIBYTE(a3) & 0xF) >= a5)
        {
          if (a5 - a4 < 0) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
          }
          uint64_t v10 = (char *)v17 + a4;
          uint64_t v11 = (char *)v17 + a5;
          goto LABEL_16;
        }

        goto LABEL_18;
      }
    }

    else if ((a2 & 0x1000000000000000LL) != 0)
    {
      uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFFLL) + 32;
      uint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
      if ((a4 & 0x8000000000000000LL) == 0) {
        goto LABEL_9;
      }
    }

    else
    {
      uint64_t v15 = a5;
      uint64_t v16 = a4;
      id v13 = _StringObject.sharedUTF8.getter(a2, a3);
      a5 = v15;
      a4 = v16;
      uint64_t v6 = (uint64_t)v13;
      uint64_t v7 = v14;
      if ((v16 & 0x8000000000000000LL) == 0)
      {
LABEL_9:
        if (v7 >= a5)
        {
          uint64_t v8 = specialized UnsafeBufferPointer.init(rebasing:)(a4, a5, v6, v7);
          uint64_t v10 = (char *)specialized UnsafeRawBufferPointer.init<A>(_:)(v8, v9);
LABEL_16:
          Hasher.combine(bytes:)(*(Swift::UnsafeRawBufferPointer *)&v10);
          goto LABEL_17;
        }

void StringProtocol.hash(into:)(unint64_t *a1, ValueMetadata *a2, uint64_t a3)
{
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (Swift::UInt64 *)((char *)&v31 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  unint64_t v12 = (uint64_t *)((char *)&v31 - v11);
  MEMORY[0x1895F8858](v10);
  uint64_t v15 = (uint64_t *)((char *)&v31 - v14);
  if (v16 == &type metadata for String)
  {
    unint64_t v24 = *v3;
    unint64_t v25 = v3[1];
    if ((v25 & 0x2000000000000000LL) != 0) {
      uint64_t v26 = HIBYTE(v25) & 0xF;
    }
    else {
      uint64_t v26 = *v3 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v27 = a1;
    uint64_t v28 = 0LL;
    goto LABEL_10;
  }

  if (a2 == &type metadata for Substring)
  {
    unint64_t v24 = v3[2];
    unint64_t v25 = v3[3];
    uint64_t v28 = *v3 >> 16;
    uint64_t v26 = v3[1] >> 16;
    uint64_t v27 = a1;
LABEL_10:
    _StringGutsSlice._normalizedHash(into:)(v27, v24, v25, v28, v26);
    return;
  }

  uint64_t v17 = *(void (**)(char *, unint64_t *, ValueMetadata *))(v13 + 16);
  v17((char *)&v31 - v14, v3, a2);
  if (swift_dynamicCast((char *)&v31, v15, (swift *)a2, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v18 = 0LL;
    Swift::UInt64 v19 = v31;
    unint64_t v20 = v32;
    uint64_t v21 = HIBYTE(v32) & 0xF;
    uint64_t v22 = v31 & 0xFFFFFFFFFFFFLL;
    BOOL v23 = (v32 & 0x2000000000000000LL) == 0;
    goto LABEL_14;
  }

  v17((char *)v12, v3, a2);
  if ((swift_dynamicCast((char *)&v31, v12, (swift *)a2, (const char *)&type metadata for Substring, 6uLL) & 1) == 0)
  {
    v17((char *)v9, v3, a2);
    Swift::UInt64 v19 = String.init<A>(_:)(v9, (swift *)a2, *(void *)(a3 + 40));
    unint64_t v20 = v30;
    uint64_t v18 = 0LL;
    uint64_t v21 = HIBYTE(v30) & 0xF;
    uint64_t v22 = v19 & 0xFFFFFFFFFFFFLL;
    BOOL v23 = (v30 & 0x2000000000000000LL) == 0;
LABEL_14:
    if (v23) {
      uint64_t v29 = v22;
    }
    else {
      uint64_t v29 = v21;
    }
    goto LABEL_17;
  }

  Swift::UInt64 v19 = v33;
  unint64_t v20 = v34;
  uint64_t v18 = v31 >> 16;
  uint64_t v29 = v32 >> 16;
LABEL_17:
  _StringGutsSlice._normalizedHash(into:)(a1, v19, v20, v18, v29);
  swift_bridgeObjectRelease(v20);
}

unsigned __int8 *specialized _StringGutsSlice.withFastUTF8<A>(_:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      id v8 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_4;
      }
    }

    else
    {
      id v8 = _StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v9 = v14;
      if ((a3 & 0x8000000000000000LL) == 0)
      {
LABEL_4:
        if (v9 >= a4)
        {
          uint64_t v10 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(a3, a4, (uint64_t)v8, v9);
          return specialized closure #1 in _StringGutsSlice._withNFCCodeUnits(_:)(v10, v11, a5);
        }

        goto LABEL_11;
      }
    }

__objc2_class **specialized _StringGutsSlice.withFastUTF8<A>(_:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      id v8 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_4;
      }
    }

    else
    {
      id v8 = _StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v9 = v14;
      if ((a3 & 0x8000000000000000LL) == 0)
      {
LABEL_4:
        if (v9 >= a4)
        {
          uint64_t v10 = (__objc2_class **)specialized UnsafeBufferPointer.init(rebasing:)(a3, a4, (uint64_t)v8, v9);
          return specialized closure #1 in _StringGutsSlice._withNFCCodeUnits(_:)(v10, v11, a5);
        }

        goto LABEL_11;
      }
    }

uint64_t specialized _StringGutsSlice.withFastUTF8<A>(_:)( uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v8 = a3;
  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((result & 0x1000000000000000LL) != 0)
    {
      id v9 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v10 = result & 0xFFFFFFFFFFFFLL;
      if ((v8 & 0x8000000000000000LL) == 0) {
        goto LABEL_4;
      }
    }

    else
    {
      id v9 = _StringObject.sharedUTF8.getter(result, a2);
      uint64_t v10 = v15;
      if ((v8 & 0x8000000000000000LL) == 0)
      {
LABEL_4:
        if (v10 >= a4)
        {
          uint64_t result = specialized UnsafeBufferPointer.init(rebasing:)(v8, a4, (uint64_t)v9, v10);
          if (result)
          {
            uint64_t v12 = v11;
            if (v11)
            {
              unint64_t v13 = (unsigned __int8 *)result;
              do
              {
                uint64_t result = a5(*v13);
                if (v5) {
                  break;
                }
                ++v13;
                --v12;
              }

              while (v12);
            }
          }

          return result;
        }

        goto LABEL_18;
      }
    }

void specialized _StringGutsSlice._withNFCCodeUnits(_:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  v11._unint64_t rawBits = (a3 << 16) | 1;
  v12._unint64_t rawBits = (a4 << 16) | 1;
  Swift::UInt64 v13 = _StringGuts.validateScalarRange(_:)(v11, v12, a1, a2);
  unint64_t v17 = v14;
  if (v13 >= 0x10000) {
    unint64_t v18 = v13;
  }
  else {
    unint64_t v18 = v13 | 3;
  }
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v19 = a2;
  }
  else {
    unint64_t v19 = a1;
  }
  if ((v19 & 0x4000000000000000LL) != 0)
  {
    if ((v18 ^ v14) >= 0x4000)
    {
      uint64_t v20 = (a1 >> 59) & 1;
      if ((a2 & 0x1000000000000000LL) == 0) {
        LOBYTE(v2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = 1;
      }
      uint64_t v21 = 4LL << v20;
      uint64_t v22 = HIBYTE(a2) & 0xF;
      if ((a2 & 0x2000000000000000LL) == 0) {
        uint64_t v22 = a1 & 0xFFFFFFFFFFFFLL;
      }
      unint64_t v38 = v22;
      unint64_t rawBits = v18;
      do
      {
        Swift::UInt8 v24 = Substring.UTF8View.subscript.getter(rawBits, v18, v17, a1, a2);
        if ((rawBits & 0xC) == v21)
        {
          unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if ((a2 & 0x1000000000000000LL) == 0)
          {
LABEL_16:
            unint64_t rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
            goto LABEL_17;
          }
        }

        else if ((a2 & 0x1000000000000000LL) == 0)
        {
          goto LABEL_16;
        }

        if (v38 <= rawBits >> 16) {
          goto LABEL_43;
        }
        unint64_t rawBits = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_17:
        Hasher._combine(_:)(v24);
      }

      while ((rawBits ^ v17) >= 0x4000);
    }
  }

  else
  {
    Swift::Bool v41 = 1;
    Swift::UInt8 v40 = 0;
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      unint64_t v28 = v14 >> 14;
      swift_bridgeObjectRetain(a2, v14, v15, v16);
      v29._unint64_t rawBits = v18;
      while (v28 != v29._rawBits >> 14)
      {
        v30._unint64_t rawBits = v29._rawBits;
        v31._unint64_t rawBits = _StringGuts.validateScalarIndex(_:in:)(v30, v18, v17, a1, a2)._rawBits;
        Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v31._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
        v33._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)(v29)._rawBits;
        v29._unint64_t rawBits = String.UnicodeScalarView._foreignIndex(after:)(v33)._rawBits;
        if (!specialized _StringGutsSlice._isScalarNFCQC(_:_:)(value, &v40))
        {
          swift_bridgeObjectRelease(a2);
          goto LABEL_30;
        }
      }

      swift_bridgeObjectRelease(a2);
      uint64_t v35 = HIBYTE(a2) & 0xF;
      if ((a2 & 0x2000000000000000LL) == 0) {
        uint64_t v35 = a1 & 0xFFFFFFFFFFFFLL;
      }
      Swift::UInt64 v39 = v35;
      v36._unint64_t rawBits = v18;
      do
      {
        if (v28 == v36._rawBits >> 14) {
          break;
        }
        Swift::UInt8 v37 = Substring.UTF8View.subscript.getter(v36._rawBits, v18, v17, a1, a2);
        if ((v36._rawBits & 0xC) == 4LL << ((a1 & 0x800000000000000LL) != 0)) {
          v36._unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v36)._rawBits;
        }
        if (v39 <= v36._rawBits >> 16) {
LABEL_43:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
        v36._unint64_t rawBits = String.UTF8View._foreignIndex(after:)(v36)._rawBits;
        Hasher._combine(_:)(v37);
      }

      while (!v5);
    }

    else
    {
      _StringGutsSlice._fastNFCCheck(_:_:)(&v41, &v40);
      if (v41)
      {
        specialized _StringGutsSlice.withFastUTF8<A>(_:)(a1, a2, a3, a4, a5);
      }

      else
      {
LABEL_30:
        swift_bridgeObjectRetain(a2, v25, v26, v27);
        do
        {
          unint64_t v34 = specialized Unicode._InternalNFC.Iterator.next()();
          if ((v34 & 0x100000000LL) != 0) {
            break;
          }
          specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v34, a5);
        }

        while (!v5);
        swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
        swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
        swift_bridgeObjectRelease(a2);
      }
    }
  }

void specialized _StringGutsSlice._withNFCCodeUnits(_:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  v11._unint64_t rawBits = (a3 << 16) | 1;
  v12._unint64_t rawBits = (a4 << 16) | 1;
  Swift::UInt64 v13 = _StringGuts.validateScalarRange(_:)(v11, v12, a1, a2);
  unint64_t v17 = v16;
  if (v13 >= 0x10000) {
    uint64_t v18 = v13;
  }
  else {
    uint64_t v18 = v13 | 3;
  }
  unint64_t v50 = a1;
  uint64_t v51 = a2;
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v19 = a2;
  }
  else {
    unint64_t v19 = a1;
  }
  if ((v19 & 0x4000000000000000LL) != 0)
  {
    if ((v18 ^ v17) >= 0x4000)
    {
      uint64_t v20 = a2;
      uint64_t v21 = (a1 >> 59) & 1;
      if ((a2 & 0x1000000000000000LL) == 0) {
        LOBYTE(v21) = 1;
      }
      uint64_t v22 = 4LL << v21;
      uint64_t v23 = HIBYTE(a2) & 0xF;
      if ((a2 & 0x2000000000000000LL) == 0) {
        uint64_t v23 = a1 & 0xFFFFFFFFFFFFLL;
      }
      unint64_t v49 = v23;
      unint64_t rawBits = v18;
      do
      {
        uint64_t v25 = v18;
        unint64_t v26 = v17;
        char v27 = Substring.UTF8View.subscript.getter(rawBits, v18, v17, a1, v20);
        if ((rawBits & 0xC) == v22)
        {
          unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if ((v20 & 0x1000000000000000LL) != 0)
          {
LABEL_24:
            if (v49 <= rawBits >> 16) {
              goto LABEL_49;
            }
            unint64_t rawBits = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
            goto LABEL_17;
          }
        }

        else if ((v20 & 0x1000000000000000LL) != 0)
        {
          goto LABEL_24;
        }

        unint64_t rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_17:
        uint64_t v28 = *a5;
        BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*a5);
        *a5 = v28;
        if (!isUniquelyReferenced_nonNull_native)
        {
          uint64_t v28 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v28 + 16) + 1LL,  1,  v28);
          *a5 = v28;
        }

        unint64_t v31 = *(void *)(v28 + 16);
        unint64_t v30 = *(void *)(v28 + 24);
        if (v31 >= v30 >> 1)
        {
          unint64_t v32 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v30 > 1),  v31 + 1,  1,  v28);
          unint64_t v17 = v26;
          uint64_t v18 = v25;
          uint64_t v28 = (uint64_t)v32;
        }

        else
        {
          uint64_t v18 = v25;
          unint64_t v17 = v26;
        }

        *(void *)(v28 + 16) = v31 + 1;
        *(_BYTE *)(v28 + v31 + 32) = v27;
        *a5 = v28;
        a1 = v50;
        uint64_t v20 = v51;
      }

      while ((rawBits ^ v17) >= 0x4000);
    }
  }

  else
  {
    unint64_t v33 = v17;
    unint64_t v34 = v18;
    Swift::Bool v53 = 1;
    Swift::UInt8 v52 = 0;
    unint64_t v35 = a2;
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      unint64_t v39 = v17 >> 14;
      swift_bridgeObjectRetain(a2, v18, v14, v15);
      v40._unint64_t rawBits = v34;
      while (v39 != v40._rawBits >> 14)
      {
        v41._unint64_t rawBits = v40._rawBits;
        v42._unint64_t rawBits = _StringGuts.validateScalarIndex(_:in:)(v41, v34, v33, v50, a2)._rawBits;
        Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v42._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
        v44._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)(v40)._rawBits;
        v40._unint64_t rawBits = String.UnicodeScalarView._foreignIndex(after:)(v44)._rawBits;
        if (!specialized _StringGutsSlice._isScalarNFCQC(_:_:)(value, &v52))
        {
          unint64_t v35 = a2;
          swift_bridgeObjectRelease(a2);
          goto LABEL_35;
        }
      }

      swift_bridgeObjectRelease(a2);
      if ((a2 & 0x2000000000000000LL) != 0) {
        unint64_t v46 = HIBYTE(a2) & 0xF;
      }
      else {
        unint64_t v46 = v50 & 0xFFFFFFFFFFFFLL;
      }
      v47._unint64_t rawBits = v34;
      do
      {
        if (v39 == v47._rawBits >> 14) {
          break;
        }
        char v48 = Substring.UTF8View.subscript.getter(v47._rawBits, v34, v33, v50, v51);
        if ((v47._rawBits & 0xC) == 4LL << ((v50 & 0x800000000000000LL) != 0))
        {
          v47._unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v47)._rawBits;
          if (v46 <= v47._rawBits >> 16) {
LABEL_49:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
        }

        else if (v46 <= v47._rawBits >> 16)
        {
          goto LABEL_49;
        }

        v47._unint64_t rawBits = String.UTF8View._foreignIndex(after:)(v47)._rawBits;
        closure #1 in String._nfcCodeUnits.getter(v48, a5);
      }

      while (!v5);
    }

    else
    {
      _StringGutsSlice._fastNFCCheck(_:_:)(&v53, &v52);
      if (v53)
      {
        specialized _StringGutsSlice.withFastUTF8<A>(_:)(a1, a2, a3, a4, a5);
      }

      else
      {
LABEL_35:
        swift_bridgeObjectRetain(v35, v36, v37, v38);
        do
        {
          unint64_t v45 = specialized Unicode._InternalNFC.Iterator.next()();
          if ((v45 & 0x100000000LL) != 0) {
            break;
          }
          specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v45, a5);
        }

        while (!v5);
        swift_bridgeObjectRelease(v35);
        swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
        swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
      }
    }
  }

void _StringGutsSlice._withNFCCodeUnits(_:)( void (*a1)(uint64_t), uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  v11._unint64_t rawBits = (a5 << 16) | 1;
  v12._unint64_t rawBits = (a6 << 16) | 1;
  Swift::UInt64 v13 = _StringGuts.validateScalarRange(_:)(v11, v12, a3, a4);
  unint64_t v17 = v14;
  if (v13 >= 0x10000) {
    unint64_t v18 = v13;
  }
  else {
    unint64_t v18 = v13 | 3;
  }
  if ((a4 & 0x2000000000000000LL) != 0) {
    unint64_t v19 = a4;
  }
  else {
    unint64_t v19 = a3;
  }
  if ((v19 & 0x4000000000000000LL) != 0)
  {
    uint64_t v20 = (a3 >> 59) & 1;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = 1;
    }
    uint64_t v21 = 4LL << v20;
    uint64_t v22 = HIBYTE(a4) & 0xF;
    if ((a4 & 0x2000000000000000LL) == 0) {
      uint64_t v22 = a3 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v37 = v22;
    unint64_t rawBits = v18;
    while (1)
    {
      if ((rawBits ^ v17) < 0x4000) {
        return;
      }
      uint64_t v24 = Substring.UTF8View.subscript.getter(rawBits, v18, v17, a3, a4);
      if ((rawBits & 0xC) == v21)
      {
        unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
        if ((a4 & 0x1000000000000000LL) == 0)
        {
LABEL_16:
          unint64_t rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
          goto LABEL_17;
        }
      }

      else if ((a4 & 0x1000000000000000LL) == 0)
      {
        goto LABEL_16;
      }

      if (v37 <= rawBits >> 16) {
        goto LABEL_44;
      }
      unint64_t rawBits = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_17:
      a1(v24);
      if (v6) {
        return;
      }
    }
  }

  Swift::Bool v41 = 1;
  Swift::UInt8 v40 = 0;
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    unint64_t v38 = v14 >> 14;
    swift_bridgeObjectRetain(a4, v14, v15, v16);
    v28._unint64_t rawBits = v18;
    while (v38 != v28._rawBits >> 14)
    {
      v29._unint64_t rawBits = v28._rawBits;
      v30._unint64_t rawBits = _StringGuts.validateScalarIndex(_:in:)(v29, v18, v17, a3, a4)._rawBits;
      Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v30._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
      v32._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)(v28)._rawBits;
      v28._unint64_t rawBits = String.UnicodeScalarView._foreignIndex(after:)(v32)._rawBits;
      if (!specialized _StringGutsSlice._isScalarNFCQC(_:_:)(value, &v40))
      {
        swift_bridgeObjectRelease(a4);
        goto LABEL_29;
      }
    }

    swift_bridgeObjectRelease(a4);
    if ((a4 & 0x2000000000000000LL) != 0) {
      unint64_t v34 = HIBYTE(a4) & 0xF;
    }
    else {
      unint64_t v34 = a3 & 0xFFFFFFFFFFFFLL;
    }
    v35._unint64_t rawBits = v18;
    do
    {
      if (v38 == v35._rawBits >> 14) {
        break;
      }
      uint64_t v36 = Substring.UTF8View.subscript.getter(v35._rawBits, v18, v17, a3, a4);
      if ((v35._rawBits & 0xC) == 4LL << ((a3 & 0x800000000000000LL) != 0))
      {
        v35._unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v35)._rawBits;
        if (v34 <= v35._rawBits >> 16) {
LABEL_44:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
      }

      else if (v34 <= v35._rawBits >> 16)
      {
        goto LABEL_44;
      }

      v35._unint64_t rawBits = String.UTF8View._foreignIndex(after:)(v35)._rawBits;
      a1(v36);
    }

    while (!v6);
  }

  else
  {
    _StringGutsSlice._fastNFCCheck(_:_:)(&v41, &v40);
    if (v41)
    {
      specialized _StringGutsSlice.withFastUTF8<A>(_:)(a3, a4, a5, a6, (uint64_t (*)(void))a1);
    }

    else
    {
LABEL_29:
      swift_bridgeObjectRetain(a4, v25, v26, v27);
      do
      {
        unint64_t v33 = specialized Unicode._InternalNFC.Iterator.next()();
        if ((v33 & 0x100000000LL) != 0) {
          break;
        }
        specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v33, (uint64_t (*)(void))a1);
      }

      while (!v6);
      swift_bridgeObjectRelease(a4);
      swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
      swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
    }
  }

void unimplemented_utf8_32bit(_:file:line:)( uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, char a5, unint64_t a6)
{
}

uint64_t (*String._guts.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _StringGuts.init(_initialCapacity:)(Swift::Int a1)
{
  if (a1 < 16) {
    return 0LL;
  }
  _StringGuts.grow(_:)(a1);
  return 0LL;
}

uint64_t _StringGuts.init()()
{
  return 0LL;
}

BOOL specialized == infix<A, B>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v25 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, (uint64_t)&type metadata for Int, 0LL, 0LL);
  uint64_t v12 = *(TupleTypeMetadata2 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v15 = (char *)&v24 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  unint64_t v17 = (char *)&v24 - v16;
  unint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL);
  v18((char *)&v24 - v16, a1, a5);
  *(void *)&v17[*((int *)TupleTypeMetadata2 + 12)] = a2;
  v18(v15, a3, a5);
  uint64_t v19 = *((int *)TupleTypeMetadata2 + 12);
  *(void *)&v15[v19] = v25;
  char v20 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a6 + 8))(v17, v15, a5, a6);
  uint64_t v21 = *(void (**)(char *, unint64_t *))(v12 + 8);
  if ((v20 & 1) != 0)
  {
    v21(v17, TupleTypeMetadata2);
    uint64_t v22 = *(void *)&v15[v19];
    v21(v15, TupleTypeMetadata2);
    return v22 == a2;
  }

  else
  {
    v21(v15, TupleTypeMetadata2);
    v21(v17, TupleTypeMetadata2);
    return 0LL;
  }

uint64_t == infix<A, B>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a8;
  uint64_t v27 = a3;
  uint64_t v28 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, a6, 0LL, 0LL);
  uint64_t v29 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v16 = (char *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  unint64_t v18 = (char *)&v26 - v17;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL);
  v19((char *)&v26 - v17, a1, a5);
  char v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16LL);
  v21(v20, a2, a6);
  v19(v16, v27, a5);
  uint64_t v22 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v22, v28, a6);
  else {
    char v23 = 0;
  }
  uint64_t v24 = *(void (**)(char *, unint64_t *))(v29 + 8);
  v24(v16, TupleTypeMetadata2);
  v24(v18, TupleTypeMetadata2);
  return v23 & 1;
}

uint64_t static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 56))(a2, v7);
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  if (_swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness)
    && (v8 < 0 || (v8 & 0x4000000000000000LL) != 0))
  {
    uint64_t v35 = v8;
    uint64_t v25 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)AssociatedTypeWitness, v10, v11);
    swift_retain((unint64_t *)v8, v26, v27, v28);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v25, v29);
    uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v25, WitnessTable);
    uint64_t v32 = *(unsigned __int8 *)(*(AssociatedTypeWitness - 1) + 80);
    closure #1 in static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)( v31 + ((v32 + 32) & ~v32),  *(void *)(v31 + 16),  a2,  a3,  (uint64_t)&v35);
    uint64_t v22 = v35;
    swift_release(v8);
    uint64_t v23 = v31;
    goto LABEL_14;
  }

  _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
  uint64_t v12 = *(AssociatedTypeWitness - 1);
  uint64_t v13 = *(unsigned __int8 *)(v12 + 80);
  if (_swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness)
    && (v8 < 0 || (v8 & 0x4000000000000000LL) != 0))
  {
    if (v8 < 0) {
      unint64_t v33 = (void *)v8;
    }
    else {
      unint64_t v33 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v14 = (uint64_t)objc_msgSend(v33, sel_count);
    if (v14 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
  }

  else
  {
    _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
    uint64_t v14 = *(void *)(v8 + 16);
  }

  uint64_t v15 = *(void *)(v12 + 72);
  uint64_t v16 = v14 * v15;
  if ((unsigned __int128)(v14 * (__int128)v15) >> 64 != (v14 * v15) >> 63)
  {
    __break(1u);
LABEL_16:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v16 < 0) {
    goto LABEL_16;
  }
  uint64_t v17 = (uint8x16_t *)(v8 + ((v13 + 32) & ~v13));
  int64_t v18 = validateUTF8(_:)(v17->i64, v16);
  if ((v20 & 1) != 0) {
    uint64_t v21 = repairUTF8(_:firstKnownBrokenRange:)(v17->i8, v16, v18, v19);
  }
  else {
    uint64_t v21 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v17, v16, v18 & 1);
  }
  uint64_t v22 = v21;
  uint64_t v23 = v8;
LABEL_14:
  swift_release(v23);
  return v22;
}

uint64_t closure #1 in static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  id v9 = (uint64_t *)UnsafeRawBufferPointer.init<A>(_:)(a1, a2, AssociatedTypeWitness);
  uint64_t v11 = (uint8x16_t *)v9;
  if (v9)
  {
    uint64_t v12 = v10 - (void)v9;
    if (v10 - (uint64_t)v9 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  int64_t v13 = validateUTF8(_:)(v9, v12);
  char v16 = v15 & 1;
  if ((v15 & 1) != 0) {
    uint64_t result = repairUTF8(_:firstKnownBrokenRange:)(v11->i8, v12, v13, v14);
  }
  else {
    uint64_t result = specialized static String._uncheckedFromUTF8(_:isASCII:)(v11, v12, v13 & 1);
  }
  *(void *)a5 = result;
  *(void *)(a5 + 8) = v18;
  *(_BYTE *)(a5 + 16) = v16;
  return result;
}

uint64_t UnsafeRawBufferPointer.bindMemory<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeRawBufferPointer.bindMemory<A>(to:)( a1,  a2,  a3,  a4,  "UnsafeBufferPointer with negative count",  39LL,  0x53FuLL);
}

uint64_t String.init<A, B>(decoding:as:)(uint64_t a1, uint64_t a2, swift *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *((void *)a3 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  int64_t v14 = (uint64_t *)((char *)v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  if (v10 != &type metadata for Unicode.UTF8)
  {
    unint64_t v21 = static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, (uint64_t)v10, 1, a3, v11, a5, v12);
    if (!v23) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
    }
    goto LABEL_10;
  }

  MEMORY[0x1895F8858](v9);
  (*(void (**)(uint64_t *__return_ptr, uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, uint64_t *@<X8>)))(*(void *)(a5 + 8) + 72LL))( v26,  partial apply for closure #1 in String.init<A, B>(decoding:as:));
  if (v26[1])
  {
    uint64_t v15 = v26[0];
LABEL_11:
    (*(void (**)(uint64_t, swift *))(v8 + 8))(a1, a3);
    return v15;
  }

  (*(void (**)(uint64_t *, uint64_t, swift *))(v8 + 16))(v14, a1, a3);
  char v16 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasContiguousBytes);
  if ((swift_dynamicCast((char *)v24, v14, a3, v16, 6uLL) & 1) == 0)
  {
    uint64_t v25 = 0LL;
    memset(v24, 0, sizeof(v24));
    outlined destroy of _HasContiguousBytes?( (uint64_t)v24,  &demangling cache variable for type metadata for _HasContiguousBytes?);
LABEL_9:
    unint64_t v21 = static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)(a1, (uint64_t)a3, a5);
LABEL_10:
    uint64_t v15 = v21;
    goto LABEL_11;
  }

  outlined init with take of MirrorPath(v24, (uint64_t)v26);
  uint64_t v17 = v27;
  uint64_t v18 = v28;
  __swift_project_boxed_opaque_existential_0Tm(v26, v27);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v18 + 16))(v17, v18) & 1) == 0)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(v26);
    goto LABEL_9;
  }

  uint64_t v19 = v27;
  uint64_t v20 = v28;
  __swift_project_boxed_opaque_existential_0Tm(v26, v27);
  (*(void (**)(__int128 *__return_ptr, uint64_t (*)@<X0>(uint8x16_t *@<X0>, uint64_t@<X1>, uint64_t *@<X8>), void, ValueMetadata *, uint64_t, uint64_t))(v20 + 8))( v24,  closure #2 in String.init<A, B>(decoding:as:),  0LL,  &type metadata for String,  v19,  v20);
  (*(void (**)(uint64_t, swift *))(v8 + 8))(a1, a3);
  uint64_t v15 = *(void *)&v24[0];
  __swift_destroy_boxed_opaque_existential_1Tm(v26);
  return v15;
}

uint64_t closure #1 in String.init<A, B>(decoding:as:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, uint64_t *a5@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = (uint64_t *)UnsafeRawBufferPointer.init<A>(_:)(a1, a2, AssociatedTypeWitness);
  uint64_t v11 = (uint8x16_t *)v9;
  if (v9) {
    uint64_t v12 = v10 - (void)v9;
  }
  else {
    uint64_t v12 = 0LL;
  }
  int64_t v13 = validateUTF8(_:)(v9, v12);
  if ((v15 & 1) != 0) {
    uint64_t result = repairUTF8(_:firstKnownBrokenRange:)(v11->i8, v12, v13, v14);
  }
  else {
    uint64_t result = specialized static String._uncheckedFromUTF8(_:isASCII:)(v11, v12, v13 & 1);
  }
  *a5 = result;
  a5[1] = v17;
  return result;
}

uint64_t closure #2 in String.init<A, B>(decoding:as:)@<X0>( uint8x16_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (a1) {
    uint64_t v5 = a2 - (void)a1;
  }
  else {
    uint64_t v5 = 0LL;
  }
  int64_t v6 = validateUTF8(_:)(a1->i64, v5);
  if ((v8 & 1) != 0) {
    uint64_t result = repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v5, v6, v7);
  }
  else {
    uint64_t result = specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v5, v6 & 1);
  }
  *a3 = result;
  a3[1] = v10;
  return result;
}

uint64_t String.init<A, B>(validating:as:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v88 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v93 = (int *)((char *)&v77 - v12);
  unint64_t v96 = (ValueMetadata *)v13;
  uint64_t v94 = type metadata accessor for Unicode.ParseResult(0LL, v13, v14, v15);
  MEMORY[0x1895F8858](v94);
  uint64_t v17 = (unsigned __int8 *)&v77 - v16;
  unint64_t v95 = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v83 = *(void *)(v95 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v95);
  uint64_t v86 = (char *)&v77 - v19;
  uint64_t v20 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v77 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v85 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v23 = *(void *)(v85 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v85);
  uint64x2_t v84 = (char *)&v77 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v24);
  uint64_t v27 = (char *)&v77 - v26;
  unint64_t v89 = (ValueMetadata *)a3;
  uint64_t v98 = a3;
  uint64_t v99 = a4;
  uint64_t v87 = a5;
  uint64_t v100 = a5;
  uint64_t v101 = a6;
  (*(void (**)(uint64_t *__return_ptr, unint64_t (*)@<X0>(uint8x16_t *@<X0>, uint64_t@<X1>, unint64_t *@<X8>), char *, void *, uint64_t, uint64_t))(a6 + 72))( &v102,  partial apply for closure #1 in String.init<A, B>(validating:as:),  v97,  &unk_189B88B50,  a4,  a6);
  uint64_t v28 = v103;
  if (v103 == 1)
  {
    uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 40))(a4, a6);
    Swift::String::Index v30 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v29 & ~(v29 >> 63),  0,  (uint64_t)&_swiftEmptyArrayStorage);
    uint64_t v81 = v20;
    uint64_t v31 = *(void (**)(char *, uint64_t, uint64_t))(v20 + 16);
    uint64_t v79 = a1;
    v31(v22, a1, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 32))(a4, a6);
    uint64_t v80 = v23;
    uint64_t v32 = *(void (**)(char *, char *, unint64_t))(v23 + 16);
    unint64_t v33 = v84;
    uint64x2_t v78 = v27;
    uint64_t v34 = v85;
    v32(v84, v27, v85);
    unint64_t v35 = v95;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  (uint64_t)v89,  v95,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
    unint64_t v37 = v86;
    (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v35,  AssociatedConformanceWitness);
    char v91 = *(void (**)(void))(AssociatedConformanceWitness + 32);
    unint64_t v92 = AssociatedConformanceWitness;
    uint64_t v82 = a4;
    unint64_t v90 = swift_getAssociatedConformanceWitness( a6,  a4,  v34,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    char v38 = 1;
    unint64_t v39 = v37;
    uint64_t v40 = v34;
    Swift::Bool v41 = v33;
LABEL_3:
    uint64_t v43 = v88;
    Swift::String::Index v42 = v89;
    while (1)
    {
      Swift::String::Index v44 = v41;
      uint64_t v45 = v40;
      unint64_t v46 = v39;
      unint64_t v47 = v95;
      v91();
      int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v17, v94);
      if (EnumCaseMultiPayload) {
        break;
      }
      unint64_t v49 = v93;
      unint64_t v50 = v96;
      (*(void (**)(int *, unsigned __int8 *, ValueMetadata *))(v43 + 32))(v93, v17, v96);
      if (v42 == &type metadata for Unicode.UTF16)
      {
        if (v50 != (ValueMetadata *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>)) {
          goto LABEL_38;
        }
        int v51 = *v49;
        unsigned int v52 = (unsigned __int16)*v49;
        if (v52 > 0x7F)
        {
          int v54 = (*v49 & 0x3F) << 8;
          if (v52 < 0x800)
          {
            unsigned int v55 = v52 >> 6;
            (*(void (**)(int *, ValueMetadata *))(v43 + 8))(v93, v96);
            int v56 = v54 | v55;
            goto LABEL_16;
          }

          if ((v52 & 0xF800) == 0xD800)
          {
LABEL_25:
            int v62 = v93;
            unsigned int v63 = (*((uint64_t (**)(int *, ValueMetadata *))v87 + 11))(v93, v42);
            (*(void (**)(int *, ValueMetadata *))(v43 + 8))(v62, v96);
            if (v63 >= 0x80)
            {
              int v64 = (v63 & 0x3F) << 8;
              if (v63 >= 0x800)
              {
                int v65 = (v64 | (v63 >> 6) & 0x3F) << 8;
                int v66 = (((v65 | (v63 >> 12) & 0x3F) << 8) | (v63 >> 18)) - 2122219023;
                int v67 = (v65 | (v63 >> 12)) + 8487393;
                if (HIWORD(v63)) {
                  unsigned int v53 = v66;
                }
                else {
                  unsigned int v53 = v67;
                }
              }

              else
              {
                int v56 = v64 | (v63 >> 6);
LABEL_16:
                unsigned int v53 = v56 + 33217;
              }
            }

            else
            {
              unsigned int v53 = v63 + 1;
            }
          }

          else
          {
            int v61 = (v54 | (v52 >> 6) & 0x3F) << 8;
            (*(void (**)(int *, ValueMetadata *))(v43 + 8))(v93, v96);
            unsigned int v53 = (v61 & 0xFFFFFFF0 | ((unsigned __int16)v51 >> 12)) + 8487393;
          }

          unint64_t v39 = v46;
          uint64_t v40 = v45;
          Swift::Bool v41 = v44;
LABEL_18:
          unint64_t v57 = v30[1].u64[0];
          do
          {
            unint64_t v58 = v30[1].u64[1];
            if (v57 >= v58 >> 1)
            {
              int8x16_t v60 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v58 > 1),  v57 + 1,  1,  (uint64_t)v30);
              uint64_t v40 = v45;
              unint64_t v39 = v46;
              Swift::String::Index v30 = (uint8x16_t *)v60;
              Swift::Bool v41 = v44;
            }

            v30[1].i64[0] = v57 + 1;
            v30[2].i8[v57] = v53 - 1;
            v38 &= v38 ^ 1 | ((char)(v53 - 1) >= 0);
            ++v57;
            BOOL v59 = v53 >= 0x100;
            v53 >>= 8;
          }

          while (v59);
          goto LABEL_3;
        }

        (*(void (**)(int *, ValueMetadata *))(v43 + 8))(v49, v96);
        unsigned int v53 = (v51 + 1);
      }

      else
      {
        if (v42 != &type metadata for Unicode.UTF8) {
          goto LABEL_25;
        }
        if (v96 != &type metadata for _ValidUTF8Buffer) {
LABEL_38:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
        unsigned int v53 = *v93;
        (*(void (**)(void))(v43 + 8))();
      }

      unint64_t v39 = v46;
      uint64_t v40 = v45;
      Swift::Bool v41 = v44;
      if (v53) {
        goto LABEL_18;
      }
    }

    uint64_t v69 = v80;
    if (EnumCaseMultiPayload == 1)
    {
      (*(void (**)(uint64_t, uint64_t))(v81 + 8))(v79, v82);
      (*(void (**)(char *, unint64_t))(v83 + 8))(v39, v47);
      unint64_t v70 = *(void (**)(char *, uint64_t))(v69 + 8);
      v70(v44, v45);
      v70(v78, v45);
      swift_bridgeObjectRelease((uint64_t)v30);
      return 0LL;
    }

    else
    {
      (*(void (**)(uint64_t, uint64_t))(v81 + 8))(v79, v82);
      (*(void (**)(char *, unint64_t))(v83 + 8))(v39, v47);
      uint16x8_t v71 = *(void (**)(char *, uint64_t))(v69 + 8);
      v71(v44, v45);
      v71(v78, v45);
      uint64_t v72 = v30[1].i64[0];
      swift_bridgeObjectRetain((unint64_t)v30, v73, v74, v75);
      uint64_t v68 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v30 + 2, v72, v38 & 1);
      swift_bridgeObjectRelease_n((uint64_t)v30, 2LL);
    }
  }

  else
  {
    uint64_t v68 = v102;
    (*(void (**)(uint64_t, uint64_t))(v20 + 8))(a1, a4);
    if (!v28) {
      return 0LL;
    }
  }

  return v68;
}

{
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(char *, uint64_t, uint64_t);
  char *v24;
  uint64_t v25;
  uint64_t WitnessTable;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  const char *v33;
  _BYTE v34[16];
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v11 = type metadata accessor for LazySequence(0LL, a4, a6, a4);
  MEMORY[0x1895F8858](v11);
  uint64_t v13 = (char *)&v32 - v12;
  uint64_t v14 = type metadata accessor for LazyMapSequence(0LL, a4, (uint64_t)&type metadata for UInt8, a6);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v32 - v19;
  unint64_t v35 = a3;
  uint64_t v36 = a4;
  unint64_t v33 = a5;
  unint64_t v37 = a5;
  char v38 = a6;
  (*(void (**)(uint64_t *__return_ptr, unint64_t (*)@<X0>(uint8x16_t *@<X0>, uint64_t@<X1>, unint64_t *@<X8>), _BYTE *, void *, uint64_t, uint64_t))(a6 + 72))( &v39,  partial apply for closure #1 in String.init<A, B>(validating:as:),  v34,  &unk_189B88B50,  a4,  a6);
  uint64_t v21 = v40;
  uint64_t v22 = *(void *)(a4 - 8);
  if (v40 != 1)
  {
    Swift::String::Index v30 = v39;
    (*(void (**)(uint64_t, uint64_t))(v22 + 8))(a1, a4);
    if (v21) {
      return v30;
    }
    return 0LL;
  }

  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 32);
  v23(v13, a1, a4);
  v23(v20, (uint64_t)v13, a4);
  uint64_t v24 = &v20[*(int *)(v14 + 44)];
  *(void *)uint64_t v24 = protocol witness for ExpressibleByBooleanLiteral.init(BOOLeanLiteral:) in conformance Bool;
  *((void *)v24 + 1) = 0LL;
  (*(void (**)(char *, char *, uint64_t))(v15 + 32))(v18, v20, v14);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v14, v25);
  uint64_t v28 = String.init<A, B>(validating:as:)((uint64_t)v18, v27, a3, v14, v33, WitnessTable);
  if (!v29) {
    return 0LL;
  }
  return v28;
}

unint64_t static String._validate<A>(_:as:)( uint8x16_t *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4, const char *a5)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v81 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v80 = (char *)&v73 - v11;
  uint64_t v82 = v12;
  uint64_t v15 = type metadata accessor for Unicode.ParseResult(0LL, v12, v13, v14);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (unsigned __int8 *)&v73 - v16;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v76 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v83 = a5;
  uint64x2_t v84 = (char *)&v73 - v19;
  uint64_t v22 = (ValueMetadata *)swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  if (v22 != &type metadata for UInt8) {
    goto LABEL_2;
  }
  if ((_UNKNOWN *)type metadata accessor for UnsafeBufferPointer(0LL, (uint64_t)&type metadata for UInt8, v20, v21) != &unk_189B88C10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
  }
  if (a3 == &type metadata for Unicode.UTF8)
  {
    char v62 = validateUTF8(_:)(a1->i64, a2);
    if ((v63 & 1) == 0) {
      return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v62 & 1);
    }
    return 0LL;
  }

  if (a3 == &type metadata for Unicode.ASCII)
  {
    if (_allASCII(_:)(a1->i64, a2)) {
      return specialized static String._uncheckedFromASCII(_:)(a1, a2);
    }
    return 0LL;
  }

uint64_t specialized transcode<A, B, C>(_:from:to:stoppingOnError:into:)( uint64_t isUniquelyReferenced_nonNull_native, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  char v37 = a3;
  char v38 = 0;
  int64_t v6 = (unsigned __int16 *)isUniquelyReferenced_nonNull_native;
  unsigned int v7 = 0;
  unsigned __int8 v8 = 0;
  unsigned int v40 = 0;
  unsigned __int8 v41 = 0;
  while (1)
  {
    if (!v8)
    {
      unsigned int v9 = *v6;
      uint64_t v10 = v6 + 1;
      if ((v9 & 0xF800) == 0xD800)
      {
        unsigned int v7 = v7 & 0xFFFF0000 | v9;
        unsigned __int8 v8 = 16;
        ++v6;
        goto LABEL_9;
      }

      char v15 = 1;
      ++v6;
      unsigned int v7 = v9;
LABEL_22:
      if ((unsigned __int16)v7 < 0x80u)
      {
        unsigned int v16 = (v7 + 1);
        if ((_BYTE)v7 == 0xFF) {
          goto LABEL_3;
        }
        goto LABEL_24;
      }

      int v21 = (v7 & 0x3F) << 8;
      if ((unsigned __int16)v7 < 0x800u)
      {
        int v22 = v21 | ((unsigned __int16)v7 >> 6);
LABEL_37:
        unsigned int v16 = v22 + 33217;
        goto LABEL_24;
      }

      if ((v7 & 0xF800) != 0xD800)
      {
        int v33 = ((v21 | ((unsigned __int16)v7 >> 6) & 0x3F) << 8) | ((unsigned __int16)v7 >> 12);
LABEL_54:
        unsigned int v16 = v33 + 8487393;
        goto LABEL_24;
      }

      if ((v15 & 1) != 0)
      {
        if ((unsigned __int16)v7 >= 0x80u)
        {
          int v35 = (v7 & 0x3F) << 8;
          if ((unsigned __int16)v7 < 0x800u)
          {
            int v22 = v35 | ((unsigned __int16)v7 >> 6);
            goto LABEL_37;
          }

          int v33 = ((unsigned __int16)v7 >> 12) | ((v35 | ((unsigned __int16)v7 >> 6) & 0x3F) << 8);
          goto LABEL_54;
        }

        unsigned int v16 = (unsigned __int16)v7 + 1;
      }

      else
      {
        unsigned int v34 = ((v7 & 0x3FF) << 10) | HIWORD(v7) & 0x3FF;
        unsigned int v16 = (((v34 + 0x10000) >> 4) & 0x3F00 | ((v34 + 0x10000) >> 18) | (((v34 >> 6) & 0x3F | (((v34 + 0x10000) & 0x3F) << 8)) << 16))
            - 2122219023;
      }

uint64_t transcode<A, B, C>(_:from:to:stoppingOnError:into:)( unint64_t a1, uint64_t a2, uint64_t a3, int a4, void (*a5)(char *), uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const char *a11, const char *a12)
{
  uint64_t v76 = a7;
  uint64_t v66 = a5;
  uint64_t v67 = a6;
  int v58 = a4;
  uint64_t v63 = a2;
  unint64_t v75 = a1;
  uint64_t v72 = a10;
  int v79 = a12;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a12,  a9,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v80 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v60 = (char *)&v56 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  int v61 = (char *)&v56 - v16;
  uint64_t v19 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v17, v18);
  uint64_t v62 = *(void *)(v19 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  int v22 = (char *)&v56 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v56 - v23;
  uint64_t v68 = a11;
  unint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  a11,  a8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v77 = *(void *)(v25 - 8);
  MEMORY[0x1895F8858](v25);
  uint64_t v27 = (char *)&v56 - v26;
  uint64_t v78 = v28;
  uint64_t v71 = type metadata accessor for Unicode.ParseResult(0LL, v28, v29, v30);
  MEMORY[0x1895F8858](v71);
  uint64_t v32 = (unsigned __int8 *)&v56 - v31;
  uint64_t v33 = a8;
  unint64_t v34 = swift_getAssociatedTypeWitness( 0LL,  a11,  a8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v57 = *(void *)(v34 - 8);
  uint64_t v35 = MEMORY[0x1895F8858](v34);
  char v37 = (char *)&v56 - v36;
  MEMORY[0x1895F8858](v35);
  unint64_t v39 = (char *)&v56 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v56 = v40;
  unsigned __int8 v41 = *(void (**)(void))(v40 + 16);
  uint64_t v73 = v39;
  v41();
  uint64_t v64 = v33;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v68,  v33,  v34,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  uint64_t v43 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  uint64_t v74 = v37;
  unint64_t v75 = v34;
  v43(v34, AssociatedConformanceWitness);
  int v59 = 0;
  uint64_t v69 = *(void (**)(char *, uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 32);
  unint64_t v70 = AssociatedConformanceWitness;
  uint64_t v65 = v19;
  v69(v73, v76, v72, v75, AssociatedConformanceWitness);
  while (1)
  {
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v32, v71);
    if (EnumCaseMultiPayload) {
      break;
    }
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v77 + 32))(v27, v32, v78);
    (*((void (**)(char *, uint64_t, uint64_t, const char *, uint64_t))v79 + 13))(v27, v63, v64, v68, a9);
    BOOL v48 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v80 + 48);
    if (v48(v24, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v77 + 8))(v27, v78);
      (*(void (**)(char *, uint64_t))(v62 + 8))(v24, v19);
LABEL_3:
      uint64_t v44 = (uint64_t)v79;
      unsigned int v45 = v60;
      (*((void (**)(uint64_t, const char *))v79 + 10))(a9, v79);
      unint64_t v46 = swift_getAssociatedConformanceWitness( v44,  a9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.EncodedScalar: BidirectionalCollection);
      Sequence.forEach(_:)(v66, v67, AssociatedTypeWitness, *(const char **)(*(void *)(v46 + 8) + 8LL));
      (*(void (**)(char *, unint64_t))(v80 + 8))(v45, AssociatedTypeWitness);
      uint64_t v19 = v65;
      goto LABEL_4;
    }

    uint64_t v49 = v62;
    (*(void (**)(char *, char *, uint64_t))(v62 + 16))(v22, v24, v19);
    if (v48(v22, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v77 + 8))(v27, v78);
      int v54 = *(void (**)(char *, uint64_t))(v49 + 8);
      v54(v24, v19);
      v54(v22, v19);
      goto LABEL_3;
    }

    uint64_t v50 = v80;
    int v51 = v61;
    (*(void (**)(char *, char *, unint64_t))(v80 + 32))(v61, v22, AssociatedTypeWitness);
    unint64_t v52 = swift_getAssociatedConformanceWitness( (uint64_t)v79,  a9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.EncodedScalar: BidirectionalCollection);
    Sequence.forEach(_:)(v66, v67, AssociatedTypeWitness, *(const char **)(*(void *)(v52 + 8) + 8LL));
    unsigned __int8 v53 = *(void (**)(char *, unint64_t))(v50 + 8);
    uint64_t v19 = v65;
    v53(v51, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v77 + 8))(v27, v78);
    (*(void (**)(char *, uint64_t))(v49 + 8))(v24, v19);
LABEL_4:
    v69(v73, v76, v72, v75, v70);
  }

  if (EnumCaseMultiPayload == 1)
  {
    int v59 = 1;
    if ((v58 & 1) == 0) {
      goto LABEL_3;
    }
  }

  (*(void (**)(char *, unint64_t))(v57 + 8))(v74, v75);
  (*(void (**)(char *, uint64_t))(v56 + 8))(v73, v76);
  return v59 & 1;
}

unint64_t closure #1 in String.init<A, B>(validating:as:)@<X0>( uint8x16_t *a1@<X0>, uint64_t a2@<X1>, ValueMetadata *a3@<X2>, const char *a4@<X4>, unint64_t *a5@<X8>)
{
  if (a1)
  {
    if (a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
  }

  else
  {
    a2 = 0LL;
  }

  unint64_t result = static String._validate<A>(_:as:)(a1, a2, a3, (uint64_t)a3, a4);
  *a5 = result;
  a5[1] = v7;
  return result;
}

int64_t String.init(unsafeUninitializedCapacity:initializingUTF8With:)( int64_t a1, uint64_t (*a2)(int64_t, int64_t))
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1 > 15) {
    return specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(a1, a2);
  }
  uint8x16_t v14 = (uint8x16_t)xmmword_1817FFDF0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  int64_t result = a2((int64_t)&v14, a1);
  if (!v2)
  {
    int64_t v4 = result;
    if (result <= 0)
    {
      if (result) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SmallString.swift",  23LL,  2,  0x109uLL,  0);
      }
      return 0LL;
    }

    else
    {
      char v5 = 8;
      if (result <= 8) {
        char v6 = 8;
      }
      else {
        char v6 = result;
      }
      char v7 = 56 * v6;
      if (result < 8) {
        char v5 = result;
      }
      unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> (v7 & 0x38);
      int64_t result = v14.i64[0] & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v5) & 0x38));
      uint64_t v9 = v14.i64[1] & v8;
      BOOL v10 = ((v14.i64[1] & v8 | result) & 0x8080808080808080LL) == 0;
      unint64_t v11 = 0xA000000000000000LL;
      if (v10) {
        unint64_t v11 = 0xE000000000000000LL;
      }
      unint64_t v12 = v11 | (v4 << 56);
      if (((v12 | v9) & 0x4000000000000000LL) == 0)
      {
        v14.i64[0] = result;
        v14.i64[1] = v9 & 0xFFFFFFFFFFFFFFLL;
        closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v14, ((v12 | v9) >> 56) & 0xF, &v13);
        return v13;
      }
    }
  }

  return result;
}

uint64_t closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)@<X0>( uint8x16_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = validateUTF8(_:)(a1->i64, a2);
  if ((v8 & 1) != 0) {
    uint64_t result = repairUTF8(_:firstKnownBrokenRange:)(a1, a2, v6, v7);
  }
  else {
    uint64_t result = specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v6 & 1);
  }
  *a3 = result;
  a3[1] = v10;
  return result;
}

void String._slowWithCString<A, B>(encodedAs:_:)( uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
}

void closure #1 in String._slowWithCString<A, B>(encodedAs:_:)( unsigned __int8 *a1@<X0>, char *a2@<X1>, uint64_t (*a3)()@<X2>, unint64_t a4@<X3>, void (*a5)(unint64_t)@<X4>, uint64_t a6@<X5>, char *a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, uint64_t a10)
{
  uint64_t v10 = a8;
  uint64_t v104 = a7;
  uint64_t v96 = a6;
  uint64_t v97 = a5;
  uint64_t v101 = a3;
  uint64_t v105 = a2;
  uint64_t v95 = a9;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a10,  a8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v90 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v93 = (char *)&v89 - v14;
  unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a10,  v10,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v100 = (char *)&v89 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v98 = (char *)&v89 - v19;
  uint64_t v22 = type metadata accessor for Optional(0LL, v15, v20, v21);
  uint64_t v102 = *(void *)(v22 - 8);
  uint64_t v103 = v22;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  unint64_t v25 = (char *)&v89 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  uint64_t v29 = (char *)&v89 - v28;
  unint64_t v115 = &_swiftEmptyArrayStorage;
  unint64_t v30 = HIBYTE(a4) & 0xC;
  if ((a4 & 0x2000000000000000LL) == 0) {
    unint64_t v30 = (unint64_t)v101 & 0xFFFFFFFFFFFCLL;
  }
  Swift::Int v31 = (v30 >> 2) + 1;
  uint64_t v94 = (uint64_t *)AssociatedTypeWitness;
  uint64_t v92 = type metadata accessor for Array(0LL, AssociatedTypeWitness, v26, v27);
  Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(v31, 0);
  char v91 = &v89;
  unsigned int v35 = 0;
  unsigned __int8 v36 = 0;
  if (a1) {
    char v37 = &v105[(void)a1];
  }
  else {
    char v37 = 0LL;
  }
  int v108 = v104;
  uint64_t v109 = v10;
  uint64_t v110 = a10;
  size_t v111 = &v115;
  unsigned int v113 = 0;
  unsigned __int8 v114 = 0;
  uint64_t v104 = v25;
  uint64_t v105 = v37;
  uint64_t v99 = v29;
  while (v36)
  {
    if ((v35 & 0x80) == 0)
    {
      lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser( v32,  v33,  v34);
      uint64_t v101 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      uint64_t v32 = ((uint64_t (*)(void *, void))v101)(v112, 0LL);
      int v44 = (v35 + 1);
      goto LABEL_40;
    }

    if (a1)
    {
      Swift::String::Index v42 = a1;
LABEL_16:
      if (v42 != (unsigned __int8 *)v105)
      {
        if (v36 >= 0x20u) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
        }
        a1 = v42 + 1;
        unsigned int v35 = (*v42 << v36) | ((-255 << v36) - 1) & v35;
        unsigned __int8 v45 = v36 + 8;
        if (v36 <= 0x17u && a1 != (unsigned __int8 *)v105)
        {
          a1 = v42 + 2;
          unsigned int v35 = (v42[1] << v45) | ((-65280 << v36) - 1) & v35;
          unsigned __int8 v45 = v36 + 16;
          if (v36 <= 0xFu && a1 != (unsigned __int8 *)v105)
          {
            a1 = v42 + 3;
            unsigned int v35 = (v42[2] << v45) | ((-16711680 << v36) - 1) & v35;
            unsigned __int8 v45 = v36 + 24;
            if (v36 <= 7u && a1 != (unsigned __int8 *)v105)
            {
              a1 = v42 + 4;
              unsigned int v35 = (v42[3] << v45) | ((0x1000000 << v36) - 1) & v35;
              unsigned __int8 v45 = v36 + 32;
            }
          }
        }

        unsigned __int8 v36 = v45;
      }
    }

    if ((v35 & 0xC0E0) == 0x80C0)
    {
      if ((v35 & 0x1E) == 0) {
        goto LABEL_37;
      }
      unsigned int v46 = 16;
      char v47 = 1;
    }

    else if ((v35 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v35 & 0x200F) == 0 || (v35 & 0x200F) == 0x200D) {
        goto LABEL_37;
      }
      unsigned int v46 = 24;
      char v47 = 1;
    }

    else
    {
      if ((v35 & 0xC0C0C0F8) != 0x808080F0 || (v35 & 0x3007) == 0 || __rev16(v35 & 0x3007) > 0x400)
      {
LABEL_37:
        uint64_t v32 = Unicode.UTF8.ForwardParser._invalidLength()();
        char v47 = 0;
        unsigned int v46 = 8 * v32;
        goto LABEL_38;
      }

      unsigned int v46 = 32;
      char v47 = 1;
    }

uint64_t _StringGuts.count.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    return HIBYTE(a2) & 0xF;
  }
  else {
    return a1 & 0xFFFFFFFFFFFFLL;
  }
}

uint64_t closure #1 in closure #1 in String._slowWithCString<A, B>(encodedAs:_:)( uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v7 = (char *)&v13 - v6;
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))((char *)&v13 - v6, a1, AssociatedTypeWitness);
  uint64_t v11 = type metadata accessor for Array(0LL, AssociatedTypeWitness, v9, v10);
  return Array.append(_:)((uint64_t)v7, v11);
}

Swift::Bool __swiftcall _GraphemeBreakingState.shouldBreak(between:and:)( Swift::Unicode::Scalar between, Swift::Unicode::Scalar and)
{
  if (between._value == 13 && and._value == 10)
  {
    char v5 = 0;
    return v5 & 1;
  }

  if (hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(between._value)
    && hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(and._value))
  {
LABEL_45:
    char v5 = 1;
    return v5 & 1;
  }

  char v6 = Unicode._GraphemeBreakProperty.init(from:)(between._value);
  char v5 = v6;
  if (v6 != 1)
  {
    unsigned __int8 v7 = v6;
    char v8 = Unicode._GraphemeBreakProperty.init(from:)(and._value);
    char v9 = v8;
    switch(v8)
    {
      case 0:
        if (v7 == 7) {
          goto LABEL_28;
        }
        if (v7) {
          goto LABEL_40;
        }
        goto LABEL_44;
      case 1:
        goto LABEL_44;
      case 2:
      case 12:
        if (v7 == 3 || v7 == 2 && v2[1])
        {
          if ((v2[2] & 1) != 0)
          {
            if (v8 != 2)
            {
              HIDWORD(v13) = and._value - 2381;
              LODWORD(v13) = and._value - 2381;
              unsigned int v12 = v13 >> 7;
              if (v12 >= 9)
              {
                char v14 = 1;
                char v10 = 1;
                goto LABEL_62;
              }

              char v10 = 1;
              char v14 = 1;
              if (((0x15Bu >> v12) & 1) == 0) {
                goto LABEL_62;
              }
              goto LABEL_61;
            }

            char v10 = 1;
            goto LABEL_50;
          }

          char v10 = 1;
        }

        else
        {
          if ((v2[2] & 1) != 0)
          {
            if (v8 != 2)
            {
              HIDWORD(v17) = and._value - 2381;
              LODWORD(v17) = and._value - 2381;
              unsigned int v16 = v17 >> 7;
              if (v16 >= 9)
              {
                char v10 = 0;
                char v14 = 1;
                goto LABEL_62;
              }

              char v10 = 0;
              if (((0x15Bu >> v16) & 1) == 0)
              {
                char v14 = 1;
                goto LABEL_62;
              }

              goto LABEL_61;
            }

            char v10 = 0;
            goto LABEL_50;
          }

          char v10 = 0;
        }

        if (!_swift_stdlib_isLinkingConsonant(between._value))
        {
          char v14 = 0;
          goto LABEL_62;
        }

        if (v9 != 2)
        {
LABEL_59:
          HIDWORD(v19) = and._value - 2381;
          LODWORD(v19) = and._value - 2381;
          unsigned int v18 = v19 >> 7;
          char v14 = 1;
          if (v18 > 8 || ((1 << v18) & 0x15B) == 0)
          {
LABEL_62:
            char v5 = 0;
            v2[1] = v10;
            v2[2] = v14;
            return v5 & 1;
          }

Swift::Unicode::Scalar_optional __swiftcall String.UnicodeScalarView.Iterator.next()()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = v0[3];
  if (v1 >= v2)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v3 = *v0;
    uint64_t v4 = v0[1];
    if ((v4 & 0x1000000000000000LL) != 0)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v10 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v1 << 16));
      Swift::Int scalarLength = v10.scalarLength;
      unsigned int value = v10._0._value;
    }

    else
    {
      if ((v4 & 0x2000000000000000LL) != 0)
      {
        v11[0] = *v0;
        v11[1] = v4 & 0xFFFFFFFFFFFFFFLL;
        char v5 = v11;
      }

      else if ((v3 & 0x1000000000000000LL) != 0)
      {
        char v5 = (void *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        char v5 = _StringObject.sharedUTF8.getter(*v0, v0[1]);
      }

      unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v5, v3, v1);
    }

    v0[2] += scalarLength;
    uint64_t v8 = value;
  }

  LOBYTE(v11[0]) = v1 >= v2;
  return (Swift::Unicode::Scalar_optional)(v8 | ((unint64_t)(v1 >= v2) << 32));
}

void (*String.unicodeScalars.modify(void *a1))(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
  a1[2] = v1;
  void *v1 = 0LL;
  v1[1] = 0xE000000000000000LL;
  return String.unicodeScalars.modify;
}

void String.unicodeScalars.modify(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4 = a1[1];
  char v5 = (void *)a1[2];
  uint64_t v6 = *a1;
  uint64_t v7 = v5[1];
  swift_bridgeObjectRetain(v4, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  *char v5 = v6;
  v5[1] = v4;
  swift_bridgeObjectRelease(v4);
}

Swift::Void __swiftcall String.UnicodeScalarView.append(_:)(Swift::Unicode::Scalar a1)
{
  unint64_t v1 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a1._value);
  uint64_t v3 = v2;
  _StringGuts.append(_:)(v1, v2);
  swift_bridgeObjectRelease(v3);
}

Swift::String::Index __swiftcall String.index(before:)(Swift::String::Index before)
{
  v1._unint64_t rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(before)._rawBits;
  if (!(v1._rawBits >> 14) && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
  }
  return String._uncheckedIndex(before:)(v1);
}

Swift::String::Index __swiftcall String.UnicodeScalarView.index(before:)(Swift::String::Index before)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(before)._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  Swift::UInt64 rawBits = v5._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0) {
    return String.UnicodeScalarView._foreignIndex(before:)(v5);
  }
  if ((v3 & 0x2000000000000000LL) != 0)
  {
    v16[0] = v4;
    v16[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    int v11 = (char *)v16 + (v5._rawBits >> 16);
    if ((*(v11 - 1) & 0xC0) == 0x80)
    {
      uint64_t v12 = 0LL;
      unint64_t v13 = v11 - 2;
      do
        int v14 = v13[v12--] & 0xC0;
      while (v14 == 128);
      uint64_t v10 = 1 - v12;
    }

    else
    {
      uint64_t v10 = 1LL;
    }
  }

  else
  {
    if ((v4 & 0x1000000000000000LL) != 0) {
      uint64_t v7 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v7 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
    }
    uint64_t v8 = 0LL;
    do
      int v9 = v7[(rawBits >> 16) - 1 + v8--] & 0xC0;
    while (v9 == 128);
    uint64_t v10 = -v8;
  }

  return (Swift::String::Index)((rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000LL | 5);
}

void specialized String.UnicodeScalarView.append<A>(contentsOf:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::String::Index v5 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( a1,  a2,  a3,  a4);
  uint64_t v6 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v5, 1LL);
  unint64_t v8 = v7;
  swift_bridgeObjectRelease((uint64_t)v5);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  }
  unint64_t v9 = v4[1];
  unint64_t v10 = specialized static String.+ infix(_:_:)(*v4, v9, v6, v8);
  unint64_t v12 = v11;
  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRelease(v8);
  *uint64_t v4 = v10;
  v4[1] = v12;
}

void String.UnicodeScalarView.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  Swift::String::Index v5 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5( (void (*)(uint64_t *__return_ptr, char *))protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar,  0LL,  a2,  a3);
  uint64_t v6 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v5, 1LL);
  unint64_t v8 = v7;
  swift_bridgeObjectRelease((uint64_t)v5);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  }
  unint64_t v9 = v4[1];
  unint64_t v10 = specialized static String.+ infix(_:_:)(*v4, v9, v6, v8);
  unint64_t v12 = v11;
  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRelease(v8);
  *uint64_t v4 = v10;
  v4[1] = v12;
}

unint64_t specialized Sequence<>.joined(separator:)(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = a2;
  unint64_t v270 = HIBYTE(a2) & 0xF;
  uint64_t v273 = a1 & 0xFFFFFFFFFFFFLL;
  uint64_t v274 = a1;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v4 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v5 = a3[2] + a3[2] * v4;
  unint64_t v6 = 0xE000000000000000LL;
  unint64_t v281 = 0LL;
  unint64_t v282 = 0xE000000000000000LL;
  if (v5 < 16)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    uint64_t v7 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v8 & 1) != 0 || v7 < v5)
    {
      uint64_t v11 = 2 * _StringGuts.uniqueNativeCapacity.getter();
      if (v11 <= v5) {
        uint64_t v11 = v5;
      }
      if ((v10 & 1) != 0) {
        int64_t v12 = v5;
      }
      else {
        int64_t v12 = v11;
      }
      uint64_t v279 = 0LL;
      uint64_t v280 = 0LL;
      unint64_t v6 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v279,  0LL,  v12,  1);
      uint64_t v9 = *(void *)(v6 + 24);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v281 = v9;
      unint64_t v282 = v6;
    }

    else
    {
      uint64_t v9 = 0LL;
      unint64_t v6 = 0xE000000000000000LL;
    }
  }

  unint64_t v13 = a3[2];
  unint64_t v277 = v13;
  uint64_t v14 = v274;
  if (v4)
  {
    if (!v13) {
      return v281;
    }
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(0LL, 1, (uint64_t)a3);
    uint64_t v18 = a3[4];
    uint64_t v271 = v3;
    v272 = a3 + 4;
    unint64_t v19 = a3[5];
    uint64_t v20 = HIBYTE(v6) & 0xF;
    uint64_t v21 = v9 & 0xFFFFFFFFFFFFLL;
    if ((v6 & 0x2000000000000000LL) != 0) {
      uint64_t v22 = HIBYTE(v6) & 0xF;
    }
    else {
      uint64_t v22 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (!v22 && (v9 & ~v6 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain(a3[5], v15, v16, v17);
      swift_bridgeObjectRelease(v6);
      unint64_t v281 = v18;
      unint64_t v282 = v19;
      unint64_t v24 = v277;
      if (v277 != 1) {
        goto LABEL_167;
      }
      return v281;
    }

    uint64_t v14 = v19 & 0x2000000000000000LL;
    uint64_t v3 = HIBYTE(v19) & 0xF;
    if ((v6 & 0x2000000000000000LL) == 0 || !v14)
    {
LABEL_26:
      uint64_t v269 = v18 & 0xFFFFFFFFFFFFLL;
      if (v14) {
        unint64_t v24 = HIBYTE(v19) & 0xF;
      }
      else {
        unint64_t v24 = v18 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v19, 3LL, v16, v17);
      if ((v19 & 0x1000000000000000LL) != 0) {
        goto LABEL_290;
      }
      swift_bridgeObjectRetain_n(v19, 4LL, v25, v26);
      Swift::Int v27 = v24;
      if ((v6 & 0x1000000000000000LL) != 0) {
        goto LABEL_293;
      }
      goto LABEL_31;
    }

    uint64_t v23 = v20 + v3;
    if ((unint64_t)(v20 + v3) > 0xF)
    {
      uint64_t v14 = 1LL;
      goto LABEL_26;
    }

    if (v3)
    {
      uint64_t v125 = 0LL;
      unint64_t v126 = 0LL;
      uint64_t v127 = 8 * v3;
      unint64_t v128 = v6;
      unint64_t v24 = v277;
      uint64_t v3 = v271;
      do
      {
        unint64_t v129 = v20 + v126;
        BOOL v77 = v126++ >= 8;
        if (v77) {
          unint64_t v130 = a3[5];
        }
        else {
          unint64_t v130 = a3[4];
        }
        char v131 = (8 * v20 + v125) & 0x38;
        uint64_t v132 = (-255LL << v131) - 1;
        unint64_t v133 = (unint64_t)(v130 >> (v125 & 0x38)) << v131;
        unint64_t v134 = v133 | v132 & v128;
        unint64_t v135 = v133 | v132 & v9;
        if (v129 < 8) {
          uint64_t v9 = v135;
        }
        else {
          unint64_t v128 = v134;
        }
        v125 += 8LL;
      }

      while (v127 != v125);
    }

    else
    {
      unint64_t v128 = v6;
      unint64_t v24 = v277;
      uint64_t v3 = v271;
    }

    swift_bridgeObjectRelease(v6);
    unint64_t v141 = 0xA000000000000000LL;
    if (!(v9 & 0x8080808080808080LL | v128 & 0x80808080808080LL)) {
      unint64_t v141 = 0xE000000000000000LL;
    }
    unint64_t v281 = v9;
    unint64_t v282 = v141 & 0xFF00000000000000LL | (v23 << 56) | v128 & 0xFFFFFFFFFFFFFFLL;
LABEL_165:
    uint64_t v14 = v274;
    if (v24 != 1) {
      goto LABEL_167;
    }
    return v281;
  }

  if (!v13) {
    return v281;
  }
  uint64_t v14 = 0LL;
  while (1)
  {
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v14, 1, (uint64_t)a3);
    unint64_t v39 = &a3[2 * v14 + 4];
    uint64_t v22 = *v39;
    unint64_t v24 = v39[1];
    unint64_t v19 = v281;
    unint64_t v6 = v282;
    unint64_t v40 = HIBYTE(v282) & 0xF;
    if ((v282 & 0x2000000000000000LL) != 0) {
      unint64_t v41 = HIBYTE(v282) & 0xF;
    }
    else {
      unint64_t v41 = v281 & 0xFFFFFFFFFFFFLL;
    }
    if (!v41 && (v281 & ~v282 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain(v24, v36, v37, v38);
      swift_bridgeObjectRelease(v6);
      unint64_t v281 = v22;
      unint64_t v282 = v24;
      goto LABEL_52;
    }

    uint64_t v18 = v24 & 0x2000000000000000LL;
    uint64_t v9 = HIBYTE(v24) & 0xF;
    if ((v282 & 0x2000000000000000LL) != 0 && v18)
    {
      unint64_t v42 = v40 + v9;
      if (v40 + v9 <= 0xF)
      {
        if (v9)
        {
          uint64_t v72 = 0LL;
          unint64_t v73 = 0LL;
          uint64_t v74 = 8 * v9;
          unint64_t v75 = v282;
          do
          {
            unint64_t v76 = v40 + v73;
            BOOL v77 = v73++ >= 8;
            if (v77) {
              unint64_t v78 = v24;
            }
            else {
              unint64_t v78 = v22;
            }
            char v79 = (8 * v40 + v72) & 0x38;
            uint64_t v80 = (-255LL << v79) - 1;
            unint64_t v81 = (unint64_t)(v78 >> (v72 & 0x38)) << v79;
            unint64_t v82 = v81 | v80 & v75;
            unint64_t v83 = v81 | v80 & v19;
            if (v76 < 8) {
              unint64_t v19 = v83;
            }
            else {
              unint64_t v75 = v82;
            }
            v72 += 8LL;
          }

          while (v74 != v72);
        }

        else
        {
          unint64_t v75 = v282;
        }

        swift_bridgeObjectRelease(v282);
        unint64_t v89 = 0xA000000000000000LL;
        if (!(v19 & 0x8080808080808080LL | v75 & 0x80808080808080LL)) {
          unint64_t v89 = 0xE000000000000000LL;
        }
        unint64_t v281 = v19;
        unint64_t v282 = v89 & 0xFF00000000000000LL | (v42 << 56) | v75 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_52;
      }

      uint64_t v18 = 1LL;
    }

    uint64_t v274 = v22 & 0xFFFFFFFFFFFFLL;
    uint64_t v21 = v18 ? HIBYTE(v24) & 0xF : v22 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v24, 3LL, v37, v38);
    if ((v24 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v24, 4LL, v43, v44);
    Swift::Int v45 = v21;
    if ((v6 & 0x1000000000000000LL) != 0) {
      goto LABEL_104;
    }
LABEL_67:
    BOOL v28 = __OFADD__(v41, v45);
    uint64_t v3 = v41 + v45;
    if (v28) {
      goto LABEL_287;
    }
LABEL_68:
    if ((v19 & ~v6 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v46 = _StringGuts.nativeUnusedCapacity.getter(v19, v6);
      if ((v47 & 1) != 0) {
        goto LABEL_309;
      }
      uint64_t v48 = (v6 >> 61) & 1;
      if (v46 < v45) {
        LOBYTE(v48) = 1;
      }
      if (v3 <= 15 && (v48 & 1) != 0)
      {
LABEL_75:
        swift_bridgeObjectRelease_n(v24, 5LL);
        swift_bridgeObjectRetain(v6, v49, v50, v51);
        unint64_t v52 = _StringGuts._convertedToSmall()(v19, v6);
        unint64_t v54 = v53;
        swift_bridgeObjectRelease(v6);
        v55._Swift::UInt64 rawBits = (v21 << 16) | 1;
        v56._Swift::UInt64 rawBits = 1LL;
        v57._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v56, v55, v22, v24);
        if (v57._rawBits < 0x10000) {
          v57._rawBits |= 3;
        }
        unint64_t v59 = specialized String.init(_:)(v57, v58, v22, v24);
        unint64_t v61 = v60;
        swift_bridgeObjectRelease(v24);
        unint64_t v62 = _StringGuts._convertedToSmall()(v59, v61);
        unint64_t v64 = v63;
        swift_bridgeObjectRelease(v61);
        unint64_t v65 = specialized _SmallString.init(_:appending:)(v52, v54, v62, v64);
        if ((v67 & 1) != 0) {
          goto LABEL_308;
        }
        unint64_t v68 = v65;
        unint64_t v69 = v66;
        swift_bridgeObjectRelease(v6);
        swift_bridgeObjectRelease(v24);
        unint64_t v281 = v68;
        unint64_t v282 = v69;
        goto LABEL_51;
      }
    }

    else if (v3 <= 15)
    {
      goto LABEL_75;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v3, v45);
    swift_bridgeObjectRelease_n(v24, 4LL);
    if ((v24 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v24);
      _StringGuts._foreignAppendInPlace(_:)(v22, v24, 0LL, v21);
      swift_bridgeObjectRelease_n(v24, 2LL);
LABEL_51:
      unint64_t v13 = v277;
      goto LABEL_52;
    }

    if (v18)
    {
      swift_bridgeObjectRelease_n(v24, 2LL);
      uint64_t v279 = v22;
      uint64_t v280 = v24 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v70 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v24) & 0xF,  (uint64_t)&v279,  HIBYTE(v24) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v70, v71, (v24 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v24);
      goto LABEL_51;
    }

    if ((v22 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v24);
      id v84 = (id)((v24 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v85 = v22 & 0xFFFFFFFFFFFFLL;
      uint64_t v86 = v22 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      id v84 = _StringObject.sharedUTF8.getter(v22, v24);
      uint64_t v86 = v95;
      swift_bridgeObjectRelease(v24);
      uint64_t v85 = v22 & 0xFFFFFFFFFFFFLL;
      if (v86 < v274) {
        goto LABEL_285;
      }
    }

    unint64_t v13 = v277;
    uint64_t v87 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v85, (uint64_t)v84, v86);
    _StringGuts.appendInPlace(_:isASCII:)(v87, v88, v22 < 0);
    swift_bridgeObjectRelease_n(v24, 2LL);
LABEL_52:
    if (++v14 == v13) {
      return v281;
    }
  }

  swift_bridgeObjectRetain_n(v24, 5LL, v43, v44);
  v90._Swift::UInt64 rawBits = 1LL;
  v91._Swift::UInt64 rawBits = (v21 << 16) | 1;
  v92._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v90, v91, v22, v24);
  if (v92._rawBits < 0x10000) {
    v92._rawBits |= 3;
  }
  Swift::Int v45 = specialized Collection.count.getter(v92, v93, v22, v24);
  swift_bridgeObjectRelease(v24);
  if ((v6 & 0x1000000000000000LL) == 0) {
    goto LABEL_67;
  }
LABEL_104:
  Swift::Int v94 = String.UTF8View._foreignCount()();
  uint64_t v3 = v94 + v45;
  if (!__OFADD__(v94, v45)) {
    goto LABEL_68;
  }
LABEL_287:
  while (2)
  {
    __break(1u);
LABEL_288:
    __break(1u);
LABEL_289:
    __break(1u);
LABEL_290:
    swift_bridgeObjectRetain_n(v19, 5LL, v25, v26);
    v254._Swift::UInt64 rawBits = 1LL;
    v255._Swift::UInt64 rawBits = (v24 << 16) | 1;
    v256._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v254, v255, v18, v19);
    if (v256._rawBits < 0x10000) {
      v256._rawBits |= 3;
    }
    Swift::Int v27 = specialized Collection.count.getter(v256, v257, v18, v19);
    swift_bridgeObjectRelease(v19);
    if ((v6 & 0x1000000000000000LL) != 0)
    {
LABEL_293:
      Swift::Int v258 = String.UTF8View._foreignCount()();
      uint64_t v22 = v258 + v27;
      if (!__OFADD__(v258, v27)) {
        goto LABEL_32;
      }
LABEL_295:
      __break(1u);
LABEL_296:
      if ((v22 & 0x1000000000000000LL) != 0)
      {
        uint64_t v18 = _StringGuts._foreignConvertedToSmall()(v18, v22);
        uint64_t v265 = v264;
        swift_bridgeObjectRelease(v22);
        uint64_t v22 = v265;
      }

      else
      {
        if ((v18 & 0x1000000000000000LL) != 0)
        {
          v259 = (unsigned __int8 *)((v22 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v260 = v18 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v259 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v18, v22);
        }

        closure #1 in _StringGuts._convertedToSmall()(v259, v260, &v279);
        swift_bridgeObjectRelease(v22);
        uint64_t v18 = v279;
        uint64_t v22 = v280;
      }

      unint64_t v24 = v277;
      uint64_t v14 = v274;
LABEL_116:
      uint64_t v105 = HIBYTE(v3) & 0xF;
      uint64_t v106 = HIBYTE(v22) & 0xF;
      uint64_t v107 = v106 + v105;
      if ((unint64_t)(v106 + v105) <= 0xF)
      {
        if (v106)
        {
          uint64_t v108 = 0LL;
          unint64_t v109 = 0LL;
          uint64_t v110 = 8 * v106;
          do
          {
            unint64_t v111 = v105 + v109;
            BOOL v77 = v109++ >= 8;
            if (v77) {
              unint64_t v112 = v22;
            }
            else {
              unint64_t v112 = v18;
            }
            char v113 = (8 * v105 + v108) & 0x38;
            uint64_t v114 = (-255LL << v113) - 1;
            unint64_t v115 = (unint64_t)(v112 >> (v108 & 0x38)) << v113;
            unint64_t v116 = v115 | v114 & v3;
            unint64_t v117 = v115 | v114 & v9;
            if (v111 < 8) {
              uint64_t v9 = v117;
            }
            else {
              uint64_t v3 = v116;
            }
            v108 += 8LL;
          }

          while (v110 != v108);
        }

        swift_bridgeObjectRelease(v6);
        swift_bridgeObjectRelease(v19);
        unint64_t v118 = 0xA000000000000000LL;
        if (!(v9 & 0x8080808080808080LL | v3 & 0x80808080808080LL)) {
          unint64_t v118 = 0xE000000000000000LL;
        }
        unint64_t v281 = v9;
        unint64_t v282 = v118 & 0xFF00000000000000LL | (v107 << 56) | v3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v3 = v271;
        if (v24 == 1) {
          return v281;
        }
LABEL_167:
        uint64_t v267 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v268 = v3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v269 = 8 * v270;
        unint64_t v143 = 1LL;
LABEL_170:
        specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v143, 1, (uint64_t)a3);
        if (__OFADD__(v143, 1LL))
        {
          __break(1u);
          continue;
        }

        unint64_t v276 = v143 + 1;
        uint64_t v145 = &v272[2 * v143];
        uint64_t v9 = *v145;
        unint64_t v19 = v145[1];
        uint64_t v18 = v281;
        unint64_t v6 = v282;
        unint64_t v146 = HIBYTE(v282) & 0xF;
        if ((v282 & 0x2000000000000000LL) != 0) {
          unint64_t v147 = HIBYTE(v282) & 0xF;
        }
        else {
          unint64_t v147 = v281 & 0xFFFFFFFFFFFFLL;
        }
        if (!v147 && (v281 & ~v282 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRetain(v19, v144, v25, v26);
          swift_bridgeObjectRetain(v3, v181, v182, v183);
          swift_bridgeObjectRelease(v6);
          unint64_t v281 = v14;
          unint64_t v282 = v3;
          goto LABEL_220;
        }

        if ((v282 & 0x2000000000000000LL) == 0)
        {
          uint64_t v21 = v273;
          if ((v3 & 0x2000000000000000LL) != 0) {
            uint64_t v21 = v270;
          }
LABEL_181:
          if ((v3 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRetain(v19, v144, v25, v26);
            v242._Swift::UInt64 rawBits = 1LL;
            v243._Swift::UInt64 rawBits = (v21 << 16) | 1;
            v244._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v242, v243, v14, v3);
            if (v244._rawBits < 0x10000) {
              v244._rawBits |= 3;
            }
            unint64_t v24 = specialized Collection.count.getter(v244, v245, v14, v3);
            if ((v6 & 0x1000000000000000LL) == 0) {
              goto LABEL_183;
            }
          }

          else
          {
            swift_bridgeObjectRetain(v19, v144, v25, v26);
            unint64_t v24 = v21;
            if ((v6 & 0x1000000000000000LL) == 0)
            {
LABEL_183:
              BOOL v28 = __OFADD__(v147, v24);
              int64_t v150 = v147 + v24;
              if (v28) {
                goto LABEL_288;
              }
              goto LABEL_184;
            }
          }

          Swift::Int v246 = String.UTF8View._foreignCount()();
          int64_t v150 = v246 + v24;
          if (__OFADD__(v246, v24)) {
            goto LABEL_288;
          }
LABEL_184:
          if ((v18 & ~v6 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v151 = _StringGuts.nativeUnusedCapacity.getter(v18, v6);
            if ((v149 & 1) != 0) {
              goto LABEL_309;
            }
            uint64_t v152 = (v6 >> 61) & 1;
            if (v150 <= 15 && (v152 & 1) != 0)
            {
LABEL_191:
              swift_bridgeObjectRetain(v6, v149, v25, v26);
              unint64_t v153 = _StringGuts._convertedToSmall()(v18, v6);
              unint64_t v155 = v154;
              swift_bridgeObjectRelease(v6);
              v156._Swift::UInt64 rawBits = (v21 << 16) | 1;
              v157._Swift::UInt64 rawBits = 1LL;
              Swift::UInt64 v158 = _StringGuts.validateScalarRange(_:)(v157, v156, v14, v3);
              Swift::UInt64 v162 = v159;
              if (v158 >= 0x10000) {
                Swift::UInt64 v163 = v158;
              }
              else {
                Swift::UInt64 v163 = v158 | 3;
              }
              swift_bridgeObjectRetain(v3, v159, v160, v161);
              v164._Swift::UInt64 rawBits = v163;
              v165._Swift::UInt64 rawBits = v162;
              unint64_t v166 = specialized String.init(_:)(v164, v165, v14, v3);
              unint64_t v168 = v167;
              swift_bridgeObjectRelease(v3);
              unint64_t v169 = _StringGuts._convertedToSmall()(v166, v168);
              uint64_t v21 = v170;
              swift_bridgeObjectRelease(v168);
              unint64_t v171 = specialized _SmallString.init(_:appending:)(v153, v155, v169, v21);
              if ((v173 & 1) != 0) {
                goto LABEL_308;
              }
              unint64_t v174 = v171;
              unint64_t v24 = v172;
              swift_bridgeObjectRelease(v6);
              unint64_t v281 = v174;
              unint64_t v282 = v24;
              goto LABEL_220;
            }
          }

          else if (v150 <= 15)
          {
            goto LABEL_191;
          }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v150, v24);
          if ((v3 & 0x1000000000000000LL) != 0)
          {
            _StringGuts._foreignAppendInPlace(_:)(v14, v3, 0LL, v21);
          }

          else if ((v3 & 0x2000000000000000LL) != 0)
          {
            uint64_t v279 = v14;
            uint64_t v280 = v268;
            if (v270 < v21) {
              goto LABEL_285;
            }
            unint64_t v194 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v21, (uint64_t)&v279, v270);
            _StringGuts.appendInPlace(_:isASCII:)(v194, v195, (v3 & 0x4000000000000000LL) != 0);
          }

          else
          {
            uint64_t v177 = v267;
            uint64_t v178 = v273;
            if ((v14 & 0x1000000000000000LL) != 0)
            {
              if (v273 < v21) {
                goto LABEL_285;
              }
            }

            else
            {
              uint64_t v177 = (uint64_t)_StringObject.sharedUTF8.getter(v14, v3);
              uint64_t v178 = v252;
              if (v252 < v21) {
                goto LABEL_285;
              }
            }

            unint64_t v179 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v21, v177, v178);
            _StringGuts.appendInPlace(_:isASCII:)(v179, v180, v14 < 0);
          }

          goto LABEL_220;
        }

        uint64_t v21 = v273;
        if ((v3 & 0x2000000000000000LL) == 0) {
          goto LABEL_181;
        }
        uint64_t v21 = v270;
        unint64_t v148 = v146 + v270;
        if (v146 + v270 > 0xF) {
          goto LABEL_181;
        }
        if (v270)
        {
          uint64_t v184 = 0LL;
          unint64_t v185 = 0LL;
          unint64_t v186 = v282;
          do
          {
            unint64_t v187 = v146 + v185;
            BOOL v77 = v185++ >= 8;
            if (v77) {
              unint64_t v188 = v3;
            }
            else {
              unint64_t v188 = v14;
            }
            char v189 = (8 * v146 + v184) & 0x38;
            uint64_t v190 = (-255LL << v189) - 1;
            unint64_t v191 = (unint64_t)(v188 >> (v184 & 0x38)) << v189;
            unint64_t v192 = v191 | v190 & v186;
            unint64_t v193 = v191 | v190 & v18;
            if (v187 < 8) {
              uint64_t v18 = v193;
            }
            else {
              unint64_t v186 = v192;
            }
            v184 += 8LL;
          }

          while (v269 != v184);
        }

        else
        {
          unint64_t v186 = v282;
        }

        unint64_t v196 = 0xA000000000000000LL;
        if (!(v18 & 0x8080808080808080LL | v186 & 0x80808080808080LL)) {
          unint64_t v196 = 0xE000000000000000LL;
        }
        unint64_t v197 = v196 | (v148 << 56);
        swift_bridgeObjectRetain(v19, v144, v25, v26);
        swift_bridgeObjectRelease(v6);
        unint64_t v281 = v18;
        unint64_t v282 = v197 & 0xFF00000000000000LL | v186 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v14 = v274;
LABEL_220:
        uint64_t v18 = v281;
        unint64_t v6 = v282;
        unint64_t v198 = HIBYTE(v282) & 0xF;
        if ((v282 & 0x2000000000000000LL) != 0) {
          unint64_t v199 = HIBYTE(v282) & 0xF;
        }
        else {
          unint64_t v199 = v281 & 0xFFFFFFFFFFFFLL;
        }
        if (!v199 && (v281 & ~v282 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v282);
          unint64_t v281 = v9;
          unint64_t v282 = v19;
          uint64_t v22 = v277;
          goto LABEL_169;
        }

        uint64_t v14 = v19 & 0x2000000000000000LL;
        uint64_t v21 = HIBYTE(v19) & 0xF;
        if ((v282 & 0x2000000000000000LL) == 0 || !v14) {
          goto LABEL_229;
        }
        unint64_t v200 = v198 + v21;
        if (v198 + v21 <= 0xF)
        {
          if (v21)
          {
            uint64_t v227 = 0LL;
            unint64_t v228 = 0LL;
            unint64_t v229 = v282;
            uint64_t v22 = v277;
            do
            {
              unint64_t v230 = v198 + v228;
              BOOL v77 = v228++ >= 8;
              if (v77) {
                unint64_t v231 = v19;
              }
              else {
                unint64_t v231 = v9;
              }
              char v232 = (8 * v198 + v227) & 0x38;
              uint64_t v233 = (-255LL << v232) - 1;
              unint64_t v234 = (unint64_t)(v231 >> (v227 & 0x38)) << v232;
              unint64_t v235 = v234 | v233 & v229;
              unint64_t v236 = v234 | v233 & v18;
              if (v230 < 8) {
                uint64_t v18 = v236;
              }
              else {
                unint64_t v229 = v235;
              }
              v227 += 8LL;
            }

            while (8 * v21 != v227);
          }

          else
          {
            unint64_t v229 = v282;
            uint64_t v22 = v277;
          }

          swift_bridgeObjectRelease(v282);
          swift_bridgeObjectRelease(v19);
          unint64_t v241 = 0xA000000000000000LL;
          if (!(v18 & 0x8080808080808080LL | v229 & 0x80808080808080LL)) {
            unint64_t v241 = 0xE000000000000000LL;
          }
          unint64_t v281 = v18;
          unint64_t v282 = v241 & 0xFF00000000000000LL | (v200 << 56) | v229 & 0xFFFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v14 = 1LL;
LABEL_229:
          uint64_t v3 = v9 & 0xFFFFFFFFFFFFLL;
          if (v14) {
            unint64_t v24 = HIBYTE(v19) & 0xF;
          }
          else {
            unint64_t v24 = v9 & 0xFFFFFFFFFFFFLL;
          }
          swift_bridgeObjectRetain_n(v19, 2LL, v175, v176);
          if ((v19 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRetain_n(v19, 5LL, v201, v202);
            v247._Swift::UInt64 rawBits = 1LL;
            v248._Swift::UInt64 rawBits = (v24 << 16) | 1;
            v249._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v247, v248, v9, v19);
            if (v249._rawBits < 0x10000) {
              v249._rawBits |= 3;
            }
            uint64_t v22 = specialized Collection.count.getter(v249, v250, v9, v19);
            swift_bridgeObjectRelease(v19);
            if ((v6 & 0x1000000000000000LL) == 0) {
              goto LABEL_234;
            }
          }

          else
          {
            swift_bridgeObjectRetain_n(v19, 4LL, v201, v202);
            uint64_t v22 = v24;
            if ((v6 & 0x1000000000000000LL) == 0)
            {
LABEL_234:
              BOOL v28 = __OFADD__(v199, v22);
              int64_t v203 = v199 + v22;
              if (v28) {
                goto LABEL_289;
              }
              goto LABEL_235;
            }
          }

          Swift::Int v251 = String.UTF8View._foreignCount()();
          int64_t v203 = v251 + v22;
          if (__OFADD__(v251, v22)) {
            goto LABEL_289;
          }
LABEL_235:
          if ((v18 & ~v6 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v204 = _StringGuts.nativeUnusedCapacity.getter(v18, v6);
            if ((v205 & 1) != 0) {
              goto LABEL_309;
            }
            uint64_t v206 = (v6 >> 61) & 1;
            if (v204 < v22) {
              LOBYTE(v206) = 1;
            }
            if (v203 <= 15 && (v206 & 1) != 0)
            {
LABEL_242:
              swift_bridgeObjectRelease_n(v19, 5LL);
              swift_bridgeObjectRetain(v6, v207, v208, v209);
              unint64_t v210 = _StringGuts._convertedToSmall()(v18, v6);
              unint64_t v212 = v211;
              swift_bridgeObjectRelease(v6);
              v213._Swift::UInt64 rawBits = (v24 << 16) | 1;
              v214._Swift::UInt64 rawBits = 1LL;
              v215._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v214, v213, v9, v19);
              if (v215._rawBits < 0x10000) {
                v215._rawBits |= 3;
              }
              unint64_t v217 = specialized String.init(_:)(v215, v216, v9, v19);
              uint64_t v9 = v218;
              swift_bridgeObjectRelease(v19);
              unint64_t v219 = _StringGuts._convertedToSmall()(v217, v9);
              uint64_t v18 = v220;
              swift_bridgeObjectRelease(v9);
              unint64_t v221 = specialized _SmallString.init(_:appending:)(v210, v212, v219, v18);
              uint64_t v22 = v277;
              uint64_t v3 = v271;
              uint64_t v14 = v274;
              if ((v223 & 1) != 0) {
                goto LABEL_308;
              }
              unint64_t v224 = v221;
              unint64_t v24 = v222;
              swift_bridgeObjectRelease(v6);
              swift_bridgeObjectRelease(v19);
              unint64_t v281 = v224;
              unint64_t v282 = v24;
              goto LABEL_169;
            }
          }

          else if (v203 <= 15)
          {
            goto LABEL_242;
          }

          unint64_t v6 = (unint64_t)&v281;
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v203, v22);
          swift_bridgeObjectRelease_n(v19, 4LL);
          if ((v19 & 0x1000000000000000LL) == 0)
          {
            if (v14)
            {
              swift_bridgeObjectRelease_n(v19, 2LL);
              uint64_t v279 = v9;
              uint64_t v280 = v19 & 0xFFFFFFFFFFFFFFLL;
              unint64_t v225 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v19) & 0xF,  (uint64_t)&v279,  HIBYTE(v19) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v225, v226, (v19 & 0x4000000000000000LL) != 0);
              swift_bridgeObjectRelease(v19);
              goto LABEL_251;
            }

            if ((v9 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v19);
              id v237 = (id)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v238 = v9 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v237 = _StringObject.sharedUTF8.getter(v9, v19);
              uint64_t v238 = v253;
              swift_bridgeObjectRelease(v19);
              if (v238 < v3) {
                goto LABEL_285;
              }
            }

            uint64_t v22 = v277;
            uint64_t v14 = v274;
            uint64_t v239 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v9 & 0xFFFFFFFFFFFFLL,  (uint64_t)v237,  v238);
            unint64_t v6 = (unint64_t)&v281;
            _StringGuts.appendInPlace(_:isASCII:)(v239, v240, v9 < 0);
            swift_bridgeObjectRelease_n(v19, 2LL);
            uint64_t v3 = v271;
LABEL_169:
            unint64_t v143 = v276;
            if (v276 == v22) {
              return v281;
            }
            goto LABEL_170;
          }

          swift_bridgeObjectRelease(v19);
          _StringGuts._foreignAppendInPlace(_:)(v9, v19, 0LL, v24);
          swift_bridgeObjectRelease_n(v19, 2LL);
LABEL_251:
          uint64_t v22 = v277;
          uint64_t v3 = v271;
        }

        uint64_t v14 = v274;
        goto LABEL_169;
      }

LABEL_308:
      unint64_t v263 = 266LL;
LABEL_310:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v263,  0);
    }

    break;
  }

            v289 = 266LL;
LABEL_310:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v289,  0);
          }

          goto LABEL_304;
        }

uint64_t specialized Sequence<>.joined(separator:)(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v303 = a2;
  unint64_t v299 = HIBYTE(a2) & 0xF;
  uint64_t v301 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v6 = a3[2] + a3[2] * v5;
  unint64_t v7 = 0xE000000000000000LL;
  unint64_t v310 = 0LL;
  unint64_t v311 = 0xE000000000000000LL;
  if (v6 < 16)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v8 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v9 & 1) != 0 || v8 < v6)
    {
      uint64_t v12 = 2 * _StringGuts.uniqueNativeCapacity.getter();
      if (v12 <= v6) {
        uint64_t v12 = v6;
      }
      if ((v11 & 1) != 0) {
        int64_t v13 = v6;
      }
      else {
        int64_t v13 = v12;
      }
      uint64_t v308 = 0LL;
      uint64_t v309 = 0LL;
      unint64_t v7 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v308,  0LL,  v13,  1);
      uint64_t v10 = *(void *)(v7 + 24);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v310 = v10;
      unint64_t v311 = v7;
    }

    else
    {
      uint64_t v10 = 0LL;
      unint64_t v7 = 0xE000000000000000LL;
    }
  }

  unint64_t v14 = a3[2];
  unint64_t v307 = v14;
  if (v5)
  {
    if (!v14) {
      return v310;
    }
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(0LL, 1, (uint64_t)a3);
    uint64_t v18 = a3[4];
    v300 = a3 + 4;
    unint64_t v19 = a3[5];
    if (&full type metadata for Substring == &full type metadata for String)
    {
      swift_bridgeObjectRetain(a3[5], v15, v16, v17);
    }

    else
    {
      unint64_t v3 = a3[6];
      unint64_t v101 = a3[7];
      swift_bridgeObjectRetain(v101, v15, v16, v17);
      v102._Swift::UInt64 rawBits = v18;
      v103._Swift::UInt64 rawBits = v19;
      uint64_t v18 = specialized String.init<A>(_:)(v102, v103, v3, v101);
      unint64_t v19 = v104;
    }

    uint64_t v105 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000LL) != 0) {
      uint64_t v30 = HIBYTE(v7) & 0xF;
    }
    else {
      uint64_t v30 = v10 & 0xFFFFFFFFFFFFLL;
    }
    if (v30 || (v10 & ~v7 & 0x2000000000000000LL) != 0)
    {
      uint64_t v22 = v19 & 0x2000000000000000LL;
      uint64_t v4 = HIBYTE(v19) & 0xF;
      if ((v7 & 0x2000000000000000LL) != 0 && v22)
      {
        uint64_t v106 = v105 + v4;
        if ((unint64_t)(v105 + v4) <= 0xF)
        {
          if (v4)
          {
            uint64_t v124 = 0LL;
            unint64_t v125 = 0LL;
            unint64_t v126 = v7;
            do
            {
              unint64_t v127 = v105 + v125;
              BOOL v82 = v125++ >= 8;
              if (v82) {
                unint64_t v128 = v19;
              }
              else {
                unint64_t v128 = v18;
              }
              char v129 = (8 * v105 + v124) & 0x38;
              uint64_t v130 = (-255LL << v129) - 1;
              unint64_t v131 = (unint64_t)(v128 >> (v124 & 0x38)) << v129;
              unint64_t v132 = v131 | v130 & v126;
              unint64_t v133 = v131 | v130 & v10;
              if (v127 < 8) {
                uint64_t v10 = v133;
              }
              else {
                unint64_t v126 = v132;
              }
              v124 += 8LL;
            }

            while (8 * v4 != v124);
          }

          else
          {
            unint64_t v126 = v7;
          }

          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v19);
          unint64_t v158 = 0xA000000000000000LL;
          if (!(v10 & 0x8080808080808080LL | v126 & 0x80808080808080LL)) {
            unint64_t v158 = 0xE000000000000000LL;
          }
          unint64_t v310 = v10;
          unint64_t v311 = v158 & 0xFF00000000000000LL | (v106 << 56) | v126 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_182;
        }

        uint64_t v22 = 1LL;
      }

      uint64_t v48 = v18 & 0xFFFFFFFFFFFFLL;
      if (v22) {
        unint64_t v3 = HIBYTE(v19) & 0xF;
      }
      else {
        unint64_t v3 = v18 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v19, 2LL, v20, v21);
      if ((v19 & 0x1000000000000000LL) != 0) {
        goto LABEL_316;
      }
      swift_bridgeObjectRetain_n(v19, 4LL, v46, v47);
      uint64_t v110 = v3;
      if ((v7 & 0x1000000000000000LL) != 0) {
        goto LABEL_319;
      }
      goto LABEL_107;
    }

    swift_bridgeObjectRelease(v7);
    unint64_t v310 = v18;
    unint64_t v311 = v19;
LABEL_182:
    uint64_t v22 = v303;
    if (v14 != 1) {
      goto LABEL_184;
    }
    return v310;
  }

  if (!v14) {
    return v310;
  }
  uint64_t v22 = 0LL;
  uint64_t v23 = (uint64_t)a3;
  while (1)
  {
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v22, 1, v23);
    BOOL v28 = &a3[4 * v22 + 4];
    uint64_t v30 = *v28;
    Swift::UInt64 v29 = v28[1];
    if (&full type metadata for Substring == &full type metadata for String)
    {
      swift_bridgeObjectRetain(v28[1], v25, v26, v27);
      unint64_t v3 = v29;
    }

    else
    {
      unint64_t v33 = v28[2];
      unint64_t v3 = v28[3];
      if ((v3 & 0x2000000000000000LL) != 0) {
        uint64_t v34 = HIBYTE(v3) & 0xF;
      }
      else {
        uint64_t v34 = v33 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain(v3, v25, v26, v27);
      else {
        BOOL v35 = v29 >> 16 == v34;
      }
      if (v35)
      {
        uint64_t v30 = v33;
      }

      else
      {
        v36._Swift::UInt64 rawBits = v30;
        v37._Swift::UInt64 rawBits = v29;
        uint64_t v30 = specialized static String._copying(_:)(v36, v37, v33, v3);
        unint64_t v39 = v38;
        swift_bridgeObjectRelease(v3);
        unint64_t v3 = v39;
      }
    }

    unint64_t v7 = v310;
    unint64_t v19 = v311;
    unint64_t v40 = HIBYTE(v311) & 0xF;
    if ((v311 & 0x2000000000000000LL) != 0) {
      unint64_t v41 = HIBYTE(v311) & 0xF;
    }
    else {
      unint64_t v41 = v310 & 0xFFFFFFFFFFFFLL;
    }
    if (!v41 && (v310 & ~v311 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v311);
      unint64_t v310 = v30;
      unint64_t v311 = v3;
      unint64_t v24 = v307;
      goto LABEL_23;
    }

    uint64_t v42 = v3 & 0x2000000000000000LL;
    uint64_t v18 = HIBYTE(v3) & 0xF;
    if ((v311 & 0x2000000000000000LL) != 0 && v42)
    {
      unint64_t v43 = v40 + v18;
      if (v40 + v18 <= 0xF)
      {
        if (v18)
        {
          uint64_t v77 = 0LL;
          unint64_t v78 = 0LL;
          uint64_t v79 = 8 * v18;
          unint64_t v80 = v311;
          unint64_t v24 = v307;
          do
          {
            unint64_t v81 = v40 + v78;
            BOOL v82 = v78++ >= 8;
            if (v82) {
              unint64_t v83 = v3;
            }
            else {
              unint64_t v83 = v30;
            }
            char v84 = (8 * v40 + v77) & 0x38;
            uint64_t v85 = (-255LL << v84) - 1;
            unint64_t v86 = (unint64_t)(v83 >> (v77 & 0x38)) << v84;
            unint64_t v87 = v86 | v85 & v80;
            unint64_t v88 = v86 | v85 & v7;
            if (v81 < 8) {
              unint64_t v7 = v88;
            }
            else {
              unint64_t v80 = v87;
            }
            v77 += 8LL;
          }

          while (v79 != v77);
        }

        else
        {
          unint64_t v80 = v311;
          unint64_t v24 = v307;
        }

        swift_bridgeObjectRelease(v311);
        swift_bridgeObjectRelease(v3);
        unint64_t v94 = 0xA000000000000000LL;
        if (!(v7 & 0x8080808080808080LL | v80 & 0x80808080808080LL)) {
          unint64_t v94 = 0xE000000000000000LL;
        }
        unint64_t v310 = v7;
        unint64_t v311 = v94 & 0xFF00000000000000LL | (v43 << 56) | v80 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_23;
      }

      uint64_t v42 = 1LL;
    }

    uint64_t v303 = v30 & 0xFFFFFFFFFFFFLL;
    uint64_t v10 = v42 ? HIBYTE(v3) & 0xF : v30 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v3, 2LL, v31, v32);
    if ((v3 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v3, 4LL, v44, v45);
    uint64_t v48 = v10;
    if ((v19 & 0x1000000000000000LL) != 0) {
      goto LABEL_87;
    }
LABEL_49:
    BOOL v49 = __OFADD__(v41, v48);
    uint64_t v4 = v41 + v48;
    if (v49) {
      goto LABEL_313;
    }
LABEL_50:
    if ((v7 & ~v19 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v19 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v50 = v311;
      int64_t v51 = _StringGuts.nativeUnusedCapacity.getter(v310, v311);
      if ((v52 & 1) != 0) {
        goto LABEL_336;
      }
      if (v4 < 16 && ((v50 & 0x2000000000000000LL) != 0 || v51 < v48)) {
        goto LABEL_62;
      }
    }

    else if (v4 <= 15)
    {
      uint64_t v50 = v311;
LABEL_62:
      swift_bridgeObjectRelease_n(v3, 5LL);
      unint64_t v55 = v310;
      swift_bridgeObjectRetain(v50, v56, v57, v58);
      unint64_t v59 = _StringGuts._convertedToSmall()(v55, v50);
      unint64_t v61 = v60;
      swift_bridgeObjectRelease(v50);
      v62._Swift::UInt64 rawBits = (v10 << 16) | 1;
      v63._Swift::UInt64 rawBits = 1LL;
      v64._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v63, v62, v30, v3);
      if (v64._rawBits < 0x10000) {
        v64._rawBits |= 3;
      }
      unint64_t v66 = specialized String.init(_:)(v64, v65, v30, v3);
      unint64_t v68 = v67;
      swift_bridgeObjectRelease(v3);
      unint64_t v69 = _StringGuts._convertedToSmall()(v66, v68);
      unint64_t v71 = v70;
      swift_bridgeObjectRelease(v68);
      unint64_t v72 = specialized _SmallString.init(_:appending:)(v59, v61, v69, v71);
      if ((v74 & 1) != 0) {
        goto LABEL_335;
      }
      uint64_t v75 = v72;
      unint64_t v76 = v73;
      swift_bridgeObjectRelease(v50);
      swift_bridgeObjectRelease(v3);
      unint64_t v310 = v75;
      unint64_t v311 = v76;
LABEL_22:
      uint64_t v23 = (uint64_t)a3;
      unint64_t v24 = v307;
      goto LABEL_23;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v4, v48);
    swift_bridgeObjectRelease_n(v3, 4LL);
    if ((v3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v3);
      _StringGuts._foreignAppendInPlace(_:)(v30, v3, 0LL, v10);
      swift_bridgeObjectRelease_n(v3, 2LL);
      goto LABEL_22;
    }

    if (v42)
    {
      swift_bridgeObjectRelease_n(v3, 2LL);
      uint64_t v308 = v30;
      uint64_t v309 = v3 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v53 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v3) & 0xF,  (uint64_t)&v308,  HIBYTE(v3) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v53, v54, (v3 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v3);
      goto LABEL_22;
    }

    if ((v30 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v3);
      id v89 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v90 = v30 & 0xFFFFFFFFFFFFLL;
      uint64_t v91 = v30 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      id v89 = _StringObject.sharedUTF8.getter(v30, v3);
      uint64_t v91 = v100;
      swift_bridgeObjectRelease(v3);
      uint64_t v90 = v30 & 0xFFFFFFFFFFFFLL;
      if (v91 < v303) {
        goto LABEL_311;
      }
    }

    uint64_t v23 = (uint64_t)a3;
    Swift::String::Index v92 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v90, (uint64_t)v89, v91);
    _StringGuts.appendInPlace(_:isASCII:)(v92, v93, v30 < 0);
    swift_bridgeObjectRelease_n(v3, 2LL);
    unint64_t v24 = v307;
LABEL_23:
    if (++v22 == v24) {
      return v310;
    }
  }

  swift_bridgeObjectRetain_n(v3, 5LL, v44, v45);
  v95._Swift::UInt64 rawBits = 1LL;
  v96._Swift::UInt64 rawBits = (v10 << 16) | 1;
  v97._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v95, v96, v30, v3);
  if (v97._rawBits < 0x10000) {
    v97._rawBits |= 3;
  }
  uint64_t v48 = specialized Collection.count.getter(v97, v98, v30, v3);
  swift_bridgeObjectRelease(v3);
  if ((v19 & 0x1000000000000000LL) == 0) {
    goto LABEL_49;
  }
LABEL_87:
  Swift::Int v99 = String.UTF8View._foreignCount()();
  uint64_t v4 = v99 + v48;
  if (!__OFADD__(v99, v48)) {
    goto LABEL_50;
  }
LABEL_313:
  while (2)
  {
    __break(1u);
LABEL_314:
    __break(1u);
LABEL_315:
    __break(1u);
LABEL_316:
    swift_bridgeObjectRetain_n(v19, 5LL, v46, v47);
    v282._Swift::UInt64 rawBits = 1LL;
    v283._Swift::UInt64 rawBits = (v3 << 16) | 1;
    v284._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v282, v283, v18, v19);
    if (v284._rawBits < 0x10000) {
      v284._rawBits |= 3;
    }
    uint64_t v110 = specialized Collection.count.getter(v284, v285, v18, v19);
    swift_bridgeObjectRelease(v19);
    if ((v7 & 0x1000000000000000LL) != 0)
    {
LABEL_319:
      Swift::Int v286 = String.UTF8View._foreignCount()();
      uint64_t v30 = v286 + v110;
      if (!__OFADD__(v286, v110)) {
        goto LABEL_108;
      }
LABEL_321:
      __break(1u);
LABEL_322:
      unint64_t v287 = v3;
      if ((v10 & 0x1000000000000000LL) != 0)
      {
        uint64_t v110 = _StringGuts._foreignConvertedToSmall()(v110, v7);
        uint64_t v10 = v294;
      }

      else
      {
        if ((v110 & 0x1000000000000000LL) != 0)
        {
          v288 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v289 = v110 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v288 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v110, v7);
          uint64_t v289 = v107;
        }

        swift_bridgeObjectRetain(v7, v107, v108, v109);
        closure #1 in _StringGuts._convertedToSmall()(v288, v289, &v308);
        swift_bridgeObjectRelease(v7);
        uint64_t v110 = v308;
        uint64_t v10 = v309;
      }

      uint64_t v22 = v303;
      unint64_t v3 = v287;
LABEL_160:
      v139._Swift::UInt64 rawBits = (v3 << 16) | 1;
      v140._Swift::UInt64 rawBits = 1LL;
      v141._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v140, v139, v18, v19);
      if (v141._rawBits < 0x10000) {
        v141._rawBits |= 3;
      }
      uint64_t v18 = specialized String.init(_:)(v141, v142, v18, v19);
      uint64_t v30 = v143;
      swift_bridgeObjectRelease(v19);
      if ((v30 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v30);
      }

      else
      {
        if ((v30 & 0x1000000000000000LL) != 0)
        {
          uint64_t v18 = _StringGuts._foreignConvertedToSmall()(v18, v30);
          uint64_t v296 = v295;
          swift_bridgeObjectRelease(v30);
          uint64_t v30 = v296;
        }

        else
        {
          if ((v18 & 0x1000000000000000LL) != 0)
          {
            v290 = (unsigned __int8 *)((v30 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v291 = v18 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            v290 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v18, v30);
          }

          closure #1 in _StringGuts._convertedToSmall()(v290, v291, &v308);
          swift_bridgeObjectRelease(v30);
          uint64_t v18 = v308;
          uint64_t v30 = v309;
        }

        uint64_t v22 = v303;
      }

      uint64_t v144 = HIBYTE(v10) & 0xF;
      uint64_t v145 = HIBYTE(v30) & 0xF;
      uint64_t v146 = v145 + v144;
      if ((unint64_t)(v145 + v144) <= 0xF)
      {
        if (v145)
        {
          uint64_t v147 = 0LL;
          unint64_t v148 = 0LL;
          uint64_t v149 = 8 * v145;
          do
          {
            unint64_t v150 = v144 + v148;
            BOOL v82 = v148++ >= 8;
            if (v82) {
              unint64_t v151 = v30;
            }
            else {
              unint64_t v151 = v18;
            }
            char v152 = (8 * v144 + v147) & 0x38;
            uint64_t v153 = (-255LL << v152) - 1;
            unint64_t v154 = (unint64_t)(v151 >> (v147 & 0x38)) << v152;
            unint64_t v155 = v154 | v153 & v10;
            unint64_t v156 = v154 | v153 & v110;
            if (v150 < 8) {
              uint64_t v110 = v156;
            }
            else {
              uint64_t v10 = v155;
            }
            v147 += 8LL;
          }

          while (v149 != v147);
        }

        swift_bridgeObjectRelease(v7);
        swift_bridgeObjectRelease(v19);
        unint64_t v157 = 0xA000000000000000LL;
        if (!(v110 & 0x8080808080808080LL | v10 & 0x80808080808080LL)) {
          unint64_t v157 = 0xE000000000000000LL;
        }
        unint64_t v310 = v110;
        unint64_t v311 = v157 & 0xFF00000000000000LL | (v146 << 56) | v10 & 0xFFFFFFFFFFFFFFLL;
        if (v307 == 1) {
          return v310;
        }
LABEL_184:
        uint64_t v297 = (v22 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v298 = v22 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v48 = 1LL;
LABEL_188:
        specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v48, 1, (uint64_t)a3);
        if (__OFADD__(v48, 1LL))
        {
          __break(1u);
          continue;
        }

        uint64_t v305 = v48 + 1;
        Swift::UInt64 v162 = &v300[4 * v48];
        uint64_t v18 = *v162;
        unint64_t v163 = v162[1];
        uint64_t v10 = v162[2];
        unint64_t v19 = v162[3];
        uint64_t v4 = v310;
        unint64_t v7 = v311;
        unint64_t v164 = HIBYTE(v311) & 0xF;
        if ((v311 & 0x2000000000000000LL) != 0) {
          unint64_t v165 = HIBYTE(v311) & 0xF;
        }
        else {
          unint64_t v165 = v310 & 0xFFFFFFFFFFFFLL;
        }
        if (!v165 && (v310 & ~v311 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRetain(v19, v161, v46, v47);
          swift_bridgeObjectRetain(v22, v202, v203, v204);
          swift_bridgeObjectRelease(v7);
          unint64_t v310 = a1;
          unint64_t v311 = v22;
          goto LABEL_238;
        }

        if ((v311 & 0x2000000000000000LL) == 0)
        {
          uint64_t v30 = v301;
          if ((v22 & 0x2000000000000000LL) != 0) {
            uint64_t v30 = v299;
          }
LABEL_199:
          if ((v22 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRetain(v19, v161, v46, v47);
            v270._Swift::UInt64 rawBits = 1LL;
            v271._Swift::UInt64 rawBits = (v30 << 16) | 1;
            v272._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v270, v271, a1, v22);
            if (v272._rawBits < 0x10000) {
              v272._rawBits |= 3;
            }
            unint64_t v3 = specialized Collection.count.getter(v272, v273, a1, v22);
            if ((v7 & 0x1000000000000000LL) == 0) {
              goto LABEL_201;
            }
          }

          else
          {
            swift_bridgeObjectRetain(v19, v161, v46, v47);
            unint64_t v3 = v30;
            if ((v7 & 0x1000000000000000LL) == 0)
            {
LABEL_201:
              BOOL v49 = __OFADD__(v165, v3);
              uint64_t v48 = v165 + v3;
              if (v49) {
                goto LABEL_314;
              }
              goto LABEL_202;
            }
          }

          Swift::Int v274 = String.UTF8View._foreignCount()();
          uint64_t v48 = v274 + v3;
          if (__OFADD__(v274, v3)) {
            goto LABEL_314;
          }
LABEL_202:
          if ((v4 & ~v7 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v168 = _StringGuts.nativeUnusedCapacity.getter(v4, v7);
            if ((v167 & 1) != 0) {
              goto LABEL_336;
            }
            uint64_t v169 = (v7 >> 61) & 1;
            if (v48 <= 15 && (v169 & 1) != 0)
            {
LABEL_209:
              swift_bridgeObjectRetain(v7, v167, v46, v47);
              unint64_t v170 = _StringGuts._convertedToSmall()(v4, v7);
              unint64_t v172 = v171;
              swift_bridgeObjectRelease(v7);
              v173._Swift::UInt64 rawBits = (v30 << 16) | 1;
              v174._Swift::UInt64 rawBits = 1LL;
              Swift::UInt64 v175 = _StringGuts.validateScalarRange(_:)(v174, v173, a1, v22);
              Swift::UInt64 v179 = v176;
              if (v175 >= 0x10000) {
                Swift::UInt64 v180 = v175;
              }
              else {
                Swift::UInt64 v180 = v175 | 3;
              }
              swift_bridgeObjectRetain(v22, v176, v177, v178);
              v181._Swift::UInt64 rawBits = v180;
              v182._Swift::UInt64 rawBits = v179;
              unint64_t v183 = specialized String.init(_:)(v181, v182, a1, v22);
              uint64_t v4 = v184;
              swift_bridgeObjectRelease(v22);
              unint64_t v185 = _StringGuts._convertedToSmall()(v183, v4);
              unint64_t v187 = v186;
              swift_bridgeObjectRelease(v4);
              unint64_t v188 = specialized _SmallString.init(_:appending:)(v170, v172, v185, v187);
              if ((v190 & 1) != 0) {
                goto LABEL_335;
              }
              uint64_t v191 = v188;
              unint64_t v192 = v189;
              swift_bridgeObjectRelease(v7);
              unint64_t v310 = v191;
              unint64_t v311 = v192;
              uint64_t v22 = v303;
              goto LABEL_238;
            }
          }

          else if (v48 <= 15)
          {
            goto LABEL_209;
          }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v48, v3);
          if ((v22 & 0x1000000000000000LL) != 0)
          {
            _StringGuts._foreignAppendInPlace(_:)(a1, v22, 0LL, v30);
          }

          else
          {
            uint64_t v196 = a1;
            if ((v22 & 0x2000000000000000LL) != 0)
            {
              uint64_t v308 = a1;
              uint64_t v309 = v298;
              if (v299 < v30) {
                goto LABEL_311;
              }
              Swift::String::Index v215 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v30, (uint64_t)&v308, v299);
              _StringGuts.appendInPlace(_:isASCII:)(v215, v216, (v22 & 0x4000000000000000LL) != 0);
            }

            else
            {
              uint64_t v197 = v297;
              uint64_t v198 = v301;
              if ((a1 & 0x1000000000000000LL) != 0)
              {
                if (v301 < v30) {
                  goto LABEL_311;
                }
              }

              else
              {
                uint64_t v197 = (uint64_t)_StringObject.sharedUTF8.getter(a1, v22);
                uint64_t v198 = v280;
                uint64_t v196 = a1;
                if (v280 < v30) {
                  goto LABEL_311;
                }
              }

              uint64_t v199 = v196;
              unint64_t v200 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v30, v197, v198);
              _StringGuts.appendInPlace(_:isASCII:)(v200, v201, v199 < 0);
            }
          }

          goto LABEL_238;
        }

        uint64_t v30 = v301;
        uint64_t v161 = -255LL;
        if ((v22 & 0x2000000000000000LL) == 0) {
          goto LABEL_199;
        }
        uint64_t v30 = v299;
        unint64_t v166 = v164 + v299;
        if (v164 + v299 > 0xF) {
          goto LABEL_199;
        }
        if (v299)
        {
          uint64_t v205 = 0LL;
          unint64_t v206 = 0LL;
          unint64_t v207 = v311;
          do
          {
            unint64_t v208 = v164 + v206;
            BOOL v82 = v206++ >= 8;
            if (v82) {
              unint64_t v209 = v22;
            }
            else {
              unint64_t v209 = a1;
            }
            char v210 = (8 * v164 + v205) & 0x38;
            uint64_t v211 = (-255LL << v210) - 1;
            unint64_t v212 = (unint64_t)(v209 >> (v205 & 0x38)) << v210;
            unint64_t v213 = v212 | v211 & v207;
            unint64_t v214 = v212 | v211 & v4;
            if (v208 < 8) {
              uint64_t v4 = v214;
            }
            else {
              unint64_t v207 = v213;
            }
            v205 += 8LL;
          }

          while (8 * v299 != v205);
        }

        else
        {
          unint64_t v207 = v311;
        }

        unint64_t v217 = 0xA000000000000000LL;
        if (!(v4 & 0x8080808080808080LL | v207 & 0x80808080808080LL)) {
          unint64_t v217 = 0xE000000000000000LL;
        }
        unint64_t v218 = v217 | (v166 << 56);
        swift_bridgeObjectRetain(v19, -255LL, v46, v47);
        swift_bridgeObjectRelease(v7);
        unint64_t v310 = v4;
        unint64_t v311 = v218 & 0xFF00000000000000LL | v207 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v22 = v303;
LABEL_238:
        if (&full type metadata for Substring == &full type metadata for String)
        {
          swift_bridgeObjectRetain(v163, v193, v194, v195);
          swift_bridgeObjectRelease(v19);
          unint64_t v19 = v163;
        }

        else
        {
          uint64_t v219 = HIBYTE(v19) & 0xF;
          if ((v19 & 0x2000000000000000LL) == 0) {
            uint64_t v219 = v10 & 0xFFFFFFFFFFFFLL;
          }
          if ((unint64_t)v18 >> 16 || v163 >> 16 != v219)
          {
            v220._Swift::UInt64 rawBits = v18;
            v221._Swift::UInt64 rawBits = v163;
            uint64_t v18 = specialized static String._copying(_:)(v220, v221, v10, v19);
            unint64_t v223 = v222;
            swift_bridgeObjectRelease(v19);
            unint64_t v19 = v223;
          }

          else
          {
            uint64_t v18 = v10;
          }
        }

        unint64_t v7 = v310;
        uint64_t v30 = v311;
        unint64_t v224 = HIBYTE(v311) & 0xF;
        if ((v311 & 0x2000000000000000LL) != 0) {
          unint64_t v225 = HIBYTE(v311) & 0xF;
        }
        else {
          unint64_t v225 = v310 & 0xFFFFFFFFFFFFLL;
        }
        if (!v225 && (v310 & ~v311 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v311);
          unint64_t v310 = v18;
          unint64_t v311 = v19;
          goto LABEL_186;
        }

        uint64_t v22 = v19 & 0x2000000000000000LL;
        uint64_t v226 = HIBYTE(v19) & 0xF;
        if ((v311 & 0x2000000000000000LL) == 0 || !v22) {
          goto LABEL_255;
        }
        unint64_t v227 = v224 + v226;
        if (v224 + v226 <= 0xF)
        {
          if (v226)
          {
            uint64_t v254 = 0LL;
            unint64_t v255 = 0LL;
            uint64_t v256 = 8 * v226;
            unint64_t v257 = v311;
            unint64_t v3 = v307;
            uint64_t v160 = v305;
            do
            {
              unint64_t v258 = v224 + v255;
              BOOL v82 = v255++ >= 8;
              if (v82) {
                unint64_t v259 = v19;
              }
              else {
                unint64_t v259 = v18;
              }
              char v260 = (8 * v224 + v254) & 0x38;
              uint64_t v261 = (-255LL << v260) - 1;
              unint64_t v262 = (unint64_t)(v259 >> (v254 & 0x38)) << v260;
              unint64_t v263 = v262 | v261 & v257;
              unint64_t v264 = v262 | v261 & v7;
              if (v258 < 8) {
                unint64_t v7 = v264;
              }
              else {
                unint64_t v257 = v263;
              }
              v254 += 8LL;
            }

            while (v256 != v254);
          }

          else
          {
            unint64_t v257 = v311;
            unint64_t v3 = v307;
            uint64_t v160 = v305;
          }

          swift_bridgeObjectRelease(v311);
          swift_bridgeObjectRelease(v19);
          unint64_t v269 = 0xA000000000000000LL;
          if (!(v7 & 0x8080808080808080LL | v257 & 0x80808080808080LL)) {
            unint64_t v269 = 0xE000000000000000LL;
          }
          unint64_t v310 = v7;
          unint64_t v311 = v269 & 0xFF00000000000000LL | (v227 << 56) | v257 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v22 = v303;
          goto LABEL_187;
        }

        uint64_t v22 = 1LL;
LABEL_255:
        uint64_t v10 = v18 & 0xFFFFFFFFFFFFLL;
        if (v22) {
          unint64_t v3 = HIBYTE(v19) & 0xF;
        }
        else {
          unint64_t v3 = v18 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v19, 2LL, v194, v195);
        if ((v19 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRetain_n(v19, 5LL, v228, v229);
          v275._Swift::UInt64 rawBits = 1LL;
          v276._Swift::UInt64 rawBits = (v3 << 16) | 1;
          v277._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v275, v276, v18, v19);
          if (v277._rawBits < 0x10000) {
            v277._rawBits |= 3;
          }
          uint64_t v4 = specialized Collection.count.getter(v277, v278, v18, v19);
          swift_bridgeObjectRelease(v19);
          if ((v30 & 0x1000000000000000LL) == 0) {
            goto LABEL_260;
          }
        }

        else
        {
          swift_bridgeObjectRetain_n(v19, 4LL, v228, v229);
          uint64_t v4 = v3;
          if ((v30 & 0x1000000000000000LL) == 0)
          {
LABEL_260:
            BOOL v49 = __OFADD__(v225, v4);
            uint64_t v48 = v225 + v4;
            if (v49) {
              goto LABEL_315;
            }
            goto LABEL_261;
          }
        }

        Swift::Int v279 = String.UTF8View._foreignCount()();
        uint64_t v48 = v279 + v4;
        if (__OFADD__(v279, v4)) {
          goto LABEL_315;
        }
LABEL_261:
        if ((v7 & ~v30 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v30 & 0xFFFFFFFFFFFFFFFLL))
        {
          unint64_t v7 = v311;
          int64_t v230 = _StringGuts.nativeUnusedCapacity.getter(v310, v311);
          if ((v231 & 1) != 0) {
            goto LABEL_336;
          }
          if (v48 < 16 && ((v7 & 0x2000000000000000LL) != 0 || v230 < v4))
          {
LABEL_273:
            swift_bridgeObjectRelease_n(v19, 5LL);
            unint64_t v234 = v310;
            swift_bridgeObjectRetain(v7, v235, v236, v237);
            unint64_t v238 = _StringGuts._convertedToSmall()(v234, v7);
            uint64_t v30 = v239;
            swift_bridgeObjectRelease(v7);
            v240._Swift::UInt64 rawBits = (v3 << 16) | 1;
            v241._Swift::UInt64 rawBits = 1LL;
            v242._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v241, v240, v18, v19);
            if (v242._rawBits < 0x10000) {
              v242._rawBits |= 3;
            }
            unint64_t v244 = specialized String.init(_:)(v242, v243, v18, v19);
            uint64_t v18 = v245;
            swift_bridgeObjectRelease(v19);
            unint64_t v246 = _StringGuts._convertedToSmall()(v244, v18);
            unint64_t v248 = v247;
            swift_bridgeObjectRelease(v18);
            unint64_t v249 = specialized _SmallString.init(_:appending:)(v238, v30, v246, v248);
            uint64_t v22 = v303;
            if ((v251 & 1) != 0) {
              goto LABEL_335;
            }
            uint64_t v252 = v249;
            unint64_t v253 = v250;
            swift_bridgeObjectRelease(v7);
            swift_bridgeObjectRelease(v19);
            unint64_t v310 = v252;
            unint64_t v311 = v253;
LABEL_186:
            unint64_t v3 = v307;
            uint64_t v160 = v305;
            goto LABEL_187;
          }
        }

        else if (v48 <= 15)
        {
          unint64_t v7 = v311;
          goto LABEL_273;
        }

        unint64_t v7 = (unint64_t)&v310;
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v48, v4);
        swift_bridgeObjectRelease_n(v19, 4LL);
        if ((v19 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v19);
          _StringGuts._foreignAppendInPlace(_:)(v18, v19, 0LL, v3);
          swift_bridgeObjectRelease_n(v19, 2LL);
        }

        else
        {
          if (!v22)
          {
            if ((v18 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v19);
              id v265 = (id)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v266 = v18 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v265 = _StringObject.sharedUTF8.getter(v18, v19);
              uint64_t v266 = v281;
              swift_bridgeObjectRelease(v19);
              if (v266 < v10) {
                goto LABEL_311;
              }
            }

            unint64_t v3 = v307;
            uint64_t v22 = v303;
            uint64_t v160 = v305;
            uint64_t v267 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v18 & 0xFFFFFFFFFFFFLL,  (uint64_t)v265,  v266);
            unint64_t v7 = (unint64_t)&v310;
            _StringGuts.appendInPlace(_:isASCII:)(v267, v268, v18 < 0);
            swift_bridgeObjectRelease_n(v19, 2LL);
            goto LABEL_187;
          }

          swift_bridgeObjectRelease_n(v19, 2LL);
          uint64_t v308 = v18;
          uint64_t v309 = v19 & 0xFFFFFFFFFFFFFFLL;
          char v232 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v19) & 0xF,  (uint64_t)&v308,  HIBYTE(v19) & 0xF);
          _StringGuts.appendInPlace(_:isASCII:)(v232, v233, (v19 & 0x4000000000000000LL) != 0);
          swift_bridgeObjectRelease(v19);
        }

        unint64_t v3 = v307;
        uint64_t v22 = v303;
        uint64_t v160 = v305;
LABEL_187:
        uint64_t v48 = v160;
        if (v160 == v3) {
          return v310;
        }
        goto LABEL_188;
      }

unint64_t Sequence<>.joined(separator:)( uint64_t a1, unint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  uint64_t v372 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v385 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  v366 = (Swift::UInt64 *)((char *)&v363 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  v370 = (uint64_t *)((char *)&v363 - v15);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  v378 = (uint64_t (*)(void (*)(uint64_t), uint64_t, ValueMetadata *))((char *)&v363 - v17);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (Swift::UInt64 *)((char *)&v363 - v19);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  v373 = (void (*)(uint64_t *, uint64_t))((char *)&v363 - v22);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  v380 = (void (*)(Swift::Int, char *, uint64_t))((char *)&v363 - v24);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  v381 = (unsigned int (*)(char *, uint64_t, ValueMetadata *))((char *)&v363 - v26);
  MEMORY[0x1895F8858](v25);
  Swift::Int v367 = (Swift::Int)&v363 - v27;
  v386 = (ValueMetadata *)v28;
  uint64_t v369 = type metadata accessor for Optional(0LL, v28, v29, v30);
  uint64_t v368 = *(void *)(v369 - 8);
  uint64_t v31 = MEMORY[0x1895F8858](v369);
  v379 = (char *)&v363 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  BOOL v35 = (char *)&v363 - v34;
  uint64_t v36 = MEMORY[0x1895F8858](v33);
  v383 = (void (*)(uint64_t))((char *)&v363 - v37);
  uint64_t v38 = *(a3 - 1);
  MEMORY[0x1895F8858](v36);
  unint64_t v40 = (char *)&v363 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v41 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v42 = MEMORY[0x1895F8858](v41);
  v382 = (char *)&v363 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  v384 = (char *)&v363 - v46;
  if (a3 == (void *)&unk_189B86C78) {
    return specialized Sequence<>.joined(separator:)(a1, a2, *v6);
  }
  if (a3 == (void *)&unk_189B87EB0) {
    return specialized Sequence<>.joined(separator:)(a1, a2, *v6);
  }
  v375 = v20;
  uint64_t v365 = v45;
  uint64_t v387 = v44;
  uint64_t v376 = a1;
  unint64_t v377 = a2;
  unint64_t v371 = HIBYTE(a2) & 0xF;
  uint64_t v374 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v47 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v47 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v48 = (*(uint64_t (**)(void *, uint64_t))(a4 + 40))(a3, a4);
  uint64_t v49 = v48 + v48 * v47;
  unint64_t v390 = 0LL;
  unint64_t v391 = 0xE000000000000000LL;
  if (v49 >= 16)
  {
    uint64_t v50 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v51 & 1) != 0 || v50 < v49)
    {
      uint64_t v53 = 2 * _StringGuts.uniqueNativeCapacity.getter();
      if (v53 <= v49) {
        uint64_t v53 = v49;
      }
      if ((v52 & 1) != 0) {
        int64_t v54 = v49;
      }
      else {
        int64_t v54 = v53;
      }
      uint64_t v388 = 0LL;
      uint64_t v389 = 0LL;
      int64_t v55 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v388,  0LL,  v54,  1);
      uint64_t v56 = *(void *)(v55 + 24);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v390 = v56;
      unint64_t v391 = v55;
    }
  }

  (*(void (**)(char *, void **, void *))(v38 + 16))(v40, v6, a3);
  uint64_t v57 = *(void (**)(void *, uint64_t))(a4 + 32);
  if (v47)
  {
    Swift::String::Index v58 = v382;
    v57(a3, a4);
    uint64_t v59 = v387;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  (uint64_t)a3,  v387,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    v383 = *(void (**)(uint64_t))(AssociatedConformanceWitness + 16);
    v384 = (char *)AssociatedConformanceWitness;
    v383(v59);
    uint64_t v61 = v385;
    uint64_t v62 = (uint64_t)v386;
    v381 = *(unsigned int (**)(char *, uint64_t, ValueMetadata *))(v385 + 48);
    if (v381(v35, 1LL, v386) == 1)
    {
      (*(void (**)(char *, uint64_t))(v365 + 8))(v58, v59);
      (*(void (**)(char *, uint64_t))(v368 + 8))(v35, v369);
      return v390;
    }

    unint64_t v73 = (uint64_t *)v367;
    v380 = *(void (**)(Swift::Int, char *, uint64_t))(v61 + 32);
    v380(v367, v35, v62);
    if ((ValueMetadata *)v62 == &type metadata for String)
    {
      uint64_t v79 = *v73;
      unint64_t v81 = v73[1];
      swift_bridgeObjectRetain(v81, v74, v75, v76);
    }

    else
    {
      if ((ValueMetadata *)v62 != &type metadata for Substring)
      {
        uint64_t v77 = v385;
        unint64_t v78 = v366;
        (*(void (**)(Swift::UInt64 *, uint64_t *, uint64_t))(v385 + 16))(v366, v73, v62);
        uint64_t v79 = String.init<A>(_:)(v78, (swift *)v62, *(void *)(v372 + 40));
        unint64_t v81 = v80;
LABEL_102:
        v373 = *(void (**)(uint64_t *, uint64_t))(v77 + 8);
        v373(v73, v62);
        uint64_t v96 = v390;
        uint64_t v106 = v391;
        unint64_t v168 = HIBYTE(v391) & 0xF;
        if ((v391 & 0x2000000000000000LL) != 0) {
          uint64_t v88 = HIBYTE(v391) & 0xF;
        }
        else {
          uint64_t v88 = v390 & 0xFFFFFFFFFFFFLL;
        }
        if (v88 || (v390 & ~v391 & 0x2000000000000000LL) != 0)
        {
          unint64_t v89 = v81 & 0x2000000000000000LL;
          uint64_t v62 = HIBYTE(v81) & 0xF;
          if ((v391 & 0x2000000000000000LL) == 0 || !v89)
          {
LABEL_111:
            int64_t v108 = v79 & 0xFFFFFFFFFFFFLL;
            if (v89) {
              Swift::Int v99 = HIBYTE(v81) & 0xF;
            }
            else {
              Swift::Int v99 = v79 & 0xFFFFFFFFFFFFLL;
            }
            swift_bridgeObjectRetain_n(v81, 2LL, v166, v167);
            if ((v81 & 0x1000000000000000LL) != 0) {
              goto LABEL_330;
            }
            swift_bridgeObjectRetain_n(v81, 4LL, v104, v105);
            Swift::Int v173 = v99;
            goto LABEL_116;
          }

          unint64_t v169 = v168 + v62;
          if (v168 + v62 > 0xF)
          {
            unint64_t v89 = 1LL;
            goto LABEL_111;
          }

          if (v62)
          {
            uint64_t v190 = 0LL;
            unint64_t v191 = 0LL;
            uint64_t v192 = 8 * v62;
            unint64_t v193 = v391;
            uint64_t v62 = (uint64_t)v386;
            unint64_t v89 = (unint64_t)v378;
            do
            {
              unint64_t v194 = v168 + v191;
              BOOL v141 = v191++ >= 8;
              if (v141) {
                unint64_t v195 = v81;
              }
              else {
                unint64_t v195 = v79;
              }
              char v196 = (8 * v168 + v190) & 0x38;
              uint64_t v197 = (-255LL << v196) - 1;
              unint64_t v198 = (unint64_t)(v195 >> (v190 & 0x38)) << v196;
              unint64_t v199 = v198 | v197 & v193;
              unint64_t v200 = v198 | v197 & v96;
              if (v194 < 8) {
                uint64_t v96 = v200;
              }
              else {
                unint64_t v193 = v199;
              }
              v190 += 8LL;
            }

            while (v192 != v190);
          }

          else
          {
            unint64_t v193 = v391;
            uint64_t v62 = (uint64_t)v386;
            unint64_t v89 = (unint64_t)v378;
          }

          swift_bridgeObjectRelease(v391);
          swift_bridgeObjectRelease(v81);
          unint64_t v227 = 0xA000000000000000LL;
          if (!(v96 & 0x8080808080808080LL | v193 & 0x80808080808080LL)) {
            unint64_t v227 = 0xE000000000000000LL;
          }
          unint64_t v390 = v96;
          unint64_t v391 = v227 & 0xFF00000000000000LL | (v169 << 56) | v193 & 0xFFFFFFFFFFFFFFLL;
LABEL_191:
          unint64_t v186 = v382;
          goto LABEL_192;
        }

        swift_bridgeObjectRelease(v391);
        unint64_t v390 = v79;
        unint64_t v391 = v81;
LABEL_153:
        unint64_t v89 = (unint64_t)v378;
        goto LABEL_191;
      }

      Swift::UInt64 v159 = *v73;
      Swift::UInt64 v160 = v73[1];
      unint64_t v161 = v73[2];
      unint64_t v162 = v73[3];
      swift_bridgeObjectRetain(v162, v74, v75, v76);
      v163._Swift::UInt64 rawBits = v159;
      v164._Swift::UInt64 rawBits = v160;
      uint64_t v79 = specialized String.init<A>(_:)(v163, v164, v161, v162);
      unint64_t v81 = v165;
    }

    uint64_t v77 = v385;
    goto LABEL_102;
  }

  v57(a3, a4);
  uint64_t v64 = v387;
  unint64_t v65 = swift_getAssociatedConformanceWitness( a4,  (uint64_t)a3,  v387,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v66 = *(char **)(v65 + 16);
  unint64_t v67 = v383;
  v382 = (char *)v65;
  v379 = v66;
  ((void (*)(uint64_t))v66)(v64);
  uint64_t v69 = v385;
  unint64_t v68 = v386;
  v378 = *(uint64_t (**)(void (*)(uint64_t), uint64_t, ValueMetadata *))(v385 + 48);
  int v70 = v378(v67, 1LL, v386);
  unint64_t v71 = (char *)v380;
  unint64_t v72 = (Swift::UInt64 *)v381;
  if (v70 == 1)
  {
LABEL_21:
    (*(void (**)(char *, uint64_t))(v365 + 8))(v384, v64);
    return v390;
  }

  unint64_t v377 = *(void *)(v69 + 32);
  ((void (*)(unsigned int (*)(char *, uint64_t, ValueMetadata *), void (*)(uint64_t), ValueMetadata *))v377)( v381,  v67,  v68);
  while (1)
  {
    if (v68 == &type metadata for String)
    {
      uint64_t v88 = *v72;
      unint64_t v89 = v72[1];
LABEL_38:
      swift_bridgeObjectRetain(v89, v82._rawBits, v83, v84);
      goto LABEL_41;
    }

    if (v68 != &type metadata for Substring)
    {
      unint64_t v86 = *(void (**)(char *, Swift::UInt64 *, ValueMetadata *))(v69 + 16);
      v86(v71, v72, v68);
      unint64_t v87 = (uint64_t *)v373;
      v86((char *)v373, (Swift::UInt64 *)v71, v68);
      if ((swift_dynamicCast((char *)&v388, v87, (swift *)v68, (const char *)&type metadata for String, 6uLL) & 1) != 0)
      {
        (*(void (**)(char *, ValueMetadata *))(v69 + 8))(v71, v68);
        uint64_t v88 = v388;
        unint64_t v89 = v389;
      }

      else
      {
        uint64_t v88 = (*(uint64_t (**)(ValueMetadata *))(*(void *)(*(void *)(v372 + 40) + 8LL) + 8LL))(v68);
        unint64_t v89 = v92;
        (*(void (**)(char *, ValueMetadata *))(v69 + 8))(v71, v68);
      }

      goto LABEL_41;
    }

    v90._Swift::UInt64 rawBits = *v72;
    v82._Swift::UInt64 rawBits = v72[1];
    uint64_t v88 = v72[2];
    unint64_t v89 = v72[3];
    uint64_t v91 = HIBYTE(v89) & 0xF;
    if ((v89 & 0x2000000000000000LL) == 0) {
      uint64_t v91 = v88 & 0xFFFFFFFFFFFFLL;
    }
    if (!(v90._rawBits >> 16) && v82._rawBits >> 16 == v91) {
      goto LABEL_38;
    }
    uint64_t v88 = specialized static String._copying(_:)(v90, v82, v72[2], v72[3]);
    unint64_t v89 = v93;
LABEL_41:
    (*(void (**)(Swift::UInt64 *, ValueMetadata *))(v69 + 8))(v72, v68);
    unint64_t v81 = v390;
    uint64_t v96 = v391;
    unint64_t v97 = HIBYTE(v391) & 0xF;
    if ((v391 & 0x2000000000000000LL) != 0) {
      unint64_t v98 = HIBYTE(v391) & 0xF;
    }
    else {
      unint64_t v98 = v390 & 0xFFFFFFFFFFFFLL;
    }
    if (!v98 && (v390 & ~v391 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v391);
      unint64_t v390 = v88;
      unint64_t v391 = v89;
      goto LABEL_27;
    }

    Swift::Int v99 = v89 & 0x2000000000000000LL;
    uint64_t v100 = HIBYTE(v89) & 0xF;
    if ((v391 & 0x2000000000000000LL) != 0 && v99)
    {
      unint64_t v101 = v97 + v100;
      if (v97 + v100 <= 0xF)
      {
        if (v100)
        {
          uint64_t v136 = 0LL;
          unint64_t v137 = 0LL;
          uint64_t v138 = 8 * v100;
          unint64_t v139 = v391;
          uint64_t v64 = v387;
          unint64_t v72 = (Swift::UInt64 *)v381;
          do
          {
            unint64_t v140 = v97 + v137;
            BOOL v141 = v137++ >= 8;
            if (v141) {
              unint64_t v142 = v89;
            }
            else {
              unint64_t v142 = v88;
            }
            char v143 = (8 * v97 + v136) & 0x38;
            uint64_t v144 = (-255LL << v143) - 1;
            unint64_t v145 = (unint64_t)(v142 >> (v136 & 0x38)) << v143;
            unint64_t v146 = v145 | v144 & v139;
            unint64_t v147 = v145 | v144 & v81;
            if (v140 < 8) {
              unint64_t v81 = v147;
            }
            else {
              unint64_t v139 = v146;
            }
            v136 += 8LL;
          }

          while (v138 != v136);
        }

        else
        {
          unint64_t v139 = v391;
          uint64_t v64 = v387;
          unint64_t v72 = (Swift::UInt64 *)v381;
        }

        swift_bridgeObjectRelease(v391);
        swift_bridgeObjectRelease(v89);
        unint64_t v152 = 0xA000000000000000LL;
        if (!(v81 & 0x8080808080808080LL | v139 & 0x80808080808080LL)) {
          unint64_t v152 = 0xE000000000000000LL;
        }
        unint64_t v390 = v81;
        unint64_t v391 = v152 & 0xFF00000000000000LL | (v101 << 56) | v139 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v71 = (char *)v380;
        goto LABEL_27;
      }

      Swift::Int v99 = 1LL;
    }

    uint64_t v62 = v88 & 0xFFFFFFFFFFFFLL;
    uint64_t v79 = v99 ? HIBYTE(v89) & 0xF : v88 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v89, 2LL, v94, v95);
    if ((v89 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v89, 4LL, v102, v103);
    uint64_t v106 = v79;
    if ((v96 & 0x1000000000000000LL) != 0) {
      goto LABEL_94;
    }
LABEL_55:
    BOOL v107 = __OFADD__(v98, v106);
    int64_t v108 = v98 + v106;
    if (v107) {
      goto LABEL_327;
    }
LABEL_56:
    if ((v81 & ~v96 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v96 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v109 = v391;
      int64_t v110 = _StringGuts.nativeUnusedCapacity.getter(v390, v391);
      if ((v111 & 1) != 0) {
        goto LABEL_350;
      }
      if (v108 >= 16 || (v109 & 0x2000000000000000LL) == 0 && v110 >= v106)
      {
LABEL_64:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v108, v106);
        swift_bridgeObjectRelease_n(v89, 4LL);
        if ((v89 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v89);
          _StringGuts._foreignAppendInPlace(_:)(v88, v89, 0LL, v79);
          swift_bridgeObjectRelease_n(v89, 2LL);
        }

        else
        {
          if (!v99)
          {
            if ((v88 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v89);
              id v148 = (id)((v89 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v149 = v88 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v148 = _StringObject.sharedUTF8.getter(v88, v89);
              uint64_t v149 = v158;
              swift_bridgeObjectRelease(v89);
              if (v149 < v62) {
                goto LABEL_98;
              }
            }

            uint64_t v64 = v387;
            unint64_t v71 = (char *)v380;
            unint64_t v72 = (Swift::UInt64 *)v381;
            unint64_t v150 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v88 & 0xFFFFFFFFFFFFLL,  (uint64_t)v148,  v149);
            _StringGuts.appendInPlace(_:isASCII:)(v150, v151, v88 < 0);
            swift_bridgeObjectRelease_n(v89, 2LL);
            uint64_t v69 = v385;
            unint64_t v68 = v386;
            goto LABEL_27;
          }

          swift_bridgeObjectRelease_n(v89, 2LL);
          uint64_t v388 = v88;
          uint64_t v389 = v89 & 0xFFFFFFFFFFFFFFLL;
          int64_t v112 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v89) & 0xF,  (uint64_t)&v388,  HIBYTE(v89) & 0xF);
          _StringGuts.appendInPlace(_:isASCII:)(v112, v113, (v89 & 0x4000000000000000LL) != 0);
          swift_bridgeObjectRelease(v89);
        }

        uint64_t v69 = v385;
        unint64_t v68 = v386;
        uint64_t v64 = v387;
        unint64_t v71 = (char *)v380;
        unint64_t v72 = (Swift::UInt64 *)v381;
        goto LABEL_27;
      }
    }

    else
    {
      if (v108 > 15) {
        goto LABEL_64;
      }
      uint64_t v109 = v391;
    }

    swift_bridgeObjectRelease_n(v89, 5LL);
    unint64_t v114 = v390;
    swift_bridgeObjectRetain(v109, v115, v116, v117);
    unint64_t v118 = _StringGuts._convertedToSmall()(v114, v109);
    unint64_t v120 = v119;
    swift_bridgeObjectRelease(v109);
    v121._Swift::UInt64 rawBits = (v79 << 16) | 1;
    v122._Swift::UInt64 rawBits = 1LL;
    v123._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v122, v121, v88, v89);
    if (v123._rawBits < 0x10000) {
      v123._rawBits |= 3;
    }
    unint64_t v125 = specialized String.init(_:)(v123, v124, v88, v89);
    unint64_t v127 = v126;
    swift_bridgeObjectRelease(v89);
    unint64_t v128 = _StringGuts._convertedToSmall()(v125, v127);
    unint64_t v130 = v129;
    swift_bridgeObjectRelease(v127);
    unint64_t v131 = specialized _SmallString.init(_:appending:)(v118, v120, v128, v130);
    uint64_t v69 = v385;
    unint64_t v68 = v386;
    uint64_t v64 = v387;
    unint64_t v72 = (Swift::UInt64 *)v381;
    if ((v133 & 1) != 0) {
      goto LABEL_349;
    }
    uint64_t v134 = v131;
    unint64_t v135 = v132;
    swift_bridgeObjectRelease(v109);
    swift_bridgeObjectRelease(v89);
    unint64_t v390 = v134;
    unint64_t v391 = v135;
    unint64_t v71 = (char *)v380;
LABEL_27:
    uint64_t v85 = v383;
    ((void (*)(uint64_t, char *))v379)(v64, v382);
    ((void (*)(Swift::UInt64 *, void (*)(uint64_t), ValueMetadata *))v377)(v72, v85, v68);
  }

  swift_bridgeObjectRetain_n(v89, 5LL, v102, v103);
  v153._Swift::UInt64 rawBits = 1LL;
  v154._Swift::UInt64 rawBits = (v79 << 16) | 1;
  v155._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v153, v154, v88, v89);
  if (v155._rawBits < 0x10000) {
    v155._rawBits |= 3;
  }
  uint64_t v106 = specialized Collection.count.getter(v155, v156, v88, v89);
  swift_bridgeObjectRelease(v89);
  if ((v96 & 0x1000000000000000LL) == 0) {
    goto LABEL_55;
  }
LABEL_94:
  Swift::Int v157 = String.UTF8View._foreignCount()();
  int64_t v108 = v157 + v106;
  if (!__OFADD__(v157, v106)) {
    goto LABEL_56;
  }
LABEL_327:
  __break(1u);
LABEL_328:
  __break(1u);
LABEL_329:
  __break(1u);
LABEL_330:
  swift_bridgeObjectRetain_n(v81, 5LL, v104, v105);
  v349._Swift::UInt64 rawBits = 1LL;
  v350._Swift::UInt64 rawBits = (v99 << 16) | 1;
  v351._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v349, v350, v79, v81);
  if (v351._rawBits < 0x10000) {
    v351._rawBits |= 3;
  }
  Swift::Int v173 = specialized Collection.count.getter(v351, v352, v79, v81);
  swift_bridgeObjectRelease(v81);
LABEL_116:
  Swift::Int v367 = v99;
  if ((v106 & 0x1000000000000000LL) != 0)
  {
    uint64_t v88 = String.UTF8View._foreignCount()();
    Swift::Int v174 = v88 + v173;
    if (!__OFADD__(v88, v173)) {
      goto LABEL_118;
    }
    goto LABEL_335;
  }

  Swift::Int v174 = v88 + v173;
  if (__OFADD__(v88, v173))
  {
LABEL_335:
    __break(1u);
    goto LABEL_336;
  }

LABEL_349:
      unint64_t v359 = 266LL;
LABEL_351:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v359,  0);
    }

                v269((uint64_t)v268, 3LL, 0LL);
                goto LABEL_350;
              }

              swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v18 + *v18, a2);
              unint64_t v120 = (int)v119;
              Swift::String::Index v121 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v18 + *v18, v119);
              swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v66 + *v66, v122);
              Swift::String::Index v124 = (int)v123;
              unint64_t v125 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v66 + *v66, v123);
              unint64_t v126 = operator new(0x28uLL);
              *(void *)unint64_t v126 = "subject type %.*s does not match %.*s";
              v126[2] = v120;
              *((void *)v126 + 2) = v121;
              v126[6] = v124;
              *((void *)v126 + 4) = v125;
              unint64_t v118 = 1;
              *(void *)a9 = v126;
              *(void *)(a9 + 8) = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*>(char const*,int,char const*,int,char const*)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*>(char const*,int,char const*,int,char const*)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
              goto LABEL_219;
            case 2:
              unint64_t v237 = a6;
              unint64_t v72 = (int *)(v13 + 8);
              unint64_t v73 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef( (_BYTE *)(*(int *)(v13 + 8) + v13 + 8),  a2);
              uint64_t v75 = v74;
              unint64_t v76 = *(void *)a5;
              if (v248)
              {
                if (v248 != v247)
                {
                  size_t v267 = (uint64_t *)(*(uint64_t (**)(void))(*v248 + 16LL))();
                  uint64_t v77 = v246;
                  if (v246) {
                    goto LABEL_122;
                  }
LABEL_180:
                  unint64_t v263 = 0LL;
                  goto LABEL_224;
                }

                size_t v267 = &v264;
                (*(void (**)(void *, uint64_t *))(v247[0] + 24LL))(v247, &v264);
                uint64_t v77 = v246;
                if (!v246) {
                  goto LABEL_180;
                }
              }

              else
              {
                size_t v267 = 0LL;
                uint64_t v77 = v246;
                if (!v246) {
                  goto LABEL_180;
                }
              }

LABEL_347:
  id v201 = _StringObject.sharedUTF8.getter(v79, v81);
  uint64_t v203 = v358;
  swift_bridgeObjectRelease(v81);
  if (v203 < (uint64_t)v366) {
LABEL_98:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  uint64_t v62 = (uint64_t)v386;
  uint64_t v59 = v387;
  unint64_t v89 = (unint64_t)v378;
  unint64_t v186 = v382;
  uint64_t v202 = (uint64_t)v366;
LABEL_167:
  int64_t v204 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v202, (uint64_t)v201, v203);
  _StringGuts.appendInPlace(_:isASCII:)(v204, v205, v79 < 0);
  swift_bridgeObjectRelease_n(v81, 2LL);
LABEL_192:
  uint64_t v228 = v379;
  ((void (*)(uint64_t, char *))v383)(v59, v384);
  if (v381(v228, 1LL, (ValueMetadata *)v62) != 1)
  {
    v366 = (Swift::UInt64 *)(v377 & 0xFFFFFFFFFFFFFFLL);
    unint64_t v364 = (v377 & 0xFFFFFFFFFFFFFFFLL) + 32;
    Swift::Int v367 = 8 * v371;
    while (1)
    {
      Swift::Int v99 = (Swift::Int)v375;
      v380((Swift::Int)v375, v228, v62);
      uint64_t v96 = v390;
      unint64_t v81 = v391;
      unint64_t v230 = HIBYTE(v391) & 0xF;
      if ((v391 & 0x2000000000000000LL) != 0) {
        unint64_t v231 = HIBYTE(v391) & 0xF;
      }
      else {
        unint64_t v231 = v390 & 0xFFFFFFFFFFFFLL;
      }
      if (!v231 && (v390 & ~v391 & 0x2000000000000000LL) == 0)
      {
        unint64_t v268 = v377;
        swift_bridgeObjectRetain(v377, v229, v104, v105);
        swift_bridgeObjectRelease(v81);
        unint64_t v390 = v376;
        unint64_t v391 = v268;
        goto LABEL_233;
      }

      uint64_t v232 = v376;
      uint64_t v88 = v377;
      if ((v391 & 0x2000000000000000LL) != 0) {
        break;
      }
      uint64_t v79 = v374;
      if ((v377 & 0x2000000000000000LL) != 0) {
        goto LABEL_209;
      }
LABEL_210:
      int64_t v108 = v79;
      if ((v377 & 0x1000000000000000LL) != 0)
      {
        v337._Swift::UInt64 rawBits = (v79 << 16) | 1;
        v338._Swift::UInt64 rawBits = 1LL;
        v339._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v338, v337, v376, v377);
        if (v339._rawBits < 0x10000) {
          v339._rawBits |= 3;
        }
        int64_t v108 = specialized Collection.count.getter(v339, v340, v232, v88);
        if ((v81 & 0x1000000000000000LL) != 0)
        {
LABEL_314:
          Swift::Int v341 = String.UTF8View._foreignCount()();
          uint64_t v106 = v341 + v108;
          if (__OFADD__(v341, v108)) {
            goto LABEL_328;
          }
          goto LABEL_213;
        }
      }

      else if ((v391 & 0x1000000000000000LL) != 0)
      {
        goto LABEL_314;
      }

      BOOL v107 = __OFADD__(v231, v108);
      uint64_t v106 = v231 + v108;
      if (v107) {
        goto LABEL_328;
      }
LABEL_213:
      if ((v96 & ~v81 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v81 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v234 = _StringGuts.nativeUnusedCapacity.getter(v96, v81);
        if ((v229 & 1) != 0) {
          goto LABEL_350;
        }
        uint64_t v235 = (v81 >> 61) & 1;
        if (v234 < v108) {
          LOBYTE(v235) = 1;
        }
        if (v106 <= 15 && (v235 & 1) != 0)
        {
LABEL_220:
          swift_bridgeObjectRetain(v81, v229, v104, v105);
          unint64_t v236 = _StringGuts._convertedToSmall()(v96, v81);
          unint64_t v238 = v237;
          swift_bridgeObjectRelease(v81);
          v239._Swift::UInt64 rawBits = (v79 << 16) | 1;
          v240._Swift::UInt64 rawBits = 1LL;
          Swift::UInt64 v241 = _StringGuts.validateScalarRange(_:)(v240, v239, v232, v88);
          Swift::UInt64 v245 = v242;
          if (v241 >= 0x10000) {
            Swift::UInt64 v246 = v241;
          }
          else {
            Swift::UInt64 v246 = v241 | 3;
          }
          swift_bridgeObjectRetain(v88, v242, v243, v244);
          v247._Swift::UInt64 rawBits = v246;
          v248._Swift::UInt64 rawBits = v245;
          unint64_t v249 = specialized String.init(_:)(v247, v248, v232, v88);
          unint64_t v251 = v250;
          swift_bridgeObjectRelease(v88);
          unint64_t v252 = _StringGuts._convertedToSmall()(v249, v251);
          unint64_t v254 = v253;
          swift_bridgeObjectRelease(v251);
          unint64_t v255 = specialized _SmallString.init(_:appending:)(v236, v238, v252, v254);
          if ((v257 & 1) != 0) {
            goto LABEL_349;
          }
          uint64_t v258 = v255;
          unint64_t v259 = v256;
          swift_bridgeObjectRelease(v81);
          unint64_t v390 = v258;
          unint64_t v391 = v259;
          goto LABEL_233;
        }
      }

      else if (v106 <= 15)
      {
        goto LABEL_220;
      }

      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v106, v108);
      if ((v88 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignAppendInPlace(_:)(v232, v88, 0LL, v79);
LABEL_233:
        unint64_t v263 = (void (*)(unint64_t, uint64_t))v373;
        goto LABEL_234;
      }

      unint64_t v263 = (void (*)(unint64_t, uint64_t))v373;
      if ((v88 & 0x2000000000000000LL) != 0)
      {
        uint64_t v388 = v232;
        uint64_t v389 = (uint64_t)v366;
        if (v371 < v79) {
          goto LABEL_98;
        }
        v329 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v79, (uint64_t)&v388, v371);
        _StringGuts.appendInPlace(_:isASCII:)(v329, v330, (v88 & 0x4000000000000000LL) != 0);
      }

      else
      {
        uint64_t v264 = v364;
        uint64_t v265 = v374;
        if ((v232 & 0x1000000000000000LL) != 0)
        {
          if (v374 < v79) {
            goto LABEL_98;
          }
        }

        else
        {
          uint64_t v264 = (uint64_t)_StringObject.sharedUTF8.getter(v232, v88);
          uint64_t v265 = v347;
          if (v347 < v79) {
            goto LABEL_98;
          }
        }

        uint64_t v266 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v79, v264, v265);
        _StringGuts.appendInPlace(_:isASCII:)(v266, v267, v232 < 0);
      }

LABEL_234:
      if ((ValueMetadata *)v62 == &type metadata for String)
      {
        uint64_t v79 = *(void *)v99;
        unint64_t v81 = *(void *)(v99 + 8);
LABEL_243:
        swift_bridgeObjectRetain(v81, v260._rawBits, v261, v262);
        goto LABEL_246;
      }

      if ((ValueMetadata *)v62 != &type metadata for Substring)
      {
        unint64_t v269 = *(void (**)(unint64_t, Swift::Int, uint64_t))(v385 + 16);
        v269(v89, v99, v62);
        Swift::String::Index v270 = v370;
        v269((unint64_t)v370, v89, v62);
        if ((swift_dynamicCast((char *)&v388, v270, (swift *)v62, (const char *)&type metadata for String, 6uLL) & 1) != 0)
        {
          v263(v89, v62);
          uint64_t v79 = v388;
          unint64_t v81 = v389;
        }

        else
        {
          uint64_t v79 = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v372 + 40) + 8LL) + 8LL))(v62);
          unint64_t v81 = v273;
          v263(v89, v62);
        }

        goto LABEL_246;
      }

      v271._Swift::UInt64 rawBits = *(void *)v99;
      v260._Swift::UInt64 rawBits = *(void *)(v99 + 8);
      uint64_t v79 = *(void *)(v99 + 16);
      unint64_t v81 = *(void *)(v99 + 24);
      uint64_t v272 = HIBYTE(v81) & 0xF;
      if ((v81 & 0x2000000000000000LL) == 0) {
        uint64_t v272 = v79 & 0xFFFFFFFFFFFFLL;
      }
      if (!(v271._rawBits >> 16) && v260._rawBits >> 16 == v272) {
        goto LABEL_243;
      }
      uint64_t v79 = specialized static String._copying(_:)(v271, v260, *(void *)(v99 + 16), *(void *)(v99 + 24));
      unint64_t v81 = v274;
LABEL_246:
      v263(v99, v62);
      uint64_t v96 = v390;
      uint64_t v106 = v391;
      unint64_t v277 = HIBYTE(v391) & 0xF;
      if ((v391 & 0x2000000000000000LL) != 0) {
        unint64_t v278 = HIBYTE(v391) & 0xF;
      }
      else {
        unint64_t v278 = v390 & 0xFFFFFFFFFFFFLL;
      }
      if (!v278 && (v390 & ~v391 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v391);
        unint64_t v390 = v79;
        unint64_t v391 = v81;
        uint64_t v59 = v387;
        goto LABEL_197;
      }

      Swift::Int v99 = v81 & 0x2000000000000000LL;
      uint64_t v88 = HIBYTE(v81) & 0xF;
      if ((v391 & 0x2000000000000000LL) != 0 && v99)
      {
        unint64_t v279 = v277 + v88;
        if (v277 + v88 <= 0xF)
        {
          uint64_t v59 = v387;
          if (v88)
          {
            uint64_t v319 = 0LL;
            unint64_t v320 = 0LL;
            unint64_t v321 = v391;
            do
            {
              unint64_t v322 = v277 + v320;
              BOOL v141 = v320++ >= 8;
              if (v141) {
                unint64_t v323 = v81;
              }
              else {
                unint64_t v323 = v79;
              }
              char v324 = (8 * v277 + v319) & 0x38;
              uint64_t v325 = (-255LL << v324) - 1;
              unint64_t v326 = (unint64_t)(v323 >> (v319 & 0x38)) << v324;
              unint64_t v327 = v326 | v325 & v321;
              unint64_t v328 = v326 | v325 & v96;
              if (v322 < 8) {
                uint64_t v96 = v328;
              }
              else {
                unint64_t v321 = v327;
              }
              v319 += 8LL;
            }

            while (8 * v88 != v319);
          }

          else
          {
            unint64_t v321 = v391;
          }

          swift_bridgeObjectRelease(v391);
          swift_bridgeObjectRelease(v81);
          unint64_t v336 = 0xA000000000000000LL;
          if (!(v96 & 0x8080808080808080LL | v321 & 0x80808080808080LL)) {
            unint64_t v336 = 0xE000000000000000LL;
          }
          unint64_t v390 = v96;
          unint64_t v391 = v336 & 0xFF00000000000000LL | (v279 << 56) | v321 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_197;
        }

        Swift::Int v99 = 1LL;
      }

      if (v99) {
        uint64_t v62 = HIBYTE(v81) & 0xF;
      }
      else {
        uint64_t v62 = v79 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v81, 2LL, v275, v276);
      if ((v81 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v81, 5LL, v280, v281);
        v342._Swift::UInt64 rawBits = 1LL;
        v343._Swift::UInt64 rawBits = (v62 << 16) | 1;
        v344._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v342, v343, v79, v81);
        if (v344._rawBits < 0x10000) {
          v344._rawBits |= 3;
        }
        unint64_t v89 = specialized Collection.count.getter(v344, v345, v79, v81);
        swift_bridgeObjectRelease(v81);
        if ((v106 & 0x1000000000000000LL) == 0)
        {
LABEL_260:
          BOOL v107 = __OFADD__(v278, v89);
          int64_t v108 = v278 + v89;
          if (v107) {
            goto LABEL_329;
          }
          goto LABEL_261;
        }
      }

      else
      {
        swift_bridgeObjectRetain_n(v81, 4LL, v280, v281);
        unint64_t v89 = v62;
        if ((v106 & 0x1000000000000000LL) == 0) {
          goto LABEL_260;
        }
      }

      Swift::Int v346 = String.UTF8View._foreignCount()();
      int64_t v108 = v346 + v89;
      if (__OFADD__(v346, v89)) {
        goto LABEL_329;
      }
LABEL_261:
      if ((v96 & ~v106 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v106 & 0xFFFFFFFFFFFFFFFLL))
      {
        uint64_t v282 = v391;
        int64_t v283 = _StringGuts.nativeUnusedCapacity.getter(v390, v391);
        if ((v284 & 1) != 0) {
          goto LABEL_350;
        }
      }

      else if (v108 <= 15)
      {
        uint64_t v282 = v391;
LABEL_273:
        swift_bridgeObjectRelease_n(v81, 5LL);
        unint64_t v287 = v390;
        swift_bridgeObjectRetain(v282, v288, v289, v290);
        unint64_t v291 = _StringGuts._convertedToSmall()(v287, v282);
        unint64_t v293 = v292;
        swift_bridgeObjectRelease(v282);
        v294._Swift::UInt64 rawBits = (v62 << 16) | 1;
        v295._Swift::UInt64 rawBits = 1LL;
        v296._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v295, v294, v79, v81);
        if (v296._rawBits < 0x10000) {
          v296._rawBits |= 3;
        }
        unint64_t v298 = specialized String.init(_:)(v296, v297, v79, v81);
        unint64_t v300 = v299;
        swift_bridgeObjectRelease(v81);
        unint64_t v301 = _StringGuts._convertedToSmall()(v298, v300);
        unint64_t v303 = v302;
        swift_bridgeObjectRelease(v300);
        unint64_t v304 = specialized _SmallString.init(_:appending:)(v291, v293, v301, v303);
        uint64_t v59 = v387;
        unint64_t v89 = (unint64_t)v378;
        if ((v306 & 1) != 0) {
          goto LABEL_349;
        }
        uint64_t v307 = v304;
        unint64_t v308 = v305;
        swift_bridgeObjectRelease(v282);
        swift_bridgeObjectRelease(v81);
        unint64_t v390 = v307;
        unint64_t v391 = v308;
        uint64_t v62 = (uint64_t)v386;
LABEL_197:
        unint64_t v186 = v382;
        goto LABEL_198;
      }

      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v108, v89);
      swift_bridgeObjectRelease_n(v81, 4LL);
      if ((v81 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v81);
        _StringGuts._foreignAppendInPlace(_:)(v79, v81, 0LL, v62);
        swift_bridgeObjectRelease_n(v81, 2LL);
        uint64_t v62 = (uint64_t)v386;
        uint64_t v59 = v387;
        unint64_t v89 = (unint64_t)v378;
        goto LABEL_197;
      }

      unint64_t v89 = (unint64_t)v378;
      unint64_t v186 = v382;
      if (v99)
      {
        swift_bridgeObjectRelease_n(v81, 2LL);
        uint64_t v388 = v79;
        uint64_t v389 = v81 & 0xFFFFFFFFFFFFFFLL;
        Swift::String::Index v285 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v81) & 0xF,  (uint64_t)&v388,  HIBYTE(v81) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v285, v286, (v81 & 0x4000000000000000LL) != 0);
        swift_bridgeObjectRelease(v81);
        uint64_t v62 = (uint64_t)v386;
        uint64_t v59 = v387;
      }

      else
      {
        if ((v79 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v81);
          id v331 = (id)((v81 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v332 = v79 & 0xFFFFFFFFFFFFLL;
          uint64_t v62 = (uint64_t)v386;
          uint64_t v59 = v387;
        }

        else
        {
          id v331 = _StringObject.sharedUTF8.getter(v79, v81);
          uint64_t v332 = v348;
          swift_bridgeObjectRelease(v81);
          if (v332 < (v79 & 0xFFFFFFFFFFFFLL)) {
            goto LABEL_98;
          }
          uint64_t v62 = (uint64_t)v386;
          uint64_t v59 = v387;
          unint64_t v89 = (unint64_t)v378;
          unint64_t v186 = v382;
        }

        v333 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v79 & 0xFFFFFFFFFFFFLL, (uint64_t)v331, v332);
        _StringGuts.appendInPlace(_:isASCII:)(v333, v334, v79 < 0);
        swift_bridgeObjectRelease_n(v81, 2LL);
      }

          uint64_t result = 0LL;
          goto LABEL_229;
        }

        uint64_t v8 = 1;
        unint64_t v65 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
        uint64_t v69 = specialized UnsafeBufferPointer.init(rebasing:)(v65, v66, v67, v68);
        if (v70)
        {
          unint64_t v71 = (unsigned __int8 *)v69;
          unint64_t v72 = a3 + 55;
          unint64_t v73 = a3 + 87;
          if (a3 > 10)
          {
            uint64_t v74 = 58;
          }

          else
          {
            unint64_t v73 = 97;
            unint64_t v72 = 65;
            uint64_t v74 = a3 + 48;
          }

          if (v69)
          {
            uint64_t v75 = v70;
            uint64_t v20 = 0LL;
            unint64_t v76 = 0LL;
            uint64_t v77 = a3 >> 63;
            while (1)
            {
              unint64_t v78 = *v71;
              if (v78 < 0x30 || v78 >= v74)
              {
                if (v78 < 0x41 || v78 >= v72)
                {
                  uint64_t result = 0LL;
                  uint64_t v8 = 1;
                  if (v78 < 0x61 || v78 >= v73) {
                    goto LABEL_229;
                  }
                  uint64_t v79 = -87;
                }

                else
                {
                  uint64_t v79 = -55;
                }
              }

              else
              {
                uint64_t v79 = -48;
              }

              uint64_t result = 0LL;
              unint64_t v80 = v78 + v79;
              if (v76) {
                unint64_t v81 = a3 >= 0;
              }
              else {
                unint64_t v81 = 1;
              }
              char v84 = !v81
                 || (v76 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
                 || ((unint64_t)v77 * (unsigned __int128)v20) >> 64 != 0;
              uint64_t v85 = v77 * v20 + v76 * a3;
              unint64_t v86 = (v20 * (unsigned __int128)(unint64_t)a3) >> 64;
              uint64_t v33 = __CFADD__(v86, v85);
              unint64_t v87 = v86 + v85;
              if (v33) {
                char v84 = 1;
              }
              uint64_t v88 = v20 * a3;
              uint64_t v33 = __CFADD__(v88, v80);
              uint64_t v20 = v88 + v80;
              unint64_t v89 = v33;
              uint64_t v33 = __CFADD__(v33, v87);
              unint64_t v76 = v89 + v87;
              Swift::String::Index v90 = v33;
              uint64_t v8 = 1;
              if ((v84 & 1) != 0 || v90) {
                goto LABEL_229;
              }
              ++v71;
              if (!--v75) {
                goto LABEL_192;
              }
            }
          }

          goto LABEL_193;
        }

uint64_t StringProtocol._ephemeralString.getter(swift *a1, uint64_t a2)
{
  uint64_t v5 = *((void *)a1 - 1);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (uint64_t *)((char *)&v24 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  char v9 = (ValueMetadata *)MEMORY[0x1895F8858](v6);
  uint64_t v14 = (char *)&v24 - v13;
  if (v9 == &type metadata for String)
  {
    uint64_t v16 = *v2;
    swift_bridgeObjectRetain(v2[1], v10, v11, v12);
  }

  else if (a1 == (swift *)&type metadata for Substring)
  {
    Swift::UInt64 v17 = *v2;
    Swift::UInt64 v18 = v2[1];
    unint64_t v20 = v2[2];
    unint64_t v19 = v2[3];
    swift_bridgeObjectRetain(v19, v10, v11, v12);
    v21._Swift::UInt64 rawBits = v17;
    v22._Swift::UInt64 rawBits = v18;
    return specialized String.init<A>(_:)(v21, v22, v20, v19);
  }

  else
  {
    uint64_t v15 = *(void (**)(char *, uint64_t *, swift *))(v5 + 16);
    v15((char *)&v24 - v13, v2, a1);
    v15((char *)v8, (uint64_t *)v14, a1);
    if (swift_dynamicCast((char *)&v24, v8, a1, (const char *)&type metadata for String, 6uLL))
    {
      (*(void (**)(char *, swift *))(v5 + 8))(v14, a1);
      return v24;
    }

    else
    {
      uint64_t v16 = (*(uint64_t (**)(swift *))(*(void *)(*(void *)(a2 + 40) + 8LL) + 8LL))(a1);
      (*(void (**)(char *, swift *))(v5 + 8))(v14, a1);
    }
  }

  return v16;
}

unint64_t specialized BidirectionalCollection<>.joined(separator:)( uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = a2;
  unint64_t v275 = HIBYTE(a2) & 0xF;
  uint64_t v278 = a1 & 0xFFFFFFFFFFFFLL;
  uint64_t v279 = a1;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v4 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v5 = a3[2] + a3[2] * v4;
  unint64_t v6 = 0xE000000000000000LL;
  unint64_t v286 = 0LL;
  unint64_t v287 = 0xE000000000000000LL;
  if (v5 < 16)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    uint64_t v7 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v8 & 1) != 0 || v7 < v5)
    {
      uint64_t v11 = 2 * _StringGuts.uniqueNativeCapacity.getter();
      if (v11 <= v5) {
        uint64_t v11 = v5;
      }
      if ((v10 & 1) != 0) {
        int64_t v12 = v5;
      }
      else {
        int64_t v12 = v11;
      }
      uint64_t v284 = 0LL;
      uint64_t v285 = 0LL;
      unint64_t v6 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v284,  0LL,  v12,  1);
      uint64_t v9 = *(void *)(v6 + 24);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v286 = v9;
      unint64_t v287 = v6;
    }

    else
    {
      uint64_t v9 = 0LL;
      unint64_t v6 = 0xE000000000000000LL;
    }
  }

  unint64_t v13 = a3[2];
  unint64_t v282 = v13;
  uint64_t v14 = v279;
  if (v4)
  {
    if (!v13) {
      return v286;
    }
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(0LL, 1, (uint64_t)a3);
    uint64_t v18 = a3[4];
    uint64_t v276 = v3;
    unint64_t v277 = a3 + 4;
    unint64_t v19 = a3[5];
    uint64_t v20 = HIBYTE(v6) & 0xF;
    uint64_t v21 = v9 & 0xFFFFFFFFFFFFLL;
    if ((v6 & 0x2000000000000000LL) != 0) {
      uint64_t v22 = HIBYTE(v6) & 0xF;
    }
    else {
      uint64_t v22 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (!v22 && (v9 & ~v6 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain(a3[5], v15, v16, v17);
      swift_bridgeObjectRelease(v6);
      unint64_t v286 = v18;
      unint64_t v287 = v19;
      unint64_t v24 = v282;
      if (v282 != 1) {
        goto LABEL_167;
      }
      return v286;
    }

    uint64_t v14 = v19 & 0x2000000000000000LL;
    uint64_t v3 = HIBYTE(v19) & 0xF;
    if ((v6 & 0x2000000000000000LL) == 0 || !v14)
    {
LABEL_26:
      uint64_t v274 = v18 & 0xFFFFFFFFFFFFLL;
      if (v14) {
        unint64_t v24 = HIBYTE(v19) & 0xF;
      }
      else {
        unint64_t v24 = v18 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(v19, 3LL, v16, v17);
      if ((v19 & 0x1000000000000000LL) != 0) {
        goto LABEL_291;
      }
      swift_bridgeObjectRetain_n(v19, 4LL, v25, v26);
      Swift::Int v27 = v24;
      if ((v6 & 0x1000000000000000LL) != 0) {
        goto LABEL_294;
      }
      goto LABEL_31;
    }

    uint64_t v23 = v20 + v3;
    if ((unint64_t)(v20 + v3) > 0xF)
    {
      uint64_t v14 = 1LL;
      goto LABEL_26;
    }

    if (v3)
    {
      uint64_t v125 = 0LL;
      unint64_t v126 = 0LL;
      uint64_t v127 = 8 * v3;
      unint64_t v128 = v6;
      unint64_t v24 = v282;
      uint64_t v3 = v276;
      do
      {
        unint64_t v129 = v20 + v126;
        BOOL v77 = v126++ >= 8;
        if (v77) {
          unint64_t v130 = a3[5];
        }
        else {
          unint64_t v130 = a3[4];
        }
        char v131 = (8 * v20 + v125) & 0x38;
        uint64_t v132 = (-255LL << v131) - 1;
        unint64_t v133 = (unint64_t)(v130 >> (v125 & 0x38)) << v131;
        unint64_t v134 = v133 | v132 & v128;
        unint64_t v135 = v133 | v132 & v9;
        if (v129 < 8) {
          uint64_t v9 = v135;
        }
        else {
          unint64_t v128 = v134;
        }
        v125 += 8LL;
      }

      while (v127 != v125);
    }

    else
    {
      unint64_t v128 = v6;
      unint64_t v24 = v282;
      uint64_t v3 = v276;
    }

    swift_bridgeObjectRelease(v6);
    unint64_t v141 = 0xA000000000000000LL;
    if (!(v9 & 0x8080808080808080LL | v128 & 0x80808080808080LL)) {
      unint64_t v141 = 0xE000000000000000LL;
    }
    unint64_t v286 = v9;
    unint64_t v287 = v141 & 0xFF00000000000000LL | (v23 << 56) | v128 & 0xFFFFFFFFFFFFFFLL;
LABEL_165:
    uint64_t v14 = v279;
    if (v24 != 1) {
      goto LABEL_167;
    }
    return v286;
  }

  if (!v13) {
    return v286;
  }
  uint64_t v14 = 0LL;
  while (1)
  {
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v14, 1, (uint64_t)a3);
    uint64_t v39 = &a3[2 * v14 + 4];
    uint64_t v22 = *v39;
    unint64_t v24 = v39[1];
    unint64_t v19 = v286;
    unint64_t v6 = v287;
    unint64_t v40 = HIBYTE(v287) & 0xF;
    if ((v287 & 0x2000000000000000LL) != 0) {
      unint64_t v41 = HIBYTE(v287) & 0xF;
    }
    else {
      unint64_t v41 = v286 & 0xFFFFFFFFFFFFLL;
    }
    if (!v41 && (v286 & ~v287 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain(v24, v36, v37, v38);
      swift_bridgeObjectRelease(v6);
      unint64_t v286 = v22;
      unint64_t v287 = v24;
      goto LABEL_52;
    }

    uint64_t v18 = v24 & 0x2000000000000000LL;
    uint64_t v9 = HIBYTE(v24) & 0xF;
    if ((v287 & 0x2000000000000000LL) != 0 && v18)
    {
      unint64_t v42 = v40 + v9;
      if (v40 + v9 <= 0xF)
      {
        if (v9)
        {
          uint64_t v72 = 0LL;
          unint64_t v73 = 0LL;
          uint64_t v74 = 8 * v9;
          unint64_t v75 = v287;
          do
          {
            unint64_t v76 = v40 + v73;
            BOOL v77 = v73++ >= 8;
            if (v77) {
              unint64_t v78 = v24;
            }
            else {
              unint64_t v78 = v22;
            }
            char v79 = (8 * v40 + v72) & 0x38;
            uint64_t v80 = (-255LL << v79) - 1;
            unint64_t v81 = (unint64_t)(v78 >> (v72 & 0x38)) << v79;
            unint64_t v82 = v81 | v80 & v75;
            unint64_t v83 = v81 | v80 & v19;
            if (v76 < 8) {
              unint64_t v19 = v83;
            }
            else {
              unint64_t v75 = v82;
            }
            v72 += 8LL;
          }

          while (v74 != v72);
        }

        else
        {
          unint64_t v75 = v287;
        }

        swift_bridgeObjectRelease(v287);
        unint64_t v89 = 0xA000000000000000LL;
        if (!(v19 & 0x8080808080808080LL | v75 & 0x80808080808080LL)) {
          unint64_t v89 = 0xE000000000000000LL;
        }
        unint64_t v286 = v19;
        unint64_t v287 = v89 & 0xFF00000000000000LL | (v42 << 56) | v75 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_52;
      }

      uint64_t v18 = 1LL;
    }

    uint64_t v279 = v22 & 0xFFFFFFFFFFFFLL;
    uint64_t v21 = v18 ? HIBYTE(v24) & 0xF : v22 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v24, 3LL, v37, v38);
    if ((v24 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v24, 4LL, v43, v44);
    Swift::Int v45 = v21;
    if ((v6 & 0x1000000000000000LL) != 0) {
      goto LABEL_104;
    }
LABEL_67:
    BOOL v28 = __OFADD__(v41, v45);
    uint64_t v3 = v41 + v45;
    if (v28) {
      goto LABEL_288;
    }
LABEL_68:
    if ((v19 & ~v6 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v46 = _StringGuts.nativeUnusedCapacity.getter(v19, v6);
      if ((v47 & 1) != 0) {
        goto LABEL_310;
      }
      uint64_t v48 = (v6 >> 61) & 1;
      if (v46 < v45) {
        LOBYTE(v48) = 1;
      }
      if (v3 <= 15 && (v48 & 1) != 0)
      {
LABEL_75:
        swift_bridgeObjectRelease_n(v24, 5LL);
        swift_bridgeObjectRetain(v6, v49, v50, v51);
        unint64_t v52 = _StringGuts._convertedToSmall()(v19, v6);
        unint64_t v54 = v53;
        swift_bridgeObjectRelease(v6);
        v55._Swift::UInt64 rawBits = (v21 << 16) | 1;
        v56._Swift::UInt64 rawBits = 1LL;
        v57._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v56, v55, v22, v24);
        if (v57._rawBits < 0x10000) {
          v57._rawBits |= 3;
        }
        unint64_t v59 = specialized String.init(_:)(v57, v58, v22, v24);
        unint64_t v61 = v60;
        swift_bridgeObjectRelease(v24);
        unint64_t v62 = _StringGuts._convertedToSmall()(v59, v61);
        unint64_t v64 = v63;
        swift_bridgeObjectRelease(v61);
        unint64_t v65 = specialized _SmallString.init(_:appending:)(v52, v54, v62, v64);
        if ((v67 & 1) != 0) {
          goto LABEL_309;
        }
        unint64_t v68 = v65;
        unint64_t v69 = v66;
        swift_bridgeObjectRelease(v6);
        swift_bridgeObjectRelease(v24);
        unint64_t v286 = v68;
        unint64_t v287 = v69;
        goto LABEL_51;
      }
    }

    else if (v3 <= 15)
    {
      goto LABEL_75;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v3, v45);
    swift_bridgeObjectRelease_n(v24, 4LL);
    if ((v24 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v24);
      _StringGuts._foreignAppendInPlace(_:)(v22, v24, 0LL, v21);
      swift_bridgeObjectRelease_n(v24, 2LL);
LABEL_51:
      unint64_t v13 = v282;
      goto LABEL_52;
    }

    if (v18)
    {
      swift_bridgeObjectRelease_n(v24, 2LL);
      uint64_t v284 = v22;
      uint64_t v285 = v24 & 0xFFFFFFFFFFFFFFLL;
      int v70 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v24) & 0xF,  (uint64_t)&v284,  HIBYTE(v24) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v70, v71, (v24 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v24);
      goto LABEL_51;
    }

    if ((v22 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v24);
      id v84 = (id)((v24 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v85 = v22 & 0xFFFFFFFFFFFFLL;
      uint64_t v86 = v22 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      id v84 = _StringObject.sharedUTF8.getter(v22, v24);
      uint64_t v86 = v95;
      swift_bridgeObjectRelease(v24);
      uint64_t v85 = v22 & 0xFFFFFFFFFFFFLL;
      if (v86 < v279) {
        goto LABEL_286;
      }
    }

    unint64_t v13 = v282;
    unint64_t v87 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v85, (uint64_t)v84, v86);
    _StringGuts.appendInPlace(_:isASCII:)(v87, v88, v22 < 0);
    swift_bridgeObjectRelease_n(v24, 2LL);
LABEL_52:
    if (++v14 == v13) {
      return v286;
    }
  }

  swift_bridgeObjectRetain_n(v24, 5LL, v43, v44);
  v90._Swift::UInt64 rawBits = 1LL;
  v91._Swift::UInt64 rawBits = (v21 << 16) | 1;
  v92._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v90, v91, v22, v24);
  if (v92._rawBits < 0x10000) {
    v92._rawBits |= 3;
  }
  Swift::Int v45 = specialized Collection.count.getter(v92, v93, v22, v24);
  swift_bridgeObjectRelease(v24);
  if ((v6 & 0x1000000000000000LL) == 0) {
    goto LABEL_67;
  }
LABEL_104:
  Swift::Int v94 = String.UTF8View._foreignCount()();
  uint64_t v3 = v94 + v45;
  if (!__OFADD__(v94, v45)) {
    goto LABEL_68;
  }
LABEL_288:
  while (2)
  {
    __break(1u);
LABEL_289:
    __break(1u);
LABEL_290:
    __break(1u);
LABEL_291:
    swift_bridgeObjectRetain_n(v19, 5LL, v25, v26);
    v259._Swift::UInt64 rawBits = 1LL;
    v260._Swift::UInt64 rawBits = (v24 << 16) | 1;
    v261._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v259, v260, v18, v19);
    if (v261._rawBits < 0x10000) {
      v261._rawBits |= 3;
    }
    Swift::Int v27 = specialized Collection.count.getter(v261, v262, v18, v19);
    swift_bridgeObjectRelease(v19);
    if ((v6 & 0x1000000000000000LL) != 0)
    {
LABEL_294:
      Swift::Int v263 = String.UTF8View._foreignCount()();
      uint64_t v22 = v263 + v27;
      if (!__OFADD__(v263, v27)) {
        goto LABEL_32;
      }
LABEL_296:
      __break(1u);
LABEL_297:
      if ((v22 & 0x1000000000000000LL) != 0)
      {
        uint64_t v18 = _StringGuts._foreignConvertedToSmall()(v18, v22);
        uint64_t v270 = v269;
        swift_bridgeObjectRelease(v22);
        uint64_t v22 = v270;
      }

      else
      {
        if ((v18 & 0x1000000000000000LL) != 0)
        {
          uint64_t v264 = (unsigned __int8 *)((v22 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v265 = v18 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v264 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v18, v22);
        }

        closure #1 in _StringGuts._convertedToSmall()(v264, v265, &v284);
        swift_bridgeObjectRelease(v22);
        uint64_t v18 = v284;
        uint64_t v22 = v285;
      }

      unint64_t v24 = v282;
      uint64_t v14 = v279;
LABEL_116:
      uint64_t v105 = HIBYTE(v3) & 0xF;
      uint64_t v106 = HIBYTE(v22) & 0xF;
      uint64_t v107 = v106 + v105;
      if ((unint64_t)(v106 + v105) <= 0xF)
      {
        if (v106)
        {
          uint64_t v108 = 0LL;
          unint64_t v109 = 0LL;
          uint64_t v110 = 8 * v106;
          do
          {
            unint64_t v111 = v105 + v109;
            BOOL v77 = v109++ >= 8;
            if (v77) {
              unint64_t v112 = v22;
            }
            else {
              unint64_t v112 = v18;
            }
            char v113 = (8 * v105 + v108) & 0x38;
            uint64_t v114 = (-255LL << v113) - 1;
            unint64_t v115 = (unint64_t)(v112 >> (v108 & 0x38)) << v113;
            unint64_t v116 = v115 | v114 & v3;
            unint64_t v117 = v115 | v114 & v9;
            if (v111 < 8) {
              uint64_t v9 = v117;
            }
            else {
              uint64_t v3 = v116;
            }
            v108 += 8LL;
          }

          while (v110 != v108);
        }

        swift_bridgeObjectRelease(v6);
        swift_bridgeObjectRelease(v19);
        unint64_t v118 = 0xA000000000000000LL;
        if (!(v9 & 0x8080808080808080LL | v3 & 0x80808080808080LL)) {
          unint64_t v118 = 0xE000000000000000LL;
        }
        unint64_t v286 = v9;
        unint64_t v287 = v118 & 0xFF00000000000000LL | (v107 << 56) | v3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v3 = v276;
        if (v24 == 1) {
          return v286;
        }
LABEL_167:
        uint64_t v272 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v273 = v3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v274 = 8 * v275;
        unint64_t v143 = 1LL;
LABEL_170:
        specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v143, 1, (uint64_t)a3);
        if (__OFADD__(v143, 1LL))
        {
          __break(1u);
          continue;
        }

        unint64_t v281 = v143 + 1;
        unint64_t v145 = &v277[2 * v143];
        uint64_t v9 = *v145;
        unint64_t v19 = v145[1];
        uint64_t v18 = v286;
        unint64_t v6 = v287;
        unint64_t v146 = HIBYTE(v287) & 0xF;
        if ((v287 & 0x2000000000000000LL) != 0) {
          unint64_t v147 = HIBYTE(v287) & 0xF;
        }
        else {
          unint64_t v147 = v286 & 0xFFFFFFFFFFFFLL;
        }
        if (!v147 && (v286 & ~v287 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRetain(v19, v144, v25, v26);
          swift_bridgeObjectRetain(v3, v181, v182, v183);
          swift_bridgeObjectRelease(v6);
          unint64_t v286 = v14;
          unint64_t v287 = v3;
          goto LABEL_220;
        }

        if ((v287 & 0x2000000000000000LL) == 0)
        {
          uint64_t v21 = v278;
          if ((v3 & 0x2000000000000000LL) != 0) {
            uint64_t v21 = v275;
          }
LABEL_181:
          if ((v3 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRetain(v19, v144, v25, v26);
            v242._Swift::UInt64 rawBits = 1LL;
            v243._Swift::UInt64 rawBits = (v21 << 16) | 1;
            Swift::UInt64 v244 = _StringGuts.validateScalarRange(_:)(v242, v243, v14, v3);
            Swift::UInt64 v248 = v245;
            if (v244 >= 0x10000) {
              uint64_t v22 = v244;
            }
            else {
              uint64_t v22 = v244 | 3;
            }
            swift_bridgeObjectRetain(v3, v245, v246, v247);
            v249._Swift::UInt64 rawBits = v22;
            v250._Swift::UInt64 rawBits = v248;
            unint64_t v24 = specialized Collection.count.getter(v249, v250, v14, v3);
            swift_bridgeObjectRelease(v3);
            if ((v6 & 0x1000000000000000LL) == 0) {
              goto LABEL_183;
            }
          }

          else
          {
            swift_bridgeObjectRetain(v19, v144, v25, v26);
            unint64_t v24 = v21;
            if ((v6 & 0x1000000000000000LL) == 0)
            {
LABEL_183:
              BOOL v28 = __OFADD__(v147, v24);
              int64_t v150 = v147 + v24;
              if (v28) {
                goto LABEL_289;
              }
              goto LABEL_184;
            }
          }

          Swift::Int v251 = String.UTF8View._foreignCount()();
          int64_t v150 = v251 + v24;
          if (__OFADD__(v251, v24)) {
            goto LABEL_289;
          }
LABEL_184:
          if ((v18 & ~v6 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v151 = _StringGuts.nativeUnusedCapacity.getter(v18, v6);
            if ((v149 & 1) != 0) {
              goto LABEL_310;
            }
            uint64_t v152 = (v6 >> 61) & 1;
            if (v150 <= 15 && (v152 & 1) != 0)
            {
LABEL_191:
              swift_bridgeObjectRetain(v6, v149, v25, v26);
              unint64_t v153 = _StringGuts._convertedToSmall()(v18, v6);
              unint64_t v155 = v154;
              swift_bridgeObjectRelease(v6);
              v156._Swift::UInt64 rawBits = (v21 << 16) | 1;
              v157._Swift::UInt64 rawBits = 1LL;
              Swift::UInt64 v158 = _StringGuts.validateScalarRange(_:)(v157, v156, v14, v3);
              Swift::UInt64 v162 = v159;
              if (v158 >= 0x10000) {
                Swift::UInt64 v163 = v158;
              }
              else {
                Swift::UInt64 v163 = v158 | 3;
              }
              swift_bridgeObjectRetain(v3, v159, v160, v161);
              v164._Swift::UInt64 rawBits = v163;
              v165._Swift::UInt64 rawBits = v162;
              unint64_t v166 = specialized String.init(_:)(v164, v165, v14, v3);
              unint64_t v168 = v167;
              swift_bridgeObjectRelease(v3);
              unint64_t v169 = _StringGuts._convertedToSmall()(v166, v168);
              uint64_t v21 = v170;
              swift_bridgeObjectRelease(v168);
              unint64_t v171 = specialized _SmallString.init(_:appending:)(v153, v155, v169, v21);
              if ((v173 & 1) != 0) {
                goto LABEL_309;
              }
              unint64_t v174 = v171;
              unint64_t v24 = v172;
              swift_bridgeObjectRelease(v6);
              unint64_t v286 = v174;
              unint64_t v287 = v24;
              goto LABEL_220;
            }
          }

          else if (v150 <= 15)
          {
            goto LABEL_191;
          }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v150, v24);
          if ((v3 & 0x1000000000000000LL) != 0)
          {
            _StringGuts._foreignAppendInPlace(_:)(v14, v3, 0LL, v21);
          }

          else if ((v3 & 0x2000000000000000LL) != 0)
          {
            uint64_t v284 = v14;
            uint64_t v285 = v273;
            if (v275 < v21) {
              goto LABEL_286;
            }
            unint64_t v194 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v21, (uint64_t)&v284, v275);
            _StringGuts.appendInPlace(_:isASCII:)(v194, v195, (v3 & 0x4000000000000000LL) != 0);
          }

          else
          {
            uint64_t v177 = v272;
            uint64_t v178 = v278;
            if ((v14 & 0x1000000000000000LL) != 0)
            {
              if (v278 < v21) {
                goto LABEL_286;
              }
            }

            else
            {
              uint64_t v177 = (uint64_t)_StringObject.sharedUTF8.getter(v14, v3);
              uint64_t v178 = v257;
              if (v257 < v21) {
                goto LABEL_286;
              }
            }

            char v179 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v21, v177, v178);
            _StringGuts.appendInPlace(_:isASCII:)(v179, v180, v14 < 0);
          }

          goto LABEL_220;
        }

        uint64_t v21 = v278;
        if ((v3 & 0x2000000000000000LL) == 0) {
          goto LABEL_181;
        }
        uint64_t v21 = v275;
        unint64_t v148 = v146 + v275;
        if (v146 + v275 > 0xF) {
          goto LABEL_181;
        }
        if (v275)
        {
          uint64_t v184 = 0LL;
          unint64_t v185 = 0LL;
          unint64_t v186 = v287;
          do
          {
            unint64_t v187 = v146 + v185;
            BOOL v77 = v185++ >= 8;
            if (v77) {
              unint64_t v188 = v3;
            }
            else {
              unint64_t v188 = v14;
            }
            char v189 = (8 * v146 + v184) & 0x38;
            uint64_t v190 = (-255LL << v189) - 1;
            unint64_t v191 = (unint64_t)(v188 >> (v184 & 0x38)) << v189;
            unint64_t v192 = v191 | v190 & v186;
            unint64_t v193 = v191 | v190 & v18;
            if (v187 < 8) {
              uint64_t v18 = v193;
            }
            else {
              unint64_t v186 = v192;
            }
            v184 += 8LL;
          }

          while (v274 != v184);
        }

        else
        {
          unint64_t v186 = v287;
        }

        unint64_t v196 = 0xA000000000000000LL;
        if (!(v18 & 0x8080808080808080LL | v186 & 0x80808080808080LL)) {
          unint64_t v196 = 0xE000000000000000LL;
        }
        unint64_t v197 = v196 | (v148 << 56);
        swift_bridgeObjectRetain(v19, v144, v25, v26);
        swift_bridgeObjectRelease(v6);
        unint64_t v286 = v18;
        unint64_t v287 = v197 & 0xFF00000000000000LL | v186 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v14 = v279;
LABEL_220:
        uint64_t v18 = v286;
        unint64_t v6 = v287;
        unint64_t v198 = HIBYTE(v287) & 0xF;
        if ((v287 & 0x2000000000000000LL) != 0) {
          unint64_t v199 = HIBYTE(v287) & 0xF;
        }
        else {
          unint64_t v199 = v286 & 0xFFFFFFFFFFFFLL;
        }
        if (!v199 && (v286 & ~v287 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v287);
          unint64_t v286 = v9;
          unint64_t v287 = v19;
          uint64_t v22 = v282;
          goto LABEL_169;
        }

        uint64_t v14 = v19 & 0x2000000000000000LL;
        uint64_t v21 = HIBYTE(v19) & 0xF;
        if ((v287 & 0x2000000000000000LL) == 0 || !v14) {
          goto LABEL_229;
        }
        unint64_t v200 = v198 + v21;
        if (v198 + v21 <= 0xF)
        {
          if (v21)
          {
            uint64_t v227 = 0LL;
            unint64_t v228 = 0LL;
            unint64_t v229 = v287;
            uint64_t v22 = v282;
            do
            {
              unint64_t v230 = v198 + v228;
              BOOL v77 = v228++ >= 8;
              if (v77) {
                unint64_t v231 = v19;
              }
              else {
                unint64_t v231 = v9;
              }
              char v232 = (8 * v198 + v227) & 0x38;
              uint64_t v233 = (-255LL << v232) - 1;
              unint64_t v234 = (unint64_t)(v231 >> (v227 & 0x38)) << v232;
              unint64_t v235 = v234 | v233 & v229;
              unint64_t v236 = v234 | v233 & v18;
              if (v230 < 8) {
                uint64_t v18 = v236;
              }
              else {
                unint64_t v229 = v235;
              }
              v227 += 8LL;
            }

            while (8 * v21 != v227);
          }

          else
          {
            unint64_t v229 = v287;
            uint64_t v22 = v282;
          }

          swift_bridgeObjectRelease(v287);
          swift_bridgeObjectRelease(v19);
          unint64_t v241 = 0xA000000000000000LL;
          if (!(v18 & 0x8080808080808080LL | v229 & 0x80808080808080LL)) {
            unint64_t v241 = 0xE000000000000000LL;
          }
          unint64_t v286 = v18;
          unint64_t v287 = v241 & 0xFF00000000000000LL | (v200 << 56) | v229 & 0xFFFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v14 = 1LL;
LABEL_229:
          uint64_t v3 = v9 & 0xFFFFFFFFFFFFLL;
          if (v14) {
            unint64_t v24 = HIBYTE(v19) & 0xF;
          }
          else {
            unint64_t v24 = v9 & 0xFFFFFFFFFFFFLL;
          }
          swift_bridgeObjectRetain_n(v19, 2LL, v175, v176);
          if ((v19 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRetain_n(v19, 5LL, v201, v202);
            v252._Swift::UInt64 rawBits = 1LL;
            v253._Swift::UInt64 rawBits = (v24 << 16) | 1;
            v254._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v252, v253, v9, v19);
            if (v254._rawBits < 0x10000) {
              v254._rawBits |= 3;
            }
            uint64_t v22 = specialized Collection.count.getter(v254, v255, v9, v19);
            swift_bridgeObjectRelease(v19);
            if ((v6 & 0x1000000000000000LL) == 0) {
              goto LABEL_234;
            }
          }

          else
          {
            swift_bridgeObjectRetain_n(v19, 4LL, v201, v202);
            uint64_t v22 = v24;
            if ((v6 & 0x1000000000000000LL) == 0)
            {
LABEL_234:
              BOOL v28 = __OFADD__(v199, v22);
              int64_t v203 = v199 + v22;
              if (v28) {
                goto LABEL_290;
              }
              goto LABEL_235;
            }
          }

          Swift::Int v256 = String.UTF8View._foreignCount()();
          int64_t v203 = v256 + v22;
          if (__OFADD__(v256, v22)) {
            goto LABEL_290;
          }
LABEL_235:
          if ((v18 & ~v6 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v204 = _StringGuts.nativeUnusedCapacity.getter(v18, v6);
            if ((v205 & 1) != 0) {
              goto LABEL_310;
            }
            uint64_t v206 = (v6 >> 61) & 1;
            if (v204 < v22) {
              LOBYTE(v206) = 1;
            }
            if (v203 <= 15 && (v206 & 1) != 0)
            {
LABEL_242:
              swift_bridgeObjectRelease_n(v19, 5LL);
              swift_bridgeObjectRetain(v6, v207, v208, v209);
              unint64_t v210 = _StringGuts._convertedToSmall()(v18, v6);
              unint64_t v212 = v211;
              swift_bridgeObjectRelease(v6);
              v213._Swift::UInt64 rawBits = (v24 << 16) | 1;
              v214._Swift::UInt64 rawBits = 1LL;
              v215._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v214, v213, v9, v19);
              if (v215._rawBits < 0x10000) {
                v215._rawBits |= 3;
              }
              unint64_t v217 = specialized String.init(_:)(v215, v216, v9, v19);
              uint64_t v9 = v218;
              swift_bridgeObjectRelease(v19);
              unint64_t v219 = _StringGuts._convertedToSmall()(v217, v9);
              uint64_t v18 = v220;
              swift_bridgeObjectRelease(v9);
              unint64_t v221 = specialized _SmallString.init(_:appending:)(v210, v212, v219, v18);
              uint64_t v22 = v282;
              uint64_t v3 = v276;
              uint64_t v14 = v279;
              if ((v223 & 1) != 0) {
                goto LABEL_309;
              }
              unint64_t v224 = v221;
              unint64_t v24 = v222;
              swift_bridgeObjectRelease(v6);
              swift_bridgeObjectRelease(v19);
              unint64_t v286 = v224;
              unint64_t v287 = v24;
              goto LABEL_169;
            }
          }

          else if (v203 <= 15)
          {
            goto LABEL_242;
          }

          unint64_t v6 = (unint64_t)&v286;
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v203, v22);
          swift_bridgeObjectRelease_n(v19, 4LL);
          if ((v19 & 0x1000000000000000LL) == 0)
          {
            if (v14)
            {
              swift_bridgeObjectRelease_n(v19, 2LL);
              uint64_t v284 = v9;
              uint64_t v285 = v19 & 0xFFFFFFFFFFFFFFLL;
              unint64_t v225 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v19) & 0xF,  (uint64_t)&v284,  HIBYTE(v19) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v225, v226, (v19 & 0x4000000000000000LL) != 0);
              swift_bridgeObjectRelease(v19);
              goto LABEL_251;
            }

            if ((v9 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v19);
              id v237 = (id)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v238 = v9 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v237 = _StringObject.sharedUTF8.getter(v9, v19);
              uint64_t v238 = v258;
              swift_bridgeObjectRelease(v19);
              if (v238 < v3) {
                goto LABEL_286;
              }
            }

            uint64_t v22 = v282;
            uint64_t v14 = v279;
            Swift::String::Index v239 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v9 & 0xFFFFFFFFFFFFLL,  (uint64_t)v237,  v238);
            unint64_t v6 = (unint64_t)&v286;
            _StringGuts.appendInPlace(_:isASCII:)(v239, v240, v9 < 0);
            swift_bridgeObjectRelease_n(v19, 2LL);
            uint64_t v3 = v276;
LABEL_169:
            unint64_t v143 = v281;
            if (v281 == v22) {
              return v286;
            }
            goto LABEL_170;
          }

          swift_bridgeObjectRelease(v19);
          _StringGuts._foreignAppendInPlace(_:)(v9, v19, 0LL, v24);
          swift_bridgeObjectRelease_n(v19, 2LL);
LABEL_251:
          uint64_t v22 = v282;
          uint64_t v3 = v276;
        }

        uint64_t v14 = v279;
        goto LABEL_169;
      }

LABEL_309:
      unint64_t v268 = 266LL;
LABEL_311:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v268,  0);
    }

    break;
  }

unint64_t BidirectionalCollection<>.joined(separator:)(uint64_t a1, unint64_t a2, void *a3)
{
  void (*v298)(uint64_t *__return_ptr, unint64_t);
  unint64_t v299;
  char *v300;
  char *v301;
  unint64_t v302;
  unint64_t AssociatedTypeWitness;
  void v304[2];
  uint64_t v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t v308;
  uint64_t v4 = v3;
  uint64_t v8 = *(a3 - 1);
  MEMORY[0x1895F8858](a1);
  char v10 = (char *)&v292 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(*(void *)(v11 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  v13,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v14 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v301 = (char *)&v292 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  unint64_t v300 = (char *)&v292 - v17;
  if (a3 == (void *)&unk_189B87EB0) {
    return specialized BidirectionalCollection<>.joined(separator:)(a1, a2, *v3);
  }
  unint64_t v302 = a1;
  uint64_t v294 = v16;
  unint64_t v295 = HIBYTE(a2) & 0xF;
  uint64_t v297 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v18 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v18 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v19 = (*(uint64_t (**)(void *, uint64_t))(v12 + 40))(a3, v12);
  uint64_t v20 = v19 + v19 * v18;
  uint64_t v307 = 0LL;
  unint64_t v308 = 0xE000000000000000LL;
  if (v20 >= 16)
  {
    uint64_t v21 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v22 & 1) != 0 || v21 < v20)
    {
      uint64_t v24 = 2 * _StringGuts.uniqueNativeCapacity.getter();
      if (v24 <= v20) {
        uint64_t v24 = v20;
      }
      if ((v23 & 1) != 0) {
        int64_t v25 = v20;
      }
      else {
        int64_t v25 = v24;
      }
      unint64_t v305 = 0LL;
      char v306 = 0LL;
      int64_t v26 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v305,  0LL,  v25,  1);
      unint64_t v27 = *(void *)(v26 + 24);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      uint64_t v307 = v27;
      unint64_t v308 = v26;
    }
  }

  (*(void (**)(char *, void **, void *))(v8 + 16))(v10, v4, a3);
  BOOL v28 = *(void (**)(void *, uint64_t))(v12 + 32);
  if (v18)
  {
    unint64_t v29 = v301;
    v28(a3, v12);
    unint64_t v30 = AssociatedTypeWitness;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v12,  (uint64_t)a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    unint64_t v298 = *(void (**)(uint64_t *__return_ptr, unint64_t))(AssociatedConformanceWitness + 16);
    unint64_t v299 = AssociatedConformanceWitness;
    v298(&v305, v30);
    unint64_t v34 = v306;
    if (!v306)
    {
      (*(void (**)(char *, unint64_t))(v294 + 8))(v29, v30);
LABEL_286:
      swift_bridgeObjectRelease(v306);
      return v307;
    }

    Swift::Int v35 = v305;
    unint64_t v37 = v307;
    unint64_t v36 = v308;
    unint64_t v38 = HIBYTE(v308) & 0xF;
    uint64_t v39 = v307 & 0xFFFFFFFFFFFFLL;
    if ((v308 & 0x2000000000000000LL) != 0) {
      uint64_t v40 = HIBYTE(v308) & 0xF;
    }
    else {
      uint64_t v40 = v307 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v300 = (char *)a2;
    if (!v40 && (v307 & ~v308 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v308);
      uint64_t v307 = v35;
      unint64_t v308 = v34;
      uint64_t v43 = v302;
      unint64_t v41 = AssociatedTypeWitness;
LABEL_165:
      uint64_t v132 = v301;
LABEL_166:
      ((void (*)(uint64_t *__return_ptr, unint64_t, unint64_t))v298)(&v305, v41, v299);
      unint64_t v34 = v306;
      if (v306)
      {
        unint64_t v292 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v293 = a2 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v163 = 8 * v295;
        uint64_t v296 = 8 * v295;
        while (1)
        {
          Swift::Int v35 = v305;
          uint64_t v39 = v307;
          unint64_t v36 = v308;
          unint64_t v164 = HIBYTE(v308) & 0xF;
          if ((v308 & 0x2000000000000000LL) != 0) {
            unint64_t v165 = HIBYTE(v308) & 0xF;
          }
          else {
            unint64_t v165 = v307 & 0xFFFFFFFFFFFFLL;
          }
          if (!v165 && (v307 & ~v308 & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRetain(a2, v162, v46, v47);
            swift_bridgeObjectRelease(v36);
            uint64_t v307 = v43;
            unint64_t v308 = a2;
            goto LABEL_208;
          }

          if ((v308 & 0x2000000000000000LL) != 0) {
            break;
          }
          unint64_t v37 = v297;
          if ((a2 & 0x2000000000000000LL) != 0) {
            goto LABEL_183;
          }
LABEL_184:
          uint64_t v40 = v37;
          if ((a2 & 0x1000000000000000LL) != 0)
          {
            v260._Swift::UInt64 rawBits = (v37 << 16) | 1;
            v261._Swift::UInt64 rawBits = 1LL;
            Swift::UInt64 v262 = _StringGuts.validateScalarRange(_:)(v261, v260, v43, a2);
            Swift::UInt64 v266 = v263;
            if (v262 >= 0x10000) {
              Swift::UInt64 v267 = v262;
            }
            else {
              Swift::UInt64 v267 = v262 | 3;
            }
            swift_bridgeObjectRetain(a2, v263, v264, v265);
            v268._Swift::UInt64 rawBits = v267;
            v269._Swift::UInt64 rawBits = v266;
            uint64_t v43 = v302;
            uint64_t v40 = specialized Collection.count.getter(v268, v269, v302, a2);
            swift_bridgeObjectRelease(a2);
            if ((v36 & 0x1000000000000000LL) == 0)
            {
LABEL_186:
              BOOL v48 = __OFADD__(v165, v40);
              int64_t v45 = v165 + v40;
              if (v48) {
                goto LABEL_289;
              }
              goto LABEL_187;
            }
          }

          else if ((v308 & 0x1000000000000000LL) == 0)
          {
            goto LABEL_186;
          }

          Swift::Int v270 = String.UTF8View._foreignCount()();
          int64_t v45 = v270 + v40;
          if (__OFADD__(v270, v40))
          {
LABEL_289:
            __break(1u);
LABEL_290:
            __break(1u);
LABEL_291:
            __break(1u);
LABEL_292:
            swift_bridgeObjectRetain_n(v34, 5LL, v46, v47);
            v280._Swift::UInt64 rawBits = 1LL;
            v281._Swift::UInt64 rawBits = (v45 << 16) | 1;
            v282._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v280, v281, v35, v34);
            if (v282._rawBits < 0x10000) {
              v282._rawBits |= 3;
            }
            int64_t v45 = specialized Collection.count.getter(v282, v283, v35, v34);
            swift_bridgeObjectRelease(v34);
            if ((v36 & 0x1000000000000000LL) != 0) {
              goto LABEL_295;
            }
LABEL_28:
            BOOL v48 = __OFADD__(v40, v45);
            uint64_t v49 = v40 + v45;
            if (!v48) {
              goto LABEL_29;
            }
LABEL_297:
            __break(1u);
LABEL_298:
            if ((v49 & 0x1000000000000000LL) != 0)
            {
              a2 = _StringGuts._foreignConvertedToSmall()(a2, v49);
              uint64_t v291 = v290;
              swift_bridgeObjectRelease(v49);
              uint64_t v49 = v291;
            }

            else
            {
              if ((a2 & 0x1000000000000000LL) != 0)
              {
                uint64_t v285 = (unsigned __int8 *)((v49 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v286 = a2 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                uint64_t v285 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, v49);
              }

              closure #1 in _StringGuts._convertedToSmall()(v285, v286, &v305);
              swift_bridgeObjectRelease(v49);
              a2 = v305;
              uint64_t v49 = v306;
            }

            uint64_t v43 = v302;
            unint64_t v41 = AssociatedTypeWitness;
            goto LABEL_146;
          }

LABEL_208:
          unint64_t v37 = v307;
          unint64_t v36 = v308;
          unint64_t v199 = HIBYTE(v308) & 0xF;
          if ((v308 & 0x2000000000000000LL) != 0) {
            unint64_t v200 = HIBYTE(v308) & 0xF;
          }
          else {
            unint64_t v200 = v307 & 0xFFFFFFFFFFFFLL;
          }
          if (!v200 && (v307 & ~v308 & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease(v308);
            uint64_t v307 = v35;
            unint64_t v308 = v34;
            unint64_t v41 = AssociatedTypeWitness;
            goto LABEL_171;
          }

          unint64_t v41 = v34 & 0x2000000000000000LL;
          a2 = HIBYTE(v34) & 0xF;
          if ((v34 & 0x2000000000000000LL & v308) != 0)
          {
            unint64_t v201 = v199 + a2;
            if (v199 + a2 <= 0xF)
            {
              if (a2)
              {
                uint64_t v233 = 0LL;
                unint64_t v234 = 0LL;
                uint64_t v235 = 8 * a2;
                unint64_t v236 = v308;
                a2 = (unint64_t)v300;
                do
                {
                  unint64_t v237 = v199 + v234;
                  BOOL v97 = v234++ >= 8;
                  if (v97) {
                    unint64_t v238 = v34;
                  }
                  else {
                    unint64_t v238 = v35;
                  }
                  char v239 = (8 * v199 + v233) & 0x38;
                  uint64_t v240 = (-255LL << v239) - 1;
                  unint64_t v241 = (unint64_t)(v238 >> (v233 & 0x38)) << v239;
                  unint64_t v242 = v241 | v240 & v236;
                  unint64_t v243 = v241 | v240 & v37;
                  if (v237 < 8) {
                    unint64_t v37 = v243;
                  }
                  else {
                    unint64_t v236 = v242;
                  }
                  v233 += 8LL;
                }

                while (v235 != v233);
              }

              else
              {
                unint64_t v236 = v308;
                a2 = (unint64_t)v300;
              }

              swift_bridgeObjectRelease(v308);
              swift_bridgeObjectRelease(v34);
              unint64_t v254 = 0xA000000000000000LL;
              if (!(v37 & 0x8080808080808080LL | v236 & 0x80808080808080LL)) {
                unint64_t v254 = 0xE000000000000000LL;
              }
              uint64_t v307 = v37;
              unint64_t v308 = v254 & 0xFF00000000000000LL | (v201 << 56) | v236 & 0xFFFFFFFFFFFFFFLL;
              unint64_t v41 = AssociatedTypeWitness;
              goto LABEL_170;
            }
          }

          uint64_t v39 = v35 & 0xFFFFFFFFFFFFLL;
          if (v41) {
            uint64_t v202 = HIBYTE(v34) & 0xF;
          }
          else {
            uint64_t v202 = v35 & 0xFFFFFFFFFFFFLL;
          }
          swift_bridgeObjectRetain_n(v34, 2LL, v193, v194);
          if ((v34 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRetain_n(v34, 5LL, v203, v204);
            v271._Swift::UInt64 rawBits = 1LL;
            v272._Swift::UInt64 rawBits = (v202 << 16) | 1;
            v273._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v271, v272, v35, v34);
            if (v273._rawBits < 0x10000) {
              v273._rawBits |= 3;
            }
            uint64_t v40 = specialized Collection.count.getter(v273, v274, v35, v34);
            swift_bridgeObjectRelease(v34);
            if ((v36 & 0x1000000000000000LL) == 0)
            {
LABEL_220:
              BOOL v48 = __OFADD__(v200, v40);
              int64_t v45 = v200 + v40;
              if (v48) {
                goto LABEL_290;
              }
              goto LABEL_221;
            }
          }

          else
          {
            swift_bridgeObjectRetain_n(v34, 4LL, v203, v204);
            uint64_t v40 = v202;
            if ((v36 & 0x1000000000000000LL) == 0) {
              goto LABEL_220;
            }
          }

          Swift::Int v275 = String.UTF8View._foreignCount()();
          int64_t v45 = v275 + v40;
          if (__OFADD__(v275, v40)) {
            goto LABEL_290;
          }
LABEL_221:
          if ((v37 & ~v36 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v36 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v205 = _StringGuts.nativeUnusedCapacity.getter(v37, v36);
            if ((v206 & 1) != 0) {
              goto LABEL_309;
            }
            uint64_t v207 = (v36 >> 61) & 1;
            if (v205 < v40) {
              LOBYTE(v207) = 1;
            }
            if (v45 <= 15 && (v207 & 1) != 0)
            {
LABEL_228:
              swift_bridgeObjectRelease_n(v34, 5LL);
              swift_bridgeObjectRetain(v36, v208, v209, v210);
              unint64_t v211 = _StringGuts._convertedToSmall()(v37, v36);
              unint64_t v213 = v212;
              swift_bridgeObjectRelease(v36);
              v214._Swift::UInt64 rawBits = (v202 << 16) | 1;
              v215._Swift::UInt64 rawBits = 1LL;
              v216._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v215, v214, v35, v34);
              if (v216._rawBits < 0x10000) {
                v216._rawBits |= 3;
              }
              unint64_t v218 = specialized String.init(_:)(v216, v217, v35, v34);
              unint64_t v220 = v219;
              swift_bridgeObjectRelease(v34);
              unint64_t v221 = _StringGuts._convertedToSmall()(v218, v220);
              unint64_t v223 = v222;
              swift_bridgeObjectRelease(v220);
              unint64_t v224 = specialized _SmallString.init(_:appending:)(v211, v213, v221, v223);
              if ((v226 & 1) != 0) {
                goto LABEL_308;
              }
              unint64_t v227 = v224;
              unint64_t v228 = v225;
              swift_bridgeObjectRelease(v36);
              swift_bridgeObjectRelease(v34);
              uint64_t v307 = v227;
              unint64_t v308 = v228;
LABEL_169:
              unint64_t v41 = AssociatedTypeWitness;
              a2 = (unint64_t)v300;
LABEL_170:
              uint64_t v43 = v302;
LABEL_171:
              uint64_t v132 = v301;
              goto LABEL_172;
            }
          }

          else if (v45 <= 15)
          {
            goto LABEL_228;
          }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v45, v40);
          swift_bridgeObjectRelease_n(v34, 4LL);
          if ((v34 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v34);
            _StringGuts._foreignAppendInPlace(_:)(v35, v34, 0LL, v202);
            swift_bridgeObjectRelease_n(v34, 2LL);
            goto LABEL_169;
          }

          uint64_t v132 = v301;
          if (v41)
          {
            swift_bridgeObjectRelease_n(v34, 2LL);
            unint64_t v305 = v35;
            char v306 = v34 & 0xFFFFFFFFFFFFFFLL;
            uint64_t v257 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v34) & 0xF,  (uint64_t)&v305,  HIBYTE(v34) & 0xF);
            _StringGuts.appendInPlace(_:isASCII:)(v257, v258, (v34 & 0x4000000000000000LL) != 0);
            swift_bridgeObjectRelease(v34);
            uint64_t v43 = v302;
            unint64_t v41 = AssociatedTypeWitness;
            a2 = (unint64_t)v300;
          }

          else
          {
            if ((v35 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v34);
              id v229 = (id)((v34 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v230 = v35 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v229 = _StringObject.sharedUTF8.getter(v35, v34);
              uint64_t v230 = v277;
              swift_bridgeObjectRelease(v34);
              if (v230 < v39) {
                goto LABEL_284;
              }
            }

            a2 = (unint64_t)v300;
            uint64_t v43 = v302;
            unint64_t v231 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v35 & 0xFFFFFFFFFFFFLL,  (uint64_t)v229,  v230);
            _StringGuts.appendInPlace(_:isASCII:)(v231, v232, v35 < 0);
            swift_bridgeObjectRelease_n(v34, 2LL);
            unint64_t v41 = AssociatedTypeWitness;
          }

        if (v14 == 18) {
          int64_t v26 = v20;
        }
        else {
          int64_t v26 = v14;
        }
        switch(v26)
        {
          case 0:
            if (v23 > 0xF) {
              goto LABEL_258;
            }
            unint64_t v27 = 1 << v23;
            if ((v27 & 0x20A1) != 0) {
              goto LABEL_248;
            }
            if ((v27 & 0x8A00) == 0) {
              goto LABEL_258;
            }
            goto LABEL_231;
          case 2:
            if ((v22 & 1) == 0) {
              goto LABEL_258;
            }
            if ((v15 & 1) != 0) {
              return v11;
            }
            if ((v33 & 1) == 0 || v32 < 2) {
              return v13;
            }
            goto LABEL_7;
          case 5:
            if (v23 > 0xD || ((1 << v23) & 0x21A1) == 0) {
              goto LABEL_258;
            }
            goto LABEL_248;
          case 7:
            if (v23 > 0xF) {
              goto LABEL_258;
            }
            if (((1 << v23) & 0xA0A1) != 0) {
              goto LABEL_248;
            }
            if (((1 << v23) & 0xA00) != 0)
            {
LABEL_231:
              uint64_t v32 = 0LL;
              uint64_t v15 = 0;
              uint64_t v14 = 18;
            }

            else
            {
              if (v23 != 2) {
                goto LABEL_258;
              }
              uint64_t v15 = 0;
              uint64_t v14 = 18;
              unint64_t v29 = 2LL;
LABEL_255:
              uint64_t v32 = v29;
            }

            char v33 = 1;
            uint64_t v13 = v11;
            goto LABEL_8;
          case 8:
            uint64_t v14 = 18;
            if (v23 != 5 && v23 != 8) {
              goto LABEL_258;
            }
            goto LABEL_8;
          case 9:
            if (v23 && v23 != 7) {
              goto LABEL_258;
            }
            goto LABEL_237;
          case 10:
            if ((v21 & 1) == 0) {
              goto LABEL_258;
            }
            goto LABEL_242;
          case 11:
          case 15:
            if (!v23 || v23 == 7)
            {
LABEL_237:
              if ((v15 & 1) != 0) {
                return v11;
              }
              if ((v33 & 1) == 0 || v32) {
                return v13;
              }
            }

            else
            {
              if (v23 != 13) {
                goto LABEL_258;
              }
LABEL_242:
              if ((v15 & 1) != 0) {
                return v11;
              }
              if ((v33 & 1) == 0 || v32 != 1) {
                return v13;
              }
            }

LABEL_285:
      (*(void (**)(char *, unint64_t))(v294 + 8))(v132, v41);
      goto LABEL_286;
    }

    unint64_t v41 = v306 & 0x2000000000000000LL;
    unint64_t v42 = HIBYTE(v306) & 0xF;
    uint64_t v43 = v302;
    if ((v306 & 0x2000000000000000LL & v308) != 0)
    {
      unint64_t v44 = v38 + v42;
      if (v38 + v42 <= 0xF)
      {
        if (v42)
        {
          uint64_t v117 = 0LL;
          unint64_t v118 = 0LL;
          uint64_t v119 = 8 * v42;
          unint64_t v120 = v308;
          do
          {
            unint64_t v121 = v38 + v118;
            BOOL v97 = v118++ >= 8;
            if (v97) {
              unint64_t v122 = v306;
            }
            else {
              unint64_t v122 = v305;
            }
            char v123 = (8 * v38 + v117) & 0x38;
            uint64_t v124 = (-255LL << v123) - 1;
            unint64_t v125 = (unint64_t)(v122 >> (v117 & 0x38)) << v123;
            unint64_t v126 = v125 | v124 & v120;
            unint64_t v127 = v125 | v124 & v37;
            if (v121 < 8) {
              unint64_t v37 = v127;
            }
            else {
              unint64_t v120 = v126;
            }
            v117 += 8LL;
          }

          while (v119 != v117);
        }

        else
        {
          unint64_t v120 = v308;
        }

        swift_bridgeObjectRelease(v308);
        swift_bridgeObjectRelease(v34);
        unint64_t v161 = 0xA000000000000000LL;
        if (!(v37 & 0x8080808080808080LL | v120 & 0x80808080808080LL)) {
          unint64_t v161 = 0xE000000000000000LL;
        }
        uint64_t v307 = v37;
        unint64_t v308 = v161 & 0xFF00000000000000LL | (v44 << 56) | v120 & 0xFFFFFFFFFFFFFFLL;
LABEL_164:
        unint64_t v41 = AssociatedTypeWitness;
        goto LABEL_165;
      }
    }

    unint64_t v292 = HIBYTE(v306) & 0xF;
    uint64_t v293 = v305 & 0xFFFFFFFFFFFFLL;
    if (v41) {
      int64_t v45 = HIBYTE(v306) & 0xF;
    }
    else {
      int64_t v45 = v305 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v306, 2LL, v32, v33);
    uint64_t v296 = v45;
    if ((v34 & 0x1000000000000000LL) != 0) {
      goto LABEL_292;
    }
    swift_bridgeObjectRetain_n(v34, 4LL, v46, v47);
    if ((v36 & 0x1000000000000000LL) == 0) {
      goto LABEL_28;
    }
LABEL_295:
    Swift::Int v284 = String.UTF8View._foreignCount()();
    uint64_t v49 = v284 + v45;
    if (__OFADD__(v284, v45)) {
      goto LABEL_297;
    }
LABEL_29:
    unint64_t v50 = v37 & ~v36;
    if ((v50 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v36 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v51 = _StringGuts.nativeUnusedCapacity.getter(v37, v36);
      if ((v52 & 1) != 0)
      {
LABEL_309:
        unint64_t v289 = 258LL;
        goto LABEL_310;
      }

      if (v49 >= 16) {
        goto LABEL_101;
      }
      if ((v36 & 0x2000000000000000LL) == 0)
      {
        if (v51 < v45)
        {
LABEL_135:
          swift_bridgeObjectRelease_n(v34, 5LL);
          if ((v36 & 0x1000000000000000LL) == 0)
          {
            uint64_t v43 = v302;
            if ((v37 & 0x1000000000000000LL) != 0)
            {
              unint64_t v141 = (unsigned __int8 *)((v36 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }

            else
            {
              unint64_t v141 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v37, v36);
              uint64_t v39 = v138;
            }

            swift_bridgeObjectRetain(v36, v138, v139, v140);
            closure #1 in _StringGuts._convertedToSmall()(v141, v39, &v305);
            swift_bridgeObjectRelease(v36);
            unint64_t v37 = v305;
            uint64_t v39 = v306;
LABEL_142:
            v142._Swift::UInt64 rawBits = (v296 << 16) | 1;
            v143._Swift::UInt64 rawBits = 1LL;
            v144._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v143, v142, v35, v34);
            if (v144._rawBits < 0x10000) {
              v144._rawBits |= 3;
            }
            a2 = specialized String.init(_:)(v144, v145, v35, v34);
            uint64_t v49 = v146;
            swift_bridgeObjectRelease(v34);
            if ((v49 & 0x2000000000000000LL) == 0) {
              goto LABEL_298;
            }
            swift_bridgeObjectRelease(v49);
            unint64_t v41 = AssociatedTypeWitness;
LABEL_146:
            uint64_t v147 = HIBYTE(v39) & 0xF;
            uint64_t v148 = HIBYTE(v49) & 0xF;
            uint64_t v149 = v148 + v147;
            if ((unint64_t)(v148 + v147) <= 0xF)
            {
              if (v148)
              {
                uint64_t v150 = 0LL;
                unint64_t v151 = 0LL;
                uint64_t v152 = 8 * v148;
                do
                {
                  unint64_t v153 = v147 + v151;
                  BOOL v97 = v151++ >= 8;
                  if (v97) {
                    unint64_t v154 = v49;
                  }
                  else {
                    unint64_t v154 = a2;
                  }
                  char v155 = (8 * v147 + v150) & 0x38;
                  uint64_t v156 = (-255LL << v155) - 1;
                  unint64_t v157 = (unint64_t)(v154 >> (v150 & 0x38)) << v155;
                  unint64_t v158 = v157 | v156 & v39;
                  unint64_t v159 = v157 | v156 & v37;
                  if (v153 < 8) {
                    unint64_t v37 = v159;
                  }
                  else {
                    uint64_t v39 = v158;
                  }
                  v150 += 8LL;
                }

                while (v152 != v150);
              }

              swift_bridgeObjectRelease(v36);
              swift_bridgeObjectRelease(v34);
              unint64_t v160 = 0xA000000000000000LL;
              if (!(v37 & 0x8080808080808080LL | v39 & 0x80808080808080LL)) {
                unint64_t v160 = 0xE000000000000000LL;
              }
              uint64_t v307 = v37;
              unint64_t v308 = v160 & 0xFF00000000000000LL | (v149 << 56) | v39 & 0xFFFFFFFFFFFFFFLL;
              a2 = (unint64_t)v300;
              goto LABEL_165;
            }

          unint64_t v243 = 266LL;
LABEL_287:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v243,  0);
        }

          unint64_t v243 = 266LL;
LABEL_287:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v243,  0);
        }

uint64_t static UInt8.&>> infix(_:_:)(unsigned __int8 a1, char a2)
{
  return a1 >> (a2 & 7);
}

Swift::String __swiftcall String.lowercased()()
{
  unint64_t v4 = v1;
  uint64_t v5 = v0;
  uint64_t v81 = *MEMORY[0x1895F89C0];
  if ((v1 & 0x1000000000000000LL) != 0)
  {
    *(void *)&__int128 v80 = 0LL;
    *((void *)&v80 + 1) = 0xE000000000000000LL;
    Swift::Int v51 = String.UTF8View._foreignCount()();
    BOOL v52 = (v4 & 0x2000000000000000LL) == 0;
    goto LABEL_52;
  }

  uint64_t v6 = (v1 >> 62) & 1;
  if ((v1 & 0x2000000000000000LL) == 0) {
    LODWORD(v6) = v0 < 0;
  }
  if ((_DWORD)v6 != 1)
  {
    *(void *)&__int128 v80 = 0LL;
    *((void *)&v80 + 1) = 0xE000000000000000LL;
    BOOL v52 = (v1 & 0x2000000000000000LL) == 0;
    if ((v1 & 0x2000000000000000LL) != 0) {
      Swift::Int v51 = HIBYTE(v1) & 0xF;
    }
    else {
      Swift::Int v51 = v0 & 0xFFFFFFFFFFFFLL;
    }
LABEL_52:
    String.reserveCapacity(_:)(v51);
    if (v52) {
      uint64_t v54 = v5 & 0xFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v54 = HIBYTE(v4) & 0xF;
    }
    if (!v54)
    {
LABEL_89:
      unint64_t v21 = *((void *)&v80 + 1);
      uint64_t v17 = v80;
      goto LABEL_46;
    }

    uint64_t v55 = 0LL;
    uint64_t v77 = v54;
    while (1)
    {
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v60 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v55 << 16));
        Swift::Int scalarLength = v60.scalarLength;
        unsigned int value = v60._0._value;
      }

      else
      {
        if (v52)
        {
          Swift::String::Index v57 = (uint8x16_t *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            Swift::String::Index v57 = (uint8x16_t *)_StringObject.sharedUTF8.getter(v5, v4);
          }
        }

        else
        {
          v79.i64[0] = v5;
          v79.i64[1] = v4 & 0xFFFFFFFFFFFFFFLL;
          Swift::String::Index v57 = &v79;
        }

        unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v57, v53, v55);
      }

      unsigned int v61 = value;
      Swift::Int v62 = scalarLength;
      v79.i64[0] = 0LL;
      Specialint Mapping = (uint8x16_t *)_swift_stdlib_getSpecialMapping(value, 1, &v79);
      if (SpecialMapping && v79.i64[0])
      {
        if (v79.i64[0] < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
        unint64_t v64 = specialized static String._uncheckedFromUTF8(_:isASCII:)(SpecialMapping, v79.i64[0], 0);
      }

      else
      {
        int Mapping = _swift_stdlib_getMapping(v61, 1);
        if (Mapping)
        {
          int64_t v67 = Mapping + (unint64_t)v61;
          if (v67 < 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
          }
          if (HIDWORD(v67)) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
          }
        }

        else
        {
          LODWORD(v67) = v61;
        }

        unint64_t v64 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v67);
      }

      uint64_t v68 = v64;
      unint64_t v69 = v65;
      uint8x16_t v70 = (uint8x16_t)v80;
      unint64_t v71 = HIBYTE(*((void *)&v80 + 1)) & 0xFLL;
      if ((*((void *)&v80 + 1) & 0x2000000000000000LL) == 0) {
        unint64_t v71 = v80 & 0xFFFFFFFFFFFFLL;
      }
      if (!v71 && ((unint64_t)v80 & ~*((void *)&v80 + 1) & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(*((uint64_t *)&v80 + 1));
        *(void *)&__int128 v80 = v68;
        *((void *)&v80 + 1) = v69;
        goto LABEL_59;
      }

      if ((*((void *)&v80 + 1) & 0x2000000000000000LL) == 0) {
        break;
      }
      if ((v65 & 0x2000000000000000LL) == 0) {
        goto LABEL_57;
      }
      specialized _SmallString.init(_:appending:)(v80, *((unint64_t *)&v80 + 1), v64, v65);
      if ((v73 & 1) == 0)
      {
        uint64_t v74 = v72;
        swift_bridgeObjectRelease(v70.i64[1]);
        swift_bridgeObjectRelease(v69);
        *(void *)&__int128 v80 = v70.i64[0];
        *((void *)&v80 + 1) = v74;
        uint64_t v54 = v77;
        goto LABEL_59;
      }

      uint64_t v56 = HIBYTE(v69) & 0xF;
      uint64_t v54 = v77;
LABEL_58:
      _StringGuts.append(_:)(v68, v69, 0LL, v56);
      swift_bridgeObjectRelease(v69);
LABEL_59:
      v55 += v62;
      if (v55 >= v54) {
        goto LABEL_89;
      }
    }

    if ((v65 & 0x2000000000000000LL) != 0)
    {
      uint64_t v56 = HIBYTE(v65) & 0xF;
      goto LABEL_58;
    }

uint64_t _StringGuts.isFastASCII.getter(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = (a2 >> 62) & 1;
  if ((a2 & 0x2000000000000000LL) == 0) {
    LODWORD(type metadata accessor for Set._Variant(0LL, *(void *)(v1 + 16), *(void *)(v1 + 24), v2) = a1 >> 63;
  }
  if ((a2 & 0x1000000000000000LL) != 0) {
    return 0LL;
  }
  else {
    return v2;
  }
}

uint64_t (*UnsafeMutableBufferPointer.subscript.modify( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20DuLL,  0);
  }
  if (a4 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

Swift::Int String.UTF8View.count.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000LL) != 0) {
    return String.UTF8View._foreignCount()();
  }
  if ((a2 & 0x2000000000000000LL) != 0) {
    return HIBYTE(a2) & 0xF;
  }
  return a1 & 0xFFFFFFFFFFFFLL;
}

uint64_t Unicode.Scalar.properties.getter@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t Unicode.Scalar.Properties.lowercaseMapping.getter()
{
  return Unicode.Scalar.Properties._getMapping(_:)(1u);
}

Swift::String __swiftcall String.uppercased()()
{
  unint64_t v4 = v1;
  uint64_t v5 = v0;
  uint64_t v81 = *MEMORY[0x1895F89C0];
  if ((v1 & 0x1000000000000000LL) != 0)
  {
    *(void *)&__int128 v80 = 0LL;
    *((void *)&v80 + 1) = 0xE000000000000000LL;
    Swift::Int v51 = String.UTF8View._foreignCount()();
    BOOL v52 = (v4 & 0x2000000000000000LL) == 0;
    goto LABEL_52;
  }

  uint64_t v6 = (v1 >> 62) & 1;
  if ((v1 & 0x2000000000000000LL) == 0) {
    LODWORD(v6) = v0 < 0;
  }
  if ((_DWORD)v6 != 1)
  {
    *(void *)&__int128 v80 = 0LL;
    *((void *)&v80 + 1) = 0xE000000000000000LL;
    BOOL v52 = (v1 & 0x2000000000000000LL) == 0;
    if ((v1 & 0x2000000000000000LL) != 0) {
      Swift::Int v51 = HIBYTE(v1) & 0xF;
    }
    else {
      Swift::Int v51 = v0 & 0xFFFFFFFFFFFFLL;
    }
LABEL_52:
    String.reserveCapacity(_:)(v51);
    if (v52) {
      uint64_t v54 = v5 & 0xFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v54 = HIBYTE(v4) & 0xF;
    }
    if (!v54)
    {
LABEL_89:
      unint64_t v21 = *((void *)&v80 + 1);
      uint64_t v17 = v80;
      goto LABEL_46;
    }

    uint64_t v55 = 0LL;
    uint64_t v77 = v54;
    while (1)
    {
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v60 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v55 << 16));
        Swift::Int scalarLength = v60.scalarLength;
        unsigned int value = v60._0._value;
      }

      else
      {
        if (v52)
        {
          Swift::String::Index v57 = (uint8x16_t *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            Swift::String::Index v57 = (uint8x16_t *)_StringObject.sharedUTF8.getter(v5, v4);
          }
        }

        else
        {
          v79.i64[0] = v5;
          v79.i64[1] = v4 & 0xFFFFFFFFFFFFFFLL;
          Swift::String::Index v57 = &v79;
        }

        unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v57, v53, v55);
      }

      unsigned int v61 = value;
      Swift::Int v62 = scalarLength;
      v79.i64[0] = 0LL;
      Specialint Mapping = (uint8x16_t *)_swift_stdlib_getSpecialMapping(value, 0, &v79);
      if (SpecialMapping && v79.i64[0])
      {
        if (v79.i64[0] < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
        unint64_t v64 = specialized static String._uncheckedFromUTF8(_:isASCII:)(SpecialMapping, v79.i64[0], 0);
      }

      else
      {
        int Mapping = _swift_stdlib_getMapping(v61, 0);
        if (Mapping)
        {
          int64_t v67 = Mapping + (unint64_t)v61;
          if (v67 < 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
          }
          if (HIDWORD(v67)) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
          }
        }

        else
        {
          LODWORD(v67) = v61;
        }

        unint64_t v64 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v67);
      }

      uint64_t v68 = v64;
      unint64_t v69 = v65;
      uint8x16_t v70 = (uint8x16_t)v80;
      unint64_t v71 = HIBYTE(*((void *)&v80 + 1)) & 0xFLL;
      if ((*((void *)&v80 + 1) & 0x2000000000000000LL) == 0) {
        unint64_t v71 = v80 & 0xFFFFFFFFFFFFLL;
      }
      if (!v71 && ((unint64_t)v80 & ~*((void *)&v80 + 1) & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(*((uint64_t *)&v80 + 1));
        *(void *)&__int128 v80 = v68;
        *((void *)&v80 + 1) = v69;
        goto LABEL_59;
      }

      if ((*((void *)&v80 + 1) & 0x2000000000000000LL) == 0) {
        break;
      }
      if ((v65 & 0x2000000000000000LL) == 0) {
        goto LABEL_57;
      }
      specialized _SmallString.init(_:appending:)(v80, *((unint64_t *)&v80 + 1), v64, v65);
      if ((v73 & 1) == 0)
      {
        uint64_t v74 = v72;
        swift_bridgeObjectRelease(v70.i64[1]);
        swift_bridgeObjectRelease(v69);
        *(void *)&__int128 v80 = v70.i64[0];
        *((void *)&v80 + 1) = v74;
        uint64_t v54 = v77;
        goto LABEL_59;
      }

      uint64_t v56 = HIBYTE(v69) & 0xF;
      uint64_t v54 = v77;
LABEL_58:
      _StringGuts.append(_:)(v68, v69, 0LL, v56);
      swift_bridgeObjectRelease(v69);
LABEL_59:
      v55 += v62;
      if (v55 >= v54) {
        goto LABEL_89;
      }
    }

    if ((v65 & 0x2000000000000000LL) != 0)
    {
      uint64_t v56 = HIBYTE(v65) & 0xF;
      goto LABEL_58;
    }

uint64_t Unicode.Scalar.Properties.uppercaseMapping.getter()
{
  return Unicode.Scalar.Properties._getMapping(_:)(0);
}

uint64_t String.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)(a3 + 8) + 8LL))(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v5;
}

__objc2_class **String._nfcCodeUnits.getter(unint64_t a1, unint64_t a2)
{
  unint64_t v4 = &_swiftEmptyArrayStorage;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  specialized _StringGutsSlice._withNFCCodeUnits(_:)(a1, a2, 0LL, v2, (uint64_t *)&v4);
  return v4;
}

__objc2_class **closure #1 in String._nfcCodeUnits.getter(char a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  Swift::String result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(*a2);
  *a2 = v4;
  if ((result & 1) == 0)
  {
    Swift::String result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v4 + 16) + 1LL,  1,  v4);
    uint64_t v4 = (uint64_t)result;
    *a2 = (uint64_t)result;
  }

  unint64_t v7 = *(void *)(v4 + 16);
  unint64_t v6 = *(void *)(v4 + 24);
  if (v7 >= v6 >> 1)
  {
    Swift::String result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v6 > 1),  v7 + 1,  1,  v4);
    uint64_t v4 = (uint64_t)result;
  }

  *(void *)(v4 + 16) = v7 + 1;
  *(_BYTE *)(v4 + v7 + 32) = a1;
  *a2 = v4;
  return result;
}

void String._withNFCCodeUnits(_:)( void (*a1)(uint64_t), uint64_t a2, unint64_t a3, unint64_t a4)
{
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v4 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v4 = a3 & 0xFFFFFFFFFFFFLL;
  }
  _StringGutsSlice._withNFCCodeUnits(_:)(a1, a2, a3, a4, 0LL, v4);
}

BOOL static UInt8.> infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a2 < a1;
}

uint64_t String.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 v5 = _StringGuts.validateScalarRange(_:)(a1, a2, a3, a4);
  if (v5 >= 0x10000) {
    uint64_t v9 = v5;
  }
  else {
    uint64_t v9 = v5 | 3;
  }
  swift_bridgeObjectRetain(a4, v6, v7, v8);
  return v9;
}

Swift::Void __swiftcall _StringGutsSlice._fastNFCCheck(_:_:)(Swift::Bool *a1, Swift::UInt8 *a2)
{
  uint64_t v6 = v5;
  uint64_t v7 = v4;
  uint64_t v8 = v2;
  if ((v3 & 0x2000000000000000LL) == 0)
  {
    if ((v2 & 0x1000000000000000LL) != 0)
    {
      id v11 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v12 = v8 & 0xFFFFFFFFFFFFLL;
      if ((v4 & 0x8000000000000000LL) == 0) {
        goto LABEL_4;
      }
    }

    else
    {
      id v11 = _StringObject.sharedUTF8.getter(v2, v3);
      uint64_t v12 = v46;
      if ((v7 & 0x8000000000000000LL) == 0)
      {
LABEL_4:
        if (v12 >= v6)
        {
          uint64_t v13 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v6, (uint64_t)v11, v12);
          if (v14 < 1) {
            return;
          }
          uint64_t v15 = v13;
          uint64_t v16 = v14;
          uint64_t v17 = 0LL;
          while ((v17 & 0x8000000000000000LL) == 0)
          {
            unsigned int v20 = *(unsigned __int8 *)(v15 + v17);
            if (v20 < 0xCC)
            {
              Swift::UInt8 v18 = 0;
              if (v20 < 0xC0) {
                uint64_t v19 = 1LL;
              }
              else {
                uint64_t v19 = 2LL;
              }
            }

            else
            {
              unsigned int v21 = __clz(v20 ^ 0xFF) - 24;
              uint64_t v19 = v21;
              if (v21 == 2)
              {
                uint64_t v24 = (_BYTE *)(v17 + v15 + 1);
                int v25 = (v20 & 0x1F) << 6;
              }

              else
              {
                uint64_t v22 = v17 + v15;
                char v23 = *(_BYTE *)(v17 + v15 + 1);
                if (v19 == 3)
                {
                  uint64_t v24 = (_BYTE *)(v22 + 2);
                  int v25 = ((v20 & 0xF) << 12) | ((v23 & 0x3F) << 6);
                }

                else
                {
                  char v26 = *(_BYTE *)(v22 + 2);
                  uint64_t v24 = (_BYTE *)(v22 + 3);
                  int v25 = ((v20 & 0xF) << 18) | ((v23 & 0x3F) << 12) | ((v26 & 0x3F) << 6);
                }
              }

              unsigned int v27 = v25 | *v24 & 0x3F;
              if (v27 >= 0x300) {
                unsigned int NormData = _swift_stdlib_getNormData(v27);
              }
              else {
                unsigned int NormData = 0;
              }
              BOOL v29 = *a2 <= (NormData >> 3);
              Swift::UInt8 v18 = NormData >> 3;
              if (!v18) {
                BOOL v29 = 1;
              }
              if ((NormData & 6) != 0 || !v29) {
                goto LABEL_50;
              }
            }

            *a2 = v18;
            v17 += v19;
            if (v17 >= v16) {
              return;
            }
          }

unsigned __int8 *specialized closure #1 in _StringGutsSlice._withNFCCodeUnits(_:)( unsigned __int8 *result, uint64_t a2, unint64_t *a3)
{
  if (result && a2)
  {
    unint64_t v3 = *a3;
    do
    {
      unsigned int v15 = *result++;
      uint64_t v14 = v15;
      uint64_t v16 = HIBYTE(v3) & 7;
      char v17 = 8 * v16;
      if (v16 == 7)
      {
        unint64_t v4 = v3 & 0xFF00000000000000LL;
        uint64_t v5 = (v14 << v17) | v3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v6 = a3[4] ^ v5;
        unint64_t v7 = a3[2];
        unint64_t v8 = v7 + a3[1];
        uint64_t v9 = v8 ^ __ROR8__(v7, 51);
        uint64_t v10 = a3[3] + v6;
        uint64_t v11 = v10 ^ __ROR8__(v6, 48);
        uint64_t v12 = v11 + __ROR8__(v8, 32);
        uint64_t v13 = v10 + v9;
        a3[3] = __ROR8__(v13, 32);
        a3[4] = v12 ^ __ROR8__(v11, 43);
        a3[1] = v12 ^ v5;
        a3[2] = v13 ^ __ROR8__(v9, 47);
      }

      else
      {
        unint64_t v4 = (v14 << v17) | v3;
      }

      unint64_t v3 = v4 + 0x100000000000000LL;
      *a3 = v4 + 0x100000000000000LL;
      --a2;
    }

    while (a2);
  }

  return result;
}

__objc2_class **specialized closure #1 in _StringGutsSlice._withNFCCodeUnits(_:)( __objc2_class **result, uint64_t a2, uint64_t *a3)
{
  if (result)
  {
    uint64_t v3 = a2;
    if (a2)
    {
      uint64_t v5 = (char *)result;
      uint64_t v6 = *a3;
      do
      {
        char v7 = *v5;
        Swift::String result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(v6);
        *a3 = v6;
        if ((result & 1) == 0)
        {
          Swift::String result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v6 + 16) + 1LL,  1,  v6);
          uint64_t v6 = (uint64_t)result;
          *a3 = (uint64_t)result;
        }

        unint64_t v9 = *(void *)(v6 + 16);
        unint64_t v8 = *(void *)(v6 + 24);
        if (v9 >= v8 >> 1)
        {
          Swift::String result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v8 > 1),  v9 + 1,  1,  v6);
          uint64_t v6 = (uint64_t)result;
        }

        ++v5;
        *(void *)(v6 + 16) = v9 + 1;
        *(_BYTE *)(v6 + v9 + 32) = v7;
        *a3 = v6;
        --v3;
      }

      while (v3);
    }
  }

  return result;
}

uint64_t _StringBreadcrumbs.init(_:)(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v6 = a1;
  *(void *)(v4 + 24) = &_swiftEmptyArrayStorage;
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v7 = HIBYTE(a2) & 0xF;
  }
  else {
    unint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(a2, 8LL, a3, a4);
  if (!v7)
  {
    swift_bridgeObjectRelease_n(a2, 9LL);
    uint64_t v17 = 0LL;
    goto LABEL_49;
  }

  *(void *)(v4 + 24) = &_swiftEmptyArrayStorage;
  swift_bridgeObjectRetain_n(a2, 4LL, v8, v9);
  *(void *)(v4 + 24) = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (v7 * (unsigned __int128)0x155555555555556uLL) >> 64,  0,  (uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v13 = ((unint64_t)v6 >> 59) & 1;
  if ((a2 & 0x1000000000000000LL) == 0) {
    LODWORD(v13) = 1;
  }
  uint64_t v14 = 4 * v7;
  int v34 = v13;
  uint64_t v15 = 4LL << v13;
  if ((a2 & 0x2000000000000000LL) != 0) {
    BOOL v16 = (a2 & 0x4000000000000000LL) != 0;
  }
  else {
    BOOL v16 = v6 < 0;
  }
  swift_bridgeObjectRetain(a2, v10, v11, v12);
  uint64_t v17 = 0LL;
  Swift::UInt64 rawBits = 15LL;
  uint64_t v35 = v6;
  unint64_t v36 = v7;
  do
  {
    if ((v17 & 0x3F) == 0)
    {
      uint64_t v19 = *(__objc2_class ***)(v4 + 24);
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v19);
      *(void *)(v4 + 24) = v19;
      if (!isUniquelyReferenced_nonNull_native)
      {
        uint64_t v19 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v19[2]->isa + 1,  1,  (uint64_t)v19);
        *(void *)(v4 + 24) = v19;
      }

      unint64_t v22 = (unint64_t)v19[2];
      unint64_t v21 = (unint64_t)v19[3];
      if (v22 >= v21 >> 1) {
        uint64_t v19 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v21 > 1),  v22 + 1,  1,  (uint64_t)v19);
      }
      v19[2] = (__objc2_class *)(v22 + 1);
      v19[v22 + 4] = (__objc2_class *)rawBits;
      *(void *)(v4 + 24) = v19;
      uint64_t v6 = v35;
      unint64_t v7 = v36;
    }

    if ((rawBits & 0xC) == v15) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    Swift::UInt64 v23 = rawBits >> 16;
    if (rawBits >> 16 >= v7) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
    }
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      Swift::UInt64 rawBits = specialized String.UTF16View._foreignIndex(after:)(rawBits);
      goto LABEL_12;
    }

    if (v16)
    {
      Swift::UInt64 rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
      goto LABEL_12;
    }

    if ((rawBits & 0xC001) != 0)
    {
      if ((a2 & 0x2000000000000000LL) != 0) {
        goto LABEL_36;
      }
    }

    else
    {
      v27._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
      Swift::UInt64 rawBits = v27._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
      Swift::UInt64 v23 = v27._rawBits >> 16;
      if ((a2 & 0x2000000000000000LL) != 0)
      {
LABEL_36:
        v37[0] = v6;
        v37[1] = a2 & 0xFFFFFFFFFFFFFFLL;
        int v25 = *((unsigned __int8 *)v37 + v23);
        if ((v25 & 0x80) != 0) {
          goto LABEL_29;
        }
        goto LABEL_37;
      }
    }

    uint64_t v24 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    if ((v6 & 0x1000000000000000LL) == 0) {
      uint64_t v24 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v6, a2);
    }
    int v25 = v24[v23];
    if ((v25 & 0x80) != 0)
    {
LABEL_29:
      LODWORD(v26) = __clz(v25 ^ 0xFF) - 24;
      if ((_DWORD)v26 == 4)
      {
        if ((rawBits & 0xC000) == 0)
        {
          Swift::UInt64 rawBits = rawBits & 0xFFFFFFFFFFFF0000LL | 0x4004;
          goto LABEL_12;
        }

        uint64_t v26 = 4LL;
      }

      else
      {
        uint64_t v26 = v26;
      }

      goto LABEL_38;
    }

Swift::String::Index __swiftcall String.UTF16View.index(after:)(Swift::String::Index after)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((after._rawBits & 0xC) == 4LL << v5) {
    after._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(after)._rawBits;
  }
  Swift::UInt64 v6 = after._rawBits >> 16;
  unint64_t v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 >= v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
  }
  if ((v3 & 0x1000000000000000LL) != 0) {
    return (Swift::String::Index)specialized String.UTF16View._foreignIndex(after:)(after._rawBits);
  }
  uint64_t v8 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LODWORD(v8) = v4 < 0;
  }
  if ((_DWORD)v8 == 1) {
    return (Swift::String::Index)((after._rawBits & 0xFFFFFFFFFFFF0000LL) + 65549);
  }
  if ((after._rawBits & 0xC001) != 0)
  {
    if ((v3 & 0x2000000000000000LL) == 0) {
      goto LABEL_15;
    }
LABEL_21:
    v16[0] = v4;
    v16[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = *((unsigned __int8 *)v16 + v6);
    if ((v10 & 0x80) != 0) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }

  Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(after)._rawBits;
  after._Swift::UInt64 rawBits = rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  Swift::UInt64 v6 = rawBits >> 16;
  if ((v3 & 0x2000000000000000LL) != 0) {
    goto LABEL_21;
  }
LABEL_15:
  if ((v4 & 0x1000000000000000LL) == 0)
  {
    Swift::UInt64 v15 = after._rawBits;
    uint64_t v12 = v3;
    Swift::UInt64 v13 = v6;
    uint64_t v10 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v12);
    after._Swift::UInt64 rawBits = v15;
    LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = *(unsigned __int8 *)(v10 + v13);
    if ((v10 & 0x80) != 0) {
      goto LABEL_24;
    }
LABEL_22:
    uint64_t v10 = 1LL;
    goto LABEL_28;
  }

  LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v6);
  if ((v10 & 0x80) == 0) {
    goto LABEL_22;
  }
LABEL_24:
  LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = __clz(v10 ^ 0xFF) - 24;
  if ((_DWORD)v10 == 4)
  {
    if ((after._rawBits & 0xC000) == 0)
    {
      unsigned __int16 v14 = 16388;
      return (Swift::String::Index)(after._rawBits & 0xFFFFFFFFFFFF0000LL | v14);
    }

    uint64_t v10 = 4LL;
  }

  else
  {
    uint64_t v10 = v10;
  }

void _StringBreadcrumbs.__deallocating_deinit()
{
}

Swift::tuple_lowerBound_String_Index_offset_Int __swiftcall _StringBreadcrumbs.getBreadcrumb(forIndex:)( Swift::String::Index forIndex)
{
  Swift::UInt64 v2 = forIndex._rawBits / 0xC00000;
  uint64_t v3 = *(void *)(v1 + 24);
  Swift::UInt64 v4 = *(void *)(v3 + 16);
  if (v4 >= (forIndex._rawBits >> 22) + 1) {
    Swift::UInt64 v5 = (forIndex._rawBits >> 22) + 1;
  }
  else {
    Swift::UInt64 v5 = *(void *)(v3 + 16);
  }
  Swift::UInt64 v6 = v5 - v2;
  if ((uint64_t)(v5 - v2) < 2)
  {
LABEL_12:
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v2, 1, v3);
    forIndex._Swift::UInt64 rawBits = *(void *)(v3 + 8 * v2 + 32);
    Swift::Int v9 = v2 << 6;
  }

  else
  {
    while (1)
    {
      BOOL v7 = __OFADD__(v2, v6 >> 1);
      int64_t v8 = v2 + (v6 >> 1);
      if (v7) {
        break;
      }
      if (v8 < 0 || v8 >= (uint64_t)v4) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      if (forIndex._rawBits >> 14 < *(void *)(v3 + 32 + 8 * v8) >> 14) {
        Swift::UInt64 v5 = v8;
      }
      else {
        Swift::UInt64 v2 = v8;
      }
      Swift::UInt64 v6 = v5 - v2;
    }

    __break(1u);
  }

  result.uint64_t offset = v9;
  result.lowerBound = forIndex;
  return result;
}

id _stdlib_binary_CFStringCreateCopy(_:)(void *a1)
{
  return objc_msgSend(a1, sel_copyWithZone_, 0);
}

uint64_t _stdlib_binary_CFStringGetLength(_:)(unint64_t a1)
{
  if ((a1 & 0x8000000000000000LL) == 0 || (a1 & 0xFF80000000000007LL) != 0xC000000000000007LL) {
    return (uint64_t)objc_msgSend((id)a1, sel_length);
  }
  if ((a1 & 0x7FFFFFFFFFFFF8LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x224uLL,  0);
  }
  if ((*(_BYTE *)((a1 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
  }
  uint64_t result = *(void *)((a1 & 0x7FFFFFFFFFFFF8LL) + 0x18);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  return result;
}

uint64_t _isNSString(_:)(uint64_t a1)
{
  if ((a1 & 0x8000000000000000LL) == 0 || (a1 & 0xFF80000000000007LL) != 0xC000000000000007LL) {
    return _swift_stdlib_isNSString();
  }
  if ((a1 & 0x7FFFFFFFFFFFF8LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x224uLL,  0);
  }
  if ((*(_BYTE *)((a1 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
  }
  if ((*(void *)((a1 & 0x7FFFFFFFFFFFF8LL) + 0x18) & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  return 1LL;
}

id _stdlib_binary_CFStringGetCharactersPtr(_:)(void *a1)
{
  return objc_msgSend(a1, sel__fastCharacterContents);
}

uint64_t _NSStringCopyBytes(_:encoding:into:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v6 = 0LL;
  if (objc_msgSend( a1,  sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_,  a3,  a4 - a3,  &v6,  a2,  0,  0,  objc_msgSend(a1, sel_length),  &v7)) {
    BOOL v4 = v8 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    return v6;
  }
  else {
    return 0LL;
  }
}

uint64_t specialized _withCocoaASCIIPointer<A>(_:requireStableAddress:work:)( unint64_t a1, void (*a2)(uint64_t *__return_ptr, void *))
{
  if ((a1 & 0x8000000000000000LL) != 0)
  {
    if ((a1 & 0xFF80000000000007LL) == 0xC000000000000007LL)
    {
      if ((a1 & 0x7FFFFFFFFFFFF8LL) == 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x224uLL,  0);
      }
      if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
      {
        if ((*(_BYTE *)((a1 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) != 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
        }
        if ((*(void *)((a1 & 0x7FFFFFFFFFFFF8LL) + 0x18) & 0x8000000000000000LL) != 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
        }
        BOOL v4 = *(void **)((a1 & 0x7FFFFFFFFFFFF8LL) + 0x10);
        goto LABEL_15;
      }
    }

    unint64_t v5 = specialized _SmallString.init(taggedCocoa:)((void *)a1, 1LL);
    if ((v7 & 1) == 0)
    {
      if ((v6 & 0x2000000000000000LL) != 0)
      {
        v11[0] = v5;
        v11[1] = v6 & 0xFFFFFFFFFFFFFFLL;
        swift_unknownObjectRetain((id)a1, v6, v7, v8);
        BOOL v4 = v11;
      }

      else
      {
        if ((v5 & 0x1000000000000000LL) != 0) {
          uint64_t v9 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          uint64_t v9 = _StringObject.sharedUTF8.getter(v5, v6);
        }
        swift_unknownObjectRetain((id)a1, v6, v7, v8);
        BOOL v4 = v9;
      }

      goto LABEL_15;
    }

    swift_unknownObjectRetain((id)a1, v6, v7, v8);
  }

  BOOL v4 = objc_msgSend((id)a1, sel__fastCStringContents_, 1);
  if (!v4)
  {
    LOBYTE(v12) = 2;
    return v12;
  }

unint64_t _bridgeCocoaString(_:)(unint64_t a1)
{
  unint64_t v1 = a1;
  if ((a1 & 0x8000000000000000LL) != 0)
  {
    if ((a1 & 0xFF80000000000007LL) != 0xC000000000000007LL) {
      goto LABEL_18;
    }
    if ((a1 & 0x7FFFFFFFFFFFF8LL) == 0)
    {
      unint64_t v23 = 548LL;
      goto LABEL_31;
    }

    if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
    {
      if ((*(_BYTE *)((v1 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) != 0) {
        goto LABEL_26;
      }
      if ((*(void *)((v1 & 0x7FFFFFFFFFFFF8LL) + 0x18) & 0x8000000000000000LL) != 0) {
        goto LABEL_27;
      }
      if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
      {
        if ((*(_BYTE *)((v1 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) == 0)
        {
          uint64_t v15 = *(void *)((v1 & 0x7FFFFFFFFFFFF8LL) + 0x18);
          if ((v15 & 0x8000000000000000LL) == 0)
          {
            unint64_t v14 = v15 | 0xC000000000000000LL;
            unint64_t v1 = v1 & 0x7FFFFFFFFFFFF8LL | 0x5000000000000000LL;
LABEL_22:
            swift_bridgeObjectRetain(v1, v3, v4, v5);
            return v14;
          }

unint64_t String.init(_cocoaString:)(void *a1)
{
  unint64_t v2 = _bridgeCocoaString(_:)((unint64_t)a1);
  swift_unknownObjectRelease(a1);
  return v2;
}

Swift::Void __swiftcall _StringGuts.grow(_:)(Swift::Int a1)
{
  unint64_t v2 = v1;
  uint64_t v4 = _StringGuts.uniqueNativeCapacity.getter();
  if ((v5 & 1) != 0)
  {
    unint64_t v7 = v1[1];
    if ((v7 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v6 = String.UTF8View._foreignCount()();
    }

    else if ((v7 & 0x2000000000000000LL) != 0)
    {
      Swift::Int v6 = HIBYTE(v7) & 0xF;
    }

    else
    {
      Swift::Int v6 = *v1 & 0xFFFFFFFFFFFFLL;
    }
  }

  else
  {
    Swift::Int v6 = 2 * v4;
  }

  if (v6 <= a1) {
    Swift::Int v8 = a1;
  }
  else {
    Swift::Int v8 = v6;
  }
  unint64_t v9 = v2[1];
  if ((v9 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignGrow(_:)(v8);
  }

  else
  {
    uint64_t v10 = *v2;
    if ((v9 & 0x2000000000000000LL) != 0)
    {
      size_t v14 = HIBYTE(v9) & 0xF;
      v19[0] = *v2;
      v19[1] = v9 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v15 = v14 | 0xC000000000000000LL;
      if ((v9 & 0x4000000000000000LL) == 0) {
        unint64_t v15 = HIBYTE(v9) & 0xF;
      }
      uint64_t v16 = v15 | 0x3000000000000000LL;
      int64_t v13 = _allocateStringStorage(codeUnitCapacity:)(v8);
      *(void *)(v13 + 16) = v17;
      *(void *)(v13 + 24) = v16;
      if (v17 < 0)
      {
        *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
        uint64_t v16 = *(void *)(v13 + 24);
      }

      *(_BYTE *)(v13 + 32 + (v16 & 0xFFFFFFFFFFFFLL)) = 0;
      specialized UnsafeMutablePointer.initialize(from:count:)((char *)v19, v14, (char *)(v13 + 32));
    }

    else
    {
      if ((v10 & 0x1000000000000000LL) != 0)
      {
        uint64_t v11 = (char *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        size_t v12 = v10 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v11 = (char *)_StringObject.sharedUTF8.getter(*v2, v9);
      }

      int64_t v13 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(v11, v12, v8, v10 < 0);
    }

    uint64_t v18 = *(void *)(v13 + 24);
    swift_bridgeObjectRelease(v2[1]);
    uint64_t *v2 = v18;
    v2[1] = v13;
  }

unint64_t _StringObject.isImmortal.getter(uint64_t a1, unint64_t a2)
{
  return a2 >> 63;
}

id _StringObject.fastUTF8.getter(uint64_t a1, uint64_t a2)
{
  if ((a1 & 0x1000000000000000LL) != 0) {
    return (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
  }
  else {
    return _StringObject.sharedUTF8.getter(a1, a2);
  }
}

unint64_t _StringObject.CountAndFlags.isASCII.getter(unint64_t a1)
{
  return a1 >> 63;
}

BOOL _StringObject.hasObjCBridgeableObject.getter(uint64_t a1, uint64_t a2)
{
  return a2 >= 0;
}

unint64_t _SwiftCreateBridgedString_DoNotCall(bytes:length:encoding:)( uint8x16_t *a1, uint64_t a2, int a3)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (a3 == 1536)
  {
    uint64_t v8 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, a2, 1LL);
    if (!v9) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
    }
  }

  else
  {
    if (a3 != 134217984) {
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD00000000000001CLL,  0x80000001818B7470LL,  "Swift/StringBridge.swift",  24LL,  2,  0x2DCuLL,  0);
    }
    int64_t v5 = validateUTF8(_:)(a1->i64, a2);
    if ((v7 & 1) != 0) {
      uint64_t v8 = repairUTF8(_:firstKnownBrokenRange:)(a1->i8, a2, v5, v6);
    }
    else {
      uint64_t v8 = specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v5 & 1);
    }
  }

  uint64_t v12 = v9;
  unint64_t v13 = String._bridgeToObjectiveCImpl()(v8, v9, v10, v11);
  swift_bridgeObjectRelease(v12);
  return v13;
}

uint64_t __SwiftNativeNSString.deinit()
{
  return v0;
}

unint64_t swift_stdlib_getDescription(uint64_t a1, swift *a2)
{
  uint64_t v3 = *((void *)a2 - 1);
  MEMORY[0x1895F8858](a1);
  int64_t v5 = (char *)&v11 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v3 + 16))(v5);
  uint64_t v11 = 0LL;
  unint64_t v12 = 0xE000000000000000LL;
  _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)v5,  (uint64_t)&v11,  a2,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  (*(void (**)(char *, swift *))(v3 + 8))(v5, a2);
  uint64_t v6 = v12;
  unint64_t v9 = String._bridgeToObjectiveCImpl()(v11, v12, v7, v8);
  swift_bridgeObjectRelease(v6);
  return v9;
}

unint64_t swift_stdlib_NSStringFromUTF8(uint8x16_t *a1, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  int64_t v4 = validateUTF8(_:)(a1->i64, a2);
  if ((v6 & 1) != 0) {
    uint64_t v7 = repairUTF8(_:firstKnownBrokenRange:)(a1->i8, a2, v4, v5);
  }
  else {
    uint64_t v7 = specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v4 & 1);
  }
  uint64_t v11 = v8;
  unint64_t v12 = String._bridgeToObjectiveCImpl()(v7, v8, v9, v10);
  swift_bridgeObjectRelease(v11);
  return v12;
}

Swift::Int __swiftcall StringProtocol._toUTF16Offset(_:)(Swift::String::Index a1)
{
  uint64_t v4 = (uint64_t)v2;
  int64_t v5 = (ValueMetadata *)v1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v2,  v1,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UTF16View);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unint64_t v13 = (char *)&v20 - v12;
  if (v5 == &type metadata for String)
  {
    v19._Swift::UInt64 rawBits = 15LL;
  }

  else
  {
    if (v5 != &type metadata for Substring)
    {
      size_t v14 = *(void (**)(ValueMetadata *, uint64_t))(v4 + 128);
      v14(v5, v4);
      v14(v5, v4);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v4,  (uint64_t)v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UTF16View: BidirectionalCollection);
      (*(void (**)(uint64_t *__return_ptr, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                      + 64LL))( &v23,  AssociatedTypeWitness);
      uint64_t v16 = *(void (**)(char *, unint64_t))(v8 + 8);
      v16(v11, AssociatedTypeWitness);
      Swift::UInt64 rawBits = a1._rawBits;
      uint64_t v22 = v23;
      Swift::Int v17 = (*(uint64_t (**)(uint64_t *, Swift::UInt64 *, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))( &v22,  &rawBits,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      v16(v13, AssociatedTypeWitness);
      return v17;
    }

    v19._Swift::UInt64 rawBits = *v3;
  }

  return String.UTF16View.distance(from:to:)(v19, a1);
}

Swift::String::Index __swiftcall StringProtocol._toUTF16Index(_:)(Swift::Int a1)
{
  uint64_t v4 = (uint64_t)v2;
  int64_t v5 = (ValueMetadata *)v1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v2,  v1,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UTF16View);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unint64_t v13 = (char *)&v19 - v12;
  if (v5 == &type metadata for String)
  {
    v18._Swift::UInt64 rawBits = 15LL;
  }

  else
  {
    if (v5 != &type metadata for Substring)
    {
      size_t v14 = *(void (**)(ValueMetadata *, uint64_t))(v4 + 128);
      v14(v5, v4);
      v14(v5, v4);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v4,  (uint64_t)v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UTF16View: BidirectionalCollection);
      (*(void (**)(uint64_t *__return_ptr, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                      + 64LL))( &v21,  AssociatedTypeWitness);
      uint64_t v16 = *(void (**)(char *, unint64_t))(v8 + 8);
      v16(v11, AssociatedTypeWitness);
      uint64_t v20 = v21;
      (*(void (**)(Swift::String::Index *__return_ptr, uint64_t *, Swift::Int, unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( &v22,  &v20,  a1,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      v16(v13, AssociatedTypeWitness);
      return v22;
    }

    v18._Swift::UInt64 rawBits = *v3;
  }

  return String.UTF16View.index(_:offsetBy:)(v18, a1);
}

Swift::Int StringProtocol._toUTF16Offsets(_:)( Swift::String::Index a1, Swift::String::Index a2, ValueMetadata *a3, char *a4)
{
  if (a3 == &type metadata for String)
  {
    uint64_t v9 = *v4;
    unint64_t v8 = v4[1];
    swift_bridgeObjectRetain(v8, a2._rawBits, (uint64_t)a3, a4);
    v10._Swift::UInt64 rawBits = a1._rawBits;
    v11._Swift::UInt64 rawBits = a2._rawBits;
    v12._Swift::UInt64 rawBits = 15LL;
    uint64_t v13 = v9;
LABEL_7:
    Swift::Int v7 = String.UTF16View._offsetRange(for:from:)(v10, v11, v12, v13, v8);
    swift_bridgeObjectRelease(v8);
    return v7;
  }

  if (a3 == &type metadata for Substring)
  {
    Swift::UInt64 v14 = *v4;
    uint64_t v15 = v4[2];
    unint64_t v8 = v4[3];
    swift_bridgeObjectRetain(v8, a2._rawBits, (uint64_t)a3, a4);
    v10._Swift::UInt64 rawBits = a1._rawBits;
    v11._Swift::UInt64 rawBits = a2._rawBits;
    v12._Swift::UInt64 rawBits = v14;
    uint64_t v13 = v15;
    goto LABEL_7;
  }

  Swift::Int v7 = StringProtocol._toUTF16Offset(_:)(a1);
  if (StringProtocol._toUTF16Offset(_:)(a2) < v7) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  return v7;
}

Swift::UInt64 String.UTF16View._offsetRange(for:from:)( Swift::String::Index a1, Swift::String::Index a2, Swift::String::Index from, uint64_t a4, unint64_t a5)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v10 = ((unint64_t)a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((a1._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if ((a2._rawBits & 0xC) == v11) {
    a2._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  }
  Swift::UInt64 v12 = rawBits >> 16;
  if ((a5 & 0x2000000000000000LL) != 0) {
    Swift::UInt64 v13 = HIBYTE(a5) & 0xF;
  }
  else {
    Swift::UInt64 v13 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v13 < v12 && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u))
  {
    unint64_t v22 = 368LL;
    goto LABEL_39;
  }

  Swift::UInt64 v14 = a2._rawBits >> 16;
  if (v13 < a2._rawBits >> 16 && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u))
  {
    unint64_t v22 = 372LL;
LABEL_39:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  v22,  0);
  }

  if ((a5 & 0x1000000000000000LL) != 0)
  {
    from._Swift::UInt64 rawBits = specialized String.UTF16View._foreignDistance(from:to:)(from._rawBits, rawBits);
    unint64_t v23 = specialized String.UTF16View._foreignDistance(from:to:)(rawBits, a2._rawBits);
    uint64_t v19 = from._rawBits + v23;
    if (__OFADD__(from._rawBits, v23))
    {
      __break(1u);
      goto LABEL_43;
    }

Swift::UInt64 StringProtocol._toUTF16Indices(_:)(Swift::Int a1, uint64_t a2, ValueMetadata *a3, char *a4)
{
  if (a3 == &type metadata for String)
  {
    uint64_t v9 = *v4;
    unint64_t v8 = v4[1];
    swift_bridgeObjectRetain(v8, a2, (uint64_t)a3, a4);
    Swift::Int v10 = a1;
    uint64_t v11 = a2;
    v12._Swift::UInt64 rawBits = 15LL;
    uint64_t v13 = v9;
LABEL_7:
    v7._Swift::UInt64 rawBits = String.UTF16View._indexRange(for:from:)(v10, v11, v12, v13, v8);
    swift_bridgeObjectRelease(v8);
    return v7._rawBits;
  }

  if (a3 == &type metadata for Substring)
  {
    Swift::UInt64 v14 = *v4;
    uint64_t v15 = v4[2];
    unint64_t v8 = v4[3];
    swift_bridgeObjectRetain(v8, a2, (uint64_t)a3, a4);
    Swift::Int v10 = a1;
    uint64_t v11 = a2;
    v12._Swift::UInt64 rawBits = v14;
    uint64_t v13 = v15;
    goto LABEL_7;
  }

  v7._Swift::UInt64 rawBits = StringProtocol._toUTF16Index(_:)(a1)._rawBits;
  if (StringProtocol._toUTF16Index(_:)(a2)._rawBits >> 14 < v7._rawBits >> 14) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  return v7._rawBits;
}

Swift::Int String.UTF16View._indexRange(for:from:)( Swift::Int offsetBy, uint64_t a2, Swift::String::Index a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9 = offsetBy;
  if ((a5 & 0x1000000000000000LL) == 0)
  {
    uint64_t v10 = (a5 >> 62) & 1;
    if ((a5 & 0x2000000000000000LL) == 0) {
      LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = a4 < 0;
    }
    if ((_DWORD)v10 == 1)
    {
      offsetBy = String.UTF16View.index(_:offsetBy:)(a3, offsetBy)._rawBits;
      if (!__OFSUB__(a2, v9))
      {
        Swift::UInt64 rawBits = offsetBy;
        v12._Swift::UInt64 rawBits = String.UTF16View.index(_:offsetBy:)((Swift::String::Index)offsetBy, a2 - v9)._rawBits;
        goto LABEL_18;
      }

      __break(1u);
      goto LABEL_24;
    }

    if (__OFSUB__(a2, offsetBy))
    {
LABEL_24:
      __break(1u);
LABEL_25:
      __break(1u);
      goto LABEL_26;
    }

    if (a2 - offsetBy <= 31)
    {
      v13._Swift::UInt64 rawBits = String.UTF16View.index(_:offsetBy:)(a3, offsetBy)._rawBits;
      Swift::UInt64 rawBits = v13._rawBits;
      if (specialized BidirectionalCollection._index(_:offsetBy:)(v13, a2 - v9, a4, a5) >> 14 >= v13._rawBits >> 14) {
        return rawBits;
      }
      goto LABEL_22;
    }

    offsetBy = String.UTF16View._nativeGetOffset(for:)(a3);
    if (__OFSUB__(v9, offsetBy)) {
      goto LABEL_25;
    }
    Swift::Int v14 = offsetBy;
    if (v9 - offsetBy <= 32)
    {
      v16._Swift::UInt64 rawBits = a3._rawBits;
      v15._Swift::UInt64 rawBits = specialized BidirectionalCollection._index(_:offsetBy:)(v16, v9, a4, a5);
    }

    else
    {
      offsetBy += v9;
      if (__OFADD__(v14, v9))
      {
LABEL_27:
        __break(1u);
        goto LABEL_28;
      }

      v15._Swift::UInt64 rawBits = String.UTF16View._nativeGetIndex(for:)(offsetBy)._rawBits;
    }

    Swift::UInt64 rawBits = v15._rawBits;
    offsetBy = v14 + a2;
    if (__OFADD__(v14, a2))
    {
LABEL_26:
      __break(1u);
      goto LABEL_27;
    }

    v12._Swift::UInt64 rawBits = String.UTF16View._nativeGetIndex(for:)(offsetBy)._rawBits;
LABEL_18:
    if (v12._rawBits >> 14 >= rawBits >> 14) {
      return rawBits;
    }
LABEL_22:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }

  offsetBy = String.UTF16View.index(_:offsetBy:)(a3, offsetBy)._rawBits;
  if (!__OFSUB__(a2, v9))
  {
    Swift::UInt64 rawBits = offsetBy;
    v12._Swift::UInt64 rawBits = String.UTF16View._foreignIndex(_:offsetBy:)((Swift::String::Index)offsetBy, a2 - v9)._rawBits;
    goto LABEL_18;
  }

unint64_t String._copyUTF16CodeUnits(into:range:)( unint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, unint64_t a6)
{
  v12._Swift::UInt64 rawBits = 15LL;
  Swift::Int v13 = String.UTF16View._indexRange(for:from:)(a3, (uint64_t)a4, v12, a5, a6);
  unint64_t v15 = v14;
  swift_bridgeObjectRelease(a6);
  return String.UTF16View._nativeCopy(into:alignedRange:)(a1, a2, v13, v15, a5, a6);
}

unint64_t String.UTF16View._nativeCopy(into:alignedRange:)( unint64_t result, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((a4 ^ a3) < 0x4000) {
    return result;
  }
  uint64_t v8 = a2;
  uint64_t v9 = (uint16x8_t *)result;
  if ((a6 & 0x2000000000000000LL) == 0)
  {
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      uint64_t v10 = (a6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    }

    else
    {
      unint64_t v54 = a4;
      uint64_t result = (unint64_t)_StringObject.sharedUTF8.getter(a5, a6);
      a4 = v54;
      uint64_t v10 = result;
    }

    uint64_t v11 = a3 >> 16;
    uint64_t v12 = a4 >> 16;
    if ((a5 & 0x8000000000000000LL) == 0)
    {
      if ((a3 & 0xC000) != 0)
      {
        __int16 v55 = a4;
        uint64_t v56 = _decodeScalar(_:startingAt:)(v10, a2, a3 >> 16);
        uint64_t v58 = v57;
        uint64_t result = Unicode.Scalar.UTF16View.subscript.getter(1LL, v56);
        if (v8 <= 0) {
          goto LABEL_89;
        }
        v9->i16[0] = result;
        v11 += v58;
        if (v11 >= v12)
        {
          if ((v55 & 0xC000) == 0x4000LL)
          {
            uint64_t v13 = 1LL;
LABEL_44:
            uint64_t result = _decodeScalar(_:startingAt:)(v10, a2, v11);
            if (result < 0x10000
              || (uint64_t result = (unsigned __int16)((result + 67043328) >> 10) + 55296,
                  (result & 0x10000) == 0))
            {
              if (v13 < v8)
              {
                v9->i16[v13] = result;
                return result;
              }

uint64_t _StringGuts.endIndex.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1;
  }
  uint64_t v3 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v3 = 11LL;
  }
  return v3 | (v2 << 16);
}

Swift::Int String.count.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1;
  }
  uint64_t v3 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v3 = 11LL;
  }
  return String.distance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)(v3 | (v2 << 16)));
}

Swift::Int __swiftcall String.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v4 = v3;
  uint64_t v5 = v2;
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(from)._rawBits;
  v8._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(to)._rawBits;
  uint64_t v9 = v7._rawBits >> 16;
  if (v7._rawBits >> 14 < v8._rawBits >> 14)
  {
    int64_t v10 = v8._rawBits >> 16;
    if (v9 < v8._rawBits >> 16)
    {
      Swift::Int v11 = 1LL;
      if ((v4 & 0x1000000000000000LL) == 0) {
        goto LABEL_6;
      }
LABEL_19:
      int64_t v14 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9) + v9;
      while (v14 < v10)
      {
        ++v11;
        uint64_t v9 = v14;
        if ((v4 & 0x1000000000000000LL) != 0) {
          goto LABEL_19;
        }
LABEL_6:
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v25 = v5;
          uint64_t v26 = v4 & 0xFFFFFFFFFFFFFFLL;
          int64_t v14 = v9 + 1;
          if (v9 + 1 != (HIBYTE(v4) & 0xF))
          {
            int v16 = *(unsigned __int16 *)((char *)&v25 + v9);
            if (v16 == 2573 || (v16 & 0x80808080) != 0) {
              goto LABEL_19;
            }
          }
        }

        else
        {
          uint64_t v12 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v13 = v5 & 0xFFFFFFFFFFFFLL;
          if ((v5 & 0x1000000000000000LL) == 0) {
            uint64_t v12 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int64_t v14 = v9 + 1;
          if (v9 + 1 != v13)
          {
            if (!v12) {
              goto LABEL_43;
            }
            int v15 = *(unsigned __int16 *)&v12[v9];
            if (v15 == 2573 || (v15 & 0x80808080) != 0) {
              goto LABEL_19;
            }
          }
        }
      }

      return v11;
    }

    return 0LL;
  }

  if (v8._rawBits >> 14 >= v7._rawBits >> 14) {
    return 0LL;
  }
  int64_t v18 = v8._rawBits >> 16;
  if (v8._rawBits >> 16 >= v9) {
    return 0LL;
  }
  Swift::Int v11 = -1LL;
  if (v9 >= 2) {
    goto LABEL_28;
  }
  while (1)
  {
    Swift::Int v19 = 1LL;
LABEL_26:
    v9 -= v19;
    if (v18 >= v9) {
      return v11;
    }
    while (1)
    {
      --v11;
      if (v9 < 2) {
        break;
      }
LABEL_28:
      if ((v4 & 0x1000000000000000LL) != 0) {
        goto LABEL_41;
      }
      if ((v4 & 0x2000000000000000LL) != 0)
      {
        uint64_t v25 = v5;
        uint64_t v26 = v4 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v21 = (char *)&v25 + v9;
      }

      else
      {
        Swift::Int v20 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v5 & 0x1000000000000000LL) == 0)
        {
          Swift::Int v20 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
          if (!v20) {
LABEL_43:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }

        unint64_t v21 = &v20[v9];
      }

      int v22 = *((unsigned __int16 *)v21 - 1);
      if (v22 == 2573 || (v22 & 0x80808080) != 0)
      {
LABEL_41:
        Swift::Int v19 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v9);
        goto LABEL_26;
      }

      if (v18 >= --v9) {
        return v11;
      }
    }
  }

Swift::Bool __swiftcall String._isValidIndex(_:)(Swift::String::Index a1)
{
  uint64_t v3 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v3) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v3) {
    return 0;
  }
  Swift::UInt64 v4 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v4 = v1 & 0xFFFFFFFFFFFFLL;
  }
  return v4 >= a1._rawBits >> 16 && _StringGuts.isOnGraphemeClusterBoundary(_:)(a1);
}

Swift::Bool __swiftcall _StringGuts.isOnGraphemeClusterBoundary(_:)(Swift::String::Index a1)
{
  if ((a1._rawBits & 2) != 0) {
    return 1;
  }
  if ((a1._rawBits & 0xC000) != 0) {
    return 0;
  }
  if (a1._rawBits < 0x10000) {
    return 1;
  }
  uint64_t v5 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v5 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 == a1._rawBits >> 16) {
    return 1;
  }
  if (!_StringGuts.isOnUnicodeScalarBoundary(_:)(a1)) {
    return 0;
  }
  return (_StringGuts._slowRoundDownToNearestCharacter(_:)((Swift::String::Index)(a1._rawBits | 1))._rawBits ^ a1._rawBits) < 0x4000;
}

Swift::String::Index __swiftcall _StringGuts.validateCharacterIndex(_:)(Swift::String::Index result)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((result._rawBits & 2) == 0 || (result._rawBits & 0xC) == 4LL << v5)
  {
    result._Swift::UInt64 rawBits = _StringGuts.validateSubscalarIndex(_:)(result)._rawBits;
    if ((result._rawBits & 1) != 0)
    {
      if ((result._rawBits & 2) != 0) {
        return result;
      }
    }

    else
    {
      Swift::UInt64 v7 = result._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(result)._rawBits & 0xFFFFFFFFFFFFFFF3LL;
      result._Swift::UInt64 rawBits = v7 | 1;
      if ((v7 & 2) != 0) {
        return result;
      }
    }

    if (result._rawBits < 0x10000) {
      return (Swift::String::Index)(result._rawBits | 3);
    }
    uint64_t v8 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000LL) == 0) {
      uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (result._rawBits >> 16 == v8) {
      return (Swift::String::Index)(result._rawBits | 3);
    }
    else {
      return _StringGuts._slowRoundDownToNearestCharacter(_:)(result);
    }
  }

  else
  {
    Swift::UInt64 v6 = HIBYTE(v2) & 0xF;
    if ((v2 & 0x2000000000000000LL) == 0) {
      Swift::UInt64 v6 = v1 & 0xFFFFFFFFFFFFLL;
    }
    if (v6 <= result._rawBits >> 16) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xFEuLL,  0);
    }
  }

  return result;
}

Swift::String::Index __swiftcall String._uncheckedIndex(after:)(Swift::String::Index after)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 v6 = (after._rawBits >> 8) & 0x3F;
  uint64_t v7 = v2 & 0x2000000000000000LL;
  uint64_t v8 = HIBYTE(v2) & 0xF;
  uint64_t v9 = v1 & 0xFFFFFFFFFFFFLL;
  if (v6) {
    goto LABEL_21;
  }
  if (v7) {
    uint64_t v10 = HIBYTE(v2) & 0xF;
  }
  else {
    uint64_t v10 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (after._rawBits >> 14 == 4 * v10)
  {
    Swift::UInt64 v6 = 0LL;
    goto LABEL_21;
  }

  Swift::UInt64 v11 = after._rawBits >> 16;
  if ((v2 & 0x1000000000000000LL) == 0)
  {
    if (v7)
    {
      uint64_t v30 = v1;
      uint64_t v31 = v2 & 0xFFFFFFFFFFFFFFLL;
      if (v11 + 1 == v8 || (int v15 = *(unsigned __int16 *)((char *)&v30 + v11), v15 != 2573) && (v15 & 0x80808080) == 0)
      {
        uint64_t v7 = 1LL;
        goto LABEL_20;
      }
    }

    else
    {
      if ((v1 & 0x1000000000000000LL) != 0)
      {
        uint64_t v12 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v13 = v1 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v12 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
        Swift::UInt64 v11 = after._rawBits >> 16;
      }

      if (v11 + 1 == v13) {
        goto LABEL_15;
      }
      if (!v12) {
        goto LABEL_52;
      }
      int v14 = *(unsigned __int16 *)&v12[v11];
      if (v14 != 2573 && (v14 & 0x80808080) == 0)
      {
LABEL_15:
        uint64_t v7 = 0LL;
LABEL_20:
        Swift::UInt64 v6 = 1LL;
        goto LABEL_21;
      }
    }
  }

  Swift::UInt64 v6 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v11);
LABEL_21:
  Swift::UInt64 v16 = after._rawBits + (v6 << 16);
  unint64_t v17 = v16 & 0xFFFFFFFFFFFF0000LL;
  if (v7) {
    uint64_t v18 = v8;
  }
  else {
    uint64_t v18 = v9;
  }
  uint64_t v19 = v3 & 0x1000000000000000LL;
  if (v17 >> 14 == 4 * v18)
  {
    Swift::Int v20 = 0LL;
LABEL_42:
    v17 |= v20 << 8;
    goto LABEL_43;
  }

  Swift::Int v21 = v16 >> 16;
  if (!v19)
  {
    if (v7)
    {
      uint64_t v30 = v4;
      uint64_t v31 = v3 & 0xFFFFFFFFFFFFFFLL;
      if (v21 + 1 != v8)
      {
        int v22 = *(unsigned __int16 *)((char *)&v30 + v21);
        if (v22 == 2573 || (v22 & 0x80808080) != 0) {
          goto LABEL_33;
        }
      }

Swift::Int __swiftcall String._characterStride(startingAt:)(Swift::String::Index startingAt)
{
  Swift::Int result = (startingAt._rawBits >> 8) & 0x3F;
  if (!result)
  {
    uint64_t v5 = v1 & 0xFFFFFFFFFFFFLL;
    if ((v2 & 0x2000000000000000LL) != 0) {
      uint64_t v6 = HIBYTE(v2) & 0xF;
    }
    else {
      uint64_t v6 = v1 & 0xFFFFFFFFFFFFLL;
    }
    if (startingAt._rawBits >> 14 == 4 * v6) {
      return 0LL;
    }
    Swift::UInt64 v7 = startingAt._rawBits >> 16;
    if ((v2 & 0x1000000000000000LL) == 0)
    {
      if ((v2 & 0x2000000000000000LL) != 0)
      {
        v12[0] = v1;
        v12[1] = v2 & 0xFFFFFFFFFFFFFFLL;
        if (v7 + 1 == (HIBYTE(v2) & 0xF)) {
          return 1LL;
        }
        int v9 = *(unsigned __int16 *)((char *)v12 + v7);
      }

      else
      {
        if ((v1 & 0x1000000000000000LL) != 0)
        {
          uint64_t v8 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          Swift::UInt64 v11 = startingAt._rawBits >> 16;
          uint64_t v8 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
          Swift::UInt64 v7 = v11;
          uint64_t v5 = v10;
        }

        if (v7 + 1 == v5) {
          return 1LL;
        }
        if (!v8) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }
        int v9 = *(unsigned __int16 *)&v8[v7];
      }

      if (v9 != 2573 && (v9 & 0x80808080) == 0) {
        return 1LL;
      }
    }

    return _StringGuts._opaqueComplexCharacterStride(startingAt:)(v7);
  }

  return result;
}

Swift::String::Index __swiftcall String.Index.init(_encodedOffset:)(Swift::Int _encodedOffset)
{
  return (Swift::String::Index)(_encodedOffset << 16);
}

Swift::String::Index __swiftcall String.Index.init(encodedOffset:characterStride:)( Swift::Int encodedOffset, Swift::Int characterStride)
{
  Swift::Int v2 = characterStride << 8;
  return (Swift::String::Index)(v2 | (encodedOffset << 16));
}

Swift::String::Index __swiftcall _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(Swift::String::Index a1)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 2) != 0 && (a1._rawBits & 0xC) != 4LL << v6)
  {
    Swift::UInt64 v7 = HIBYTE(v2) & 0xF;
    if ((v2 & 0x2000000000000000LL) == 0) {
      Swift::UInt64 v7 = v1 & 0xFFFFFFFFFFFFLL;
    }
    if (v7 < a1._rawBits >> 16)
    {
      if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x188uLL,  0);
      }
    }

    return v5;
  }

  v8._Swift::UInt64 rawBits = _StringGuts.validateInclusiveSubscalarIndex_5_7(_:)(a1)._rawBits;
  v5._Swift::UInt64 rawBits = v8._rawBits;
  if ((v8._rawBits & 1) != 0)
  {
    if ((v8._rawBits & 2) != 0) {
      return v5;
    }
  }

  else
  {
    Swift::UInt64 v10 = v8._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL;
    v5._Swift::UInt64 rawBits = v10 | 1;
    if ((v10 & 2) != 0) {
      return v5;
    }
  }

  if (v5._rawBits < 0x10000) {
    return (Swift::String::Index)(v5._rawBits | 3);
  }
  uint64_t v11 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    uint64_t v11 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v5._rawBits >> 16 == v11) {
    return (Swift::String::Index)(v5._rawBits | 3);
  }
  return _StringGuts._slowRoundDownToNearestCharacter(_:)(v5);
}

Swift::String::Index __swiftcall String._uncheckedIndex(before:)(Swift::String::Index before)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  if (before._rawBits < 0x4000)
  {
    Swift::Int v6 = 0LL;
LABEL_15:
    Swift::Int v10 = v6 << 8;
    goto LABEL_19;
  }

  Swift::Int v6 = before._rawBits >> 16;
  if (before._rawBits >= 0x20000)
  {
    if ((v2 & 0x1000000000000000LL) == 0)
    {
      if ((v2 & 0x2000000000000000LL) != 0)
      {
        v14[0] = v1;
        v14[1] = v2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt64 v7 = v14;
      }

      else if ((v1 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v7 = (void *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        Swift::UInt64 v13 = before._rawBits >> 16;
        Swift::UInt64 v7 = _StringObject.sharedUTF8.getter(v1, v2);
        Swift::Int v6 = before._rawBits >> 16;
        if (!v7) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }
      }

      int v8 = *(unsigned __int16 *)((char *)v7 + v6 - 2);
      if (v8 != 2573 && (v8 & 0x80808080) == 0)
      {
        Swift::Int v6 = 1LL;
        goto LABEL_15;
      }
    }

    Swift::Int v6 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v6);
  }

  Swift::Int v10 = v6 << 8;
  if (v6 > 63) {
    Swift::Int v10 = 0LL;
  }
LABEL_19:
  uint64_t v11 = 7LL;
  if (((v3 >> 60) & ((v4 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v11 = 11LL;
  }
  return (Swift::String::Index)(v10 | (before._rawBits - (v6 << 16)) & 0xFFFFFFFFFFFF0000LL | v11);
}

Swift::Int __swiftcall String._characterStride(endingAt:)(Swift::String::Index endingAt)
{
  if (endingAt._rawBits < 0x4000) {
    return 0LL;
  }
  Swift::Int result = endingAt._rawBits >> 16;
  if (endingAt._rawBits >= 0x20000)
  {
    if ((v2 & 0x1000000000000000LL) != 0) {
      return _StringGuts._opaqueComplexCharacterStride(endingAt:)(result);
    }
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      v9[0] = v1;
      v9[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      Swift::String::Index v5 = v9;
    }

    else if ((v1 & 0x1000000000000000LL) != 0)
    {
      Swift::String::Index v5 = (void *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      Swift::Int v8 = result;
      Swift::String::Index v5 = _StringObject.sharedUTF8.getter(v1, v2);
      Swift::Int result = v8;
      if (!v5) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      }
    }

    int v6 = *(unsigned __int16 *)((char *)v5 + result - 2);
    if (v6 != 2573 && (v6 & 0x80808080) == 0) {
      return 1LL;
    }
    else {
      return _StringGuts._opaqueComplexCharacterStride(endingAt:)(result);
    }
  }

  return result;
}

Swift::String::Index __swiftcall String.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v4 = v3;
  uint64_t v5 = v2;
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(_)._rawBits;
  if (offsetBy < 0)
  {
    Swift::Int v31 = 0LL;
    if (((v4 >> 60) & ((v5 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v32 = 11LL;
    }
    else {
      uint64_t v32 = 7LL;
    }
    while (1)
    {
      if (!(v7._rawBits >> 14))
      {
        unint64_t v33 = 163LL;
LABEL_75:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  v33,  0);
      }

      uint64_t v34 = v7._rawBits >> 16;
      if (v7._rawBits < 0x20000) {
        goto LABEL_55;
      }
      if ((v4 & 0x1000000000000000LL) != 0) {
        break;
      }
      if ((v4 & 0x2000000000000000LL) != 0)
      {
        uint64_t v43 = v5;
        uint64_t v44 = v4 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v38 = (char *)&v43 + v34;
      }

      else
      {
        uint16x8_t v37 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v5 & 0x1000000000000000LL) == 0)
        {
          uint16x8_t v37 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
          if (!v37) {
LABEL_72:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }

        unint64_t v38 = &v37[v34];
      }

      int v39 = *((unsigned __int16 *)v38 - 1);
      if (v39 == 2573 || (v39 & 0x80808080) != 0) {
        break;
      }
      Swift::UInt64 v35 = v7._rawBits - 0x10000;
      uint64_t v36 = 256LL;
LABEL_57:
      --v31;
      v7._Swift::UInt64 rawBits = v36 | v32 | v35 & 0xFFFFFFFFFFFF0000LL;
      if (v31 <= offsetBy) {
        return v7;
      }
    }

    uint64_t v34 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v7._rawBits >> 16);
LABEL_55:
    Swift::UInt64 v35 = v7._rawBits - (v34 << 16);
    uint64_t v36 = v34 << 8;
    if (v34 > 63) {
      uint64_t v36 = 0LL;
    }
    goto LABEL_57;
  }

  if (offsetBy)
  {
    uint64_t v8 = HIBYTE(v4) & 0xF;
    if ((v4 & 0x2000000000000000LL) != 0) {
      uint64_t v9 = HIBYTE(v4) & 0xF;
    }
    else {
      uint64_t v9 = v5 & 0xFFFFFFFFFFFFLL;
    }
    Swift::UInt64 v10 = 4 * v9;
    uint64_t v11 = v4 & 0xFFFFFFFFFFFFFFLL;
    if (((v4 >> 60) & ((v5 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v12 = 11LL;
    }
    else {
      uint64_t v12 = 7LL;
    }
    do
    {
      if (v10 <= v7._rawBits >> 14)
      {
        unint64_t v33 = 158LL;
        goto LABEL_75;
      }

      Swift::UInt64 v13 = (v7._rawBits >> 8) & 0x3F;
      if (!v13)
      {
        Swift::UInt64 v14 = v7._rawBits >> 16;
        if ((v4 & 0x1000000000000000LL) == 0)
        {
          if ((v4 & 0x2000000000000000LL) != 0)
          {
            uint64_t v43 = v5;
            uint64_t v44 = v11;
            if (v14 + 1 == v8) {
              goto LABEL_26;
            }
            int v18 = *(unsigned __int16 *)((char *)&v43 + v14);
            if (v18 != 2573 && (v18 & 0x80808080) == 0) {
              goto LABEL_26;
            }
          }

          else
          {
            int v15 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v16 = v5 & 0xFFFFFFFFFFFFLL;
            if ((v5 & 0x1000000000000000LL) == 0)
            {
              uint64_t v42 = v11;
              int v15 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
              uint64_t v11 = v42;
            }

            if (v14 + 1 == v16) {
              goto LABEL_26;
            }
            if (!v15) {
              goto LABEL_72;
            }
            int v17 = *(unsigned __int16 *)&v15[v14];
            if (v17 != 2573 && (v17 & 0x80808080) == 0)
            {
LABEL_26:
              Swift::UInt64 v13 = 1LL;
              goto LABEL_27;
            }
          }
        }

        uint64_t v30 = v11;
        Swift::UInt64 v13 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v7._rawBits >> 16);
        uint64_t v11 = v30;
      }

Swift::String::Index_optional __swiftcall String.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  Swift::UInt64 rawBits = limitedBy._rawBits;
  uint64_t v10 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SmallString.swift",  23LL,  2,  0xD7uLL, 0) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((limitedBy._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(limitedBy)._rawBits;
  }
  Swift::UInt64 v12 = _._rawBits;
  if ((_._rawBits & 0xC) == v11) {
    Swift::UInt64 v12 = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  }
  v13._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(_)._rawBits;
  Swift::UInt64 v14 = rawBits >> 14;
  Swift::UInt64 v15 = v12 >> 14;
  if (offsetBy < 0)
  {
    Swift::Int v40 = 0LL;
    uint64_t v41 = v5 & 0xFFFFFFFFFFFFFFLL;
    if (((v5 >> 60) & ((v6 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v42 = 11LL;
    }
    else {
      uint64_t v42 = 7LL;
    }
    while (1)
    {
      Swift::UInt64 v49 = v13._rawBits >> 14;
      if (v15 >= v14 && v14 >= v49) {
        goto LABEL_86;
      }
      if (!v49)
      {
        unint64_t v43 = 245LL;
LABEL_90:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  v43,  0);
      }

      int64_t v46 = v13._rawBits >> 16;
      if (v13._rawBits < 0x20000) {
        goto LABEL_63;
      }
      if ((v5 & 0x1000000000000000LL) != 0) {
        goto LABEL_62;
      }
      if ((v5 & 0x2000000000000000LL) != 0)
      {
        uint64_t v63 = v6;
        uint64_t v64 = v41;
        int v52 = *(unsigned __int16 *)((char *)&v63 + v46 - 2);
        if (v52 == 2573 || (v52 & 0x80808080) != 0) {
          goto LABEL_62;
        }
      }

      else
      {
        unint64_t v50 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v6 & 0x1000000000000000LL) == 0)
        {
          uint64_t v62 = v41;
          unint64_t v50 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
          uint64_t v41 = v62;
          if (!v50) {
LABEL_83:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }

        int v51 = *(unsigned __int16 *)&v50[v46 - 2];
        if (v51 == 2573 || (v51 & 0x80808080) != 0)
        {
LABEL_62:
          uint64_t v44 = v41;
          Swift::Int v45 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v13._rawBits >> 16);
          uint64_t v41 = v44;
          int64_t v46 = v45;
LABEL_63:
          Swift::UInt64 v47 = v13._rawBits - (v46 << 16);
          uint64_t v48 = v46 << 8;
          if (v46 > 63) {
            uint64_t v48 = 0LL;
          }
          goto LABEL_65;
        }
      }

      Swift::UInt64 v47 = v13._rawBits - 0x10000;
      uint64_t v48 = 256LL;
LABEL_65:
      --v40;
      v13._Swift::UInt64 rawBits = v48 | v42 | v47 & 0xFFFFFFFFFFFF0000LL;
      if (v40 <= offsetBy)
      {
        if (v15 < v14 || v13._rawBits >> 14 >= v14) {
          goto LABEL_87;
        }
        goto LABEL_86;
      }
    }
  }

  if (offsetBy)
  {
    uint64_t v16 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000LL) != 0) {
      uint64_t v17 = HIBYTE(v5) & 0xF;
    }
    else {
      uint64_t v17 = v6 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v18 = 4 * v17;
    uint64_t v19 = v5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v20 = (v5 & 0xFFFFFFFFFFFFFFFLL) + 32;
    if (((v5 >> 60) & ((v6 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v21 = 11LL;
    }
    else {
      uint64_t v21 = 7LL;
    }
    while (1)
    {
      Swift::UInt64 v22 = v13._rawBits >> 14;
      if (v14 >= v15 && v22 >= v14) {
        goto LABEL_86;
      }
      if (v22 >= v18)
      {
        unint64_t v43 = 238LL;
        goto LABEL_90;
      }

      Swift::UInt64 v23 = (v13._rawBits >> 8) & 0x3F;
      if (!v23) {
        break;
      }
LABEL_31:
      Swift::UInt64 v28 = v13._rawBits + (v23 << 16);
      unint64_t v29 = v28 & 0xFFFFFFFFFFFF0000LL;
      if (v18 == (v28 & 0xFFFFFFFFFFFF0000LL) >> 14)
      {
        Swift::Int v30 = 0LL;
      }

      else
      {
        Swift::UInt64 v31 = v28 >> 16;
        if ((v5 & 0x1000000000000000LL) != 0) {
          goto LABEL_52;
        }
        if ((v5 & 0x2000000000000000LL) != 0)
        {
          uint64_t v63 = v6;
          uint64_t v64 = v19;
          if (v31 + 1 != v16)
          {
            int v35 = *(unsigned __int16 *)((char *)&v63 + v31);
            if (v35 == 2573 || (v35 & 0x80808080) != 0) {
              goto LABEL_52;
            }
          }
        }

        else
        {
          uint64_t v32 = (char *)v20;
          uint64_t v33 = v6 & 0xFFFFFFFFFFFFLL;
          if ((v6 & 0x1000000000000000LL) == 0)
          {
            uint64_t v60 = v20;
            uint64_t v62 = v16;
            uint64_t v56 = v19;
            uint64_t v32 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
            uint64_t v19 = v56;
            uint64_t v20 = v60;
            uint64_t v16 = v62;
          }

          if (v31 + 1 != v33)
          {
            if (!v32) {
              goto LABEL_83;
            }
            int v34 = *(unsigned __int16 *)&v32[v31];
            if (v34 == 2573 || (v34 & 0x80808080) != 0)
            {
LABEL_52:
              uint64_t v58 = v20;
              uint64_t v62 = v16;
              Swift::Int v37 = v31;
              uint64_t v38 = v19;
              Swift::Int v30 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v37);
              uint64_t v20 = v58;
              uint64_t v16 = v62;
              uint64_t v19 = v38;
              if (v30 > 63) {
                goto LABEL_50;
              }
              goto LABEL_49;
            }
          }
        }

        Swift::Int v30 = 1LL;
      }

Swift::Int __swiftcall _StringGuts._opaqueCharacterStride(startingAt:)(Swift::Int startingAt)
{
  if ((v2 & 0x1000000000000000LL) == 0)
  {
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      v9[0] = v1;
      v9[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (startingAt + 1 == (HIBYTE(v2) & 0xF)) {
        return 1LL;
      }
      int v6 = *(unsigned __int16 *)((char *)v9 + startingAt);
    }

    else
    {
      if ((v1 & 0x1000000000000000LL) != 0)
      {
        unint64_t v4 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v5 = v1 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v4 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
      }

      if (startingAt + 1 == v5) {
        return 1LL;
      }
      if (!v4) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      }
      int v6 = *(unsigned __int16 *)&v4[startingAt];
    }

    if (v6 == 2573 || (v6 & 0x8080) != 0) {
      return _StringGuts._opaqueComplexCharacterStride(startingAt:)(startingAt);
    }
    return 1LL;
  }

  return _StringGuts._opaqueComplexCharacterStride(startingAt:)(startingAt);
}

Swift::Int __swiftcall _StringGuts._opaqueCharacterStride(endingAt:)(Swift::Int endingAt)
{
  if (endingAt >= 2)
  {
    if ((v2 & 0x1000000000000000LL) != 0) {
      return _StringGuts._opaqueComplexCharacterStride(endingAt:)(endingAt);
    }
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      v7[0] = v1;
      v7[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v3 = v7;
    }

    else if ((v1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v3 = (void *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      Swift::Int v6 = endingAt;
      unint64_t v3 = _StringObject.sharedUTF8.getter(v1, v2);
      endingAt = v6;
      if (!v3) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      }
    }

    int v4 = *(unsigned __int16 *)((char *)v3 + endingAt - 2);
    if (v4 != 2573 && (v4 & 0x80808080) == 0) {
      return 1LL;
    }
    else {
      return _StringGuts._opaqueComplexCharacterStride(endingAt:)(endingAt);
    }
  }

  return endingAt;
}

Swift::String::Index __swiftcall _StringGuts.validateScalarIndex(_:)(Swift::String::Index result)
{
  uint64_t v3 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v3) = 1;
  }
  if ((result._rawBits & 1) == 0 || (result._rawBits & 0xC) == 4LL << v3)
  {
    result._Swift::UInt64 rawBits = _StringGuts.validateSubscalarIndex(_:)(result)._rawBits;
    if ((result._rawBits & 1) == 0) {
      return (Swift::String::Index)(result._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(result)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1);
    }
  }

  else
  {
    Swift::UInt64 v4 = HIBYTE(v2) & 0xF;
    if ((v2 & 0x2000000000000000LL) == 0) {
      Swift::UInt64 v4 = v1 & 0xFFFFFFFFFFFFLL;
    }
    if (v4 <= result._rawBits >> 16) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x79uLL,  0);
    }
  }

  return result;
}

Swift::String __swiftcall _StringGuts.errorCorrectedCharacter(startingAt:endingAt:)( Swift::Int startingAt, Swift::Int endingAt)
{
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::String v13 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(startingAt, endingAt);
    unint64_t object = v13._object;
    uint64_t countAndFlagsBits = v13._countAndFlagsBits;
    goto LABEL_19;
  }

  if (endingAt < startingAt) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if ((v3 & 0x2000000000000000LL) == 0)
  {
    if ((v2 & 0x1000000000000000LL) != 0)
    {
      id v6 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      Swift::Int v7 = v2 & 0xFFFFFFFFFFFFLL;
      if ((startingAt & 0x8000000000000000LL) == 0) {
        goto LABEL_6;
      }
    }

    else
    {
      id v6 = _StringObject.sharedUTF8.getter(v2, v3);
      Swift::Int v7 = v15;
      if ((startingAt & 0x8000000000000000LL) == 0)
      {
LABEL_6:
        if (v7 >= endingAt)
        {
          uint64_t v8 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(startingAt, endingAt, (uint64_t)v6, v7);
          uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v8, v9);
          goto LABEL_19;
        }

        goto LABEL_14;
      }
    }

uint64_t String.Index.characterStride.getter(unint64_t a1)
{
  return (a1 >> 8) & 0x3F;
}

Swift::String::Index protocol witness for BidirectionalCollection.index(before:) in conformance String@<X0>( Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

Swift::String::Index protocol witness for BidirectionalCollection.formIndex(before:) in conformance String( Swift::String::Index *a1)
{
  result._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a1->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance String@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = String.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void, void, void))String.index(_:offsetBy:limitedBy:),  a4);
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance String( Swift::String::Index *a1, Swift::String::Index *a2)
{
  return String.distance(from:to:)((Swift::String::Index)a1->_rawBits, (Swift::String::Index)a2->_rawBits);
}

void protocol witness for Collection.startIndex.getter in conformance String(void *a1@<X8>)
{
  *a1 = 15LL;
}

void (*protocol witness for Collection.subscript.read in conformance String( uint64_t *a1, Swift::UInt64 *a2))(uint64_t a1)
{
  v4._Swift::UInt64 rawBits = *a2;
  uint64_t v5 = String.subscript.getter(v4, *(void *)v2, *(void *)(v2 + 8));
  a1[1] = v6;
  a1[2] = v6;
  *a1 = v5;
  return protocol witness for Collection.subscript.read in conformance String;
}

void protocol witness for Collection.subscript.read in conformance String(uint64_t a1)
{
}

unint64_t protocol witness for Collection.subscript.getter in conformance String@<X0>( Swift::UInt64 *a1@<X0>, uint64_t *a2@<X8>)
{
  v4._Swift::UInt64 rawBits = a1[1];
  unint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  v7._Swift::UInt64 rawBits = *a1;
  Swift::UInt64 v8 = _StringGuts.validateScalarRange(_:)(v7, v4, v6, v5);
  uint64_t v12 = v8 | 3;
  if (v8 >= 0x10000) {
    uint64_t v12 = v8;
  }
  *a2 = v12;
  a2[1] = v9;
  a2[2] = v6;
  a2[3] = v5;
  return swift_bridgeObjectRetain(v5, v9, v10, v11);
}

BOOL protocol witness for Collection.isEmpty.getter in conformance String()
{
  unint64_t v1 = v0[1];
  uint64_t v2 = *v0 & 0xFFFFFFFFFFFFLL;
  if ((v1 & 0x2000000000000000LL) != 0) {
    uint64_t v2 = HIBYTE(v1) & 0xF;
  }
  return v2 == 0;
}

Swift::Int protocol witness for Collection.count.getter in conformance String()
{
  unint64_t v1 = v0[1];
  uint64_t v2 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = *v0;
  }
  uint64_t v3 = 7LL;
  if (((v1 >> 60) & ((*v0 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v3 = 11LL;
  }
  return String.distance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)(v3 | (v2 << 16)));
}

Swift::String::Index protocol witness for Collection.index(after:) in conformance String@<X0>( Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  v3._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  result._Swift::UInt64 rawBits = String._uncheckedIndex(after:)(v3)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

Swift::String::Index protocol witness for Collection.formIndex(after:) in conformance String( Swift::String::Index *a1)
{
  v2._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  result._Swift::UInt64 rawBits = String._uncheckedIndex(after:)(v2)._rawBits;
  a1->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

  ;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance String(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance String( a1,  a2,  (uint64_t (*)(void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance String( void *a1, Swift::String_optional *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *(void *)v3, *(void *)(v3 + 8));
}

uint64_t (*String.Iterator._guts.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.Iterator._position.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t (*String.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.Iterator._end.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t (*String.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::String_optional __swiftcall String.Iterator.next()()
{
  Swift::Int v1 = v0[2];
  if (v1 < v0[3])
  {
    uint64_t v2 = *v0;
    unint64_t v3 = v0[1];
    if ((v3 & 0x1000000000000000LL) != 0) {
      goto LABEL_30;
    }
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v21 = *v0;
      uint64_t v22 = v3 & 0xFFFFFFFFFFFFFFLL;
      Swift::Int v6 = v1 + 1;
      if (v1 + 1 == (HIBYTE(v3) & 0xF)) {
        goto LABEL_16;
      }
      int v7 = *(unsigned __int16 *)((char *)&v21 + v1);
    }

    else
    {
      if ((v2 & 0x1000000000000000LL) != 0)
      {
        Swift::String::Index v4 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        Swift::String::Index v4 = (char *)_StringObject.sharedUTF8.getter(*v0, v0[1]);
      }

      Swift::Int v6 = v1 + 1;
      if (v1 + 1 == v5) {
        goto LABEL_16;
      }
      if (!v4) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      }
      int v7 = *(unsigned __int16 *)&v4[v1];
    }

    if (v7 == 2573 || (v7 & 0x8080) != 0)
    {
LABEL_30:
      Swift::Int v9 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v1);
      Swift::Int v6 = v9 + v1;
      uint64_t v10 = *v0;
      unint64_t v11 = v0[1];
      if ((v11 & 0x1000000000000000LL) != 0) {
        goto LABEL_31;
      }
      goto LABEL_17;
    }

uint64_t protocol witness for IteratorProtocol.next() in conformance String.Iterator@<X0>( Swift::String_optional *a1@<X8>)
{
  Swift::String_optional v3 = String.Iterator.next()();
  uint64_t result = v3.value._countAndFlagsBits;
  *a1 = v3;
  return result;
}

uint64_t static StringProtocol.== infix<A>(_:_:)( uint64_t a1, uint64_t a2, ValueMetadata *a3, ValueMetadata *a4)
{
  uint64_t v8 = MEMORY[0x1895F8858](a4[-1].Description);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  id v12 = (uint64_t *)((char *)&v57 - v11);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  Swift::Int v15 = (Swift::UInt64 *)((char *)&v57 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  unint64_t v18 = (uint64_t *)((char *)&v57 - v17);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v26 = (uint64_t *)((char *)&v57 - v23);
  if (v27 == &type metadata for String)
  {
    if (a4 == &type metadata for String) {
      return specialized static StringProtocol.== infix<A>(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)a2,  *(void *)(a2 + 8));
    }
    if (a4 == &type metadata for Substring) {
      return specialized static StringProtocol.== infix<A>(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)a2,  *(void *)(a2 + 8),  *(void *)(a2 + 16),  *(void *)(a2 + 24));
    }
  }

  if (a3 != &type metadata for Substring) {
    goto LABEL_3;
  }
  if (a4 == &type metadata for String) {
    return specialized static StringProtocol.== infix<A>(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(void *)a2,  *(void *)(a2 + 8));
  }
  if (a4 == &type metadata for Substring)
  {
    uint64_t v32 = *(void *)(a1 + 16);
    unint64_t v33 = *(void *)(a1 + 24);
    uint64_t v34 = *(void *)a1 >> 16;
    uint64_t v35 = *(void *)(a1 + 8) >> 16;
    uint64_t v36 = *(void *)(a2 + 16);
    unint64_t v37 = *(void *)(a2 + 24);
    uint64_t v38 = *(void *)a2 >> 16;
    uint64_t v39 = *(void *)(a2 + 8) >> 16;
    if (v32 != v36 || v33 != v37 || v34 != v38 || v35 != v39) {
      return _stringCompareInternal(_:_:_:_:expecting:)(v32, v33, v34, v35, v36, v37, v38, v39, 0) & 1;
    }
    char v40 = 1;
  }

  else
  {
LABEL_3:
    uint64_t v59 = v25;
    uint64_t v60 = v19;
    uint64_t v28 = v20;
    uint64_t v58 = v24;
    uint64_t v62 = v21;
    unint64_t v29 = *(void (**)(char *, uint64_t, ValueMetadata *))(v22 + 16);
    v29((char *)&v57 - v23, a1, a3);
    if (swift_dynamicCast((char *)&v63, v26, (swift *)a3, (const char *)&type metadata for String, 6uLL))
    {
      unint64_t v30 = v64;
      Swift::UInt64 v61 = v63;
    }

    else
    {
      v29((char *)v18, a1, a3);
      if ((swift_dynamicCast((char *)&v63, v18, (swift *)a3, (const char *)&type metadata for Substring, 6uLL) & 1) != 0)
      {
        unint64_t v30 = v66;
        Swift::UInt64 v61 = v65;
      }

      else
      {
        v29((char *)v15, a1, a3);
        Swift::UInt64 v61 = String.init<A>(_:)(v15, (swift *)a3, *(void *)(v28 + 40));
        unint64_t v30 = v41;
      }
    }

    uint64_t v42 = *(void *)(*(void *)(v28 + 8) + 8LL);
    (*(void (**)(Swift::UInt64 *__return_ptr, ValueMetadata *, uint64_t))(v42 + 64))(&v63, a3, v42);
    Swift::UInt64 v43 = v63;
    (*(void (**)(Swift::UInt64 *__return_ptr, ValueMetadata *, uint64_t))(v42 + 72))(&v63, a3, v42);
    Swift::UInt64 v44 = v63;
    Swift::Int v45 = *(void (**)(uint64_t *, uint64_t, ValueMetadata *))(v60 + 16);
    v45(v12, a2, a4);
    if ((swift_dynamicCast((char *)&v63, v12, (swift *)a4, (const char *)&type metadata for String, 6uLL) & 1) != 0)
    {
      Swift::UInt64 v47 = v63;
      unint64_t v46 = v64;
    }

    else
    {
      uint64_t v48 = v59;
      v45(v59, a2, a4);
      if ((swift_dynamicCast((char *)&v63, v48, (swift *)a4, (const char *)&type metadata for Substring, 6uLL) & 1) != 0)
      {
        Swift::UInt64 v47 = v65;
        unint64_t v46 = v66;
      }

      else
      {
        Swift::UInt64 v49 = v58;
        v45((uint64_t *)v58, a2, a4);
        Swift::UInt64 v47 = String.init<A>(_:)(v49, (swift *)a4, *(void *)(v62 + 40));
        unint64_t v46 = v50;
      }
    }

    uint64_t v51 = v43 >> 16;
    uint64_t v52 = v44 >> 16;
    uint64_t v53 = *(void *)(*(void *)(v62 + 8) + 8LL);
    (*(void (**)(Swift::UInt64 *__return_ptr, ValueMetadata *, uint64_t))(v53 + 64))(&v63, a4, v53);
    Swift::UInt64 v54 = v63;
    (*(void (**)(Swift::UInt64 *__return_ptr, ValueMetadata *, uint64_t))(v53 + 72))(&v63, a4, v53);
    uint64_t v55 = v54 >> 16;
    uint64_t v56 = v63 >> 16;
    if (v61 == v47 && v30 == v46 && v51 == v55 && v52 == v56)
    {
      swift_bridgeObjectRelease_n(v30, 2LL);
      char v40 = 1;
    }

    else
    {
      char v40 = _stringCompareInternal(_:_:_:_:expecting:)(v61, v30, v51, v52, v47, v46, v55, v56, 0);
      swift_bridgeObjectRelease(v30);
      swift_bridgeObjectRelease(v46);
    }
  }

  return v40 & 1;
}

Swift::UInt64 StringProtocol._wholeGuts.getter(ValueMetadata *a1, uint64_t a2)
{
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  int v7 = (void *)((char *)v22 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v8 = MEMORY[0x1895F8858](v5);
  uint64_t v10 = (void *)((char *)v22 - v9);
  uint64_t v11 = (ValueMetadata *)MEMORY[0x1895F8858](v8);
  uint64_t v17 = (void *)((char *)v22 - v16);
  if (v11 == &type metadata for String)
  {
    uint64_t v19 = *v2;
    unint64_t v20 = v2[1];
LABEL_7:
    swift_bridgeObjectRetain(v20, v12, v13, v14);
    return v19;
  }

  if (a1 == &type metadata for Substring)
  {
    uint64_t v19 = v2[2];
    unint64_t v20 = v2[3];
    goto LABEL_7;
  }

  unint64_t v18 = *(void (**)(char *, uint64_t *, ValueMetadata *))(v15 + 16);
  v18((char *)v22 - v16, v2, a1);
  v18((char *)v10, v2, a1);
  v18((char *)v7, v2, a1);
  return String.init<A>(_:)(v7, (swift *)a1, *(void *)(a2 + 40));
}

unint64_t StringProtocol._offsetRange.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 8) + 8LL);
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(v3 + 64))(&v6, a1, v3);
  unint64_t v4 = v6;
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(v3 + 72))(&v6, a1, v3);
  return v4 >> 16;
}

uint64_t _stringCompare(_:_:_:_:expecting:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a1 == a5 && a2 == a6 && a3 == a7 && a4 == a8) {
    return (a9 & 1) == 0;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, a3, a4, a5, a6, a7, a8, a9 & 1);
  }
}

BOOL static StringProtocol.!= infix<A>(_:_:)(uint64_t a1, uint64_t a2, ValueMetadata *a3, ValueMetadata *a4)
{
  return (static StringProtocol.== infix<A>(_:_:)(a1, a2, a3, a4) & 1) == 0;
}

uint64_t static StringProtocol.< infix<A>(_:_:)( uint64_t a1, uint64_t a2, swift *a3, ValueMetadata *a4, uint64_t a5)
{
  Description = a4[-1].Description;
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v15 = (uint64_t *)((char *)&v67 - v14);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  unint64_t v18 = (Swift::UInt64 *)((char *)&v67 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (uint64_t *)((char *)&v67 - v20);
  MEMORY[0x1895F8858](v19);
  unint64_t v30 = (uint64_t *)((char *)&v67 - v27);
  if (v23 == &type metadata for String)
  {
    if (a4 == &type metadata for String) {
      return specialized static StringProtocol.< infix<A>(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)a2,  *(void *)(a2 + 8));
    }
    if (a4 == &type metadata for Substring) {
      return specialized static StringProtocol.< infix<A>(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)a2,  *(void *)(a2 + 8),  *(void *)(a2 + 16),  *(void *)(a2 + 24));
    }
    if (&full type metadata for String != &full type metadata for Substring) {
      goto LABEL_16;
    }
  }

  else if (a3 != (swift *)&type metadata for Substring)
  {
    unint64_t v69 = v29;
    uint64_t v70 = a5;
    uint64_t v68 = v28;
    uint64_t v71 = v25;
    Swift::UInt64 v31 = *(void (**)(char *, uint64_t, swift *))(v26 + 16);
    v31((char *)&v67 - v27, a1, a3);
    if (swift_dynamicCast((char *)&v73, v30, a3, (const char *)&type metadata for String, 6uLL))
    {
      Swift::UInt64 v32 = v73;
      unint64_t v33 = v74;
LABEL_14:
      Swift::UInt64 v72 = v32;
      a5 = v70;
      goto LABEL_20;
    }

    v31((char *)v21, a1, a3);
    if (swift_dynamicCast((char *)&v73, v21, a3, (const char *)&type metadata for Substring, 6uLL))
    {
      Swift::UInt64 v32 = v75;
      unint64_t v33 = v76;
      goto LABEL_14;
    }

    v31((char *)v18, a1, a3);
    a5 = v70;
    Swift::UInt64 v72 = String.init<A>(_:)(v18, a3, *(void *)(v70 + 40));
    unint64_t v33 = v36;
LABEL_20:
    uint64_t v37 = *(void *)(*(void *)(a5 + 8) + 8LL);
    (*(void (**)(Swift::UInt64 *__return_ptr, swift *, uint64_t))(v37 + 64))(&v73, a3, v37);
    Swift::UInt64 v38 = v73;
    (*(void (**)(Swift::UInt64 *__return_ptr, swift *, uint64_t))(v37 + 72))(&v73, a3, v37);
    Swift::UInt64 v42 = v73;
    if (a4 == &type metadata for String)
    {
      uint64_t v45 = *(void *)a2;
      unint64_t v44 = *(void *)(a2 + 8);
    }

    else
    {
      if (a4 != &type metadata for Substring)
      {
        Swift::UInt64 v43 = (void (*)(uint64_t *, uint64_t, ValueMetadata *))Description[2];
        v43(v15, a2, a4);
        if (swift_dynamicCast( (char *)&v73,  v15,  (swift *)a4,  (const char *)&type metadata for String,  6uLL))
        {
          uint64_t v45 = v73;
          unint64_t v44 = v74;
        }

        else
        {
          Swift::UInt64 v54 = v69;
          v43(v69, a2, a4);
          if (!swift_dynamicCast( (char *)&v73,  v54,  (swift *)a4,  (const char *)&type metadata for Substring,  6uLL))
          {
            Swift::UInt64 v63 = v68;
            v43((uint64_t *)v68, a2, a4);
            uint64_t v64 = v71;
            Swift::UInt64 v65 = String.init<A>(_:)(v63, (swift *)a4, *(void *)(v71 + 40));
            uint64_t v46 = v64;
            uint64_t v45 = v65;
            unint64_t v44 = v66;
            goto LABEL_28;
          }

          uint64_t v45 = v75;
          unint64_t v44 = v76;
        }

uint64_t static StringProtocol.> infix<A>(_:_:)( uint64_t a1, uint64_t a2, ValueMetadata *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  return static StringProtocol.< infix<A>(_:_:)(a2, a1, a4, a3, a6) & 1;
}

BOOL static StringProtocol.<= infix<A>(_:_:)( uint64_t a1, uint64_t a2, ValueMetadata *a3, swift *a4, uint64_t a5, uint64_t a6)
{
  return (static StringProtocol.< infix<A>(_:_:)(a2, a1, a4, a3, a6) & 1) == 0;
}

BOOL static StringProtocol.>= infix<A>(_:_:)( uint64_t a1, uint64_t a2, swift *a3, ValueMetadata *a4, uint64_t a5)
{
  return (static StringProtocol.< infix<A>(_:_:)(a1, a2, a3, a4, a5) & 1) == 0;
}

uint64_t _stringCompare(_:_:expecting:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, char a5)
{
  int v5 = a5 & 1;
  if (a1 == a3 && a2 == a4) {
    return v5 == 0;
  }
  if ((~a2 & 0x6000000000000000LL) != 0 || (a4 & 0x2000000000000000LL) == 0 || (a4 & 0x4000000000000000LL) == 0) {
    return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, v5);
  }
  BOOL v8 = bswap64(a1) < bswap64(a3) && v5 != 0;
  BOOL v9 = a2 == a4;
  BOOL v10 = bswap64(a2) < bswap64(a4);
  if (v5) {
    BOOL v9 = v10;
  }
  if (a1 == a3) {
    return v9;
  }
  else {
    return v8;
  }
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance Character( unint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = *a2;
  unint64_t v7 = a2[1];
  if (v4 == *a2 && v5 == v7) {
    return 0LL;
  }
  if ((~v5 & 0x6000000000000000LL) != 0 || (v7 & 0x2000000000000000LL) == 0 || (v7 & 0x4000000000000000LL) == 0) {
    return _stringCompareInternal(_:_:expecting:)(v4, v5, v6, v7, 1);
  }
  BOOL v12 = bswap64(v4) < bswap64(v6);
  BOOL v13 = bswap64(v5) < bswap64(v7);
  if (v4 == v6) {
    return v13;
  }
  else {
    return v12;
  }
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Character( unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  if (v4 == v2 && v5 == v3)
  {
    char v9 = 0;
  }

  else if ((~v5 & 0x6000000000000000LL) != 0 || (v3 & 0x2000000000000000LL) == 0 || (v3 & 0x4000000000000000LL) == 0)
  {
    char v9 = _stringCompareInternal(_:_:expecting:)(v4, v5, v2, v3, 1);
  }

  else
  {
    BOOL v10 = bswap64(v4) < bswap64(v2);
    BOOL v11 = bswap64(v5) < bswap64(v3);
    if (v4 == v2) {
      char v9 = v11;
    }
    else {
      char v9 = v10;
    }
  }

  return (v9 & 1) == 0;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Character( unint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = *a2;
  unint64_t v7 = a2[1];
  if (v4 == *a2 && v5 == v7)
  {
    char v11 = 0;
  }

  else if ((~v5 & 0x6000000000000000LL) != 0 || (v7 & 0x2000000000000000LL) == 0 || (v7 & 0x4000000000000000LL) == 0)
  {
    char v11 = _stringCompareInternal(_:_:expecting:)(v4, v5, v6, v7, 1);
  }

  else
  {
    BOOL v12 = bswap64(v4) < bswap64(v6);
    BOOL v13 = bswap64(v5) < bswap64(v7);
    if (v4 == v6) {
      char v11 = v13;
    }
    else {
      char v11 = v12;
    }
  }

  return (v11 & 1) == 0;
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance Character( unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  if (v4 == v2 && v5 == v3) {
    return 0LL;
  }
  if ((~v5 & 0x6000000000000000LL) != 0 || (v3 & 0x2000000000000000LL) == 0 || (v3 & 0x4000000000000000LL) == 0) {
    return _stringCompareInternal(_:_:expecting:)(v4, v5, v2, v3, 1);
  }
  BOOL v10 = bswap64(v4) < bswap64(v2);
  BOOL v11 = bswap64(v5) < bswap64(v3);
  if (v4 == v2) {
    return v11;
  }
  else {
    return v10;
  }
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Substring( unint64_t *a1, void *a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = a1[2];
  unint64_t v7 = a1[3];
  uint64_t v8 = a2[2];
  unint64_t v9 = a2[3];
  uint64_t v10 = v4 >> 16;
  uint64_t v11 = v5 >> 16;
  uint64_t v12 = *a2 >> 16;
  uint64_t v13 = a2[1] >> 16;
  if (v6 == v8 && v7 == v9 && v10 == v12 && v11 == v13) {
    return 1LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(v6, v7, v10, v11, v8, v9, v12, v13, 0) & 1;
  }
}

uint64_t static _StringComparisonResult.== infix(_:_:)(char a1, char a2)
{
  if ((a1 & 1) != 0)
  {
    if ((a2 & 1) != 0) {
      return 1LL;
    }
  }

  else if ((a2 & 1) == 0)
  {
    return 1LL;
  }

  return 0LL;
}

uint64_t _stringCompareWithSmolCheck(_:_:expecting:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, char a5)
{
  int v5 = a5 & 1;
  if ((~a2 & 0x6000000000000000LL) != 0 || (~a4 & 0x6000000000000000LL) != 0) {
    return _stringCompareInternal(_:_:expecting:)(a1, a2, a3, a4, v5);
  }
  BOOL v6 = bswap64(a2) < bswap64(a4);
  if (!v5) {
    BOOL v6 = a2 == a4;
  }
  unint64_t v7 = bswap64(a1);
  unint64_t v8 = bswap64(a3);
  if (v5) {
    BOOL v9 = v7 >= v8;
  }
  else {
    BOOL v9 = 1;
  }
  unsigned int v10 = !v9;
  if (a1 == a3) {
    return v6;
  }
  else {
    return v10;
  }
}

uint64_t _stringCompareInternal(_:_:expecting:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, char a5)
{
  int v7 = a5 & 1;
  if ((a2 & 0x1000000000000000LL) != 0 || (a4 & 0x1000000000000000LL) != 0) {
    return _stringCompareSlow(_:_:expecting:)(a1, a2, a3, a4, a5 & 1);
  }
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v8 = a2;
  }
  else {
    unint64_t v8 = a1;
  }
  if ((v8 & 0x4000000000000000LL) != 0)
  {
    uint64_t v10 = a4 & 0x2000000000000000LL;
    if ((a4 & 0x2000000000000000LL) != 0) {
      unint64_t v11 = a4;
    }
    else {
      unint64_t v11 = a3;
    }
    uint64_t v9 = (v11 >> 62) & 1;
    if ((a2 & 0x2000000000000000LL) != 0)
    {
LABEL_18:
      uint64_t v17 = HIBYTE(a2) & 0xF;
      uint64_t __s1 = a1;
      uint64_t v41 = a2 & 0xFFFFFFFFFFFFFFLL;
      if (v10)
      {
        unint64_t v18 = HIBYTE(a4) & 0xF;
        v39[0] = a3;
        v39[1] = a4 & 0xFFFFFFFFFFFFFFLL;
        if ((v9 & 1) != 0)
        {
          if ((a5 & 1) != 0 || v17 == v18)
          {
            if (v18 >= v17) {
              size_t v19 = HIBYTE(a2) & 0xF;
            }
            else {
              size_t v19 = HIBYTE(a4) & 0xF;
            }
            int v20 = _swift_stdlib_memcmp(&__s1, v39, v19);
            uint64_t v21 = v20;
            uint64_t v22 = v17 - v18;
LABEL_44:
            if (!v20) {
              uint64_t v21 = v22;
            }
            BOOL v30 = v21 == 0;
            BOOL v31 = v21 < 0;
            char v32 = v30;
            if (v7) {
              return v31;
            }
            else {
              return v32;
            }
          }

          return 0;
        }

        p_s1 = &__s1;
        Swift::UInt64 v34 = v39;
        uint64_t v36 = HIBYTE(a2) & 0xF;
        uint64_t v37 = HIBYTE(a4) & 0xF;
        return _stringCompareFastUTF8Abnormal(_:_:expecting:)((uint64_t)p_s1, v36, (uint64_t)v34, v37, v7);
      }

      if ((a3 & 0x1000000000000000LL) != 0)
      {
        id v23 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v24 = a3 & 0xFFFFFFFFFFFFLL;
        if ((_DWORD)v9)
        {
LABEL_28:
          if (v7 || v17 == v24)
          {
            if (v24 >= v17) {
              size_t v25 = v17;
            }
            else {
              size_t v25 = v24;
            }
            int v20 = _swift_stdlib_memcmp(&__s1, v23, v25);
            uint64_t v21 = v20;
            uint64_t v22 = v17 - v24;
            goto LABEL_44;
          }

          return 0;
        }
      }

      else
      {
        id v23 = _StringObject.sharedUTF8.getter(a3, a4);
        uint64_t v24 = v38;
        if ((_DWORD)v9) {
          goto LABEL_28;
        }
      }

      p_s1 = &__s1;
      uint64_t v36 = v17;
      Swift::UInt64 v34 = (uint64_t *)v23;
      uint64_t v37 = v24;
      return _stringCompareFastUTF8Abnormal(_:_:expecting:)((uint64_t)p_s1, v36, (uint64_t)v34, v37, v7);
    }
  }

  else
  {
    LODWORD(v9) = 0;
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      uint64_t v10 = a4 & 0x2000000000000000LL;
      goto LABEL_18;
    }
  }

  if ((a1 & 0x1000000000000000LL) == 0)
  {
    id v12 = _StringObject.sharedUTF8.getter(a1, a2);
    uint64_t v13 = v26;
    if ((a4 & 0x2000000000000000LL) == 0) {
      goto LABEL_15;
    }
LABEL_36:
    uint64_t v27 = HIBYTE(a4) & 0xF;
    uint64_t __s1 = a3;
    uint64_t v41 = a4 & 0xFFFFFFFFFFFFFFLL;
    if ((v9 & 1) != 0)
    {
      if (v7 || v13 == v27)
      {
        if (v27 >= v13) {
          size_t v29 = v13;
        }
        else {
          size_t v29 = HIBYTE(a4) & 0xF;
        }
        int v20 = _swift_stdlib_memcmp(v12, &__s1, v29);
        uint64_t v21 = v20;
        uint64_t v22 = v13 - v27;
        goto LABEL_44;
      }

      return 0;
    }

    Swift::UInt64 v34 = &__s1;
    p_s1 = (uint64_t *)v12;
    uint64_t v36 = v13;
    uint64_t v37 = HIBYTE(a4) & 0xF;
    return _stringCompareFastUTF8Abnormal(_:_:expecting:)((uint64_t)p_s1, v36, (uint64_t)v34, v37, v7);
  }

  id v12 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v13 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000LL) != 0) {
    goto LABEL_36;
  }
LABEL_15:
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    id v14 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v15 = a3 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    id v14 = _StringObject.sharedUTF8.getter(a3, a4);
    uint64_t v15 = v33;
  }

  return _stringCompareFastUTF8(_:_:expecting:bothNFC:)(v12, v13, v14, v15, v7, v9);
}

BOOL _stringCompareSlow(_:_:expecting:)( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, char a5)
{
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v6 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v7 = HIBYTE(a2) & 0xF;
  }
  return _StringGutsSlice.compare(with:expecting:)(a3, a4, 0LL, v6, a5 & 1, a1, a2, 0LL, v7);
}

uint64_t _stringCompareFastUTF8(_:_:expecting:bothNFC:)( const void *a1, uint64_t a2, void *__s2, uint64_t a4, char a5, char a6)
{
  int v8 = a5 & 1;
  if ((a6 & 1) == 0) {
    return _stringCompareFastUTF8Abnormal(_:_:expecting:)((uint64_t)a1, a2, (uint64_t)__s2, a4, a5 & 1);
  }
  if ((a5 & 1) == 0 && a2 != a4) {
    return 0LL;
  }
  if (a4 >= a2) {
    size_t v10 = a2;
  }
  else {
    size_t v10 = a4;
  }
  int v11 = _swift_stdlib_memcmp(a1, __s2, v10);
  uint64_t v12 = v11;
  if (!v11) {
    uint64_t v12 = a2 - a4;
  }
  BOOL v13 = v12 == 0;
  BOOL v14 = v12 < 0;
  unsigned int v15 = v13;
  if (v8) {
    return v14;
  }
  else {
    return v15;
  }
}

uint64_t _stringCompareInternal(_:_:_:_:expecting:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char v15 = a9 & 1;
  if ((a2 & 0x1000000000000000LL) != 0 || (a6 & 0x1000000000000000LL) != 0) {
    return _StringGutsSlice.compare(with:expecting:)(a5, a6, a7, a8, a9 & 1, a1, a2, a3, a4);
  }
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v16 = a2;
  }
  else {
    unint64_t v16 = a1;
  }
  if ((v16 & 0x4000000000000000LL) != 0)
  {
    if ((a6 & 0x2000000000000000LL) != 0) {
      unint64_t v29 = a6;
    }
    else {
      unint64_t v29 = a5;
    }
    uint64_t v17 = (v29 >> 62) & 1;
    if ((a2 & 0x2000000000000000LL) == 0) {
      goto LABEL_8;
    }
  }

  else
  {
    LODWORD(v17) = 0;
    if ((a2 & 0x2000000000000000LL) == 0)
    {
LABEL_8:
      if ((a1 & 0x1000000000000000LL) != 0)
      {
        id v18 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v19 = a1 & 0xFFFFFFFFFFFFLL;
        if (a3 < 0) {
          goto LABEL_75;
        }
      }

      else
      {
        id v18 = _StringObject.sharedUTF8.getter(a1, a2);
        uint64_t v19 = v52;
        if (a3 < 0) {
          goto LABEL_75;
        }
      }

      if (v19 >= a4)
      {
        int v20 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a3, a4, (uint64_t)v18, v19);
        uint64_t v22 = v20;
        uint64_t v23 = v21;
        if ((a6 & 0x2000000000000000LL) == 0)
        {
          if ((a5 & 0x1000000000000000LL) != 0)
          {
            id v24 = (id)((a6 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v25 = a5 & 0xFFFFFFFFFFFFLL;
            if ((a7 & 0x8000000000000000LL) == 0) {
              goto LABEL_14;
            }
          }

          else
          {
            id v24 = _StringObject.sharedUTF8.getter(a5, a6);
            uint64_t v25 = v53;
            if ((a7 & 0x8000000000000000LL) == 0)
            {
LABEL_14:
              if (v25 >= a8)
              {
                uint64_t v26 = (void *)specialized UnsafeBufferPointer.init(rebasing:)(a7, a8, (uint64_t)v24, v25);
                return _stringCompareFastUTF8(_:_:expecting:bothNFC:)(v22, v23, v26, v27, v15, v17);
              }

              goto LABEL_67;
            }
          }

LABEL_70:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
      }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  if ((v2 & 0x1000000000000000LL) == 0) {
    goto LABEL_69;
  }
  size_t v10 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
  int v11 = v7 & 0xFFFFFFFFFFFFLL;
  while (1)
  {
    uint64_t v12 = specialized UnsafeBufferPointer.init(rebasing:)((uint64_t)v4, v5, (uint64_t)v10, v11);
    BOOL v14 = specialized UnsafeRawBufferPointer.init<A>(_:)(v12, v13);
    if (!v14) {
      goto LABEL_65;
    }
    unint64_t v4 = (int8x8_t *)v14;
    if ((uint64_t)(v15 - v14) < 1)
    {
LABEL_21:
      BOOL v14 = 0LL;
      goto LABEL_65;
    }

    int v5 = v15;
    unint64_t v16 = (int8x8_t *)v14;
    if ((*(_BYTE *)v14 & 0xC0) == 0x80)
    {
      uint64_t v17 = (int8x8_t *)(v14 + 1);
      do
      {
        unint64_t v16 = v17;
        uint64_t v17 = (int8x8_t *)((char *)v17 + 1);
      }

      while ((v16->i8[0] & 0xC0) == 0x80);
    }

    v41[0] = v16;
    BOOL v14 = specialized String.UTF16View._utf16Length<A, B>(readPtr:endPtr:unsignedSIMDType:signedSIMDType:)(v41, v15);
    id v18 = v41[0];
    if (v14 >= 1)
    {
      uint64_t v19 = v41[0]->i8[0];
      if ((v41[0]->i8[0] & 0xC0) == 0x80)
      {
        if (v41[0] > v4)
        {
          int v20 = (char *)&v41[0][-1] + 7;
          while (v20 > (char *)v4)
          {
            uint64_t v21 = *v20--;
            if ((v21 & 0xC0) != 0x80)
            {
              id v18 = (int8x8_t *)(v20 + 1);
              goto LABEL_50;
            }
          }

          id v18 = v4;
LABEL_50:
          v41[0] = v18;
          uint64_t v19 = v18->i8[0];
        }

        if ((v19 & 0xF8) == 0xF0)
        {
          if (v18 == v4) {
            goto LABEL_21;
          }
          v14 -= 2LL;
        }

        else
        {
          --v14;
          if (v18 == v4) {
            goto LABEL_21;
          }
        }
      }
    }

    for (; (unint64_t)v18 < v5; v14 += v35)
    {
      uint64_t v33 = __clz(~v18->i8[0]) - 24;
      if (v18->i8[0] >= 0) {
        int64_t v34 = 1;
      }
      else {
        int64_t v34 = v33;
      }
      id v18 = (int8x8_t *)((char *)v18 + v34);
      if (v34 == 4) {
        uint64_t v35 = 2LL;
      }
      else {
        uint64_t v35 = 1LL;
      }
    }

    uint64_t v71 = 0LL;
    Swift::UInt64 v72 = 0LL;
    goto LABEL_62;
  }

  if (v105 < 0xFFFFFFFFFFFFFF81LL) {
    goto LABEL_70;
  }
  else {
    uint64_t v71 = v107 << -(char)v105;
  }
  Swift::UInt64 v72 = (v106 << -(char)v105) | (v107 >> 1 >> (v105 - 1));
LABEL_62:
  *Swift::UInt64 v73 = v71;
  v73[1] = v72;
  return result;
}

    uint64_t v71 = 0LL;
    Swift::UInt64 v72 = 0LL;
    goto LABEL_62;
  }

  if (v105 <= 0xFFFFFFFFFFFFFF80LL) {
    goto LABEL_70;
  }
  else {
    Swift::UInt64 v72 = v107 >> -(char)v105;
  }
  uint64_t v71 = ((2 * v107) << (v105 - 1)) | (v106 >> -(char)v105);
LABEL_62:
  *Swift::UInt64 v73 = v71;
  v73[1] = v72;
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  Swift::UInt64 v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    Swift::UInt64 v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    unint64_t v76 = v70;
    if (v75 < v124) {
      goto LABEL_70;
    }
    goto LABEL_33;
  }

  unint64_t v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  char v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  BOOL v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v70,  v29,  a3);
LABEL_55:
  uint64_t v100 = v97;
  v62(v29, a3);
  unint64_t v76 = v70;
  if ((v100 & 1) != 0) {
    goto LABEL_70;
  }
LABEL_33:
  v62(v76, a3);
LABEL_34:
  unint64_t v78 = v122;
  uint8x16_t v79 = v122(a3, a4);
  v66(v69, v68, a3);
  if (v79 < 65)
  {
    unint64_t v88 = v78(a3, a4);
    v62(v69, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0) {
      goto LABEL_47;
    }
  }

  else
  {
    v62(v69, a3);
  }

  __int128 v80 = v116;
  v66(v116, v68, a3);
  uint64_t v124 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v81 = v121(a3, a4);
  int8x16x4_t v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      unint64_t v87 = &v124;
      goto LABEL_45;
    }
  }

  else if (v82 > 63)
  {
    char v123 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    unint64_t v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    id v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v80,  a3);
    v62(v29, a3);
    if ((v89 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_46;
  }

  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v62(v68, a3);
  if ((v90 & 0x8000000000000000LL) != 0)
  {
    uint64_t v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFF8LL) {
      LOBYTE(v54) = 0;
    }
    else {
      Swift::UInt64 v54 = v118 << -(char)v90;
    }
  }

  else
  {
    uint64_t v55 = v120;
    if (v90 >= 8) {
      Swift::UInt64 v54 = (char)v118 >> 7;
    }
    else {
      Swift::UInt64 v54 = (char)v118 >> v90;
    }
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  Swift::UInt64 v72 = v121(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    Swift::UInt64 v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
    unint64_t v76 = v70;
    if (v75 < v123) {
      goto LABEL_70;
    }
    goto LABEL_34;
  }

  BOOL v97 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v97(&v123, &type metadata for Int, v98, a3, a4);
  unint64_t v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v70,  v29,  a3);
LABEL_56:
  char v99 = v96;
  v61(v29, a3);
  unint64_t v76 = v70;
  if ((v99 & 1) != 0) {
    goto LABEL_70;
  }
LABEL_34:
  v61(v76, a3);
LABEL_35:
  uint64_t v77 = v121;
  unint64_t v78 = v121(a3, a4);
  v66(v68, v69, a3);
  if (v78 < 65)
  {
    unint64_t v87 = v77(a3, a4);
    v61(v68, a3);
    if (v87 != 64 || (v120(a3, a4) & 1) != 0) {
      goto LABEL_48;
    }
  }

  else
  {
    v61(v68, a3);
  }

  uint8x16_t v79 = v115;
  v66(v115, v69, a3);
  char v123 = 0x7FFFFFFFFFFFFFFFLL;
  __int128 v80 = v120(a3, a4);
  uint64_t v81 = v121(a3, a4);
  if ((v80 & 1) != 0)
  {
    if (v81 > 64)
    {
      unint64_t v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      char v86 = &v123;
      goto LABEL_46;
    }
  }

  else if (v81 > 63)
  {
    unint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
    char v86 = &v122;
LABEL_46:
    v84(v86, &type metadata for Int, v85, a3, a4);
    unint64_t v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v79,  a3);
    v61(v29, a3);
    if ((v88 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_47;
  }

  v66(v29, v79, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v61(v29, a3);
LABEL_47:
  v61(v79, a3);
LABEL_48:
  id v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v61(v69, a3);
  if ((v89 & 0x8000000000000000LL) == 0)
  {
    if (v89 < 8)
    {
      Swift::UInt64 v54 = v118 << v89;
      goto LABEL_51;
    }

    goto LABEL_26;
  }

  if (v89 > 0xFFFFFFFFFFFFFFF8LL)
  {
    Swift::UInt64 v54 = (char)v118 >> -(char)v89;
    goto LABEL_51;
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  Swift::UInt64 v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    Swift::UInt64 v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    unint64_t v76 = v70;
    if (v75 < v124) {
      goto LABEL_70;
    }
    goto LABEL_33;
  }

  unint64_t v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  char v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  BOOL v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v70,  v29,  a3);
LABEL_55:
  uint64_t v100 = v97;
  v62(v29, a3);
  unint64_t v76 = v70;
  if ((v100 & 1) != 0) {
    goto LABEL_70;
  }
LABEL_33:
  v62(v76, a3);
LABEL_34:
  unint64_t v78 = v122;
  uint8x16_t v79 = v122(a3, a4);
  v66(v69, v68, a3);
  if (v79 < 65)
  {
    unint64_t v88 = v78(a3, a4);
    v62(v69, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0) {
      goto LABEL_47;
    }
  }

  else
  {
    v62(v69, a3);
  }

  __int128 v80 = v116;
  v66(v116, v68, a3);
  uint64_t v124 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v81 = v121(a3, a4);
  int8x16x4_t v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      unint64_t v87 = &v124;
      goto LABEL_45;
    }
  }

  else if (v82 > 63)
  {
    char v123 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    unint64_t v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    id v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v80,  a3);
    v62(v29, a3);
    if ((v89 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_46;
  }

  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v62(v68, a3);
  if ((v90 & 0x8000000000000000LL) != 0)
  {
    uint64_t v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFF0LL) {
      LOWORD(v54) = 0;
    }
    else {
      Swift::UInt64 v54 = v118 << -(char)v90;
    }
  }

  else
  {
    uint64_t v55 = v120;
    if (v90 >= 0x10) {
      Swift::UInt64 v54 = (__int16)v118 >> 15;
    }
    else {
      Swift::UInt64 v54 = (__int16)v118 >> v90;
    }
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  Swift::UInt64 v72 = v121(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    Swift::UInt64 v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
    unint64_t v76 = v70;
    if (v75 < v123) {
      goto LABEL_70;
    }
    goto LABEL_34;
  }

  BOOL v97 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v97(&v123, &type metadata for Int, v98, a3, a4);
  unint64_t v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v70,  v29,  a3);
LABEL_56:
  char v99 = v96;
  v61(v29, a3);
  unint64_t v76 = v70;
  if ((v99 & 1) != 0) {
    goto LABEL_70;
  }
LABEL_34:
  v61(v76, a3);
LABEL_35:
  uint64_t v77 = v121;
  unint64_t v78 = v121(a3, a4);
  v66(v68, v69, a3);
  if (v78 < 65)
  {
    unint64_t v87 = v77(a3, a4);
    v61(v68, a3);
    if (v87 != 64 || (v120(a3, a4) & 1) != 0) {
      goto LABEL_48;
    }
  }

  else
  {
    v61(v68, a3);
  }

  uint8x16_t v79 = v115;
  v66(v115, v69, a3);
  char v123 = 0x7FFFFFFFFFFFFFFFLL;
  __int128 v80 = v120(a3, a4);
  uint64_t v81 = v121(a3, a4);
  if ((v80 & 1) != 0)
  {
    if (v81 > 64)
    {
      unint64_t v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      char v86 = &v123;
      goto LABEL_46;
    }
  }

  else if (v81 > 63)
  {
    unint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
    char v86 = &v122;
LABEL_46:
    v84(v86, &type metadata for Int, v85, a3, a4);
    unint64_t v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v79,  a3);
    v61(v29, a3);
    if ((v88 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_47;
  }

  v66(v29, v79, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v61(v29, a3);
LABEL_47:
  v61(v79, a3);
LABEL_48:
  id v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v61(v69, a3);
  if ((v89 & 0x8000000000000000LL) == 0)
  {
    if (v89 < 0x10)
    {
      Swift::UInt64 v54 = v118 << v89;
      goto LABEL_51;
    }

    goto LABEL_26;
  }

  if (v89 > 0xFFFFFFFFFFFFFFF0LL)
  {
    Swift::UInt64 v54 = (__int16)v118 >> -(char)v89;
    goto LABEL_51;
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  Swift::UInt64 v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    Swift::UInt64 v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    unint64_t v76 = v70;
    if (v75 < v124) {
      goto LABEL_70;
    }
    goto LABEL_33;
  }

  unint64_t v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  char v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  BOOL v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v70,  v29,  a3);
LABEL_55:
  uint64_t v100 = v97;
  v62(v29, a3);
  unint64_t v76 = v70;
  if ((v100 & 1) != 0) {
    goto LABEL_70;
  }
LABEL_33:
  v62(v76, a3);
LABEL_34:
  unint64_t v78 = v122;
  uint8x16_t v79 = v122(a3, a4);
  v66(v69, v68, a3);
  if (v79 < 65)
  {
    unint64_t v88 = v78(a3, a4);
    v62(v69, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0) {
      goto LABEL_47;
    }
  }

  else
  {
    v62(v69, a3);
  }

  __int128 v80 = v116;
  v66(v116, v68, a3);
  uint64_t v124 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v81 = v121(a3, a4);
  int8x16x4_t v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      unint64_t v87 = &v124;
      goto LABEL_45;
    }
  }

  else if (v82 > 63)
  {
    char v123 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    unint64_t v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    id v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v80,  a3);
    v62(v29, a3);
    if ((v89 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_46;
  }

  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v62(v68, a3);
  if ((v90 & 0x8000000000000000LL) != 0)
  {
    uint64_t v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFE0LL) {
      Swift::UInt64 v54 = 0;
    }
    else {
      Swift::UInt64 v54 = v118 << -(char)v90;
    }
  }

  else
  {
    uint64_t v55 = v120;
    if (v90 >= 0x20) {
      Swift::UInt64 v54 = v118 >> 31;
    }
    else {
      Swift::UInt64 v54 = v118 >> v90;
    }
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  Swift::UInt64 v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    Swift::UInt64 v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    unint64_t v76 = v70;
    if (v75 < v124) {
      goto LABEL_70;
    }
    goto LABEL_33;
  }

  unint64_t v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  char v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  BOOL v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v70,  v29,  a3);
LABEL_55:
  uint64_t v100 = v97;
  v62(v29, a3);
  unint64_t v76 = v70;
  if ((v100 & 1) != 0) {
    goto LABEL_70;
  }
LABEL_33:
  v62(v76, a3);
LABEL_34:
  unint64_t v78 = v122;
  uint8x16_t v79 = v122(a3, a4);
  v66(v68, v69, a3);
  if (v79 < 65)
  {
    unint64_t v88 = v78(a3, a4);
    v62(v68, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0) {
      goto LABEL_47;
    }
  }

  else
  {
    v62(v68, a3);
  }

  __int128 v80 = v116;
  v66(v116, v69, a3);
  uint64_t v124 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v81 = v121(a3, a4);
  int8x16x4_t v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      unint64_t v87 = &v124;
      goto LABEL_45;
    }
  }

  else if (v82 > 63)
  {
    char v123 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    char v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    unint64_t v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    id v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v80,  a3);
    v62(v29, a3);
    if ((v89 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_46;
  }

  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v62(v69, a3);
  if ((v90 & 0x8000000000000000LL) != 0)
  {
    uint64_t v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFE0LL) {
      Swift::UInt64 v54 = v119 >> 31;
    }
    else {
      Swift::UInt64 v54 = v119 >> -(char)v90;
    }
  }

  else
  {
    uint64_t v55 = v120;
    if (v90 >= 0x20) {
      Swift::UInt64 v54 = 0;
    }
    else {
      Swift::UInt64 v54 = v119 << v90;
    }
  }

    if (v23 != v25)
    {
      uint64_t v26 = v32 + 1;
      do
      {
        uint64_t v27 = *v23++;
      }

      while (v23 != v25);
    }
  }

uint64_t _StringGuts.withFastUTF8<A>(range:_:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(char *), uint64_t a4, uint64_t a5, unint64_t a6)
{
  if ((a6 & 0x2000000000000000LL) == 0)
  {
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      id v9 = (id)((a6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v10 = a5 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0x8000000000000000LL) == 0) {
        goto LABEL_4;
      }
    }

    else
    {
      id v9 = _StringObject.sharedUTF8.getter(a5, a6);
      uint64_t v10 = v14;
      if ((a1 & 0x8000000000000000LL) == 0)
      {
LABEL_4:
        if (v10 >= a2)
        {
          int v11 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a1, a2, (uint64_t)v9, v10);
          return a3(v11);
        }

        goto LABEL_11;
      }
    }

BOOL _stringCompareFastUTF8Abnormal(_:_:expecting:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  int v7 = a5 & 1;
  if (a4 >= a2) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = a4;
  }
  if (v8 < 1)
  {
LABEL_8:
    if ((a5 & 1) != 0) {
      return a2 < a4;
    }
    else {
      return a2 == a4;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    while (*(unsigned __int8 *)(a1 + v11) == *(unsigned __int8 *)(a3 + v11))
    {
      if (v8 == ++v11) {
        goto LABEL_8;
      }
    }

    uint64_t v13 = a2;
    if (a2 != v11)
    {
      uint64_t v14 = v11;
      do
        int v15 = *(_BYTE *)(a1 + v14--) & 0xC0;
      while (v15 == 128);
      uint64_t v13 = v14 + 1;
    }

    unsigned int v16 = _decodeScalar(_:startingAt:)(a1, a2, v13);
    uint64_t v18 = v17;
    unsigned int v19 = _decodeScalar(_:startingAt:)(a3, v17, v13);
    uint64_t v40 = v20;
    if (v16 >= 0x300 && (_swift_stdlib_getNormData(v16) & 0x7FE) != 0
      || v19 >= 0x300 && (_swift_stdlib_getNormData(v19) & 0x7FE) != 0
      || !UnsafeBufferPointer<A>.hasNormalizationBoundary(before:)(v18 + v13, a1, a2)
      || !UnsafeBufferPointer<A>.hasNormalizationBoundary(before:)(v40 + v13, a3, a4))
    {
      uint64_t v22 = _findBoundary(_:before:)(a1, a2, v11);
      uint64_t v23 = _findBoundary(_:before:)(a3, a4, v11);
      if (v23 >= v22) {
        uint64_t v24 = v22;
      }
      else {
        uint64_t v24 = v23;
      }
      uint64_t v25 = specialized Collection.subscript.getter(v24, a1, a2);
      uint64_t v29 = specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
      uint64_t v31 = v30;
      uint64_t v32 = specialized Collection.subscript.getter(v24, a3, a4);
      uint64_t v36 = specialized UnsafeBufferPointer.init(rebasing:)(v32, v33, v34, v35);
      uint64_t v38 = ((unint64_t)(v29 + 0x7FFFFFFFFFFFFFE0LL) >> 56) & 0xF;
      if (((v29 + 0x7FFFFFFFFFFFFFE0LL) & 0x2000000000000000LL) == 0) {
        uint64_t v38 = v31 & 0xFFFFFFFFFFFFLL;
      }
      if (((v36 + 0x7FFFFFFFFFFFFFE0LL) & 0x2000000000000000LL) != 0) {
        uint64_t v39 = ((unint64_t)(v36 + 0x7FFFFFFFFFFFFFE0LL) >> 56) & 0xF;
      }
      else {
        uint64_t v39 = v37 & 0xFFFFFFFFFFFFLL;
      }
      return _StringGutsSlice.compare(with:expecting:)( v37 | 0x1000000000000000LL,  (v36 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL,  0LL,  v39,  v7,  v31 | 0x1000000000000000LL,  (v29 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL,  0LL,  v38);
    }

    else
    {
      if (v7) {
        BOOL v21 = v16 >= v19;
      }
      else {
        BOOL v21 = 1;
      }
      return !v21;
    }
  }

uint64_t _scalarAlign(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != a2)
  {
    do
      int v3 = *(_BYTE *)(a1 + a3--) & 0xC0;
    while (v3 == 128);
    ++a3;
  }

  return a3;
}

BOOL UnsafeBufferPointer<A>.hasNormalizationBoundary(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL result = 1LL;
  if (a1 && a1 != a3)
  {
    unsigned int v5 = _decodeScalar(_:startingAt:)(a2, a2, a1);
    if (v5 >= 0x300)
    {
      __int16 NormData = _swift_stdlib_getNormData(v5);
      if ((NormData & 0x7F8) != 0) {
        return 0LL;
      }
    }

    else
    {
      LOBYTE(NormData) = 0;
    }

    return (NormData & 6) == 0;
  }

  return result;
}

uint64_t _findBoundary(_:before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (a3 < a2)
  {
    do
      int v4 = *(_BYTE *)(a1 + a3--) & 0xC0;
    while (v4 == 128);
    if (a3 == -1)
    {
      return 0LL;
    }

    else
    {
      uint64_t v3 = a3 + 1;
      int v6 = *(char *)(a1 + a3 + 1);
      if (v6 < 0) {
        __asm { BR              X10 }
      }
    }
  }

  return v3;
}

void sub_1815EC4F8()
{
  unsigned int v4 = ((v0 & 0x1F) << 6) | *(_BYTE *)(v2 + v1 + 1) & 0x3F;
  if (v4 >= 0x300 && (_swift_stdlib_getNormData(v4) & 0x7FE) != 0)
  {
    uint64_t v5 = v2 - 1;
    if ((*(_BYTE *)(v1 + v2 - 1) & 0xC0) == 0x80)
    {
      do
        int v6 = *(_BYTE *)(v3 + v2--) & 0xC0;
      while (v6 == 128);
      uint64_t v5 = v2 - 1;
    }

    if (v5) {
      JUMPOUT(0x1815EC4C8LL);
    }
  }

  JUMPOUT(0x1815EC4A0LL);
}

BOOL _StringGutsSlice.compare(with:expecting:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = a6;
  uint64_t v12 = a4;
  uint64_t v15 = a1;
  uint64_t v16 = a9;
  int v17 = a5 & 1;
  if ((a7 & 0x1000000000000000LL) != 0 || (a2 & 0x1000000000000000LL) != 0) {
    return _StringGutsSlice._slowCompare(with:expecting:)(v15, a2, a3, v12, v17, v11, a7, a8, v16);
  }
  if ((a7 & 0x2000000000000000LL) != 0)
  {
    uint64_t v68 = a6;
    uint64_t v69 = a7 & 0xFFFFFFFFFFFFFFLL;
    if (a8 < 0) {
      goto LABEL_57;
    }
    uint64_t v38 = a9 - a8;
    if (a9 - a8 >= 0)
    {
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        v67[0] = a1;
        v67[1] = a2 & 0xFFFFFFFFFFFFFFLL;
        if (a3 < 0) {
          goto LABEL_57;
        }
        int v41 = a5 & 1;
        uint64_t v42 = a6;
        uint64_t v45 = a4 - a3;
        if (a4 - a3 < 0) {
          goto LABEL_51;
        }
        BOOL v48 = (char *)v67 + a3;
        if (v45 >= v38) {
          size_t v46 = a9 - a8;
        }
        else {
          size_t v46 = a4 - a3;
        }
        int v47 = (char *)&v68 + a8;
      }

      else
      {
        if ((a1 & 0x1000000000000000LL) != 0)
        {
          uint64_t v39 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
          uint64_t v40 = a1 & 0xFFFFFFFFFFFFLL;
          if (a3 < 0) {
            goto LABEL_57;
          }
        }

        else
        {
          id v62 = _StringObject.sharedUTF8.getter(a1, a2);
          uint64_t v12 = a4;
          uint64_t v39 = (uint64_t)v62;
          uint64_t v40 = v63;
          if (a3 < 0) {
            goto LABEL_57;
          }
        }

        if (v40 < v12) {
          goto LABEL_50;
        }
        int v41 = v17;
        uint64_t v42 = v11;
        uint64_t v44 = specialized UnsafeBufferPointer.init(rebasing:)(a3, v12, v39, v40);
        uint64_t v45 = v43;
        if (v43 >= v38) {
          size_t v46 = a9 - a8;
        }
        else {
          size_t v46 = v43;
        }
        int v47 = (char *)&v68 + a8;
        BOOL v48 = (char *)v44;
      }

      int v56 = _swift_stdlib_memcmp(v47, v48, v46);
      uint64_t v57 = v56;
      if (!v56) {
        uint64_t v57 = v38 - v45;
      }
      uint64_t v11 = v42;
      int v17 = v41;
      uint64_t v15 = a1;
      uint64_t v12 = a4;
      if (!v57) {
        return v17 == 0;
      }
      return _StringGutsSlice._slowCompare(with:expecting:)(v15, a2, a3, v12, v17, v11, a7, a8, v16);
    }

uint64_t _utf8ScalarLength(_:endingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  do
    int v4 = *(_BYTE *)(a3 + a1 - 1 + v3--) & 0xC0;
  while (v4 == 128);
  return -v3;
}

Swift::_StringComparisonResult __swiftcall _StringComparisonResult.init(signedNotation:)(Swift::Int signedNotation)
{
  return signedNotation != 0;
}

Swift::Int _StringComparisonResult.hashValue.getter(char a1)
{
  return Hasher._finalize()();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance _StringComparisonResult( _BYTE *a1, _BYTE *a2)
{
  if ((*a1 & 1) != 0)
  {
    if (*a2) {
      return 1LL;
    }
  }

  else if ((*a2 & 1) == 0)
  {
    return 1LL;
  }

  return 0LL;
}

BOOL _StringGutsSlice._slowCompare(with:expecting:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v9 = HIBYTE(a7) & 0xF;
  if ((a7 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = a6 & 0xFFFFFFFFFFFFLL;
  }
  if (v9 < (a9 & 0xFFFFFFFFFFFFuLL)) {
    goto LABEL_128;
  }
  id v89 = &_swiftEmptyArrayStorage;
  unint64_t v11 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    unint64_t v11 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < (a4 & 0xFFFFFFFFFFFFuLL)) {
LABEL_128:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
  unint64_t v87 = &_swiftEmptyArrayStorage;
  swift_bridgeObjectRetain(a7, a2, a3, (char *)a4);
  swift_bridgeObjectRetain(a2, v12, v13, v14);
  BOOL v15 = 0;
  unint64_t v16 = 0LL;
  unint64_t v17 = 0LL;
  BOOL v18 = 0;
  char v19 = 1;
  int v20 = 1;
  while (1)
  {
    int64_t v21 = v89;
    unint64_t v22 = (unint64_t)v89[2];
    BOOL v86 = v22 != 0;
    if (v22)
    {
      if (!v18)
      {
        unint64_t v23 = v22 - 1;
        if (v22 > 1)
        {
          BOOL v75 = v15;
          int v79 = v20;
          uint64_t v24 = 0LL;
          unint64_t v25 = 0LL;
          uint64_t v26 = 8 * v22 + 24;
          do
          {
            int64_t v27 = v21[2];
            if (v25 >= (unint64_t)v27 || v23 >= (unint64_t)v27) {
LABEL_121:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
            __int16 v81 = WORD2(v21[v24 + 4]);
            int v84 = (int)v21[v24 + 4];
            int v28 = *(_DWORD *)((char *)v21 + v26);
            __int16 v29 = *(_WORD *)((char *)v21 + v26 + 4);
            specialized Array._checkSubscript_mutating(_:)(v25, (uint64_t)v21);
            uint64_t v30 = &v21[v24];
            *((_DWORD *)v30 + 8) = v28;
            *((_WORD *)v30 + 18) = v29;
            specialized Array._checkSubscript_mutating(_:)(v23, (uint64_t)v21);
            int64_t v31 = (char *)v21 + v26;
            *(_DWORD *)int64_t v31 = v84;
            *((_WORD *)v31 + 2) = v81;
            ++v25;
            --v23;
            v26 -= 8LL;
            ++v24;
          }

          while ((uint64_t)v25 < (uint64_t)v23);
          int v20 = v79;
          BOOL v15 = v75;
          if (!v21[2]) {
LABEL_127:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x363uLL,  0);
        }
      }

      if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v21))
      {
        uint64_t v45 = v21[2];
        if (!v45) {
          goto LABEL_120;
        }
      }

      else
      {
        int64_t v21 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v21);
        uint64_t v45 = v21[2];
        if (!v45) {
          goto LABEL_120;
        }
      }

      char v46 = 0;
      int v47 = (__objc2_class *)((char *)v45 - 1);
      unsigned int v48 = v21[(void)v47 + 4];
      void v21[2] = v47;
      id v89 = v21;
      goto LABEL_59;
    }

    unint64_t v32 = specialized Unicode._InternalNFD.Iterator.next()();
    char v33 = v20;
    unint64_t v34 = v17;
    if ((v32 & 0x1000000000000LL) != 0) {
      goto LABEL_56;
    }
    while (2)
    {
      unint64_t v17 = v32;
      while (1)
      {
        if ((v33 & 1) != 0)
        {
          if ((v17 & 0x7F800000000LL) == 0) {
            goto LABEL_49;
          }
          int v20 = 1;
          unsigned int v48 = v17;
          unint64_t v17 = v34;
          goto LABEL_58;
        }

        int64_t v36 = v89;
        uint64_t v37 = v89[2];
        if (!v37)
        {
          if (v17 >= 0x300 && (v17 & 0x600000000LL) != 0)
          {
            unint64_t v38 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v34, v17);
            if ((v38 & 0x100000000LL) == 0)
            {
LABEL_51:
              unint64_t v17 = v38;
              goto LABEL_49;
            }

            uint64_t Composition = _swift_stdlib_getComposition(v34, v17);
            if ((_DWORD)Composition != -1) {
              break;
            }
          }

          if ((v17 & 0x7F800000000LL) == 0) {
            goto LABEL_57;
          }
          goto LABEL_35;
        }

        if ((v17 >> 35) <= (WORD2(v89[(void)v37 + 3]) >> 3))
        {
          if ((v17 >> 35))
          {
            if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v89))
            {
              int64_t v36 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v37->isa + 1,  1,  (uint64_t)v89);
              id v89 = v36;
            }

            unint64_t v43 = (unint64_t)v36[2];
            unint64_t v42 = (unint64_t)v36[3];
            if (v43 >= v42 >> 1)
            {
              int64_t v36 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v42 > 1),  v43 + 1,  1,  (uint64_t)v36);
              id v89 = v36;
            }

            v36[2] = (__objc2_class *)(v43 + 1);
            uint64_t v44 = &v36[v43];
            *((_DWORD *)v44 + 8) = v17;
            *((_WORD *)v44 + 18) = WORD2(v17);
            goto LABEL_23;
          }

LABEL_120:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty Array",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x51CuLL,  0);
    }

    char v83 = v46;
    unint64_t v60 = specialized Unicode._InternalNFD.Iterator.next()();
    if ((v60 & 0x1000000000000LL) != 0)
    {
      LODWORD(v62) = v16;
      char v68 = v19;
      char v19 = 1;
      unint64_t v16 = 0LL;
      if ((v46 & 1) == 0) {
        goto LABEL_109;
      }
      goto LABEL_122;
    }

    unint64_t v61 = v60;
    unint64_t v62 = v16;
LABEL_79:
    unint64_t v16 = v62;
    if ((v19 & 1) != 0) {
      break;
    }
    uint64_t v63 = v87;
    uint64_t v67 = v87[2];
    if (v67)
    {
      if ((v61 >> 35) <= (WORD2(v87[(void)v67 + 3]) >> 3))
      {
      }

      else if (v61 >= 0x300 && (v61 & 0x600000000LL) != 0)
      {
        unint64_t v62 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v62, v61);
        if ((v62 & 0x100000000LL) == 0) {
          goto LABEL_78;
        }
        unint64_t v62 = _swift_stdlib_getComposition(v16, v61);
        if ((_DWORD)v62 != -1) {
          goto LABEL_78;
        }
      }

      specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
      uint64_t v63 = v87;
      goto LABEL_75;
    }

    if (v61 >= 0x300 && (v61 & 0x600000000LL) != 0)
    {
      unint64_t v62 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v62, v61);
      if ((v62 & 0x100000000LL) == 0) {
        goto LABEL_78;
      }
      unint64_t v62 = _swift_stdlib_getComposition(v16, v61);
      if ((_DWORD)v62 != -1) {
        goto LABEL_78;
      }
    }

    if ((v61 & 0x7F800000000LL) != 0)
    {
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v87))
      {
        uint64_t v63 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v87[2]->isa + 1,  1,  (uint64_t)v87);
        unint64_t v87 = v63;
      }

    size_t v92 = _StringObject.sharedUTF8.getter(v6, v26);
    uint64_t v93 = v155;
    if (v155 < v7) {
      goto LABEL_121;
    }
LABEL_67:
    unint64_t v94 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v29, v7, (uint64_t)v92, v93);
    _StringGuts.appendInPlace(_:isASCII:)(v94, v95, v6 < 0);
LABEL_85:
    swift_bridgeObjectRelease(v26);
  }

  unint64_t v115 = v158;
  unint64_t v9 = v160;
LABEL_89:
  uint64_t v131 = __src;
  uint64_t v132 = v164;
  swift_bridgeObjectRelease(v115[1]);
  *unint64_t v115 = v131;
  v115[1] = v132;
  return v9;
}

  v22.partialValue.low = 0LL;
  uint64_t v8 = 0;
LABEL_193:
  unint64_t v103 = v8;
LABEL_194:
  LOBYTE(v102[0]) = (a2 & 0x1000000000000000LL) != 0;
  return v22.partialValue.low;
}

uint64_t Substring.init(_:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    unint64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v4 < (a4 & 0xFFFFFFFFFFFFuLL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
  }
  if (((a3 << 16) | 1uLL) >= 0x10000) {
    return (a3 << 16) | 1;
  }
  else {
    return (a3 << 16) | 3;
  }
}

BOOL _allASCII(_:)(uint64_t *a1, uint64_t a2)
{
  if (!a2) {
    return 1LL;
  }
  if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFF0LL) < 1)
  {
    uint64_t i = a1;
  }

  else
  {
    if (((a1[1] | *a1) & 0x8080808080808080LL) != 0) {
      return 0LL;
    }
    for (uint64_t i = a1 + 2; i < (uint64_t *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFF0LL)); i += 2)
    {
      uint64_t v3 = *i;
      uint64_t v4 = i[1];
      if (((v4 | v3) & 0x8080808080808080LL) != 0) {
        return 0LL;
      }
    }
  }

  if (i < (uint64_t *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFF8LL)))
  {
    if ((*i & 0x8080808080808080LL) != 0) {
      return 0LL;
    }
    ++i;
  }

  if (i < (uint64_t *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFFCLL)))
  {
    if ((*(_DWORD *)i & 0x80808080) != 0) {
      return 0LL;
    }
    uint64_t i = (uint64_t *)((char *)i + 4);
  }

  if (i < (uint64_t *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFFELL)))
  {
    if ((*(_WORD *)i & 0x8080) != 0) {
      return 0LL;
    }
    uint64_t i = (uint64_t *)((char *)i + 2);
  }

  return i >= (uint64_t *)((char *)a1 + a2) || (*(char *)i & 0x80000000) == 0;
}

uint64_t static UInt16.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

BOOL static UInt16.== infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 == a2;
}

uint64_t validateUTF8(_:)(uint64_t *a1, uint64_t a2)
{
  if (_allASCII(_:)(a1, a2)) {
    return 1LL;
  }
  if (a1 && a2)
  {
    uint64_t v5 = 0LL;
    int v6 = (uint64_t *)((char *)a1 + a2);
    char v7 = 1;
    uint64_t v8 = a1;
    unint64_t v9 = a1;
    while (1)
    {
      int v11 = *(char *)v9;
      unint64_t v9 = (uint64_t *)((char *)v9 + 1);
      unsigned __int8 v10 = v11;
      if ((v11 & 0x80000000) == 0)
      {
        uint64_t v12 = 1LL;
        goto LABEL_8;
      }

      if (v10 <= 0xDFu)
      {
        if (v9 == v6 || (*(_BYTE *)v9 & 0xC0) != 0x80) {
          goto LABEL_53;
        }
        char v7 = 0;
        unint64_t v9 = (uint64_t *)((char *)v8 + 2);
        uint64_t v12 = 2LL;
      }

      else
      {
        if (v10 == 224)
        {
          if (v9 == v6
            || ((uint64_t v13 = (uint64_t *)((char *)v8 + 2), (*((_BYTE *)v8 + 1) + 64) >= 0xE0u)
              ? (BOOL v14 = v13 == v6)
              : (BOOL v14 = 1),
                v14))
          {
LABEL_53:
            unint64_t v17 = swift_allocError( (uint64_t)&unk_189B86A70,  (uint64_t)&protocol witness table for UTF8ValidationError,  0LL,  0);
            swift_willThrow();
            swift_errorRelease(v17);
            uint64_t v18 = specialized Collection.subscript.getter(v5, (uint64_t)a1, a2);
            return findInvalidRange #1 (_:) in validateUTF8(_:)(v18, v19, v20, v21);
          }

          goto LABEL_37;
        }

        if (v10 <= 0xECu) {
          goto LABEL_33;
        }
        if (v10 == 237)
        {
          if (v9 == v6) {
            goto LABEL_53;
          }
          unsigned int v15 = *((unsigned __int8 *)v8 + 1);
          if (v15 > 0x9F) {
            goto LABEL_53;
          }
LABEL_35:
          if ((v15 & 0xC0) != 0x80) {
            goto LABEL_53;
          }
          uint64_t v13 = (uint64_t *)((char *)v8 + 2);
LABEL_37:
          if ((*(_BYTE *)v13 & 0xC0) != 0x80) {
            goto LABEL_53;
          }
          char v7 = 0;
          unint64_t v9 = (uint64_t *)((char *)v8 + 3);
          uint64_t v12 = 3LL;
          goto LABEL_8;
        }

        if ((v10 + 16) >= 0xFEu)
        {
LABEL_33:
          if (v9 == v6) {
            goto LABEL_53;
          }
          LOBYTE(v15) = *((_BYTE *)v8 + 1);
          goto LABEL_35;
        }

        if (v10 == 240)
        {
        }

        else
        {
          if ((v10 + 12) >= 0xFDu)
          {
            if (v9 == v6) {
              goto LABEL_53;
            }
            LOBYTE(v16) = *((_BYTE *)v8 + 1);
          }

          else
          {
            if (v9 == v6) {
              goto LABEL_53;
            }
            unsigned int v16 = *((unsigned __int8 *)v8 + 1);
            if (v16 > 0x8F) {
              goto LABEL_53;
            }
          }

          if ((v16 & 0xC0) != 0x80) {
            goto LABEL_53;
          }
        }

        if ((uint64_t *)((char *)v8 + 2) == v6
          || (*((_BYTE *)v8 + 2) & 0xC0) != 0x80
          || (uint64_t *)((char *)v8 + 3) == v6
          || (*((_BYTE *)v8 + 3) & 0xC0) != 0x80)
        {
          goto LABEL_53;
        }

        char v7 = 0;
        unint64_t v9 = (uint64_t *)((char *)v8 + 4);
        uint64_t v12 = 4LL;
      }

uint64_t repairUTF8(_:firstKnownBrokenRange:)( char *a1, int64_t a2, int64_t a3, int64_t a4)
{
  uint64_t v52 = 0LL;
  unint64_t v53 = 0xE000000000000000LL;
  if (__OFADD__(a2, 15LL))
  {
    __break(1u);
    goto LABEL_121;
  }

  int64_t v7 = a2;
  _StringGuts.reserveCapacity(_:)(a2 + 15);
  if (a3 < 0) {
    goto LABEL_102;
  }
  while (1)
  {
    if (v7 < a3) {
      goto LABEL_110;
    }
    uint64_t v8 = v52 & 0xFFFFFFFFFFFFLL;
    if ((v53 & 0x2000000000000000LL) != 0) {
      uint64_t v8 = HIBYTE(v53) & 0xF;
    }
    BOOL v9 = __OFADD__(v8, v7);
    uint64_t v10 = v8 + v7;
    if (v9)
    {
      __break(1u);
LABEL_112:
      __break(1u);
LABEL_113:
      __break(1u);
LABEL_114:
      unint64_t v51 = 1860LL;
      goto LABEL_109;
    }

    if (__OFADD__(v10, 3LL)) {
      goto LABEL_112;
    }
    _StringGuts.reserveCapacity(_:)(v10 + 3);
    if (a3 && !a1) {
      goto LABEL_122;
    }
    uint64_t v11 = v53 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v12 = (v53 & 0xFFFFFFFFFFFFFFFLL) + 32;
    specialized UnsafeMutablePointer.initialize(from:count:)( a1,  a3,  (char *)(v12 + (*(void *)((v53 & 0xFFFFFFFFFFFFFFFLL) + 0x18) & 0xFFFFFFFFFFFFLL)));
    uint64_t v13 = *(void *)(v11 + 24) & 0xFFFFFFFFFFFFLL;
    if (__OFADD__(v13, a3)) {
      goto LABEL_113;
    }
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v13 + a3, 0);
    uint64_t v52 = *(void *)(v11 + 24);
    size_t v54 = 3LL;
    uint64_t v55 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v55, &v54, &v52);
    if (v7 < a4) {
      goto LABEL_102;
    }
    if (a4 < 0) {
      goto LABEL_114;
    }
    size_t v14 = v7 - a4;
    if (v7 - a4 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    uint64_t v15 = (uint64_t)&a1[a4];
    if (!v14) {
      break;
    }
    unsigned int v16 = &a1[a4];
    if ((v14 & 0xFFFFFFFFFFFFFFF0LL) != 0)
    {
      if (((*(void *)(v15 + 8) | *(void *)v15) & 0x8080808080808080LL) != 0) {
        goto LABEL_32;
      }
      unsigned int v16 = &a1[a4 + 16];
      while ((unint64_t)v16 < v15 + (v14 & 0xFFFFFFFFFFFFFFF0LL))
      {
        uint64_t v17 = *(void *)v16;
        uint64_t v18 = *((void *)v16 + 1);
        v16 += 16;
        if (((v18 | v17) & 0x8080808080808080LL) != 0) {
          goto LABEL_32;
        }
      }
    }

    if ((unint64_t)v16 < v15 + (v14 & 0xFFFFFFFFFFFFFFF8LL))
    {
      if ((*(void *)v16 & 0x8080808080808080LL) != 0) {
        goto LABEL_32;
      }
      v16 += 8;
    }

    if ((unint64_t)v16 < v15 + (v14 & 0xFFFFFFFFFFFFFFFCLL))
    {
      if ((*(_DWORD *)v16 & 0x80808080) != 0) {
        goto LABEL_32;
      }
      v16 += 4;
    }

    if ((*(_WORD *)v16 & 0x8080) == 0)
    {
      v16 += 2;
LABEL_30:
    }

Swift::Void __swiftcall __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( Swift::Int newCount, Swift::Bool newIsASCII)
{
  if (newIsASCII) {
    unint64_t v3 = newCount | 0xC000000000000000LL;
  }
  else {
    unint64_t v3 = newCount;
  }
  *(void *)(v2 + 24) = v3 | 0x3000000000000000LL;
  *(_BYTE *)(v2 + 32 + (v3 & 0xFFFFFFFFFFFFLL)) = 0;
  uint64_t v4 = *(void *)(v2 + 16);
  if (v4 < 0)
  {
    uint64_t v5 = (uint64_t *)((v2 + 32 + (v4 & 0xFFFFFFFFFFFFLL) + 7) & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v6 = *v5;
    *uint64_t v5 = 0LL;
    swift_release(v6);
  }

uint64_t static String._uncheckedFromUTF16(_:)(unsigned __int16 *a1, uint64_t a2)
{
  uint64_t v4 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  a2 & ~(a2 >> 63),  0,  (uint64_t)&_swiftEmptyArrayStorage);
  int64_t v7 = (uint8x16_t *)v4;
  unsigned int v8 = 0;
  unsigned __int8 v9 = 0;
  if (a1) {
    uint64_t v10 = &a1[a2];
  }
  else {
    uint64_t v10 = 0LL;
  }
  unsigned int v43 = 0;
  unsigned __int8 v44 = 0;
  uint64_t v11 = &type metadata for Unicode.UTF16.ForwardParser;
  while (v9)
  {
    if ((v8 & 0xF800) != 0xD800)
    {
      int v24 = v11;
      lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser( (uint64_t)v4,  (uint64_t)v11,  v5);
      uint64_t v41 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      uint64_t v4 = (__objc2_class **)((uint64_t (*)(char *, void))v41)(v42, 0LL);
      uint64_t v11 = v24;
      unsigned int v8 = (unsigned __int16)v8;
      char v18 = 1;
      goto LABEL_25;
    }

    if (!a1) {
      goto LABEL_16;
    }
    uint64_t v13 = a1;
    if (a1 == v10) {
      goto LABEL_16;
    }
LABEL_12:
    unsigned int v14 = v9;
    if (v9 >= 0x20u) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    }
    a1 = v13 + 1;
    unsigned int v8 = (*v13 << v9) | ((-65535 << v9) - 1) & v8;
    v9 += 16;
    if (v14 <= 0xF && a1 != v10)
    {
      a1 = v13 + 2;
      unsigned int v8 = (v13[1] << v9) | ((0x10000 << v14) - 1) & v8;
      unsigned __int8 v9 = v14 + 32;
    }

uint64_t specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(uint64_t a1, char a2)
{
  int64_t v4 = *(void *)(a1 + 16);
  unsigned int v8 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v4,  0,  (uint64_t)&_swiftEmptyArrayStorage);
  if (!v4) {
    goto LABEL_33;
  }
  int64_t v9 = 0LL;
  char v10 = 0;
  uint64_t v11 = a1 + 32;
  uint64_t v5 = 8487393LL;
  do
  {
    if (v9 <= v4) {
      int64_t v12 = v4;
    }
    else {
      int64_t v12 = v9;
    }
    while (1)
    {
      if (v9 == v12) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      unsigned int v13 = *(_DWORD *)(v11 + 4 * v9++);
      unsigned int v14 = HIWORD(v13);
      if (HIWORD(v13) > 0x10u || (v13 & 0xFFFFF800) == 55296) {
        break;
      }
      if (v13 >= 0x80)
      {
        int v21 = (v13 & 0x3F) << 8;
        if (v13 >= 0x800)
        {
          unsigned int v22 = v13 >> 12;
          int v23 = (v21 | (v13 >> 6) & 0x3F) << 8;
          int v24 = (((v23 | (v13 >> 12) & 0x3F) << 8) | (v13 >> 18)) - 2122219023;
          int v25 = (v23 | v22) + 8487393;
          if (v14) {
            unsigned int v16 = v24;
          }
          else {
            unsigned int v16 = v25;
          }
        }

        else
        {
          unsigned int v16 = (v21 | (v13 >> 6)) + 33217;
        }
      }

      else
      {
        unsigned int v16 = v13 + 1;
      }

      unint64_t v17 = v8[1].u64[0];
      do
      {
        unint64_t v18 = v8[1].u64[1];
        if (v17 >= v18 >> 1)
        {
          unint64_t v20 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v18 > 1),  v17 + 1,  1,  (uint64_t)v8);
          uint64_t v5 = 8487393LL;
          unsigned int v8 = (uint8x16_t *)v20;
        }

        v8[1].i64[0] = v17 + 1;
        v8[2].i8[v17++] = v16 - 1;
        BOOL v19 = v16 >= 0x100;
        v16 >>= 8;
      }

      while (v19);
      if (v9 == v4) {
        goto LABEL_35;
      }
    }

    unint64_t v27 = v8[1].u64[0];
    unint64_t v26 = v8[1].u64[1];
    unint64_t v28 = v26 >> 1;
    unint64_t v29 = v27 + 1;
    if (v26 >> 1 <= v27)
    {
      unint64_t v31 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v26 > 1),  v27 + 1,  1,  (uint64_t)v8);
      uint64_t v5 = 8487393LL;
      unsigned int v8 = (uint8x16_t *)v31;
      unint64_t v26 = (unint64_t)v31[3];
      unint64_t v28 = v26 >> 1;
    }

    v8[1].i64[0] = v29;
    v8[2].i8[v27] = -17;
    unint64_t v30 = v27 + 2;
    if (v28 <= v29)
    {
      uint64_t v32 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v26 > 1),  v27 + 2,  1,  (uint64_t)v8);
      uint64_t v5 = 8487393LL;
      unsigned int v8 = (uint8x16_t *)v32;
      unint64_t v26 = (unint64_t)v32[3];
      unint64_t v28 = v26 >> 1;
    }

    v8[1].i64[0] = v30;
    v8[2].i8[v29] = -65;
    if (v28 <= v30)
    {
      unsigned int v33 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v26 > 1),  v27 + 3,  1,  (uint64_t)v8);
      uint64_t v5 = 8487393LL;
      unsigned int v8 = (uint8x16_t *)v33;
    }

    v8[1].i64[0] = v27 + 3;
    v8[2].i8[v30] = -67;
    char v10 = 1;
  }

  while (v9 != v4);
LABEL_35:
  if ((v10 & 1) != 0 && (a2 & 1) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v8);
    return 0LL;
  }

  else
  {
LABEL_33:
    uint64_t v34 = v8[1].i64[0];
    swift_bridgeObjectRetain((unint64_t)v8, v5, v6, v7);
    uint64_t v35 = specialized static String._uncheckedFromUTF8(_:)(v8 + 2, v34);
    swift_bridgeObjectRelease_n((uint64_t)v8, 2LL);
  }

  return v35;
}

{
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint8x16_t *v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  int64_t v12;
  int64_t v13;
  int64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __objc2_class **v23;
  unint64_t v24;
  int64_t v25;
  uint64_t v26;
  uint64_t v27;
  __objc2_class **v28;
  uint64_t v29;
  uint64_t v30;
  __objc2_class **v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __objc2_class **v35;
  uint64_t v36;
  uint64_t v37;
  char v39;
  char v40;
  int64_t v4 = *(void *)(a1 + 16);
  unsigned int v8 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v4,  0,  (uint64_t)&_swiftEmptyArrayStorage);
  if (!v4) {
    goto LABEL_22;
  }
  uint64_t v39 = a2;
  uint64_t v40 = 0;
  int64_t v9 = 0LL;
  char v10 = a1 + 32;
  do
  {
    uint64_t v11 = 0LL;
    if (v9 <= v4) {
      int64_t v12 = v4;
    }
    else {
      int64_t v12 = v9;
    }
    unsigned int v13 = v9 - v12;
    unsigned int v14 = v4;
    unsigned int v15 = v10;
    while (1)
    {
      if (!(v13 + v11)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      unsigned int v16 = *(char *)(v15 + v9);
      unint64_t v18 = v8[1].u64[0];
      unint64_t v17 = v8[1].u64[1];
      BOOL v19 = v17 >> 1;
      unint64_t v20 = v18 + 1;
      if (v16 < 0) {
        break;
      }
      if (v19 <= v18)
      {
        int v21 = (uint64_t)v8;
        unsigned int v22 = v10;
        int v23 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v17 > 1),  v18 + 1,  1,  v21);
        char v10 = v22;
        unsigned int v8 = (uint8x16_t *)v23;
      }

      v8[1].i64[0] = v20;
      v8[2].i8[v18] = v16;
      ++v11;
      ++v15;
      if (v9 == --v14) {
        goto LABEL_24;
      }
    }

    if (v19 <= v18)
    {
      unint64_t v26 = (uint64_t)v8;
      unint64_t v27 = v10;
      unint64_t v28 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v17 > 1),  v18 + 1,  1,  v26);
      char v10 = v27;
      unsigned int v8 = (uint8x16_t *)v28;
      unint64_t v17 = (unint64_t)v28[3];
      BOOL v19 = v17 >> 1;
    }

    v8[1].i64[0] = v20;
    v8[2].i8[v18] = -17;
    int v24 = v18 + 2;
    if (v19 <= v20)
    {
      unint64_t v29 = (uint64_t)v8;
      unint64_t v30 = v10;
      unint64_t v31 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v17 > 1),  v18 + 2,  1,  v29);
      char v10 = v30;
      int v24 = v18 + 2;
      unsigned int v8 = (uint8x16_t *)v31;
      unint64_t v17 = (unint64_t)v31[3];
      BOOL v19 = v17 >> 1;
    }

    v8[1].i64[0] = v24;
    v8[2].i8[v20] = -65;
    if (v19 <= v24)
    {
      uint64_t v32 = v24;
      unsigned int v33 = (uint64_t)v8;
      uint64_t v34 = v10;
      uint64_t v35 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v17 > 1),  v18 + 3,  1,  v33);
      char v10 = v34;
      int v24 = v32;
      unsigned int v8 = (uint8x16_t *)v35;
    }

    int v25 = v9 + 1;
    v9 += 1 + v11;
    v8[1].i64[0] = v18 + 3;
    v8[2].i8[v24] = -67;
    uint64_t v40 = 1;
  }

  while (v25 != v14);
LABEL_24:
  if ((v40 & 1) != 0 && (v39 & 1) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v8);
    return 0LL;
  }

  else
  {
LABEL_22:
    unsigned int v36 = v8[1].i64[0];
    swift_bridgeObjectRetain((unint64_t)v8, v5, v6, v7);
    int v37 = specialized static String._uncheckedFromUTF8(_:)(v8 + 2, v36);
    swift_bridgeObjectRelease_n((uint64_t)v8, 2LL);
  }

  return v37;
}

uint64_t specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)( char *a1, uint64_t a2, char a3)
{
  int64_t v9 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  a2 & ~(a2 >> 63),  0,  (uint64_t)&_swiftEmptyArrayStorage);
  char v10 = 0;
  if (!a1 || !a2) {
    goto LABEL_20;
  }
  uint64_t v11 = &a1[a2];
  do
  {
    int64_t v12 = a1;
    while (1)
    {
      int v14 = *v12++;
      __int8 v13 = v14;
      unint64_t v16 = v9[1].u64[0];
      unint64_t v15 = v9[1].u64[1];
      unint64_t v17 = v15 >> 1;
      unint64_t v18 = v16 + 1;
      if (v14 < 0) {
        break;
      }
      if (v17 <= v16) {
        int64_t v9 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v15 > 1),  v16 + 1,  1,  (uint64_t)v9);
      }
      v9[1].i64[0] = v18;
      v9[2].i8[v16] = v13;
      a1 = v12;
      if (v12 == v11) {
        goto LABEL_17;
      }
    }

    if (v17 <= v16)
    {
      int64_t v9 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v15 > 1),  v16 + 1,  1,  (uint64_t)v9);
      unint64_t v15 = v9[1].u64[1];
      unint64_t v17 = v15 >> 1;
    }

    v9[1].i64[0] = v18;
    v9[2].i8[v16] = -17;
    unint64_t v19 = v16 + 2;
    if (v17 <= v18)
    {
      unint64_t v20 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v15 > 1),  v16 + 2,  1,  (uint64_t)v9);
      unint64_t v19 = v16 + 2;
      int64_t v9 = (uint8x16_t *)v20;
      unint64_t v15 = (unint64_t)v20[3];
      unint64_t v17 = v15 >> 1;
    }

    v9[1].i64[0] = v19;
    v9[2].i8[v18] = -65;
    if (v17 <= v19)
    {
      unint64_t v21 = v19;
      unsigned int v22 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v15 > 1),  v16 + 3,  1,  (uint64_t)v9);
      unint64_t v19 = v21;
      int64_t v9 = (uint8x16_t *)v22;
    }

    ++a1;
    v9[1].i64[0] = v16 + 3;
    v9[2].i8[v19] = -67;
    char v10 = 1;
  }

  while (a1 != v11);
LABEL_17:
  if ((v10 & 1) != 0 && (a3 & 1) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v9);
    return 0LL;
  }

  else
  {
LABEL_20:
    uint64_t v24 = v9[1].i64[0];
    swift_bridgeObjectRetain((unint64_t)v9, v6, v7, v8);
    uint64_t v23 = specialized static String._uncheckedFromUTF8(_:)(v9 + 2, v24);
    swift_bridgeObjectRelease_n((uint64_t)v9, 2LL);
  }

  return v23;
}

uint64_t specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)( unsigned __int16 *a1, uint64_t a2, char a3)
{
  uint64_t v7 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  a2 & ~(a2 >> 63),  0,  (uint64_t)&_swiftEmptyArrayStorage);
  unsigned int v8 = 0;
  unsigned __int8 v9 = 0;
  uint64_t v10 = 0LL;
  if (a1) {
    uint64_t v11 = &a1[a2];
  }
  else {
    uint64_t v11 = 0LL;
  }
  unsigned int v51 = 0;
  unsigned __int8 v52 = 0;
  int64_t v12 = &type metadata for Unicode.UTF16.ForwardParser;
  while (v9)
  {
    if ((v8 & 0xF800) != 0xD800)
    {
      unint64_t v26 = v12;
      unsigned int v48 = v10;
      lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser( v10,  (uint64_t)v12,  v5);
      uint64_t v46 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(char *, void))v46)(v50, 0LL);
      uint64_t v10 = v48;
      int64_t v12 = v26;
      unsigned int v8 = (unsigned __int16)v8;
      int v19 = 1;
      goto LABEL_25;
    }

    if (!a1) {
      goto LABEL_16;
    }
    int v14 = a1;
    if (a1 == v11) {
      goto LABEL_16;
    }
LABEL_12:
    unsigned int v15 = v9;
    if (v9 >= 0x20u) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    }
    a1 = v14 + 1;
    unsigned int v8 = (*v14 << v9) | ((-65535 << v9) - 1) & v8;
    v9 += 16;
    if (v15 <= 0xF && a1 != v11)
    {
      a1 = v14 + 2;
      unsigned int v8 = (v14[1] << v9) | ((0x10000 << v15) - 1) & v8;
      unsigned __int8 v9 = v15 + 32;
    }

uint64_t static String._slowFromCodeUnits<A, B>(_:encoding:repair:)( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6)
{
  int v69 = a2;
  BOOL v72 = a6;
  BOOL v75 = (ValueMetadata *)a4;
  unint64_t AssociatedTypeWitness = (ValueMetadata *)swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  Description = (void (**)(unsigned int *, unsigned __int8 *, ValueMetadata *))AssociatedTypeWitness[-1].Description;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v14 = (unsigned int *)&v68[-v13];
  uint64_t v77 = type metadata accessor for Unicode.ParseResult(0LL, (uint64_t)AssociatedTypeWitness, v15, v16);
  MEMORY[0x1895F8858](v77);
  char v18 = &v68[-v17];
  unint64_t v81 = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v71 = *(void *)(v81 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v81);
  int v80 = &v68[-v20];
  unint64_t v78 = *(_BYTE **)(a3 - 8);
  MEMORY[0x1895F8858](v19);
  unsigned int v76 = &v68[-((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v22 = *(void *)(a5 + 8);
  uint64_t v74 = a3;
  unint64_t v79 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v22,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v73 = *(void *)(v79 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v79);
  int v25 = &v68[-((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  MEMORY[0x1895F8858](v23);
  unint64_t v27 = &v68[-v26];
  uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v22 + 40))(a3, v22);
  unint64_t v29 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v28 & ~(v28 >> 63),  0,  (uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v30 = v74;
  (*((void (**)(_BYTE *, uint64_t, uint64_t))v78 + 2))(v76, a1, v74);
  (*(void (**)(uint64_t, uint64_t))(v22 + 32))(v30, v22);
  unint64_t v31 = *(void (**)(_BYTE *, _BYTE *, unint64_t))(v73 + 16);
  unint64_t v78 = v25;
  int64_t v32 = v25;
  uint64_t v70 = v27;
  uint64_t v33 = v79;
  v31(v32, v27, v79);
  unint64_t v34 = v81;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v72,  (uint64_t)v75,  v81,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v34,  AssociatedConformanceWitness);
  unsigned int v76 = *(_BYTE **)(AssociatedConformanceWitness + 32);
  unint64_t v36 = swift_getAssociatedConformanceWitness( v22,  v74,  v33,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  LODWORD(v74) = 0;
LABEL_2:
  while (1)
  {
    int v37 = v75;
    while (1)
    {
      ((void (*)(_BYTE *, unint64_t, unint64_t, unint64_t, unint64_t))v76)( v78,  v79,  v36,  v81,  AssociatedConformanceWitness);
      int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v18, v77);
      if (EnumCaseMultiPayload) {
        break;
      }
      Description[4](v14, v18, AssociatedTypeWitness);
      if (v37 == &type metadata for Unicode.UTF16)
      {
        if (AssociatedTypeWitness != (ValueMetadata *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>)) {
          goto LABEL_43;
        }
        unsigned int v39 = *v14;
        unsigned int v40 = (unsigned __int16)*v14;
        if (v40 > 0x7F)
        {
          int v48 = (*v14 & 0x3F) << 8;
          if (v40 < 0x800)
          {
            unsigned int v49 = v40 >> 6;
            ((void (*)(unsigned int *, ValueMetadata *))Description[1])(v14, AssociatedTypeWitness);
            int v50 = v48 | v49;
            goto LABEL_23;
          }

          if ((*v14 & 0xF800) == 0xD800)
          {
LABEL_31:
            unsigned int v55 = (*((uint64_t (**)(unsigned int *, ValueMetadata *))v72 + 11))(v14, v37);
            ((void (*)(unsigned int *, ValueMetadata *))Description[1])(v14, AssociatedTypeWitness);
            if (v55 >= 0x80)
            {
              int v56 = (v55 & 0x3F) << 8;
              if (v55 >= 0x800)
              {
                int v57 = (v56 | (v55 >> 6) & 0x3F) << 8;
                int v58 = (((v57 | (v55 >> 12) & 0x3F) << 8) | (v55 >> 18)) - 2122219023;
                int v59 = (v57 | (v55 >> 12)) + 8487393;
                if (HIWORD(v55)) {
                  unsigned int v41 = v58;
                }
                else {
                  unsigned int v41 = v59;
                }
              }

              else
              {
                int v50 = v56 | (v55 >> 6);
LABEL_23:
                unsigned int v41 = v50 + 33217;
              }
            }

            else
            {
              unsigned int v41 = v55 + 1;
            }
          }

          else
          {
            int v54 = (v48 | (v40 >> 6) & 0x3F) << 8;
            ((void (*)(unsigned int *, ValueMetadata *))Description[1])(v14, AssociatedTypeWitness);
            unsigned int v41 = (v54 & 0xFFFFFFF0 | ((unsigned __int16)v39 >> 12)) + 8487393;
          }

unint64_t closure #1 in static String._fromCodeUnits<A, B>(_:encoding:repair:)@<X0>( uint8x16_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  if (a1) {
    uint64_t v5 = a2 - (void)a1;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (_allASCII(_:)(a1->i64, v5))
  {
    unint64_t result = specialized static String._uncheckedFromASCII(_:)(a1, v5);
  }

  else
  {
    unint64_t result = 0LL;
    unint64_t v7 = 0LL;
  }

  *a3 = result;
  a3[1] = v7;
  return result;
}

unint64_t static String._fromInvalidUTF16(_:)(uint8x16_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t result = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, a2, 1LL, a4);
  if (!v5) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringCreate.swift",  24LL,  2,  0x122uLL,  0);
  }
  return result;
}

unint64_t Substring._offsetRange.getter(unint64_t a1)
{
  return a1 >> 16;
}

void *static UnsafeMutableBufferPointer.allocate(capacity:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 - 8);
  uint64_t v4 = *(void *)(v3 + 72);
  int64_t v5 = v4 * a1;
  if ((unsigned __int128)(v4 * (__int128)a1) >> 64 != v5 >> 63)
  {
    __break(1u);
    goto LABEL_8;
  }

  unsigned int v6 = *(unsigned __int8 *)(v3 + 80);
  if (v6 > 0xF) {
    uint64_t v7 = v6 + 1;
  }
  else {
    uint64_t v7 = 0LL;
  }
  unint64_t result = swift_slowAlloc(v5, v7 - 1);
  if (a1 < 0) {
LABEL_8:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  return result;
}

uint64_t _ValidUTF8Buffer.count.getter(unsigned int a1)
{
  return 4LL - (__clz(a1) >> 3);
}

uint64_t specialized Slice.deinitialize<A>()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = a3 + a1;
  if (a3) {
    uint64_t v5 = result;
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = a2 - a1;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  if (v6)
  {
    if (!v5) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
    }
  }

  else if (!v5)
  {
    return 0LL;
  }

  return result;
}

Swift::_StringObject::CountAndFlags __swiftcall _StringObject.CountAndFlags.init(count:isASCII:isNFC:isNativelyStored:isTailAllocated:)( Swift::Int count, Swift::Bool isASCII, Swift::Bool isNFC, Swift::Bool isNativelyStored, Swift::Bool isTailAllocated)
{
  v5._storage = count | 0x8000000000000000LL;
  if (!isASCII) {
    v5._storage = count;
  }
  if (isNFC) {
    v5._storage |= 0x4000000000000000LL;
  }
  if (isNativelyStored) {
    v5._storage |= 0x2000000000000000LL;
  }
  if (isTailAllocated) {
    return (Swift::_StringObject::CountAndFlags)(v5._storage | 0x1000000000000000LL);
  }
  else {
    return v5;
  }
}

uint64_t (*_StringGuts._object.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _StringObject.init(immortal:isASCII:)(uint64_t a1, unint64_t a2, char a3)
{
  unint64_t v3 = a2 | 0xC000000000000000LL;
  if ((a3 & 1) == 0) {
    unint64_t v3 = a2;
  }
  return v3 | 0x1000000000000000LL;
}

uint64_t _StringObject.count.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    return HIBYTE(a2) & 0xF;
  }
  else {
    return a1 & 0xFFFFFFFFFFFFLL;
  }
}

BOOL _StringGuts.isEmpty.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  return v2 == 0;
}

uint64_t _StringObject.smallIsASCII.getter(uint64_t a1, unint64_t a2)
{
  return (a2 >> 62) & 1;
}

BOOL _StringGuts.isASCII.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    return (a2 >> 62) & 1;
  }
  else {
    return a1 < 0;
  }
}

BOOL _StringObject.isASCII.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    return (a2 >> 62) & 1;
  }
  else {
    return a1 < 0;
  }
}

uint64_t _StringGuts.isForeign.getter(uint64_t a1, unint64_t a2)
{
  return (a2 >> 60) & 1;
}

uint64_t _StringObject.isForeign.getter(uint64_t a1, unint64_t a2)
{
  return (a2 >> 60) & 1;
}

void *_StringGuts.withFastCChar<A>(_:)@<X0>( uint64_t (*a1)(void, void)@<X0>, uint64_t a2@<X2>, unint64_t a3@<X3>, void *a4@<X8>)
{
  if ((a3 & 0x2000000000000000LL) != 0)
  {
    v8[0] = a2;
    v8[1] = a3 & 0xFFFFFFFFFFFFFFLL;
    return ((void *(*)(void *__return_ptr, void *, unint64_t))a1)(a4, v8, HIBYTE(a3) & 0xF);
  }

  else
  {
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      id v5 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a2 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      id v5 = _StringObject.sharedUTF8.getter(a2, a3);
      if (v5)
      {
        if (v6 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }
    }

    return (void *)a1(v5, v6);
  }

BOOL _StringObject.isFastZeroTerminated.getter(uint64_t a1, uint64_t a2)
{
  BOOL v2 = (a2 & 0x2000000000000000LL) != 0 || (a1 & 0x1000000000000000LL) != 0;
  return (a2 & 0x1000000000000000LL) == 0 && v2;
}

BOOL specialized _StringGuts._slowWithCString<A>(_:)( unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v6 = String.utf8CString.getter(a1, a2, a3, a4);
  unint64_t v7 = *((unsigned __int8 *)v6 + 32);
  BOOL v9 = (v7 > 0x20 || ((0x100003E01uLL >> v7) & 1) == 0)
    && (unsigned int v8 = (_BYTE *)((uint64_t (*)(__objc2_class **, uint64_t))a4)(v6 + 4, a3)) != 0LL
    && *v8 == 0;
  swift_release((uint64_t)v6);
  return v9;
}

uint64_t _StringGuts._slowWithCString<A>(_:)( void (*a1)(__objc2_class **), uint64_t a2, unint64_t a3, char *a4)
{
  id v5 = String.utf8CString.getter(a3, (unint64_t)a4, a3, a4);
  a1(v5 + 4);
  return swift_release((uint64_t)v5);
}

uint64_t _StringGuts.copyUTF8(into:)(char *__dst, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if ((a4 & 0x1000000000000000LL) != 0) {
    return _StringGuts._foreignCopyUTF8(into:)((uint64_t)__dst, a2, a3, a4);
  }
  if ((a4 & 0x2000000000000000LL) == 0)
  {
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      uint64_t v6 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      int64_t v7 = a3 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v6 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
      int64_t v7 = v8;
      if (v8 > a2) {
        return 0LL;
      }
    }

    specialized UnsafeMutablePointer.initialize(from:count:)(v6, v7, __dst);
    return v7;
  }

  int64_t v7 = HIBYTE(a4) & 0xF;
  v10[0] = a3;
  v10[1] = a4 & 0xFFFFFFFFFFFFFFLL;
  if (v7 > a2) {
    return 0LL;
  }
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)v10, HIBYTE(a4) & 0xF, __dst);
  return v7;
}

uint64_t _StringGuts._foreignCopyUTF8(into:)( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  int64_t v8 = (char *)(a4 & 0xFFFFFFFFFFFFFFFLL);
  uint64_t v9 = specialized UnsafeMutableRawBufferPointer.init<A>(_:)(a1, a2);
  uint64_t v11 = _NSStringCopyBytes(_:encoding:into:)(v8, 4LL, v9, v10);
  if ((v12 & 1) == 0) {
    return v11;
  }
  uint64_t v13 = 0LL;
  if ((a4 & 0x2000000000000000LL) != 0) {
    unint64_t v14 = HIBYTE(a4) & 0xF;
  }
  else {
    unint64_t v14 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v14)
  {
    uint64_t v15 = (a3 >> 59) & 1;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v15) = 1;
    }
    uint64_t v16 = 4LL << v15;
    uint64_t v26 = v8 + 32;
    Swift::UInt64 v17 = 15LL;
    uint64_t v18 = a2 & ~(a2 >> 63);
    do
    {
      Swift::UInt64 v19 = v17 & 0xC;
      Swift::UInt64 rawBits = v17;
      if (v19 == v16) {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v17)._rawBits;
      }
      Swift::UInt64 v21 = rawBits >> 16;
      if (rawBits >> 16 >= v14)
      {
        unint64_t v25 = 228LL;
        goto LABEL_34;
      }

      if ((a4 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt8 v23 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        if (v19 != v16) {
          goto LABEL_20;
        }
      }

      else if ((a4 & 0x2000000000000000LL) != 0)
      {
        v27[0] = a3;
        v27[1] = a4 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt8 v23 = *((_BYTE *)v27 + v21);
        if (v19 != v16) {
          goto LABEL_20;
        }
      }

      else
      {
        uint64_t v22 = v26;
        if ((a3 & 0x1000000000000000LL) == 0) {
          uint64_t v22 = _StringObject.sharedUTF8.getter(a3, a4);
        }
        Swift::UInt8 v23 = v22[v21];
        if (v19 != v16)
        {
LABEL_20:
          if ((a4 & 0x1000000000000000LL) == 0) {
            goto LABEL_21;
          }
          goto LABEL_24;
        }
      }

      Swift::UInt64 v17 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v17)._rawBits;
      if ((a4 & 0x1000000000000000LL) == 0)
      {
LABEL_21:
        Swift::UInt64 v17 = (v17 & 0xFFFFFFFFFFFF0000LL) + 65540;
        goto LABEL_26;
      }

Swift::String::Index __swiftcall _StringGuts._slowEnsureMatchingEncoding(_:)(Swift::String::Index a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  char rawBits = a1._rawBits;
  Swift::UInt64 v6 = a1._rawBits >> 16;
  uint64_t v7 = LOWORD(a1._rawBits) >> 14;
  if ((v3 & 0x1000000000000000LL) == 0 || (v4 & 0x800000000000000LL) != 0)
  {
    v13._char rawBits = String.UTF16View.index(_:offsetBy:)((Swift::String::Index)15LL, v6)._rawBits;
    Swift::UInt64 v14 = v13._rawBits + (v7 << 16);
    Swift::UInt64 v15 = v13._rawBits & 0xFFFFFFFFFFFFFFFCLL | rawBits & 3;
    unint64_t v16 = v14 & 0xFFFFFFFFFFFF0000LL;
    if (!v7) {
      unint64_t v16 = v15;
    }
    return (Swift::String::Index)(v16 | 4);
  }

  else
  {
    v8._char rawBits = String.UTF8View._foreignIndex(_:offsetBy:)((Swift::String::Index)15LL, v6)._rawBits;
    Swift::UInt64 v9 = v8._rawBits + (v7 << 16);
    Swift::UInt64 v10 = v8._rawBits & 0xFFFFFFFFFFFFFFFCLL | rawBits & 3;
    unint64_t v11 = v9 & 0xFFFFFFFFFFFF0000LL;
    if (!v7) {
      unint64_t v11 = v10;
    }
    return (Swift::String::Index)(v11 | 8);
  }

Swift::String::Index __swiftcall String.UTF16View.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v7 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((_._rawBits & 0xC) == 4LL << v7) {
    _._char rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  }
  uint64_t v8 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v8 < _._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0xCBuLL,  0);
  }
  if ((v4 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignIndex(_:offsetBy:)(_, offsetBy);
  }
  uint64_t v9 = (v4 >> 62) & 1;
  if ((v4 & 0x2000000000000000LL) == 0) {
    LODWORD(v9) = v5 < 0;
  }
  if ((_DWORD)v9 == 1)
  {
    if (!__OFADD__(offsetBy, _._rawBits >> 16)) {
      return (Swift::String::Index)(((offsetBy + (_._rawBits >> 16)) << 16) | 0xD);
    }
    __break(1u);
    goto LABEL_27;
  }

  if ((_._rawBits & 0xC001) == 0) {
LABEL_27:
  }
    _._char rawBits = _._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(_)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
  unint64_t v11 = 64LL;
  if (_._rawBits < 0x4000) {
    unint64_t v11 = 32LL;
  }
  if (offsetBy >= 0) {
    unint64_t v12 = offsetBy;
  }
  else {
    unint64_t v12 = -offsetBy;
  }
  if (v12 < v11) {
    return (Swift::String::Index)(specialized BidirectionalCollection._index(_:offsetBy:)(_, offsetBy, v5, v4) | 4);
  }
  Swift::Int v13 = String.UTF16View._nativeGetOffset(for:)(_);
  BOOL v14 = __OFADD__(v13, offsetBy);
  result._char rawBits = v13 + offsetBy;
  if (!v14) {
    return String.UTF16View._nativeGetIndex(for:)(result._rawBits);
  }
  __break(1u);
  return result;
}

uint64_t String.Index.transcodedOffset.getter(unsigned __int16 a1)
{
  return a1 >> 14;
}

Swift::String::Index __swiftcall String.Index.encoded(offsetBy:)(Swift::Int offsetBy)
{
  return (Swift::String::Index)((v1 + (offsetBy << 16)) & 0xFFFFFFFFFFFF0000LL);
}

Swift::String::Index __swiftcall String.UTF8View.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  uint64_t v7 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((_._rawBits & 0xC) == 4LL << v7)
  {
    _._char rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
    if ((v4 & 0x1000000000000000LL) == 0)
    {
LABEL_5:
      Swift::UInt64 v8 = offsetBy + (_._rawBits >> 16);
      if (__OFADD__(offsetBy, _._rawBits >> 16))
      {
        __break(1u);
      }

      else if ((v8 & 0x8000000000000000LL) == 0)
      {
        unint64_t v9 = HIBYTE(v4) & 0xF;
        if ((v4 & 0x2000000000000000LL) == 0) {
          unint64_t v9 = v5 & 0xFFFFFFFFFFFFLL;
        }
        if (v9 >= v8) {
          return (Swift::String::Index)((v8 << 16) | 4);
        }
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xA7uLL,  0);
    }
  }

  else if ((v3 & 0x1000000000000000LL) == 0)
  {
    goto LABEL_5;
  }

  return String.UTF8View._foreignIndex(_:offsetBy:)(_, offsetBy);
}

BOOL _StringGuts._isContiguousASCII.getter(uint64_t a1, uint64_t a2)
{
  return (a2 & 0x3000000000000000LL) == 0 && a1 < 0;
}

uint64_t _StringGuts._isContiguousUTF16.getter()
{
  return 0LL;
}

id _StringGuts.startASCII.getter(uint64_t a1, uint64_t a2)
{
  if ((a1 & 0x1000000000000000LL) != 0) {
    return (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
  }
  id result = _StringObject.sharedUTF8.getter(a1, a2);
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGuts.swift",  22LL,  2,  0x1A3uLL,  0);
  }
  return result;
}

void _StringGuts.startUTF16.getter()
{
}

  ;
}

uint64_t _StringGuts._isLargeZeroTerminatedContiguousUTF8.getter(unint64_t a1, uint64_t a2)
{
  if ((a2 & 0x3000000000000000LL) != 0) {
    return 0LL;
  }
  else {
    return (a1 >> 60) & 1;
  }
}

id _StringGuts._largeContiguousUTF8CodeUnits.getter(uint64_t a1, uint64_t a2)
{
  if ((a1 & 0x1000000000000000LL) != 0) {
    return (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
  }
  else {
    return _StringObject.sharedUTF8.getter(a1, a2);
  }
}

const char *_persistCString(_:)(const char *result)
{
  if (result)
  {
    uint64_t v1 = (char *)result;
    size_t v2 = _swift_stdlib_strlen(result);
    size_t v3 = v2 + 1;
    if (__OFADD__(v2, 1LL))
    {
      __break(1u);
    }

    else
    {
      unint64_t v4 = specialized static Array._allocateUninitialized(_:)( (__objc2_class *)(v2 + 1),  (uint64_t (*)(__objc2_class *))specialized static Array._allocateBufferUninitialized(minimumCapacity:));
      Swift::UInt64 v8 = v5;
      unint64_t v9 = v4;
      if ((v3 & 0x8000000000000000LL) == 0)
      {
        v6[0] = v5;
        v6[1] = v3;
        specialized UnsafeMutablePointer.moveInitialize(from:count:)( v1,  v3,  v5,  "UnsafeMutablePointer.update with negative count",  47LL,  0x3DEuLL);
        size_t v7 = v3;
        specialized $defer #1 <A>() in Array.init(_unsafeUninitializedCapacity:initializingWith:)( &v7,  v3,  v6,  &v8,  (uint64_t *)&v9);
        return (const char *)v9;
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  return result;
}

Swift::tuple_Unicode_Scalar_scalarLength_Int __swiftcall _StringGuts.foreignErrorCorrectedScalar(startingAt:)( Swift::String::Index startingAt)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 v5 = startingAt._rawBits >> 16;
  Swift::UInt64 v6 = (void *)(v2 & 0xFFFFFFFFFFFFFFFLL);
  int v7 = objc_msgSend((id)(v2 & 0xFFFFFFFFFFFFFFFLL), sel_characterAtIndex_, startingAt._rawBits >> 16);
  if ((v7 & 0xF800 | 0x400) == 0xDC00)
  {
    if ((v7 & 0xFC00) != 0xDC00)
    {
      uint64_t v9 = HIBYTE(v3) & 0xF;
      if ((v3 & 0x2000000000000000LL) == 0) {
        uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
      }
      if (v5 + 1 != v9)
      {
        unsigned __int16 v10 = (unsigned __int16)objc_msgSend(v6, sel_characterAtIndex_);
        if ((v10 & 0xFC00) == 0xDC00)
        {
          int v7 = (v10 & 0x3FF | ((v7 & 0x3FF) << 10)) + 0x10000;
          Swift::Int v8 = 2LL;
          goto LABEL_10;
        }
      }
    }

    int v7 = 65533;
  }

  Swift::Int v8 = 1LL;
LABEL_10:
  Swift::UInt32 v11 = v7;
  result.Swift::Int scalarLength = v8;
  result._0._unsigned int value = v11;
  return result;
}

uint64_t _StringGuts.nativeCapacity.getter(uint64_t a1, uint64_t a2)
{
  if ((a1 & ~a2 & 0x2000000000000000LL) != 0) {
    return (*(void *)(a2 + 16) & 0xFFFFFFFFFFFFLL) - 1;
  }
  else {
    return 0LL;
  }
}

unint64_t _StringGuts.nativeUnusedCapacity.getter(uint64_t a1, uint64_t a2)
{
  if ((a1 & ~a2 & 0x2000000000000000LL) != 0) {
    return (*(void *)(a2 + 16) & 0xFFFFFFFFFFFFLL) + (~*(void *)(a2 + 24) | 0xFFFF000000000000LL);
  }
  else {
    return 0LL;
  }
}

uint64_t _StringGuts.uniqueNativeCapacity.getter()
{
  uint64_t v1 = v0[1];
  if ((*v0 & ~v1 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v1 & 0xFFFFFFFFFFFFFFFLL)) {
    return (*(void *)(v0[1] + 16LL) & 0xFFFFFFFFFFFFLL) - 1;
  }
  else {
    return 0LL;
  }
}

BOOL _StringGuts.isUniqueNative.getter()
{
  uint64_t v1 = v0[1];
  return (*v0 & ~v1 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v1 & 0xFFFFFFFFFFFFFFFLL);
}

uint64_t _StringObject.largeAddressBits.getter(uint64_t a1, uint64_t a2)
{
  return a2 & 0xFFFFFFFFFFFFFFFLL;
}

Swift::Void __swiftcall _StringGuts.reserveCapacity(_:)(Swift::Int a1)
{
  if (a1 >= 16)
  {
    unint64_t v2 = v1;
    Swift::Int v4 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v5 & 1) != 0 || v4 < a1)
    {
      uint64_t v6 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v7 & 1) != 0)
      {
        unint64_t v9 = v1[1];
        if ((v9 & 0x1000000000000000LL) != 0)
        {
          Swift::Int v8 = String.UTF8View._foreignCount()();
        }

        else if ((v9 & 0x2000000000000000LL) != 0)
        {
          Swift::Int v8 = HIBYTE(v9) & 0xF;
        }

        else
        {
          Swift::Int v8 = *v1 & 0xFFFFFFFFFFFFLL;
        }
      }

      else
      {
        Swift::Int v8 = 2 * v6;
      }

      if (v8 <= a1) {
        Swift::Int v10 = a1;
      }
      else {
        Swift::Int v10 = v8;
      }
      unint64_t v11 = v1[1];
      if ((v11 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignGrow(_:)(v10);
      }

      else
      {
        uint64_t v12 = *v1;
        if ((v11 & 0x2000000000000000LL) != 0)
        {
          size_t v16 = HIBYTE(v11) & 0xF;
          v22[0] = *v2;
          v22[1] = v11 & 0xFFFFFFFFFFFFFFLL;
          unint64_t v17 = v16 | 0xC000000000000000LL;
          if ((v11 & 0x4000000000000000LL) == 0) {
            unint64_t v17 = HIBYTE(v11) & 0xF;
          }
          uint64_t v18 = v17 | 0x3000000000000000LL;
          int64_t v15 = _allocateStringStorage(codeUnitCapacity:)(v10);
          *(void *)(v15 + 16) = v19;
          *(void *)(v15 + 24) = v18;
          if (v19 < 0)
          {
            *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
            uint64_t v18 = *(void *)(v15 + 24);
          }

          *(_BYTE *)(v15 + 32 + (v18 & 0xFFFFFFFFFFFFLL)) = 0;
          specialized UnsafeMutablePointer.initialize(from:count:)((char *)v22, v16, (char *)(v15 + 32));
        }

        else
        {
          if ((v12 & 0x1000000000000000LL) != 0)
          {
            Swift::Int v13 = (char *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v14 = v12 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            Swift::Int v21 = v10;
            Swift::Int v13 = (char *)_StringObject.sharedUTF8.getter(*v2, v11);
            Swift::Int v10 = v21;
          }

          int64_t v15 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v13,  v14,  v10,  v12 < 0);
        }

        uint64_t v20 = *(void *)(v15 + 24);
        swift_bridgeObjectRelease(v2[1]);
        uint64_t *v2 = v20;
        v2[1] = v15;
      }
    }
  }

void _StringGuts._foreignGrow(_:)(int64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1 > 15)
  {
    uint64_t v8 = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(a1, v1);
    unint64_t v12 = v13;
  }

  else
  {
    uint8x16_t v15 = (uint8x16_t)xmmword_1817FFDF0;
    if (a1 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
    uint64_t v2 = _StringGuts._foreignCopyUTF8(into:)((uint64_t)&v15, a1, *v1, v1[1]);
    if ((v3 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000029LL,  0x80000001818BB170LL,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  0x91uLL,  0);
    }
    if (v2 <= 0)
    {
      if (v2) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SmallString.swift",  23LL,  2,  0x109uLL,  0);
      }
      uint64_t v8 = 0LL;
      unint64_t v12 = 0xE000000000000000LL;
    }

    else
    {
      char v4 = 8;
      if (v2 <= 8) {
        char v5 = 8;
      }
      else {
        char v5 = v2;
      }
      char v6 = 56 * v5;
      if (v2 < 8) {
        char v4 = v2;
      }
      unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> (v6 & 0x38);
      uint64_t v8 = v15.i64[0] & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v4) & 0x38));
      uint64_t v9 = v15.i64[1] & v7;
      BOOL v10 = ((v15.i64[1] & v7 | v8) & 0x8080808080808080LL) == 0;
      unint64_t v11 = 0xA000000000000000LL;
      if (v10) {
        unint64_t v11 = 0xE000000000000000LL;
      }
      unint64_t v12 = v11 | (v2 << 56) | v9;
      if ((v12 & 0x4000000000000000LL) == 0)
      {
        v15.i64[0] = v8;
        v15.i64[1] = v9 & 0xFFFFFFFFFFFFFFLL;
        closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v15, HIBYTE(v12) & 0xF, v14);
        uint64_t v8 = v14[0];
        unint64_t v12 = v14[1];
      }
    }
  }

  swift_bridgeObjectRelease(v1[1]);
  unint64_t *v1 = v8;
  v1[1] = v12;
}

void _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(int64_t a1, int64_t a2)
{
  char v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = v3[1];
  int64_t v8 = _StringGuts.nativeUnusedCapacity.getter(v6, v7);
  BOOL v11 = (v9 & 1) == 0 && v8 >= a2;
  if ((v6 & ~v7 & 0x2000000000000000LL) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL);
    uint64_t v6 = *v3;
    uint64_t v7 = v3[1];
    if (isUniquelyReferenced_nonNull_native)
    {
      if (v11) {
        return;
      }
      goto LABEL_12;
    }
  }

  if (!v11)
  {
LABEL_12:
    uint64_t v13 = 2 * _StringGuts.nativeCapacity.getter(v6, v7);
    if ((v14 & 1) != 0) {
      uint64_t v13 = 0LL;
    }
    if (v13 > a1) {
      a1 = v13;
    }
  }

  uint64_t v15 = _StringGuts.uniqueNativeCapacity.getter();
  if ((v16 & 1) != 0)
  {
    unint64_t v18 = v3[1];
    if ((v18 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v17 = String.UTF8View._foreignCount()();
    }

    else if ((v18 & 0x2000000000000000LL) != 0)
    {
      Swift::Int v17 = HIBYTE(v18) & 0xF;
    }

    else
    {
      Swift::Int v17 = *v3 & 0xFFFFFFFFFFFFLL;
    }
  }

  else
  {
    Swift::Int v17 = 2 * v15;
  }

  if (v17 <= a1) {
    int64_t v19 = a1;
  }
  else {
    int64_t v19 = v17;
  }
  unint64_t v20 = v3[1];
  if ((v20 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignGrow(_:)(v19);
  }

  else
  {
    uint64_t v21 = *v3;
    if ((v20 & 0x2000000000000000LL) != 0)
    {
      size_t v25 = HIBYTE(v20) & 0xF;
      v30[0] = *v3;
      v30[1] = v20 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v26 = v25 | 0xC000000000000000LL;
      if ((v20 & 0x4000000000000000LL) == 0) {
        unint64_t v26 = HIBYTE(v20) & 0xF;
      }
      uint64_t v27 = v26 | 0x3000000000000000LL;
      int64_t v24 = _allocateStringStorage(codeUnitCapacity:)(v19);
      *(void *)(v24 + 16) = v28;
      *(void *)(v24 + 24) = v27;
      if (v28 < 0)
      {
        *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
        uint64_t v27 = *(void *)(v24 + 24);
      }

      *(_BYTE *)(v24 + 32 + (v27 & 0xFFFFFFFFFFFFLL)) = 0;
      specialized UnsafeMutablePointer.initialize(from:count:)((char *)v30, v25, (char *)(v24 + 32));
    }

    else
    {
      if ((v21 & 0x1000000000000000LL) != 0)
      {
        uint64_t v22 = (char *)((v20 & 0xFFFFFFFFFFFFFFFLL) + 32);
        size_t v23 = v21 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v22 = (char *)_StringObject.sharedUTF8.getter(*v3, v20);
      }

      int64_t v24 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v22,  v23,  v19,  v21 < 0);
    }

    uint64_t v29 = *(void *)(v24 + 24);
    swift_bridgeObjectRelease(v3[1]);
    *char v3 = v29;
    v3[1] = v24;
  }

void _StringGuts.append(_:)(uint64_t a1, unint64_t x1_0, uint64_t a3, uint64_t a4)
{
  char v5 = (uint64_t *)v4;
  if ((x1_0 & 0x1000000000000000LL) != 0)
  {
    unint64_t v55 = HIBYTE(x1_0) & 0xF;
    if ((x1_0 & 0x2000000000000000LL) == 0) {
      unint64_t v55 = a1 & 0xFFFFFFFFFFFFLL;
    }
    if (v55 < (a4 & 0xFFFFFFFFFFFFuLL)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
    }
    if (((a3 << 16) | 1uLL) >= 0x10000) {
      v57._char rawBits = (a3 << 16) | 1;
    }
    else {
      v57._char rawBits = (a3 << 16) | 3;
    }
    v56._char rawBits = (a4 << 16) | 1;
    Swift::Int v10 = specialized Collection.count.getter(v57, v56, a1, x1_0);
    unint64_t v12 = *v4;
    unint64_t v11 = v4[1];
    if ((v11 & 0x1000000000000000LL) == 0) {
      goto LABEL_4;
    }
LABEL_48:
    Swift::Int v58 = String.UTF8View._foreignCount()();
    int64_t v14 = v58 + v10;
    if (!__OFADD__(v58, v10)) {
      goto LABEL_8;
    }
    goto LABEL_50;
  }

  Swift::Int v10 = a4 - a3;
  if (__OFSUB__(a4, a3))
  {
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }

  unint64_t v12 = *v4;
  unint64_t v11 = v4[1];
  if ((v11 & 0x1000000000000000LL) != 0) {
    goto LABEL_48;
  }
LABEL_4:
  if ((v11 & 0x2000000000000000LL) != 0) {
    uint64_t v13 = HIBYTE(v11) & 0xF;
  }
  else {
    uint64_t v13 = v12 & 0xFFFFFFFFFFFFLL;
  }
  int64_t v14 = v13 + v10;
  if (__OFADD__(v13, v10))
  {
LABEL_50:
    __break(1u);
    goto LABEL_51;
  }

unint64_t _StringGuts._foreignConvertedToSmall()(unint64_t a1, unint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint8x16_t v15 = (uint8x16_t)xmmword_1817FFDF0;
  uint64_t v2 = _StringGuts._foreignCopyUTF8(into:)((uint64_t)&v15, 15LL, a1, a2);
  if ((v3 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000029LL,  0x80000001818BB170LL,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  0xD1uLL,  0);
  }
  if (v2 <= 0)
  {
    if (v2) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SmallString.swift",  23LL,  2,  0x109uLL,  0);
    }
    unint64_t v8 = 0LL;
    unint64_t v12 = 0xE000000000000000LL;
  }

  else
  {
    char v4 = 8;
    if (v2 <= 8) {
      char v5 = 8;
    }
    else {
      char v5 = v2;
    }
    char v6 = 56 * v5;
    if (v2 < 8) {
      char v4 = v2;
    }
    unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> (v6 & 0x38);
    unint64_t v8 = v15.i64[0] & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v4) & 0x38));
    uint64_t v9 = v15.i64[1] & v7;
    BOOL v10 = ((v15.i64[1] & v7 | v8) & 0x8080808080808080LL) == 0;
    unint64_t v11 = 0xA000000000000000LL;
    if (v10) {
      unint64_t v11 = 0xE000000000000000LL;
    }
    unint64_t v12 = v11 | (v2 << 56) | v9;
    if ((v12 & 0x4000000000000000LL) == 0)
    {
      v15.i64[0] = v8;
      v15.i64[1] = v9 & 0xFFFFFFFFFFFFFFLL;
      closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v15, HIBYTE(v12) & 0xF, v14);
      unint64_t v8 = v14[0];
      unint64_t v12 = v14[1];
    }
  }

  swift_bridgeObjectRelease(v12);
  return v8;
}

unint64_t _StringGuts._convertedToSmall()(unint64_t result, unint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) == 0)
  {
    void v6[2] = v2;
    v6[3] = v3;
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      return _StringGuts._foreignConvertedToSmall()(result, a2);
    }

    else
    {
      if ((result & 0x1000000000000000LL) != 0)
      {
        char v4 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v5 = result & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        char v4 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(result, a2);
      }

      closure #1 in _StringGuts._convertedToSmall()(v4, v5, v6);
      return v6[0];
    }
  }

  return result;
}

unsigned __int8 *closure #1 in _StringGuts._convertedToSmall()@<X0>( unsigned __int8 *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    if (a2 > 15) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  0xDFuLL,  0);
    }
    uint64_t v3 = 0LL;
    uint64_t v4 = 0LL;
    uint64_t v5 = 8LL;
    if (a2 < 8) {
      uint64_t v5 = a2;
    }
    unint64_t v6 = v5 & ~(v5 >> 63);
    unint64_t v7 = v5 - 1;
    unint64_t v8 = result;
    do
    {
      if (v6 <= v7) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
      }
      unsigned int v9 = *v8++;
      v3 |= (unint64_t)v9 << (v4 & 0x38);
      v4 += 8LL;
      --v5;
    }

    while (v5);
    if (a2 <= 8)
    {
      uint64_t v10 = 0LL;
    }

    else
    {
      uint64_t v10 = result[8];
      if (a2 != 9)
      {
        v10 |= (unint64_t)result[9] << 8;
        if (a2 != 10)
        {
          v10 |= (unint64_t)result[10] << 16;
          if (a2 != 11)
          {
            v10 |= (unint64_t)result[11] << 24;
            if (a2 != 12)
            {
              v10 |= (unint64_t)result[12] << 32;
              if (a2 != 13)
              {
                v10 |= (unint64_t)result[13] << 40;
                if (a2 != 14) {
                  v10 |= (unint64_t)result[14] << 48;
                }
              }
            }
          }
        }
      }
    }

    unint64_t v12 = 0xA000000000000000LL;
    if (((v10 | v3) & 0x8080808080808080LL) == 0) {
      unint64_t v12 = 0xE000000000000000LL;
    }
    unint64_t v11 = v12 | (a2 << 56) | v10;
  }

  else
  {
    uint64_t v3 = 0LL;
    unint64_t v11 = 0xE000000000000000LL;
  }

  *a3 = v3;
  a3[1] = v11;
  return result;
}

void _StringGuts.appendInPlace(_:isASCII:)(char *a1, size_t a2, char a3)
{
  uint64_t v4 = v3;
  uint64_t v7 = v3[1] & 0xFFFFFFFFFFFFFFFLL;
  specialized UnsafeMutablePointer.initialize(from:count:)( a1,  a2,  (char *)(v7 + (*(void *)(v7 + 24) & 0xFFFFFFFFFFFFLL) + 32));
  uint64_t v8 = *(void *)(v7 + 24);
  if (__OFADD__(v8 & 0xFFFFFFFFFFFFLL, a2))
  {
    __break(1u);
  }

  else
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)((v8 & 0xFFFFFFFFFFFFLL) + a2, (v8 < 0) & a3);
    *uint64_t v4 = *(void *)(v7 + 24);
  }

void _StringGuts._foreignAppendInPlace(_:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    unint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 < (a4 & 0xFFFFFFFFFFFFuLL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
  }
  unint64_t v6 = v4;
  unint64_t v8 = (a3 << 16) | 1;
  if (v8 < 0x10000) {
    unint64_t v8 = (a3 << 16) | 3;
  }
  v15[0] = v8;
  v15[1] = (a4 << 16) | 1;
  void v15[2] = a1;
  unint64_t v16 = a2;
  unint64_t v17 = v8;
  uint64_t v9 = v4[1];
  if ((a2 & 0x2000000000000000LL) != 0) {
    char v10 = (a2 & 0x4000000000000000LL) != 0;
  }
  else {
    char v10 = a1 < 0;
  }
  specialized __StringStorage.appendInPlace<A>(_:isASCII:)(v15, v10);
  uint64_t v11 = v16;
  swift_bridgeObjectRetain(a2, v12, v13, v14);
  swift_bridgeObjectRelease(v11);
  *unint64_t v6 = *(void *)(v9 + 24);
}

void closure #1 in _StringGuts.appendInPlace(_:isASCII:)(uint64_t a1, char *__src, size_t __n, char a4)
{
  uint64_t v7 = *(void *)(a1 + 24);
  if (__OFADD__(v7 & 0xFFFFFFFFFFFFLL, __n)) {
    __break(1u);
  }
  else {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)((v7 & 0xFFFFFFFFFFFFLL) + __n, (v7 < 0) & a4);
  }
}

void __StringStorage.appendInPlace(_:isASCII:)(char *a1, size_t a2, char a3)
{
  uint64_t v6 = *(void *)(v3 + 24);
  if (__OFADD__(v6 & 0xFFFFFFFFFFFFLL, a2)) {
    __break(1u);
  }
  else {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)((v6 & 0xFFFFFFFFFFFFLL) + a2, (v6 < 0) & a3);
  }
}

void specialized __StringStorage.appendInPlace<A>(_:isASCII:)(unint64_t *a1, char a2)
{
  Swift::UInt64 v4 = a1[4];
  Swift::UInt64 v5 = a1[1] >> 14;
  if (v5 != v4 >> 14)
  {
    unint64_t v6 = 0LL;
    uint64_t v10 = v2 + 32;
    while (1)
    {
      unint64_t v11 = *a1;
      unint64_t v13 = a1[2];
      uint64_t v12 = a1[3];
      uint64_t v14 = (v13 >> 59) & 1;
      if ((v12 & 0x1000000000000000LL) == 0) {
        LOBYTE(v14) = 1;
      }
      Swift::UInt64 rawBits = v4;
      if ((v4 & 0xC) == 4LL << v14)
      {
        uint64_t v34 = v10;
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v4)._rawBits;
        uint64_t v10 = v34;
      }

      if (rawBits >> 14 < v11 >> 14 || rawBits >> 14 >= v5) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/Substring.swift",  21LL,  2,  0x29BuLL,  0);
      }
      if ((v12 & 0x1000000000000000LL) != 0)
      {
        uint64_t v25 = v10;
        Swift::UInt8 v26 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        uint64_t v10 = v25;
        Swift::UInt8 v19 = v26;
      }

      else
      {
        Swift::UInt64 v17 = rawBits >> 16;
        if ((v12 & 0x2000000000000000LL) != 0)
        {
          v35[0] = v13;
          v35[1] = v12 & 0xFFFFFFFFFFFFFFLL;
          Swift::UInt8 v19 = *((_BYTE *)v35 + v17);
        }

        else
        {
          if ((v13 & 0x1000000000000000LL) != 0)
          {
            id v18 = (_BYTE *)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            uint64_t v32 = v12;
            uint64_t v33 = v10;
            id v18 = _StringObject.sharedUTF8.getter(v13, v32);
            uint64_t v10 = v33;
          }

          Swift::UInt8 v19 = v18[v17];
        }
      }

      unint64_t v20 = a1[2];
      unint64_t v21 = a1[3];
      uint64_t v22 = (v20 >> 59) & 1;
      if ((v21 & 0x1000000000000000LL) == 0) {
        LOBYTE(v22) = 1;
      }
      if ((v4 & 0xC) == 4LL << v22)
      {
        v27._Swift::UInt64 rawBits = v4;
        uint64_t v28 = v10;
        v29._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v27)._rawBits;
        uint64_t v10 = v28;
        Swift::UInt64 v4 = v29._rawBits;
        if ((v21 & 0x1000000000000000LL) != 0)
        {
LABEL_31:
          unint64_t v30 = HIBYTE(v21) & 0xF;
          if ((v21 & 0x2000000000000000LL) == 0) {
            unint64_t v30 = v20 & 0xFFFFFFFFFFFFLL;
          }
          if (v30 <= v4 >> 16) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
          }
          uint64_t v31 = v10;
          Swift::UInt64 v23 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v4)._rawBits;
          uint64_t v10 = v31;
          goto LABEL_25;
        }
      }

      else if ((v21 & 0x1000000000000000LL) != 0)
      {
        goto LABEL_31;
      }

      Swift::UInt64 v23 = (v4 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_25:
      a1[4] = v23;
      uint64_t v7 = *(void *)(v2 + 24);
      uint64_t v8 = v7 & 0xFFFFFFFFFFFFLL;
      uint64_t v24 = (*(void *)(v2 + 16) & 0xFFFFFFFFFFFFLL) + ~(v7 & 0xFFFFFFFFFFFFLL);
      if (v24 < 0) {
        goto LABEL_38;
      }
      if (v6 >= v24) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
      }
      *(_BYTE *)(v10 + v8 + v6++) = v19;
      Swift::UInt64 v4 = a1[4];
      Swift::UInt64 v5 = a1[1] >> 14;
      if (v5 == v4 >> 14) {
        goto LABEL_3;
      }
    }
  }

  unint64_t v6 = 0LL;
  uint64_t v7 = *(void *)(v2 + 24);
  uint64_t v8 = v7 & 0xFFFFFFFFFFFFLL;
LABEL_3:
  if (__OFADD__(v8, v6))
  {
    __break(1u);
LABEL_38:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v8 + v6, (v7 < 0) & a2);
}

Swift::Void __swiftcall _StringGuts.clear()()
{
  uint64_t v1 = v0[1];
  if ((*v0 & ~v1 & 0x2000000000000000LL) != 0
    && (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v1 & 0xFFFFFFFFFFFFFFFLL),
        uint64_t v1 = v0[1],
        isUniquelyReferenced_nonNull_native))
  {
    uint64_t v3 = v1 & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v4 = 0xF000000000000000LL;
    *(void *)(v1 + 24) = 0xF000000000000000LL;
    *(_BYTE *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 0x2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000015LL,  0x80000001818B7510LL,  "Swift/StringGuts.swift",  22LL,  2,  0x1A9uLL, 0) = 0;
    uint64_t v5 = *(void *)(v1 + 16);
    if (v5 < 0)
    {
      unint64_t v6 = (uint64_t *)(((v1 & 0xFFFFFFFFFFFFFFFLL) + 32 + (v5 & 0xFFFFFFFFFFFFLL) + 7) & 0xFFFFFFFFFFFFFFF8LL);
      uint64_t v7 = *v6;
      *unint64_t v6 = 0LL;
      swift_release(v7);
      unint64_t v4 = *(void *)(v3 + 24);
    }

    unint64_t *v0 = v4;
  }

  else
  {
    swift_bridgeObjectRelease(v1);
    unint64_t *v0 = 0LL;
    v0[1] = 0xE000000000000000LL;
  }

Swift::Void __swiftcall _StringGuts.remove(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  uint64_t v3 = v2;
  Swift::UInt64 v6 = from._rawBits >> 16;
  Swift::UInt64 v7 = to._rawBits >> 16;
  uint64_t v9 = *v3;
  unint64_t v8 = v3[1];
  if ((*v3 & ~v8 & 0x2000000000000000LL) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL);
    unint64_t v8 = v3[1];
    if (isUniquelyReferenced_nonNull_native)
    {
      __StringStorage.remove(from:to:)(v6, v7);
      *uint64_t v3 = *(void *)(v8 + 24);
      return;
    }

    uint64_t v9 = *v3;
  }

  v141._Swift::UInt64 rawBits = to._rawBits;
  unint64_t v144 = 0LL;
  unint64_t v145 = 0xE000000000000000LL;
  uint64_t v11 = _StringGuts.nativeCapacity.getter(v9, v8);
  uint64_t v13 = HIBYTE(v8) & 0xF;
  if ((v8 & 0x2000000000000000LL) == 0) {
    uint64_t v13 = v9 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v14 = v6 - v7 + v13;
  if ((v12 & 1) != 0) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = v11;
  }
  if (v15 >= 16 && ((uint64_t v16 = _StringGuts.uniqueNativeCapacity.getter(), (v17 & 1) != 0) || v16 < v15))
  {
    uint64_t v21 = 2 * _StringGuts.uniqueNativeCapacity.getter();
    if (v21 <= v15) {
      uint64_t v21 = v15;
    }
    if ((v20 & 1) != 0) {
      int64_t v22 = v15;
    }
    else {
      int64_t v22 = v21;
    }
    uint64_t v142 = 0LL;
    uint64_t v143 = 0LL;
    unint64_t v19 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v142,  0LL,  v22,  1);
    unint64_t v18 = *(void *)(v19 + 24);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v144 = v18;
    unint64_t v145 = v19;
  }

  else
  {
    unint64_t v18 = 0LL;
    unint64_t v19 = 0xE000000000000000LL;
  }

  v23._Swift::UInt64 rawBits = from._rawBits;
  unint64_t v27 = specialized Collection.subscript.getter(v23, *v3, v3[1]);
  uint64_t v28 = v25;
  unint64_t v29 = v26;
  uint64_t v30 = v27 >> 16;
  uint64_t v31 = v24 >> 16;
  unint64_t v140 = v24;
  if ((v26 & 0x1000000000000000LL) == 0)
  {
    unint64_t v32 = v31 - v30;
    swift_bridgeObjectRetain_n(v26, 2LL, v25, (char *)v26);
    if ((v19 & 0x1000000000000000LL) == 0) {
      goto LABEL_22;
    }
LABEL_114:
    Swift::Int v130 = String.UTF8View._foreignCount()();
    int64_t v37 = v130 + v32;
    if (!__OFADD__(v130, v32)) {
      goto LABEL_26;
    }
LABEL_116:
    __break(1u);
    goto LABEL_117;
  }

  Swift::UInt64 v125 = v24 & 0xFFFFFFFFFFFF0000LL | 1;
  swift_bridgeObjectRetain_n(v26, 3LL, v25, (char *)v26);
  v126._Swift::UInt64 rawBits = v27 & 0xFFFFFFFFFFFF0000LL | 1;
  v127._Swift::UInt64 rawBits = v125;
  v128._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v126, v127, v28, v29);
  if (v128._rawBits < 0x10000) {
    v128._rawBits |= 3;
  }
  unint64_t v32 = specialized Collection.count.getter(v128, v129, v28, v29);
  swift_bridgeObjectRelease(v29);
  unint64_t v18 = v144;
  unint64_t v19 = v145;
  if ((v145 & 0x1000000000000000LL) != 0) {
    goto LABEL_114;
  }
LABEL_22:
  if ((v19 & 0x2000000000000000LL) != 0) {
    uint64_t v36 = HIBYTE(v19) & 0xF;
  }
  else {
    uint64_t v36 = v18 & 0xFFFFFFFFFFFFLL;
  }
  int64_t v37 = v36 + v32;
  if (__OFADD__(v36, v32)) {
    goto LABEL_116;
  }
LABEL_26:
  if ((v18 & ~v19 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v19 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v38 = _StringGuts.nativeUnusedCapacity.getter(v18, v19);
    if ((v39 & 1) != 0) {
      goto LABEL_129;
    }
LABEL_38:
    swift_bridgeObjectRelease(v29);
    swift_bridgeObjectRetain(v19, v45, v46, v47);
    unint64_t v48 = _StringGuts._convertedToSmall()(v18, v19);
    unint64_t v50 = v49;
    swift_bridgeObjectRelease(v19);
    unint64_t v51 = HIBYTE(v29) & 0xF;
    if ((v29 & 0x2000000000000000LL) == 0) {
      unint64_t v51 = v28 & 0xFFFFFFFFFFFFLL;
    }
    if (v51 < v31) {
      goto LABEL_123;
    }
    if ((v27 & 0xFFFFFFFFFFFF0000LL | 1) >= 0x10000) {
      v52._Swift::UInt64 rawBits = v27 & 0xFFFFFFFFFFFF0000LL | 1;
    }
    else {
      v52._Swift::UInt64 rawBits = v27 & 0xFFFFFFFFFFFF0000LL | 3;
    }
    if (v52._rawBits >> 16 || v31 != v51)
    {
      v53._Swift::UInt64 rawBits = v140 & 0xFFFFFFFFFFFF0000LL | 1;
      uint64_t v28 = specialized static String._copying(_:)(v52, v53, v28, v29);
      unint64_t v55 = v54;
      swift_bridgeObjectRelease(v29);
      unint64_t v29 = v55;
    }

    unint64_t v56 = _StringGuts._convertedToSmall()(v28, v29);
    unint64_t v58 = v57;
    swift_bridgeObjectRelease(v29);
    uint64_t v59 = HIBYTE(v50) & 0xF;
    uint64_t v60 = HIBYTE(v58) & 0xF;
    uint64_t v61 = v60 + v59;
    if ((unint64_t)(v60 + v59) > 0xF)
    {
LABEL_128:
      unint64_t v139 = 266LL;
      goto LABEL_130;
    }

    if (v60)
    {
      char v62 = 0;
      unint64_t v63 = 0LL;
      do
      {
        unint64_t v64 = v59 + v63;
        unint64_t v65 = v63 + 1;
        if (v63 >= 8) {
          unint64_t v66 = v58;
        }
        else {
          unint64_t v66 = v56;
        }
        unint64_t v67 = v66 >> (v62 & 0x38);
        char v68 = (8 * v59 + v62) & 0x38;
        uint64_t v69 = (-255LL << v68) - 1;
        unint64_t v70 = (unint64_t)v67 << v68;
        unint64_t v71 = v70 | v69 & v50;
        unint64_t v72 = v70 | v69 & v48;
        if (v64 < 8) {
          unint64_t v48 = v72;
        }
        else {
          unint64_t v50 = v71;
        }
        v62 += 8;
        unint64_t v63 = v65;
      }

      while (v60 != v65);
    }

    swift_bridgeObjectRelease(v19);
    unint64_t v73 = 0xA000000000000000LL;
    if (!(v48 & 0x8080808080808080LL | v50 & 0x80808080808080LL)) {
      unint64_t v73 = 0xE000000000000000LL;
    }
    unint64_t v144 = v48;
    unint64_t v145 = v73 & 0xFF00000000000000LL | (v61 << 56) | v50 & 0xFFFFFFFFFFFFFFLL;
    goto LABEL_64;
  }

  if (v37 <= 15) {
    goto LABEL_38;
  }
LABEL_32:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v37, v32);
  swift_bridgeObjectRelease(v29);
  if ((v29 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(v28, v29, v30, v31);
LABEL_61:
    swift_bridgeObjectRelease(v29);
    goto LABEL_64;
  }

  if ((v29 & 0x2000000000000000LL) == 0)
  {
    if ((v28 & 0x1000000000000000LL) != 0)
    {
      id v40 = (id)((v29 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v41 = v28 & 0xFFFFFFFFFFFFLL;
      if ((v28 & 0xFFFFFFFFFFFFLL) < v31) {
        goto LABEL_127;
      }
    }

    else
    {
      id v40 = _StringObject.sharedUTF8.getter(v28, v29);
      uint64_t v41 = v137;
      if (v137 < v31) {
        goto LABEL_127;
      }
    }

    unint64_t v42 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v30, v31, (uint64_t)v40, v41);
    unint64_t v43 = v145;
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v145 & 0xFFFFFFFFFFFFFFFLL, v42, v44, v28 < 0);
    unint64_t v144 = *(void *)(v43 + 24);
    goto LABEL_61;
  }

  swift_bridgeObjectRelease(v29);
  unint64_t v74 = HIBYTE(v29) & 0xF;
  uint64_t v142 = v28;
  uint64_t v143 = v29 & 0xFFFFFFFFFFFFFFLL;
  if (v74 < v31) {
    goto LABEL_127;
  }
  BOOL v75 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v30, v31, (uint64_t)&v142, v74);
  unint64_t v76 = v145;
  closure #1 in _StringGuts.appendInPlace(_:isASCII:)( v145 & 0xFFFFFFFFFFFFFFFLL,  v75,  v77,  (v29 & 0x4000000000000000LL) != 0);
  unint64_t v144 = *(void *)(v76 + 24);
LABEL_64:
  v78._Swift::UInt64 rawBits = v141._rawBits;
  uint64_t v28 = specialized Collection.subscript.getter(v78, *v3, v3[1]);
  unint64_t v27 = v34;
  unint64_t v32 = v35;
  uint64_t v31 = (unint64_t)v28 >> 16;
  int64_t v37 = v33 >> 16;
  v141._Swift::UInt64 rawBits = v33;
  if ((v35 & 0x1000000000000000LL) == 0)
  {
    uint64_t v79 = v34;
    Swift::Int v80 = v37 - v31;
    swift_bridgeObjectRetain_n(v35, 2LL, v34, (char *)v35);
    unint64_t v82 = v144;
    unint64_t v81 = v145;
    if ((v145 & 0x1000000000000000LL) == 0) {
      goto LABEL_66;
    }
LABEL_120:
    Swift::Int v136 = String.UTF8View._foreignCount()();
    int64_t v83 = v136 + v80;
    if (!__OFADD__(v136, v80)) {
      goto LABEL_71;
    }
    goto LABEL_122;
  }

Swift::Void __swiftcall __StringStorage.remove(from:to:)(Swift::Int from, Swift::Int to)
{
}

void String.append(contentsOf:)(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = (uint64_t *)v4;
  uint64_t v9 = a1 >> 16;
  unint64_t v10 = a2 >> 16;
  if ((a4 & 0x1000000000000000LL) == 0)
  {
    Swift::Int v11 = v10 - v9;
    unint64_t v13 = *v4;
    unint64_t v12 = v4[1];
    if ((v12 & 0x1000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_47:
    Swift::Int v63 = String.UTF8View._foreignCount()();
    int64_t v15 = v63 + v11;
    if (!__OFADD__(v63, v11)) {
      goto LABEL_7;
    }
LABEL_49:
    __break(1u);
    goto LABEL_50;
  }

  v53._Swift::UInt64 rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 1;
  v54._Swift::UInt64 rawBits = a2 & 0xFFFFFFFFFFFF0000LL | 1;
  Swift::UInt64 v55 = _StringGuts.validateScalarRange(_:)(v53, v54, a3, a4);
  Swift::UInt64 v59 = v56;
  if (v55 >= 0x10000) {
    Swift::UInt64 v60 = v55;
  }
  else {
    Swift::UInt64 v60 = v55 | 3;
  }
  swift_bridgeObjectRetain(a4, v56, v57, v58);
  v61._Swift::UInt64 rawBits = v60;
  v62._Swift::UInt64 rawBits = v59;
  Swift::Int v11 = specialized Collection.count.getter(v61, v62, a3, a4);
  swift_bridgeObjectRelease(a4);
  unint64_t v13 = *v5;
  unint64_t v12 = v5[1];
  if ((v12 & 0x1000000000000000LL) != 0) {
    goto LABEL_47;
  }
LABEL_3:
  if ((v12 & 0x2000000000000000LL) != 0) {
    uint64_t v14 = HIBYTE(v12) & 0xF;
  }
  else {
    uint64_t v14 = v13 & 0xFFFFFFFFFFFFLL;
  }
  int64_t v15 = v14 + v11;
  if (__OFADD__(v14, v11)) {
    goto LABEL_49;
  }
LABEL_7:
  if ((v13 & ~v12 & 0x2000000000000000LL) == 0
    || (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL),
        unint64_t v13 = *v5,
        unint64_t v12 = v5[1],
        !isUniquelyReferenced_nonNull_native))
  {
    if (v15 > 15) {
      goto LABEL_13;
    }
LABEL_19:
    unint64_t v23 = _StringGuts._convertedToSmall()(v13, v12);
    unint64_t v25 = HIBYTE(a4) & 0xF;
    if ((a4 & 0x2000000000000000LL) == 0) {
      unint64_t v25 = a3 & 0xFFFFFFFFFFFFLL;
    }
    if (v25 >= v10)
    {
      unint64_t v26 = v23;
      unint64_t v27 = v24;
      if ((a1 & 0xFFFFFFFFFFFF0000LL | 1) >= 0x10000) {
        v29._Swift::UInt64 rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 1;
      }
      else {
        v29._Swift::UInt64 rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 3;
      }
      v28._Swift::UInt64 rawBits = a2 & 0xFFFFFFFFFFFF0000LL | 1;
      unint64_t v30 = specialized String.init(_:)(v29, v28, a3, a4);
      uint64_t v32 = v31;
      unint64_t v33 = _StringGuts._convertedToSmall()(v30, v31);
      unint64_t v35 = v34;
      swift_bridgeObjectRelease(v32);
      uint64_t v36 = HIBYTE(v27) & 0xF;
      uint64_t v37 = HIBYTE(v35) & 0xF;
      uint64_t v38 = v37 + v36;
      if ((unint64_t)(v37 + v36) <= 0xF)
      {
        if (v37)
        {
          char v39 = 0;
          unint64_t v40 = 0LL;
          do
          {
            unint64_t v41 = v36 + v40;
            unint64_t v42 = v40 + 1;
            if (v40 >= 8) {
              unint64_t v43 = v35;
            }
            else {
              unint64_t v43 = v33;
            }
            unint64_t v44 = v43 >> (v39 & 0x38);
            char v45 = (8 * v36 + v39) & 0x38;
            uint64_t v46 = (-255LL << v45) - 1;
            unint64_t v47 = (unint64_t)v44 << v45;
            unint64_t v48 = v47 | v46 & v27;
            unint64_t v49 = v47 | v46 & v26;
            if (v41 < 8) {
              unint64_t v26 = v49;
            }
            else {
              unint64_t v27 = v48;
            }
            v39 += 8;
            unint64_t v40 = v42;
          }

          while (v37 != v42);
        }

        swift_bridgeObjectRelease(v12);
        unint64_t v50 = 0xA000000000000000LL;
        if (!(v26 & 0x8080808080808080LL | v27 & 0x80808080808080LL)) {
          unint64_t v50 = 0xE000000000000000LL;
        }
        *uint64_t v5 = v26;
        v5[1] = v50 & 0xFF00000000000000LL | (v38 << 56) | v27 & 0xFFFFFFFFFFFFFFLL;
        return;
      }

      unint64_t v65 = 266LL;
LABEL_56:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v65,  0);
    }

unint64_t specialized _StringGuts.replaceSubrange<A>(_:with:)( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = (uint64_t)v4;
  unint64_t v11 = *(void *)v5;
  unint64_t v10 = *(void *)(v5 + 8);
  if ((*(void *)v5 & ~v10 & 0x2000000000000000LL) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL);
    unint64_t v11 = *(void *)v5;
    unint64_t v10 = *(void *)(v5 + 8);
    if (isUniquelyReferenced_nonNull_native)
    {
      if ((a4 & 0x1000000000000000LL) != 0) {
        return specialized _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( a1,  a2,  a3,  a4,  (uint64_t)closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))specialized FlattenSequence<>.startIndex.getter,  (uint64_t (*)(uint64_t))specialized FlattenSequence<>.distance(from:to:),  (void (*)(unint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))specialized __StringStorage.replace<A>(from:to:with:replacementCount:));
      }
      if ((a4 & 0x2000000000000000LL) != 0)
      {
        unint64_t v249 = a3;
        unint64_t v250 = a4 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v15 = a1 >> 16;
        uint64_t v88 = v11 & 0xFFFFFFFFFFFFLL;
        if ((v10 & 0x2000000000000000LL) != 0) {
          uint64_t v88 = HIBYTE(v10) & 0xF;
        }
        Swift::Int v89 = v88 - (a2 >> 16) + (HIBYTE(a4) & 0xF) + (a1 >> 16);
        if (v89 > 15)
        {
          uint64_t v90 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v91 & 1) != 0 || v90 < v89) {
            _StringGuts.grow(_:)(v89);
          }
        }

        unint64_t v20 = *(void *)(v5 + 8);
        unint64_t v23 = (char *)&v249;
        uint64_t v21 = a1 >> 16;
        uint64_t v22 = a2 >> 16;
        size_t v24 = HIBYTE(a4) & 0xF;
        goto LABEL_94;
      }

      if ((a3 & 0x1000000000000000LL) != 0)
      {
        unint64_t v13 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v14 = a3 & 0xFFFFFFFFFFFFLL;
LABEL_7:
        unint64_t v15 = a1 >> 16;
        uint64_t v16 = v11 & 0xFFFFFFFFFFFFLL;
        if ((v10 & 0x2000000000000000LL) != 0) {
          uint64_t v16 = HIBYTE(v10) & 0xF;
        }
        Swift::Int v17 = v14 + (a1 >> 16) + v16 - (a2 >> 16);
        if (v17 >= 16)
        {
          uint64_t v18 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v19 & 1) != 0 || v18 < v17) {
            _StringGuts.grow(_:)(v17);
          }
        }

        unint64_t v20 = *(void *)(v5 + 8);
        uint64_t v21 = a1 >> 16;
        uint64_t v22 = a2 >> 16;
        unint64_t v23 = v13;
        size_t v24 = v14;
LABEL_94:
        __StringStorage.replace(from:to:with:)(v21, v22, v23, v24);
        *(void *)uint64_t v5 = *(void *)(v20 + 24);
        return v15;
      }

{
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  uint64_t v14;
  char v15;
  Swift::Int v16;
  uint64_t v17;
  char v18;
  Swift::String::Index v19;
  Swift::UInt64 v20;
  uint64_t v21;
  Swift::UInt64 v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  unint64_t v26;
  Swift::String::Index v27;
  Swift::String::Index v28;
  __objc2_class **v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  __objc2_class **v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  Swift::String::Index v44;
  Swift::UInt64 v45;
  uint64_t v46;
  Swift::UInt64 v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  unint64_t v51;
  Swift::String::Index v52;
  Swift::String::Index v53;
  __objc2_class **v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  size_t v63;
  Swift::UInt64 v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v5 = v4;
  unint64_t v11 = *v5;
  unint64_t v10 = v5[1];
  if ((*v5 & ~v10 & 0x2000000000000000LL) != 0)
  {
    if (swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((a4 & 0x1000000000000000LL) != 0) {
        return specialized _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( a1,  a2,  a3,  a4,  (uint64_t)protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))specialized FlattenSequence<>.startIndex.getter,  (uint64_t (*)(uint64_t))specialized FlattenSequence<>.distance(from:to:),  (void (*)(unint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))specialized __StringStorage.replace<A>(from:to:with:replacementCount:));
      }
      if ((a4 & 0x2000000000000000LL) != 0)
      {
        unint64_t v13 = HIBYTE(a4) & 0xF;
        unint64_t v66 = a3;
        Swift::String::Index v67 = a4 & 0xFFFFFFFFFFFFFFLL;
        unint64_t v12 = (char *)&v66;
      }

      else if ((a3 & 0x1000000000000000LL) != 0)
      {
        unint64_t v12 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v13 = a3 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v12 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
        unint64_t v13 = v63;
      }

      return specialized _StringGuts.uniqueNativeReplaceSubrange(_:with:isASCII:)(a1, a2, v12, v13);
    }

    uint64_t v64 = a2;
    uint64_t v65 = a3;
    unint64_t v11 = *v5;
    unint64_t v10 = v5[1];
  }

  else
  {
    uint64_t v64 = a2;
    uint64_t v65 = a3;
  }

  unint64_t v66 = 0LL;
  Swift::String::Index v67 = 0xE000000000000000LL;
  uint64_t v14 = _StringGuts.nativeCapacity.getter(v11, v10);
  if ((v15 & 1) == 0)
  {
    uint64_t v16 = v14;
    if (v14 > 15)
    {
      Swift::Int v17 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v18 & 1) != 0 || v17 < v16) {
        _StringGuts.grow(_:)(v16);
      }
    }
  }

  v19._Swift::UInt64 rawBits = a1;
  unint64_t v20 = specialized Collection.subscript.getter(v19, v11, v10);
  uint64_t v22 = v21;
  size_t v24 = v23;
  uint64_t v26 = (unint64_t)v25;
  swift_bridgeObjectRetain((unint64_t)v25, v21, v23, v25);
  v27._Swift::UInt64 rawBits = v20;
  v28._Swift::UInt64 rawBits = v22;
  uint64_t v29 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v27,  v28,  v24,  v26);
  swift_bridgeObjectRelease(v26);
  char v30 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v29, 1LL);
  uint64_t v32 = v31;
  swift_bridgeObjectRelease((uint64_t)v29);
  if (!v32) {
    goto LABEL_27;
  }
  int64_t v33 = specialized static String.+ infix(_:_:)(v66, v67, v30, v32);
  uint64_t v35 = v34;
  swift_bridgeObjectRelease(v67);
  swift_bridgeObjectRelease(v32);
  unint64_t v66 = v33;
  Swift::String::Index v67 = v35;
  uint64_t v36 = (v35 & 0x2000000000000000LL) != 0 ? HIBYTE(v35) & 0xF : v33 & 0xFFFFFFFFFFFFLL;
  unint64_t v37 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSS17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v65,  a4);
  unint64_t v38 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v37, 1LL);
  uint64_t v40 = v39;
  swift_bridgeObjectRelease((uint64_t)v37);
  if (!v40) {
    goto LABEL_27;
  }
  uint64_t v41 = specialized static String.+ infix(_:_:)(v33, v35, v38, v40);
  Swift::Int v43 = v42;
  swift_bridgeObjectRelease(v35);
  swift_bridgeObjectRelease(v40);
  unint64_t v66 = v41;
  Swift::String::Index v67 = v43;
  v44._Swift::UInt64 rawBits = v64;
  unint64_t v45 = specialized Collection.subscript.getter(v44, v11, v10);
  char v47 = v46;
  char v49 = v48;
  uint64_t v51 = (unint64_t)v50;
  swift_bridgeObjectRetain((unint64_t)v50, v46, v48, v50);
  v52._Swift::UInt64 rawBits = v45;
  v53._Swift::UInt64 rawBits = v47;
  uint64_t v54 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v52,  v53,  v49,  v51);
  swift_bridgeObjectRelease(v51);
  id v55 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v54, 1LL);
  uint64_t v57 = v56;
  swift_bridgeObjectRelease((uint64_t)v54);
  if (!v57) {
LABEL_27:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  size_t v58 = specialized static String.+ infix(_:_:)(v41, v43, v55, v57);
  uint64_t v60 = v59;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease(v43);
  swift_bridgeObjectRelease(v57);
  *uint64_t v5 = v58;
  v5[1] = v60;
  return v36;
}

LABEL_242:
    __break(1u);
    goto LABEL_243;
  }

    Swift::String::Index v204 = 266LL;
    goto LABEL_244;
  }

  swift_bridgeObjectRelease(v231);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v28;
}

uint64_t specialized _StringGuts.replaceSubrange<A>(_:with:)( Swift::UInt64 a1, unint64_t a2, Swift::Int a3, uint64_t a4, int64_t a5, unint64_t a6)
{
  unint64_t v7 = (unint64_t)v6;
  uint64_t v14 = *v6;
  unint64_t v15 = v6[1];
  if ((*v6 & ~v15 & 0x2000000000000000LL) == 0
    || (v16 = swift_isUniquelyReferenced_nonNull_native(v15 & 0xFFFFFFFFFFFFFFFLL), uint64_t v14 = *v6, v15 = v6[1], !v16))
  {
    Swift::UInt64 v186 = a2;
    unint64_t v187 = a4;
    unint64_t v188 = a3;
    unint64_t v190 = a5;
    unint64_t v192 = a6;
    uint64_t v184 = v6;
    unint64_t v200 = 0LL;
    unint64_t v201 = 0xE000000000000000LL;
    Swift::Int v33 = _StringGuts.nativeCapacity.getter(v14, v15);
    if ((v34 & 1) == 0) {
      String.reserveCapacity(_:)(v33);
    }
    v35._Swift::UInt64 rawBits = a1;
    unint64_t v185 = v14;
    unint64_t v7 = specialized Collection.subscript.getter(v35, v14, v15);
    a6 = v38;
    unint64_t v39 = v36;
    a1 = v37;
    a2 = v38 >> 16;
    uint64_t v183 = v7 >> 16;
    if ((v37 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v37, 3LL, v36, (char *)v37);
      v148._Swift::UInt64 rawBits = v7 & 0xFFFFFFFFFFFF0000LL | 1;
      v149._Swift::UInt64 rawBits = a6 & 0xFFFFFFFFFFFF0000LL | 1;
      v150._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v148, v149, v39, a1);
      if (v150._rawBits < 0x10000) {
        v150._rawBits |= 3;
      }
      uint64_t v14 = v39;
      Swift::Int v40 = specialized Collection.count.getter(v150, v151, v39, a1);
      swift_bridgeObjectRelease(a1);
      uint64_t v44 = v200;
      unint64_t v43 = v201;
    }

    else
    {
      uint64_t v14 = v36;
      Swift::Int v40 = a2 - (v7 >> 16);
      swift_bridgeObjectRetain_n(v37, 2LL, v36, (char *)v37);
      uint64_t v44 = v200;
      unint64_t v43 = v201;
    }

    uint64_t v45 = HIBYTE(v43) & 0xF;
    a4 = v45 + v40;
    if (__OFADD__(v45, v40))
    {
      __break(1u);
      goto LABEL_109;
    }

    if ((v44 & ~v43 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v43 & 0xFFFFFFFFFFFFFFFLL))
    {
      _StringGuts.nativeUnusedCapacity.getter(v44, v43);
      if ((v46 & 1) != 0) {
        goto LABEL_149;
      }
      if (a4 > 15)
      {
LABEL_22:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(a4, v40);
        swift_bridgeObjectRelease(a1);
        if ((a1 & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v14, a1, v183, a2);
          goto LABEL_48;
        }

        if ((a1 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(a1);
          unint64_t v94 = HIBYTE(a1) & 0xF;
          uint64_t v194 = v14;
          uint64_t v195 = a1 & 0xFFFFFFFFFFFFFFLL;
          if (v94 < a2) {
            goto LABEL_133;
          }
          unint64_t v95 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v183, a2, (uint64_t)&v194, v94);
          _StringGuts.appendInPlace(_:isASCII:)(v95, v96, (a1 & 0x4000000000000000LL) != 0);
          goto LABEL_63;
        }

        if ((v14 & 0x1000000000000000LL) != 0)
        {
          id v47 = (id)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v48 = v14 & 0xFFFFFFFFFFFFLL;
LABEL_26:
          char v49 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v183, a2, (uint64_t)v47, v48);
          _StringGuts.appendInPlace(_:isASCII:)(v49, v50, v14 < 0);
LABEL_48:
          swift_bridgeObjectRelease(a1);
LABEL_63:
          unint64_t v69 = v192;
          unint64_t v70 = v185;
          goto LABEL_64;
        }

uint64_t specialized _StringGuts.replaceSubrange<A>(_:with:)( Swift::UInt64 a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = v3;
  uint64_t v9 = *v3;
  unint64_t v8 = v3[1];
  if ((*v3 & ~v8 & 0x2000000000000000LL) == 0
    || (v10 = swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL), v9 = *v3, unint64_t v8 = v3[1], !v10))
  {
    Swift::UInt64 v169 = a2;
    char v167 = v3;
    unint64_t v173 = 0LL;
    unint64_t v174 = 0xE000000000000000LL;
    Swift::Int v20 = _StringGuts.nativeCapacity.getter(v9, v8);
    if ((v21 & 1) == 0) {
      String.reserveCapacity(_:)(v20);
    }
    v22._Swift::UInt64 rawBits = a1;
    unint64_t v168 = v9;
    uint64_t v25 = specialized Collection.subscript.getter(v22, v9, v8);
    unint64_t v27 = v26;
    unint64_t v28 = v23;
    unint64_t v17 = v24;
    a2 = v26 >> 16;
    uint64_t v166 = (unint64_t)v25 >> 16;
    if ((v24 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v24, 3LL, v23, (char *)v24);
      v155._Swift::UInt64 rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
      v156._Swift::UInt64 rawBits = v27 & 0xFFFFFFFFFFFF0000LL | 1;
      v157._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v155, v156, v28, v17);
      if (v157._rawBits < 0x10000) {
        v157._rawBits |= 3;
      }
      uint64_t v9 = v28;
      Swift::Int v29 = specialized Collection.count.getter(v157, v158, v28, v17);
      swift_bridgeObjectRelease(v17);
    }

    else
    {
      uint64_t v9 = v23;
      Swift::Int v29 = a2 - ((unint64_t)v25 >> 16);
      swift_bridgeObjectRetain_n(v24, 2LL, v23, (char *)v24);
    }

    unint64_t v32 = v174;
    uint64_t v170 = a3;
    unint64_t v33 = HIBYTE(v174) & 0xF;
    int64_t v34 = v33 + v29;
    if (__OFADD__(v33, v29))
    {
      __break(1u);
      goto LABEL_122;
    }

    if ((v173 & ~v174 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v174 & 0xFFFFFFFFFFFFFFFLL))
    {
      _StringGuts.nativeUnusedCapacity.getter(v173, v174);
      if ((v35 & 1) != 0) {
        goto LABEL_138;
      }
      if (v34 > 15)
      {
LABEL_19:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v34, v29);
        swift_bridgeObjectRelease(v17);
        if ((v17 & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v9, v17, v166, a2);
          swift_bridgeObjectRelease(v17);
          unint64_t v41 = v173;
          unint64_t v39 = v174;
          goto LABEL_57;
        }

        if ((v17 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v17);
          unint64_t v89 = HIBYTE(v17) & 0xF;
          uint64_t v171 = v9;
          uint64_t v172 = v17 & 0xFFFFFFFFFFFFFFLL;
          if (v89 < a2) {
            goto LABEL_133;
          }
          uint64_t v90 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v166, a2, (uint64_t)&v171, v89);
          unint64_t v39 = v174;
          closure #1 in _StringGuts.appendInPlace(_:isASCII:)( v174 & 0xFFFFFFFFFFFFFFFLL,  v90,  v91,  (v17 & 0x4000000000000000LL) != 0);
          unint64_t v41 = *(void *)(v39 + 24);
          unint64_t v173 = v41;
          goto LABEL_57;
        }

        if ((v9 & 0x1000000000000000LL) != 0)
        {
          id v36 = (id)((v17 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v37 = v9 & 0xFFFFFFFFFFFFLL;
LABEL_23:
          unint64_t v38 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v166, a2, (uint64_t)v36, v37);
          unint64_t v39 = v174;
          closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v174 & 0xFFFFFFFFFFFFFFFLL, v38, v40, v9 < 0);
          unint64_t v41 = *(void *)(v174 + 24);
          unint64_t v173 = v41;
          swift_bridgeObjectRelease(v17);
LABEL_57:
          unint64_t v63 = v168;
          Swift::UInt64 v62 = v169;
          goto LABEL_58;
        }

LABEL_125:
      unint64_t v95 = String.UTF8View._foreignCount()();
      goto LABEL_65;
    }

        char v21 = 0;
        goto LABEL_103;
      }

      unint64_t v8 = 1;
      uint64_t v59 = specialized Collection.subscript.getter(1LL, (uint64_t)v82, v24);
      unint64_t v63 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v59, v60, v61, v62);
      if (v64)
      {
        unint64_t v65 = a3 + 55;
        uint64_t v66 = a3 + 87;
        if (a3 > 10)
        {
          unint64_t v67 = 58;
        }

        else
        {
          uint64_t v66 = 97;
          unint64_t v65 = 65;
          unint64_t v67 = a3 + 48;
        }

        if (v63)
        {
          LOBYTE(v68) = 0;
          while (1)
          {
            unint64_t v69 = *v63;
            if (v69 < 0x30 || v69 >= v67)
            {
              if (v69 < 0x41 || v69 >= v65)
              {
                char v21 = 0;
                unint64_t v8 = 1;
                if (v69 < 0x61 || v69 >= v66) {
                  goto LABEL_103;
                }
                char v70 = -87;
              }

              else
              {
                char v70 = -55;
              }
            }

            else
            {
              char v70 = -48;
            }

            char v21 = 0;
            uint64_t v71 = v68 * a3;
            unint64_t v8 = 1;
            if ((v71 & 0xFF00) == 0)
            {
              BOOL v68 = v71 + (v69 + v70);
              if (((v68 >> 8) & 1) == 0)
              {
                unint64_t v8 = 0;
                ++v63;
                char v21 = v68;
                if (--v64) {
                  continue;
                }
              }
            }

            goto LABEL_103;
          }
        }

        goto LABEL_102;
      }

        char v21 = 0;
        goto LABEL_103;
      }

      unint64_t v8 = 1;
      unint64_t v69 = specialized Collection.subscript.getter(1LL, (uint64_t)v98, v26);
      unint64_t v73 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v69, v70, v71, v72);
      if (v74)
      {
        unint64_t v75 = a3 + 55;
        Swift::UInt64 v76 = a3 + 87;
        if (a3 > 10)
        {
          uint64_t v77 = 58;
        }

        else
        {
          Swift::UInt64 v76 = 97;
          unint64_t v75 = 65;
          uint64_t v77 = a3 + 48;
        }

        if (v73)
        {
          LOBYTE(v78) = 0;
          while (1)
          {
            uint64_t v79 = *v73;
            if (v79 < 0x30 || v79 >= v77)
            {
              if (v79 < 0x41 || v79 >= v75)
              {
                char v21 = 0;
                unint64_t v8 = 1;
                if (v79 < 0x61 || v79 >= v76) {
                  goto LABEL_103;
                }
                unint64_t v80 = -87;
              }

              else
              {
                unint64_t v80 = -55;
              }
            }

            else
            {
              unint64_t v80 = -48;
            }

            char v21 = 0;
            int64_t v81 = v79 + v80;
            uint64_t v82 = (char)v78 * (char)a3;
            Swift::UInt64 v83 = (char)(v78 * a3);
            Swift::UInt64 v78 = v83 + v81;
            uint64_t v84 = v78 != (char)(v83 + v81);
            unint64_t v8 = 1;
            if (v83 == v82 && !v84)
            {
              unint64_t v8 = 0;
              ++v73;
              char v21 = v78;
              if (--v74) {
                continue;
              }
            }

            goto LABEL_103;
          }
        }

        goto LABEL_102;
      }

        char v21 = 0;
        goto LABEL_103;
      }

      unint64_t v8 = 1;
      uint64_t v59 = specialized Collection.subscript.getter(1LL, (uint64_t)v82, v24);
      unint64_t v63 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v59, v60, v61, v62);
      if (v64)
      {
        unint64_t v65 = a3 + 55;
        uint64_t v66 = a3 + 87;
        if (a3 > 10)
        {
          unint64_t v67 = 58;
        }

        else
        {
          uint64_t v66 = 97;
          unint64_t v65 = 65;
          unint64_t v67 = a3 + 48;
        }

        if (v63)
        {
          LOWORD(v68) = 0;
          while (1)
          {
            unint64_t v69 = *v63;
            if (v69 < 0x30 || v69 >= v67)
            {
              if (v69 < 0x41 || v69 >= v65)
              {
                char v21 = 0;
                unint64_t v8 = 1;
                if (v69 < 0x61 || v69 >= v66) {
                  goto LABEL_103;
                }
                char v70 = -87;
              }

              else
              {
                char v70 = -55;
              }
            }

            else
            {
              char v70 = -48;
            }

            char v21 = 0;
            uint64_t v71 = (unsigned __int16)v68 * (unsigned __int16)a3;
            unint64_t v8 = 1;
            if ((v71 & 0xFFFF0000) == 0)
            {
              BOOL v68 = (unsigned __int16)v71 + (v69 + v70);
              if ((v68 & 0x10000) == 0)
              {
                unint64_t v8 = 0;
                ++v63;
                char v21 = v68;
                if (--v64) {
                  continue;
                }
              }
            }

            goto LABEL_103;
          }
        }

        goto LABEL_102;
      }

        char v21 = 0;
        goto LABEL_103;
      }

      unint64_t v8 = 1;
      unint64_t v69 = specialized Collection.subscript.getter(1LL, (uint64_t)v98, v26);
      unint64_t v73 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v69, v70, v71, v72);
      if (v74)
      {
        unint64_t v75 = a3 + 55;
        Swift::UInt64 v76 = a3 + 87;
        if (a3 > 10)
        {
          uint64_t v77 = 58;
        }

        else
        {
          Swift::UInt64 v76 = 97;
          unint64_t v75 = 65;
          uint64_t v77 = a3 + 48;
        }

        if (v73)
        {
          LOWORD(v78) = 0;
          while (1)
          {
            uint64_t v79 = *v73;
            if (v79 < 0x30 || v79 >= v77)
            {
              if (v79 < 0x41 || v79 >= v75)
              {
                char v21 = 0;
                unint64_t v8 = 1;
                if (v79 < 0x61 || v79 >= v76) {
                  goto LABEL_103;
                }
                unint64_t v80 = -87;
              }

              else
              {
                unint64_t v80 = -55;
              }
            }

            else
            {
              unint64_t v80 = -48;
            }

            char v21 = 0;
            int64_t v81 = v79 + v80;
            uint64_t v82 = (__int16)v78 * (__int16)a3;
            Swift::UInt64 v83 = (__int16)(v78 * a3);
            Swift::UInt64 v78 = v83 + v81;
            uint64_t v84 = v78 != (__int16)(v83 + v81);
            unint64_t v8 = 1;
            if (v83 == v82 && !v84)
            {
              unint64_t v8 = 0;
              ++v73;
              char v21 = v78;
              if (--v74) {
                continue;
              }
            }

            goto LABEL_103;
          }
        }

        goto LABEL_102;
      }

  Swift::String::Index v221 = v377;
  Swift::Int v222 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000LL) == 0) {
    Swift::Int v222 = v407 & 0xFFFFFFFFFFFFLL;
  }
  if (v222 || (v407 & ~v408 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236LL;
    v408 = 0xE200000000000000LL;
  }

  v145(5LL, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  unint64_t v223 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v223, v221, v3);
  uint64_t v224 = v402;
  unint64_t v225 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  uint64_t v226 = (void *)swift_getDynamicType(v225, v224, 1);
  LODWORD(v224) = swift_isOptionalType(v226);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v224)
  {
    memcpy(v101, v221, v3);
    uint64_t v227 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v227, 7uLL);
LABEL_132:
    unint64_t v228 = (uint64_t)v402;
    unint64_t v229 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    uint64_t v230 = (*(uint64_t (**)(uint64_t, uint64_t))(v229 + 8))(v228, v229);
    id v232 = v231;
    specialized String.write<A>(to:)(&v407, v230, v231, v233);
    swift_bridgeObjectRelease(v232);
LABEL_133:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_136;
  }

  unint64_t v234 = v376;
  memcpy(v376, v221, v3);
  if ((swift_dynamicCast((char *)&v401, v234, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t v235 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v235);
  }

  else
  {
    unint64_t v302 = v370;
    memcpy(v370, v221, v3);
    unint64_t v303 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v302, v2, v303, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      unint64_t v304 = (uint64_t)v402;
      unint64_t v305 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v305 + 8))( &v407,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v304,  v305);
      goto LABEL_133;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for TextOutputStreamable?);
    unint64_t v326 = v364;
    memcpy(v364, v221, v3);
    unint64_t v327 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v326, v2, v327, 6uLL)
      || (v406 = 0LL,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomStringConvertible?),  unint64_t v328 = v358,  memcpy(v358, v221, v3),  v329 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v404, v328, v2, v329, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_132;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v405 + 1) = v2;
    Swift::String::Index v349 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v349, v221, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    Swift::String::Index v350 = v401._object;
    Swift::String::Index v351 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v221,  &v401,  &v407,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v351);
    swift_release((uint64_t)v350);
  }

        uint64_t v11 = *((void *)&v21 + 1);
      }

  uint64_t v134 = 0LL;
  unint64_t v135 = 0LL;
  Type = 0LL;
  if (swift::Demangle::__runtime::Demangler::demangleBoundGenerics( (uint64_t)this,  (const void **)&v134,  (int8x16_t **)&v133,  a4,  a5))
  {
    char v106 = *((_DWORD *)v7 + 24);
    if (v106)
    {
      unint64_t v107 = v106 - 1;
      Type = *(void *)(*((void *)v7 + 11) + 8LL * v107);
      *((_DWORD *)v7 + 24) = v107;
      if (Type)
      {
        Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v7, 102, v45);
        uint64_t v110 = (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( v7,  300,  (swift::Demangle::__runtime::Node *)Type,  Node,  v109);
        unint64_t v113 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(v7, 235);
        if ((_DWORD)v135)
        {
          unint64_t v114 = v135 - 1;
          do
          {
            unint64_t v115 = v114;
            swift::Demangle::__runtime::Node::addChild(v113, v134[v114--], v7, v111, v112);
          }

          while (v115);
        }

        swift::Demangle::__runtime::Node::addChild(v110, (swift::Demangle::__runtime::Node *)v113, v7, v111, v112);
        if (v133) {
          swift::Demangle::__runtime::Node::addChild(v110, v133, v7, v117, v118);
        }
        Type = swift::Demangle::__runtime::Demangler::createType( v7,  (swift::Demangle::__runtime::Node *)v110,  v116,  v117,  v118);
        unint64_t v136 = Type;
        if (Type)
        {
          unint64_t v65 = (const void **)((char *)v7 + 104);
          uint64_t v66 = (uint64_t *)&v136;
LABEL_76:
          swift::Demangle::__runtime::Vector<swift::Demangle::__runtime::Node *>::push_back(v65, v66, v7);
        }
      }

      return Type;
    }

    return 0LL;
  }

  return Type;
}

unint64_t specialized _StringGuts.replaceSubrange<A>(_:with:)( Swift::UInt64 a1, int64_t a2, uint64_t a3, Swift::UInt64 a4)
{
  int64_t v6 = (int64_t)v4;
  unint64_t v12 = *v4;
  unint64_t v11 = v4[1];
  if ((*v4 & ~v11 & 0x2000000000000000LL) == 0
    || (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL),
        unint64_t v12 = *v4,
        unint64_t v11 = v4[1],
        !isUniquelyReferenced_nonNull_native))
  {
    uint64_t v175 = a3;
    Swift::UInt64 v173 = a4;
    unint64_t __src = 0LL;
    unint64_t v180 = 0xE000000000000000LL;
    Swift::Int v31 = _StringGuts.nativeCapacity.getter(v12, v11);
    if ((v32 & 1) == 0) {
      String.reserveCapacity(_:)(v31);
    }
    v33._Swift::UInt64 rawBits = a1;
    unint64_t v21 = specialized Collection.subscript.getter(v33, v12, v11);
    a3 = v36;
    unint64_t v176 = v34;
    a4 = v35;
    int64_t v5 = v36 >> 16;
    uint64_t v171 = v21 >> 16;
    uint64_t v172 = v4;
    if ((v35 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v35, 3LL, v34, (char *)v35);
      v160._Swift::UInt64 rawBits = v21 & 0xFFFFFFFFFFFF0000LL | 1;
      v161._Swift::UInt64 rawBits = a3 & 0xFFFFFFFFFFFF0000LL | 1;
      v162._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v160, v161, v176, a4);
      if (v162._rawBits < 0x10000) {
        v162._rawBits |= 3;
      }
      Swift::Int v37 = specialized Collection.count.getter(v162, v163, v176, a4);
      swift_bridgeObjectRelease(a4);
    }

    else
    {
      Swift::Int v37 = v5 - (v21 >> 16);
      swift_bridgeObjectRetain_n(v35, 2LL, v34, (char *)v35);
    }

    unint64_t v40 = v180;
    Swift::UInt64 v174 = a2;
    unint64_t v41 = HIBYTE(v180) & 0xF;
    a2 = v41 + v37;
    if (__OFADD__(v41, v37))
    {
      __break(1u);
      goto LABEL_117;
    }

    if ((__src & ~v180 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v180 & 0xFFFFFFFFFFFFFFFLL))
    {
      _StringGuts.nativeUnusedCapacity.getter(__src, v180);
      if ((v42 & 1) != 0) {
        goto LABEL_134;
      }
      if (a2 > 15) {
        goto LABEL_26;
      }
    }

    else if (a2 >= 16)
    {
LABEL_26:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(a2, v37);
      swift_bridgeObjectRelease(a4);
      if ((a4 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignAppendInPlace(_:)(v176, a4, v171, v5);
        swift_bridgeObjectRelease(a4);
        unint64_t v50 = __src;
        unint64_t v21 = v180;
        unint64_t v71 = v173;
        a3 = v175;
        goto LABEL_53;
      }

      a3 = v175;
      int64_t v6 = v176;
      if ((a4 & 0x2000000000000000LL) == 0)
      {
        if ((v176 & 0x1000000000000000LL) == 0) {
          goto LABEL_123;
        }
        id v43 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v44 = v176 & 0xFFFFFFFFFFFFLL;
        goto LABEL_128;
      }

      swift_bridgeObjectRelease(a4);
      unint64_t v84 = HIBYTE(a4) & 0xF;
      unint64_t v177 = v176;
      uint64_t v178 = a4 & 0xFFFFFFFFFFFFFFLL;
      if (v84 < v5) {
        goto LABEL_128;
      }
      char v85 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v171, v5, (uint64_t)&v177, v84);
      size_t v87 = v86;
      unint64_t v21 = v180;
      uint64_t v88 = v180 & 0xFFFFFFFFFFFFFFFLL;
      specialized UnsafeMutablePointer.initialize(from:count:)( v85,  v86,  (char *)((v180 & 0xFFFFFFFFFFFFFFFLL)
               + (*(void *)((v180 & 0xFFFFFFFFFFFFFFFLL) + 0x18) & 0xFFFFFFFFFFFFLL)
               + 32));
      uint64_t v89 = *(void *)(v88 + 24);
      if (!__OFADD__(v89 & 0xFFFFFFFFFFFFLL, v87))
      {
        __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( (v89 & 0xFFFFFFFFFFFFLL) + v87,  (a4 >> 62) & (v89 < 0));
        unint64_t v50 = *(void *)(v88 + 24);
        unint64_t __src = v50;
        goto LABEL_52;
      }

      goto LABEL_126;
    }

    swift_bridgeObjectRelease(a4);
    swift_bridgeObjectRetain(v180, v53, v54, v55);
    unint64_t v50 = _StringGuts._convertedToSmall()(__src, v180);
    unint64_t v57 = v56;
    swift_bridgeObjectRelease(v180);
    v58._Swift::UInt64 rawBits = v21 & 0xFFFFFFFFFFFF0000LL | 1;
    v59._Swift::UInt64 rawBits = a3 & 0xFFFFFFFFFFFF0000LL | 1;
    v60._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v58, v59, v176, a4);
    if (v60._rawBits < 0x10000) {
      v60._rawBits |= 3;
    }
    unint64_t v62 = specialized String.init(_:)(v60, v61, v176, a4);
    unint64_t v64 = v63;
    swift_bridgeObjectRelease(a4);
    unint64_t v65 = _StringGuts._convertedToSmall()(v62, v64);
    unint64_t v67 = v66;
    swift_bridgeObjectRelease(v64);
    uint64_t v68 = HIBYTE(v57) & 0xF;
    uint64_t v69 = HIBYTE(v67) & 0xF;
    uint64_t v70 = v69 + v68;
    if ((unint64_t)(v69 + v68) <= 0xF)
    {
      unint64_t v71 = v173;
      if (v69)
      {
        char v72 = 0;
        unint64_t v73 = 0LL;
        do
        {
          unint64_t v74 = v68 + v73;
          unint64_t v75 = v73 + 1;
          if (v73 >= 8) {
            unint64_t v76 = v67;
          }
          else {
            unint64_t v76 = v65;
          }
          unint64_t v77 = v76 >> (v72 & 0x38);
          char v78 = (8 * v68 + v72) & 0x38;
          uint64_t v79 = (-255LL << v78) - 1;
          unint64_t v80 = (unint64_t)v77 << v78;
          unint64_t v81 = v80 | v79 & v57;
          unint64_t v82 = v80 | v79 & v50;
          if (v74 < 8) {
            unint64_t v50 = v82;
          }
          else {
            unint64_t v57 = v81;
          }
          v72 += 8;
          unint64_t v73 = v75;
        }

        while (v69 != v75);
      }

      swift_bridgeObjectRelease(v180);
      unint64_t v83 = 0xA000000000000000LL;
      if (!(v50 & 0x8080808080808080LL | v57 & 0x80808080808080LL)) {
        unint64_t v83 = 0xE000000000000000LL;
      }
      unint64_t v21 = v83 & 0xFF00000000000000LL | (v70 << 56) | v57 & 0xFFFFFFFFFFFFFFLL;
      unint64_t __src = v50;
      unint64_t v180 = v21;
      a3 = v175;
      goto LABEL_53;
    }

uint64_t specialized _StringGuts.replaceSubrange<A>(_:with:)(Swift::UInt64 a1, Swift::UInt64 a2)
{
  uint64_t v3 = v2;
  uint64_t v7 = *v3;
  uint64_t v6 = v3[1];
  if ((*v3 & ~v6 & 0x2000000000000000LL) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL);
    uint64_t v7 = *v3;
    uint64_t v6 = v3[1];
    if (isUniquelyReferenced_nonNull_native)
    {
      uint64_t v9 = a1 >> 16;
      uint64_t v10 = a2 >> 16;
      uint64_t v11 = v7 & 0xFFFFFFFFFFFFLL;
      if ((v6 & 0x2000000000000000LL) != 0) {
        uint64_t v11 = HIBYTE(v6) & 0xF;
      }
      int64_t v12 = v11 - v10 + v9;
      if (v12 >= 16)
      {
        uint64_t v13 = _StringGuts.uniqueNativeCapacity.getter();
        if ((v14 & 1) != 0 || v13 < v12)
        {
          uint64_t v15 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v16 & 1) != 0)
          {
            unint64_t v133 = v3[1];
            if ((v133 & 0x1000000000000000LL) != 0)
            {
              Swift::Int v17 = String.UTF8View._foreignCount()();
            }

            else if ((v133 & 0x2000000000000000LL) != 0)
            {
              Swift::Int v17 = HIBYTE(v133) & 0xF;
            }

            else
            {
              Swift::Int v17 = *v3 & 0xFFFFFFFFFFFFLL;
            }
          }

          else
          {
            Swift::Int v17 = 2 * v15;
          }

          if (v17 > v12) {
            int64_t v12 = v17;
          }
          unint64_t v134 = v3[1];
          if ((v134 & 0x1000000000000000LL) != 0)
          {
            _StringGuts._foreignGrow(_:)(v12);
          }

          else
          {
            uint64_t v135 = *v3;
            if ((v134 & 0x2000000000000000LL) != 0)
            {
              size_t v139 = HIBYTE(v134) & 0xF;
              uint64_t __src = *v3;
              unint64_t v164 = v134 & 0xFFFFFFFFFFFFFFLL;
              unint64_t v140 = v139 | 0xC000000000000000LL;
              if ((v134 & 0x4000000000000000LL) == 0) {
                unint64_t v140 = HIBYTE(v134) & 0xF;
              }
              uint64_t v141 = v140 | 0x3000000000000000LL;
              int64_t v138 = _allocateStringStorage(codeUnitCapacity:)(v12);
              *(void *)(v138 + 16) = v142;
              *(void *)(v138 + 24) = v141;
              if (v142 < 0)
              {
                *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
                uint64_t v141 = *(void *)(v138 + 24);
              }

              *(_BYTE *)(v138 + 32 + (v141 & 0xFFFFFFFFFFFFLL)) = 0;
              specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v139, (char *)(v138 + 32));
            }

            else
            {
              if ((v135 & 0x1000000000000000LL) != 0)
              {
                unint64_t v136 = (char *)((v134 & 0xFFFFFFFFFFFFFFFLL) + 32);
                size_t v137 = v135 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                unint64_t v136 = (char *)_StringObject.sharedUTF8.getter(*v3, v134);
              }

              int64_t v138 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v136,  v137,  v12,  v135 < 0);
            }

            uint64_t v143 = *(void *)(v138 + 24);
            swift_bridgeObjectRelease(v3[1]);
            *uint64_t v3 = v143;
            v3[1] = v138;
          }
        }
      }

      uint64_t v144 = v3[1];
      specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( v9,  v10,  (uint64_t)closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL,  0LL);
      *uint64_t v3 = *(void *)(v144 + 24);
      return v9;
    }
  }

  Swift::UInt64 v159 = a2;
  uint64_t __src = 0LL;
  unint64_t v164 = 0xE000000000000000LL;
  Swift::Int v18 = _StringGuts.nativeCapacity.getter(v7, v6);
  if ((v19 & 1) == 0) {
    String.reserveCapacity(_:)(v18);
  }
  uint64_t v158 = v3;
  v20._Swift::UInt64 rawBits = a1;
  unint64_t v21 = specialized Collection.subscript.getter(v20, v7, v6);
  unint64_t v25 = v21;
  unint64_t v26 = v22;
  unint64_t v27 = v23;
  uint64_t v28 = v24;
  uint64_t v160 = v22 >> 16;
  uint64_t v157 = v21 >> 16;
  if ((v24 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain_n(v24, 3LL, v23, (char *)v24);
    v146._Swift::UInt64 rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
    v147._Swift::UInt64 rawBits = v26 & 0xFFFFFFFFFFFF0000LL | 1;
    v148._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v146, v147, v27, v28);
    if (v148._rawBits < 0x10000) {
      v148._rawBits |= 3;
    }
    Swift::Int v29 = specialized Collection.count.getter(v148, v149, v27, v28);
    swift_bridgeObjectRelease(v28);
    uint64_t v32 = __src;
    Swift::UInt64 v33 = v164;
  }

  else
  {
    Swift::Int v29 = (v22 >> 16) - (v21 >> 16);
    swift_bridgeObjectRetain_n(v24, 2LL, v23, (char *)v24);
    uint64_t v32 = __src;
    Swift::UInt64 v33 = v164;
  }

  uint64_t v34 = HIBYTE(v33) & 0xF;
  int64_t v35 = v34 + v29;
  if (__OFADD__(v34, v29))
  {
    __break(1u);
    goto LABEL_113;
  }

  if ((v32 & ~v33 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v33 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v35 >= 16) {
      goto LABEL_19;
    }
LABEL_27:
    swift_bridgeObjectRelease(v28);
    swift_bridgeObjectRetain(v33, v46, v47, v48);
    uint64_t v32 = _StringGuts._convertedToSmall()(v32, v33);
    unint64_t v50 = v49;
    swift_bridgeObjectRelease(v33);
    v51._Swift::UInt64 rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
    v52._Swift::UInt64 rawBits = v26 & 0xFFFFFFFFFFFF0000LL | 1;
    v53._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v51, v52, v27, v28);
    if (v53._rawBits < 0x10000) {
      v53._rawBits |= 3;
    }
    unint64_t v55 = specialized String.init(_:)(v53, v54, v27, v28);
    unint64_t v57 = v56;
    swift_bridgeObjectRelease(v28);
    unint64_t v58 = _StringGuts._convertedToSmall()(v55, v57);
    unint64_t v60 = v59;
    swift_bridgeObjectRelease(v57);
    uint64_t v61 = HIBYTE(v50) & 0xF;
    uint64_t v62 = HIBYTE(v60) & 0xF;
    uint64_t v63 = v62 + v61;
    if ((unint64_t)(v62 + v61) <= 0xF)
    {
      if (v62)
      {
        char v64 = 0;
        unint64_t v65 = 0LL;
        do
        {
          unint64_t v66 = v61 + v65;
          unint64_t v67 = v65 + 1;
          if (v65 >= 8) {
            unint64_t v68 = v60;
          }
          else {
            unint64_t v68 = v58;
          }
          unint64_t v69 = v68 >> (v64 & 0x38);
          char v70 = (8 * v61 + v64) & 0x38;
          uint64_t v71 = (-255LL << v70) - 1;
          unint64_t v72 = (unint64_t)v69 << v70;
          unint64_t v73 = v72 | v71 & v50;
          unint64_t v74 = v72 | v71 & v32;
          if (v66 < 8) {
            uint64_t v32 = v74;
          }
          else {
            unint64_t v50 = v73;
          }
          v64 += 8;
          unint64_t v65 = v67;
        }

        while (v62 != v67);
      }

      swift_bridgeObjectRelease(v33);
      unint64_t v75 = 0xA000000000000000LL;
      if (!(v32 & 0x8080808080808080LL | v50 & 0x80808080808080LL)) {
        unint64_t v75 = 0xE000000000000000LL;
      }
      unint64_t v27 = v75 & 0xFF00000000000000LL | (v63 << 56) | v50 & 0xFFFFFFFFFFFFFFLL;
      uint64_t __src = v32;
      unint64_t v164 = v27;
      goto LABEL_46;
    }

const char *_StringGuts.replaceSubrange<A>(_:with:)( Swift::UInt64 a1, Swift::UInt64 a2, unint64_t *a3, ValueMetadata *a4, Swift::Int a5)
{
  Swift::Int v6 = a5;
  uint64_t v264 = a3;
  Swift::UInt64 v265 = a1;
  Swift::UInt64 v262 = a2;
  uint64_t v8 = *(void *)(a5 + 8);
  uint64_t v9 = type metadata accessor for LazyMapSequence(255LL, (uint64_t)a4, (uint64_t)&type metadata for String.UTF8View, v8);
  v275[0] = v6;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v9, v275);
  Swift::String::Index v260 = (const char *)lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View( WitnessTable,  v10,  v11);
  uint64_t v12 = type metadata accessor for FlattenSequence<>.Index(0LL, v9, WitnessTable, (uint64_t)v260);
  uint64_t v256 = *(void *)(v12 - 8);
  uint64_t v257 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v15 = (unint64_t *)((char *)&v252 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v13);
  Swift::String::Index v255 = (char *)&v252 - v16;
  uint64_t v261 = v8;
  uint64_t v18 = type metadata accessor for LazySequence(0LL, (uint64_t)a4, v8, v17);
  MEMORY[0x1895F8858](v18);
  Swift::String::Index v20 = (char *)&v252 - v19;
  uint64_t v22 = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v9, v21);
  unint64_t v25 = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(v22, v23, v24);
  uint64_t v26 = type metadata accessor for FlattenSequence(255LL, v9, v22, v25);
  uint64_t v28 = swift_getWitnessTable(&protocol conformance descriptor for FlattenSequence<A>, v26, v27);
  uint64_t v259 = v26;
  uint64_t v30 = type metadata accessor for LazySequence(0LL, v26, v28, v29);
  uint64_t v31 = MEMORY[0x1895F8858](v30);
  uint64_t v263 = a4;
  uint64_t Description = (uint64_t)a4[-1].Description;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  int64_t v35 = (uint64_t *)((char *)&v252 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v36 = MEMORY[0x1895F8858](v33);
  size_t v40 = (uint64_t *)((char *)&v252 - v39);
  unint64_t v41 = *v5;
  unint64_t v42 = v5[1];
  Swift::UInt64 v266 = v5;
  if ((v41 & ~v42 & 0x2000000000000000LL) == 0)
  {
LABEL_14:
    unint64_t __src = 0LL;
    unint64_t v270 = 0xE000000000000000LL;
    Swift::Int v54 = _StringGuts.nativeCapacity.getter(v41, v42);
    if ((v55 & 1) == 0) {
      String.reserveCapacity(_:)(v54);
    }
    v56._Swift::UInt64 rawBits = v265;
    Swift::UInt64 v265 = v41;
    unint64_t v59 = specialized Collection.subscript.getter(v56, v41, v42);
    unint64_t v61 = v60;
    uint64_t v62 = v57;
    unint64_t v63 = v58;
    uint64_t v64 = v60 >> 16;
    Swift::String::Index v260 = (const char *)(v59 >> 16);
    if ((v58 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v58, 3LL, v57, (char *)v58);
      v205._Swift::UInt64 rawBits = v59 & 0xFFFFFFFFFFFF0000LL | 1;
      v206._Swift::UInt64 rawBits = v61 & 0xFFFFFFFFFFFF0000LL | 1;
      v207._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v205, v206, v62, v63);
      if (v207._rawBits < 0x10000) {
        v207._rawBits |= 3;
      }
      Swift::Int v65 = specialized Collection.count.getter(v207, v208, v62, v63);
      swift_bridgeObjectRelease(v63);
      uint64_t v67 = __src;
      unint64_t v66 = v270;
      if ((v270 & 0x1000000000000000LL) == 0)
      {
LABEL_18:
        if ((v66 & 0x2000000000000000LL) != 0) {
          goto LABEL_22;
        }
        int64_t v68 = (v67 & 0xFFFFFFFFFFFFLL) + v65;
        if (!__OFADD__(v67 & 0xFFFFFFFFFFFFLL, v65)) {
          goto LABEL_23;
        }
        goto LABEL_21;
      }
    }

    else
    {
      Swift::Int v65 = v64 - (v59 >> 16);
      swift_bridgeObjectRetain_n(v58, 2LL, v57, (char *)v58);
      uint64_t v67 = __src;
      unint64_t v66 = v270;
      if ((v270 & 0x1000000000000000LL) == 0) {
        goto LABEL_18;
      }
    }

    Swift::Int v209 = String.UTF8View._foreignCount()();
    int64_t v68 = v209 + v65;
    if (!__OFADD__(v209, v65)) {
      goto LABEL_23;
    }
    do
    {
LABEL_21:
      __break(1u);
LABEL_22:
      uint64_t v69 = HIBYTE(v66) & 0xF;
      int64_t v68 = v69 + v65;
    }

    while (__OFADD__(v69, v65));
LABEL_23:
    if ((v67 & ~v66 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v66 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v70 = _StringGuts.nativeUnusedCapacity.getter(v67, v66);
      if ((v71 & 1) != 0) {
        goto LABEL_187;
      }
      if (v68 > 15 || (v66 & 0x2000000000000000LL) == 0 && v70 >= v65)
      {
LABEL_29:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v68, v65);
        swift_bridgeObjectRelease(v63);
        if ((v63 & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v62, v63, (uint64_t)v260, v64);
        }

        else
        {
          if ((v63 & 0x2000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v63);
            unint64_t v122 = HIBYTE(v63) & 0xF;
            uint64_t v273 = v62;
            uint64_t v274 = v63 & 0xFFFFFFFFFFFFFFLL;
            if (v122 < v64) {
              goto LABEL_178;
            }
            uint64_t v123 = (char *)specialized UnsafeBufferPointer.init(rebasing:)((uint64_t)v260, v64, (uint64_t)&v273, v122);
            _StringGuts.appendInPlace(_:isASCII:)(v123, v124, (v63 & 0x4000000000000000LL) != 0);
            goto LABEL_69;
          }

          if ((v62 & 0x1000000000000000LL) != 0)
          {
            id v72 = (id)((v63 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v73 = v62 & 0xFFFFFFFFFFFFLL;
            if ((v62 & 0xFFFFFFFFFFFFLL) < v64) {
              goto LABEL_178;
            }
          }

          else
          {
            id v72 = _StringObject.sharedUTF8.getter(v62, v63);
            uint64_t v73 = v247;
            if (v247 < v64) {
              goto LABEL_178;
            }
          }

          unint64_t v74 = (char *)specialized UnsafeBufferPointer.init(rebasing:)((uint64_t)v260, v64, (uint64_t)v72, v73);
          _StringGuts.appendInPlace(_:isASCII:)(v74, v75, v62 < 0);
        }

        swift_bridgeObjectRelease(v63);
LABEL_69:
        unint64_t v95 = v265;
LABEL_70:
        unint64_t v125 = (const char *)(__src & 0xFFFFFFFFFFFFLL);
        if ((v270 & 0x2000000000000000LL) != 0) {
          unint64_t v125 = (const char *)(HIBYTE(v270) & 0xF);
        }
        Swift::String::Index v260 = v125;
        String.append<A>(contentsOf:)(v264, v263, v261);
        unint64_t v43 = __src;
        uint64_t v9 = v270;
        unint64_t v128 = HIBYTE(v270) & 0xF;
        if ((v270 & 0x2000000000000000LL) == 0) {
          unint64_t v128 = __src & 0xFFFFFFFFFFFFLL;
        }
        Swift::UInt64 v265 = v128;
        swift_bridgeObjectRetain_n(v270, 3LL, v126, v127);
        v129._Swift::UInt64 rawBits = v262;
        Swift::UInt64 v45 = specialized Collection.subscript.getter(v129, v95, v42);
        unint64_t v46 = v132;
        uint64_t Description = v130;
        unint64_t v133 = v131;
        Swift::String::Index v20 = (char *)(v45 >> 16);
        uint64_t v15 = (unint64_t *)(v132 >> 16);
        if ((v131 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRetain_n(v131, 3LL, v130, (char *)v131);
          v210._Swift::UInt64 rawBits = v45 & 0xFFFFFFFFFFFF0000LL | 1;
          v211._Swift::UInt64 rawBits = v46 & 0xFFFFFFFFFFFF0000LL | 1;
          v212._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v210, v211, Description, v133);
          if (v212._rawBits < 0x10000) {
            v212._rawBits |= 3;
          }
          Swift::Int v6 = specialized Collection.count.getter(v212, v213, Description, v133);
          swift_bridgeObjectRelease(v9);
          uint64_t v134 = v133;
        }

        else
        {
          Swift::Int v6 = (char *)v15 - v20;
          swift_bridgeObjectRetain_n(v131, 2LL, v130, (char *)v131);
          uint64_t v134 = v9;
        }

        swift_bridgeObjectRelease(v9);
        swift_bridgeObjectRelease(v134);
        Swift::Int v135 = v265;
        if ((v9 & 0x1000000000000000LL) != 0) {
          Swift::Int v135 = String.UTF8View._foreignCount()();
        }
        swift_bridgeObjectRelease(v9);
        BOOL v136 = __OFADD__(v135, v6);
        int64_t v137 = v135 + v6;
        if (v136)
        {
          __break(1u);
          goto LABEL_140;
        }

        if ((v43 & ~v9 & 0x2000000000000000LL) == 0
          || (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL),
              unint64_t v43 = __src,
              uint64_t v9 = v270,
              !isUniquelyReferenced_nonNull_native))
        {
          if (v137 > 15) {
            goto LABEL_85;
          }
LABEL_91:
          swift_bridgeObjectRelease(v133);
          swift_bridgeObjectRetain(v9, v146, v147, v148);
          unint64_t v149 = _StringGuts._convertedToSmall()(v43, v9);
          unint64_t v151 = v150;
          swift_bridgeObjectRelease(v9);
          v152._Swift::UInt64 rawBits = v45 & 0xFFFFFFFFFFFF0000LL | 1;
          v153._Swift::UInt64 rawBits = v46 & 0xFFFFFFFFFFFF0000LL | 1;
          v154._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v152, v153, Description, v133);
          if (v154._rawBits < 0x10000) {
            v154._rawBits |= 3;
          }
          unint64_t v156 = specialized String.init(_:)(v154, v155, Description, v133);
          unint64_t v158 = v157;
          swift_bridgeObjectRelease(v133);
          unint64_t v159 = _StringGuts._convertedToSmall()(v156, v158);
          unint64_t v161 = v160;
          swift_bridgeObjectRelease(v158);
          uint64_t v162 = HIBYTE(v151) & 0xF;
          uint64_t v163 = HIBYTE(v161) & 0xF;
          uint64_t v164 = v163 + v162;
          if ((unint64_t)(v163 + v162) <= 0xF)
          {
            uint64_t v141 = v266;
            unint64_t v50 = v260;
            if (v163)
            {
              char v165 = 0;
              unint64_t v166 = 0LL;
              do
              {
                unint64_t v167 = v162 + v166;
                unint64_t v168 = v166 + 1;
                if (v166 >= 8) {
                  unint64_t v169 = v161;
                }
                else {
                  unint64_t v169 = v159;
                }
                unint64_t v170 = v169 >> (v165 & 0x38);
                char v171 = (8 * v162 + v165) & 0x38;
                uint64_t v172 = (-255LL << v171) - 1;
                unint64_t v173 = (unint64_t)v170 << v171;
                unint64_t v174 = v173 | v172 & v151;
                unint64_t v175 = v173 | v172 & v149;
                if (v167 < 8) {
                  unint64_t v149 = v175;
                }
                else {
                  unint64_t v151 = v174;
                }
                v165 += 8;
                unint64_t v166 = v168;
              }

              while (v163 != v168);
            }

            swift_bridgeObjectRelease(v9);
            unint64_t v176 = 0xA000000000000000LL;
            if (!(v149 & 0x8080808080808080LL | v151 & 0x80808080808080LL)) {
              unint64_t v176 = 0xE000000000000000LL;
            }
            unint64_t __src = v149;
            unint64_t v270 = v176 & 0xFF00000000000000LL | (v164 << 56) | v151 & 0xFFFFFFFFFFFFFFLL;
            goto LABEL_109;
          }

          goto LABEL_186;
        }

        int64_t v139 = _StringGuts.nativeUnusedCapacity.getter(__src, v270);
        if ((v140 & 1) == 0)
        {
          if (v137 > 15 || (v9 & 0x2000000000000000LL) == 0 && v139 >= v6)
          {
LABEL_85:
            _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v137, v6);
            swift_bridgeObjectRelease(v133);
            if ((v133 & 0x1000000000000000LL) != 0)
            {
              _StringGuts._foreignAppendInPlace(_:)(Description, v133, (uint64_t)v20, (uint64_t)v15);
              swift_bridgeObjectRelease(v133);
              uint64_t v141 = v266;
              unint64_t v50 = v260;
            }

            else
            {
              uint64_t v141 = v266;
              unint64_t v50 = v260;
              if ((v133 & 0x2000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v133);
                unint64_t v177 = HIBYTE(v133) & 0xF;
                uint64_t v273 = Description;
                uint64_t v274 = v133 & 0xFFFFFFFFFFFFFFLL;
                uint64_t v178 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( (uint64_t)v20,  (uint64_t)v15,  (uint64_t)&v273,  v177);
                _StringGuts.appendInPlace(_:isASCII:)(v178, v179, (v133 & 0x4000000000000000LL) != 0);
              }

              else
              {
                if ((Description & 0x1000000000000000LL) != 0)
                {
                  id v142 = (id)((v133 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v143 = Description & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  id v142 = _StringObject.sharedUTF8.getter(Description, v133);
                  uint64_t v143 = v248;
                }

                uint64_t v144 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( (uint64_t)v20,  (uint64_t)v15,  (uint64_t)v142,  v143);
                _StringGuts.appendInPlace(_:isASCII:)(v144, v145, Description < 0);
                swift_bridgeObjectRelease(v133);
              }
            }

LABEL_176:
    uint64_t v48 = (char *)_StringObject.sharedUTF8.getter(v47, v46);
    size_t v49 = v249;
LABEL_8:
    unint64_t v50 = (const char *)(v265 >> 16);
    uint64_t v51 = v262 >> 16;
    unint64_t v52 = v15[1];
    if ((v52 & 0x2000000000000000LL) != 0) {
      uint64_t v53 = HIBYTE(v52) & 0xF;
    }
    else {
      uint64_t v53 = *v15 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t Description = v53 - v51 + v49 + (v265 >> 16);
    if (Description < 16) {
      goto LABEL_66;
    }
    goto LABEL_63;
  }

  v270 &= 0xFFFFFFFFFFFFFFuLL;
  uint64_t v183 = v266;
  unint64_t v50 = (const char *)(v265 >> 16);
  uint64_t v184 = v262 >> 16;
  unint64_t v185 = v266[1];
  if ((v185 & 0x2000000000000000LL) != 0) {
    uint64_t v186 = HIBYTE(v185) & 0xF;
  }
  else {
    uint64_t v186 = *v266 & 0xFFFFFFFFFFFFLL;
  }
  Swift::Int v187 = v186 - v184 + (HIBYTE(v46) & 0xF) + (v265 >> 16);
  if (v187 > 15)
  {
    uint64_t v188 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v189 & 1) != 0 || v188 < v187) {
      _StringGuts.grow(_:)(v187);
    }
  }

  unint64_t v190 = v183[1];
  __StringStorage.replace(from:to:with:)((uint64_t)v50, v184, (char *)&__src, HIBYTE(v46) & 0xF);
  swift_bridgeObjectRelease(v46);
  *uint64_t v183 = *(void *)(v190 + 24);
  return v50;
}

unint64_t closure #3 in _StringGuts.replaceSubrange<A>(_:with:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, void *a5@<X8>)
{
  uint64_t v5 = *a1;
  unint64_t v6 = a1[1];
  *a5 = v5;
  a5[1] = v6;
  return swift_bridgeObjectRetain(v6, a2, a3, a4);
}

unint64_t specialized _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t (*a7)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t (*a8)(uint64_t), void (*a9)(unint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v13 = v9;
  uint64_t v20 = a7(a3, a4, a5, a6);
  uint64_t v21 = a8(v20);
  unint64_t v23 = a1 >> 16;
  uint64_t v24 = (a1 >> 16) + v21;
  if (__OFADD__(a1 >> 16, v21))
  {
    __break(1u);
LABEL_32:
    __break(1u);
    goto LABEL_33;
  }

  unint64_t v11 = a2 >> 16;
  unint64_t v25 = v13[1];
  if ((v25 & 0x2000000000000000LL) != 0) {
    uint64_t v26 = HIBYTE(v25) & 0xF;
  }
  else {
    uint64_t v26 = *v13 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v27 = v26 - v11;
  uint64_t v28 = v24 + v27;
  if (__OFADD__(v24, v27)) {
    goto LABEL_32;
  }
  uint64_t v10 = v21;
  uint64_t v29 = a9;
  if (v28 >= 16)
  {
    size_t v49 = a9;
    uint64_t v30 = _StringGuts.uniqueNativeCapacity.getter();
    uint64_t v29 = a9;
    if ((v31 & 1) != 0 || v30 < v28)
    {
      uint64_t v32 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v33 & 1) != 0)
      {
        unint64_t v35 = v13[1];
        if ((v35 & 0x1000000000000000LL) != 0)
        {
          Swift::Int v34 = String.UTF8View._foreignCount()();
        }

        else if ((v35 & 0x2000000000000000LL) != 0)
        {
          Swift::Int v34 = HIBYTE(v35) & 0xF;
        }

        else
        {
          Swift::Int v34 = *v13 & 0xFFFFFFFFFFFFLL;
        }
      }

      else
      {
        Swift::Int v34 = 2 * v32;
      }

      if (v34 <= v28) {
        int64_t v22 = v28;
      }
      else {
        int64_t v22 = v34;
      }
      unint64_t v36 = v13[1];
      if ((v36 & 0x1000000000000000LL) == 0)
      {
        uint64_t v37 = *v13;
        if ((v36 & 0x2000000000000000LL) != 0)
        {
          __src[0] = *v13;
          __src[1] = v36 & 0xFFFFFFFFFFFFFFLL;
          unint64_t v41 = HIBYTE(v36) & 0xF | 0xC000000000000000LL;
          uint64_t __n = HIBYTE(v36) & 0xF;
          if ((v36 & 0x4000000000000000LL) == 0) {
            unint64_t v41 = HIBYTE(v36) & 0xF;
          }
          uint64_t v42 = v41 | 0x3000000000000000LL;
          int64_t v40 = _allocateStringStorage(codeUnitCapacity:)(v22);
          *(void *)(v40 + 16) = v43;
          *(void *)(v40 + 24) = v42;
          if (v43 < 0)
          {
            *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
            uint64_t v42 = *(void *)(v40 + 24);
          }

          *(_BYTE *)(v40 + 32 + (v42 & 0xFFFFFFFFFFFFLL)) = 0;
          specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, __n, (char *)(v40 + 32));
        }

        else
        {
          if ((v37 & 0x1000000000000000LL) != 0)
          {
            uint64_t v38 = (char *)((v36 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v39 = v37 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            int64_t v47 = v22;
            uint64_t v38 = (char *)_StringObject.sharedUTF8.getter(*v13, v36);
            int64_t v22 = v47;
          }

          int64_t v40 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v38,  v39,  v22,  v37 < 0);
        }

        uint64_t v44 = *(void *)(v40 + 24);
        swift_bridgeObjectRelease(v13[1]);
        uint64_t *v13 = v44;
        v13[1] = v40;
        goto LABEL_29;
      }

uint64_t specialized _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v8 = a1 >> 16;
  uint64_t v9 = a2 >> 16;
  unint64_t v10 = v4[1];
  if ((v10 & 0x2000000000000000LL) != 0) {
    uint64_t v11 = HIBYTE(v10) & 0xF;
  }
  else {
    uint64_t v11 = *v4 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v12 = v11 - v9 + v8;
  if (v12 >= 16)
  {
    uint64_t v13 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v14 & 1) != 0 || v13 < v12)
    {
      uint64_t v15 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v16 & 1) != 0)
      {
        unint64_t v18 = v4[1];
        if ((v18 & 0x1000000000000000LL) != 0)
        {
          Swift::Int v17 = String.UTF8View._foreignCount()();
        }

        else if ((v18 & 0x2000000000000000LL) != 0)
        {
          Swift::Int v17 = HIBYTE(v18) & 0xF;
        }

        else
        {
          Swift::Int v17 = *v4 & 0xFFFFFFFFFFFFLL;
        }
      }

      else
      {
        Swift::Int v17 = 2 * v15;
      }

      if (v17 <= v12) {
        int64_t v19 = v12;
      }
      else {
        int64_t v19 = v17;
      }
      unint64_t v20 = v4[1];
      if ((v20 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignGrow(_:)(v19);
      }

      else
      {
        uint64_t v21 = *v4;
        if ((v20 & 0x2000000000000000LL) != 0)
        {
          size_t v25 = HIBYTE(v20) & 0xF;
          v33[0] = *v5;
          v33[1] = v20 & 0xFFFFFFFFFFFFFFLL;
          unint64_t v26 = v25 | 0xC000000000000000LL;
          if ((v20 & 0x4000000000000000LL) == 0) {
            unint64_t v26 = HIBYTE(v20) & 0xF;
          }
          uint64_t v27 = v26 | 0x3000000000000000LL;
          int64_t v24 = _allocateStringStorage(codeUnitCapacity:)(v19);
          *(void *)(v24 + 16) = v28;
          *(void *)(v24 + 24) = v27;
          if (v28 < 0)
          {
            *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
            uint64_t v27 = *(void *)(v24 + 24);
          }

          *(_BYTE *)(v24 + 32 + (v27 & 0xFFFFFFFFFFFFLL)) = 0;
          specialized UnsafeMutablePointer.initialize(from:count:)((char *)v33, v25, (char *)(v24 + 32));
        }

        else
        {
          if ((v21 & 0x1000000000000000LL) != 0)
          {
            int64_t v22 = (char *)((v20 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v23 = v21 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            int64_t v32 = v19;
            int64_t v22 = (char *)_StringObject.sharedUTF8.getter(*v5, v20);
            int64_t v19 = v32;
          }

          int64_t v24 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v22,  v23,  v19,  v21 < 0);
        }

        uint64_t v29 = *(void *)(v24 + 24);
        swift_bridgeObjectRelease(v5[1]);
        *uint64_t v5 = v29;
        v5[1] = v24;
      }
    }
  }

  uint64_t v30 = v5[1];
  specialized __StringStorage.replace<A>(from:to:with:replacementCount:)(v8, v9, a3, a4, 0LL);
  *uint64_t v5 = *(void *)(v30 + 24);
  return v8;
}

uint64_t specialized _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( unint64_t a1, unint64_t a2, int a3, void (*a4)(uint64_t *__return_ptr, int *), unint64_t *a5)
{
  uint64_t v7 = v5;
  int v41 = a3;
  a4(__src, &v41);
  unint64_t v13 = specialized FlattenSequence<>.distance(from:to:)(0LL, 0LL, 0, 1LL, 0LL, 1, a3, a4, a5);
  uint64_t v15 = a1 >> 16;
  unint64_t v16 = v15 + v13;
  if (__OFADD__(v15, v13))
  {
    __break(1u);
LABEL_31:
    __break(1u);
    goto LABEL_32;
  }

  a2 >>= 16;
  unint64_t v17 = v5[1];
  if ((v17 & 0x2000000000000000LL) != 0) {
    uint64_t v18 = HIBYTE(v17) & 0xF;
  }
  else {
    uint64_t v18 = *v5 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v19 = v18 - a2;
  uint64_t v20 = v16 + v19;
  if (__OFADD__(v16, v19)) {
    goto LABEL_31;
  }
  uint64_t v6 = v13;
  if (v20 < 16) {
    goto LABEL_29;
  }
  uint64_t v21 = _StringGuts.uniqueNativeCapacity.getter();
  if ((v22 & 1) == 0 && v21 >= v20) {
    goto LABEL_29;
  }
  uint64_t v23 = _StringGuts.uniqueNativeCapacity.getter();
  if ((v24 & 1) != 0)
  {
    unint64_t v26 = v5[1];
    if ((v26 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v25 = String.UTF8View._foreignCount()();
    }

    else if ((v26 & 0x2000000000000000LL) != 0)
    {
      Swift::Int v25 = HIBYTE(v26) & 0xF;
    }

    else
    {
      Swift::Int v25 = *v5 & 0xFFFFFFFFFFFFLL;
    }
  }

  else
  {
    Swift::Int v25 = 2 * v23;
  }

  if (v25 <= v20) {
    int64_t v14 = v20;
  }
  else {
    int64_t v14 = v25;
  }
  unint64_t v27 = v5[1];
  if ((v27 & 0x1000000000000000LL) != 0)
  {
LABEL_32:
    _StringGuts._foreignGrow(_:)(v14);
    goto LABEL_29;
  }

  uint64_t v28 = *v5;
  if ((v27 & 0x2000000000000000LL) != 0)
  {
    __src[0] = *v7;
    __src[1] = v27 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v32 = HIBYTE(v27) & 0xF | 0xC000000000000000LL;
    uint64_t __n = HIBYTE(v27) & 0xF;
    if ((v27 & 0x4000000000000000LL) == 0) {
      unint64_t v32 = HIBYTE(v27) & 0xF;
    }
    uint64_t v33 = v32 | 0x3000000000000000LL;
    int64_t v31 = _allocateStringStorage(codeUnitCapacity:)(v14);
    *(void *)(v31 + 16) = v34;
    *(void *)(v31 + 24) = v33;
    if (v34 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      uint64_t v33 = *(void *)(v31 + 24);
    }

    *(_BYTE *)(v31 + 32 + (v33 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, __n, (char *)(v31 + 32));
  }

  else
  {
    if ((v28 & 0x1000000000000000LL) != 0)
    {
      uint64_t v29 = (char *)((v27 & 0xFFFFFFFFFFFFFFFLL) + 32);
      size_t v30 = v28 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      int64_t v38 = v14;
      uint64_t v29 = (char *)_StringObject.sharedUTF8.getter(*v7, v27);
      int64_t v14 = v38;
    }

    int64_t v31 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(v29, v30, v14, v28 < 0);
  }

  uint64_t v35 = *(void *)(v31 + 24);
  swift_bridgeObjectRelease(v7[1]);
  *uint64_t v7 = v35;
  v7[1] = v31;
LABEL_29:
  uint64_t v36 = v7[1];
  specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( v15,  a2,  a3,  (void (*)(uint64_t *__return_ptr, char *))a4,  a5,  v6);
  *uint64_t v7 = *(void *)(v36 + 24);
  return v15;
}

uint64_t _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = v5;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 112))(a4, a5);
  uint64_t v14 = a1 >> 16;
  uint64_t v15 = v14 + v12;
  if (__OFADD__(v14, v12))
  {
    __break(1u);
LABEL_31:
    __break(1u);
    goto LABEL_32;
  }

  a2 >>= 16;
  unint64_t v16 = v5[1];
  if ((v16 & 0x2000000000000000LL) != 0) {
    uint64_t v17 = HIBYTE(v16) & 0xF;
  }
  else {
    uint64_t v17 = *v5 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v18 = v17 - a2;
  uint64_t v19 = v15 + v18;
  if (__OFADD__(v15, v18)) {
    goto LABEL_31;
  }
  uint64_t v6 = v12;
  if (v19 < 16) {
    goto LABEL_29;
  }
  uint64_t v20 = _StringGuts.uniqueNativeCapacity.getter();
  if ((v21 & 1) == 0 && v20 >= v19) {
    goto LABEL_29;
  }
  uint64_t v22 = _StringGuts.uniqueNativeCapacity.getter();
  if ((v23 & 1) != 0)
  {
    unint64_t v25 = v5[1];
    if ((v25 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v24 = String.UTF8View._foreignCount()();
    }

    else if ((v25 & 0x2000000000000000LL) != 0)
    {
      Swift::Int v24 = HIBYTE(v25) & 0xF;
    }

    else
    {
      Swift::Int v24 = *v5 & 0xFFFFFFFFFFFFLL;
    }
  }

  else
  {
    Swift::Int v24 = 2 * v22;
  }

  if (v24 <= v19) {
    int64_t v13 = v19;
  }
  else {
    int64_t v13 = v24;
  }
  unint64_t v26 = v5[1];
  if ((v26 & 0x1000000000000000LL) != 0)
  {
LABEL_32:
    _StringGuts._foreignGrow(_:)(v13);
    goto LABEL_29;
  }

  uint64_t v27 = *v5;
  if ((v26 & 0x2000000000000000LL) != 0)
  {
    __src[0] = *v7;
    __src[1] = v26 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v31 = HIBYTE(v26) & 0xF | 0xC000000000000000LL;
    uint64_t __n = HIBYTE(v26) & 0xF;
    if ((v26 & 0x4000000000000000LL) == 0) {
      unint64_t v31 = HIBYTE(v26) & 0xF;
    }
    uint64_t v32 = v31 | 0x3000000000000000LL;
    int64_t v30 = _allocateStringStorage(codeUnitCapacity:)(v13);
    *(void *)(v30 + 16) = v33;
    *(void *)(v30 + 24) = v32;
    if (v33 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      uint64_t v32 = *(void *)(v30 + 24);
    }

    *(_BYTE *)(v30 + 32 + (v32 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, __n, (char *)(v30 + 32));
  }

  else
  {
    if ((v27 & 0x1000000000000000LL) != 0)
    {
      uint64_t v28 = (char *)((v26 & 0xFFFFFFFFFFFFFFFLL) + 32);
      size_t v29 = v27 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      int64_t v37 = v13;
      uint64_t v28 = (char *)_StringObject.sharedUTF8.getter(*v7, v26);
      int64_t v13 = v37;
    }

    int64_t v30 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(v28, v29, v13, v27 < 0);
  }

  uint64_t v34 = *(void *)(v30 + 24);
  swift_bridgeObjectRelease(v7[1]);
  *uint64_t v7 = v34;
  v7[1] = v30;
LABEL_29:
  uint64_t v35 = v7[1];
  __StringStorage.replace<A>(from:to:with:replacementCount:)(v14, a2, a3, v6, a4);
  *uint64_t v7 = *(void *)(v35 + 24);
  return v14;
}

void specialized String.append<A>(contentsOf:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v5 = (uint64_t *)v4;
  uint64_t v9 = a1 >> 16;
  uint64_t v10 = a2 >> 16;
  if ((a4 & 0x1000000000000000LL) == 0)
  {
    Swift::Int v11 = v10 - v9;
    unint64_t v13 = *v4;
    unint64_t v12 = v4[1];
    if ((v12 & 0x1000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_49:
    Swift::Int v68 = String.UTF8View._foreignCount()();
    int64_t v15 = v68 + v11;
    if (!__OFADD__(v68, v11)) {
      goto LABEL_7;
    }
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }

  v58._Swift::UInt64 rawBits = a1 & 0xFFFFFFFFFFFF0000LL | 1;
  v59._Swift::UInt64 rawBits = a2 & 0xFFFFFFFFFFFF0000LL | 1;
  Swift::UInt64 v60 = _StringGuts.validateScalarRange(_:)(v58, v59, a3, a4);
  Swift::UInt64 v64 = v61;
  if (v60 >= 0x10000) {
    Swift::UInt64 v65 = v60;
  }
  else {
    Swift::UInt64 v65 = v60 | 3;
  }
  swift_bridgeObjectRetain(a4, v61, v62, v63);
  v66._Swift::UInt64 rawBits = v65;
  v67._Swift::UInt64 rawBits = v64;
  Swift::Int v11 = specialized Collection.count.getter(v66, v67, a3, a4);
  swift_bridgeObjectRelease(a4);
  unint64_t v13 = *v5;
  unint64_t v12 = v5[1];
  if ((v12 & 0x1000000000000000LL) != 0) {
    goto LABEL_49;
  }
LABEL_3:
  if ((v12 & 0x2000000000000000LL) != 0) {
    uint64_t v14 = HIBYTE(v12) & 0xF;
  }
  else {
    uint64_t v14 = v13 & 0xFFFFFFFFFFFFLL;
  }
  int64_t v15 = v14 + v11;
  if (__OFADD__(v14, v11)) {
    goto LABEL_51;
  }
LABEL_7:
  if ((v13 & ~v12 & 0x2000000000000000LL) != 0
    && (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL),
        unint64_t v13 = *v5,
        unint64_t v12 = v5[1],
        isUniquelyReferenced_nonNull_native))
  {
    int64_t v17 = _StringGuts.nativeUnusedCapacity.getter(*v5, v5[1]);
    if ((v18 & 1) != 0)
    {
      unint64_t v70 = 258LL;
LABEL_59:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v70,  0);
    }

    if (v15 > 15 || (v12 & 0x2000000000000000LL) == 0 && v17 >= v11)
    {
LABEL_13:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v15, v11);
      if ((a4 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignAppendInPlace(_:)(a3, a4, v9, v10);
        return;
      }

      if ((a4 & 0x2000000000000000LL) != 0)
      {
        v72[0] = a3;
        v72[1] = a4 & 0xFFFFFFFFFFFFFFLL;
        if ((HIBYTE(a4) & 0xF) >= (unint64_t)v10)
        {
          if (v10 - v9 >= 0)
          {
            uint64_t v24 = v5[1] & 0xFFFFFFFFFFFFFFFLL;
            specialized UnsafeMutablePointer.initialize(from:count:)( (char *)v72 + v9,  v10 - v9,  (char *)(v24 + (*(void *)(v24 + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
            uint64_t v56 = *(void *)(v24 + 24);
            Swift::Int v26 = (v56 & 0xFFFFFFFFFFFFLL) + v10 - v9;
            LOBYTE(v27) = (a4 >> 62) & (v56 < 0);
            goto LABEL_43;
          }

void specialized String.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v96 = *(void *)(a1 + 16);
  if (v96)
  {
    uint64_t v5 = 0LL;
    uint64_t v95 = a1 + 32;
    do
    {
      uint64_t v6 = (unint64_t *)(v95 + 16 * v5);
      unint64_t v8 = *v6;
      unint64_t v7 = v6[1];
      unint64_t v10 = *v4;
      unint64_t v9 = v4[1];
      uint64_t v11 = HIBYTE(v9) & 0xF;
      if ((v9 & 0x2000000000000000LL) != 0) {
        uint64_t v12 = HIBYTE(v9) & 0xF;
      }
      else {
        uint64_t v12 = *v4 & 0xFFFFFFFFFFFFLL;
      }
      if (!v12 && (v10 & ~v9 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRetain(v7, a2, a3, a4);
        swift_bridgeObjectRelease(v9);
        *unint64_t v4 = v8;
        v4[1] = v7;
        goto LABEL_4;
      }

      uint64_t v13 = v7 & 0x2000000000000000LL;
      uint64_t v14 = HIBYTE(v7) & 0xF;
      if ((v9 & 0x2000000000000000LL) != 0 && v13)
      {
        uint64_t v15 = v11 + v14;
        if ((unint64_t)(v11 + v14) <= 0xF)
        {
          if (v14)
          {
            uint64_t v59 = 0LL;
            unint64_t v60 = 0LL;
            uint64_t v61 = v4[1];
            do
            {
              unint64_t v62 = v11 + v60;
              unint64_t v63 = v60 + 1;
              if (v60 >= 8) {
                unint64_t v64 = v7;
              }
              else {
                unint64_t v64 = v8;
              }
              unint64_t v65 = v64 >> (v59 & 0x38);
              char v66 = (8 * v11 + v59) & 0x38;
              uint64_t v67 = (-255LL << v66) - 1;
              unint64_t v68 = (unint64_t)v65 << v66;
              unint64_t v69 = v68 | v67 & v61;
              unint64_t v70 = v68 | v67 & v10;
              if (v62 < 8) {
                unint64_t v10 = v70;
              }
              else {
                uint64_t v61 = v69;
              }
              v59 += 8LL;
              unint64_t v60 = v63;
            }

            while (v14 != v63);
          }

          else
          {
            uint64_t v61 = v4[1];
          }

          swift_bridgeObjectRelease(v4[1]);
          unint64_t v85 = 0xA000000000000000LL;
          if (!(v10 & 0x8080808080808080LL | v61 & 0x80808080808080LL)) {
            unint64_t v85 = 0xE000000000000000LL;
          }
          unint64_t v58 = v85 & 0xFF00000000000000LL | (v15 << 56) | v61 & 0xFFFFFFFFFFFFFFLL;
          *unint64_t v4 = v10;
LABEL_79:
          v4[1] = v58;
          goto LABEL_4;
        }

        uint64_t v13 = 1LL;
      }

      uint64_t v97 = v5;
      int64_t __n = v8 & 0xFFFFFFFFFFFFLL;
      if (v13) {
        uint64_t v16 = HIBYTE(v7) & 0xF;
      }
      else {
        uint64_t v16 = v8 & 0xFFFFFFFFFFFFLL;
      }
      if ((v7 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v7, 3LL, a3, a4);
        v86._Swift::UInt64 rawBits = 1LL;
        v87._Swift::UInt64 rawBits = (v16 << 16) | 1;
        v88._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v86, v87, v8, v7);
        if (v88._rawBits < 0x10000) {
          v88._rawBits |= 3;
        }
        Swift::Int v17 = specialized Collection.count.getter(v88, v89, v8, v7);
        swift_bridgeObjectRelease(v7);
        if ((v9 & 0x1000000000000000LL) == 0)
        {
LABEL_19:
          BOOL v18 = __OFADD__(v12, v17);
          int64_t v19 = v12 + v17;
          if (v18) {
            goto LABEL_92;
          }
          goto LABEL_20;
        }
      }

      else
      {
        swift_bridgeObjectRetain_n(v7, 2LL, a3, a4);
        Swift::Int v17 = v16;
        if ((v9 & 0x1000000000000000LL) == 0) {
          goto LABEL_19;
        }
      }

      Swift::Int v90 = String.UTF8View._foreignCount()();
      int64_t v19 = v90 + v17;
      if (__OFADD__(v90, v17))
      {
LABEL_92:
        __break(1u);
LABEL_93:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
      }

void specialized String.append<A>(contentsOf:)( unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  if (&full type metadata for CollectionOfOne<Character> == &full type metadata for String)
  {
    specialized String.append<A>(contentsOf:)(a1, a2, a3, a4);
    return;
  }

  if (&full type metadata for CollectionOfOne<Character> == &full type metadata for Substring)
  {
    __break(1u);
LABEL_92:
    unint64_t v90 = 266LL;
    goto LABEL_94;
  }

  if (&full type metadata for CollectionOfOne<Character> == &full type metadata for [Character])
  {
    specialized String.append<A>(contentsOf:)(a1, a2, a3, a4);
    return;
  }

  unint64_t v8 = *v4;
  unint64_t v7 = v4[1];
  uint64_t v9 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) != 0) {
    uint64_t v10 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v10 = *v4 & 0xFFFFFFFFFFFFLL;
  }
  if (!v10 && (v8 & ~v7 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain(a2, a2, a3, a4);
    swift_bridgeObjectRelease(v7);
    *unint64_t v4 = a1;
    v4[1] = a2;
    return;
  }

  uint64_t v11 = a2 & 0x2000000000000000LL;
  uint64_t v12 = HIBYTE(a2) & 0xF;
  if ((v7 & 0x2000000000000000LL) != 0 && v11)
  {
    uint64_t v13 = v9 + v12;
    if ((unint64_t)(v9 + v12) <= 0xF)
    {
      if (v12)
      {
        uint64_t v56 = 0LL;
        unint64_t v57 = 0LL;
        uint64_t v58 = v4[1];
        do
        {
          unint64_t v59 = v9 + v57;
          unint64_t v60 = v57 + 1;
          if (v57 >= 8) {
            unint64_t v61 = a2;
          }
          else {
            unint64_t v61 = a1;
          }
          unint64_t v62 = v61 >> (v56 & 0x38);
          char v63 = (8 * v9 + v56) & 0x38;
          uint64_t v64 = (-255LL << v63) - 1;
          unint64_t v65 = (unint64_t)v62 << v63;
          unint64_t v66 = v65 | v64 & v58;
          unint64_t v67 = v65 | v64 & v8;
          if (v59 < 8) {
            unint64_t v8 = v67;
          }
          else {
            uint64_t v58 = v66;
          }
          v56 += 8LL;
          unint64_t v57 = v60;
        }

        while (v12 != v60);
      }

      else
      {
        uint64_t v58 = v4[1];
      }

      swift_bridgeObjectRelease(v4[1]);
      unint64_t v82 = 0xA000000000000000LL;
      if (!(v8 & 0x8080808080808080LL | v58 & 0x80808080808080LL)) {
        unint64_t v82 = 0xE000000000000000LL;
      }
      *unint64_t v4 = v8;
      v4[1] = v82 & 0xFF00000000000000LL | (v13 << 56) | v58 & 0xFFFFFFFFFFFFFFLL;
      return;
    }

    uint64_t v11 = 1LL;
  }

  int64_t __n = a1 & 0xFFFFFFFFFFFFLL;
  if (v11) {
    uint64_t v14 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v14 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if ((a2 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(a2, 2LL, a3, a4);
    Swift::Int v15 = v14;
    if ((v7 & 0x1000000000000000LL) == 0) {
      goto LABEL_21;
    }
LABEL_85:
    Swift::Int v87 = String.UTF8View._foreignCount()();
    int64_t v17 = v87 + v15;
    if (!__OFADD__(v87, v15)) {
      goto LABEL_22;
    }
LABEL_87:
    __break(1u);
    goto LABEL_88;
  }

  swift_bridgeObjectRetain_n(a2, 2LL, a3, a4);
  v83._Swift::UInt64 rawBits = 1LL;
  v84._Swift::UInt64 rawBits = (v14 << 16) | 1;
  v85._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v83, v84, a1, a2);
  if (v85._rawBits < 0x10000) {
    v85._rawBits |= 3;
  }
  Swift::Int v15 = specialized Collection.count.getter(v85, v86, a1, a2);
  if ((v7 & 0x1000000000000000LL) != 0) {
    goto LABEL_85;
  }
LABEL_21:
  BOOL v16 = __OFADD__(v10, v15);
  int64_t v17 = v10 + v15;
  if (v16) {
    goto LABEL_87;
  }
LABEL_22:
  if ((v8 & ~v7 & 0x2000000000000000LL) == 0
    || (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL),
        unint64_t v8 = *v4,
        unint64_t v7 = v4[1],
        !isUniquelyReferenced_nonNull_native))
  {
    if (v17 >= 16) {
      goto LABEL_28;
    }
LABEL_40:
    unint64_t v30 = _StringGuts._convertedToSmall()(v8, v7);
    unint64_t v32 = v31;
    v33._Swift::UInt64 rawBits = (v14 << 16) | 1;
    v34._Swift::UInt64 rawBits = 3LL;
    unint64_t v35 = specialized String.init(_:)(v34, v33, a1, a2);
    unint64_t v37 = v36;
    swift_bridgeObjectRelease(a2);
    unint64_t v38 = _StringGuts._convertedToSmall()(v35, v37);
    unint64_t v40 = v39;
    swift_bridgeObjectRelease(v37);
    uint64_t v41 = HIBYTE(v32) & 0xF;
    uint64_t v42 = HIBYTE(v40) & 0xF;
    uint64_t v43 = v42 + v41;
    if ((unint64_t)(v42 + v41) <= 0xF)
    {
      if (v42)
      {
        char v44 = 0;
        unint64_t v45 = 0LL;
        do
        {
          unint64_t v46 = v41 + v45;
          unint64_t v47 = v45 + 1;
          if (v45 >= 8) {
            unint64_t v48 = v40;
          }
          else {
            unint64_t v48 = v38;
          }
          unint64_t v49 = v48 >> (v44 & 0x38);
          char v50 = (8 * v41 + v44) & 0x38;
          uint64_t v51 = (-255LL << v50) - 1;
          unint64_t v52 = (unint64_t)v49 << v50;
          unint64_t v53 = v52 | v51 & v32;
          unint64_t v54 = v52 | v51 & v30;
          if (v46 < 8) {
            unint64_t v30 = v54;
          }
          else {
            unint64_t v32 = v53;
          }
          v44 += 8;
          unint64_t v45 = v47;
        }

        while (v42 != v47);
      }

      swift_bridgeObjectRelease(v7);
      swift_bridgeObjectRelease(a2);
      unint64_t v55 = 0xA000000000000000LL;
      if (!(v30 & 0x8080808080808080LL | v32 & 0x80808080808080LL)) {
        unint64_t v55 = 0xE000000000000000LL;
      }
      *unint64_t v4 = v30;
      v4[1] = v55 & 0xFF00000000000000LL | (v43 << 56) | v32 & 0xFFFFFFFFFFFFFFLL;
      return;
    }

    goto LABEL_92;
  }

  int64_t v19 = _StringGuts.nativeUnusedCapacity.getter(*v4, v4[1]);
  if ((v20 & 1) != 0)
  {
    unint64_t v90 = 258LL;
LABEL_94:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v90,  0);
  }

  if (v17 <= 15 && ((v7 & 0x2000000000000000LL) != 0 || v19 < v15)) {
    goto LABEL_40;
  }
LABEL_28:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v17, v15);
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    _StringGuts._foreignAppendInPlace(_:)(a1, a2, 0LL, v14);
    swift_bridgeObjectRelease_n(a2, 2LL);
    return;
  }

  swift_bridgeObjectRelease(a2);
  if (v11)
  {
    __src[0] = a1;
    __src[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v21 = v4[1];
    uint64_t v22 = v21 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v23 = (v21 & 0xFFFFFFFFFFFFFFFLL) + 32;
    uint64_t v24 = (char *)(v23 + (*(void *)(v21 + 24) & 0xFFFFFFFFFFFFLL));
    if (__src >= (void *)&v24[v12] || v24 >= (char *)__src + v12)
    {
      memcpy(v24, __src, HIBYTE(a2) & 0xF);
      uint64_t v25 = *(void *)(v22 + 24);
      unint64_t v26 = (v25 & 0xFFFFFFFFFFFFLL) + v12;
      BOOL v27 = v25 > -1 || (a2 & 0x4000000000000000LL) == 0;
      unint64_t v28 = v26 | 0xC000000000000000LL;
      if (v27) {
        unint64_t v28 = v26;
      }
      *(void *)(v22 + 24) = v28 | 0x3000000000000000LL;
      *(_BYTE *)(v23 + (v28 & 0xFFFFFFFFFFFFLL)) = 0;
      uint64_t v29 = *(void *)(v22 + 16);
      if (v29 < 0)
      {
        uint64_t v80 = (uint64_t *)((v23 + (v29 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
        uint64_t v81 = *v80;
        *uint64_t v80 = 0LL;
        swift_bridgeObjectRelease(a2);
        swift_release(v81);
      }

      else
      {
        swift_bridgeObjectRelease(a2);
      }

      *unint64_t v4 = *(void *)(v22 + 24);
      return;
    }

{
  unint64_t *v4;
  unint64_t v7;
  uint64_t v8;
  unint64_t v7 = v4[1];
  unint64_t v8 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) == 0) {
    unint64_t v8 = *v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 || (*v4 & ~v7 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(a1, a2);
  }

  else
  {
    swift_bridgeObjectRetain(a2, a2, a3, a4);
    swift_bridgeObjectRelease(v7);
    *unint64_t v4 = a1;
    v4[1] = a2;
  }

void specialized String.append<A>(contentsOf:)( uint64_t a1, unint64_t a2, unint64_t a3, char *a4)
{
  if (&full type metadata for Repeated<Character> != &full type metadata for String)
  {
    if (&full type metadata for Repeated<Character> == &full type metadata for Substring)
    {
      __break(1u);
LABEL_103:
      unint64_t v95 = 266LL;
LABEL_105:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v95,  0);
    }

    if (&full type metadata for Repeated<Character> == &full type metadata for [Character])
    {
      specialized String.append<A>(contentsOf:)(a1, a2, a3, a4);
      return;
    }

    swift_bridgeObjectRetain(a3, a2, a3, a4);
    if (!a1)
    {
LABEL_98:
      swift_bridgeObjectRelease(a3);
      return;
    }

    uint64_t v11 = 0LL;
    uint64_t v12 = HIBYTE(a3) & 0xF;
    size_t v13 = a2 & 0xFFFFFFFFFFFFLL;
    if ((a3 & 0x2000000000000000LL) != 0) {
      uint64_t v14 = HIBYTE(a3) & 0xF;
    }
    else {
      uint64_t v14 = a2 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v97 = (char *)v103 + v12;
    uint64_t v101 = v14;
    Swift::UInt64 v98 = (v14 << 16) | 1;
    uint64_t v15 = a1 & ~(a1 >> 63);
    while (1)
    {
      if (v11 == v15) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x51uLL,  0);
      }
      int64_t __n = v13;
      unint64_t v17 = *v4;
      unint64_t v16 = v4[1];
      uint64_t v18 = HIBYTE(v16) & 0xF;
      uint64_t v19 = (v16 & 0x2000000000000000LL) != 0 ? HIBYTE(v16) & 0xF : *v4 & 0xFFFFFFFFFFFFLL;
      if (v19 || (v17 & ~v16 & 0x2000000000000000LL) != 0) {
        break;
      }
      uint64_t v76 = v15;
      swift_bridgeObjectRetain(a3, v8, v9, v10);
      swift_bridgeObjectRelease(v16);
      uint64_t v15 = v76;
      *unint64_t v4 = a2;
      v4[1] = a3;
      size_t v13 = __n;
LABEL_82:
      if (++v11 == a1) {
        goto LABEL_98;
      }
    }

    uint64_t v100 = v15;
    if ((v16 & 0x2000000000000000LL) != 0 && (a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v20 = v18 + v12;
      if ((unint64_t)(v18 + v12) <= 0xF)
      {
        if (v12)
        {
          uint64_t v64 = 0LL;
          unint64_t v65 = 0LL;
          uint64_t v66 = v4[1];
          do
          {
            unint64_t v67 = v18 + v65;
            unint64_t v68 = v65 + 1;
            if (v65 >= 8) {
              unint64_t v69 = a3;
            }
            else {
              unint64_t v69 = a2;
            }
            unint64_t v70 = v69 >> (v64 & 0x38);
            char v71 = (8 * v18 + v64) & 0x38;
            uint64_t v72 = (-255LL << v71) - 1;
            unint64_t v73 = (unint64_t)v70 << v71;
            unint64_t v74 = v73 | v72 & v66;
            unint64_t v75 = v73 | v72 & v17;
            if (v67 < 8) {
              unint64_t v17 = v75;
            }
            else {
              uint64_t v66 = v74;
            }
            v64 += 8LL;
            unint64_t v65 = v68;
          }

          while (v12 != v68);
        }

        else
        {
          uint64_t v66 = v4[1];
        }

        swift_bridgeObjectRelease(v16);
        unint64_t v85 = 0xA000000000000000LL;
        if (!(v17 & 0x8080808080808080LL | v66 & 0x80808080808080LL)) {
          unint64_t v85 = 0xE000000000000000LL;
        }
        *unint64_t v4 = v17;
        v4[1] = v85 & 0xFF00000000000000LL | (v20 << 56) | v66 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_80;
      }
    }

    size_t v99 = v12;
    swift_bridgeObjectRetain_n(a3, 2LL, v9, v10);
    Swift::Int v21 = v101;
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      v88._Swift::UInt64 rawBits = 1LL;
      v89._Swift::UInt64 rawBits = v98;
      v90._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v88, v89, a2, a3);
      if (v90._rawBits < 0x10000) {
        v90._rawBits |= 3;
      }
      Swift::Int v21 = specialized Collection.count.getter(v90, v91, a2, a3);
      if ((v16 & 0x1000000000000000LL) == 0)
      {
LABEL_23:
        BOOL v22 = __OFADD__(v19, v21);
        int64_t v23 = v19 + v21;
        if (v22) {
          goto LABEL_99;
        }
LABEL_24:
        if ((v17 & ~v16 & 0x2000000000000000LL) != 0
          && (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL),
              unint64_t v17 = *v4,
              unint64_t v16 = v4[1],
              isUniquelyReferenced_nonNull_native))
        {
          int64_t v25 = _StringGuts.nativeUnusedCapacity.getter(*v4, v4[1]);
          if ((v26 & 1) != 0)
          {
            unint64_t v95 = 258LL;
            goto LABEL_105;
          }

          if (v23 > 15 || (v16 & 0x2000000000000000LL) == 0 && v25 >= v21) {
            goto LABEL_30;
          }
        }

        else if (v23 >= 16)
        {
LABEL_30:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v23, v21);
          if ((a3 & 0x1000000000000000LL) != 0)
          {
            _StringGuts._foreignAppendInPlace(_:)(a2, a3, 0LL, v101);
            swift_bridgeObjectRelease_n(a3, 2LL);
            uint64_t v12 = v99;
            size_t v13 = __n;
          }

          else
          {
            swift_bridgeObjectRelease(a3);
            size_t v13 = __n;
            if ((a3 & 0x2000000000000000LL) != 0)
            {
              v103[0] = a2;
              v103[1] = a3 & 0xFFFFFFFFFFFFFFLL;
              uint64_t v77 = v4[1];
              uint64_t v78 = v77 & 0xFFFFFFFFFFFFFFFLL;
              uint64_t v79 = (v77 & 0xFFFFFFFFFFFFFFFLL) + 32;
              uint64_t v80 = (char *)(v79 + (*(void *)(v77 + 24) & 0xFFFFFFFFFFFFLL));
              if (v103 < (void *)&v80[v99] && v80 < v97) {
                goto LABEL_101;
              }
              memcpy(v80, v103, v99);
              uint64_t v81 = *(void *)(v78 + 24);
              BOOL v82 = v81 > -1 || (a3 & 0x4000000000000000LL) == 0;
              size_t v83 = (v81 & 0xFFFFFFFFFFFFLL) + v99;
              if (!v82) {
                v83 |= 0xC000000000000000LL;
              }
              *(void *)(v78 + 24) = v83 | 0x3000000000000000LL;
              *(_BYTE *)(v79 + (v83 & 0xFFFFFFFFFFFFLL)) = 0;
              uint64_t v84 = *(void *)(v78 + 16);
              if (v84 < 0)
              {
                Swift::String::Index v86 = (uint64_t *)((v79 + (v84 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
                uint64_t v87 = *v86;
                *Swift::String::Index v86 = 0LL;
                swift_bridgeObjectRelease(a3);
                swift_release(v87);
              }

              else
              {
                swift_bridgeObjectRelease(a3);
              }

              *unint64_t v4 = *(void *)(v78 + 24);
              uint64_t v12 = v99;
            }

            else
            {
              BOOL v27 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
              if ((a2 & 0x1000000000000000LL) == 0)
              {
                unint64_t v93 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
                if (v94 < __n) {
                  goto LABEL_100;
                }
                BOOL v27 = v93;
                if (__n)
                {
                  size_t v13 = __n;
                  if (!v93) {
                    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
                  }
                }

                else
                {
                  size_t v13 = 0LL;
                }
              }

              uint64_t v28 = v4[1];
              uint64_t v29 = v28 & 0xFFFFFFFFFFFFFFFLL;
              uint64_t v30 = (v28 & 0xFFFFFFFFFFFFFFFLL) + 32;
              unint64_t v31 = (char *)(v30 + (*(void *)(v28 + 24) & 0xFFFFFFFFFFFFLL));
              uint64_t v12 = v99;
              if (&v31[v13] > v27 && v31 < &v27[v13]) {
LABEL_101:
              }
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
              memcpy(v31, v27, v13);
              uint64_t v32 = *(void *)(v29 + 24);
              size_t v33 = (v32 & 0xFFFFFFFFFFFFLL) + v13;
              if (((v32 & a2 & 0x8000000000000000LL) != 0LL) != v22) {
                v33 |= 0xC000000000000000LL;
              }
              uint64_t v34 = v33 | 0x3000000000000000LL;
              *(void *)(v29 + 24) = v33 | 0x3000000000000000LL;
              *(_BYTE *)(v30 + (v33 & 0xFFFFFFFFFFFFLL)) = 0;
              uint64_t v35 = *(void *)(v29 + 16);
              if (v35 < 0)
              {
                unint64_t v36 = (uint64_t *)((v30 + (v35 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
                uint64_t v37 = *v36;
                *unint64_t v36 = 0LL;
                swift_release(v37);
                uint64_t v34 = *(void *)(v29 + 24);
              }

              *unint64_t v4 = v34;
              swift_bridgeObjectRelease(a3);
            }
          }

          goto LABEL_81;
        }

        uint64_t v96 = v11;
        unint64_t v38 = _StringGuts._convertedToSmall()(v17, v16);
        unint64_t v40 = v39;
        v41._Swift::UInt64 rawBits = 3LL;
        v42._Swift::UInt64 rawBits = v98;
        unint64_t v43 = specialized String.init(_:)(v41, v42, a2, a3);
        unint64_t v45 = v44;
        swift_bridgeObjectRelease(a3);
        unint64_t v46 = _StringGuts._convertedToSmall()(v43, v45);
        unint64_t v48 = v47;
        swift_bridgeObjectRelease(v45);
        uint64_t v49 = HIBYTE(v40) & 0xF;
        uint64_t v50 = HIBYTE(v48) & 0xF;
        uint64_t v51 = v50 + v49;
        if (v50)
        {
          char v52 = 0;
          unint64_t v53 = 0LL;
          do
          {
            unint64_t v54 = v49 + v53;
            unint64_t v55 = v53 + 1;
            if (v53 >= 8) {
              unint64_t v56 = v48;
            }
            else {
              unint64_t v56 = v46;
            }
            unint64_t v57 = v56 >> (v52 & 0x38);
            char v58 = (8 * v49 + v52) & 0x38;
            uint64_t v59 = (-255LL << v58) - 1;
            unint64_t v60 = (unint64_t)v57 << v58;
            unint64_t v61 = v60 | v59 & v40;
            unint64_t v62 = v60 | v59 & v38;
            if (v54 < 8) {
              unint64_t v38 = v62;
            }
            else {
              unint64_t v40 = v61;
            }
            v52 += 8;
            unint64_t v53 = v55;
          }

          while (v50 != v55);
        }

        swift_bridgeObjectRelease(v16);
        swift_bridgeObjectRelease(a3);
        unint64_t v63 = 0xA000000000000000LL;
        if (!(v38 & 0x8080808080808080LL | v40 & 0x80808080808080LL)) {
          unint64_t v63 = 0xE000000000000000LL;
        }
        *unint64_t v4 = v38;
        v4[1] = v63 & 0xFF00000000000000LL | (v51 << 56) | v40 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v11 = v96;
        uint64_t v12 = v99;
LABEL_80:
        size_t v13 = __n;
LABEL_81:
        uint64_t v15 = v100;
        goto LABEL_82;
      }
    }

    else if ((v16 & 0x1000000000000000LL) == 0)
    {
      goto LABEL_23;
    }

    Swift::Int v92 = String.UTF8View._foreignCount()();
    int64_t v23 = v92 + v21;
    if (__OFADD__(v92, v21))
    {
LABEL_99:
      __break(1u);
LABEL_100:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    goto LABEL_24;
  }

  specialized String.append<A>(contentsOf:)(a1, a2, a3, a4);
}

void String.append<A>(contentsOf:)(unint64_t *a1, ValueMetadata *a2, uint64_t a3)
{
  void (*v126)(unint64_t *__return_ptr, unint64_t);
  unint64_t v127;
  char *v128;
  unint64_t AssociatedTypeWitness;
  uint64_t *v130;
  unint64_t __src;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v128 = (char *)&v123 - v9;
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v123 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (uint64_t *)((char *)&v123 - v14);
  MEMORY[0x1895F8858](v13);
  Swift::Int v21 = (uint64_t *)((char *)&v123 - v20);
  if (a2 == &type metadata for String)
  {
    specialized String.append<A>(contentsOf:)(*a1, a1[1], v17, v18);
    return;
  }

  uint64_t v130 = v3;
  if (a2 == &type metadata for Substring)
  {
    specialized String.append<A>(contentsOf:)(*a1, a1[1], a1[2], a1[3]);
    return;
  }

  if (a2 == (ValueMetadata *)&unk_189B86C40)
  {
    specialized String.append<A>(contentsOf:)(*a1, v16, v17, v18);
    return;
  }

  BOOL v22 = *(void (**)(char *, unint64_t *, ValueMetadata *))(v19 + 16);
  v22((char *)&v123 - v20, a1, a2);
  if (!swift_dynamicCast((char *)&__src, v21, (swift *)a2, (const char *)&type metadata for String, 6uLL))
  {
    v22((char *)v15, a1, a2);
    if (swift_dynamicCast( (char *)&__src,  v15,  (swift *)a2,  (const char *)&type metadata for Substring,  6uLL))
    {
      uint64_t v24 = v134;
      String.append(contentsOf:)(__src, v132, v133, v134);
      goto LABEL_15;
    }

    uint64_t v124 = v7;
    v22(v12, a1, a2);
    (*(void (**)(ValueMetadata *, uint64_t))(a3 + 32))(a2, a3);
    unint64_t v28 = AssociatedTypeWitness;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v126 = *(void (**)(unint64_t *__return_ptr, unint64_t))(AssociatedConformanceWitness + 16);
    unint64_t v127 = AssociatedConformanceWitness;
    v126(&__src, v28);
    unint64_t v33 = v132;
    uint64_t v34 = (unint64_t *)v130;
    if (!v132)
    {
LABEL_107:
      (*(void (**)(char *, unint64_t))(v124 + 8))(v128, AssociatedTypeWitness);
      return;
    }

    unint64_t v35 = __src;
    while (1)
    {
      unint64_t v40 = *v34;
      unint64_t v39 = v34[1];
      uint64_t v41 = HIBYTE(v39) & 0xF;
      if ((v39 & 0x2000000000000000LL) != 0) {
        uint64_t v42 = HIBYTE(v39) & 0xF;
      }
      else {
        uint64_t v42 = *v34 & 0xFFFFFFFFFFFFLL;
      }
      if (!v42 && (v40 & ~v39 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v34[1]);
        unint64_t *v34 = v35;
        v34[1] = v33;
        goto LABEL_23;
      }

      uint64_t v43 = v33 & 0x2000000000000000LL;
      uint64_t v44 = HIBYTE(v33) & 0xF;
      unint64_t v45 = v41 + v44;
      if ((v33 & 0x2000000000000000LL & v39) != 0 && v45 <= 0xF)
      {
        if (v44)
        {
          uint64_t v93 = 0LL;
          unint64_t v94 = 0LL;
          unint64_t v36 = v34[1];
          do
          {
            unint64_t v95 = v41 + v94;
            unint64_t v96 = v94 + 1;
            if (v94 >= 8) {
              unint64_t v97 = v33;
            }
            else {
              unint64_t v97 = v35;
            }
            unint64_t v98 = v97 >> (v93 & 0x38);
            char v99 = (8 * v41 + v93) & 0x38;
            uint64_t v100 = (-255LL << v99) - 1;
            unint64_t v101 = (unint64_t)v98 << v99;
            unint64_t v102 = v101 | v100 & v36;
            unint64_t v103 = v101 | v100 & v40;
            if (v95 < 8) {
              unint64_t v40 = v103;
            }
            else {
              unint64_t v36 = v102;
            }
            v93 += 8LL;
            unint64_t v94 = v96;
          }

          while (v44 != v96);
        }

        else
        {
          unint64_t v36 = v34[1];
        }

        swift_bridgeObjectRelease(v34[1]);
        swift_bridgeObjectRelease(v33);
        unint64_t v37 = 0xA000000000000000LL;
        if (!(v40 & 0x8080808080808080LL | v36 & 0x80808080808080LL)) {
          unint64_t v37 = 0xE000000000000000LL;
        }
        unint64_t v38 = v37 & 0xFF00000000000000LL | (v45 << 56) | v36 & 0xFFFFFFFFFFFFFFLL;
        unint64_t *v34 = v40;
LABEL_22:
        v34[1] = v38;
        goto LABEL_23;
      }

      uint64_t v125 = v35 & 0xFFFFFFFFFFFFLL;
      if (v43) {
        uint64_t v47 = HIBYTE(v33) & 0xF;
      }
      else {
        uint64_t v47 = v35 & 0xFFFFFFFFFFFFLL;
      }
      if ((v33 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v33, 2LL, v31, v32);
        v115._Swift::UInt64 rawBits = 1LL;
        v116._Swift::UInt64 rawBits = (v47 << 16) | 1;
        v117._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v115, v116, v35, v33);
        if (v117._rawBits < 0x10000) {
          v117._rawBits |= 3;
        }
        Swift::Int v48 = specialized Collection.count.getter(v117, v118, v35, v33);
        swift_bridgeObjectRelease(v33);
        if ((v39 & 0x1000000000000000LL) == 0)
        {
LABEL_39:
          BOOL v49 = __OFADD__(v42, v48);
          int64_t v50 = v42 + v48;
          if (v49) {
            goto LABEL_110;
          }
          goto LABEL_40;
        }
      }

      else
      {
        swift_bridgeObjectRetain(v33, v30, v31, v32);
        Swift::Int v48 = v47;
        if ((v39 & 0x1000000000000000LL) == 0) {
          goto LABEL_39;
        }
      }

      Swift::Int v119 = String.UTF8View._foreignCount()();
      int64_t v50 = v119 + v48;
      if (__OFADD__(v119, v48))
      {
LABEL_110:
        __break(1u);
LABEL_111:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }

uint64_t specialized _StringGuts.replaceSubrange<A>(_:with:)(unint64_t a1, unint64_t a2)
{
  uint64_t v3 = v2;
  unint64_t v7 = *v3;
  unint64_t v6 = v3[1];
  if ((*v3 & ~v6 & 0x2000000000000000LL) != 0)
  {
    if (swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL)) {
      return specialized _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( a1,  a2,  (uint64_t)protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar,  0LL);
    }
    Swift::UInt64 v52 = a2;
    unint64_t v7 = *v3;
    unint64_t v6 = v3[1];
  }

  else
  {
    Swift::UInt64 v52 = a2;
  }

  Swift::Int v9 = _StringGuts.nativeCapacity.getter(v7, v6);
  if ((v10 & 1) == 0) {
    String.reserveCapacity(_:)(v9);
  }
  v11._Swift::UInt64 rawBits = a1;
  Swift::UInt64 v12 = specialized Collection.subscript.getter(v11, v7, v6);
  Swift::UInt64 v14 = v13;
  unint64_t v16 = v15;
  unint64_t v18 = (unint64_t)v17;
  swift_bridgeObjectRetain((unint64_t)v17, v13, v15, v17);
  v19._Swift::UInt64 rawBits = v12;
  v20._Swift::UInt64 rawBits = v14;
  Swift::Int v21 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v19,  v20,  v16,  v18);
  uint64_t v22 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v21, 1LL);
  unint64_t v24 = v23;
  swift_bridgeObjectRelease((uint64_t)v21);
  if (!v24) {
    goto LABEL_16;
  }
  unint64_t v25 = specialized static String.+ infix(_:_:)(0LL, 0xE000000000000000LL, v22, v24);
  unint64_t v27 = v26;
  swift_bridgeObjectRelease(v18);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRelease(v24);
  uint64_t v8 = (v27 & 0x2000000000000000LL) != 0 ? HIBYTE(v27) & 0xF : v25 & 0xFFFFFFFFFFFFLL;
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, 0LL, 0);
  uint64_t v28 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(&_swiftEmptyArrayStorage, 1LL);
  unint64_t v30 = v29;
  swift_release((uint64_t)&_swiftEmptyArrayStorage);
  if (!v30) {
    goto LABEL_16;
  }
  unint64_t v31 = specialized static String.+ infix(_:_:)(v25, v27, v28, v30);
  unint64_t v33 = v32;
  swift_bridgeObjectRelease(v27);
  swift_bridgeObjectRelease(v30);
  v34._Swift::UInt64 rawBits = v52;
  Swift::UInt64 v35 = specialized Collection.subscript.getter(v34, v7, v6);
  Swift::UInt64 v37 = v36;
  unint64_t v39 = v38;
  unint64_t v41 = (unint64_t)v40;
  swift_bridgeObjectRetain((unint64_t)v40, v36, v38, v40);
  v42._Swift::UInt64 rawBits = v35;
  v43._Swift::UInt64 rawBits = v37;
  uint64_t v44 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v42,  v43,  v39,  v41);
  uint64_t v45 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v44, 1LL);
  unint64_t v47 = v46;
  swift_bridgeObjectRelease((uint64_t)v44);
  if (!v47) {
LABEL_16:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  unint64_t v48 = specialized static String.+ infix(_:_:)(v31, v33, v45, v47);
  unint64_t v50 = v49;
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(v41);
  swift_bridgeObjectRelease(v33);
  swift_bridgeObjectRelease(v47);
  *uint64_t v3 = v48;
  v3[1] = v50;
  return v8;
}

uint64_t specialized _StringGuts.replaceSubrange<A>(_:with:)( unint64_t a1, unint64_t a2, int a3)
{
  unint64_t v4 = v3;
  unint64_t v9 = *v4;
  unint64_t v8 = v4[1];
  if ((*v4 & ~v8 & 0x2000000000000000LL) != 0)
  {
    if (swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL)) {
      return specialized _StringGuts.uniqueNativeReplaceSubrange<A>(_:with:)( a1,  a2,  a3,  (void (*)(uint64_t *__return_ptr, int *))protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar,  0LL);
    }
    Swift::UInt64 v55 = a2;
    unint64_t v9 = *v4;
    unint64_t v8 = v4[1];
  }

  else
  {
    Swift::UInt64 v55 = a2;
  }

  Swift::Int v11 = _StringGuts.nativeCapacity.getter(v9, v8);
  if ((v12 & 1) == 0) {
    String.reserveCapacity(_:)(v11);
  }
  v13._Swift::UInt64 rawBits = a1;
  Swift::UInt64 v14 = specialized Collection.subscript.getter(v13, v9, v8);
  Swift::UInt64 v16 = v15;
  unint64_t v18 = v17;
  unint64_t v20 = (unint64_t)v19;
  swift_bridgeObjectRetain((unint64_t)v19, v15, v17, v19);
  v21._Swift::UInt64 rawBits = v14;
  v22._Swift::UInt64 rawBits = v16;
  unint64_t v23 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v21,  v22,  v18,  v20);
  uint64_t v24 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v23, 1LL);
  unint64_t v26 = v25;
  swift_bridgeObjectRelease((uint64_t)v23);
  if (!v26) {
    goto LABEL_16;
  }
  unint64_t v27 = specialized static String.+ infix(_:_:)(0LL, 0xE000000000000000LL, v24, v26);
  unint64_t v29 = v28;
  swift_bridgeObjectRelease(v20);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRelease(v26);
  uint64_t v10 = (v29 & 0x2000000000000000LL) != 0 ? HIBYTE(v29) & 0xF : v27 & 0xFFFFFFFFFFFFLL;
  unint64_t v30 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s15CollectionOfOneVys7UnicodeO6ScalarVG_Tg506_sSS17ij42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n(a3);
  uint64_t v31 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v30, 1LL);
  unint64_t v33 = v32;
  swift_bridgeObjectRelease((uint64_t)v30);
  if (!v33) {
    goto LABEL_16;
  }
  unint64_t v34 = specialized static String.+ infix(_:_:)(v27, v29, v31, v33);
  unint64_t v36 = v35;
  swift_bridgeObjectRelease(v29);
  swift_bridgeObjectRelease(v33);
  v37._Swift::UInt64 rawBits = v55;
  Swift::UInt64 v38 = specialized Collection.subscript.getter(v37, v9, v8);
  Swift::UInt64 v40 = v39;
  unint64_t v42 = v41;
  unint64_t v44 = (unint64_t)v43;
  swift_bridgeObjectRetain((unint64_t)v43, v39, v41, v43);
  v45._Swift::UInt64 rawBits = v38;
  v46._Swift::UInt64 rawBits = v40;
  unint64_t v47 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v45,  v46,  v42,  v44);
  uint64_t v48 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v47, 1LL);
  unint64_t v50 = v49;
  swift_bridgeObjectRelease((uint64_t)v47);
  if (!v50) {
LABEL_16:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  unint64_t v51 = specialized static String.+ infix(_:_:)(v34, v36, v48, v50);
  unint64_t v53 = v52;
  swift_bridgeObjectRelease(v8);
  swift_bridgeObjectRelease(v44);
  swift_bridgeObjectRelease(v36);
  swift_bridgeObjectRelease(v50);
  *unint64_t v4 = v51;
  v4[1] = v53;
  return v10;
}

uint64_t _StringGuts.replaceSubrange<A>(_:with:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = (char *)a4;
  unint64_t v188 = a1;
  uint64_t v189 = a3;
  uint64_t v186 = a5;
  unint64_t v187 = a2;
  uint64_t v7 = *(void *)(a5 + 8);
  uint64_t v8 = type metadata accessor for LazySequence(0LL, a4, v7, a4);
  MEMORY[0x1895F8858](v8);
  unint64_t v185 = (char *)&v182 - v9;
  uint64_t v10 = type metadata accessor for LazyMapSequence( 255LL,  (uint64_t)v6,  (uint64_t)&type metadata for Unicode.Scalar.UTF8View,  v7);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v10, v11);
  unint64_t v15 = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View( WitnessTable,  v13,  v14);
  uint64_t v16 = type metadata accessor for FlattenSequence(255LL, v10, WitnessTable, v15);
  uint64_t v18 = swift_getWitnessTable(&protocol conformance descriptor for FlattenSequence<A>, v16, v17);
  uint64_t v20 = type metadata accessor for LazySequence(0LL, v16, v18, v19);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v22 = *((void *)v6 - 1);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v25 = (uint64_t *)((char *)&v182 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v30 = (uint64_t *)((char *)&v182 - v29);
  unint64_t v31 = *v5;
  unint64_t v32 = v5[1];
  unint64_t v190 = (uint64_t *)v5;
  if ((v31 & ~v32 & 0x2000000000000000LL) != 0)
  {
    uint64_t v182 = v28;
    uint64_t v183 = v27;
    uint64_t v184 = v26;
    if (swift_isUniquelyReferenced_nonNull_native(v32 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v33 = *(void (**)(uint64_t *, uint64_t, char *))(v22 + 16);
      uint64_t v34 = v189;
      v33(v30, v189, v6);
      if (swift_dynamicCast( (char *)&v196,  v30,  (swift *)v6,  (const char *)&type metadata for String.UnicodeScalarView,  6uLL))
      {
        unint64_t v35 = v197;
        unint64_t v36 = v190;
        if ((v197 & 0x1000000000000000LL) == 0)
        {
          if ((v197 & 0x2000000000000000LL) == 0)
          {
            if ((v196 & 0x1000000000000000LL) != 0)
            {
              unint64_t v6 = (char *)((v197 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v16 = v196 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              unint64_t v6 = (char *)_StringObject.sharedUTF8.getter(v196, v197);
              uint64_t v16 = v180;
            }

            uint64_t v37 = v188 >> 16;
            uint64_t v10 = v187 >> 16;
            unint64_t v38 = v36[1];
            if ((v38 & 0x2000000000000000LL) != 0) {
              uint64_t v39 = HIBYTE(v38) & 0xF;
            }
            else {
              uint64_t v39 = *v36 & 0xFFFFFFFFFFFFLL;
            }
            int64_t v40 = v39 - v10 + v16 + (v188 >> 16);
            if (v40 < 16) {
              goto LABEL_109;
            }
            uint64_t v41 = _StringGuts.uniqueNativeCapacity.getter();
            if ((v42 & 1) == 0 && v41 >= v40) {
              goto LABEL_109;
            }
            uint64_t v43 = _StringGuts.uniqueNativeCapacity.getter();
            if ((v44 & 1) != 0)
            {
              unint64_t v131 = v36[1];
              if ((v131 & 0x1000000000000000LL) != 0)
              {
                Swift::Int v45 = String.UTF8View._foreignCount()();
              }

              else if ((v131 & 0x2000000000000000LL) != 0)
              {
                Swift::Int v45 = HIBYTE(v131) & 0xF;
              }

              else
              {
                Swift::Int v45 = *v36 & 0xFFFFFFFFFFFFLL;
              }
            }

            else
            {
              Swift::Int v45 = 2 * v43;
            }

            if (v45 > v40) {
              int64_t v40 = v45;
            }
            unint64_t v133 = v36[1];
            if ((v133 & 0x1000000000000000LL) == 0)
            {
              uint64_t v134 = *v36;
              if ((v133 & 0x2000000000000000LL) == 0)
              {
                if ((v134 & 0x1000000000000000LL) != 0)
                {
LABEL_73:
                  Swift::Int v135 = (char *)((v133 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  size_t v136 = v134 & 0xFFFFFFFFFFFFLL;
LABEL_74:
                  int64_t v137 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v135,  v136,  v40,  v134 < 0);
LABEL_108:
                  uint64_t v159 = *(void *)(v137 + 24);
                  swift_bridgeObjectRelease(v36[1]);
                  *unint64_t v36 = v159;
                  v36[1] = v137;
LABEL_109:
                  uint64_t v160 = v36[1];
                  __StringStorage.replace(from:to:with:)(v37, v10, v6, v16);
                  *unint64_t v36 = *(void *)(v160 + 24);
                  swift_bridgeObjectRelease(v35);
                  return v37;
                }

LABEL_134:
            __break(1u);
            goto LABEL_135;
          }

uint64_t String.UnicodeScalarView.init()()
{
  return 0LL;
}

void __StringStorage.replace(from:to:with:)(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t v8 = (char *)(v4 + 32 + a1);
  size_t v9 = (*(void *)(v4 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v4 + 32 + a2),  v9,  &v8[a4],  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( a3,  a4,  v8,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  if ((*(void *)(v4 + 24) & 0x8000000000000000LL) == 0)
  {
    BOOL v10 = 0;
    size_t v11 = a1 + a4;
    if (!__OFADD__(a1, a4)) {
      goto LABEL_3;
    }
LABEL_7:
    __break(1u);
    goto LABEL_8;
  }

  BOOL v10 = _allASCII(_:)((uint64_t *)a3, a4);
  size_t v11 = a1 + a4;
  if (__OFADD__(a1, a4)) {
    goto LABEL_7;
  }
LABEL_3:
  BOOL v12 = __OFADD__(v11, v9);
  Swift::Int v13 = v11 + v9;
  if (!v12)
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v13, v10);
    return;
  }

void specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v8 = v7;
  Swift::Int v13 = (_BYTE *)(v8 + 32 + a1);
  size_t v14 = (*(void *)(v8 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v8 + 32 + a2),  v14,  &v13[a7],  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  uint64_t v15 = *(void *)(v8 + 24);
  uint64_t v35 = a4;
  uint64_t v36 = (uint64_t)a6;
  swift_bridgeObjectRetain(a4, v16, v17, v18);
  swift_retain(a6, v19, v20, v21);
  unint64_t v22 = specialized LazyMapSequence.Iterator.next()();
  if ((v22 & 0x100000000LL) == 0)
  {
    unsigned int v23 = v22;
    char v24 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v22, 0LL);
    unint64_t v25 = 1LL;
    LOBYTE(v27) = v24 >= 0 && v15 < 0;
    _BYTE *v13 = v24;
    uint64_t v28 = 1LL;
    while (v23 > 0x7F)
    {
      if (v23 >= 0x800)
      {
        if (v23 >= 0x10000)
        {
          if (v25 == 4) {
            goto LABEL_27;
          }
        }

        else if (v25 == 3)
        {
          goto LABEL_27;
        }

        if ((v25 & 0x8000000000000000LL) != 0) {
          goto LABEL_37;
        }
        if (v23 >= 0x10000)
        {
          if (v25 >= 4) {
LABEL_37:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unicode.Scalar.UTF8View index is out of bounds",  46LL,  2,  "Swift/UnicodeScalar.swift",  25LL,  2,  0x1E9uLL,  0);
          uint64_t v31 = 4LL;
        }

        else
        {
          if (v25 >= 3) {
            goto LABEL_37;
          }
          uint64_t v31 = 3LL;
        }

        unint64_t v34 = v31;
        char v29 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v23, v25);
        if (v25 >= v34) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
        }
LABEL_13:
        ++v25;
        LOBYTE(v27) = (v29 >= 0) & v27;
        v13[v28] = v29;
        if (__OFADD__(v28++, 1LL)) {
          goto LABEL_40;
        }
      }

      else
      {
        if (v25 != 2)
        {
          if (v25 >= 2) {
            goto LABEL_37;
          }
          goto LABEL_12;
        }

{
  uint64_t v7;
  uint64_t v8;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v24;
  uint64_t v8 = v7;
  Swift::Int v13 = (*(void *)(v8 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v8 + 32 + a2),  v13,  (char *)(v8 + 32 + a1 + a7),  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  size_t v14 = *(void *)(v8 + 24) >> 63;
  swift_bridgeObjectRetain(a4, v15, v16, v17);
  swift_retain(a6, v18, v19, v20);
  uint64_t v21 = 0LL;
  while (1)
  {
    unint64_t v22 = specialized FlattenSequence.Iterator.next()();
    if ((v22 & 0x100) != 0) {
      break;
    }
    LOBYTE(v14) = ((v22 & 0x80u) == 0) & v14;
    *(_BYTE *)(v8 + a1 + v21 + 32) = v22;
    if (__OFADD__(v21++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  swift_release((uint64_t)a6);
  swift_bridgeObjectRelease(a4);
  swift_bridgeObjectRelease(0LL);
  char v24 = a1 + a7;
  if (__OFADD__(a1, a7))
  {
    __break(1u);
  }

  else if (!__OFADD__(v24, v13))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v24 + v13, v14 & 1);
    return;
  }

  __break(1u);
}

{
  uint64_t v7;
  uint64_t v8;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v24;
  uint64_t v8 = v7;
  Swift::Int v13 = (*(void *)(v8 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v8 + 32 + a2),  v13,  (char *)(v8 + 32 + a1 + a7),  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  size_t v14 = *(void *)(v8 + 24) >> 63;
  swift_bridgeObjectRetain(a4, v15, v16, v17);
  swift_retain(a6, v18, v19, v20);
  uint64_t v21 = 0LL;
  while (1)
  {
    unint64_t v22 = specialized FlattenSequence.Iterator.next()();
    if ((v22 & 0x100) != 0) {
      break;
    }
    LOBYTE(v14) = ((v22 & 0x80u) == 0) & v14;
    *(_BYTE *)(v8 + a1 + v21 + 32) = v22;
    if (__OFADD__(v21++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  swift_bridgeObjectRelease(a4);
  swift_release((uint64_t)a6);
  swift_bridgeObjectRelease(0LL);
  char v24 = a1 + a7;
  if (__OFADD__(a1, a7))
  {
    __break(1u);
  }

  else if (!__OFADD__(v24, v13))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v24 + v13, v14 & 1);
    return;
  }

  __break(1u);
}

void specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  size_t v9 = (*(void *)(v5 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v5 + 32 + a2),  v9,  (char *)(v5 + 32 + a1 + a4),  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  uint64_t v10 = *(void *)(v5 + 24) >> 63;
  size_t v11 = *(unint64_t **)(a3 + 40);
  unint64_t v22 = *(void *)(a3 + 24);
  uint64_t v23 = (uint64_t)v11;
  swift_bridgeObjectRetain(v22, v12, v13, v14);
  swift_retain(v11, v15, v16, v17);
  uint64_t v18 = 0LL;
  while (1)
  {
    __int16 v19 = specialized FlattenSequence.Iterator.next()();
    if ((v19 & 0x100) != 0) {
      break;
    }
    LOBYTE(v1__StringStorage._updateCountAndFlags(newCount:newIsASCII:)( from - to + (*(void *)(v2 + 24) & 0xFFFFFFFFFFFFLL),  *(uint64_t *)(v2 + 24) < 0) = ((v19 & 0x80u) == 0) & v10;
    *(_BYTE *)(v5 + a1 + v18 + 32) = v19;
    if (__OFADD__(v18++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  swift_release(v23);
  swift_bridgeObjectRelease(v22);
  swift_bridgeObjectRelease(0LL);
  uint64_t v21 = a1 + a4;
  if (__OFADD__(a1, a4))
  {
    __break(1u);
  }

  else if (!__OFADD__(v21, v9))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v21 + v9, v10 & 1);
    return;
  }

  __break(1u);
}

void specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  uint64_t v7 = v6;
  size_t v12 = (*(void *)(v7 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v7 + 32 + a2),  v12,  (char *)(v7 + 32 + a1 + a6),  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  uint64_t v13 = *(void *)(v7 + 24) >> 63;
  swift_bridgeObjectRetain(a3, v14, v15, v16);
  uint64_t v20 = (uint64_t)swift_retain(a5, v17, v18, v19);
  uint64_t v24 = 0LL;
  while (1)
  {
    uint64_t v20 = specialized FlattenSequence.Iterator.next()(v20, v21, v22, v23);
    if ((v20 & 0x100) != 0) {
      break;
    }
    LOBYTE(v13) = ((v20 & 0x80u) == 0LL) & v13;
    *(_BYTE *)(v7 + a1 + v24 + 32) = v20;
    if (__OFADD__(v24++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  swift_bridgeObjectRelease(a3);
  swift_release((uint64_t)a5);
  swift_bridgeObjectRelease(0LL);
  uint64_t v26 = a1 + a6;
  if (__OFADD__(a1, a6))
  {
    __break(1u);
  }

  else if (!__OFADD__(v26, v12))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v26 + v12, v13 & 1);
    return;
  }

  __break(1u);
}

void specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v8 = (*(void *)(v5 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v5 + 32 + a2),  v8,  (char *)(v5 + 32 + a1 + a5),  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  uint64_t v9 = a1 + a5;
  if (__OFADD__(a1, a5))
  {
    __break(1u);
  }

  else if (!__OFADD__(v9, v8))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v9 + v8, *(uint64_t *)(v5 + 24) < 0);
    return;
  }

  __break(1u);
}

void specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( uint64_t a1, uint64_t a2, int a3, void (*a4)(uint64_t *__return_ptr, char *), unint64_t *a5, uint64_t a6)
{
  uint64_t v7 = v6;
  size_t v12 = (_BYTE *)(v7 + 32 + a1);
  size_t v27 = (*(void *)(v7 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v7 + 32 + a2),  v27,  &v12[a6],  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  uint64_t v13 = *(void *)(v7 + 24);
  swift_retain(a5, v14, v15, v16);
  HIDWORD(v29) = a3;
  a4(&v29, (char *)&v29 + 4);
  unsigned int v17 = v29;
  char v18 = Unicode.Scalar.UTF8View.subscript.getter(0LL, v29);
  unint64_t v19 = specialized RandomAccessCollection<>.index(after:)(0LL, v17);
  char v21 = v18 >= 0 && v13 < 0;
  *size_t v12 = v18;
  uint64_t v22 = v7 + a1;
  uint64_t v23 = 33LL;
  while (1)
  {
    if (v17 < 0x80)
    {
      if (v19 == 1) {
        break;
      }
      goto LABEL_8;
    }

    if (v17 < 0x800)
    {
      if (v19 == 2) {
        break;
      }
      goto LABEL_8;
    }

    if (v17 < 0x10000)
    {
      if (v19 == 3) {
        break;
      }
      goto LABEL_8;
    }

    if (v19 == 4) {
      break;
    }
LABEL_8:
    uint64_t v24 = v23 - 32;
    char v25 = Unicode.Scalar.UTF8View.subscript.getter(v19, v17);
    unint64_t v19 = specialized RandomAccessCollection<>.index(after:)(v19, v17);
    v21 &= v25 >= 0;
    *(_BYTE *)(v22 + v23++) = v25;
    if (__OFADD__(v24, 1LL))
    {
      __break(1u);
      goto LABEL_23;
    }
  }

  swift_release((uint64_t)a5);
  uint64_t v26 = a1 + a6;
  if (__OFADD__(a1, a6))
  {
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }

  if (!__OFADD__(v26, v27))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v26 + v27, v21 & 1);
    return;
  }

void specialized __StringStorage.replace<A>(from:to:with:replacementCount:)( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  size_t v9 = (*(void *)(v5 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v5 + 32 + a2),  v9,  (char *)(v5 + 32 + a1 + a5),  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  uint64_t v10 = *(void *)(v5 + 24) >> 63;
  swift_retain(a4, v11, v12, v13);
  uint64_t v14 = 0LL;
  while (1)
  {
    __int16 v15 = specialized FlattenSequence.Iterator.next()();
    if ((v15 & 0x100) != 0) {
      break;
    }
    LOBYTE(v1__StringStorage._updateCountAndFlags(newCount:newIsASCII:)( from - to + (*(void *)(v2 + 24) & 0xFFFFFFFFFFFFLL),  *(uint64_t *)(v2 + 24) < 0) = ((v15 & 0x80u) == 0) & v10;
    *(_BYTE *)(v5 + a1 + v14 + 32) = v15;
    if (__OFADD__(v14++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  swift_release((uint64_t)a4);
  swift_bridgeObjectRelease(0LL);
  uint64_t v17 = a1 + a5;
  if (__OFADD__(a1, a5))
  {
    __break(1u);
  }

  else if (!__OFADD__(v17, v9))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v17 + v9, v10 & 1);
    return;
  }

  __break(1u);
}

void __StringStorage.replace<A>(from:to:with:replacementCount:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v22)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v6 = v5;
  uint64_t v29 = a3;
  uint64_t v11 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v25 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = *(void *)(v14 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  size_t v27 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v18 = (char *)&v25 - v17;
  uint64_t v28 = a4;
  uint64_t v26 = (*(void *)(v6 + 24) & 0xFFFFFFFFFFFFLL) - a2;
  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v6 + 32 + a2),  v26,  (char *)(v6 + 32 + a1 + a4),  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
  uint64_t v19 = *(void *)(v6 + 24) >> 63;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, v29, a5);
  (*(void (**)(uint64_t, uint64_t))(v15 + 32))(a5, v15);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v15,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v21 = 0LL;
  uint64_t v22 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  uint64_t v29 = a1;
  while (1)
  {
    v22(&v30, AssociatedTypeWitness, AssociatedConformanceWitness);
    if ((v30 & 0x100) != 0) {
      break;
    }
    LOBYTE(v19) = ((v30 & 0x80u) == 0LL) & v19;
    *(_BYTE *)(v6 + a1 + v21 + 32) = v30;
    if (__OFADD__(v21++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  (*(void (**)(char *, unint64_t))(v27 + 8))(v18, AssociatedTypeWitness);
  uint64_t v24 = v29 + v28;
  if (__OFADD__(v29, v28))
  {
    __break(1u);
  }

  else if (!__OFADD__(v24, v26))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v24 + v26, v19 & 1);
    return;
  }

  __break(1u);
}

uint64_t _StringGuts.mutateSubrangeInSubstring(subrange:startIndex:endIndex:with:)( Swift::UInt64 a1, Swift::UInt64 a2, uint64_t *a3, Swift::UInt64 *a4, uint64_t (*a5)(uint64_t *))
{
  uint64_t v7 = v5;
  size_t v8 = a5;
  unint64_t v13 = v5[1];
  if ((v13 & 0x1000000000000000LL) != 0)
  {
    uint64_t v6 = *v5;
    if ((*v5 & 0x800000000000000LL) == 0)
    {
LABEL_36:
      v30._Swift::UInt64 rawBits = *a3;
      Swift::UInt64 v31 = *a3;
      uint64_t v54 = *a3 & 0xC;
      if (v54 == 4) {
        goto LABEL_76;
      }
      while (1)
      {
        unint64_t v32 = HIBYTE(v13) & 0xF;
        if ((v13 & 0x2000000000000000LL) == 0) {
          unint64_t v32 = v6 & 0xFFFFFFFFFFFFLL;
        }
        Swift::UInt64 v55 = v32;
        if (v32 < v31 >> 16) {
LABEL_80:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
        Swift::Int startingAt = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)v31);
        Swift::UInt64 rawBits = *a4;
        if (v54 == 4)
        {
          v34._Swift::UInt64 rawBits = v30._rawBits;
          Swift::UInt64 v35 = *a4;
          v36._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v34)._rawBits;
          Swift::UInt64 rawBits = v35;
          v30._Swift::UInt64 rawBits = v36._rawBits;
        }

        Swift::UInt64 v37 = v55;
        if ((rawBits & 0xC) == 4)
        {
          v51._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          Swift::UInt64 v37 = v55;
          Swift::UInt64 rawBits = v51._rawBits;
          if (v55 < v30._rawBits >> 16) {
            goto LABEL_80;
          }
        }

        else if (v55 < v30._rawBits >> 16)
        {
          goto LABEL_80;
        }

        if (v37 < rawBits >> 16) {
          goto LABEL_80;
        }
        v30._Swift::UInt64 rawBits = String.UTF8View._foreignDistance(from:to:)(v30, (Swift::String::Index)rawBits);
        if ((a1 & 0xC) == 4) {
          a1 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)a1)._rawBits;
        }
        Swift::UInt64 v38 = v55;
        if ((a2 & 0xC) == 4)
        {
          v52._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)a2)._rawBits;
          Swift::UInt64 v38 = v55;
          a2 = v52._rawBits;
          if (v55 < a1 >> 16) {
            goto LABEL_80;
          }
        }

        else if (v55 < a1 >> 16)
        {
          goto LABEL_80;
        }

        if (v38 < a2 >> 16) {
          goto LABEL_80;
        }
        Swift::Int v39 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)a1, (Swift::String::Index)a2);
        uint64_t v40 = v8(v7);
        uint64_t v42 = v41 - v40;
        if (__OFSUB__(v41, v40)) {
          break;
        }
        BOOL v43 = __OFADD__(v30._rawBits, v42);
        Swift::UInt64 v44 = v30._rawBits + v42;
        if (v43) {
          goto LABEL_83;
        }
        size_t v8 = (uint64_t (*)(uint64_t *))(v44 - v39);
        if (__OFSUB__(v44, v39)) {
          goto LABEL_84;
        }
        if (v40 == v41)
        {
          Swift::Int v45 = 0LL;
          Swift::Int v46 = startingAt << 16;
LABEL_70:
          v46 |= v45 << 8;
          goto LABEL_71;
        }

        uint64_t v47 = *v7;
        v30._Swift::UInt64 rawBits = v7[1];
        if ((v30._rawBits & 0x1000000000000000LL) == 0)
        {
          if ((v30._rawBits & 0x2000000000000000LL) != 0)
          {
            uint64_t v56 = *v7;
            uint64_t v57 = v30._rawBits & 0xFFFFFFFFFFFFFFLL;
            if (startingAt + 1 == (HIBYTE(v30._rawBits) & 0xF)) {
              goto LABEL_69;
            }
            int v50 = *(unsigned __int16 *)((char *)&v56 + startingAt);
          }

          else
          {
            if ((v47 & 0x1000000000000000LL) != 0)
            {
              Swift::String::Index v48 = (char *)((v30._rawBits & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v49 = v47 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              Swift::String::Index v48 = (char *)_StringObject.sharedUTF8.getter(*v7, v7[1]);
            }

            if (startingAt + 1 == v49)
            {
LABEL_69:
              Swift::Int v46 = startingAt << 16;
              Swift::Int v45 = 1LL;
              goto LABEL_70;
            }

            if (!v48) {
              goto LABEL_81;
            }
            int v50 = *(unsigned __int16 *)&v48[startingAt];
          }

          if (v50 != 2573 && (v50 & 0x80808080) == 0) {
            goto LABEL_69;
          }
        }

Swift::Int __swiftcall String.UTF8View.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  Swift::UInt64 rawBits = from._rawBits;
  uint64_t v8 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = 4LL << v8;
  if ((from._rawBits & 0xC) == 4LL << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(from)._rawBits;
  }
  if ((to._rawBits & 0xC) == v9)
  {
    to._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
    if ((v4 & 0x1000000000000000LL) == 0) {
      return (to._rawBits >> 16) - (rawBits >> 16);
    }
  }

  else if ((v4 & 0x1000000000000000LL) == 0)
  {
    return (to._rawBits >> 16) - (rawBits >> 16);
  }

  unint64_t v11 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    unint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < rawBits >> 16 || v11 < to._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }
  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, to);
}

Swift::String::Index __swiftcall String.Index.init(encodedOffset:transcodedOffset:characterStride:)( Swift::Int encodedOffset, Swift::Int transcodedOffset, Swift::Int characterStride)
{
  Swift::Int v3 = characterStride << 8;
  return (Swift::String::Index)((transcodedOffset << 14) | (encodedOffset << 16) | v3);
}

Swift::String::Index __swiftcall String.Index.init(encodedOffset:transcodedOffset:)( Swift::Int encodedOffset, Swift::Int transcodedOffset)
{
  return (Swift::String::Index)((transcodedOffset << 14) | (encodedOffset << 16));
}

uint64_t _StringObject.CountAndFlags._storage.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*_StringObject.CountAndFlags._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _StringObject.CountAndFlags.init(zero:)()
{
  return 0LL;
}

uint64_t _StringObject._countAndFlagsBits.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*_StringObject._countAndFlagsBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t _StringObject._object.getter(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  return swift_bridgeObjectRetain(a2, a2, a3, a4);
}

void _StringObject._object.setter(uint64_t a1)
{
  *(void *)(v1 + 8) = a1;
}

uint64_t (*_StringObject._object.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _StringObject.discriminatedObjectRawBits.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _StringObject.init(bridgeObject:countAndFlags:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _StringObject.init(object:discriminator:countAndFlags:)( unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a3;
}

uint64_t _StringObject.init(pointerBits:discriminator:countAndFlags:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

unint64_t static _StringObject.Nibbles.emptyString.getter()
{
  return 0xE000000000000000LL;
}

unint64_t static _StringObject.Nibbles.small(isASCII:)(char a1)
{
  if ((a1 & 1) != 0) {
    return 0xE000000000000000LL;
  }
  else {
    return 0xA000000000000000LL;
  }
}

uint64_t static _StringObject.Nibbles.largeAddressMask.getter()
{
  return 0xFFFFFFFFFFFFFFFLL;
}

unint64_t static _StringObject.Nibbles.discriminatorMask.getter()
{
  return 0xF000000000000000LL;
}

unint64_t static _StringObject.Nibbles.largeImmortal()()
{
  return 0x8000000000000000LL;
}

uint64_t static _StringObject.Nibbles.largeMortal()()
{
  return 0LL;
}

uint64_t static _StringObject.nativeBias.getter()
{
  return 32LL;
}

BOOL _StringObject.isLarge.getter(uint64_t a1, uint64_t a2)
{
  return (a2 & 0x2000000000000000LL) == 0;
}

uint64_t _StringObject.largeFastIsTailAllocated.getter(unint64_t a1)
{
  return (a1 >> 60) & 1;
}

uint64_t _StringObject.CountAndFlags.isTailAllocated.getter(unint64_t a1)
{
  return (a1 >> 60) & 1;
}

uint64_t _StringObject.smallCount.getter(uint64_t a1, unint64_t a2)
{
  return HIBYTE(a2) & 0xF;
}

uint64_t static _StringObject.CountAndFlags.countMask.getter()
{
  return 0xFFFFFFFFFFFFLL;
}

unint64_t static _StringObject.CountAndFlags.flagsMask.getter()
{
  return 0xFFFF000000000000LL;
}

unint64_t static _StringObject.CountAndFlags.isASCIIMask.getter()
{
  return 0x8000000000000000LL;
}

uint64_t static _StringObject.CountAndFlags.isNFCMask.getter()
{
  return 0x4000000000000000LL;
}

uint64_t static _StringObject.CountAndFlags.isNativelyStoredMask.getter()
{
  return 0x2000000000000000LL;
}

uint64_t static _StringObject.CountAndFlags.isTailAllocatedMask.getter()
{
  return 0x1000000000000000LL;
}

BOOL static UInt64.<= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 >= a1;
}

uint64_t _StringObject.CountAndFlags.count.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFFLL;
}

uint64_t _StringObject.CountAndFlags.isNFC.getter(unint64_t a1)
{
  return (a1 >> 62) & 1;
}

uint64_t _StringObject.CountAndFlags.isNativelyStored.getter(unint64_t a1)
{
  return (a1 >> 61) & 1;
}

Swift::_StringObject::CountAndFlags __swiftcall _StringObject.CountAndFlags.init(count:flags:)( Swift::Int count, Swift::UInt16 flags)
{
  return (Swift::_StringObject::CountAndFlags)(count | (flags << 48));
}

unint64_t _StringObject.CountAndFlags.flags.getter(unint64_t a1)
{
  return HIWORD(a1);
}

Swift::_StringObject::CountAndFlags __swiftcall _StringObject.CountAndFlags.init(immortalCount:isASCII:)( Swift::Int immortalCount, Swift::Bool isASCII)
{
  unint64_t v2 = immortalCount | 0xC000000000000000LL;
  if (!isASCII) {
    unint64_t v2 = immortalCount;
  }
  return (Swift::_StringObject::CountAndFlags)(v2 | 0x1000000000000000LL);
}

uint64_t _StringObject.largeCount.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFFLL;
}

uint64_t _StringObject.nativeUTF8Start.getter(uint64_t a1, uint64_t a2)
{
  return (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
}

uint64_t _StringObject.nativeUTF8.getter(uint64_t a1, uint64_t a2)
{
  return (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
}

id _StringObject.getSharedUTF8Start()(uint64_t a1, uint64_t a2)
{
  if ((a2 & 0x4000000000000000LL) != 0) {
    return objc_msgSend((id)(a2 & 0xFFFFFFFFFFFFFFFLL), sel__fastCStringContents_, 1);
  }
  else {
    return *(id *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 0x18);
  }
}

id _StringObject.sharedUTF8.getter(uint64_t a1, uint64_t a2)
{
  return _StringObject.getSharedUTF8Start()(a1, a2);
}

uint64_t Unmanaged._withUnsafeGuaranteedRef<A>(_:)(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a3);
}

uint64_t specialized StringProtocol.hasPrefix<A>(_:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  return specialized Sequence<>.starts<A>(with:)(a1, a2, a3, *(void *)(*(void *)(*(void *)(a4 + 8) + 8LL) + 8LL));
}

uint64_t StringProtocol.hasPrefix<A>(_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return Sequence<>.starts<A>(with:)( a1,  a2,  a3,  *(const char **)(*(void *)(*(void *)(a4 + 8) + 8LL) + 8LL),  *(const char **)(*(void *)(*(void *)(a5 + 8) + 8LL) + 8LL),  (uint64_t)&protocol witness table for Character);
}

uint64_t specialized StringProtocol.hasSuffix<A>(_:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v8 = type metadata accessor for ReversedCollection(0LL, a3, *(void *)(a4 + 8), a4);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  unint64_t v11 = (char *)&v15 - v10;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))((char *)&v15 - v10, v4, v5);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, v8, v12);
  LOBYTE(v5) = specialized Sequence<>.starts<A>(with:)(a1, a2, v8, WitnessTable);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
  return v5 & 1;
}

uint64_t StringProtocol.hasSuffix<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = type metadata accessor for ReversedCollection(0LL, a3, *(void *)(a5 + 8), a4);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v10);
  unint64_t v13 = (char *)&v25 - v12;
  uint64_t v15 = type metadata accessor for ReversedCollection(0LL, a2, *(void *)(a4 + 8), v14);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  unint64_t v18 = (char *)&v25 - v17;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))((char *)&v25 - v17, v5, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(v13, a1, a3);
  uint64_t WitnessTable = (const char *)swift_getWitnessTable( &protocol conformance descriptor for ReversedCollection<A>,  v15,  v19);
  uint64_t v22 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, v10, v21);
  char v23 = Sequence<>.starts<A>(with:)(v13, v15, v10, WitnessTable, v22, (uint64_t)&protocol witness table for Character);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v10);
  (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v15);
  return v23 & 1;
}

Swift::Void __swiftcall Substring._slowMakeContiguousUTF8()()
{
  uint64_t v5 = v3[2];
  unint64_t v4 = v3[3];
  v6._Swift::UInt64 rawBits = *v3;
  swift_bridgeObjectRetain(v4, v0, v1, v2);
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)15LL)._rawBits;
  v8._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v6)._rawBits >> 14;
  if (v7._rawBits >> 14 < v8._rawBits)
  {
    uint64_t v9 = 0LL;
    while (1)
    {
      uint64_t v10 = v9 + 1;
      if (__OFADD__(v9, 1LL)) {
        break;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        v7._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v7)._rawBits;
      }

      else
      {
        Swift::UInt64 v11 = v7._rawBits >> 16;
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v5;
          uint64_t v99 = v4 & 0xFFFFFFFFFFFFFFLL;
          int v13 = *((unsigned __int8 *)&v98 + v11);
        }

        else
        {
          uint64_t v12 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            uint64_t v12 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int v13 = v12[v11];
        }

        int v14 = (char)v13;
        unsigned int v15 = __clz(v13 ^ 0xFF) - 24;
        if (v14 >= 0) {
          LOBYTE(v15) = 1;
        }
        v7._Swift::UInt64 rawBits = ((v11 + v15) << 16) | 5;
      }

      ++v9;
      if (v8._rawBits <= v7._rawBits >> 14) {
        goto LABEL_34;
      }
    }

    __break(1u);
    goto LABEL_151;
  }

  if (v8._rawBits < v7._rawBits >> 14)
  {
    uint64_t v10 = 0LL;
    while (1)
    {
      BOOL v16 = __OFSUB__(v10--, 1LL);
      if (v16) {
        goto LABEL_152;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        v7._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
      }

      else
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v5;
          uint64_t v99 = v4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v98 + (v7._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v21 = 0LL;
            do
              int v22 = *((_BYTE *)&v97 + (v7._rawBits >> 16) + v21-- + 6) & 0xC0;
            while (v22 == 128);
            uint64_t v20 = 1 - v21;
          }

          else
          {
            uint64_t v20 = 1LL;
          }
        }

        else
        {
          uint64_t v17 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            uint64_t v17 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          uint64_t v18 = 0LL;
          do
            int v19 = v17[(v7._rawBits >> 16) - 1 + v18--] & 0xC0;
          while (v19 == 128);
          uint64_t v20 = -v18;
        }

        v7._Swift::UInt64 rawBits = (v7._rawBits - (v20 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (v8._rawBits >= v7._rawBits >> 14) {
        goto LABEL_34;
      }
    }
  }

  uint64_t v10 = 0LL;
LABEL_34:
  swift_bridgeObjectRelease(v4);
  uint64_t v24 = v97[2];
  unint64_t v23 = v97[3];
  v25._Swift::UInt64 rawBits = *v97;
  v26._Swift::UInt64 rawBits = v97[1];
  swift_bridgeObjectRetain(v23, v27, v28, v29);
  v30._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v25)._rawBits;
  v31._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v26)._rawBits >> 14;
  if (v30._rawBits >> 14 < v31._rawBits)
  {
    uint64_t v32 = 0LL;
    while (1)
    {
      uint64_t v33 = v32 + 1;
      if (__OFADD__(v32, 1LL)) {
        break;
      }
      if ((v23 & 0x1000000000000000LL) != 0)
      {
        v30._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v30)._rawBits;
      }

      else
      {
        Swift::UInt64 v34 = v30._rawBits >> 16;
        if ((v23 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v24;
          uint64_t v99 = v23 & 0xFFFFFFFFFFFFFFLL;
          int v36 = *((unsigned __int8 *)&v98 + v34);
        }

        else
        {
          Swift::UInt64 v35 = (unsigned __int8 *)((v23 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v24 & 0x1000000000000000LL) == 0) {
            Swift::UInt64 v35 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v24, v23);
          }
          int v36 = v35[v34];
        }

        int v37 = (char)v36;
        unsigned int v38 = __clz(v36 ^ 0xFF) - 24;
        if (v37 >= 0) {
          LOBYTE(v38) = 1;
        }
        v30._Swift::UInt64 rawBits = ((v34 + v38) << 16) | 5;
      }

      ++v32;
      if (v31._rawBits <= v30._rawBits >> 14) {
        goto LABEL_67;
      }
    }

LABEL_151:
    __break(1u);
LABEL_152:
    __break(1u);
LABEL_153:
    __break(1u);
    goto LABEL_154;
  }

  if (v31._rawBits < v30._rawBits >> 14)
  {
    uint64_t v33 = 0LL;
    while (1)
    {
      BOOL v16 = __OFSUB__(v33--, 1LL);
      if (v16) {
        goto LABEL_153;
      }
      if ((v23 & 0x1000000000000000LL) != 0)
      {
        v30._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v30)._rawBits;
      }

      else
      {
        if ((v23 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v24;
          uint64_t v99 = v23 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v98 + (v30._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v43 = 0LL;
            do
              int v44 = *((_BYTE *)&v97 + (v30._rawBits >> 16) + v43-- + 6) & 0xC0;
            while (v44 == 128);
            uint64_t v42 = 1 - v43;
          }

          else
          {
            uint64_t v42 = 1LL;
          }
        }

        else
        {
          Swift::Int v39 = (char *)((v23 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v24 & 0x1000000000000000LL) == 0) {
            Swift::Int v39 = (char *)_StringObject.sharedUTF8.getter(v24, v23);
          }
          uint64_t v40 = 0LL;
          do
            int v41 = v39[(v30._rawBits >> 16) - 1 + v40--] & 0xC0;
          while (v41 == 128);
          uint64_t v42 = -v40;
        }

        v30._Swift::UInt64 rawBits = (v30._rawBits - (v42 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (v31._rawBits >= v30._rawBits >> 14) {
        goto LABEL_67;
      }
    }
  }

  uint64_t v33 = 0LL;
LABEL_67:
  swift_bridgeObjectRelease(v23);
  unint64_t v45 = v97[2];
  unint64_t v46 = v97[3];
  swift_bridgeObjectRetain(v46, v47, v48, v49);
  uint64_t v50 = specialized static String._copying(_:)(v45, v46);
  unint64_t v52 = v51;
  swift_bridgeObjectRelease(v46);
  swift_bridgeObjectRetain(v52, v53, v54, v55);
  v56._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)15LL)._rawBits;
  if (v10 < 0)
  {
    uint64_t v63 = 0LL;
    unint64_t v64 = (char *)&v97 + 6;
    while (1)
    {
      Swift::UInt64 v65 = v56._rawBits >> 16;
      if (!(v56._rawBits >> 16)) {
        goto LABEL_148;
      }
      if ((v52 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 rawBits = v56._rawBits;
        unint64_t v72 = v64;
        v73._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)((Swift::String::Index)rawBits)._rawBits;
        unint64_t v64 = v72;
        v56._Swift::UInt64 rawBits = v73._rawBits;
      }

      else
      {
        if ((v52 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v50;
          uint64_t v99 = v52 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v98 + v65 - 1) & 0xC0) == 0x80)
          {
            uint64_t v68 = 0LL;
            do
              int v69 = v64[v65 + v68--] & 0xC0;
            while (v69 == 128);
            uint64_t v70 = 1 - v68;
          }

          else
          {
            uint64_t v70 = 1LL;
          }

          v65 -= v70;
        }

        else
        {
          uint64_t v66 = (char *)((v52 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v50 & 0x1000000000000000LL) == 0)
          {
            Swift::UInt64 v74 = v64;
            uint64_t v66 = (char *)_StringObject.sharedUTF8.getter(v50, v52);
            unint64_t v64 = v74;
          }

          do
            int v67 = v66[--v65] & 0xC0;
          while (v67 == 128);
        }

        v56._Swift::UInt64 rawBits = (v65 << 16) | 5;
      }

      if (v10 >= --v63) {
        goto LABEL_103;
      }
    }
  }

  if (v10)
  {
    if ((v52 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v57 = HIBYTE(v52) & 0xF;
    }
    else {
      Swift::UInt64 v57 = v50 & 0xFFFFFFFFFFFFLL;
    }
    while (1)
    {
      Swift::UInt64 v58 = v56._rawBits >> 16;
      if (v56._rawBits >> 16 >= v57) {
        goto LABEL_147;
      }
      if ((v52 & 0x1000000000000000LL) != 0)
      {
        v56._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v56)._rawBits;
        if (!--v10) {
          break;
        }
      }

      else
      {
        if ((v52 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v50;
          uint64_t v99 = v52 & 0xFFFFFFFFFFFFFFLL;
          int v60 = *((unsigned __int8 *)&v98 + v58);
        }

        else
        {
          uint64_t v59 = (unsigned __int8 *)((v52 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v50 & 0x1000000000000000LL) == 0) {
            uint64_t v59 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v50, v52);
          }
          int v60 = v59[v58];
        }

        int v61 = (char)v60;
        unsigned int v62 = __clz(v60 ^ 0xFF) - 24;
        if (v61 >= 0) {
          LOBYTE(v62) = 1;
        }
        v56._Swift::UInt64 rawBits = ((v58 + v62) << 16) | 5;
        if (!--v10) {
          break;
        }
      }
    }
  }

  unint64_t v196 = v274;
  unint64_t v197 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000LL) == 0) {
    unint64_t v197 = v273 & 0xFFFFFFFFFFFFLL;
  }
  if (v197 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
  {
    if ((v274 & 0x2000000000000000LL) == 0
      || (unint64_t v198 = specialized _SmallString.init(_:appending:)(v273, v274, 0x29uLL, 0xE100000000000000LL), (v192 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v191, v192, v193);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      return v273;
    }

    else
    {
      unint64_t v199 = v198;
      swift_bridgeObjectRelease(v196);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v274);
    return 41LL;
  }

  return v199;
}

    unint64_t v233 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_155;
  }

  if ((object & 0x2000000000000000LL) == 0) {
    goto LABEL_151;
  }
LABEL_154:
  unint64_t v233 = HIBYTE(object) & 0xF;
LABEL_155:
  swift_bridgeObjectRetain(object, v76, v77, v78);
  _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v233);
  swift_bridgeObjectRelease_n(object, 2LL);
  uint64_t countAndFlagsBits = v379;
  unint64_t object = v380;
LABEL_156:
  uint64_t v240 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000LL) == 0) {
    uint64_t v240 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v240 || (countAndFlagsBits & ~object & 0x2000000000000000LL) != 0)
  {
    if ((object & 0x2000000000000000LL) == 0
      || (uint64_t v241 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x283EuLL, 0xE200000000000000LL),
          (v238 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v237, v238, v239);
      _StringGuts.append(_:)(10302LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      uint64_t v242 = v241;
      uint64_t v243 = v237;
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      v379 = v242;
      v380 = v243;
    }
  }

  else
  {
    swift_bridgeObjectRelease(object);
    v379 = 10302LL;
    v380 = 0xE200000000000000LL;
  }

  uint64_t v244 = *(const char **)(v369 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v244,  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v244,  (uint64_t)v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v247 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v248 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  size_t v249 = v370;
  v247(0LL, v248, AssociatedConformanceWitness);
  uint64_t v374 = (uint64_t *)v2;
  int64_t v250 = __swift_allocate_boxed_opaque_existential_0Tm(&v373);
  memcpy(v250, v249, v3);
  unint64_t v251 = v374;
  uint64_t v252 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
  DynamicType = (void *)swift_getDynamicType(v252, v251, 1);
  LODWORD(v251) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
  if ((_DWORD)v251)
  {
    uint64_t v254 = v372;
    memcpy(v372, v249, v3);
    Swift::String::Index v255 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v373, v254, v2, v255, 7uLL);
    goto LABEL_166;
  }

  Swift::UInt64 v265 = v365;
  memcpy(v365, v249, v3);
  if ((swift_dynamicCast((char *)&v373, v265, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    Swift::UInt64 v266 = v373._object;
    String.append(_:)(v373);
    swift_bridgeObjectRelease((uint64_t)v266);
    goto LABEL_174;
  }

  unint64_t v317 = v362;
  memcpy(v362, v249, v3);
  unint64_t v318 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v376, v317, v2, v318, 6uLL))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
    uint64_t v319 = (uint64_t)v374;
    unint64_t v320 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v320 + 8))( &v379,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v319,  v320);
LABEL_171:
    __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
    goto LABEL_174;
  }

  v378 = 0LL;
  uint64_t v376 = 0u;
  unint64_t v377 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for TextOutputStreamable?);
  v329 = v359;
  memcpy(v359, v249, v3);
  size_t v330 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v376, v329, v2, v330, 6uLL)
    || (v378 = 0LL,
        uint64_t v376 = 0u,
        unint64_t v377 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for CustomStringConvertible?),  id v331 = v356,  memcpy(v356, v249, v3),  v332 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v376, v331, v2, v332, 6uLL)))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
LABEL_166:
    uint64_t v256 = (uint64_t)v374;
    uint64_t v257 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    uint64_t v259 = (*(uint64_t (**)(uint64_t, uint64_t))(v257 + 8))(v256, v257);
    Swift::String::Index v260 = v258;
    uint64_t v261 = HIBYTE(v380) & 0xF;
    if ((v380 & 0x2000000000000000LL) == 0) {
      uint64_t v261 = v379 & 0xFFFFFFFFFFFFLL;
    }
    if (v261 || (v379 & ~v380 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v259, v258);
      swift_bridgeObjectRelease(v260);
    }

    else
    {
      swift_bridgeObjectRelease(v380);
      v379 = v259;
      v380 = v260;
    }

    goto LABEL_171;
  }

  v378 = 0LL;
  uint64_t v376 = 0u;
  unint64_t v377 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v377 + 1) = v2;
  Swift::Int v341 = __swift_allocate_boxed_opaque_existential_0Tm(&v376);
  memcpy(v341, v249, v3);
  Mirror.init(reflecting:)((uint64_t *)&v376, (uint64_t)&v373);
  Swift::String::Index v342 = v373._object;
  Swift::String::Index v343 = v375;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v249,  &v373,  &v379,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  swift_release(v343);
  swift_release((uint64_t)v342);
LABEL_174:
  uint64_t v267 = v380;
  Swift::String::Index v268 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000LL) == 0) {
    Swift::String::Index v268 = v379 & 0xFFFFFFFFFFFFLL;
  }
  if (v268 || (v379 & ~v380 & 0x2000000000000000LL) != 0)
  {
    if ((v380 & 0x2000000000000000LL) == 0
      || (Swift::String::Index v269 = specialized _SmallString.init(_:appending:)(v379, v380, 0x202CuLL, 0xE200000000000000LL),
          (v263 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v262, v263, v264);
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      unint64_t v270 = v269;
      unint64_t v271 = v262;
      swift_bridgeObjectRelease(v267);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      v379 = v270;
      v380 = v271;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v380);
    v379 = 8236LL;
    v380 = 0xE200000000000000LL;
  }

  unint64_t v272 = v371;
  v247(1LL, v248, AssociatedConformanceWitness);
  uint64_t v374 = (uint64_t *)v2;
  uint64_t v273 = __swift_allocate_boxed_opaque_existential_0Tm(&v373);
  memcpy(v273, v272, v3);
  uint64_t v274 = v374;
  Swift::Int v275 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
  uint64_t v276 = (void *)swift_getDynamicType(v275, v274, 1);
  LODWORD(v274) = swift_isOptionalType(v276);
  __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
  if ((_DWORD)v274)
  {
    uint64_t v277 = v372;
    memcpy(v372, v272, v3);
    uint64_t v278 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v373, v277, v2, v278, 7uLL);
    goto LABEL_184;
  }

  uint64_t v288 = v366;
  memcpy(v366, v272, v3);
  if ((swift_dynamicCast((char *)&v373, v288, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    unint64_t v289 = v373._object;
    String.append(_:)(v373);
    swift_bridgeObjectRelease((uint64_t)v289);
    goto LABEL_192;
  }

  unint64_t v321 = v363;
  memcpy(v363, v272, v3);
  unint64_t v322 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v376, v321, v2, v322, 6uLL))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
    unint64_t v323 = (uint64_t)v374;
    char v324 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v324 + 8))( &v379,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v323,  v324);
LABEL_189:
    __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
    goto LABEL_192;
  }

  v378 = 0LL;
  uint64_t v376 = 0u;
  unint64_t v377 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for TextOutputStreamable?);
  v333 = v360;
  memcpy(v360, v272, v3);
  size_t v334 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v376, v333, v2, v334, 6uLL)
    || (v378 = 0LL,
        uint64_t v376 = 0u,
        unint64_t v377 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for CustomStringConvertible?),  unint64_t v335 = v357,  memcpy(v357, v272, v3),  v336 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v376, v335, v2, v336, 6uLL)))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
LABEL_184:
    size_t v279 = (uint64_t)v374;
    Swift::String::Index v280 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    Swift::String::Index v282 = (*(uint64_t (**)(uint64_t, uint64_t))(v280 + 8))(v279, v280);
    Swift::String::Index v283 = v281;
    Swift::Int v284 = HIBYTE(v380) & 0xF;
    if ((v380 & 0x2000000000000000LL) == 0) {
      Swift::Int v284 = v379 & 0xFFFFFFFFFFFFLL;
    }
    if (v284 || (v379 & ~v380 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v282, v281);
      swift_bridgeObjectRelease(v283);
    }

    else
    {
      swift_bridgeObjectRelease(v380);
      v379 = v282;
      v380 = v283;
    }

    goto LABEL_189;
  }

  v378 = 0LL;
  uint64_t v376 = 0u;
  unint64_t v377 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v377 + 1) = v2;
  Swift::String::Index v344 = __swift_allocate_boxed_opaque_existential_0Tm(&v376);
  memcpy(v344, v272, v3);
  Mirror.init(reflecting:)((uint64_t *)&v376, (uint64_t)&v373);
  Swift::String::Index v345 = v373._object;
  Swift::Int v346 = v375;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v272,  &v373,  &v379,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  swift_release(v346);
  swift_release((uint64_t)v345);
LABEL_192:
  uint64_t v290 = v380;
  uint64_t v291 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000LL) == 0) {
    uint64_t v291 = v379 & 0xFFFFFFFFFFFFLL;
  }
  if (v291 || (v379 & ~v380 & 0x2000000000000000LL) != 0)
  {
    if ((v380 & 0x2000000000000000LL) == 0
      || (unint64_t v292 = specialized _SmallString.init(_:appending:)(v379, v380, 0x202CuLL, 0xE200000000000000LL),
          (v286 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v285, v286, v287);
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      uint64_t v293 = v292;
      uint64_t v294 = v285;
      swift_bridgeObjectRelease(v290);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      v379 = v293;
      v380 = v294;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v380);
    v379 = 8236LL;
    v380 = 0xE200000000000000LL;
  }

  v247(2LL, v248, AssociatedConformanceWitness);
  uint64_t v374 = (uint64_t *)v2;
  unint64_t v295 = __swift_allocate_boxed_opaque_existential_0Tm(&v373);
  memcpy(v295, v13, v3);
  uint64_t v296 = v374;
  uint64_t v297 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
  unint64_t v298 = (void *)swift_getDynamicType(v297, v296, 1);
  LODWORD(v296) = swift_isOptionalType(v298);
  __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
  if ((_DWORD)v296)
  {
    unint64_t v299 = v372;
    memcpy(v372, v13, v3);
    unint64_t v300 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v373, v299, v2, v300, 7uLL);
    goto LABEL_202;
  }

  unint64_t v310 = v367;
  memcpy(v367, v13, v3);
  if ((swift_dynamicCast((char *)&v373, v310, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    unint64_t v311 = v373._object;
    String.append(_:)(v373);
    swift_bridgeObjectRelease((uint64_t)v311);
    goto LABEL_210;
  }

  uint64_t v325 = v364;
  memcpy(v364, v13, v3);
  unint64_t v326 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v376, v325, v2, v326, 6uLL))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
    unint64_t v327 = (uint64_t)v374;
    unint64_t v328 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v328 + 8))( &v379,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v327,  v328);
LABEL_207:
    __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
    goto LABEL_210;
  }

  v378 = 0LL;
  uint64_t v376 = 0u;
  unint64_t v377 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for TextOutputStreamable?);
  Swift::String::Index v337 = v361;
  memcpy(v361, v13, v3);
  Swift::String::Index v338 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v376, v337, v2, v338, 6uLL)
    || (v378 = 0LL,
        uint64_t v376 = 0u,
        unint64_t v377 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for CustomStringConvertible?),  Swift::String::Index v339 = v358,  memcpy(v358, v13, v3),  v340 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v376, v339, v2, v340, 6uLL)))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
LABEL_202:
    unint64_t v301 = (uint64_t)v374;
    unint64_t v302 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    unint64_t v304 = (*(uint64_t (**)(uint64_t, uint64_t))(v302 + 8))(v301, v302);
    unint64_t v305 = v303;
    char v306 = HIBYTE(v380) & 0xF;
    if ((v380 & 0x2000000000000000LL) == 0) {
      char v306 = v379 & 0xFFFFFFFFFFFFLL;
    }
    if (v306 || (v379 & ~v380 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v304, v303);
      swift_bridgeObjectRelease(v305);
    }

    else
    {
      swift_bridgeObjectRelease(v380);
      v379 = v304;
      v380 = v305;
    }

    goto LABEL_207;
  }

  v378 = 0LL;
  uint64_t v376 = 0u;
  unint64_t v377 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v376,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v377 + 1) = v2;
  uint64_t v347 = __swift_allocate_boxed_opaque_existential_0Tm(&v376);
  memcpy(v347, v13, v3);
  Mirror.init(reflecting:)((uint64_t *)&v376, (uint64_t)&v373);
  uint64_t v348 = v373._object;
  Swift::String::Index v349 = v375;
  ((void (*)(char *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v13,  &v373,  &v379,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  swift_release(v349);
  swift_release((uint64_t)v348);
LABEL_210:
  unint64_t v312 = v380;
  unint64_t v313 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000LL) == 0) {
    unint64_t v313 = v379 & 0xFFFFFFFFFFFFLL;
  }
  if (v313 || (v379 & ~v380 & 0x2000000000000000LL) != 0)
  {
    if ((v380 & 0x2000000000000000LL) == 0
      || (char v314 = specialized _SmallString.init(_:appending:)(v379, v380, 0x29uLL, 0xE100000000000000LL), (v308 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v307, v308, v309);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      return v379;
    }

    else
    {
      uint64_t v315 = v314;
      swift_bridgeObjectRelease(v312);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v380);
    return 41LL;
  }

  return v315;
}

LABEL_148:
    unint64_t v96 = 206LL;
LABEL_149:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  v96,  0);
  }

  if (v33)
  {
    if ((v52 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v76 = HIBYTE(v52) & 0xF;
    }
    else {
      Swift::UInt64 v76 = v50 & 0xFFFFFFFFFFFFLL;
    }
    while (1)
    {
      Swift::UInt64 v77 = v75._rawBits >> 16;
      if (v75._rawBits >> 16 >= v76) {
        break;
      }
      if ((v52 & 0x1000000000000000LL) != 0)
      {
        v75._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v75)._rawBits;
        if (!--v33) {
          goto LABEL_139;
        }
      }

      else
      {
        if ((v52 & 0x2000000000000000LL) != 0)
        {
          uint64_t v98 = v50;
          uint64_t v99 = v52 & 0xFFFFFFFFFFFFFFLL;
          int v79 = *((unsigned __int8 *)&v98 + v77);
        }

        else
        {
          unint64_t v78 = (unsigned __int8 *)((v52 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v50 & 0x1000000000000000LL) == 0) {
            unint64_t v78 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v50, v52);
          }
          int v79 = v78[v77];
        }

        int v80 = (char)v79;
        unsigned int v81 = __clz(v79 ^ 0xFF) - 24;
        if (v80 >= 0) {
          LOBYTE(v81) = 1;
        }
        v75._Swift::UInt64 rawBits = ((v77 + v81) << 16) | 5;
        if (!--v33) {
          goto LABEL_139;
        }
      }
    }

Swift::Int __swiftcall String.UnicodeScalarView.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(from)._rawBits;
  Swift::Int result = _StringGuts.validateInclusiveScalarIndex(_:)(to)._rawBits;
  Swift::UInt64 v9 = (unint64_t)result >> 14;
  if (v7._rawBits >> 14 < (unint64_t)result >> 14)
  {
    for (uint64_t i = 0LL; ; ++i)
    {
      Swift::Int v11 = i + 1;
      if (__OFADD__(i, 1LL)) {
        break;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        Swift::Int result = String.UnicodeScalarView._foreignIndex(after:)(v7)._rawBits;
        v7._Swift::UInt64 rawBits = result;
      }

      else
      {
        Swift::UInt64 v12 = v7._rawBits >> 16;
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = v5;
          uint64_t v23 = v4 & 0xFFFFFFFFFFFFFFLL;
          int v13 = *((unsigned __int8 *)&v22 + v12);
        }

        else
        {
          Swift::Int result = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((v5 & 0x1000000000000000LL) == 0) {
            Swift::Int result = (Swift::Int)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int v13 = *(unsigned __int8 *)(result + v12);
        }

        int v14 = (char)v13;
        unsigned int v15 = __clz(v13 ^ 0xFF) - 24;
        if (v14 >= 0) {
          LOBYTE(v15) = 1;
        }
        v7._Swift::UInt64 rawBits = ((v12 + v15) << 16) | 5;
      }

      if (v9 <= v7._rawBits >> 14) {
        return v11;
      }
    }

    __break(1u);
LABEL_36:
    __break(1u);
    return result;
  }

  if (v9 < v7._rawBits >> 14)
  {
    Swift::Int v11 = 0LL;
    while (!__OFSUB__(v11--, 1LL))
    {
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        Swift::Int result = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
        v7._Swift::UInt64 rawBits = result;
      }

      else
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = v5;
          uint64_t v23 = v4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v22 + (v7._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v20 = 0LL;
            do
              int v21 = *((_BYTE *)&v22 + (v7._rawBits >> 16) + v20-- - 2) & 0xC0;
            while (v21 == 128);
            uint64_t v19 = 1 - v20;
          }

          else
          {
            uint64_t v19 = 1LL;
          }
        }

        else
        {
          Swift::Int result = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((v5 & 0x1000000000000000LL) == 0) {
            Swift::Int result = (Swift::Int)_StringObject.sharedUTF8.getter(v5, v4);
          }
          uint64_t v17 = 0LL;
          do
            int v18 = *(_BYTE *)(result + (v7._rawBits >> 16) - 1 + v17--) & 0xC0;
          while (v18 == 128);
          uint64_t v19 = -v17;
        }

        v7._Swift::UInt64 rawBits = (v7._rawBits - (v19 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
        if (v9 >= v7._rawBits >> 14) {
          return v11;
        }
      }
    }

    goto LABEL_36;
  }

  return 0LL;
}

Swift::String::Index __swiftcall String.UnicodeScalarView.index(_:offsetBy:)( Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v4 = v3;
  uint64_t v5 = v2;
  result._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(_)._rawBits;
  if (offsetBy < 0)
  {
    uint64_t v14 = 0LL;
    while (1)
    {
      Swift::UInt64 v15 = result._rawBits >> 16;
      if (!(result._rawBits >> 16)) {
        break;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        result._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(result)._rawBits;
      }

      else
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v23 = v5;
          uint64_t v24 = v4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v23 + v15 - 1) & 0xC0) == 0x80)
          {
            uint64_t v18 = 0LL;
            do
              int v19 = v22[v15 + v18--] & 0xC0;
            while (v19 == 128);
            uint64_t v20 = 1 - v18;
          }

          else
          {
            uint64_t v20 = 1LL;
          }

          v15 -= v20;
        }

        else
        {
          BOOL v16 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            BOOL v16 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          do
            int v17 = v16[--v15] & 0xC0;
          while (v17 == 128);
        }

        result._Swift::UInt64 rawBits = (v15 << 16) | 5;
      }

      if (--v14 <= offsetBy) {
        return result;
      }
    }

    unint64_t v21 = 206LL;
LABEL_40:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  v21,  0);
  }

  if (offsetBy)
  {
    if ((v4 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v8 = HIBYTE(v4) & 0xF;
    }
    else {
      Swift::UInt64 v8 = v5 & 0xFFFFFFFFFFFFLL;
    }
    while (1)
    {
      Swift::UInt64 v9 = result._rawBits >> 16;
      if (result._rawBits >> 16 >= v8) {
        break;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        result._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(result)._rawBits;
      }

      else
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v23 = v5;
          uint64_t v24 = v4 & 0xFFFFFFFFFFFFFFLL;
          int v11 = *((unsigned __int8 *)&v23 + v9);
        }

        else
        {
          uint64_t v10 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            uint64_t v10 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int v11 = v10[v9];
        }

        int v12 = (char)v11;
        unsigned int v13 = __clz(v11 ^ 0xFF) - 24;
        if (v12 >= 0) {
          LOBYTE(v13) = 1;
        }
        result._Swift::UInt64 rawBits = ((v9 + v13) << 16) | 5;
      }

      if (!--offsetBy) {
        return result;
      }
    }

    unint64_t v21 = 201LL;
    goto LABEL_40;
  }

  return result;
}

uint64_t String.Index._rawBits.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*String.Index._rawBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t String.Index.orderingValue.getter(unint64_t a1)
{
  return a1 >> 14;
}

BOOL String.Index.isZeroPosition.getter(unint64_t a1)
{
  return a1 < 0x4000;
}

uint64_t String.Index.utf16Offset<A>(in:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UTF16View);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unsigned int v13 = (char *)&v19 - v12;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t))(a4 + 128);
  v14(a3, a4);
  v14(a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UTF16View: BidirectionalCollection);
  (*(void (**)(uint64_t *__return_ptr, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 64LL))( &v22,  AssociatedTypeWitness);
  BOOL v16 = *(void (**)(char *, unint64_t))(v8 + 8);
  v16(v11, AssociatedTypeWitness);
  uint64_t v20 = a2;
  uint64_t v21 = v22;
  uint64_t v17 = (*(uint64_t (**)(uint64_t *, uint64_t *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))( &v21,  &v20,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  v16(v13, AssociatedTypeWitness);
  return v17;
}

unint64_t String.Index.encodedOffset.getter(unint64_t a1)
{
  return a1 >> 16;
}

unint64_t String.Index.init<A>(utf16Offset:in:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = a1;
  uint64_t v25 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UTF16View);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v20 - v11;
  unsigned int v13 = *(void (**)(uint64_t, uint64_t))(a4 + 128);
  v13(a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UTF16View: BidirectionalCollection);
  uint64_t v14 = *(void *)(AssociatedConformanceWitness + 8);
  (*(void (**)(uint64_t *__return_ptr, unint64_t, uint64_t))(v14 + 64))( &v27,  AssociatedTypeWitness,  v14);
  Swift::UInt64 v15 = *(void (**)(char *, unint64_t))(v7 + 8);
  uint64_t v16 = v24;
  v15(v12, AssociatedTypeWitness);
  uint64_t v21 = v27;
  uint64_t v22 = v13;
  v13(a3, a4);
  (*(void (**)(uint64_t *__return_ptr, unint64_t, uint64_t))(v14 + 72))( &v29,  AssociatedTypeWitness,  v14);
  v15(v10, AssociatedTypeWitness);
  uint64_t v17 = v29;
  if (v16 < 0)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(v25, a3);
  }

  else
  {
    uint64_t v18 = v25;
    v22(a3, a4);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(v18, a3);
    uint64_t v29 = v21;
    uint64_t v26 = v17;
    (*(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t, uint64_t *, unint64_t))(AssociatedConformanceWitness + 56))( &v27,  &v29,  v16,  &v26,  AssociatedTypeWitness);
    v15(v12, AssociatedTypeWitness);
    if (v28 != 1) {
      return v27;
    }
  }

  return (v17 & 0xFFFFFFFFFFFF0000LL) + 0x10000;
}

unint64_t String.Index.nextEncoded.getter(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000LL) + 0x10000;
}

Swift::String::Index __swiftcall String.Index.init(encodedOffset:)(Swift::Int encodedOffset)
{
  return (Swift::String::Index)(encodedOffset << 16);
}

unint64_t String.Index.strippingTranscoding.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFF0000LL;
}

unint64_t String.Index.priorEncoded.getter(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000LL) - 0x10000;
}

unint64_t String.Index.nextTranscoded.getter(uint64_t a1)
{
  return (((unsigned __int16)a1 & 0xC000) + 0x4000LL) | a1 & 0xFFFFFFFFFFFF0000LL;
}

unint64_t String.Index.priorTranscoded.getter(uint64_t a1)
{
  return (((unsigned __int16)a1 & 0xC000) - 0x4000LL) | a1 & 0xFFFFFFFFFFFF0000LL;
}

Swift::String::Index __swiftcall String.Index.transcoded(withOffset:)(Swift::Int withOffset)
{
  return (Swift::String::Index)(v1 & 0xFFFFFFFFFFFF0000LL | (withOffset << 14));
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance String.Index( void *a1, void *a2)
{
  return (*a2 ^ *a1) < 0x4000uLL;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance String.Index( void *a1, void *a2)
{
  return *a1 >> 14 < *a2 >> 14;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance String.Index( void *a1, void *a2)
{
  return *a2 >> 14 >= *a1 >> 14;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance String.Index( void *a1, void *a2)
{
  return *a1 >> 14 >= *a2 >> 14;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance String.Index( void *a1, void *a2)
{
  return *a2 >> 14 < *a1 >> 14;
}

void String.Index.hash(into:)(uint64_t a1, unint64_t a2)
{
}

Swift::Int String.Index.hashValue.getter(unint64_t a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance String.Index()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance String.Index()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance String.Index()
{
  return Hasher._finalize()();
}

Swift::String::Index_optional __swiftcall String.Index.init(_:within:)(Swift::String::Index _, Swift::String within)
{
  Swift::UInt64 v2 = specialized String.Index.init(_:within:)(_, within._countAndFlagsBits, (uint64_t)within._object);
  Swift::Bool v4 = v3 & 1;
  result.value._Swift::UInt64 rawBits = v2;
  result.is_nil = v4;
  return result;
}

Swift::UInt64 String.Index.init<A>(_:within:)(Swift::UInt64 a1, Swift::UInt64 *a2, swift *a3, uint64_t a4)
{
  v7._Swift::UInt64 rawBits = a1;
  uint64_t v8 = *((void *)a3 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (uint64_t *)((char *)v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v9);
  unsigned int v13 = (uint64_t *)((char *)v26 - v12);
  uint64_t v14 = *(void (**)(char *))(v8 + 16);
  v14((char *)v26 - v12);
  if ((swift_dynamicCast((char *)v26, v13, a3, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    (*(void (**)(Swift::UInt64 *, swift *))(v8 + 8))(a2, a3);
    v15._Swift::UInt64 rawBits = v7._rawBits;
    Swift::UInt64 v16 = specialized String.Index.init(_:within:)(v15, v26[0], v26[1]);
    if ((v17 & 1) != 0) {
      return 0LL;
    }
    return v16;
  }

  ((void (*)(uint64_t *, Swift::UInt64 *, swift *))v14)(v11, a2, a3);
  if ((swift_dynamicCast((char *)v26, v11, a3, (const char *)&type metadata for Substring, 6uLL) & 1) == 0)
  {
    Swift::UInt64 v21 = String.init<A>(_:)(a2, a3, *(void *)(a4 + 40));
    v22._Swift::UInt64 rawBits = v7._rawBits;
    Swift::UInt64 v16 = specialized String.Index.init(_:within:)(v22, v21, v23);
    if ((v24 & 1) != 0) {
      return 0LL;
    }
    return v16;
  }

  (*(void (**)(Swift::UInt64 *, swift *))(v8 + 8))(a2, a3);
  uint64_t v18 = v27;
  unint64_t v19 = (v26[2] >> 59) & 1;
  if ((v27 & 0x1000000000000000LL) == 0) {
    LOBYTE(v19) = 1;
  }
  if ((v7._rawBits & 0xC) == 4LL << v19) {
    v7._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v7)._rawBits;
  }
  Swift::Bool v20 = Substring._isValidIndex(_:)(v7);
  swift_bridgeObjectRelease(v18);
  if (!v20) {
    return 0LL;
  }
  return v7._rawBits;
}

Swift::Bool __swiftcall Substring._isValidIndex(_:)(Swift::String::Index a1)
{
  uint64_t v5 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v5) {
    return 0;
  }
  unint64_t v7 = v1;
  Swift::UInt64 v9 = a1._rawBits >> 14;
  unint64_t v10 = v1 >> 14;
  if (a1._rawBits >> 14 < v1 >> 14) {
    return 0;
  }
  uint64_t v11 = v2;
  unint64_t v12 = v2 >> 14;
  if (v2 >> 14 < v9) {
    return 0;
  }
  unint64_t v13 = v4;
  uint64_t v14 = v3;
  if (!_StringGuts.isOnUnicodeScalarBoundary(_:)(a1)) {
    return 0;
  }
  unint64_t v15 = a1._rawBits | 1;
  return v9 == v15 >> 14;
}

uint64_t String.Index.samePosition(in:)(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return String.Index.samePosition(in:)(a1, a2, a3, (char *)specialized String.Index.init(_:within:));
}

{
  return String.Index.samePosition(in:)(a1, a2, a3, (char *)specialized String.Index.init(_:within:));
}

{
  return String.Index.samePosition(in:)(a1, a2, a3, (char *)specialized String.Index.init(_:within:));
}

Swift::UInt64 String.Index.init(_:within:)( Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  return specialized String.Index.init(_:within:)(a1, a2, a3);
}

{
  return specialized String.Index.init(_:within:)(a1, a2, a3);
}

{
  return specialized String.Index.init(_:within:)(a1, a2, a3);
}

Swift::String::Index __swiftcall _StringGuts.validateInclusiveCharacterIndex(_:)(Swift::String::Index result)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((result._rawBits & 2) == 0 || (result._rawBits & 0xC) == 4LL << v5)
  {
    result._Swift::UInt64 rawBits = _StringGuts.validateInclusiveSubscalarIndex(_:)(result)._rawBits;
    if ((result._rawBits & 1) != 0)
    {
      if ((result._rawBits & 2) != 0) {
        return result;
      }
    }

    else
    {
      Swift::UInt64 v7 = result._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(result)._rawBits & 0xFFFFFFFFFFFFFFF3LL;
      result._Swift::UInt64 rawBits = v7 | 1;
      if ((v7 & 2) != 0) {
        return result;
      }
    }

    if (result._rawBits < 0x10000) {
      return (Swift::String::Index)(result._rawBits | 3);
    }
    uint64_t v8 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000LL) == 0) {
      uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (result._rawBits >> 16 == v8) {
      return (Swift::String::Index)(result._rawBits | 3);
    }
    else {
      return _StringGuts._slowRoundDownToNearestCharacter(_:)(result);
    }
  }

  else
  {
    Swift::UInt64 v6 = HIBYTE(v2) & 0xF;
    if ((v2 & 0x2000000000000000LL) == 0) {
      Swift::UInt64 v6 = v1 & 0xFFFFFFFFFFFFLL;
    }
    if (v6 < result._rawBits >> 16) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x119uLL,  0);
    }
  }

  return result;
}

unint64_t _StringGuts.validateInclusiveCharacterIndex(_:in:)( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v9 = (a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((result & 2) != 0 && (result & 0xC) != 4LL << v9)
  {
    if (result >> 14 < a2 >> 14 || a3 >> 14 < result >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x128uLL,  0);
    }
    return result;
  }

  Swift::String::Index_optional result = _StringGuts.validateInclusiveSubscalarIndex(_:in:)(result, a2, a3, a4, a5);
  if ((result & 1) != 0)
  {
    if ((a2 & 2) != 0) {
      goto LABEL_10;
    }
  }

  else
  {
    Swift::String::Index_optional result = result & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)result)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((a2 & 2) != 0)
    {
LABEL_10:
      if ((result & 2) != 0) {
        return result;
      }
    }
  }

  if (result >> 14 != a2 >> 14 && result >> 14 != a3 >> 14) {
    return _StringGuts._slowRoundDownToNearestCharacter(_:in:)(result, a2, a3, a4, a5);
  }
  return result;
}

Swift::String::Index __swiftcall _StringGuts.validateInclusiveScalarIndex(_:)(Swift::String::Index result)
{
  uint64_t v3 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v3) = 1;
  }
  if ((result._rawBits & 1) == 0 || (result._rawBits & 0xC) == 4LL << v3)
  {
    result._Swift::UInt64 rawBits = _StringGuts.validateInclusiveSubscalarIndex(_:)(result)._rawBits;
    if ((result._rawBits & 1) == 0) {
      return (Swift::String::Index)(result._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(result)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1);
    }
  }

  else
  {
    Swift::UInt64 v4 = HIBYTE(v2) & 0xF;
    if ((v2 & 0x2000000000000000LL) == 0) {
      Swift::UInt64 v4 = v1 & 0xFFFFFFFFFFFFLL;
    }
    if (v4 < result._rawBits >> 16) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xA5uLL,  0);
    }
  }

  return result;
}

Swift::String::Index __swiftcall _StringGuts.validateInclusiveSubscalarIndex(_:)(Swift::String::Index result)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((result._rawBits & 0xC) == 4LL << v5) {
    result._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(result)._rawBits;
  }
  Swift::UInt64 v6 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v6 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 < result._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x35uLL,  0);
  }
  return result;
}

Swift::UInt64 _StringGuts.validateInclusiveSubscalarIndex(_:in:)( Swift::UInt64 result, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v7 = (a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((result & 0xC) == 4LL << v7) {
    Swift::String::Index_optional result = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)result)._rawBits;
  }
  if (result >> 14 < a2 >> 14 || a3 >> 14 < result >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x41uLL,  0);
  }
  return result;
}

Swift::String::Index __swiftcall _StringGuts.validateSubscalarIndex(_:)(Swift::String::Index result)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((result._rawBits & 0xC) == 4LL << v5) {
    result._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(result)._rawBits;
  }
  Swift::UInt64 v6 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v6 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 <= result._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x1FuLL,  0);
  }
  return result;
}

Swift::UInt64 _StringGuts.validateSubscalarIndex(_:in:)( Swift::UInt64 result, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v7 = (a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((result & 0xC) == 4LL << v7) {
    Swift::String::Index_optional result = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)result)._rawBits;
  }
  if (result >> 14 < a2 >> 14 || result >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x2BuLL,  0);
  }
  return result;
}

Swift::UInt64 _StringGuts.validateSubscalarRange(_:in:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v10 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1__StringStorage._updateCountAndFlags(newCount:newIsASCII:)( from - to + (*(void *)(v2 + 24) & 0xFFFFFFFFFFFFLL),  *(uint64_t *)(v2 + 24) < 0) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((a2._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  }
  if ((a1._rawBits & 0xC) == v11) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if (a1._rawBits >> 14 < a3 >> 14 || rawBits >> 14 < a1._rawBits >> 14 || a4 >> 14 < rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
  }
  return a1._rawBits;
}

Swift::String::Index __swiftcall _StringGuts.scalarAlign(_:)(Swift::String::Index a1)
{
  Swift::UInt64 rawBits = a1._rawBits;
  if ((a1._rawBits & 1) == 0) {
    return (Swift::String::Index)(a1._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a1)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1);
  }
  return (Swift::String::Index)rawBits;
}

Swift::String::Index _StringGuts.validateScalarIndex(_:in:)( Swift::String::Index result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  char v7 = (a5 & 0x1000000000000000LL) == 0 || (a4 & 0x800000000000000LL) != 0;
  uint64_t v8 = result._rawBits & 0xC;
  uint64_t v9 = 4LL << v7;
  if ((result._rawBits & 1) == 0 || v8 == v9)
  {
    if (v8 == v9) {
      result._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(result)._rawBits;
    }
    if (result._rawBits >> 14 < a2 >> 14 || result._rawBits >> 14 >= a3 >> 14)
    {
      unint64_t v10 = 43LL;
LABEL_17:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v10,  0);
    }

    if ((result._rawBits & 1) == 0) {
      return (Swift::String::Index)(result._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(result)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1);
    }
  }

  else if (result._rawBits >> 14 < a2 >> 14 || result._rawBits >> 14 >= a3 >> 14)
  {
    unint64_t v10 = 143LL;
    goto LABEL_17;
  }

  return result;
}

Swift::UInt64 _StringGuts.validateScalarRange(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v5 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((a1._rawBits & 1) == 0
    || (uint64_t v6 = 4LL << v5, (a1._rawBits & 0xC) == v6)
    || (a2._rawBits & 1) == 0
    || (a2._rawBits & 0xC) == v6)
  {
    Swift::UInt64 v8 = _StringGuts.validateSubscalarRange(_:)(a1, a2, a3, a4, 0x50uLL);
    Swift::UInt64 rawBits = v8;
    v10._Swift::UInt64 rawBits = v9;
    if ((v8 & 1) != 0)
    {
      if ((v9 & 1) != 0) {
        return rawBits;
      }
    }

    else
    {
      Swift::UInt64 rawBits = v8 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v10._rawBits & 1) != 0) {
        return rawBits;
      }
    }

    _StringGuts.scalarAlignSlow(_:)(v10)._rawBits;
    return rawBits;
  }

  Swift::UInt64 v7 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v7 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 < a2._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
  }
  return rawBits;
}

Swift::UInt64 _StringGuts.validateScalarRange(_:in:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v7 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((a1._rawBits & 1) == 0
    || (uint64_t v8 = 4LL << v7, (a1._rawBits & 0xC) == v8)
    || (a2._rawBits & 1) == 0
    || (a2._rawBits & 0xC) == v8)
  {
    Swift::UInt64 v9 = _StringGuts.validateSubscalarRange(_:in:)(a1, a2, a3, a4, a5, a6);
    Swift::UInt64 rawBits = v9;
    if ((v10._rawBits & 1) != 0)
    {
      if ((v9 & 1) != 0) {
        return rawBits;
      }
    }

    else
    {
      _StringGuts.scalarAlignSlow(_:)(v10)._rawBits;
      if ((rawBits & 1) != 0) {
        return rawBits;
      }
    }

    return rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
  }

  if (a1._rawBits >> 14 < a3 >> 14 || a4 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
  }
  return rawBits;
}

unint64_t _StringGuts.validateCharacterIndex(_:in:)( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v9 = (a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((result & 2) != 0 && (result & 0xC) != 4LL << v9)
  {
    if (result >> 14 < a2 >> 14 || result >> 14 >= a3 >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x10BuLL,  0);
    }
    return result;
  }

  Swift::String::Index_optional result = _StringGuts.validateSubscalarIndex(_:in:)(result, a2, a3, a4, a5);
  if ((result & 1) != 0)
  {
    if ((a2 & 2) != 0) {
      goto LABEL_10;
    }
  }

  else
  {
    Swift::String::Index_optional result = result & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)result)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((a2 & 2) != 0)
    {
LABEL_10:
      if ((result & 2) != 0) {
        return result;
      }
    }
  }

  if (result >> 14 != a2 >> 14 && result >> 14 != a3 >> 14) {
    return _StringGuts._slowRoundDownToNearestCharacter(_:in:)(result, a2, a3, a4, a5);
  }
  return result;
}

Swift::String::Index __swiftcall _StringGuts.validateInclusiveSubscalarIndex_5_7(_:)(Swift::String::Index a1)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 < rawBits >> 16 && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x141uLL,  0);
  }
  return (Swift::String::Index)rawBits;
}

Swift::UInt64 _StringGuts.validateSubscalarRange(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v10 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1__StringStorage._updateCountAndFlags(newCount:newIsASCII:)( from - to + (*(void *)(v2 + 24) & 0xFFFFFFFFFFFFLL),  *(uint64_t *)(v2 + 24) < 0) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((a2._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  }
  if ((a1._rawBits & 0xC) == v11) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  uint64_t v12 = a3 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v12 = HIBYTE(a4) & 0xF;
  }
  if (rawBits >> 14 > 4 * v12 || rawBits >> 14 < a1._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  a5,  0);
  }
  return a1._rawBits;
}

Swift::UInt64 _StringGuts.validateScalarRange_5_7(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v5 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((a1._rawBits & 1) == 0
    || (uint64_t v6 = 4LL << v5, (a1._rawBits & 0xC) == v6)
    || (a2._rawBits & 1) == 0
    || (a2._rawBits & 0xC) == v6)
  {
    Swift::UInt64 v8 = _StringGuts.validateSubscalarRange(_:)(a1, a2, a3, a4, 0x164uLL);
    Swift::UInt64 rawBits = v8;
    v10._Swift::UInt64 rawBits = v9;
    if ((v8 & 1) != 0)
    {
      if ((v9 & 1) != 0) {
        return rawBits;
      }
    }

    else
    {
      Swift::UInt64 rawBits = v8 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v10._rawBits & 1) != 0) {
        return rawBits;
      }
    }

    _StringGuts.scalarAlignSlow(_:)(v10)._rawBits;
    return rawBits;
  }

  Swift::UInt64 v7 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v7 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 < a2._rawBits >> 16 && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x174uLL,  0);
  }
  return rawBits;
}

Swift::Int _StringGuts.validateWordIndex(_:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t (*a4)(void))
{
  v6._Swift::UInt64 rawBits = a4();
  Swift::UInt64 rawBits = v6._rawBits;
  if ((v6._rawBits & 1) != 0)
  {
    if (v6._rawBits < 0x10000) {
      return rawBits;
    }
  }

  else
  {
    Swift::UInt64 rawBits = v6._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v6)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if (rawBits < 0x10000) {
      return rawBits;
    }
  }

  Swift::UInt64 v8 = rawBits >> 16;
  uint64_t v9 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    uint64_t v9 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 != v9)
  {
    Swift::Int v10 = _StringGuts.previousWordIndex(endingAt:)(rawBits >> 16);
    if (v8 != _StringGuts.nextWordIndex(startingAt:)(v10)) {
      return v10 << 16;
    }
  }

  return rawBits;
}

uint64_t (*DefaultStringInterpolation._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t DefaultStringInterpolation.appendInterpolation<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(a3 + 8))( v3,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  a2,  a3);
}

uint64_t protocol witness for StringInterpolationProtocol.init(literalCapacity:interpolationCount:) in conformance DefaultStringInterpolation@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (a2 + 0x4000000000000000LL < 0)
  {
    __break(1u);
  }

  else
  {
    BOOL v4 = __OFADD__(result, 2 * a2);
    result += 2 * a2;
    if (!v4)
    {
      Swift::String::Index_optional result = static String._createEmpty(withInitialCapacity:)(result);
      *a3 = result;
      a3[1] = v5;
      return result;
    }
  }

  __break(1u);
  return result;
}

void protocol witness for StringInterpolationProtocol.appendLiteral(_:) in conformance DefaultStringInterpolation( Swift::String *a1)
{
}

void String._writeASCII(_:)(uint64_t a1, uint64_t a2)
{
}

Swift::Bool __swiftcall String.hasPrefix(_:)(Swift::String a1)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t object = (uint64_t)a1._object;
  if ((v2 & 0x2000000000000000LL) != 0) {
    unint64_t v6 = v2;
  }
  else {
    unint64_t v6 = v1;
  }
  if ((v2 & 0x1000000000000000LL) != 0 || (v6 & 0x4000000000000000LL) == 0) {
    return specialized Sequence<>.starts<A>(with:)(a1._countAndFlagsBits, (unint64_t)a1._object, v1, (char *)v2);
  }
  unint64_t v7 = ((uint64_t)a1._object & 0x2000000000000000LL) != 0 ? (unint64_t)a1._object : a1._countAndFlagsBits;
  int64_t v8 = HIBYTE(a1._object) & 0xF;
  uint64_t v9 = a1._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  else {
    unint64_t v10 = a1._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v11 = HIBYTE(v2) & 0xF;
  uint64_t v12 = v1 & 0xFFFFFFFFFFFFLL;
  if ((v2 & 0x2000000000000000LL) != 0) {
    unint64_t v13 = HIBYTE(v2) & 0xF;
  }
  else {
    unint64_t v13 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v13 < v10) {
    return 0;
  }
  if ((object & 0x2000000000000000LL) == 0)
  {
    if ((a1._countAndFlagsBits & 0x1000000000000000LL) != 0)
    {
      uint64_t v14 = (const void *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
      int64_t v15 = a1._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      if ((v2 & 0x2000000000000000LL) == 0) {
        goto LABEL_21;
      }
    }

    else
    {
      id v19 = _StringObject.sharedUTF8.getter(a1._countAndFlagsBits, object);
      uint64_t v11 = HIBYTE(v3) & 0xF;
      uint64_t v14 = v19;
      int64_t v15 = v20;
      uint64_t v12 = v4 & 0xFFFFFFFFFFFFLL;
      if ((v3 & 0x2000000000000000LL) == 0)
      {
LABEL_21:
        if ((v4 & 0x1000000000000000LL) != 0)
        {
          p_s2 = (uint64_t *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if (v12 >= v15)
          {
LABEL_23:
            if (v15 && !p_s2) {
              goto LABEL_32;
            }
LABEL_40:
            if (!_swift_stdlib_memcmp(p_s2, v14, v15)) {
              return _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v9 << 16));
            }
            return 0;
          }
        }

        else
        {
          int64_t v23 = v15;
          p_s2 = (uint64_t *)_StringObject.sharedUTF8.getter(v4, v3);
          int64_t v15 = v23;
          if (v21 >= v23) {
            goto LABEL_23;
          }
        }

Swift::Bool __swiftcall String.hasSuffix(_:)(Swift::String a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  unint64_t object = (unint64_t)a1._object;
  if ((v2 & 0x2000000000000000LL) != 0) {
    unint64_t v6 = v2;
  }
  else {
    unint64_t v6 = v1;
  }
  if ((v2 & 0x1000000000000000LL) != 0 || (v6 & 0x4000000000000000LL) == 0) {
    return specialized Sequence<>.starts<A>(with:)(a1._countAndFlagsBits, (unint64_t)a1._object, v1, v2);
  }
  unint64_t v7 = ((uint64_t)a1._object & 0x2000000000000000LL) != 0 ? (unint64_t)a1._object : a1._countAndFlagsBits;
  uint64_t v8 = HIBYTE(v2) & 0xF;
  uint64_t v9 = v1 & 0xFFFFFFFFFFFFLL;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = v1 & 0xFFFFFFFFFFFFLL;
  }
  int64_t v10 = HIBYTE(object) & 0xF;
  uint64_t v11 = a1._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if ((object & 0x2000000000000000LL) != 0) {
    uint64_t v12 = HIBYTE(object) & 0xF;
  }
  else {
    uint64_t v12 = a1._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v13 = v8 - v12;
  if (v8 - v12 < 0) {
    return 0;
  }
  if ((object & 0x2000000000000000LL) == 0)
  {
    if ((a1._countAndFlagsBits & 0x1000000000000000LL) != 0)
    {
      id v14 = (id)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v15 = a1._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      if ((v2 & 0x2000000000000000LL) == 0)
      {
LABEL_20:
        if ((v4 & 0x1000000000000000LL) != 0)
        {
          uint64_t v16 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
          uint64_t v17 = v9;
          goto LABEL_22;
        }

        uint64_t v32 = v9;
        id v33 = _StringObject.sharedUTF8.getter(v4, v3);
        uint64_t v17 = v34;
        if (v34 >= v32)
        {
          uint64_t v16 = (uint64_t)v33;
          uint64_t v9 = v32;
LABEL_22:
          uint64_t v18 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v13, v9, v16, v17);
          uint64_t v11 = v19;
          if (v15 >= v19) {
            size_t v20 = v19;
          }
          else {
            size_t v20 = v15;
          }
LABEL_39:
          int v28 = _swift_stdlib_memcmp(v18, v14, v20);
          uint64_t v29 = v28;
          uint64_t v30 = v11 - v15;
          goto LABEL_40;
        }

BOOL protocol witness for StringProtocol.hasPrefix(_:) in conformance String(Swift::String a1)
{
  return String.hasPrefix(_:)(a1);
}

BOOL protocol witness for StringProtocol.hasSuffix(_:) in conformance String(Swift::String a1)
{
  return String.hasSuffix(_:)(a1);
}

uint64_t protocol witness for StringProtocol.lowercased() in conformance String()
{
  return String.lowercased()()._countAndFlagsBits;
}

uint64_t protocol witness for StringProtocol.uppercased() in conformance String()
{
  return String.uppercased()()._countAndFlagsBits;
}

uint64_t protocol witness for StringProtocol.init<A, B>(decoding:as:) in conformance String@<X0>( uint64_t a1@<X0>, swift *a2@<X2>, uint64_t a3@<X4>, uint64_t a4@<X6>, uint64_t *a5@<X8>)
{
  uint64_t v10 = *((void *)a2 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v16 = (uint64_t *)((char *)v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  if (v12 != &type metadata for Unicode.UTF8)
  {
    unint64_t v25 = static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, (uint64_t)v12, 1, a2, v13, a3, v14);
    if (!v26) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
    }
    goto LABEL_10;
  }

  MEMORY[0x1895F8858](v11);
  (*(void (**)(uint64_t *__return_ptr, uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, uint64_t *@<X8>)))(*(void *)(a3 + 8) + 72LL))( &v29,  closure #1 in String.init<A, B>(decoding:as:)partial apply);
  uint64_t v17 = v30;
  if (v30)
  {
    uint64_t v18 = v29;
LABEL_11:
    uint64_t result = (*(uint64_t (**)(uint64_t, swift *))(v10 + 8))(a1, a2);
    goto LABEL_12;
  }

  (*(void (**)(uint64_t *, uint64_t, swift *))(v10 + 16))(v16, a1, a2);
  uint64_t v19 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasContiguousBytes);
  if ((swift_dynamicCast((char *)v27, v16, a2, v19, 6uLL) & 1) == 0)
  {
    uint64_t v28 = 0LL;
    memset(v27, 0, sizeof(v27));
    outlined destroy of _HasContiguousBytes?( (uint64_t)v27,  &demangling cache variable for type metadata for _HasContiguousBytes?);
LABEL_9:
    unint64_t v25 = static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)(a1, (uint64_t)a2, a3);
LABEL_10:
    uint64_t v18 = v25;
    uint64_t v17 = v26;
    goto LABEL_11;
  }

  outlined init with take of MirrorPath(v27, (uint64_t)&v29);
  uint64_t v20 = v31;
  uint64_t v21 = v32;
  __swift_project_boxed_opaque_existential_0Tm(&v29, v31);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v21 + 16))(v20, v21) & 1) == 0)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(&v29);
    goto LABEL_9;
  }

  (*(void (**)(uint64_t, swift *))(v10 + 8))(a1, a2);
  uint64_t v22 = v31;
  uint64_t v23 = v32;
  __swift_project_boxed_opaque_existential_0Tm(&v29, v31);
  (*(void (**)(__int128 *__return_ptr, uint64_t (*)@<X0>(uint8x16_t *@<X0>, uint64_t@<X1>, uint64_t *@<X8>), void, uint64_t, uint64_t, uint64_t))(v23 + 8))( v27,  closure #2 in String.init<A, B>(decoding:as:),  0LL,  a4,  v22,  v23);
  uint64_t v17 = *((void *)&v27[0] + 1);
  uint64_t v18 = *(void *)&v27[0];
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(&v29);
LABEL_12:
  *a5 = v18;
  a5[1] = v17;
  return result;
}

uint64_t *protocol witness for StringProtocol.init(cString:) in conformance String@<X0>( char *a1@<X0>, uint64_t **a2@<X8>)
{
  size_t v4 = _swift_stdlib_strlen(a1);
  if ((v4 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t result = _sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n( (uint64_t *)a1,  v4);
  *a2 = result;
  a2[1] = v6;
  return result;
}

unint64_t protocol witness for StringProtocol.init<A>(decodingCString:as:) in conformance String@<X0>( uint8x16_t *a1@<X0>, ValueMetadata *a2@<X1>, ValueMetadata *a3@<X2>, const char *a4@<X3>, unint64_t *a5@<X8>)
{
  unint64_t result = String.init<A>(decodingCString:as:)(a1, a2, a3, a4);
  *a5 = result;
  a5[1] = v7;
  return result;
}

uint64_t protocol witness for StringProtocol.withCString<A>(_:) in conformance String( void (*a1)(__objc2_class **), uint64_t a2)
{
  return String.withCString<A>(_:)(a1, a2, *(void *)v2, *(char **)(v2 + 8));
}

void protocol witness for StringProtocol.withCString<A, B>(encodedAs:_:) in conformance String( ValueMetadata *a1, uint64_t a2, uint64_t a3)
{
  if (a1 == &type metadata for Unicode.UTF8)
  {
    MEMORY[0x1895F8858](a1);
    void v11[2] = v4;
    uint64_t v11[3] = v5;
    v11[4] = v7;
    void v11[5] = v6;
    v11[6] = v8;
    String.withCString<A>(_:)( (void (*)(__objc2_class **))partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:),  (uint64_t)v11,  v9,  v10);
  }

  else
  {
    String._slowWithCString<A, B>(encodedAs:_:)((uint64_t)a1, a2, a3, *(char **)v3, *(void *)(v3 + 8));
  }

uint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance String@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = result;
  a3[1] = a2;
  return result;
}

Swift::UInt64 String.init<A>(_:)(unint64_t *a1, swift *a2, uint64_t a3)
{
  uint64_t v6 = *((void *)a2 - 1);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  unint64_t v9 = (uint64_t *)((char *)&v23 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v7);
  id v14 = (uint64_t *)((char *)&v23 - v13);
  if (v10 != &type metadata for String)
  {
    if (a2 != (swift *)&type metadata for Substring)
    {
      if (a2 == (swift *)&unk_189B86C40)
      {
        uint64_t v21 = *a1;
        Swift::UInt64 v23 = 0LL;
        Swift::UInt64 v24 = 0xE000000000000000LL;
        specialized String.append<A>(contentsOf:)(v21, (uint64_t)v10, v11, v12);
        swift_bridgeObjectRelease(v21);
      }

      else
      {
        uint64_t v15 = *(void (**)(char *, unint64_t *, swift *))(v6 + 16);
        v15((char *)&v23 - v13, a1, a2);
        if ((swift_dynamicCast((char *)&v23, v14, a2, (const char *)&type metadata for String, 6uLL) & 1) == 0)
        {
          v15((char *)v9, a1, a2);
          if ((swift_dynamicCast((char *)&v23, v9, a2, (const char *)&type metadata for Substring, 6uLL) & 1) != 0)
          {
            (*(void (**)(unint64_t *, swift *))(v6 + 8))(a1, a2);
            v16._Swift::UInt64 rawBits = v23;
            v17._Swift::UInt64 rawBits = v24;
            unint64_t v18 = v25;
            unint64_t v19 = v26;
LABEL_9:
            uint64_t v20 = specialized String.init(_:)(v16, v17, v18, v19);
            swift_bridgeObjectRelease(v19);
            return v20;
          }

          Swift::UInt64 v23 = 0LL;
          Swift::UInt64 v24 = 0xE000000000000000LL;
          String.append<A>(contentsOf:)(a1, (ValueMetadata *)a2, a3);
        }

        (*(void (**)(unint64_t *, swift *))(v6 + 8))(a1, a2);
      }

      return v23;
    }

    v16._Swift::UInt64 rawBits = *a1;
    v17._Swift::UInt64 rawBits = a1[1];
    unint64_t v18 = a1[2];
    unint64_t v19 = a1[3];
    goto LABEL_9;
  }

  return *a1;
}

unint64_t specialized String.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a2._rawBits;
  Swift::UInt64 v8 = a1._rawBits;
  uint64_t v10 = *v4;
  unint64_t v9 = v4[1];
  uint64_t v11 = ((unint64_t)*v4 >> 59) & 1;
  if ((v9 & 0x1000000000000000LL) == 0) {
    LOBYTE(v11) = 1;
  }
  uint64_t v12 = a1._rawBits & 0xC;
  uint64_t v13 = 4LL << v11;
  uint64_t v14 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v12 == v13 || (a2._rawBits & 1) == 0 || v14 == v13)
  {
    if (v14 == v13)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v12 != v13) {
        goto LABEL_13;
      }
    }

    else if (v12 != v13)
    {
      goto LABEL_13;
    }

    Swift::UInt64 v8 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v8)._rawBits;
LABEL_13:
    uint64_t v17 = HIBYTE(v9) & 0xF;
    if ((v9 & 0x2000000000000000LL) == 0) {
      uint64_t v17 = v10 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 > 4 * v17 || rawBits >> 14 < v8 >> 14)
    {
      unint64_t v16 = 80LL;
LABEL_20:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v16,  0);
    }

    if ((v8 & 1) != 0)
    {
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
      }
    }

    else
    {
      Swift::UInt64 v8 = v8 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
      }
    }

    Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
  }

  Swift::UInt64 v15 = HIBYTE(v9) & 0xF;
  if ((v9 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v15 = v10 & 0xFFFFFFFFFFFFLL;
  }
  if (v15 < a2._rawBits >> 16)
  {
    unint64_t v16 = 210LL;
    goto LABEL_20;
  }

  return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
}

uint64_t specialized String.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3)
{
  Swift::UInt64 rawBits = a2._rawBits;
  v6._Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v8 = *v3;
  unint64_t v7 = v3[1];
  uint64_t v9 = ((unint64_t)*v3 >> 59) & 1;
  if ((v7 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  uint64_t v10 = a1._rawBits & 0xC;
  uint64_t v11 = 4LL << v9;
  uint64_t v12 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v10 == v11 || (a2._rawBits & 1) == 0 || v12 == v11)
  {
    if (v12 == v11)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v10 != v11) {
        goto LABEL_13;
      }
    }

    else if (v10 != v11)
    {
      goto LABEL_13;
    }

    v6._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v6)._rawBits;
LABEL_13:
    uint64_t v15 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000LL) == 0) {
      uint64_t v15 = v8 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 > 4 * v15 || rawBits >> 14 < v6._rawBits >> 14)
    {
      unint64_t v14 = 80LL;
LABEL_20:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v14,  0);
    }

    if ((v6._rawBits & 1) != 0)
    {
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v6._rawBits, rawBits, a3);
      }
    }

    else
    {
      v6._Swift::UInt64 rawBits = v6._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v6)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v6._rawBits, rawBits, a3);
      }
    }

    Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    return specialized _StringGuts.replaceSubrange<A>(_:with:)(v6._rawBits, rawBits, a3);
  }

  Swift::UInt64 v13 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v13 = v8 & 0xFFFFFFFFFFFFLL;
  }
  if (v13 < a2._rawBits >> 16)
  {
    unint64_t v14 = 210LL;
    goto LABEL_20;
  }

  return specialized _StringGuts.replaceSubrange<A>(_:with:)(v6._rawBits, rawBits, a3);
}

uint64_t specialized String.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, Swift::Int a3, uint64_t a4, int64_t a5, unint64_t a6)
{
  Swift::UInt64 rawBits = a2._rawBits;
  v11._Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v13 = *v6;
  unint64_t v12 = v6[1];
  uint64_t v14 = ((unint64_t)*v6 >> 59) & 1;
  if ((v12 & 0x1000000000000000LL) == 0) {
    LOBYTE(vHasher._combine(_:)(*v0 >> 14) = 1;
  }
  uint64_t v15 = a1._rawBits & 0xC;
  uint64_t v16 = 4LL << v14;
  uint64_t v17 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v15 == v16 || (a2._rawBits & 1) == 0 || v17 == v16)
  {
    if (v17 == v16)
    {
      unint64_t v23 = a6;
      v24._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      a6 = v23;
      Swift::UInt64 rawBits = v24._rawBits;
      if (v15 != v16) {
        goto LABEL_13;
      }
    }

    else if (v15 != v16)
    {
      goto LABEL_13;
    }

    unint64_t v25 = a6;
    v26._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v11)._rawBits;
    a6 = v25;
    v11._Swift::UInt64 rawBits = v26._rawBits;
LABEL_13:
    uint64_t v20 = HIBYTE(v12) & 0xF;
    if ((v12 & 0x2000000000000000LL) == 0) {
      uint64_t v20 = v13 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 > 4 * v20 || rawBits >> 14 < v11._rawBits >> 14)
    {
      unint64_t v19 = 80LL;
LABEL_20:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v19,  0);
    }

    if ((v11._rawBits & 1) != 0)
    {
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v11._rawBits, rawBits, a3, a4, a5, a6);
      }
    }

    else
    {
      unint64_t v27 = a6;
      v28._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v11)._rawBits;
      a6 = v27;
      v11._Swift::UInt64 rawBits = v11._rawBits & 0xC | v28._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v11._rawBits, rawBits, a3, a4, a5, a6);
      }
    }

    unint64_t v29 = a6;
    v30._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    a6 = v29;
    Swift::UInt64 rawBits = rawBits & 0xC | v30._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    return specialized _StringGuts.replaceSubrange<A>(_:with:)(v11._rawBits, rawBits, a3, a4, a5, a6);
  }

  Swift::UInt64 v18 = HIBYTE(v12) & 0xF;
  if ((v12 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v18 = v13 & 0xFFFFFFFFFFFFLL;
  }
  if (v18 < a2._rawBits >> 16)
  {
    unint64_t v19 = 210LL;
    goto LABEL_20;
  }

  return specialized _StringGuts.replaceSubrange<A>(_:with:)(v11._rawBits, rawBits, a3, a4, a5, a6);
}

const char *String.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, ValueMetadata *a4, Swift::Int a5)
{
  v7._Swift::UInt64 rawBits = a2._rawBits;
  v8._Swift::UInt64 rawBits = a1._rawBits;
  if (a4 == &type metadata for String) {
    return (const char *)specialized String.replaceSubrange<A>(_:with:)(a1, a2, *(void *)a3, *(void *)(a3 + 8));
  }
  if (a4 == &type metadata for Substring) {
    return (const char *)specialized String.replaceSubrange<A>(_:with:)( a1,  a2,  *(void *)a3,  *(void *)(a3 + 8),  *(void *)(a3 + 16),  *(void *)(a3 + 24));
  }
  if (a4 != (ValueMetadata *)&unk_189B86C40)
  {
    uint64_t v12 = *v5;
    unint64_t v11 = v5[1];
    char v13 = (v11 & 0x1000000000000000LL) == 0 || (*v5 & 0x800000000000000LL) != 0;
    uint64_t v14 = a1._rawBits & 0xC;
    uint64_t v15 = 4LL << v13;
    uint64_t v16 = a2._rawBits & 0xC;
    if ((a1._rawBits & 1) != 0 && v14 != v15 && (a2._rawBits & 1) != 0 && v16 != v15)
    {
      Swift::UInt64 v17 = HIBYTE(v11) & 0xF;
      if ((v11 & 0x2000000000000000LL) == 0) {
        Swift::UInt64 v17 = v12 & 0xFFFFFFFFFFFFLL;
      }
      if (v17 < a2._rawBits >> 16)
      {
        unint64_t v18 = 210LL;
        goto LABEL_28;
      }

      return _StringGuts.replaceSubrange<A>(_:with:)(v8._rawBits, v7._rawBits, (unint64_t *)a3, a4, a5);
    }

    if (v16 == v15)
    {
      uint64_t v24 = a1._rawBits & 0xC;
      uint64_t v21 = v15;
      v22._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      uint64_t v23 = v21;
      v7._Swift::UInt64 rawBits = v22._rawBits;
      if (v24 != v23) {
        goto LABEL_19;
      }
    }

    else if (v14 != v15)
    {
      goto LABEL_19;
    }

    v8._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v8)._rawBits;
LABEL_19:
    uint64_t v20 = v12 & 0xFFFFFFFFFFFFLL;
    if ((v11 & 0x2000000000000000LL) != 0) {
      uint64_t v20 = HIBYTE(v11) & 0xF;
    }
    if (v7._rawBits >> 14 > 4 * v20 || v7._rawBits >> 14 < v8._rawBits >> 14)
    {
      unint64_t v18 = 80LL;
LABEL_28:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v18,  0);
    }

    if ((v8._rawBits & 1) != 0)
    {
      if ((v7._rawBits & 1) != 0) {
        return _StringGuts.replaceSubrange<A>(_:with:)(v8._rawBits, v7._rawBits, (unint64_t *)a3, a4, a5);
      }
    }

    else
    {
      v8._Swift::UInt64 rawBits = v8._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v7._rawBits & 1) != 0) {
        return _StringGuts.replaceSubrange<A>(_:with:)(v8._rawBits, v7._rawBits, (unint64_t *)a3, a4, a5);
      }
    }

    v7._Swift::UInt64 rawBits = v7._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v7)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    return _StringGuts.replaceSubrange<A>(_:with:)(v8._rawBits, v7._rawBits, (unint64_t *)a3, a4, a5);
  }

  return (const char *)specialized String.replaceSubrange<A>(_:with:)(a1, a2, *(void *)a3);
}

Swift::Void __swiftcall String.insert(_:at:)(Swift::String _, Swift::String::Index at)
{
  unint64_t object = _._object;
  uint64_t countAndFlagsBits = _._countAndFlagsBits;
  v4._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(at)._rawBits;
  specialized _StringGuts.replaceSubrange<A>(_:with:)( v4._rawBits,  v4._rawBits,  countAndFlagsBits,  (unint64_t)object);
}

const char *String.insert<A>(contentsOf:at:)( unint64_t *a1, Swift::String::Index a2, ValueMetadata *a3, Swift::Int a4)
{
  if (a3 == &type metadata for String)
  {
    uint64_t v10 = *a1;
    unint64_t v9 = a1[1];
    v11._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(a2)._rawBits;
    return (const char *)specialized _StringGuts.replaceSubrange<A>(_:with:)(v11._rawBits, v11._rawBits, v10, v9);
  }

  else if (a3 == &type metadata for Substring)
  {
    Swift::Int v12 = *a1;
    uint64_t v13 = a1[1];
    int64_t v15 = a1[2];
    unint64_t v14 = a1[3];
    v16._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(a2)._rawBits;
    return (const char *)specialized _StringGuts.replaceSubrange<A>(_:with:)( v16._rawBits,  v16._rawBits,  v12,  v13,  v15,  v14);
  }

  else if (a3 == (ValueMetadata *)&unk_189B86C40)
  {
    unint64_t v17 = *a1;
    v18._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(a2)._rawBits;
    return (const char *)specialized _StringGuts.replaceSubrange<A>(_:with:)(v18._rawBits, v18._rawBits, v17);
  }

  else
  {
    v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(a2)._rawBits;
    return _StringGuts.replaceSubrange<A>(_:with:)(v7._rawBits, v7._rawBits, a1, a3, a4);
  }

Swift::String __swiftcall String.remove(at:)(Swift::String::Index at)
{
  uint64_t v2 = *v1;
  unint64_t v3 = v1[1];
  v4._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(at)._rawBits;
  Swift::UInt64 v5 = (v4._rawBits >> 8) & 0x3F;
  Swift::UInt64 v6 = v4._rawBits >> 16;
  if (!v5)
  {
    uint64_t v7 = v2 & 0xFFFFFFFFFFFFLL;
    if ((v3 & 0x2000000000000000LL) != 0) {
      uint64_t v8 = HIBYTE(v3) & 0xF;
    }
    else {
      uint64_t v8 = v2 & 0xFFFFFFFFFFFFLL;
    }
    if (v4._rawBits >> 14 == 4 * v8)
    {
      Swift::UInt64 v5 = 0LL;
      goto LABEL_22;
    }

    if ((v3 & 0x1000000000000000LL) != 0) {
      goto LABEL_38;
    }
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v29 = v2;
      uint64_t v30 = v3 & 0xFFFFFFFFFFFFFFLL;
      if (v6 + 1 == (HIBYTE(v3) & 0xF)) {
        goto LABEL_21;
      }
      int v10 = *(unsigned __int16 *)((char *)&v29 + v6);
    }

    else
    {
      if ((v2 & 0x1000000000000000LL) != 0) {
        unint64_t v9 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        unint64_t v9 = (char *)_StringObject.sharedUTF8.getter(v2, v3);
      }
      if (v6 + 1 == v7) {
        goto LABEL_21;
      }
      if (!v9) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      }
      int v10 = *(unsigned __int16 *)&v9[v6];
    }

    if (v10 == 2573 || (v10 & 0x8080) != 0)
    {
LABEL_38:
      Swift::UInt64 v5 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v4._rawBits >> 16);
      goto LABEL_22;
    }

void String.removeSubrange(_:)(Swift::String::Index a1, Swift::String::Index a2)
{
  Swift::UInt64 v3 = _StringGuts.validateScalarRange(_:)(a1, a2, *v2, v2[1]);
  _StringGuts.remove(from:to:)((Swift::String::Index)v3, v4);
}

Swift::Void __swiftcall String.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  if (keepingCapacity)
  {
    _StringGuts.clear()();
  }

  else
  {
    swift_bridgeObjectRelease(v1[1]);
    void *v1 = 0LL;
    v1[1] = 0xE000000000000000LL;
  }

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance String( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(void, void, uint64_t, uint64_t, uint64_t))String.replaceSubrange<A>(_:with:));
}

unint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance String@<X0>( unint64_t *a1@<X0>, unint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized String.init(repeating:count:)(*a1, a1[1], a2);
  *a3 = result;
  a3[1] = v5;
  return result;
}

Swift::UInt64 protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance String@<X0>( unint64_t *a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, Swift::UInt64 *a4@<X8>)
{
  Swift::UInt64 result = String.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  return result;
}

void protocol witness for RangeReplaceableCollection.append(_:) in conformance String(uint64_t *a1)
{
  uint64_t v1 = (void *)a1[1];
  v2._uint64_t countAndFlagsBits = *a1;
  v2._unint64_t object = v1;
  String.append(contentsOf:)(v2);
  swift_bridgeObjectRelease((uint64_t)v1);
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance String( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance String( a1,  a2,  a3,  a4,  a5,  (void (*)(void))String.append<A>(contentsOf:));
}

void protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance String( uint64_t *a1, Swift::String::Index *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  v4._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)a2->_rawBits)._rawBits;
  specialized _StringGuts.replaceSubrange<A>(_:with:)(v4._rawBits, v4._rawBits, v2, v3);
  swift_bridgeObjectRelease(v3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance String( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(uint64_t, void))String.insert<A>(contentsOf:at:));
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance String@<X0>( Swift::String::Index *a1@<X0>, Swift::String *a2@<X8>)
{
  Swift::String v4 = String.remove(at:)((Swift::String::Index)a1->_rawBits);
  uint64_t result = v4._countAndFlagsBits;
  *a2 = v4;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance String( Swift::UInt64 *a1)
{
  v2._Swift::UInt64 rawBits = a1[1];
  v3._Swift::UInt64 rawBits = *a1;
  Swift::UInt64 v4 = _StringGuts.validateScalarRange(_:)(v3, v2, *v1, v1[1]);
  _StringGuts.remove(from:to:)((Swift::String::Index)v4, v5);
}

void protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance String( void *a1@<X8>)
{
  *a1 = 0LL;
  a1[1] = 0LL;
}

uint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance String@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.removeFirst()();
  *a1 = result;
  a1[1] = v3;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeAll(keepingCapacity:) in conformance String( char a1)
{
  if ((a1 & 1) != 0)
  {
    _StringGuts.clear()();
  }

  else
  {
    swift_bridgeObjectRelease(v1[1]);
    void *v1 = 0LL;
    v1[1] = 0xE000000000000000LL;
  }

void protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance String( uint64_t (*a1)(void *), uint64_t a2, uint64_t a3, char *a4)
{
}

Swift::Void __swiftcall String._boundsCheck(_:)(Swift::String::Index a1)
{
  Swift::UInt64 v3 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v3 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v3 <= a1._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x13EuLL,  0);
  }
}

void String._boundsCheck(_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    unint64_t v4 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v4 < a2 >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x146uLL,  0);
  }
}

{
  unint64_t v4;
  unint64_t v4 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    unint64_t v4 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v4 <= a2 >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x14FuLL,  0);
  }
}

uint64_t String.max<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  else {
    uint64_t v9 = a1;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, v9, a3);
}

uint64_t String.min<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  else {
    uint64_t v9 = a1;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, v9, a3);
}

void static Sequence<>.+ infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x16DuLL,  0);
}

Swift::Float __swiftcall Float.init(_:)(Swift::Int a1)
{
  return (float)a1;
}

float static Float.* infix(_:_:)(float a1, float a2)
{
  return a1 * a2;
}

Swift::Int __swiftcall Int.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int because it is either infinite or NaN",  75LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x36EDuLL,  0);
  }
  if (a1 <= -9.2234e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int because the result would be less than Int.min",  84LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x36F0uLL,  0);
  }
  if (a1 >= 9.2234e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int because the result would be greater than Int.max",  87LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x36F3uLL,  0);
  }
  return (uint64_t)a1;
}

int64_t _allocateStringStorage(codeUnitCapacity:)(int64_t result)
{
  uint64_t v2 = result + 1;
  if (__OFADD__(result, 1LL))
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v1 = 8LL * (result > 63);
  BOOL v3 = __OFADD__(v2, v1);
  v2 += v1;
  if (v3)
  {
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }

  BOOL v3 = __OFADD__(v2, 32LL);
  v2 += 32LL;
  if (v3)
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }

  if (v2 <= 127)
  {
    unint64_t v4 = (v2 + 15) & 0xFFFFFFFFFFFFFFF0LL;
    int64_t v5 = v4 - 32;
    if (!__OFSUB__(v4, 32LL))
    {
      uint64_t v6 = type metadata accessor for __StringStorage();
      uint64_t result = (int64_t)swift_allocObject(v6, v5 + 32, 7uLL);
      uint64_t v7 = (void *)result;
      goto LABEL_7;
    }

    goto LABEL_16;
  }

unint64_t __StringStorage._breadcrumbsAddress.getter()
{
  uint64_t v1 = *(void *)(v0 + 16);
  if ((v1 & 0x8000000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Internal error: string breadcrumbs not present",  46LL,  2,  "Swift/StringStorage.swift",  25LL,  2,  0x1C6uLL,  0);
  }
  return (v0 + (v1 & 0xFFFFFFFFFFFFLL) + 39) & 0xFFFFFFFFFFFFFFF8LL;
}

void __StringStorage.__deallocating_deinit()
{
  uint64_t v1 = *(void *)(v0 + 16);
  if (v1 < 0)
  {
    unint64_t v2 = (v0 + (v1 & 0xFFFFFFFFFFFFLL) + 39) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _StringBreadcrumbs?);
    swift_arrayDestroy(v2, 1LL, v3);
  }

  swift_deallocClassInstance(v0);
}

uint64_t __SharedStringStorage.__ivar_destroyer()
{
  return swift_release(*(void *)(v0 + 40));
}

Swift::Void __swiftcall UnsafePointer.deallocate()()
{
}

void __SharedStringStorage.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  int64_t v5 = *(void **)(v4 + 16);
  if (!v5)
  {
    if (*(_BYTE *)(v4 + 48) == 1)
    {
      int64_t v5 = 0LL;
    }

    else
    {
      swift_slowDealloc(*(void **)(v4 + 24));
      int64_t v5 = *(void **)(v4 + 16);
    }
  }

  swift_retain((unint64_t *)v4, a2, a3, a4);
  swift_unknownObjectRelease(v5);
  uint64_t v6 = *(void *)(v4 + 40);
  swift_release(v4);
  swift_release(v6);
  swift_deallocClassInstance(v4);
}

unint64_t *_StringGuts.loadUnmanagedBreadcrumbs()(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = a2 & 0xFFFFFFFFFFFFFFFLL;
  if ((a1 & ~a2 & 0x2000000000000000LL) != 0)
  {
    int64_t v5 = (unint64_t *)__StringStorage._breadcrumbsAddress.getter();
    uint64_t v6 = (unint64_t *)atomic_load(v5);
    if (v6) {
      return v6;
    }
  }

  else
  {
    int64_t v5 = (unint64_t *)(v4 + 40);
    uint64_t v6 = (unint64_t *)atomic_load((unint64_t *)(v4 + 40));
    if (v6) {
      return v6;
    }
  }

  uint64_t v7 = type metadata accessor for _StringBreadcrumbs();
  uint64_t v6 = swift_allocObject(v7, 0x20uLL, 7uLL);
  swift_bridgeObjectRetain(a2, v8, v9, v10);
  _StringBreadcrumbs.init(_:)(a1, a2, v11, v12);
  swift_retain(v6, v13, v14, v15);
  while (1)
  {
    unint64_t v16 = __ldaxr(v5);
    if (v16) {
      break;
    }
    if (!__stlxr((unint64_t)v6, v5))
    {
      char v17 = 1;
      goto LABEL_10;
    }
  }

  char v17 = 0;
  __clrex();
LABEL_10:
  swift_release((uint64_t)v6);
  if ((v17 & 1) == 0)
  {
    swift_release((uint64_t)v6);
    return (unint64_t *)v16;
  }

  return v6;
}

uint64_t String.init(_nativeStorage:)(unint64_t a1)
{
  if ((a1 & 0x8000000000000000LL) != 0)
  {
    swift_unknownObjectRelease((id)a1);
    if ((a1 & 0xFF80000000000007LL) == 0xC000000000000007LL)
    {
      uint64_t v3 = a1 & 0x7FFFFFFFFFFFF8LL;
      if (!v3) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x224uLL,  0);
      }
      if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
      {
        if ((*(_BYTE *)(v3 + 8) & 4) != 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
        }
        if ((*(void *)(v3 + 24) & 0x8000000000000000LL) != 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
        }
      }
    }

    return 0LL;
  }

  uint64_t v2 = _swift_classOfObjCHeapObject((void *)a1);
  if (type metadata accessor for __StringStorage() == v2) {
    return *(void *)(a1 + 24);
  }
  if (type metadata accessor for __SharedStringStorage() != v2)
  {
    swift_unknownObjectRelease((id)a1);
    return 0LL;
  }

  return *(void *)(a1 + 32);
}

BOOL specialized _AbstractStringStorage._nativeIsEqual<A>(_:)(uint64_t a1)
{
  size_t v2 = *(void *)(v1 + 32) & 0xFFFFFFFFFFFFLL;
  if (v2 != (*(void *)(a1 + 24) & 0xFFFFFFFFFFFFLL)) {
    return 0LL;
  }
  if (*(void *)(v1 + 24) == a1 + 32) {
    return 1LL;
  }
  return memcmp(*(const void **)(v1 + 24), (const void *)(a1 + 32), v2) == 0;
}

{
  uint64_t v1;
  size_t v2;
  const void *v3;
  size_t v2 = *(void *)(v1 + 24) & 0xFFFFFFFFFFFFLL;
  if (v2 != (*(void *)(a1 + 32) & 0xFFFFFFFFFFFFLL)) {
    return 0LL;
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  return (const void *)(v1 + 32) == v3 || memcmp((const void *)(v1 + 32), v3, v2) == 0;
}

{
  uint64_t v1;
  size_t v2;
  const void *v3;
  size_t v2 = *(void *)(v1 + 32) & 0xFFFFFFFFFFFFLL;
  if (v2 != (*(void *)(a1 + 32) & 0xFFFFFFFFFFFFLL)) {
    return 0LL;
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  return *(const void **)(v1 + 24) == v3 || memcmp(*(const void **)(v1 + 24), v3, v2) == 0;
}

Swift::UInt16 __swiftcall __StringStorage.character(at:)(Swift::Int at)
{
  unint64_t v2 = *(void *)(v1 + 24);
  v3._Swift::UInt64 rawBits = String.UTF16View.index(_:offsetBy:)((Swift::String::Index)15LL, at)._rawBits;
  Swift::UInt64 rawBits = v3._rawBits;
  uint64_t v8 = (v2 >> 59) & 1;
  if ((v1 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  if ((v3._rawBits & 0xC) == 4LL << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v3)._rawBits;
  }
  unint64_t v9 = rawBits >> 16;
  unint64_t v10 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    unint64_t v10 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (v9 >= v10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x1A7uLL,  0);
  }
  if ((v1 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }
  if ((rawBits & 1) == 0) {
    unint64_t v9 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits >> 16;
  }
  swift_bridgeObjectRetain(v1, v4._rawBits, v5._rawBits, (char *)v6._rawBits);
  v11._Swift::UInt32 value = _StringGuts.fastUTF8Scalar(startingAt:)(v9)._value;
  Swift::UInt32 value = v11._value;
  if ((rawBits & 0xC000) == 0x4000)
  {
    if (v11._value < 0x10000) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
    }
    swift_bridgeObjectRelease(v1);
    return value & 0x3FF | 0xDC00;
  }

  else
  {
    swift_bridgeObjectRelease(v1);
    if (HIWORD(value)) {
      return ((value + 67043328) >> 10) - 10240;
    }
    else {
      return value;
    }
  }

uint64_t String.UTF16View.subscript.getter(Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = rawBits >> 16;
  unint64_t v8 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    unint64_t v8 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x1A7uLL,  0);
  }
  if ((a3 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }
  if ((rawBits & 1) == 0) {
    unint64_t v7 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits >> 16;
  }
  v9._Swift::UInt32 value = _StringGuts.fastUTF8Scalar(startingAt:)(v7)._value;
  if ((rawBits & 0xC000) == 0x4000)
  {
    if (!HIWORD(v9._value)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
    }
    return v9._value & 0x3FF | 0xFFFFDC00;
  }

  else if (HIWORD(v9._value))
  {
    return ((v9._value + 67043328) >> 10) - 10240;
  }

  else
  {
    return v9._value;
  }

void __StringStorage.getCharacters(_:range:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a2 < 0 || a3 < 0)
  {
    unint64_t v12 = 49LL;
    goto LABEL_9;
  }

  uint64_t v6 = a2 + a3;
  if (__OFADD__(a2, a3))
  {
    __break(1u);
    goto LABEL_11;
  }

  uint64_t v7 = *(void *)(v4 + 24);
  if ((v7 & 0xFFFFFFFFFFFFLL) < v6)
  {
LABEL_11:
    unint64_t v12 = 54LL;
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/StringStorageBridge.swift",  31LL,  2,  v12,  0);
  }

  if (__OFSUB__(v6, a2))
  {
    __break(1u);
LABEL_13:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  if (a3 < 0) {
    goto LABEL_13;
  }
  swift_bridgeObjectRetain(v4, a2, a3, a4);
  v9._Swift::UInt64 rawBits = 15LL;
  Swift::Int v10 = String.UTF16View._indexRange(for:from:)(a2, v6, v9, v7, v4);
  String.UTF16View._nativeCopy(into:alignedRange:)(a1, v6 - a2, v10, v11, v7, v4);
  swift_bridgeObjectRelease(v4);
}

uint64_t __StringStorage.getCString(_:maxLength:encoding:)(char *__dst, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(v3 + 24);
  if (a3 == 1 && v5 < 0 || a3 == 4)
  {
    if ((v5 & 0xFFFFFFFFFFFFLL) >= a2)
    {
      return 0LL;
    }

    else
    {
      specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v3 + 32), v5 & 0xFFFFFFFFFFFFLL, __dst);
      __dst[*(void *)(v3 + 24) & 0xFFFFFFFFFFFFLL] = 0;
      return 1LL;
    }
  }

  else
  {
    char CStringTrampoline = _swift_stdlib_NSStringGetCStringTrampoline((void *)v3, (uint64_t)__dst, a2, a3);
    if (CStringTrampoline < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    return CStringTrampoline;
  }

uint64_t __StringStorage.isEqualToString(to:)(uint64_t result)
{
  if (result)
  {
    unint64_t v2 = result;
    if (result < 0)
    {
      if ((result & 0xFF80000000000007LL) == 0xC000000000000007LL)
      {
        if ((result & 0x7FFFFFFFFFFFF8LL) == 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x224uLL,  0);
        }
        if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
        {
          if ((*(_BYTE *)((v2 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
          }
          if ((*(void *)((v2 & 0x7FFFFFFFFFFFF8LL) + 0x18) & 0x8000000000000000LL) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
        }
      }
    }

    else
    {
      uint64_t v3 = *v1;
      uint64_t v4 = _swift_classOfObjCHeapObject((void *)result);
      if (v3 == v4)
      {
        size_t v7 = v1[3] & 0xFFFFFFFFFFFFLL;
        if (v7 == (*(void *)(v2 + 24) & 0xFFFFFFFFFFFFLL)) {
          return memcmp(v1 + 4, (const void *)(v2 + 32), v7) == 0;
        }
        return 0LL;
      }

      if (type metadata accessor for __SharedStringStorage() == v4) {
        return specialized _AbstractStringStorage._nativeIsEqual<A>(_:)(v2);
      }
    }

    if ((_isNSString(_:)(v2) & 1) == 0) {
      return 0LL;
    }
    uint64_t v5 = _stdlib_binary_CFStringGetLength(_:)(v2);
    uint64_t v8 = MEMORY[0x1895F8858](v5);
    MEMORY[0x1895F8858](v8);
    char v6 = specialized _withCocoaASCIIPointer<A>(_:requireStableAddress:work:)( v2,  (void (*)(uint64_t *__return_ptr, void *))thunk for @callee_guaranteed (@unowned UnsafePointer<UInt8>) -> (@unowned Bool)partial apply);
    if (v6 == 2)
    {
      return 0LL;
    }

    return v6 & 1;
  }

  return result;
}

Swift::UInt16 __swiftcall __SharedStringStorage.character(at:)(Swift::Int at)
{
  unint64_t v2 = *(void *)(v1 + 32);
  v3._Swift::UInt64 rawBits = String.UTF16View.index(_:offsetBy:)((Swift::String::Index)15LL, at)._rawBits;
  Swift::UInt64 rawBits = v3._rawBits;
  uint64_t v8 = (v2 >> 59) & 1;
  if ((v1 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  if ((v3._rawBits & 0xC) == 4LL << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v3)._rawBits;
  }
  unint64_t v9 = rawBits >> 16;
  unint64_t v10 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    unint64_t v10 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (v9 >= v10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x1A7uLL,  0);
  }
  if ((v1 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }
  if ((rawBits & 1) == 0) {
    unint64_t v9 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits >> 16;
  }
  swift_bridgeObjectRetain(v1, v4._rawBits, v5._rawBits, (char *)v6._rawBits);
  v11._Swift::UInt32 value = _StringGuts.fastUTF8Scalar(startingAt:)(v9)._value;
  Swift::UInt32 value = v11._value;
  if ((rawBits & 0xC000) == 0x4000)
  {
    if (v11._value < 0x10000) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
    }
    swift_bridgeObjectRelease(v1);
    return value & 0x3FF | 0xDC00;
  }

  else
  {
    swift_bridgeObjectRelease(v1);
    if (HIWORD(value)) {
      return ((value + 67043328) >> 10) - 10240;
    }
    else {
      return value;
    }
  }

void __SharedStringStorage.getCharacters(_:range:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a2 < 0 || a3 < 0)
  {
    unint64_t v12 = 49LL;
    goto LABEL_9;
  }

  uint64_t v6 = a2 + a3;
  if (__OFADD__(a2, a3))
  {
    __break(1u);
    goto LABEL_11;
  }

  uint64_t v7 = *(void *)(v4 + 32);
  if ((v7 & 0xFFFFFFFFFFFFLL) < v6)
  {
LABEL_11:
    unint64_t v12 = 54LL;
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/StringStorageBridge.swift",  31LL,  2,  v12,  0);
  }

  if (__OFSUB__(v6, a2))
  {
    __break(1u);
LABEL_13:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  if (a3 < 0) {
    goto LABEL_13;
  }
  swift_bridgeObjectRetain(v4, a2, a3, a4);
  v9._Swift::UInt64 rawBits = 15LL;
  Swift::Int v10 = String.UTF16View._indexRange(for:from:)(a2, v6, v9, v7, v4);
  String.UTF16View._nativeCopy(into:alignedRange:)(a1, v6 - a2, v10, v11, v7, v4);
  swift_bridgeObjectRelease(v4);
}

uint64_t __SharedStringStorage.getCString(_:maxLength:encoding:)(char *__dst, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(v3 + 32);
  if (a3 == 1 && v5 < 0 || a3 == 4)
  {
    if ((v5 & 0xFFFFFFFFFFFFLL) >= a2)
    {
      return 0LL;
    }

    else
    {
      specialized UnsafeMutablePointer.initialize(from:count:)(*(char **)(v3 + 24), v5 & 0xFFFFFFFFFFFFLL, __dst);
      __dst[*(void *)(v3 + 32) & 0xFFFFFFFFFFFFLL] = 0;
      return 1LL;
    }
  }

  else
  {
    char CStringTrampoline = _swift_stdlib_NSStringGetCStringTrampoline((void *)v3, (uint64_t)__dst, a2, a3);
    if (CStringTrampoline < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    return CStringTrampoline;
  }

uint64_t __SharedStringStorage.isEqualToString(to:)(uint64_t result)
{
  if (result)
  {
    unint64_t v2 = result;
    if (result < 0)
    {
      if ((result & 0xFF80000000000007LL) == 0xC000000000000007LL)
      {
        if ((result & 0x7FFFFFFFFFFFF8LL) == 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x224uLL,  0);
        }
        if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
        {
          if ((*(_BYTE *)((v2 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
          }
          if ((*(void *)((v2 & 0x7FFFFFFFFFFFF8LL) + 0x18) & 0x8000000000000000LL) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
        }
      }
    }

    else
    {
      uint64_t v3 = *v1;
      uint64_t v4 = _swift_classOfObjCHeapObject((void *)result);
      if (type metadata accessor for __StringStorage() == v4) {
        return specialized _AbstractStringStorage._nativeIsEqual<A>(_:)(v2);
      }
      if (v3 == v4) {
        return specialized _AbstractStringStorage._nativeIsEqual<A>(_:)(v2);
      }
    }

    if ((_isNSString(_:)(v2) & 1) == 0) {
      return 0LL;
    }
    uint64_t v5 = _stdlib_binary_CFStringGetLength(_:)(v2);
    uint64_t v7 = MEMORY[0x1895F8858](v5);
    MEMORY[0x1895F8858](v7);
    char v6 = specialized _withCocoaASCIIPointer<A>(_:requireStableAddress:work:)( v2,  (void (*)(uint64_t *__return_ptr, void *))thunk for @callee_guaranteed (@unowned UnsafePointer<UInt8>) -> (@unowned Bool)partial apply);
    if (v6 == 2)
    {
      return 0LL;
    }

    return v6 & 1;
  }

  return result;
}

uint64_t __SharedStringStorage.isEqual(to:)(uint64_t result)
{
  if (result)
  {
    unint64_t v2 = result;
    if (result < 0)
    {
      if ((result & 0xFF80000000000007LL) == 0xC000000000000007LL)
      {
        if ((result & 0x7FFFFFFFFFFFF8LL) == 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x224uLL,  0);
        }
        if (_swift_stdlib_dyld_is_objc_constant_string() == 1)
        {
          if ((*(_BYTE *)((v2 & 0x7FFFFFFFFFFFF8LL) + 8) & 4) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
          }
          if ((*(void *)((v2 & 0x7FFFFFFFFFFFF8LL) + 0x18) & 0x8000000000000000LL) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
        }
      }
    }

    else
    {
      uint64_t v3 = *v1;
      uint64_t v4 = _swift_classOfObjCHeapObject((void *)result);
      if (type metadata accessor for __StringStorage() == v4) {
        return specialized _AbstractStringStorage._nativeIsEqual<A>(_:)(v2);
      }
      if (v3 == v4) {
        return specialized _AbstractStringStorage._nativeIsEqual<A>(_:)(v2);
      }
    }

    if ((_isNSString(_:)(v2) & 1) == 0) {
      return 0LL;
    }
    uint64_t v5 = _stdlib_binary_CFStringGetLength(_:)(v2);
    uint64_t v7 = MEMORY[0x1895F8858](v5);
    MEMORY[0x1895F8858](v7);
    char v6 = specialized _withCocoaASCIIPointer<A>(_:requireStableAddress:work:)( v2,  (void (*)(uint64_t *__return_ptr, void *))partial apply for thunk for @callee_guaranteed (@unowned UnsafePointer<UInt8>) -> (@unowned Bool));
    if (v6 == 2)
    {
      return 0LL;
    }

    return v6 & 1;
  }

  return result;
}

Swift::Int __swiftcall _findStringSwitchCase(cases:string:)(Swift::OpaquePointer cases, Swift::String string)
{
  uint64_t v2 = *((void *)cases._rawValue + 2);
  if (v2)
  {
    unint64_t object = (unint64_t)string._object;
    uint64_t countAndFlagsBits = string._countAndFlagsBits;
    Swift::Int v5 = 0LL;
    char v6 = (char *)cases._rawValue + 32;
    do
    {
      uint64_t v7 = &v6[24 * v5];
      char v8 = v7[16];
      if ((v8 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "StaticString should have pointer representation",  47LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x85uLL,  0);
      }
      Swift::String::Index v9 = *(unsigned __int8 **)v7;
      if (!*(void *)v7) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x88uLL,  0);
      }
      uint64_t v10 = *((void *)v7 + 1);
      if (v10 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      if (v10)
      {
        if ((unint64_t)v10 <= 0xF)
        {
          uint64_t v13 = v10 - 8;
          if (v10 >= 8) {
            uint64_t v14 = 8LL;
          }
          else {
            uint64_t v14 = v10;
          }
          uint64_t v11 = *v9;
          if (v14 != 1)
          {
            v11 |= (unint64_t)v9[1] << 8;
            if (v14 != 2)
            {
              v11 |= (unint64_t)v9[2] << 16;
              if (v14 != 3)
              {
                v11 |= (unint64_t)v9[3] << 24;
                if (v14 != 4)
                {
                  v11 |= (unint64_t)v9[4] << 32;
                  if (v14 != 5)
                  {
                    v11 |= (unint64_t)v9[5] << 40;
                    if (v14 != 6)
                    {
                      v11 |= (unint64_t)v9[6] << 48;
                      if (v14 != 7) {
                        v11 |= (unint64_t)v9[7] << 56;
                      }
                    }
                  }
                }
              }
            }
          }

          uint64_t v15 = 0LL;
          if ((unint64_t)v10 >= 9)
          {
            uint64_t v16 = 0LL;
            char v17 = v9 + 8;
            unint64_t v18 = v13 & ~(v13 >> 63);
            do
            {
              if (v18 <= v10 - 9) {
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
              }
              unsigned int v19 = *v17++;
              v15 |= (unint64_t)v19 << v16;
              v16 += 8LL;
              --v13;
            }

            while (v13);
          }

          unint64_t v20 = 0xA000000000000000LL;
          if (((v15 | v11) & 0x8080808080808080LL) == 0) {
            unint64_t v20 = 0xE000000000000000LL;
          }
          unint64_t v12 = v20 | (v10 << 56) | v15;
          if (v11 != countAndFlagsBits) {
            goto LABEL_34;
          }
        }

        else
        {
          if ((v8 & 2) != 0) {
            v10 |= 0xC000000000000000LL;
          }
          uint64_t v11 = v10 | 0x1000000000000000LL;
          unint64_t v12 = (unint64_t)(v9 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
          if ((v10 | 0x1000000000000000LL) != countAndFlagsBits) {
            goto LABEL_34;
          }
        }
      }

      else
      {
        uint64_t v11 = 0LL;
        unint64_t v12 = 0xE000000000000000LL;
        if (countAndFlagsBits) {
          goto LABEL_34;
        }
      }

      if (v12 == object)
      {
        swift_bridgeObjectRelease(v12);
        return v5;
      }

Swift::Int __swiftcall _findStringSwitchCaseWithCache(cases:string:cache:)( Swift::OpaquePointer cases, Swift::String string, Swift::_OpaqueStringSwitchCache *cache)
{
  unint64_t object = string._object;
  unint64_t countAndFlagsBits = string._countAndFlagsBits;
  context[2] = *MEMORY[0x1895F89C0];
  p_b = &cache->b;
  Builtin::Word a = cache->a;
  context[0] = cases._rawValue;
  context[1] = &cache->b;
  if (a != -1LL) {
    swift_once((dispatch_once_t *)cache, (dispatch_function_t)@objc _createStringTableCache(_:), context);
  }
  unint64_t v7 = *p_b;
  if (!*(void *)(v7 + 16)) {
    return -1LL;
  }
  swift_bridgeObjectRetain(v7, string._countAndFlagsBits, (uint64_t)string._object, (char *)cache);
  unint64_t v8 = specialized __RawDictionaryStorage.find<A>(_:)(countAndFlagsBits, (unint64_t)object);
  if ((v9 & 1) != 0) {
    Swift::Int v10 = *(void *)(*(void *)(v7 + 56) + 8 * v8);
  }
  else {
    Swift::Int v10 = -1LL;
  }
  swift_bridgeObjectRelease(v7);
  return v10;
}

uint64_t UnsafeMutableRawPointer.bindMemory<A>(to:capacity:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

Swift::Void __swiftcall _createStringTableCache(_:)(Builtin::RawPointer a1)
{
  unint64_t v4 = *(void *)a1;
  Swift::Int v5 = (void *)*((void *)a1 + 1);
  unint64_t v6 = *(void *)(*(void *)a1 + 16LL);
  swift_bridgeObjectRetain(*(void *)a1, v1, v2, v3);
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)&_swiftEmptyDictionarySingleton);
  unsigned int v38 = v5;
  if (qword_18C4714C0 >= v6)
  {
    if (!isUniquelyReferenced_nonNull_native) {
      specialized _NativeDictionary.copy()();
    }
  }

  else
  {
    if (isUniquelyReferenced_nonNull_native)
    {
      uint64_t v8 = v6;
      char v9 = 1;
    }

    else
    {
      uint64_t v8 = v6;
      char v9 = 0;
    }

    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v8, v9);
  }

  swift_bridgeObjectRelease(0x8000000000000000LL);
  uint64_t v10 = *(void *)(v4 + 16);
  swift_bridgeObjectRetain(v4, v11, v12, v13);
  if (v10)
  {
    for (unint64_t i = 0LL; i != v10; ++i)
    {
      if (i >= *(void *)(v4 + 16)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      uint64_t v15 = v4 + 32 + 24 * i;
      char v16 = *(_BYTE *)(v15 + 16);
      if ((v16 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "StaticString should have pointer representation",  47LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x85uLL,  0);
      }
      char v17 = *(unsigned __int8 **)v15;
      if (!*(void *)v15) {
        goto LABEL_57;
      }
      uint64_t v18 = *(void *)(v15 + 8);
      if (v18 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      if (v18)
      {
        if ((unint64_t)v18 <= 0xF)
        {
          uint64_t v21 = v18 - 8;
          uint64_t v22 = 8LL;
          if (v18 < 8) {
            uint64_t v22 = v18;
          }
          unint64_t v19 = *v17;
          if (v22 != 1)
          {
            v19 |= (unint64_t)v17[1] << 8;
            if (v22 != 2)
            {
              v19 |= (unint64_t)v17[2] << 16;
              if (v22 != 3)
              {
                v19 |= (unint64_t)v17[3] << 24;
                if (v22 != 4)
                {
                  v19 |= (unint64_t)v17[4] << 32;
                  if (v22 != 5)
                  {
                    v19 |= (unint64_t)v17[5] << 40;
                    if (v22 != 6)
                    {
                      v19 |= (unint64_t)v17[6] << 48;
                      if (v22 != 7) {
                        v19 |= (unint64_t)v17[7] << 56;
                      }
                    }
                  }
                }
              }
            }
          }

          uint64_t v23 = 0LL;
          if ((unint64_t)v18 >= 9)
          {
            uint64_t v24 = 0LL;
            unint64_t v25 = v17 + 8;
            unint64_t v26 = v21 & ~(v21 >> 63);
            do
            {
              if (v26 <= v18 - 9) {
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
              }
              unsigned int v27 = *v25++;
              v23 |= (unint64_t)v27 << v24;
              v24 += 8LL;
              --v21;
            }

            while (v21);
          }

          unint64_t v28 = 0xA000000000000000LL;
          if (((v23 | v19) & 0x8080808080808080LL) == 0) {
            unint64_t v28 = 0xE000000000000000LL;
          }
          unint64_t v20 = v28 | (v18 << 56) | v23;
        }

        else
        {
          if ((v16 & 2) != 0) {
            v18 |= 0xC000000000000000LL;
          }
          unint64_t v19 = v18 | 0x1000000000000000LL;
          unint64_t v20 = (unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
        }
      }

      else
      {
        unint64_t v19 = 0LL;
        unint64_t v20 = 0xE000000000000000LL;
      }

      char v29 = swift_isUniquelyReferenced_nonNull_native((uint64_t)&_swiftEmptyDictionarySingleton);
      unint64_t v31 = specialized __RawDictionaryStorage.find<A>(_:)(v19, v20);
      BOOL v32 = (v30 & 1) == 0;
      uint64_t v33 = qword_18C4714B8 + v32;
      if (__OFADD__(qword_18C4714B8, v32))
      {
        __break(1u);
LABEL_56:
        __break(1u);
LABEL_57:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  0x88uLL,  0);
      }

      char v34 = v30;
      if (qword_18C4714C0 >= v33)
      {
        if ((v29 & 1) != 0)
        {
          if ((v30 & 1) != 0) {
            goto LABEL_10;
          }
        }

        else
        {
          specialized _NativeDictionary.copy()();
          if ((v34 & 1) != 0) {
            goto LABEL_10;
          }
        }
      }

      else
      {
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v33, v29);
        unint64_t v35 = specialized __RawDictionaryStorage.find<A>(_:)(v19, v20);
        if ((v34 & 1) != (v36 & 1)) {
          KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
        }
        unint64_t v31 = v35;
        if ((v34 & 1) != 0)
        {
LABEL_10:
          swift_bridgeObjectRelease(v20);
          *(void *)(qword_18C4714E0 + 8 * v31) = i;
          goto LABEL_11;
        }
      }

      *(&_swiftEmptyDictionarySingleton + (v31 >> 6) + 8) = (__objc2_class *)((unint64_t)*(&_swiftEmptyDictionarySingleton
                                                                                                + (v31 >> 6)
                                                                                                + 8) | (1LL << v31));
      uint64_t v37 = (unint64_t *)(qword_18C4714D8 + 16 * v31);
      *uint64_t v37 = v19;
      v37[1] = v20;
      *(void *)(qword_18C4714E0 + 8 * v31) = i;
      if (__OFADD__(qword_18C4714B8, 1LL)) {
        goto LABEL_56;
      }
      ++qword_18C4714B8;
LABEL_11:
      swift_bridgeObjectRelease(0x8000000000000000LL);
    }
  }

  swift_bridgeObjectRelease(v4);
  void *v38 = &_swiftEmptyDictionarySingleton;
  swift_bridgeObjectRelease(v4);
}

uint64_t _StringRepresentation._isASCII.getter()
{
  return *v0;
}

uint64_t _StringRepresentation._isASCII.setter(uint64_t result)
{
  _BYTE *v1 = result;
  return result;
}

uint64_t (*_StringRepresentation._isASCII.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _StringRepresentation._count.getter()
{
  return *(void *)(v0 + 8);
}

uint64_t _StringRepresentation._count.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*_StringRepresentation._count.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _StringRepresentation._capacity.getter()
{
  return *(void *)(v0 + 16);
}

uint64_t _StringRepresentation._capacity.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*_StringRepresentation._capacity.modify())()
{
  return EnumeratedSequence._base.modify;
}

id _StringRepresentation._form.getter@<X0>(uint64_t a1@<X2>, char *a2@<X3>, uint64_t a3@<X8>)
{
  unint64_t v4 = *(void **)(v3 + 24);
  *(void *)a3 = v4;
  uint64_t v5 = *(unsigned __int8 *)(v3 + 32);
  *(_BYTE *)(a3 + 8) = v5;
  return outlined copy of _StringRepresentation._Form(v4, v5, a1, a2);
}

void _StringRepresentation._form.setter(uint64_t *a1)
{
  uint64_t v2 = *a1;
  char v3 = *((_BYTE *)a1 + 8);
  outlined consume of _StringRepresentation._Form(*(id *)(v1 + 24), *(_BYTE *)(v1 + 32));
  *(void *)(v1 + 24) = v2;
  *(_BYTE *)(v1 + 32) = v3;
}

uint64_t (*_StringRepresentation._form.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _StringRepresentation._objectIdentifier.getter()
{
  if (*(_BYTE *)(v0 + 32)) {
    uint64_t v1 = 0LL;
  }
  else {
    uint64_t v1 = *(void *)(v0 + 24);
  }
  if (*(_BYTE *)(v0 + 32) == 1) {
    return *(void *)(v0 + 24);
  }
  else {
    return v1;
  }
}

unint64_t *_StringGuts._classify()@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if ((a2 & 0x2000000000000000LL) != 0)
  {
    uint64_t result = (unint64_t *)_StringGuts.nativeCapacity.getter(a1, a2);
    *(_BYTE *)a3 = (a2 & 0x4000000000000000LL) != 0;
    *(void *)(a3 + 8) = HIBYTE(a2) & 0xF;
    *(_OWORD *)(a3 + 16) = xmmword_1817FFE10;
    char v12 = 3;
LABEL_10:
    *(_BYTE *)(a3 + 32) = v12;
    return result;
  }

  uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
  uint64_t result = (unint64_t *)_StringGuts.nativeCapacity.getter(a1, a2);
  if ((v8 & 1) != 0) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = result;
  }
  if ((a2 & 0x4000000000000000LL) != 0)
  {
    *(_BYTE *)a3 = a1 < 0;
    *(void *)(a3 + 8) = v6;
    *(void *)(a3 + 16) = v11;
    *(void *)(a3 + 24) = a2 & 0xFFFFFFFFFFFFFFFLL;
    *(_BYTE *)(a3 + 32) = 0;
    return (unint64_t *)swift_unknownObjectRetain((id)(a2 & 0xFFFFFFFFFFFFFFFLL), v8, v9, v10);
  }

  if ((a2 & 0x8000000000000000LL) != 0)
  {
    *(_BYTE *)a3 = a1 < 0;
    *(void *)(a3 + 8) = v6;
    *(void *)(a3 + 16) = v11;
    *(void *)(a3 + 24) = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    char v12 = 2;
    goto LABEL_10;
  }

  if ((a1 & ~a2 & 0x2000000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringTesting.swift",  25LL,  2,  0x5DuLL,  0);
  }
  *(_BYTE *)a3 = a1 < 0;
  *(void *)(a3 + 8) = v6;
  *(void *)(a3 + 16) = v11;
  *(void *)(a3 + 24) = a2 & 0xFFFFFFFFFFFFFFFLL;
  *(_BYTE *)(a3 + 32) = 1;
  return swift_retain((unint64_t *)(a2 & 0xFFFFFFFFFFFFFFFLL), v8, v9, v10);
}

char *UnsafeMutableRawPointer.initializeMemory<A>(as:from:count:)( int a1, char *a2, uint64_t a3, char *__dst, uint64_t a5)
{
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.initializeMemory with negative count",  60LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x492uLL,  0);
  }
  uint64_t v5 = *(void *)(*(void *)(a5 - 8) + 72LL);
  uint64_t v6 = a3 * v5;
  if ((unsigned __int128)(a3 * (__int128)v5) >> 64 != (a3 * v5) >> 63)
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v8 = &__dst[v6];
  unint64_t v9 = (unint64_t)&a2[v6];
  if (v8 > a2 && v9 > (unint64_t)__dst) {
LABEL_10:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.initializeMemory overlapping range",  58LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x495uLL,  0);
  swift_arrayInitWithCopy(__dst, a2, a3, a5);
  return __dst;
}

uint64_t UnsafeMutableRawBufferPointer.subscript.setter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xC1uLL,  0);
  }
  if (!a3 || a4 - a3 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0xC2uLL,  0);
  }
  *(_BYTE *)(a3 + a2) = result;
  return result;
}

uint64_t (*String.UnicodeScalarView._guts.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::String::Index __swiftcall String.UnicodeScalarView.index(after:)(Swift::String::Index after)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(after)._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0) {
    return String.UnicodeScalarView._foreignIndex(after:)(v5);
  }
  Swift::UInt64 v6 = v5._rawBits >> 16;
  if ((v3 & 0x2000000000000000LL) != 0)
  {
    v12[0] = v4;
    v12[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    int v8 = *((unsigned __int8 *)v12 + v6);
  }

  else
  {
    if ((v4 & 0x1000000000000000LL) != 0) {
      unint64_t v7 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      unint64_t v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
    }
    int v8 = v7[v6];
  }

  int v9 = (char)v8;
  unsigned int v10 = __clz(v8 ^ 0xFF) - 24;
  if (v9 >= 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
  }
  return (Swift::String::Index)(((v6 + v10) << 16) | 5);
}

Swift::Int __swiftcall _StringGuts.fastUTF8ScalarLength(startingAt:)(Swift::Int startingAt)
{
  if ((v2 & 0x2000000000000000LL) != 0)
  {
    v9[0] = v1;
    v9[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    int v5 = *((unsigned __int8 *)v9 + startingAt);
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0) {
      uint64_t v4 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v4 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v1, v2);
    }
    int v5 = v4[startingAt];
  }

  int v6 = (char)v5;
  unsigned int v7 = __clz(v5 ^ 0xFF) - 24;
  if (v6 >= 0) {
    LOBYTE(v7) = 1;
  }
  return v7;
}

Swift::String::Index __swiftcall String.UnicodeScalarView._foreignIndex(after:)(Swift::String::Index after)
{
  Swift::UInt16 v2 = _StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:)(after);
  uint64_t v3 = 0x10000LL;
  if (v2 >> 10 == 54) {
    uint64_t v3 = 0x20000LL;
  }
  return (Swift::String::Index)((v3 + after._rawBits) & 0xFFFFFFFFFFFF0000LL | 9);
}

Swift::String::Index __swiftcall String.UnicodeScalarView._foreignIndex(before:)(Swift::String::Index before)
{
  Swift::UInt16 v2 = _StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:)((Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000LL)
                                                                                - 0x10000));
  uint64_t v3 = -65536LL;
  if (v2 >> 10 == 55) {
    uint64_t v3 = -131072LL;
  }
  return (Swift::String::Index)((v3 + before._rawBits) & 0xFFFFFFFFFFFF0000LL | 9);
}

uint64_t String.UnicodeScalarView.subscript.getter(Swift::String::Index a1, uint64_t a2, uint64_t a3)
{
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(a1)._rawBits;
  if ((a3 & 0x1000000000000000LL) != 0) {
    return *(_OWORD *)&_StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v5._rawBits & 0xFFFFFFFFFFFF0000LL));
  }
  Swift::UInt64 v7 = v5._rawBits >> 16;
  if ((a3 & 0x2000000000000000LL) != 0)
  {
    v10[0] = a2;
    v10[1] = a3 & 0xFFFFFFFFFFFFFFLL;
    return _decodeScalar(_:startingAt:)((uint64_t)v10, v6._rawBits, v7);
  }

  else
  {
    if ((a2 & 0x1000000000000000LL) != 0) {
      id v8 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      id v8 = _StringObject.sharedUTF8.getter(a2, a3);
    }
    return _decodeScalar(_:startingAt:)((uint64_t)v8, v6._rawBits, v7);
  }

Swift::tuple_Unicode_Scalar_scalarLength_Int __swiftcall _StringGuts.errorCorrectedScalar(startingAt:)( Swift::Int startingAt)
{
  if ((v2 & 0x1000000000000000LL) != 0)
  {
    Swift::tuple_Unicode_Scalar_scalarLength_Int v7 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(startingAt << 16));
    Swift::Int scalarLength = v7.scalarLength;
    Swift::UInt32 value = v7._0._value;
  }

  else if ((v2 & 0x2000000000000000LL) != 0)
  {
    v8[0] = v1;
    v8[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)v8, v1, startingAt);
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0) {
      id v4 = (id)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      id v4 = _StringObject.sharedUTF8.getter(v1, v2);
    }
    Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)v4, v1, startingAt);
  }

  result.Swift::Int scalarLength = scalarLength;
  result._0._Swift::UInt32 value = value;
  return result;
}

Swift::String::Index_optional __swiftcall String.UnicodeScalarView.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  Swift::UInt64 rawBits = limitedBy._rawBits;
  uint64_t v10 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((limitedBy._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(limitedBy)._rawBits;
  }
  Swift::UInt64 v12 = _._rawBits;
  if ((_._rawBits & 0xC) == v11) {
    Swift::UInt64 v12 = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  }
  v13._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(_)._rawBits;
  Swift::UInt64 v14 = rawBits >> 14;
  if ((offsetBy & 0x8000000000000000LL) == 0)
  {
    Swift::UInt64 v15 = v12 >> 14;
    if (offsetBy)
    {
      if ((v5 & 0x2000000000000000LL) != 0) {
        Swift::UInt64 v16 = HIBYTE(v5) & 0xF;
      }
      else {
        Swift::UInt64 v16 = v6 & 0xFFFFFFFFFFFFLL;
      }
      while (1)
      {
        if (v14 >= v15 && v13._rawBits >> 14 >= v14) {
          goto LABEL_51;
        }
        Swift::UInt64 v17 = v13._rawBits >> 16;
        if (v13._rawBits >> 16 >= v16) {
          break;
        }
        if ((v5 & 0x1000000000000000LL) != 0)
        {
          v13._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v13)._rawBits;
          if (!--offsetBy) {
            goto LABEL_26;
          }
        }

        else
        {
          if ((v5 & 0x2000000000000000LL) != 0)
          {
            uint64_t v35 = v6;
            uint64_t v36 = v5 & 0xFFFFFFFFFFFFFFLL;
            int v19 = *((unsigned __int8 *)&v35 + v17);
          }

          else
          {
            uint64_t v18 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
            if ((v6 & 0x1000000000000000LL) == 0) {
              uint64_t v18 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v6, v5);
            }
            int v19 = v18[v17];
          }

          int v20 = (char)v19;
          unsigned int v21 = __clz(v19 ^ 0xFF) - 24;
          if (v20 >= 0) {
            LOBYTE(v21) = 1;
          }
          v13._Swift::UInt64 rawBits = ((v17 + v21) << 16) | 5;
          if (!--offsetBy) {
            goto LABEL_26;
          }
        }
      }

      unint64_t v33 = 229LL;
LABEL_55:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  v33,  0);
    }

Swift::UInt64 protocol witness for BidirectionalCollection.index(before:) in conformance String.UnicodeScalarView@<X0>( Swift::String::Index *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v4 = v2[1];
  v6._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if (!(v6._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  Swift::UInt64 rawBits = v6._rawBits;
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(before:)(v6)._rawBits;
  }

  else
  {
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      v17[0] = v5;
      v17[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      Swift::UInt64 v12 = (char *)v17 + (v6._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        uint64_t v13 = 0LL;
        Swift::UInt64 v14 = v12 - 2;
        do
          int v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        uint64_t v11 = 1 - v13;
      }

      else
      {
        uint64_t v11 = 1LL;
      }
    }

    else
    {
      if ((v5 & 0x1000000000000000LL) != 0) {
        id v8 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        id v8 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
      }
      uint64_t v9 = 0LL;
      do
        int v10 = v8[(rawBits >> 16) - 1 + v9--] & 0xC0;
      while (v10 == 128);
      uint64_t v11 = -v9;
    }

    Swift::UInt64 result = (rawBits - (v11 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
  }

  *a2 = result;
  return result;
}

Swift::UInt64 protocol witness for BidirectionalCollection.formIndex(before:) in conformance String.UnicodeScalarView( Swift::String::Index *a1)
{
  uint64_t v4 = *v1;
  uint64_t v3 = v1[1];
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  Swift::UInt64 rawBits = v5._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(before:)(v5)._rawBits;
  }

  else
  {
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      v16[0] = v4;
      v16[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v11 = (char *)v16 + (v5._rawBits >> 16);
      if ((*(v11 - 1) & 0xC0) == 0x80)
      {
        uint64_t v12 = 0LL;
        uint64_t v13 = v11 - 2;
        do
          int v14 = v13[v12--] & 0xC0;
        while (v14 == 128);
        uint64_t v10 = 1 - v12;
      }

      else
      {
        uint64_t v10 = 1LL;
      }
    }

    else
    {
      if ((v4 & 0x1000000000000000LL) != 0) {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v7 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v7 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      uint64_t v8 = 0LL;
      do
        int v9 = v7[(rawBits >> 16) - 1 + v8--] & 0xC0;
      while (v9 == 128);
      uint64_t v10 = -v8;
    }

    Swift::UInt64 result = (rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
  }

  a1->_Swift::UInt64 rawBits = result;
  return result;
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance String.UnicodeScalarView@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = String.UnicodeScalarView.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String.UnicodeScalarView@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void, void, void))String.UnicodeScalarView.index(_:offsetBy:limitedBy:),  a4);
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance String.UnicodeScalarView( Swift::String::Index *a1, Swift::String::Index *a2)
{
  return String.UnicodeScalarView.distance(from:to:)( (Swift::String::Index)a1->_rawBits,  (Swift::String::Index)a2->_rawBits);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance String.UnicodeScalarView( uint64_t *a1, Swift::String::Index *a2))()
{
  uint64_t v5 = *v2;
  uint64_t v4 = v2[1];
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a2->_rawBits)._rawBits;
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v6._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
  }

  else
  {
    Swift::UInt64 v8 = v6._rawBits >> 16;
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      *a1 = v5;
      a1[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      id v9 = a1;
    }

    else if ((v5 & 0x1000000000000000LL) != 0)
    {
      id v9 = (id)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      id v9 = _StringObject.sharedUTF8.getter(v5, v4);
    }

    int value = _decodeScalar(_:startingAt:)((uint64_t)v9, v7._rawBits, v8);
  }

  *(_DWORD *)a1 = value;
  return EnumeratedSequence._base.modify;
}

unint64_t protocol witness for Collection.subscript.getter in conformance String.UnicodeScalarView@<X0>( Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  v4._Swift::UInt64 rawBits = a1[1];
  v5._Swift::UInt64 rawBits = *a1;
  *a2 = specialized String.UnicodeScalarView.subscript.getter(v5, v4, *v2, v2[1]);
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = (Swift::UInt64)v8;
  return swift_bridgeObjectRetain((unint64_t)v8, v6, v7, v8);
}

Swift::UInt64 String.UnicodeScalarView.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 v4 = specialized String.UnicodeScalarView.subscript.getter(a1, a2, a3, a4);
  swift_bridgeObjectRetain((unint64_t)v7, v5, v6, v7);
  return v4;
}

unint64_t protocol witness for Collection.indices.getter in conformance String@<X0>(void *a1@<X8>)
{
  *a1 = v2;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return swift_bridgeObjectRetain(v3, v3, v4, v5);
}

BOOL protocol witness for Collection.isEmpty.getter in conformance String.UnicodeScalarView()
{
  return specialized Collection.isEmpty.getter(*(void *)v0, *(void *)(v0 + 8));
}

Swift::String::Index protocol witness for Collection.count.getter in conformance String.UnicodeScalarView()
{
  return specialized Collection.count.getter(*(void *)v0, *(void *)(v0 + 8));
}

unint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance String.UnicodeScalarView( unint64_t *a1, unint64_t *a2)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(*a1, *a2, a2[1]);
}

{
  return specialized Collection._failEarlyRangeCheck(_:bounds:)(*a1, *a2, a2[1]);
}

{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(*a1, a1[1], *a2, a2[1]);
}

Swift::UInt64 protocol witness for Collection.index(after:) in conformance String.UnicodeScalarView@<X0>( Swift::String::Index *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v4 = v2[1];
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }

  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      v13[0] = v5;
      v13[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      int v9 = *((unsigned __int8 *)v13 + v7);
    }

    else
    {
      if ((v5 & 0x1000000000000000LL) != 0) {
        Swift::UInt64 v8 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt64 v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v4);
      }
      int v9 = v8[v7];
    }

    int v10 = (char)v9;
    unsigned int v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0) {
      LOBYTE(v11) = 1;
    }
    Swift::UInt64 result = ((v7 + v11) << 16) | 5;
  }

  *a2 = result;
  return result;
}

Swift::UInt64 protocol witness for Collection.formIndex(after:) in conformance String.UnicodeScalarView( Swift::String::Index *a1)
{
  uint64_t v4 = *v1;
  uint64_t v3 = v1[1];
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v5)._rawBits;
  }

  else
  {
    Swift::UInt64 v6 = v5._rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      v12[0] = v4;
      v12[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      int v8 = *((unsigned __int8 *)v12 + v6);
    }

    else
    {
      if ((v4 & 0x1000000000000000LL) != 0) {
        Swift::UInt64 v7 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt64 v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      int v8 = v7[v6];
    }

    int v9 = (char)v8;
    unsigned int v10 = __clz(v8 ^ 0xFF) - 24;
    if (v9 >= 0) {
      LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
    }
    Swift::UInt64 result = ((v6 + v10) << 16) | 5;
  }

  a1->_Swift::UInt64 rawBits = result;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance String(void *a1@<X8>)
{
  unint64_t v2 = v1[1];
  uint64_t v3 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v3 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  *a1 = *v1;
  a1[1] = v2;
  a1[2] = 0LL;
  a1[3] = v3;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance String.UnicodeScalarView( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance String( a1,  a2,  (uint64_t (*)(void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance String.UnicodeScalarView( uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *(void *)v3, *(void *)(v3 + 8));
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance String.UnicodeScalarView@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySuqd__Isgyrzo_s7UInt128V5WordsVABsAG_pAKRszr__lIetMgyrzo_Tpq5( a1,  a2);
}

uint64_t String.UnicodeScalarView.Iterator._guts.getter( uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  return a1;
}

void String.UnicodeScalarView.Iterator._guts.setter(uint64_t a1, uint64_t a2)
{
  void *v2 = a1;
  v2[1] = a2;
}

uint64_t (*String.UnicodeScalarView.Iterator._guts.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.UnicodeScalarView.Iterator._position.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t String.UnicodeScalarView.Iterator._position.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*String.UnicodeScalarView.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.UnicodeScalarView.Iterator._end.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t String.UnicodeScalarView.Iterator._end.setter(uint64_t result)
{
  *(void *)(v1 + 24) = result;
  return result;
}

uint64_t (*String.UnicodeScalarView.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance String.UnicodeScalarView.Iterator@<X0>( uint64_t a1@<X8>)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = v1[3];
  if (v3 >= v4)
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v5 = *v1;
    uint64_t v6 = v1[1];
    if ((v6 & 0x1000000000000000LL) != 0)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v10 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v3 << 16));
      Swift::Int scalarLength = v10.scalarLength;
      uint64_t result = *(void *)&v10._0._value;
    }

    else
    {
      if ((v6 & 0x2000000000000000LL) != 0)
      {
        v11[0] = *v1;
        v11[1] = v6 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt64 v7 = v11;
      }

      else if ((v5 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v7 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        Swift::UInt64 v7 = _StringObject.sharedUTF8.getter(*v1, v1[1]);
      }

      uint64_t result = _decodeScalar(_:startingAt:)((uint64_t)v7, v5, v3);
    }

    v1[2] += scalarLength;
  }

  *(_DWORD *)a1 = result;
  *(_BYTE *)(a1 + 4) = v3 >= v4;
  return result;
}

uint64_t String.UnicodeScalarView.debugDescription.getter(uint64_t a1, unint64_t x1_0)
{
  uint64_t v4 = specialized static String._createEmpty(withInitialCapacity:)(27LL);
  unint64_t v8 = v4;
  unint64_t v9 = v5;
  unint64_t v256 = v4;
  unint64_t v257 = v5;
  uint64_t v10 = HIBYTE(v5) & 0xF;
  uint64_t v11 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000LL) != 0) {
    uint64_t v12 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v12 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (!v12 && (v4 & ~v5 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v5);
    unint64_t v256 = 0xD000000000000018LL;
    unint64_t v257 = 0x80000001818B76F0LL | 0x8000000000000000LL;
    goto LABEL_86;
  }

  if ((v5 & 0x2000000000000000LL) != 0 && (0x80000001818B76F0LL & 0x2000000000000000LL) != 0)
  {
    unint64_t v13 = v10 + ((0x80000001818B76F0LL >> 56) & 0xF);
    if (v13 <= 0xF)
    {
      unint64_t v40 = (0x80000001818B76F0LL >> 56) & 0xF;
      if (v40)
      {
        char v68 = 0;
        uint64_t v69 = 0LL;
        unint64_t v41 = v5;
        do
        {
          uint64_t v70 = v10 + v69;
          uint64_t v71 = v69 + 1;
          unint64_t v72 = 0x80000001818B76F0LL | 0x8000000000000000LL;
          if (v69 < 8) {
            unint64_t v72 = 0xD000000000000018LL;
          }
          unint64_t v73 = v72 >> (v68 & 0x38);
          char v74 = (8 * v10 + v68) & 0x38;
          uint64_t v75 = (-255LL << v74) - 1;
          unint64_t v76 = (unint64_t)v73 << v74;
          unint64_t v77 = v76 | v75 & v41;
          unint64_t v78 = v76 | v75 & v8;
          if (v70 < 8) {
            unint64_t v8 = v78;
          }
          else {
            unint64_t v41 = v77;
          }
          v68 += 8;
          uint64_t v69 = v71;
        }

        while (v40 != v71);
      }

      else
      {
        unint64_t v41 = v5;
      }

      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
      unint64_t v79 = 0xA000000000000000LL;
      if (!(v8 & 0x8080808080808080LL | v41 & 0x80808080808080LL)) {
        unint64_t v79 = 0xE000000000000000LL;
      }
      unint64_t v67 = v79 & 0xFF00000000000000LL | (v13 << 56) | v41 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_85;
    }
  }

  if ((0x80000001818B76F0LL & 0x2000000000000000LL) != 0) {
    unint64_t v14 = (0x80000001818B76F0LL >> 56) & 0xF;
  }
  else {
    unint64_t v14 = 24LL;
  }
  swift_bridgeObjectRetain_n(0x80000001818B76F0LL | 0x8000000000000000LL, 2LL, v6, v7);
  if ((0x80000001818B76F0LL & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(0x80000001818B76F0LL | 0x8000000000000000LL, 4LL, v15, v16);
    Swift::Int v17 = v14;
    if ((v9 & 0x1000000000000000LL) == 0) {
      goto LABEL_14;
    }
LABEL_274:
    Swift::Int v237 = String.UTF8View._foreignCount()();
    Swift::Int v19 = v237 + v17;
    if (!__OFADD__(v237, v17)) {
      goto LABEL_15;
    }
LABEL_276:
    __break(1u);
LABEL_277:
    unint64_t v238 = 816LL;
LABEL_278:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  v238,  0);
  }

  swift_bridgeObjectRetain_n(0x80000001818B76F0LL | 0x8000000000000000LL, 5LL, v15, v16);
  v233._Swift::UInt64 rawBits = 1LL;
  v234._Swift::UInt64 rawBits = (v14 << 16) | 1;
  v235._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v233,  v234,  0xD000000000000018LL,  0x80000001818B76F0LL | 0x8000000000000000LL);
  if (v235._rawBits < 0x10000) {
    v235._rawBits |= 3;
  }
  Swift::Int v17 = specialized Collection.count.getter( v235,  v236,  0xD000000000000018LL,  0x80000001818B76F0LL | 0x8000000000000000LL);
  swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
  if ((v9 & 0x1000000000000000LL) != 0) {
    goto LABEL_274;
  }
LABEL_14:
  BOOL v18 = __OFADD__(v12, v17);
  Swift::Int v19 = v12 + v17;
  if (v18) {
    goto LABEL_276;
  }
LABEL_15:
  unint64_t v20 = v8 & ~v9;
  if ((v20 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v19 > 15) {
      goto LABEL_23;
    }
    if ((v9 & 0x2000000000000000LL) == 0) {
      goto LABEL_48;
    }
    goto LABEL_56;
  }

  int64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
  if ((v22 & 1) != 0)
  {
LABEL_284:
    unint64_t v239 = 258LL;
    goto LABEL_285;
  }

  if (v19 > 15) {
    goto LABEL_23;
  }
  if ((v9 & 0x2000000000000000LL) != 0)
  {
LABEL_56:
    swift_bridgeObjectRelease_n(0x80000001818B76F0LL | 0x8000000000000000LL, 5LL);
    unint64_t v39 = v9;
LABEL_57:
    v45._Swift::UInt64 rawBits = (v14 << 16) | 1;
    v46._Swift::UInt64 rawBits = 1LL;
    v47._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v46,  v45,  0xD000000000000018LL,  0x80000001818B76F0LL | 0x8000000000000000LL);
    if (v47._rawBits < 0x10000) {
      v47._rawBits |= 3;
    }
    unint64_t v49 = specialized String.init(_:)(v47, v48, 0xD000000000000018LL, 0x80000001818B76F0LL | 0x8000000000000000LL);
    unint64_t v51 = v50;
    swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
    if ((v51 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v51);
    }

    else if ((v51 & 0x1000000000000000LL) != 0)
    {
      unint64_t v49 = _StringGuts._foreignConvertedToSmall()(v49, v51);
      unint64_t v244 = v243;
      swift_bridgeObjectRelease(v51);
      unint64_t v51 = v244;
    }

    else
    {
      if ((v49 & 0x1000000000000000LL) != 0)
      {
        uint64_t v240 = (unsigned __int8 *)((v51 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v241 = v49 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v240 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v49, v51);
      }

      closure #1 in _StringGuts._convertedToSmall()(v240, v241, &v255);
      swift_bridgeObjectRelease(v51);
      unint64_t v49 = v255;
      unint64_t v51 = *((void *)&v255 + 1);
    }

    uint64_t v52 = HIBYTE(v39) & 0xF;
    uint64_t v53 = HIBYTE(v51) & 0xF;
    uint64_t v54 = v53 + v52;
    if ((unint64_t)(v53 + v52) <= 0xF)
    {
      if (v53)
      {
        char v55 = 0;
        unint64_t v56 = 0LL;
        do
        {
          unint64_t v57 = v52 + v56;
          unint64_t v58 = v56 + 1;
          if (v56 >= 8) {
            unint64_t v59 = v51;
          }
          else {
            unint64_t v59 = v49;
          }
          unint64_t v60 = v59 >> (v55 & 0x38);
          char v61 = (8 * v52 + v55) & 0x38;
          uint64_t v62 = (-255LL << v61) - 1;
          unint64_t v63 = (unint64_t)v60 << v61;
          unint64_t v64 = v63 | v62 & v39;
          unint64_t v65 = v63 | v62 & v8;
          if (v57 < 8) {
            unint64_t v8 = v65;
          }
          else {
            unint64_t v39 = v64;
          }
          v55 += 8;
          unint64_t v56 = v58;
        }

        while (v53 != v58);
      }

      swift_bridgeObjectRelease(v9);
      swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
      unint64_t v66 = 0xA000000000000000LL;
      if (!(v8 & 0x8080808080808080LL | v39 & 0x80808080808080LL)) {
        unint64_t v66 = 0xE000000000000000LL;
      }
      unint64_t v67 = v66 & 0xFF00000000000000LL | (v54 << 56) | v39 & 0xFFFFFFFFFFFFFFLL;
LABEL_85:
      unint64_t v256 = v8;
      unint64_t v257 = v67;
      goto LABEL_86;
    }

LABEL_279:
    unint64_t v239 = 266LL;
LABEL_285:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v239,  0);
  }

  if (v21 < v17)
  {
LABEL_48:
    swift_bridgeObjectRelease_n(0x80000001818B76F0LL | 0x8000000000000000LL, 5LL);
    if ((v9 & 0x1000000000000000LL) == 0)
    {
      if ((v8 & 0x1000000000000000LL) != 0)
      {
        unsigned int v38 = (unsigned __int8 *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        unsigned int v38 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v8, v9);
        uint64_t v11 = v35;
      }

      swift_bridgeObjectRetain(v9, v35, v36, v37);
      closure #1 in _StringGuts._convertedToSmall()(v38, v11, &v255);
      swift_bridgeObjectRelease(v9);
      unint64_t v8 = v255;
      unint64_t v39 = *((void *)&v255 + 1);
      goto LABEL_57;
    }

    goto LABEL_287;
  }

LABEL_126:
      if ((v101 & ~v100 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v100 & 0xFFFFFFFFFFFFFFFLL))
      {
        uint64_t v115 = v254;
        int64_t v116 = _StringGuts.nativeUnusedCapacity.getter(v253, v254);
        a1 = v248;
        if ((v117 & 1) != 0) {
          goto LABEL_284;
        }
        x1_0 = v247;
        if (v114 > 15 || (v115 & 0x2000000000000000LL) == 0 && v116 >= v110)
        {
LABEL_134:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v114, v110);
          swift_bridgeObjectRelease_n(v80, 4LL);
          if ((v80 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v80);
            _StringGuts._foreignAppendInPlace(_:)(v106, v80, 0LL, v249);
          }

          else
          {
            if (v107)
            {
              swift_bridgeObjectRelease_n(v80, 2LL);
              *(void *)&unsigned __int128 v252 = v106;
              *((void *)&v252 + 1) = v80 & 0xFFFFFFFFFFFFFFLL;
              uint64_t v118 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v108, (uint64_t)&v252, v108);
              _StringGuts.appendInPlace(_:isASCII:)(v118, v119, (v80 & 0x4000000000000000LL) != 0);
              goto LABEL_178;
            }

            if ((v106 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v80);
              id v162 = (id)((v80 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v163 = v106 & 0xFFFFFFFFFFFFLL;
              uint64_t v164 = v106 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v162 = _StringObject.sharedUTF8.getter(v106, v80);
              uint64_t v164 = v175;
              swift_bridgeObjectRelease(v80);
              uint64_t v163 = v106 & 0xFFFFFFFFFFFFLL;
              if (v164 < (uint64_t)(v106 & 0xFFFFFFFFFFFFLL)) {
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
              }
            }

            int64_t v165 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v163, (uint64_t)v162, v164);
            _StringGuts.appendInPlace(_:isASCII:)(v165, v166, (v106 & 0x8000000000000000LL) != 0LL);
          }

          swift_bridgeObjectRelease(v80);
          goto LABEL_178;
        }
      }

      else
      {
        x1_0 = v247;
        a1 = v248;
        if (v114 > 15) {
          goto LABEL_134;
        }
        uint64_t v115 = v254;
      }

      swift_bridgeObjectRelease_n(v80, 5LL);
      unint64_t v126 = v253;
      swift_bridgeObjectRetain(v115, v127, v128, v129);
      unint64_t v130 = _StringGuts._convertedToSmall()(v126, v115);
      unint64_t v132 = v131;
      swift_bridgeObjectRelease(v115);
      v133._Swift::UInt64 rawBits = (v249 << 16) | 1;
      v134._Swift::UInt64 rawBits = 1LL;
      v135._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v134, v133, v106, v80);
      if (v135._rawBits < 0x10000) {
        v135._rawBits |= 3;
      }
      unint64_t v137 = specialized String.init(_:)(v135, v136, v106, v80);
      unint64_t v139 = v138;
      swift_bridgeObjectRelease(v80);
      unint64_t v140 = _StringGuts._convertedToSmall()(v137, v139);
      unint64_t v142 = v141;
      swift_bridgeObjectRelease(v139);
      unint64_t v143 = specialized _SmallString.init(_:appending:)(v130, v132, v140, v142);
      if ((v145 & 1) != 0) {
        goto LABEL_279;
      }
      uint64_t v146 = v143;
      uint64_t v147 = v144;
      swift_bridgeObjectRelease(v115);
      uint64_t v253 = v146;
      uint64_t v254 = v147;
LABEL_178:
      uint64_t v80 = v253;
      unint64_t v106 = v254;
      swift_bridgeObjectRelease(*((uint64_t *)&v255 + 1));
      char v84 = 0;
      *(void *)&unsigned __int128 v255 = v80;
      *((void *)&v255 + 1) = v106;
      if (v83 >= v250) {
        goto LABEL_191;
      }
    }

    Swift::String_optional v123 = Unicode.Scalar._escaped(asASCII:)(1);
    unint64_t object = (unint64_t)v123.value._object;
    if (v123.value._object) {
      uint64_t countAndFlagsBits = v123.value._countAndFlagsBits;
    }
    else {
      uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v90);
    }
    unint64_t v125 = object;
    uint64_t v160 = HIBYTE(v100) & 0xF;
    if ((v100 & 0x2000000000000000LL) == 0) {
      uint64_t v160 = v101 & 0xFFFFFFFFFFFFLL;
    }
    if (v160 || (v101 & ~v100 & 0x2000000000000000LL) != 0)
    {
      if ((v100 & 0x2000000000000000LL) == 0)
      {
        if ((object & 0x2000000000000000LL) != 0) {
LABEL_172:
        }
          uint64_t v161 = HIBYTE(v125) & 0xF;
        else {
LABEL_165:
        }
          uint64_t v161 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        a1 = v248;
        swift_bridgeObjectRetain(v125, object, v121, v122);
        _StringGuts.append(_:)(countAndFlagsBits, v125, 0LL, v161);
        swift_bridgeObjectRelease_n(v125, 2LL);
        x1_0 = v247;
        goto LABEL_94;
      }

      if ((object & 0x2000000000000000LL) == 0) {
        goto LABEL_165;
      }
      unint64_t v167 = specialized _SmallString.init(_:appending:)(v101, v100, countAndFlagsBits, object);
      if ((v121 & 1) != 0) {
        goto LABEL_172;
      }
      uint64_t v168 = v167;
      unint64_t v169 = object;
      swift_bridgeObjectRelease(v100);
      swift_bridgeObjectRelease(v125);
      *(void *)&unsigned __int128 v255 = v168;
      *((void *)&v255 + 1) = v169;
    }

    else
    {
      swift_bridgeObjectRelease(v100);
      *(void *)&unsigned __int128 v255 = countAndFlagsBits;
      *((void *)&v255 + 1) = v125;
    }

    x1_0 = v247;
    a1 = v248;
LABEL_94:
    char v84 = 1;
  }

  while (v83 < v250);
  uint64_t v80 = v255;
  unint64_t v106 = *((void *)&v255 + 1);
LABEL_191:
  uint64_t v81 = 0xE100000000000000LL;
LABEL_192:
  uint64_t v253 = 34LL;
  uint64_t v254 = 0xE100000000000000LL;
  uint64_t v176 = HIBYTE(v106) & 0xF;
  if ((v106 & 0x2000000000000000LL) == 0) {
    uint64_t v176 = v80 & 0xFFFFFFFFFFFFLL;
  }
  if (!v176) {
    goto LABEL_246;
  }
  while (2)
  {
    uint64_t v182 = v253;
    uint64_t v183 = v254;
    swift_bridgeObjectRetain(v254, v42, v43, v44);
    unint64_t v184 = specialized Collection.first.getter(v182, v183);
    swift_bridgeObjectRelease(v183);
    if ((v184 & 0x100000000LL) != 0)
    {
      unint64_t v238 = 839LL;
      goto LABEL_278;
    }

    *(void *)&unsigned __int128 v252 = v80;
    *((void *)&v252 + 1) = v106;
    *(void *)&unsigned __int128 v255 = 0LL;
    *((void *)&v255 + 1) = 0xE000000000000000LL;
    unint64_t v185 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v184);
    uint64_t v187 = v186;
    _StringGuts.append(_:)(v185, v186);
    swift_bridgeObjectRelease(v187);
    unint64_t v189 = *((void *)&v252 + 1);
    uint64_t v188 = v252;
    swift_bridgeObjectRetain(*((unint64_t *)&v252 + 1), v190, v191, v192);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unsigned __int128 v255 = __PAIR128__(v189, v188);
    uint64_t v196 = HIBYTE(v189) & 0xF;
    if ((v189 & 0x2000000000000000LL) == 0) {
      uint64_t v196 = v188;
    }
    uint64_t v197 = 7LL;
    if (((v189 >> 60) & ((v188 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v197 = 11LL;
    }
    v198._Swift::UInt64 rawBits = v197 | (v196 << 16);
    swift_bridgeObjectRetain(v189, v193, v194, v195);
    v199._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(v198)._rawBits;
    Swift::UInt64 rawBits = v199._rawBits;
    if (!(v199._rawBits >> 14))
    {
      if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
      }
      uint64_t v201 = 0LL;
      goto LABEL_219;
    }

    uint64_t v201 = v199._rawBits >> 16;
    if (v199._rawBits < 0x20000)
    {
LABEL_223:
      if (v201 <= 63) {
        uint64_t v206 = v201 << 8;
      }
      else {
        uint64_t v206 = 63LL;
      }
    }

    else
    {
      if ((v189 & 0x1000000000000000LL) != 0) {
        goto LABEL_222;
      }
      if ((v189 & 0x2000000000000000LL) != 0)
      {
        *(void *)&unsigned __int128 v252 = v188;
        *((void *)&v252 + 1) = v189 & 0xFFFFFFFFFFFFFFLL;
        char v203 = (char *)&v252 + v201;
      }

      else
      {
        if ((v188 & 0x1000000000000000LL) != 0)
        {
          uint64_t v202 = (char *)((v189 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          uint64_t v202 = (char *)_StringObject.sharedUTF8.getter(v188, v189);
          if (!v202) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
          }
        }

        char v203 = &v202[v201];
      }

      int v204 = *((unsigned __int16 *)v203 - 1);
      if (v204 == 2573 || (v204 & 0x80808080) != 0)
      {
LABEL_222:
        uint64_t v201 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
        goto LABEL_223;
      }

      uint64_t v201 = 1LL;
LABEL_219:
      uint64_t v206 = v201 << 8;
    }

    v207._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v198)._rawBits;
    if (!(v207._rawBits >> 14)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
    }
    Swift::UInt64 v208 = v207._rawBits;
    swift_bridgeObjectRelease(v189);
    if ((v189 & 0x1000000000000000LL) != 0)
    {
      Swift::UInt64 v213 = String.UnicodeScalarView._foreignIndex(before:)((Swift::String::Index)v208)._rawBits;
      swift_bridgeObjectRelease(v189);
    }

    else
    {
      if ((v189 & 0x2000000000000000LL) != 0)
      {
        uint64_t v210 = 0LL;
        *(void *)&unsigned __int128 v252 = v188;
        *((void *)&v252 + 1) = v189 & 0xFFFFFFFFFFFFFFLL;
        do
          int v212 = *(&v251 + (v208 >> 16) + v210--) & 0xC0;
        while (v212 == 128);
      }

      else
      {
        if ((v188 & 0x1000000000000000LL) != 0) {
          Swift::Int v209 = (char *)((v189 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          Swift::Int v209 = (char *)_StringObject.sharedUTF8.getter(v188, v189);
        }
        uint64_t v210 = 0LL;
        do
          int v211 = v209[(v208 >> 16) - 1 + v210--] & 0xC0;
        while (v211 == 128);
      }

      swift_bridgeObjectRelease(v189);
      Swift::UInt64 v213 = (v208 - -65536 * v210) & 0xFFFFFFFFFFFF0000LL | 5;
    }

    if (((rawBits - (v201 << 16)) & 0xFFFFFFFFFFFF0000LL | v206) >> 14 >= v213 >> 14)
    {
      v217._Swift::UInt64 rawBits = specialized Collection.dropFirst(_:)(1LL, v253, v254);
      uint64_t v219 = v218;
      *(void *)&unsigned __int128 v252 = v188;
      *((void *)&v252 + 1) = v189;
      *(void *)&unsigned __int128 v255 = 0LL;
      *((void *)&v255 + 1) = 0xE000000000000000LL;
      specialized String.UnicodeScalarView.append<A>(contentsOf:)(v217, v258, v220, v218);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      swift_bridgeObjectRelease(v219);
      unint64_t v106 = *((void *)&v252 + 1);
      uint64_t v80 = v252;
      goto LABEL_247;
    }

    *(void *)&unsigned __int128 v252 = v188;
    *((void *)&v252 + 1) = v189;
    specialized RangeReplaceableCollection<>.removeLast()();
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unsigned int v214 = specialized RangeReplaceableCollection<>.removeLast()();
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unsigned __int128 v255 = v252;
    Swift::String_optional v215 = Unicode.Scalar._escaped(asASCII:)(1);
    unint64_t v177 = v215.value._object;
    if (v215.value._object) {
      uint64_t v178 = v215.value._countAndFlagsBits;
    }
    else {
      uint64_t v178 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v214);
    }
    unint64_t v216 = (unint64_t)v177;
    v179._Swift::UInt64 rawBits = 15LL;
    v180._Swift::UInt64 rawBits = 15LL;
    specialized String.UnicodeScalarView.replaceSubrange<A>(_:with:)(v179, v180, v178, v216);
    swift_bridgeObjectRelease(v216);
    uint64_t v80 = v255;
    unint64_t v106 = *((void *)&v255 + 1);
    unint64_t v181 = HIBYTE(*((void *)&v255 + 1)) & 0xFLL;
    if ((*((void *)&v255 + 1) & 0x2000000000000000LL) == 0) {
      unint64_t v181 = v255 & 0xFFFFFFFFFFFFLL;
    }
    if (v181) {
      continue;
    }
    break;
  }

  uint64_t v81 = v254;
LABEL_246:
  swift_bridgeObjectRelease(v81);
LABEL_247:
  Swift::Int v113 = v256;
  uint64_t v110 = v257;
  unint64_t v224 = HIBYTE(v257) & 0xF;
  if ((v257 & 0x2000000000000000LL) == 0) {
    unint64_t v224 = v256 & 0xFFFFFFFFFFFFLL;
  }
  if (!v224 && (v256 & ~v257 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v257);
    unint64_t v256 = v80;
    unint64_t v257 = v106;
    goto LABEL_261;
  }

  if ((v257 & 0x2000000000000000LL) != 0)
  {
    if ((v106 & 0x2000000000000000LL) != 0)
    {
LABEL_257:
      unint64_t v226 = specialized _SmallString.init(_:appending:)(v113, v110, v80, v106);
      if ((v222 & 1) != 0) {
        goto LABEL_259;
      }
      unint64_t v227 = v226;
      unint64_t v228 = v221;
      swift_bridgeObjectRelease(v110);
      swift_bridgeObjectRelease(v106);
      unint64_t v256 = v227;
      unint64_t v257 = v228;
      unint64_t v106 = v228;
      uint64_t v80 = v227;
      goto LABEL_261;
    }

      int64_t v21 = 0;
      goto LABEL_103;
    }

    goto LABEL_124;
  }

  if ((a1 & 0x1000000000000000LL) != 0)
  {
    unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
    if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
      goto LABEL_5;
    }
LABEL_124:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
  uint64_t v6 = v81;
  if (v81 <= 0) {
    goto LABEL_124;
  }
LABEL_5:
  Swift::UInt64 v7 = *v5;
  if (v7 == 43)
  {
    unint64_t v8 = 1;
    unint64_t v39 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
    uint64_t v43 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v39, v40, v41, v42);
    if (v44)
    {
      Swift::String::Index v45 = a3 + 55;
      Swift::String::Index v46 = a3 + 87;
      if (a3 > 10)
      {
        Swift::String::Index v47 = 58;
      }

      else
      {
        Swift::String::Index v46 = 97;
        Swift::String::Index v45 = 65;
        Swift::String::Index v47 = a3 + 48;
      }

      if (v43)
      {
        LOBYTE(v48) = 0;
        while (1)
        {
          unint64_t v49 = *v43;
          if (v49 < 0x30 || v49 >= v47)
          {
            if (v49 < 0x41 || v49 >= v45)
            {
              int64_t v21 = 0;
              unint64_t v8 = 1;
              if (v49 < 0x61 || v49 >= v46) {
                goto LABEL_103;
              }
              unint64_t v50 = -87;
            }

            else
            {
              unint64_t v50 = -55;
            }
          }

          else
          {
            unint64_t v50 = -48;
          }

          int64_t v21 = 0;
          unint64_t v51 = v48 * a3;
          unint64_t v8 = 1;
          if ((v51 & 0xFF00) == 0)
          {
            Swift::String::Index v48 = v51 + (v49 + v50);
            if (((v48 >> 8) & 1) == 0)
            {
              unint64_t v8 = 0;
              ++v43;
              int64_t v21 = v48;
              if (--v44) {
                continue;
              }
            }
          }

          goto LABEL_103;
        }
      }

      goto LABEL_102;
    }

    goto LABEL_126;
  }

  if (v7 != 45)
  {
    LOBYTE(v52) = 0;
    uint64_t v53 = a3 + 55;
    uint64_t v54 = a3 + 87;
    if (a3 > 10)
    {
      char v55 = 58;
    }

    else
    {
      uint64_t v54 = 97;
      uint64_t v53 = 65;
      char v55 = a3 + 48;
    }

    while (1)
    {
      unint64_t v56 = *v5;
      if (v56 < 0x30 || v56 >= v55)
      {
        if (v56 < 0x41 || v56 >= v53)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v56 < 0x61 || v56 >= v54) {
            goto LABEL_103;
          }
          unint64_t v57 = -87;
        }

        else
        {
          unint64_t v57 = -55;
        }
      }

      else
      {
        unint64_t v57 = -48;
      }

      int64_t v21 = 0;
      unint64_t v58 = v52 * a3;
      unint64_t v8 = 1;
      if ((v58 & 0xFF00) == 0)
      {
        uint64_t v52 = v58 + (v56 + v57);
        if (((v52 >> 8) & 1) == 0)
        {
          unint64_t v8 = 0;
          ++v5;
          int64_t v21 = v52;
          if (--v6) {
            continue;
          }
        }
      }

      goto LABEL_103;
    }
  }

  unint64_t v8 = 1;
  unint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
  unint64_t v13 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
  if (!v14) {
    goto LABEL_125;
  }
  uint64_t v15 = a3 + 55;
  Swift::UInt64 v16 = a3 + 87;
  if (a3 > 10)
  {
    Swift::Int v17 = 58;
  }

  else
  {
    Swift::UInt64 v16 = 97;
    uint64_t v15 = 65;
    Swift::Int v17 = a3 + 48;
  }

  if (v13)
  {
    LOBYTE(v18) = 0;
    while (1)
    {
      Swift::Int v19 = *v13;
      if (v19 < 0x30 || v19 >= v17)
      {
        if (v19 < 0x41 || v19 >= v15)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v19 < 0x61 || v19 >= v16) {
            goto LABEL_103;
          }
          unint64_t v20 = -87;
        }

        else
        {
          unint64_t v20 = -55;
        }
      }

      else
      {
        unint64_t v20 = -48;
      }

      int64_t v21 = 0;
      char v22 = v19 + v20;
      int64_t v23 = v18 * a3;
      BOOL v18 = (v18 * a3) - v22;
      unint64_t v8 = 1;
      if ((v23 & 0xFF00) == 0 && (v18 & 0xFFFFFF00) == 0)
      {
        unint64_t v8 = 0;
        ++v13;
        int64_t v21 = v18;
        if (--v14) {
          continue;
        }
      }

      goto LABEL_103;
    }
  }

      int64_t v21 = 0;
      goto LABEL_103;
    }

    goto LABEL_124;
  }

  if ((a1 & 0x1000000000000000LL) != 0)
  {
    unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
    if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
      goto LABEL_5;
    }
LABEL_124:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
  uint64_t v6 = v97;
  if (v97 <= 0) {
    goto LABEL_124;
  }
LABEL_5:
  Swift::UInt64 v7 = *v5;
  if (v7 == 43)
  {
    unint64_t v8 = 1;
    uint64_t v43 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
    Swift::String::Index v47 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v43, v44, v45, v46);
    if (v48)
    {
      unint64_t v49 = a3 + 55;
      unint64_t v50 = a3 + 87;
      if (a3 > 10)
      {
        unint64_t v51 = 58;
      }

      else
      {
        unint64_t v50 = 97;
        unint64_t v49 = 65;
        unint64_t v51 = a3 + 48;
      }

      if (v47)
      {
        LOBYTE(v52) = 0;
        while (1)
        {
          uint64_t v53 = *v47;
          if (v53 < 0x30 || v53 >= v51)
          {
            if (v53 < 0x41 || v53 >= v49)
            {
              int64_t v21 = 0;
              unint64_t v8 = 1;
              if (v53 < 0x61 || v53 >= v50) {
                goto LABEL_103;
              }
              uint64_t v54 = -87;
            }

            else
            {
              uint64_t v54 = -55;
            }
          }

          else
          {
            uint64_t v54 = -48;
          }

          int64_t v21 = 0;
          char v55 = v53 + v54;
          unint64_t v56 = (char)v52 * (char)a3;
          unint64_t v57 = (char)(v52 * a3);
          uint64_t v52 = v57 + v55;
          unint64_t v58 = v52 != (char)(v57 + v55);
          unint64_t v8 = 1;
          if (v57 == v56 && !v58)
          {
            unint64_t v8 = 0;
            ++v47;
            int64_t v21 = v52;
            if (--v48) {
              continue;
            }
          }

          goto LABEL_103;
        }
      }

      goto LABEL_102;
    }

    goto LABEL_126;
  }

  if (v7 != 45)
  {
    LOBYTE(v59) = 0;
    unint64_t v60 = a3 + 55;
    char v61 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v62 = 58;
    }

    else
    {
      char v61 = 97;
      unint64_t v60 = 65;
      uint64_t v62 = a3 + 48;
    }

    while (1)
    {
      unint64_t v63 = *v5;
      if (v63 < 0x30 || v63 >= v62)
      {
        if (v63 < 0x41 || v63 >= v60)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v63 < 0x61 || v63 >= v61) {
            goto LABEL_103;
          }
          unint64_t v64 = -87;
        }

        else
        {
          unint64_t v64 = -55;
        }
      }

      else
      {
        unint64_t v64 = -48;
      }

      int64_t v21 = 0;
      unint64_t v65 = v63 + v64;
      unint64_t v66 = (char)v59 * (char)a3;
      unint64_t v67 = (char)(v59 * a3);
      unint64_t v59 = v67 + v65;
      char v68 = v59 != (char)(v67 + v65);
      unint64_t v8 = 1;
      if (v67 == v66 && !v68)
      {
        unint64_t v8 = 0;
        ++v5;
        int64_t v21 = v59;
        if (--v6) {
          continue;
        }
      }

      goto LABEL_103;
    }
  }

  unint64_t v8 = 1;
  unint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
  unint64_t v13 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
  if (!v14) {
    goto LABEL_125;
  }
  uint64_t v15 = a3 + 55;
  Swift::UInt64 v16 = a3 + 87;
  if (a3 > 10)
  {
    Swift::Int v17 = 58;
  }

  else
  {
    Swift::UInt64 v16 = 97;
    uint64_t v15 = 65;
    Swift::Int v17 = a3 + 48;
  }

  if (v13)
  {
    LOBYTE(v18) = 0;
    while (1)
    {
      Swift::Int v19 = *v13;
      if (v19 < 0x30 || v19 >= v17)
      {
        if (v19 < 0x41 || v19 >= v15)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v19 < 0x61 || v19 >= v16) {
            goto LABEL_103;
          }
          unint64_t v20 = -87;
        }

        else
        {
          unint64_t v20 = -55;
        }
      }

      else
      {
        unint64_t v20 = -48;
      }

      int64_t v21 = 0;
      char v22 = v19 + v20;
      int64_t v23 = (char)v18 * (char)a3;
      char v24 = (char)(v18 * a3);
      BOOL v18 = v24 - v22;
      Swift::UInt64 v25 = v18 != (char)(v24 - v22);
      unint64_t v8 = 1;
      if (v24 == v23 && !v25)
      {
        unint64_t v8 = 0;
        ++v13;
        int64_t v21 = v18;
        if (--v14) {
          continue;
        }
      }

      goto LABEL_103;
    }
  }

      int64_t v21 = 0;
      goto LABEL_103;
    }

    goto LABEL_124;
  }

  if ((a1 & 0x1000000000000000LL) != 0)
  {
    unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
    if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
      goto LABEL_5;
    }
LABEL_124:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
  uint64_t v6 = v81;
  if (v81 <= 0) {
    goto LABEL_124;
  }
LABEL_5:
  Swift::UInt64 v7 = *v5;
  if (v7 == 43)
  {
    unint64_t v8 = 1;
    unint64_t v39 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
    uint64_t v43 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v39, v40, v41, v42);
    if (v44)
    {
      Swift::String::Index v45 = a3 + 55;
      Swift::String::Index v46 = a3 + 87;
      if (a3 > 10)
      {
        Swift::String::Index v47 = 58;
      }

      else
      {
        Swift::String::Index v46 = 97;
        Swift::String::Index v45 = 65;
        Swift::String::Index v47 = a3 + 48;
      }

      if (v43)
      {
        LOWORD(v48) = 0;
        while (1)
        {
          unint64_t v49 = *v43;
          if (v49 < 0x30 || v49 >= v47)
          {
            if (v49 < 0x41 || v49 >= v45)
            {
              int64_t v21 = 0;
              unint64_t v8 = 1;
              if (v49 < 0x61 || v49 >= v46) {
                goto LABEL_103;
              }
              unint64_t v50 = -87;
            }

            else
            {
              unint64_t v50 = -55;
            }
          }

          else
          {
            unint64_t v50 = -48;
          }

          int64_t v21 = 0;
          unint64_t v51 = (unsigned __int16)v48 * (unsigned __int16)a3;
          unint64_t v8 = 1;
          if ((v51 & 0xFFFF0000) == 0)
          {
            Swift::String::Index v48 = (unsigned __int16)v51 + (v49 + v50);
            if ((v48 & 0x10000) == 0)
            {
              unint64_t v8 = 0;
              ++v43;
              int64_t v21 = v48;
              if (--v44) {
                continue;
              }
            }
          }

          goto LABEL_103;
        }
      }

      goto LABEL_102;
    }

    goto LABEL_126;
  }

  if (v7 != 45)
  {
    LOWORD(v52) = 0;
    uint64_t v53 = a3 + 55;
    uint64_t v54 = a3 + 87;
    if (a3 > 10)
    {
      char v55 = 58;
    }

    else
    {
      uint64_t v54 = 97;
      uint64_t v53 = 65;
      char v55 = a3 + 48;
    }

    while (1)
    {
      unint64_t v56 = *v5;
      if (v56 < 0x30 || v56 >= v55)
      {
        if (v56 < 0x41 || v56 >= v53)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v56 < 0x61 || v56 >= v54) {
            goto LABEL_103;
          }
          unint64_t v57 = -87;
        }

        else
        {
          unint64_t v57 = -55;
        }
      }

      else
      {
        unint64_t v57 = -48;
      }

      int64_t v21 = 0;
      unint64_t v58 = (unsigned __int16)v52 * (unsigned __int16)a3;
      unint64_t v8 = 1;
      if ((v58 & 0xFFFF0000) == 0)
      {
        uint64_t v52 = (unsigned __int16)v58 + (v56 + v57);
        if ((v52 & 0x10000) == 0)
        {
          unint64_t v8 = 0;
          ++v5;
          int64_t v21 = v52;
          if (--v6) {
            continue;
          }
        }
      }

      goto LABEL_103;
    }
  }

  unint64_t v8 = 1;
  unint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
  unint64_t v13 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
  if (!v14) {
    goto LABEL_125;
  }
  uint64_t v15 = a3 + 55;
  Swift::UInt64 v16 = a3 + 87;
  if (a3 > 10)
  {
    Swift::Int v17 = 58;
  }

  else
  {
    Swift::UInt64 v16 = 97;
    uint64_t v15 = 65;
    Swift::Int v17 = a3 + 48;
  }

  if (v13)
  {
    LOWORD(v18) = 0;
    while (1)
    {
      Swift::Int v19 = *v13;
      if (v19 < 0x30 || v19 >= v17)
      {
        if (v19 < 0x41 || v19 >= v15)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v19 < 0x61 || v19 >= v16) {
            goto LABEL_103;
          }
          unint64_t v20 = -87;
        }

        else
        {
          unint64_t v20 = -55;
        }
      }

      else
      {
        unint64_t v20 = -48;
      }

      int64_t v21 = 0;
      char v22 = v19 + v20;
      int64_t v23 = (unsigned __int16)v18 * (unsigned __int16)a3;
      BOOL v18 = (unsigned __int16)(v18 * a3) - v22;
      unint64_t v8 = 1;
      if ((v23 & 0xFFFF0000) == 0 && (v18 & 0xFFFF0000) == 0)
      {
        unint64_t v8 = 0;
        ++v13;
        int64_t v21 = v18;
        if (--v14) {
          continue;
        }
      }

      goto LABEL_103;
    }
  }

      int64_t v21 = 0;
      goto LABEL_103;
    }

    goto LABEL_124;
  }

  if ((a1 & 0x1000000000000000LL) != 0)
  {
    unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
    if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
      goto LABEL_5;
    }
LABEL_124:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
  uint64_t v6 = v97;
  if (v97 <= 0) {
    goto LABEL_124;
  }
LABEL_5:
  Swift::UInt64 v7 = *v5;
  if (v7 == 43)
  {
    unint64_t v8 = 1;
    uint64_t v43 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
    Swift::String::Index v47 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v43, v44, v45, v46);
    if (v48)
    {
      unint64_t v49 = a3 + 55;
      unint64_t v50 = a3 + 87;
      if (a3 > 10)
      {
        unint64_t v51 = 58;
      }

      else
      {
        unint64_t v50 = 97;
        unint64_t v49 = 65;
        unint64_t v51 = a3 + 48;
      }

      if (v47)
      {
        LOWORD(v52) = 0;
        while (1)
        {
          uint64_t v53 = *v47;
          if (v53 < 0x30 || v53 >= v51)
          {
            if (v53 < 0x41 || v53 >= v49)
            {
              int64_t v21 = 0;
              unint64_t v8 = 1;
              if (v53 < 0x61 || v53 >= v50) {
                goto LABEL_103;
              }
              uint64_t v54 = -87;
            }

            else
            {
              uint64_t v54 = -55;
            }
          }

          else
          {
            uint64_t v54 = -48;
          }

          int64_t v21 = 0;
          char v55 = v53 + v54;
          unint64_t v56 = (__int16)v52 * (__int16)a3;
          unint64_t v57 = (__int16)(v52 * a3);
          uint64_t v52 = v57 + v55;
          unint64_t v58 = v52 != (__int16)(v57 + v55);
          unint64_t v8 = 1;
          if (v57 == v56 && !v58)
          {
            unint64_t v8 = 0;
            ++v47;
            int64_t v21 = v52;
            if (--v48) {
              continue;
            }
          }

          goto LABEL_103;
        }
      }

      goto LABEL_102;
    }

    goto LABEL_126;
  }

  if (v7 != 45)
  {
    LOWORD(v59) = 0;
    unint64_t v60 = a3 + 55;
    char v61 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v62 = 58;
    }

    else
    {
      char v61 = 97;
      unint64_t v60 = 65;
      uint64_t v62 = a3 + 48;
    }

    while (1)
    {
      unint64_t v63 = *v5;
      if (v63 < 0x30 || v63 >= v62)
      {
        if (v63 < 0x41 || v63 >= v60)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v63 < 0x61 || v63 >= v61) {
            goto LABEL_103;
          }
          unint64_t v64 = -87;
        }

        else
        {
          unint64_t v64 = -55;
        }
      }

      else
      {
        unint64_t v64 = -48;
      }

      int64_t v21 = 0;
      unint64_t v65 = v63 + v64;
      unint64_t v66 = (__int16)v59 * (__int16)a3;
      unint64_t v67 = (__int16)(v59 * a3);
      unint64_t v59 = v67 + v65;
      char v68 = v59 != (__int16)(v67 + v65);
      unint64_t v8 = 1;
      if (v67 == v66 && !v68)
      {
        unint64_t v8 = 0;
        ++v5;
        int64_t v21 = v59;
        if (--v6) {
          continue;
        }
      }

      goto LABEL_103;
    }
  }

  unint64_t v8 = 1;
  unint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
  unint64_t v13 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
  if (!v14) {
    goto LABEL_125;
  }
  uint64_t v15 = a3 + 55;
  Swift::UInt64 v16 = a3 + 87;
  if (a3 > 10)
  {
    Swift::Int v17 = 58;
  }

  else
  {
    Swift::UInt64 v16 = 97;
    uint64_t v15 = 65;
    Swift::Int v17 = a3 + 48;
  }

  if (v13)
  {
    LOWORD(v18) = 0;
    while (1)
    {
      Swift::Int v19 = *v13;
      if (v19 < 0x30 || v19 >= v17)
      {
        if (v19 < 0x41 || v19 >= v15)
        {
          int64_t v21 = 0;
          unint64_t v8 = 1;
          if (v19 < 0x61 || v19 >= v16) {
            goto LABEL_103;
          }
          unint64_t v20 = -87;
        }

        else
        {
          unint64_t v20 = -55;
        }
      }

      else
      {
        unint64_t v20 = -48;
      }

      int64_t v21 = 0;
      char v22 = v19 + v20;
      int64_t v23 = (__int16)v18 * (__int16)a3;
      char v24 = (__int16)(v18 * a3);
      BOOL v18 = v24 - v22;
      Swift::UInt64 v25 = v18 != (__int16)(v24 - v22);
      unint64_t v8 = 1;
      if (v24 == v23 && !v25)
      {
        unint64_t v8 = 0;
        ++v13;
        int64_t v21 = v18;
        if (--v14) {
          continue;
        }
      }

      goto LABEL_103;
    }
  }

      swift::warning(0LL, "swift runtime: unknown registers setting '%.*s'\n", a3, (char *)a4, v11, (void)v21);
      return;
    }

    a2 = v23;
  }

  if (a2 != 6) {
    goto LABEL_34;
  }
  if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "images", 6uLL))
  {
    uint64_t v11 = *((void *)&v21 + 1);
    if (*((void *)&v21 + 1) == 4LL)
    {
      if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "none",  4uLL))
      {
        dword_18C471480 = 0;
        return;
      }

      uint64_t v11 = *((void *)&v21 + 1);
    }

    if (v11 == 3)
    {
      if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "all",  3uLL))
      {
        dword_18C471480 = 1;
        return;
      }

      uint64_t v11 = *((void *)&v21 + 1);
    }

    if (v11 == 9)
    {
      if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "mentioned",  9uLL))
      {
        dword_18C471480 = 2;
        return;
      }

      goto LABEL_125;
    }

    goto LABEL_126;
  }

  a2 = v23;
LABEL_34:
  if (a2 == 5)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "limit", 5uLL))
    {
      uint64_t v12 = *((void *)&v21 + 1);
      if (*((void *)&v21 + 1) == 4LL)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "none",  4uLL))
        {
          dword_18C471484 = -1;
          return;
        }

        uint64_t v12 = *((void *)&v21 + 1);
      }

      if (__swift::__runtime::llvm::getAsSignedInteger((_BYTE *)v21, v12, 0LL, (unint64_t *)&v20)
        || (void)v20 != (int)v20
        || (int)v20 < 1)
      {
        swift::warning(0LL, "swift runtime: bad backtrace limit '%.*s'\n", v13, v14, *((void *)&v21 + 1), (void)v21);
      }

      else
      {
        dword_18C471484 = v20;
      }

      return;
    }

    a2 = v23;
  }

  if (a2 == 3)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "top", 3uLL))
    {
      if (__swift::__runtime::llvm::getAsSignedInteger( (_BYTE *)v21,  *((uint64_t *)&v21 + 1),  0LL,  (unint64_t *)&v20)
        || (void)v20 != (int)v20
        || (v20 & 0x80000000) != 0)
      {
        swift::warning( 0LL,  "swift runtime: bad backtrace top count '%.*s'\n",  v15,  v16,  *((void *)&v21 + 1),  (void)v21);
      }

      else
      {
        dword_18C471488 = v20;
      }

      return;
    }

    a2 = v23;
  }

  if (a2 == 5)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "cache", 5uLL))
    {
      return;
    }

    a2 = v23;
  }

  if (a2 != 9) {
    goto LABEL_46;
  }
  if (__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "output-to", 9uLL))
  {
    a2 = v23;
LABEL_46:
    if (a2 != 11)
    {
LABEL_49:
      swift::warning(0LL, "swift runtime: unknown backtracing setting '%.*s'\n", a3, (char *)a4, a2, v22);
      return;
    }

    if (__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "symbolicate", 0xBuLL))
    {
      a2 = v23;
      goto LABEL_49;
    }

    return;
  }

  Swift::Int v17 = *((void *)&v21 + 1);
  if (*((void *)&v21 + 1) == 4LL)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive((unsigned __int8 **)&v21, "auto", 4uLL))
    {
      dword_18C471498 = -1;
      return;
    }

    Swift::Int v17 = *((void *)&v21 + 1);
  }

  if (v17 == 6)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "stdout",  6uLL))
    {
      dword_18C471498 = 0;
      return;
    }

    Swift::Int v17 = *((void *)&v21 + 1);
    if (*((void *)&v21 + 1) == 6LL)
    {
      if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "stderr",  6uLL))
      {
        dword_18C471498 = 2;
        return;
      }

      Swift::Int v17 = *((void *)&v21 + 1);
    }
  }

  swift::warning(0LL, "swift runtime: unknown output-to setting '%.*s'\n", a3, (char *)a4, v17, (void)v21);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance String.UnicodeScalarView()
{
  return String.UnicodeScalarView.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

unint64_t key path setter for String.unicodeScalars : String(void *a1, void *a2)
{
  unint64_t v4 = a1[1];
  *a2 = *a1;
  a2[1] = v4;
  return swift_bridgeObjectRetain(v4, v5, v6, v7);
}

void String.unicodeScalars.setter(uint64_t a1, uint64_t a2)
{
  void *v2 = a1;
  v2[1] = a2;
}

unint64_t specialized String.UnicodeScalarView.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a2._rawBits;
  Swift::UInt64 v8 = a1._rawBits;
  uint64_t v10 = *v4;
  unint64_t v9 = v4[1];
  uint64_t v11 = ((unint64_t)*v4 >> 59) & 1;
  if ((v9 & 0x1000000000000000LL) == 0) {
    LOBYTE(v11) = 1;
  }
  uint64_t v12 = a1._rawBits & 0xC;
  uint64_t v13 = 4LL << v11;
  uint64_t v14 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v12 == v13 || (a2._rawBits & 1) == 0 || v14 == v13)
  {
    if (v14 == v13)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v12 != v13) {
        goto LABEL_14;
      }
    }

    else if (v12 != v13)
    {
      goto LABEL_14;
    }

    Swift::UInt64 v8 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v8)._rawBits;
LABEL_14:
    uint64_t v17 = HIBYTE(v9) & 0xF;
    if ((v9 & 0x2000000000000000LL) == 0) {
      uint64_t v17 = v10 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 > 4 * v17 || rawBits >> 14 < v8 >> 14)
    {
      unint64_t v16 = 356LL;
LABEL_21:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v16,  0);
    }

    if ((v8 & 1) != 0)
    {
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
      }
    }

    else
    {
      Swift::UInt64 v8 = v8 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((rawBits & 1) != 0) {
        return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
      }
    }

    Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
  }

  Swift::UInt64 v15 = HIBYTE(v9) & 0xF;
  if ((v9 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v15 = v10 & 0xFFFFFFFFFFFFLL;
  }
  if (v15 < a2._rawBits >> 16 && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u))
  {
    unint64_t v16 = 372LL;
    goto LABEL_21;
  }

  return specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, rawBits, a3, a4);
}

uint64_t String.UnicodeScalarView.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  Swift::UInt64 v9 = _StringGuts.validateScalarRange_5_7(_:)(a1, a2, *v5, v5[1]);
  return _StringGuts.replaceSubrange<A>(_:with:)(v9, v10, a3, a4, a5);
}

void protocol witness for RangeReplaceableCollection.init() in conformance String.UnicodeScalarView( void *a1@<X8>)
{
  *a1 = 0LL;
  a1[1] = 0xE000000000000000LL;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance String.UnicodeScalarView( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(void, void, uint64_t, uint64_t, uint64_t))String.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance String( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(void, void, uint64_t, uint64_t, uint64_t))
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a2, a3);
}

unint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance String.UnicodeScalarView@<X0>( int *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a2);
  *a3 = result;
  a3[1] = v5;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance String.UnicodeScalarView@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t v7 = specialized RangeReplaceableCollection.init<A>(_:)(a1, a2, a3);
  unint64_t v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

void protocol witness for RangeReplaceableCollection.append(_:) in conformance String.UnicodeScalarView( unsigned int *a1)
{
  unint64_t v1 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(*a1);
  uint64_t v3 = v2;
  _StringGuts.append(_:)(v1, v2);
  swift_bridgeObjectRelease(v3);
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance String.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance String( a1,  a2,  a3,  a4,  a5,  (void (*)(void))String.UnicodeScalarView.append<A>(contentsOf:));
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance String( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void (*a6)(void))
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance String.UnicodeScalarView( int *a1, Swift::UInt64 *a2)
{
  int v3 = *a1;
  v5._Swift::UInt64 rawBits = *a2;
  v4._Swift::UInt64 rawBits = v5._rawBits;
  Swift::UInt64 v6 = _StringGuts.validateScalarRange_5_7(_:)(v4, v5, *v2, v2[1]);
  return specialized _StringGuts.replaceSubrange<A>(_:with:)(v6, v7, v3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance String.UnicodeScalarView( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(uint64_t, void))specialized RangeReplaceableCollection.insert<A>(contentsOf:at:));
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance String( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(uint64_t, void))
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance String.UnicodeScalarView@<X0>( Swift::UInt64 *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.remove(at:)(*a1);
  *a2 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance String.UnicodeScalarView( Swift::UInt64 *a1)
{
  v2._Swift::UInt64 rawBits = a1[1];
  v3._Swift::UInt64 rawBits = *a1;
  Swift::UInt64 v4 = _StringGuts.validateScalarRange_5_7(_:)(v3, v2, *v1, v1[1]);
  return specialized _StringGuts.replaceSubrange<A>(_:with:)(v4, v5);
}

void protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance String.UnicodeScalarView( uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 1;
}

unint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance String.UnicodeScalarView@<X0>( _DWORD *a1@<X8>)
{
  unint64_t result = specialized RangeReplaceableCollection.removeFirst()();
  *a1 = result;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance String.UnicodeScalarView( uint64_t (*a1)(void *), uint64_t a2, uint64_t a3, char *a4)
{
}

Swift::Bool __swiftcall _StringGuts.isOnUnicodeScalarBoundary(_:)(Swift::String::Index a1)
{
  if ((a1._rawBits & 0xC000) != 0) {
    return 0;
  }
  if (a1._rawBits < 0x4000) {
    return 1;
  }
  uint64_t v6 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 14 == 4 * v6) {
    return 1;
  }
  void v10[4] = v3;
  uint64_t v10[5] = v4;
  if ((v2 & 0x1000000000000000LL) != 0) {
    return a1._rawBits >> 14 == _StringGuts.foreignScalarAlign(_:)(a1)._rawBits >> 14;
  }
  if ((v2 & 0x2000000000000000LL) != 0)
  {
    v10[0] = v1;
    v10[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    char v8 = *((_BYTE *)v10 + (a1._rawBits >> 16));
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v7 = (_BYTE *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      Swift::UInt64 rawBits = a1._rawBits;
      unint64_t v7 = _StringObject.sharedUTF8.getter(v1, v2);
      a1._Swift::UInt64 rawBits = rawBits;
    }

    char v8 = v7[a1._rawBits >> 16];
  }

  return (v8 & 0xC0) != 128;
}

Swift::String::Index_optional __swiftcall String.Index.samePosition(in:)(Swift::String in)
{
  Swift::UInt64 v2 = String.Index.samePosition(in:)( in._countAndFlagsBits,  (unint64_t)in._object,  v1,  (char *)specialized String.Index.init(_:within:));
  result.value._Swift::UInt64 rawBits = v2;
  result.is_nil = v3;
  return result;
}

uint64_t String.UnicodeScalarView.customMirror.getter@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  a1,  a2,  8,  0LL,  0LL,  a5);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return protocol witness for CustomReflectable.customMirror.getter in conformance String.UnicodeScalarView( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void))specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:),  a4);
}

Swift::UInt16 __swiftcall _StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:)(Swift::String::Index at)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 v6 = at._rawBits >> 16;
  unint64_t v7 = (void *)(v2 & 0xFFFFFFFFFFFFFFFLL);
  Swift::UInt16 v8 = (unsigned __int16)objc_msgSend((id)(v2 & 0xFFFFFFFFFFFFFFFLL), sel_characterAtIndex_, at._rawBits >> 16);
  if ((v8 & 0xFC00) != 0xD800)
  {
    if ((v8 & 0xFC00) != 0xDC00
      || at._rawBits >= 0x10000 && (objc_msgSend(v7, sel_characterAtIndex_, v6 - 1) & 0xFC00) == 0xD800)
    {
      return v8;
    }

    return -3;
  }

  unint64_t v9 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 + 1 >= v9) {
    return -3;
  }
  return v8;
}

BOOL static Unicode.UTF16.isLeadSurrogate(_:)(unsigned __int16 a1)
{
  return a1 >> 10 == 54;
}

BOOL static Unicode.UTF16.isTrailSurrogate(_:)(unsigned __int16 a1)
{
  return a1 >> 10 == 55;
}

uint64_t (*String.UTF16View._guts.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::String::Index __swiftcall String.UTF16View.index(before:)(Swift::String::Index before)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 rawBits = before._rawBits;
  uint64_t v6 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((before._rawBits & 0xC) == 4LL << v6)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(before)._rawBits;
    if (rawBits < 0x4000) {
      goto LABEL_23;
    }
  }

  else if (before._rawBits < 0x4000)
  {
    goto LABEL_23;
  }

  uint64_t v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v7 < rawBits >> 14) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0xAFuLL,  0);
  if ((v3 & 0x1000000000000000LL) != 0) {
    return (Swift::String::Index)specialized String.UTF16View._foreignIndex(before:)(rawBits);
  }
  uint64_t v8 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LODWORD(v8) = v4 < 0;
  }
  if ((_DWORD)v8 == 1) {
    return (Swift::String::Index)((rawBits & 0xFFFFFFFFFFFF0000LL) - 65523);
  }
  if ((rawBits & 0xC000) != 0) {
    return (Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL | 5);
  }
  if ((rawBits & 1) == 0) {
    Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  }
  result._Swift::UInt64 rawBits = _StringGuts.fastUTF8ScalarLength(endingAt:)(rawBits >> 16);
  if (result._rawBits == 4) {
    return (Swift::String::Index)((rawBits & 0xFFFFFFFFFFFF0000LL) - 245756);
  }
  if (!__OFSUB__(0LL, result._rawBits)) {
    return (Swift::String::Index)((((rawBits >> 16) - result._rawBits) << 16) | 5);
  }
  __break(1u);
  return result;
}

Swift::Int __swiftcall _StringGuts.fastUTF8ScalarLength(endingAt:)(Swift::Int endingAt)
{
  if ((v2 & 0x2000000000000000LL) != 0)
  {
LABEL_11:
    v9[0] = v1;
    v9[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    Swift::Int result = 1LL;
    Swift::Int v8 = endingAt - 1;
    do
    {
      if (v8 < 0) {
        goto LABEL_19;
      }
      if ((*((_BYTE *)v9 + v8) & 0xC0) != 0x80) {
        return result;
      }
      --v8;
      BOOL v7 = __OFADD__(result++, 1LL);
    }

    while (!v7);
    __break(1u);
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0)
    {
      uint64_t v4 = (_BYTE *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v1 &= 0xFFFFFFFFFFFFuLL;
    }

    else
    {
      uint64_t v4 = _StringObject.sharedUTF8.getter(v1, v2);
    }

    Swift::Int result = 1LL;
    Swift::Int v6 = endingAt - 1;
    while (1)
    {
      if (v6 < 0) {
LABEL_19:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
      if (endingAt - 1 >= v1) {
LABEL_20:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
      if ((v4[v6] & 0xC0) != 0x80) {
        break;
      }
      --v6;
      BOOL v7 = __OFADD__(result++, 1LL);
      if (v7)
      {
        __break(1u);
        goto LABEL_11;
      }
    }
  }

  return result;
}

Swift::String::Index __swiftcall String.UTF16View._foreignIndex(_:offsetBy:)( Swift::String::Index _, Swift::Int offsetBy)
{
  int64_t v4 = offsetBy + (_._rawBits >> 16);
  if (v4 < 0) {
    goto LABEL_6;
  }
  unint64_t v5 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 < v4) {
LABEL_6:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x2A6uLL,  0);
  return (Swift::String::Index)((v4 << 16) | 8);
}

uint64_t Int.magnitude.getter(uint64_t result)
{
  if (result < 0) {
    return -result;
  }
  return result;
}

Swift::Int __swiftcall String.UTF16View._nativeGetOffset(for:)(Swift::String::Index a1)
{
  unint64_t rawBits = a1._rawBits;
  uint64_t v4 = (v2 >> 62) & 1;
  if ((v2 & 0x2000000000000000LL) == 0) {
    LODWORD((*(void (**)(char *, uint64_t))(v11 + 16))((char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), v4) = v1 < 0;
  }
  if ((_DWORD)v4 == 1) {
    return a1._rawBits >> 16;
  }
  if (a1._rawBits < 0x4000) {
    return 0LL;
  }
  unint64_t v6 = v2;
  uint64_t v7 = v1;
  if ((a1._rawBits & 0xC001) == 0) {
    goto LABEL_58;
  }
  while (1)
  {
    uint64_t v8 = v7 & ~v6 & 0x2000000000000000LL;
    if (v6 >> 60)
    {
      if (!v8) {
        return String.UTF16View._utf16Distance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)rawBits);
      }
    }

    else if (!v8)
    {
      goto LABEL_13;
    }

    if ((*(void *)(v6 + 16) & 0x8000000000000000LL) == 0) {
      return String.UTF16View._utf16Distance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)rawBits);
    }
LABEL_13:
    if (rawBits < 0x400000) {
      return String.UTF16View._utf16Distance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)rawBits);
    }
    unint64_t v9 = _StringGuts.loadUnmanagedBreadcrumbs()(v7, v6);
    uint64_t v10 = HIBYTE(v6) & 0xF;
    uint64_t v11 = v7 & 0xFFFFFFFFFFFFLL;
    if ((v6 & 0x2000000000000000LL) == 0) {
      uint64_t v10 = v7 & 0xFFFFFFFFFFFFLL;
    }
    if (rawBits >> 14 == 4 * v10) {
      return v9[2];
    }
    Swift::tuple_lowerBound_String_Index_offset_Int v13 = _StringBreadcrumbs.getBreadcrumb(forIndex:)((Swift::String::Index)rawBits);
    unsigned __int16 v12 = v13.lowerBound._rawBits;
    uint64_t v14 = rawBits >> 16;
    if (rawBits >> 16 < v13.lowerBound._rawBits >> 16) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    if ((v6 & 0x2000000000000000LL) != 0) {
LABEL_61:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    if ((v7 & 0x1000000000000000LL) != 0)
    {
      id v15 = (id)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (v11 < v14) {
        goto LABEL_61;
      }
    }

    else
    {
      id v15 = _StringObject.sharedUTF8.getter(v7, v6);
      unsigned __int16 v12 = v13.lowerBound._rawBits;
      uint64_t v11 = v31;
      uint64_t v14 = rawBits >> 16;
    }

    unint64_t v16 = ((unsigned __int16)rawBits >> 14) - (unint64_t)(v12 >> 14);
    uint64_t v17 = specialized UnsafeBufferPointer.init(rebasing:)(v13.lowerBound._rawBits >> 16, v14, (uint64_t)v15, v11);
    Swift::Int result = specialized UnsafeRawBufferPointer.init<A>(_:)(v17, v18);
    if (result)
    {
      unint64_t rawBits = result;
      unint64_t v20 = v19;
      int64_t v21 = (int8x8_t *)result;
      if ((*(_BYTE *)result & 0xC0) == 0x80)
      {
        unint64_t v22 = result + 1;
        do
        {
          int64_t v21 = (int8x8_t *)v22;
          if (v22 >= v19) {
            break;
          }
          ++v22;
        }

        while ((v21->i8[0] & 0xC0) == 0x80);
      }

      char v32 = v21;
      Swift::Int result = specialized String.UTF16View._utf16Length<A, B>(readPtr:endPtr:unsignedSIMDType:signedSIMDType:)( &v32,  v19);
      int64_t v23 = v32;
      if (result >= 1)
      {
        __int8 v24 = v32->i8[0];
        if ((v32->i8[0] & 0xC0) == 0x80)
        {
          if ((unint64_t)v32 > rawBits)
          {
            Swift::UInt64 v25 = (char *)&v32[-1] + 7;
            while ((unint64_t)v25 > rawBits)
            {
              __int8 v26 = *v25--;
              __int8 v24 = v26;
              if ((v26 & 0xC0) != 0x80)
              {
                int64_t v23 = (int8x8_t *)(v25 + 1);
                goto LABEL_37;
              }
            }

            __int8 v24 = *(_BYTE *)rawBits;
            int64_t v23 = (int8x8_t *)rawBits;
LABEL_37:
            char v32 = v23;
          }

          if ((v24 & 0xF8) == 0xF0)
          {
            result -= 2LL;
          }

          else
          {
            --result;
            if (v23 == (int8x8_t *)rawBits)
            {
LABEL_53:
              Swift::Int result = 0LL;
              goto LABEL_54;
            }
          }
        }
      }

      for (; (unint64_t)v23 < v20; result += v29)
      {
        unsigned int v27 = __clz(~v23->i8[0]) - 24;
        if (v23->i8[0] >= 0) {
          int v28 = 1;
        }
        else {
          int v28 = v27;
        }
        int64_t v23 = (int8x8_t *)((char *)v23 + v28);
        if (v28 == 4) {
          uint64_t v29 = 2LL;
        }
        else {
          uint64_t v29 = 1LL;
        }
      }
    }

Swift::String::Index __swiftcall String.UTF16View._nativeGetIndex(for:)(Swift::Int a1)
{
  if (a1 < 0)
  {
    unint64_t v32 = 883LL;
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  v32,  0);
  }

  if (!a1) {
    return (Swift::String::Index)15LL;
  }
  unint64_t v4 = v2;
  uint64_t v5 = v1;
  uint64_t v6 = (v2 >> 62) & 1;
  if ((v2 & 0x2000000000000000LL) == 0) {
    LODWORD(v6) = v1 < 0;
  }
  if ((_DWORD)v6 == 1) {
    return (Swift::String::Index)((a1 << 16) | 0xD);
  }
  uint64_t v8 = v1 & ~v2 & 0x2000000000000000LL;
  if (v2 >> 60)
  {
    if (!v8)
    {
LABEL_21:
      v12._unint64_t rawBits = 15LL;
      return (Swift::String::Index)(specialized BidirectionalCollection._index(_:offsetBy:)(v12, a1, v1, v2) | 4);
    }

    goto LABEL_13;
  }

  if (v8)
  {
LABEL_13:
    goto LABEL_15;
  }

Swift::String::Index_optional __swiftcall String.UTF16View.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  Swift::UInt64 rawBits = limitedBy._rawBits;
  uint64_t v10 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((limitedBy._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(limitedBy)._rawBits;
  }
  uint64_t v12 = HIBYTE(v5) & 0xF;
  if ((v5 & 0x2000000000000000LL) == 0) {
    uint64_t v12 = v6 & 0xFFFFFFFFFFFFLL;
  }
  Swift::UInt64 v13 = 4 * v12;
  if (4 * v12 < rawBits >> 14)
  {
    v18.unsigned int value = String.UTF16View.index(_:offsetBy:)(_, offsetBy);
    goto LABEL_37;
  }

  if ((_._rawBits & 0xC) != v11)
  {
    if (v13 >= _._rawBits >> 14) {
      goto LABEL_10;
    }
LABEL_41:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0xEDuLL,  0);
  }

  _._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  if (v13 < _._rawBits >> 14) {
    goto LABEL_41;
  }
LABEL_10:
  if ((v5 & 0x1000000000000000LL) != 0)
  {
    Swift::String::Index_optional v18 = String.UTF16View._foreignIndex(_:offsetBy:limitedBy:)(_, offsetBy, (Swift::String::Index)rawBits);
    Swift::Bool is_nil = v18.is_nil;
    goto LABEL_38;
  }

  uint64_t v14 = (v5 >> 62) & 1;
  if ((v5 & 0x2000000000000000LL) == 0) {
    LOBYTE(vHasher._combine(_:)(*v0 >> 14) = v6 < 0;
  }
  if ((v14 & 1) == 0)
  {
    if ((rawBits & 0xC001) == 0) {
      Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    }
    if ((_._rawBits & 0xC001) == 0) {
      _._Swift::UInt64 rawBits = _._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(_)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    }
    unint64_t v15 = 96LL;
    if (_._rawBits < 0x4000) {
      unint64_t v15 = 64LL;
    }
    unint64_t v16 = offsetBy >= 0 ? offsetBy : -offsetBy;
    if (v16 < v15)
    {
      v17._Swift::UInt64 rawBits = _._rawBits;
      v18.value._Swift::UInt64 rawBits = specialized BidirectionalCollection._index(_:offsetBy:limitedBy:)( v17,  offsetBy,  rawBits,  v6,  v5);
      Swift::Bool is_nil = v18.is_nil;
      if (!v18.is_nil) {
        v18.value._rawBits |= 4uLL;
      }
      goto LABEL_38;
    }
  }

  Swift::Int v20 = String.UTF16View._nativeGetOffset(for:)(_);
  v18.value._Swift::UInt64 rawBits = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)rawBits);
  if ((offsetBy & 0x8000000000000000LL) == 0)
  {
    if (rawBits >> 14 < _._rawBits >> 14) {
      goto LABEL_35;
    }
    if (!__OFADD__(v20, offsetBy))
    {
      goto LABEL_35;
    }

    __break(1u);
LABEL_46:
    __break(1u);
    return v18;
  }

  if (_._rawBits >> 14 < rawBits >> 14) {
    goto LABEL_35;
  }
  if (__OFADD__(v20, offsetBy)) {
    goto LABEL_46;
  }
  if (v20 + offsetBy < (uint64_t)v18.value._rawBits)
  {
LABEL_44:
    v18.value._Swift::UInt64 rawBits = 0LL;
    Swift::Bool is_nil = 1;
    goto LABEL_38;
  }

Swift::String::Index_optional __swiftcall String.UTF16View._foreignIndex(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  Swift::Int v5 = (limitedBy._rawBits >> 16) - (_._rawBits >> 16);
  if (offsetBy >= 1)
  {
LABEL_7:
    Swift::UInt64 v6 = 0LL;
    Swift::Bool v7 = 1;
    goto LABEL_14;
  }

  if (v5 <= 0 && v5 > offsetBy) {
    goto LABEL_7;
  }
LABEL_8:
  int64_t v8 = (_._rawBits >> 16) + offsetBy;
  if (v8 < 0) {
    goto LABEL_13;
  }
  unint64_t v9 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (v9 < v8) {
LABEL_13:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x29CuLL,  0);
  Swift::Bool v7 = 0;
  Swift::UInt64 v6 = (v8 << 16) | 8;
LABEL_14:
  result.value._Swift::UInt64 rawBits = v6;
  result.Swift::Bool is_nil = v7;
  return result;
}

Swift::Int __swiftcall String.UTF16View.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v4 = v3;
  uint64_t v5 = v2;
  Swift::UInt64 rawBits = from._rawBits;
  uint64_t v8 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = 4LL << v8;
  if ((from._rawBits & 0xC) == 4LL << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(from)._rawBits;
  }
  if ((to._rawBits & 0xC) == v9) {
    to._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
  }
  Swift::UInt64 v10 = rawBits >> 16;
  if ((v4 & 0x2000000000000000LL) != 0) {
    Swift::UInt64 v11 = HIBYTE(v4) & 0xF;
  }
  else {
    Swift::UInt64 v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < v10 && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u))
  {
    unint64_t v18 = 279LL;
    goto LABEL_39;
  }

  if (v11 < to._rawBits >> 16 && _swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u))
  {
    unint64_t v18 = 283LL;
LABEL_39:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  v18,  0);
  }

  if ((v4 & 0x1000000000000000LL) != 0) {
    return specialized String.UTF16View._foreignDistance(from:to:)(rawBits, to._rawBits);
  }
  Swift::Int result = (to._rawBits >> 16) - v10;
  uint64_t v13 = (v4 >> 62) & 1;
  if ((v4 & 0x2000000000000000LL) == 0) {
    LOBYTE(v13) = v5 < 0;
  }
  if ((v13 & 1) == 0)
  {
    if (rawBits < 0x4000 || to._rawBits < 0x4000)
    {
      if ((result & 0x8000000000000000LL) == 0)
      {
LABEL_27:
        if ((rawBits & 0xC001) == 0) {
          Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        }
        if ((to._rawBits & 0xC001) == 0) {
          to._Swift::UInt64 rawBits = to._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(to)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        }
        if (to._rawBits >> 14 >= rawBits >> 14) {
          return String.UTF16View._utf16Distance(from:to:)((Swift::String::Index)rawBits, to);
        }
        Swift::Int v16 = String.UTF16View._utf16Distance(from:to:)(to, (Swift::String::Index)rawBits);
        BOOL v17 = __OFSUB__(0LL, v16);
        Swift::Int result = -v16;
        if (v17) {
          __break(1u);
        }
        return result;
      }

      unint64_t v15 = 32LL;
    }

    else
    {
      if ((result & 0x8000000000000000LL) == 0)
      {
LABEL_23:
        Swift::Int v14 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)rawBits);
        return String.UTF16View._nativeGetOffset(for:)(to) - v14;
      }

      unint64_t v15 = 64LL;
    }

    if (v15 <= v10 - (to._rawBits >> 16)) {
      goto LABEL_23;
    }
    goto LABEL_27;
  }

  return result;
}

Swift::Int __swiftcall String.UTF16View._utf16Distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v4 = (int8x8_t *)(from._rawBits >> 16);
  Swift::UInt64 v5 = to._rawBits >> 16;
  if (to._rawBits >> 16 < from._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v6 = v3;
  uint64_t v7 = v2;
  unsigned __int16 rawBits = to._rawBits;
  unsigned __int16 v9 = from._rawBits;
  if ((v3 & 0x2000000000000000LL) != 0)
  {
    v41[0] = (int8x8_t *)v2;
    v41[1] = (int8x8_t *)(v3 & 0xFFFFFFFFFFFFFFLL);
    if ((HIBYTE(v3) & 0xF) >= v5)
    {
      if ((uint64_t)(v5 - (void)v4) < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      uint64_t v22 = (int8x8_t *)((char *)v41 + (void)v4);
      v5 += (Swift::UInt64)v41;
      unsigned int v23 = (int8x8_t *)((char *)v41 + (void)v4);
      if ((*((_BYTE *)v41 + (void)v4) & 0xC0) == 0x80)
      {
        unsigned int v24 = (int8x8_t *)((char *)v41 + (void)v4 + 1);
        do
        {
          unsigned int v23 = v24;
          unsigned int v24 = (int8x8_t *)((char *)v24 + 1);
        }

        while ((v23->i8[0] & 0xC0) == 0x80);
      }

      unint64_t v40 = v23;
      uint64_t v14 = specialized String.UTF16View._utf16Length<A, B>(readPtr:endPtr:unsignedSIMDType:signedSIMDType:)(&v40, v5);
      uint64_t v25 = v40;
      if (v14 >= 1)
      {
        __int8 v26 = v40->i8[0];
        if ((v40->i8[0] & 0xC0) == 0x80)
        {
          if (v22 < v40)
          {
            int v27 = (int8x8_t *)((char *)v41 + (void)v4);
            uint64_t v28 = (int8x8_t *)((char *)v40 - 1);
            do
            {
              if (v22 >= v28) {
                goto LABEL_33;
              }
              __int8 v29 = v28->i8[0];
              uint64_t v28 = (int8x8_t *)((char *)v28 - 1);
            }

            while ((v29 & 0xC0) == 0x80);
            int v27 = (int8x8_t *)((char *)v28 + 1);
LABEL_33:
            unint64_t v40 = v27;
            __int8 v26 = v27->i8[0];
            uint64_t v25 = v27;
          }

          if ((v26 & 0xF8) == 0xF0)
          {
            if (v25 == v22) {
              goto LABEL_21;
            }
            v14 -= 2LL;
          }

          else
          {
            --v14;
            if (v25 == v22) {
              goto LABEL_21;
            }
          }
        }
      }

      for (; (unint64_t)v25 < v5; v14 += v32)
      {
        unsigned int v30 = __clz(~v25->i8[0]) - 24;
        if (v25->i8[0] >= 0) {
          int v31 = 1;
        }
        else {
          int v31 = v30;
        }
        uint64_t v25 = (int8x8_t *)((char *)v25 + v31);
        if (v31 == 4) {
          uint64_t v32 = 2LL;
        }
        else {
          uint64_t v32 = 1LL;
        }
      }

      goto LABEL_65;
    }

Swift::Int __swiftcall String.UTF16View._foreignCount()()
{
  if ((v1 & 0x2000000000000000LL) != 0) {
    return HIBYTE(v1) & 0xF;
  }
  else {
    return v0 & 0xFFFFFFFFFFFFLL;
  }
}

Swift::Unicode::Scalar __swiftcall _StringGuts.fastUTF8Scalar(startingAt:)(Swift::Int startingAt)
{
  if ((v2 & 0x2000000000000000LL) != 0)
  {
    v6[0] = v1;
    v6[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    return (Swift::Unicode::Scalar)_decodeScalar(_:startingAt:)((uint64_t)v6, v1, startingAt);
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0) {
      id v4 = (id)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      id v4 = _StringObject.sharedUTF8.getter(v1, v2);
    }
    return (Swift::Unicode::Scalar)_decodeScalar(_:startingAt:)((uint64_t)v4, v1, startingAt);
  }

Swift::UInt16 __swiftcall String.UTF16View._foreignSubscript(position:)(Swift::String::Index position)
{
  return _StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:)((Swift::String::Index)(position._rawBits & 0xFFFFFFFFFFFF0000LL));
}

void protocol witness for BidirectionalCollection.index(before:) in conformance String.UTF16View( Swift::String::Index *a1@<X0>, uint64_t a2@<X2>, char *a3@<X3>, unint64_t *a4@<X8>)
{
  Swift::UInt64 rawBits = a1->_rawBits;
  uint64_t v7 = *v4;
  unint64_t v8 = v4[1];
  uint64_t v9 = ((unint64_t)*v4 >> 59) & 1;
  if ((v8 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((a1->_rawBits & 0xC) == 4LL << v9)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
    if (rawBits < 0x4000) {
      goto LABEL_24;
    }
  }

  else if (rawBits < 0x4000)
  {
    goto LABEL_24;
  }

  uint64_t v10 = HIBYTE(v8) & 0xF;
  uint64_t v11 = v7 & 0xFFFFFFFFFFFFLL;
  if ((v8 & 0x2000000000000000LL) != 0) {
    uint64_t v12 = HIBYTE(v8) & 0xF;
  }
  else {
    uint64_t v12 = v7 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v12 < rawBits >> 14) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0xAFuLL,  0);
  if ((v8 & 0x1000000000000000LL) != 0)
  {
    unint64_t v14 = specialized String.UTF16View._foreignIndex(before:)(rawBits);
    goto LABEL_29;
  }

  uint64_t v13 = (v8 >> 62) & 1;
  if ((v8 & 0x2000000000000000LL) == 0) {
    LOBYTE(v13) = v7 < 0;
  }
  if ((v13 & 1) != 0)
  {
    unint64_t v14 = (rawBits & 0xFFFFFFFFFFFF0000LL) - 65523;
LABEL_29:
    *a4 = v14;
    return;
  }

  if ((rawBits & 0xC000) != 0)
  {
    unint64_t v14 = rawBits & 0xFFFFFFFFFFFF0000LL | 5;
    goto LABEL_29;
  }

  if ((rawBits & 1) != 0)
  {
    uint64_t v15 = rawBits >> 16;
    if ((v8 & 0x2000000000000000LL) == 0) {
      goto LABEL_18;
    }
LABEL_27:
    v22[0] = v7;
    v22[1] = v8 & 0xFFFFFFFFFFFFFFLL;
    closure #1 in _StringGuts.fastUTF8ScalarLength(endingAt:)((uint64_t)v22, v10, v15, &v21);
    uint64_t v17 = v21;
    if (v21 != 4) {
      goto LABEL_21;
    }
LABEL_28:
    unint64_t v14 = (rawBits & 0xFFFFFFFFFFFF0000LL) - 245756;
    goto LABEL_29;
  }

  v20._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
  uint64_t v10 = HIBYTE(v8) & 0xF;
  Swift::UInt64 rawBits = v20._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  uint64_t v15 = rawBits >> 16;
  if ((v8 & 0x2000000000000000LL) != 0) {
    goto LABEL_27;
  }
LABEL_18:
  if ((v7 & 0x1000000000000000LL) != 0)
  {
    id v16 = (id)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
  }

  else
  {
    id v16 = _StringObject.sharedUTF8.getter(v7, v8);
    uint64_t v11 = v10;
  }

  swift_bridgeObjectRetain(v8, v10, a2, a3);
  closure #1 in _StringGuts.fastUTF8ScalarLength(endingAt:)((uint64_t)v16, v11, v15, v22);
  swift_bridgeObjectRelease(v8);
  uint64_t v17 = v22[0];
  if (v22[0] == 4) {
    goto LABEL_28;
  }
LABEL_21:
  BOOL v18 = __OFSUB__(0LL, v17);
  uint64_t v19 = -v17;
  if (!v18)
  {
    unint64_t v14 = ((v19 + v15) << 16) | 5;
    goto LABEL_29;
  }

  __break(1u);
  swift_errorRelease(0LL);
  swift_bridgeObjectRelease(v8);
  __break(1u);
  swift_errorRelease(0LL);
  __break(1u);
}

unint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance String.UTF16View( Swift::UInt64 *a1)
{
  uint64_t v4 = *v1;
  unint64_t v3 = v1[1];
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = ((unint64_t)v4 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v6)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if (rawBits < 0x4000) {
      goto LABEL_26;
    }
  }

  else if (rawBits < 0x4000)
  {
    goto LABEL_26;
  }

  unint64_t v7 = HIBYTE(v3) & 0xF;
  uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000LL) != 0) {
    uint64_t v9 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v9 < rawBits >> 14) {
LABEL_26:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0xAFuLL,  0);
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = specialized String.UTF16View._foreignIndex(before:)(rawBits);
    goto LABEL_38;
  }

  uint64_t v10 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = v4 < 0;
  }
  if ((v10 & 1) != 0)
  {
    unint64_t result = (rawBits & 0xFFFFFFFFFFFF0000LL) - 65523;
    goto LABEL_38;
  }

  if ((rawBits & 0xC000) != 0)
  {
    unint64_t result = rawBits & 0xFFFFFFFFFFFF0000LL | 5;
    goto LABEL_38;
  }

  if ((rawBits & 1) != 0)
  {
    Swift::UInt64 v12 = rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) == 0) {
      goto LABEL_18;
    }
  }

  else
  {
    unint64_t v21 = v4 & 0xFFFFFFFFFFFFLL;
    v16._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    unint64_t v7 = HIBYTE(v3) & 0xF;
    uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
    Swift::UInt64 rawBits = v16._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
    Swift::UInt64 v12 = rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) == 0)
    {
LABEL_18:
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        uint64_t v13 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
        if (rawBits >= 0x10000) {
          goto LABEL_20;
        }
      }

      else
      {
        unint64_t v21 = rawBits;
        uint64_t v18 = v3;
        Swift::UInt64 v19 = v12;
        id v20 = _StringObject.sharedUTF8.getter(v4, v18);
        Swift::UInt64 v12 = v19;
        uint64_t v13 = (uint64_t)v20;
        Swift::UInt64 rawBits = v21;
        if (v21 >= 0x10000)
        {
LABEL_20:
          uint64_t v14 = 0LL;
          uint64_t v15 = v12 + v13 - 1;
          while ((uint64_t)v12 <= v8)
          {
            if ((*(_BYTE *)(v15 + v14) & 0xC0) != 0x80) {
              goto LABEL_35;
            }
          }

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance String.UTF16View@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = String.UTF16View.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String.UTF16View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void, void, void))String.UTF16View.index(_:offsetBy:limitedBy:),  a4);
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance String.UTF16View( Swift::String::Index *a1, Swift::String::Index *a2)
{
  return String.UTF16View.distance(from:to:)((Swift::String::Index)a1->_rawBits, (Swift::String::Index)a2->_rawBits);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance String.UTF16View( _WORD *a1, Swift::String::Index *a2))()
{
  Swift::UInt64 rawBits = a2->_rawBits;
  uint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = ((unint64_t)*v2 >> 59) & 1;
  if ((v6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((a2->_rawBits & 0xC) == 4LL << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)a2->_rawBits)._rawBits;
  }
  unint64_t v8 = rawBits >> 16;
  unint64_t v9 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 >= v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x1A7uLL,  0);
  }
  if ((v6 & 0x1000000000000000LL) != 0)
  {
    __int16 value = String.UTF16View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }

  else
  {
    if ((rawBits & 1) == 0) {
      unint64_t v8 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits >> 16;
    }
    v10.___int16 value = _StringGuts.fastUTF8Scalar(startingAt:)(v8)._value;
    if ((rawBits & 0xC000) == 0x4000)
    {
      if (!HIWORD(v10._value)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
      }
      __int16 value = v10._value & 0x3FF | 0xDC00;
    }

    else if (HIWORD(v10._value))
    {
      __int16 value = ((v10._value + 67043328) >> 10) - 10240;
    }

    else
    {
      __int16 value = v10._value;
    }
  }

  *a1 = value;
  return EnumeratedSequence._base.modify;
}

unint64_t protocol witness for Collection.subscript.getter in conformance String.UTF8View@<X0>( Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  v4._Swift::UInt64 rawBits = a1[1];
  v5._Swift::UInt64 rawBits = *a1;
  *a2 = specialized String.UTF8View.subscript.getter(v5, v4, *v2, v2[1]);
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = (Swift::UInt64)v8;
  return swift_bridgeObjectRetain((unint64_t)v8, v6, v7, v8);
}

Swift::UInt64 String.UTF8View.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 v4 = specialized String.UTF8View.subscript.getter(a1, a2, a3, a4);
  swift_bridgeObjectRetain((unint64_t)v7, v5, v6, v7);
  return v4;
}

Swift::Int protocol witness for Collection.count.getter in conformance String.UTF16View()
{
  unint64_t v1 = v0[1];
  if ((v1 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignCount()();
  }
  uint64_t v2 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = *v0;
  }
  return String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v2 << 16) | 7));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, uint64_t, void, void, void)@<X5>, uint64_t a5@<X8>)
{
  uint64_t result = a4(*a1, a2, *a3, *v5, v5[1]);
  *(void *)a5 = result;
  *(_BYTE *)(a5 + 8) = v8 & 1;
  return result;
}

unint64_t protocol witness for Collection.index(after:) in conformance String.UTF16View@<X0>( Swift::UInt64 *a1@<X0>, unint64_t *a2@<X8>)
{
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  uint64_t v7 = ((unint64_t)*v2 >> 59) & 1;
  if ((v5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v8 = rawBits >> 16;
  unint64_t v9 = HIBYTE(v5) & 0xF;
  if ((v5 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 >= v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
  }
  if ((v5 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = specialized String.UTF16View._foreignIndex(after:)(rawBits);
    goto LABEL_29;
  }

  uint64_t v10 = (v5 >> 62) & 1;
  if ((v5 & 0x2000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = v6 < 0;
  }
  if ((v10 & 1) == 0)
  {
    if ((rawBits & 0xC001) != 0)
    {
      if ((v5 & 0x2000000000000000LL) == 0)
      {
LABEL_15:
        if ((v6 & 0x1000000000000000LL) != 0)
        {
          LODWORD(v12) = *(unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32 + v8);
          if ((v12 & 0x80) != 0) {
            goto LABEL_17;
          }
LABEL_26:
          uint64_t v12 = 1LL;
          goto LABEL_27;
        }

        Swift::UInt64 v15 = rawBits;
        uint64_t v12 = (uint64_t)_StringObject.sharedUTF8.getter(v6, v5);
        Swift::UInt64 rawBits = v15;
        LODWORD(v12) = *(unsigned __int8 *)(v12 + v8);
        if ((v12 & 0x80) == 0) {
          goto LABEL_26;
        }
LABEL_17:
        LODWORD(v12) = __clz(v12 ^ 0xFF) - 24;
        if ((_DWORD)v12 == 4)
        {
          if ((rawBits & 0xC000) == 0)
          {
            unsigned __int16 v13 = 16388;
LABEL_28:
            unint64_t result = rawBits & 0xFFFFFFFFFFFF0000LL | v13;
            goto LABEL_29;
          }

          uint64_t v12 = 4LL;
        }

        else
        {
          uint64_t v12 = v12;
        }

unint64_t protocol witness for Collection.formIndex(after:) in conformance String.UTF16View( Swift::UInt64 *a1)
{
  uint64_t v4 = *v1;
  unint64_t v3 = v1[1];
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = ((unint64_t)*v1 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v7 = rawBits >> 16;
  unint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
  }
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = specialized String.UTF16View._foreignIndex(after:)(rawBits);
    goto LABEL_29;
  }

  uint64_t v9 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LOBYTE(v9) = v4 < 0;
  }
  if ((v9 & 1) == 0)
  {
    if ((rawBits & 0xC001) != 0)
    {
      if ((v3 & 0x2000000000000000LL) == 0)
      {
LABEL_15:
        if ((v4 & 0x1000000000000000LL) != 0)
        {
          LODWORD(v11) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v7);
          if ((v11 & 0x80) != 0) {
            goto LABEL_17;
          }
LABEL_26:
          uint64_t v11 = 1LL;
          goto LABEL_27;
        }

        Swift::UInt64 v14 = rawBits;
        uint64_t v11 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v3);
        Swift::UInt64 rawBits = v14;
        LODWORD(v11) = *(unsigned __int8 *)(v11 + v7);
        if ((v11 & 0x80) == 0) {
          goto LABEL_26;
        }
LABEL_17:
        LODWORD(v11) = __clz(v11 ^ 0xFF) - 24;
        if ((_DWORD)v11 == 4)
        {
          if ((rawBits & 0xC000) == 0)
          {
            unsigned __int16 v12 = 16388;
LABEL_28:
            unint64_t result = rawBits & 0xFFFFFFFFFFFF0000LL | v12;
            goto LABEL_29;
          }

          uint64_t v11 = 4LL;
        }

        else
        {
          uint64_t v11 = v11;
        }

void protocol witness for Sequence.makeIterator() in conformance String.UTF16View(uint64_t a1@<X8>)
{
  unint64_t v2 = v1[1];
  uint64_t v3 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v3 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  *(void *)a1 = *v1;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = v3;
  *(_WORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 34) = 1;
}

uint64_t String.UTF16View.makeIterator()@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = HIBYTE(a2) & 0xF;
  *(void *)a3 = result;
  *(void *)(a3 + 8) = a2;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v3 = result & 0xFFFFFFFFFFFFLL;
  }
  *(void *)(a3 + 16) = 0LL;
  *(void *)(a3 + 24) = v3;
  *(_WORD *)(a3 + 32) = 0;
  *(_BYTE *)(a3 + 34) = 1;
  return result;
}

Swift::Int protocol witness for Sequence.underestimatedCount.getter in conformance String.UTF16View()
{
  return specialized Collection.underestimatedCount.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance String.UTF16View( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance String( a1,  a2,  (uint64_t (*)(void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance String.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *(void *)v3, *(void *)(v3 + 8));
}

uint64_t String.UTF16View.Iterator._guts.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *v4;
  swift_bridgeObjectRetain(v4[1], a2, a3, a4);
  return v5;
}

void String.UTF16View.Iterator._guts.setter(uint64_t a1, uint64_t a2)
{
  void *v2 = a1;
  v2[1] = a2;
}

uint64_t (*String.UTF16View.Iterator._guts.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.UTF16View.Iterator._position.getter()
{
  return *(void *)(v0 + 16);
}

uint64_t String.UTF16View.Iterator._position.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*String.UTF16View.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.UTF16View.Iterator._end.getter()
{
  return *(void *)(v0 + 24);
}

uint64_t String.UTF16View.Iterator._end.setter(uint64_t result)
{
  *(void *)(v1 + 24) = result;
  return result;
}

uint64_t (*String.UTF16View.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.UTF16View.Iterator._nextIsTrailingSurrogate.getter()
{
  return *(unsigned __int16 *)(v0 + 32) | (*(unsigned __int8 *)(v0 + 34) << 16);
}

uint64_t String.UTF16View.Iterator._nextIsTrailingSurrogate.setter(uint64_t result)
{
  *(_WORD *)(v1 + 32) = result;
  *(_BYTE *)(v1 + 34) = BYTE2(result) & 1;
  return result;
}

uint64_t (*String.UTF16View.Iterator._nextIsTrailingSurrogate.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.UTF16View.Iterator.init(_:)@<X0>( uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = HIBYTE(a2) & 0xF;
  *(void *)a3 = result;
  *(void *)(a3 + 8) = a2;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v3 = result & 0xFFFFFFFFFFFFLL;
  }
  *(void *)(a3 + 16) = 0LL;
  *(void *)(a3 + 24) = v3;
  *(_WORD *)(a3 + 32) = 0;
  *(_BYTE *)(a3 + 34) = 1;
  return result;
}

Swift::UInt16_optional __swiftcall String.UTF16View.Iterator.next()()
{
  if ((*(_BYTE *)(v0 + 34) & 1) != 0)
  {
    uint64_t v1 = *(void *)(v0 + 16);
    if (v1 >= *(void *)(v0 + 24))
    {
      LOWORD(v3) = 0;
      int v5 = 1;
    }

    else
    {
      uint64_t v2 = *(void *)v0;
      uint64_t v3 = *(void *)(v0 + 8);
      if ((v3 & 0x1000000000000000LL) != 0)
      {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v9 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v1 << 16));
        Swift::Int scalarLength = v9.scalarLength;
        uint64_t v6 = *(void *)&v9._0._value;
        goto LABEL_10;
      }

      if ((v3 & 0x2000000000000000LL) != 0)
      {
        v12[0] = *(void *)v0;
        v12[1] = v3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v4 = v12;
      }

      else
      {
        if ((v2 & 0x1000000000000000LL) == 0) {
          goto LABEL_17;
        }
        uint64_t v4 = (void *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      while (1)
      {
        uint64_t v6 = _decodeScalar(_:startingAt:)((uint64_t)v4, v2, v1);
LABEL_10:
        LOWORD(v3) = v6;
        *(void *)(v0 + 16) += scalarLength;
        int v10 = v6;
        *(_WORD *)(v0 + 32) = Unicode.Scalar.UTF16View.subscript.getter(1LL, v6);
        *(_BYTE *)(v0 + 34) = 0;
        uint64_t v3 = (unsigned __int16)((v10 + 67043328) >> 10) + 55296;
        if ((v3 & 0x10000) == 0) {
          break;
        }
        __break(1u);
LABEL_17:
        uint64_t v11 = v1;
        uint64_t v4 = _StringObject.sharedUTF8.getter(v2, v3);
        uint64_t v1 = v11;
      }

      int v5 = 0;
    }
  }

  else
  {
    int v5 = 0;
    LOWORD(v3) = *(_WORD *)(v0 + 32);
    *(_WORD *)(v0 + 32) = 0;
    *(_BYTE *)(v0 + 34) = 1;
  }

  return (Swift::UInt16_optional)((unsigned __int16)v3 | (v5 << 16));
}

uint64_t protocol witness for IteratorProtocol.next() in conformance String.UTF16View.Iterator@<X0>( uint64_t a1@<X8>)
{
  *(Swift::UInt16_optional *)&uint64_t result = String.UTF16View.Iterator.next()();
  *(_WORD *)a1 = result;
  *(_BYTE *)(a1 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t String.UTF16View.debugDescription.getter(uint64_t a1, unint64_t x1_0)
{
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(15LL);
  unint64_t v5 = (unint64_t)v4;
  v261._uint64_t countAndFlagsBits = v3;
  v261._unint64_t object = v4;
  Swift::String v8 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("StringUTF16(", 0xCuLL, 1);
  uint64_t v9 = HIBYTE(v5) & 0xF;
  uint64_t v10 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000LL) != 0) {
    uint64_t v11 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v11 = v3 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v251 = x1_0;
  if (v11 || (v3 & ~v5 & 0x2000000000000000LL) != 0)
  {
    uint64_t v12 = (uint64_t)v8._object & 0x2000000000000000LL;
    unint64_t v13 = ((unint64_t)v8._object >> 56) & 0xF;
    if ((v5 & 0x2000000000000000LL) != 0 && v12)
    {
      unint64_t v14 = v13 + v9;
      if (v13 + v9 <= 0xF)
      {
        if (v13)
        {
          char v66 = 0;
          unint64_t v67 = 0LL;
          unint64_t v68 = v5;
          x1_0 = v251;
          uint64_t v27 = a1;
          do
          {
            unint64_t v69 = v9 + v67;
            unint64_t v70 = v67 + 1;
            if (v67 >= 8) {
              unint64_t object = (unint64_t)v8._object;
            }
            else {
              unint64_t object = v8._countAndFlagsBits;
            }
            unint64_t v72 = object >> (v66 & 0x38);
            char v73 = (8 * v9 + v66) & 0x38;
            uint64_t v74 = (-255LL << v73) - 1;
            unint64_t v75 = (unint64_t)v72 << v73;
            unint64_t v76 = v75 | v74 & v68;
            unint64_t v77 = v75 | v74 & v3;
            if (v69 < 8) {
              unint64_t v3 = v77;
            }
            else {
              unint64_t v68 = v76;
            }
            v66 += 8;
            unint64_t v67 = v70;
          }

          while (v13 != v70);
        }

        else
        {
          unint64_t v68 = v5;
          x1_0 = v251;
          uint64_t v27 = a1;
        }

        swift_bridgeObjectRelease(v5);
        swift_bridgeObjectRelease((uint64_t)v8._object);
        unint64_t v83 = 0xA000000000000000LL;
        if (!(v3 & 0x8080808080808080LL | v68 & 0x80808080808080LL)) {
          unint64_t v83 = 0xE000000000000000LL;
        }
        unint64_t v65 = (void *)(v83 & 0xFF00000000000000LL | (v14 << 56) | v68 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_88;
      }

      uint64_t v12 = 1LL;
    }

    if (v12) {
      int64_t v15 = ((unint64_t)v8._object >> 56) & 0xF;
    }
    else {
      int64_t v15 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v8._object, 2LL, v6, v7);
    uint64_t v254 = v15;
    if (((uint64_t)v8._object & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v8._object, 5LL, v16, v17);
      v235._Swift::UInt64 rawBits = 1LL;
      v236._Swift::UInt64 rawBits = (v15 << 16) | 1;
      v237._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v235,  v236,  v8._countAndFlagsBits,  (unint64_t)v8._object);
      if (v237._rawBits < 0x10000) {
        v237._rawBits |= 3;
      }
      int64_t v15 = specialized Collection.count.getter(v237, v238, v8._countAndFlagsBits, (unint64_t)v8._object);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      if ((v5 & 0x1000000000000000LL) == 0)
      {
LABEL_15:
        BOOL v18 = __OFADD__(v11, v15);
        Swift::Int v19 = v11 + v15;
        if (!v18)
        {
LABEL_16:
          unint64_t v20 = v3 & ~v5;
          if ((v20 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
            if ((v22 & 1) != 0)
            {
LABEL_286:
              unint64_t v243 = 258LL;
              goto LABEL_287;
            }

            if (v19 > 15) {
              goto LABEL_24;
            }
            if ((v5 & 0x2000000000000000LL) == 0)
            {
              if (v21 < v15)
              {
LABEL_46:
                swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
                if ((v5 & 0x1000000000000000LL) == 0)
                {
                  if ((v3 & 0x1000000000000000LL) != 0)
                  {
                    unint64_t v40 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  }

                  else
                  {
                    unint64_t v40 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v5);
                    uint64_t v10 = v37;
                  }

                  x1_0 = v251;
                  uint64_t v41 = v254;
                  swift_bridgeObjectRetain(v5, v37, v38, v39);
                  closure #1 in _StringGuts._convertedToSmall()(v40, v10, &v260);
                  swift_bridgeObjectRelease(v5);
                  unint64_t v3 = v260;
                  unint64_t v42 = *((void *)&v260 + 1);
                  goto LABEL_53;
                }

                goto LABEL_289;
              }

LABEL_278:
        __break(1u);
LABEL_279:
        unint64_t v240 = 816LL;
LABEL_280:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  v240,  0);
      }
    }

    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v8._object, 4LL, v16, v17);
      if ((v5 & 0x1000000000000000LL) == 0) {
        goto LABEL_15;
      }
    }

    Swift::Int v239 = String.UTF8View._foreignCount()();
    Swift::Int v19 = v239 + v15;
    if (!__OFADD__(v239, v15)) {
      goto LABEL_16;
    }
    goto LABEL_278;
  }

  swift_bridgeObjectRelease(v5);
  Swift::String v261 = v8;
  uint64_t v27 = a1;
LABEL_89:
  uint64_t v84 = 34LL;
  uint64_t v85 = 0xE100000000000000LL;
  *(void *)&unsigned __int128 v260 = 34LL;
  *((void *)&v260 + 1) = 0xE100000000000000LL;
  uint64_t v86 = HIBYTE(x1_0) & 0xF;
  if ((x1_0 & 0x2000000000000000LL) == 0) {
    uint64_t v86 = v27 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v255 = v86;
  if (!v86)
  {
    unint64_t v110 = 0xE100000000000000LL;
    goto LABEL_195;
  }

  uint64_t v87 = 0LL;
  uint64_t v248 = (x1_0 & 0xFFFFFFFFFFFFFFFLL) + 32;
  uint64_t v249 = x1_0 & 0xFFFFFFFFFFFFFFLL;
  char v88 = 1;
  do
  {
    while (1)
    {
      if ((x1_0 & 0x1000000000000000LL) != 0)
      {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v93 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v87 << 16));
        Swift::Int scalarLength = v93.scalarLength;
        unsigned int value = v93._0._value;
      }

      else
      {
        if ((x1_0 & 0x2000000000000000LL) != 0)
        {
          uint64_t v258 = v27;
          uint64_t v259 = v249;
          unsigned int v90 = &v258;
        }

        else
        {
          unsigned int v90 = (uint64_t *)v248;
          if ((v27 & 0x1000000000000000LL) == 0) {
            unsigned int v90 = (uint64_t *)_StringObject.sharedUTF8.getter(v27, x1_0);
          }
        }

        unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v90, v34, v87);
      }

      unsigned int v94 = value;
      v87 += scalarLength;
      unsigned __int128 v98 = (unsigned __int128)Unicode.Scalar._escaped(asASCII:)(0);
      uint64_t v95 = (void *)*((void *)&v98 + 1);
      if (*((void *)&v98 + 1))
      {
        uint64_t v99 = *((void *)&v260 + 1);
        unint64_t v100 = HIBYTE(*((void *)&v260 + 1)) & 0xFLL;
        if ((*((void *)&v260 + 1) & 0x2000000000000000LL) == 0) {
          unint64_t v100 = v260 & 0xFFFFFFFFFFFFLL;
        }
        if (v100 || ((unint64_t)v260 & ~*((void *)&v260 + 1) & 0x2000000000000000LL) != 0)
        {
          if ((*((void *)&v98 + 1) & 0x2000000000000000LL & *((void *)&v260 + 1)) == 0
            || (unint64_t v101 = specialized _SmallString.init(_:appending:)( v260,  *((unint64_t *)&v260 + 1),  v98,  *((unint64_t *)&v98 + 1)),  (v96 & 1) != 0))
          {
            if ((*((void *)&v98 + 1) & 0x2000000000000000LL) != 0) {
              uint64_t v89 = HIBYTE(*((void *)&v98 + 1)) & 0xFLL;
            }
            else {
              uint64_t v89 = v98 & 0xFFFFFFFFFFFFLL;
            }
            swift_bridgeObjectRetain(*((unint64_t *)&v98 + 1), (uint64_t)v95, v96, v97);
            _StringGuts.append(_:)(v98, *((unint64_t *)&v98 + 1), 0LL, v89);
            swift_bridgeObjectRelease_n(*((uint64_t *)&v98 + 1), 2LL);
          }

          else
          {
            uint64_t v102 = v101;
            unint64_t v103 = v95;
            swift_bridgeObjectRelease(v99);
            swift_bridgeObjectRelease(*((uint64_t *)&v98 + 1));
            *(void *)&unsigned __int128 v260 = v102;
            *((void *)&v260 + 1) = v103;
          }
        }

        else
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v260 + 1));
          unsigned __int128 v260 = v98;
        }

        goto LABEL_97;
      }

      uint64_t v105 = v260;
      unint64_t v104 = *((void *)&v260 + 1);
      if ((v88 & 1) != 0)
      {
        LODWORD(v258) = 0;
        swift_bridgeObjectRetain(*((unint64_t *)&v260 + 1), 0LL, v96, v97);
        unint64_t v106 = specialized BidirectionalCollection.last.getter(v105, v104);
        swift_bridgeObjectRelease(v104);
        if ((v106 & 0x100000000LL) != 0) {
          goto LABEL_279;
        }
        if (!_GraphemeBreakingState.shouldBreak(between:and:)( (Swift::Unicode::Scalar)v106,  (Swift::Unicode::Scalar)v94)) {
          break;
        }
      }

      uint64_t v258 = v105;
      uint64_t v259 = v104;
      *(void *)&unsigned __int128 v260 = 0LL;
      *((void *)&v260 + 1) = 0xE000000000000000LL;
      unint64_t v110 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v94);
      uint64_t v84 = v107;
      uint64_t v111 = v107 & 0x2000000000000000LL;
      uint64_t v112 = HIBYTE(v107) & 0xF;
      uint64_t v113 = HIBYTE(v104) & 0xF;
      if ((v104 & 0x2000000000000000LL) != 0 && v111)
      {
        if ((unint64_t)(v112 + v113) <= 0xF)
        {
          swift_bridgeObjectRelease(v107);
          if (v112)
          {
            char v152 = 0;
            unint64_t v153 = 0LL;
            unint64_t v154 = v104;
            do
            {
              unint64_t v155 = v113 + v153;
              unint64_t v156 = v153 + 1;
              if (v153 >= 8) {
                unint64_t v157 = v84;
              }
              else {
                unint64_t v157 = v110;
              }
              unint64_t v158 = v157 >> (v152 & 0x38);
              char v159 = (8 * v113 + v152) & 0x38;
              uint64_t v160 = (-255LL << v159) - 1;
              unint64_t v161 = (unint64_t)v158 << v159;
              unint64_t v162 = v161 | v160 & v154;
              unint64_t v163 = v161 | v160 & v105;
              if (v155 < 8) {
                uint64_t v105 = v163;
              }
              else {
                unint64_t v154 = v162;
              }
              v152 += 8;
              unint64_t v153 = v156;
            }

            while (v112 != v156);
          }

          else
          {
            unint64_t v154 = v104;
          }

          swift_bridgeObjectRelease(v104);
          unint64_t v174 = 0xE000000000000000LL;
          if (v105 & 0x8080808080808080LL | v154 & 0x80808080808080LL) {
            unint64_t v174 = 0xA000000000000000LL;
          }
          uint64_t v258 = v105;
          uint64_t v259 = v174 & 0xFF00000000000000LL | ((v112 + v113) << 56) | v154 & 0xFFFFFFFFFFFFFFLL;
          x1_0 = v251;
          uint64_t v27 = a1;
          goto LABEL_181;
        }

        uint64_t v111 = 1LL;
      }

      if (v111) {
        int64_t v114 = HIBYTE(v107) & 0xF;
      }
      else {
        int64_t v114 = v110 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain(v107, v107, v108, v109);
      uint64_t v253 = v114;
      if ((v84 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v84, 5LL, v115, v116);
        v175._Swift::UInt64 rawBits = 1LL;
        v176._Swift::UInt64 rawBits = (v114 << 16) | 1;
        v177._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v175, v176, v110, v84);
        if (v177._rawBits < 0x10000) {
          v177._rawBits |= 3;
        }
        int64_t v114 = specialized Collection.count.getter(v177, v178, v110, v84);
        swift_bridgeObjectRelease(v84);
        uint64_t v250 = v110 & 0xFFFFFFFFFFFFLL;
        if ((v104 & 0x1000000000000000LL) != 0)
        {
LABEL_188:
          Swift::Int v117 = String.UTF8View._foreignCount()();
          int64_t v118 = v117 + v114;
          if (__OFADD__(v117, v114)) {
            goto LABEL_259;
          }
          goto LABEL_129;
        }
      }

      else
      {
        swift_bridgeObjectRetain_n(v84, 4LL, v115, v116);
        uint64_t v250 = v110 & 0xFFFFFFFFFFFFLL;
        if ((v104 & 0x1000000000000000LL) != 0) {
          goto LABEL_188;
        }
      }

      if ((v104 & 0x2000000000000000LL) != 0) {
        Swift::Int v117 = HIBYTE(v104) & 0xF;
      }
      else {
        Swift::Int v117 = v105 & 0xFFFFFFFFFFFFLL;
      }
      int64_t v118 = v117 + v114;
      if (__OFADD__(v117, v114))
      {
LABEL_259:
        __break(1u);
        goto LABEL_260;
      }

        __break(1u);
LABEL_279:
        unint64_t v240 = 816LL;
LABEL_280:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  v240,  0);
      }
    }

    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v8._object, 4LL, v16, v17);
      if ((v5 & 0x1000000000000000LL) == 0) {
        goto LABEL_15;
      }
    }

    Swift::Int v239 = String.UTF8View._foreignCount()();
    Swift::Int v19 = v239 + v15;
    if (!__OFADD__(v239, v15)) {
      goto LABEL_16;
    }
    goto LABEL_278;
  }

  swift_bridgeObjectRelease(v5);
  Swift::String v261 = v8;
  uint64_t v27 = a1;
LABEL_89:
  uint64_t v84 = 34LL;
  uint64_t v85 = 0xE100000000000000LL;
  *(void *)&unsigned __int128 v260 = 34LL;
  *((void *)&v260 + 1) = 0xE100000000000000LL;
  uint64_t v86 = HIBYTE(x1_0) & 0xF;
  if ((x1_0 & 0x2000000000000000LL) == 0) {
    uint64_t v86 = v27 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v255 = v86;
  if (!v86)
  {
    unint64_t v110 = 0xE100000000000000LL;
    goto LABEL_195;
  }

  uint64_t v87 = 0LL;
  uint64_t v248 = (x1_0 & 0xFFFFFFFFFFFFFFFLL) + 32;
  uint64_t v249 = x1_0 & 0xFFFFFFFFFFFFFFLL;
  char v88 = 1;
  do
  {
    while (1)
    {
      if ((x1_0 & 0x1000000000000000LL) != 0)
      {
        Swift::tuple_Unicode_Scalar_scalarLength_Int v93 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v87 << 16));
        Swift::Int scalarLength = v93.scalarLength;
        unsigned int value = v93._0._value;
      }

      else
      {
        if ((x1_0 & 0x2000000000000000LL) != 0)
        {
          uint64_t v258 = v27;
          uint64_t v259 = v249;
          unsigned int v90 = &v258;
        }

        else
        {
          unsigned int v90 = (uint64_t *)v248;
          if ((v27 & 0x1000000000000000LL) == 0) {
            unsigned int v90 = (uint64_t *)_StringObject.sharedUTF8.getter(v27, x1_0);
          }
        }

        unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v90, v34, v87);
      }

      unsigned int v94 = value;
      v87 += scalarLength;
      unsigned __int128 v98 = (unsigned __int128)Unicode.Scalar._escaped(asASCII:)(0);
      uint64_t v95 = (void *)*((void *)&v98 + 1);
      if (*((void *)&v98 + 1))
      {
        uint64_t v99 = *((void *)&v260 + 1);
        unint64_t v100 = HIBYTE(*((void *)&v260 + 1)) & 0xFLL;
        if ((*((void *)&v260 + 1) & 0x2000000000000000LL) == 0) {
          unint64_t v100 = v260 & 0xFFFFFFFFFFFFLL;
        }
        if (v100 || ((unint64_t)v260 & ~*((void *)&v260 + 1) & 0x2000000000000000LL) != 0)
        {
          if ((*((void *)&v98 + 1) & 0x2000000000000000LL & *((void *)&v260 + 1)) == 0
            || (unint64_t v101 = specialized _SmallString.init(_:appending:)( v260,  *((unint64_t *)&v260 + 1),  v98,  *((unint64_t *)&v98 + 1)),  (v96 & 1) != 0))
          {
            if ((*((void *)&v98 + 1) & 0x2000000000000000LL) != 0) {
              uint64_t v89 = HIBYTE(*((void *)&v98 + 1)) & 0xFLL;
            }
            else {
              uint64_t v89 = v98 & 0xFFFFFFFFFFFFLL;
            }
            swift_bridgeObjectRetain(*((unint64_t *)&v98 + 1), (uint64_t)v95, v96, v97);
            _StringGuts.append(_:)(v98, *((unint64_t *)&v98 + 1), 0LL, v89);
            swift_bridgeObjectRelease_n(*((uint64_t *)&v98 + 1), 2LL);
          }

          else
          {
            uint64_t v102 = v101;
            unint64_t v103 = v95;
            swift_bridgeObjectRelease(v99);
            swift_bridgeObjectRelease(*((uint64_t *)&v98 + 1));
            *(void *)&unsigned __int128 v260 = v102;
            *((void *)&v260 + 1) = v103;
          }
        }

        else
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v260 + 1));
          unsigned __int128 v260 = v98;
        }

        goto LABEL_97;
      }

      uint64_t v105 = v260;
      unint64_t v104 = *((void *)&v260 + 1);
      if ((v88 & 1) != 0)
      {
        LODWORD(v258) = 0;
        swift_bridgeObjectRetain(*((unint64_t *)&v260 + 1), 0LL, v96, v97);
        unint64_t v106 = specialized BidirectionalCollection.last.getter(v105, v104);
        swift_bridgeObjectRelease(v104);
        if ((v106 & 0x100000000LL) != 0) {
          goto LABEL_279;
        }
        if (!_GraphemeBreakingState.shouldBreak(between:and:)( (Swift::Unicode::Scalar)v106,  (Swift::Unicode::Scalar)v94)) {
          break;
        }
      }

      uint64_t v258 = v105;
      uint64_t v259 = v104;
      *(void *)&unsigned __int128 v260 = 0LL;
      *((void *)&v260 + 1) = 0xE000000000000000LL;
      unint64_t v110 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v94);
      uint64_t v84 = v107;
      uint64_t v111 = v107 & 0x2000000000000000LL;
      uint64_t v112 = HIBYTE(v107) & 0xF;
      uint64_t v113 = HIBYTE(v104) & 0xF;
      if ((v104 & 0x2000000000000000LL) != 0 && v111)
      {
        if ((unint64_t)(v112 + v113) <= 0xF)
        {
          swift_bridgeObjectRelease(v107);
          if (v112)
          {
            char v152 = 0;
            unint64_t v153 = 0LL;
            unint64_t v154 = v104;
            do
            {
              unint64_t v155 = v113 + v153;
              unint64_t v156 = v153 + 1;
              if (v153 >= 8) {
                unint64_t v157 = v84;
              }
              else {
                unint64_t v157 = v110;
              }
              unint64_t v158 = v157 >> (v152 & 0x38);
              char v159 = (8 * v113 + v152) & 0x38;
              uint64_t v160 = (-255LL << v159) - 1;
              unint64_t v161 = (unint64_t)v158 << v159;
              unint64_t v162 = v161 | v160 & v154;
              unint64_t v163 = v161 | v160 & v105;
              if (v155 < 8) {
                uint64_t v105 = v163;
              }
              else {
                unint64_t v154 = v162;
              }
              v152 += 8;
              unint64_t v153 = v156;
            }

            while (v112 != v156);
          }

          else
          {
            unint64_t v154 = v104;
          }

          swift_bridgeObjectRelease(v104);
          unint64_t v174 = 0xE000000000000000LL;
          if (v105 & 0x8080808080808080LL | v154 & 0x80808080808080LL) {
            unint64_t v174 = 0xA000000000000000LL;
          }
          uint64_t v258 = v105;
          uint64_t v259 = v174 & 0xFF00000000000000LL | ((v112 + v113) << 56) | v154 & 0xFFFFFFFFFFFFFFLL;
          x1_0 = v251;
          uint64_t v27 = a1;
          goto LABEL_181;
        }

        uint64_t v111 = 1LL;
      }

      if (v111) {
        int64_t v114 = HIBYTE(v107) & 0xF;
      }
      else {
        int64_t v114 = v110 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain(v107, v107, v108, v109);
      uint64_t v253 = v114;
      if ((v84 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v84, 5LL, v115, v116);
        v175._Swift::UInt64 rawBits = 1LL;
        v176._Swift::UInt64 rawBits = (v114 << 16) | 1;
        v177._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v175, v176, v110, v84);
        if (v177._rawBits < 0x10000) {
          v177._rawBits |= 3;
        }
        int64_t v114 = specialized Collection.count.getter(v177, v178, v110, v84);
        swift_bridgeObjectRelease(v84);
        uint64_t v250 = v110 & 0xFFFFFFFFFFFFLL;
        if ((v104 & 0x1000000000000000LL) != 0)
        {
LABEL_188:
          Swift::Int v117 = String.UTF8View._foreignCount()();
          int64_t v118 = v117 + v114;
          if (__OFADD__(v117, v114)) {
            goto LABEL_259;
          }
          goto LABEL_129;
        }
      }

      else
      {
        swift_bridgeObjectRetain_n(v84, 4LL, v115, v116);
        uint64_t v250 = v110 & 0xFFFFFFFFFFFFLL;
        if ((v104 & 0x1000000000000000LL) != 0) {
          goto LABEL_188;
        }
      }

      if ((v104 & 0x2000000000000000LL) != 0) {
        Swift::Int v117 = HIBYTE(v104) & 0xF;
      }
      else {
        Swift::Int v117 = v105 & 0xFFFFFFFFFFFFLL;
      }
      int64_t v118 = v117 + v114;
      if (__OFADD__(v117, v114))
      {
LABEL_259:
        __break(1u);
        goto LABEL_260;
      }

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance String.UTF16View()
{
  return String.UTF16View.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t (*String.utf16.modify(void *a1, uint64_t a2, uint64_t a3, char *a4))()
{
  a1[2] = v4;
  unint64_t v6 = v4[1];
  *a1 = *v4;
  a1[1] = v6;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  return String.utf16.modify;
}

BOOL String.Index._foreignIsWithin(_:)(uint64_t a1, uint64_t a2, __int16 a3)
{
  return specialized String.Index._foreignIsWithin(_:)(a3);
}

uint64_t String.Index.samePosition(in:)(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  return ((uint64_t (*)(uint64_t, uint64_t, unint64_t))a4)(a3, a1, a2);
}

uint64_t String.UTF16View.customMirror.getter@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  a1,  a2,  8,  0LL,  0LL,  a5);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return protocol witness for CustomReflectable.customMirror.getter in conformance String.UnicodeScalarView( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void))specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:),  a4);
}

uint64_t specialized String.UTF16View._utf16Length<A, B>(readPtr:endPtr:unsignedSIMDType:signedSIMDType:)( int8x8_t **a1, unint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = 0LL;
  do
  {
    uint64_t v4 = v2 + 2;
    uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)vaddv_s8( vand_s8( vcgt_s8((int8x8_t)0xC0C0C0C0C0C0C0C0LL, *v2),  (int8x8_t)0x8040201008040201LL)));
    v5.i16[0] = vaddlv_u8(v5);
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)vaddv_s8( vand_s8( (int8x8_t)vcgt_u8( (uint8x8_t)*v2,  (uint8x8_t)0xEFEFEFEFEFEFEFEFLL),  (int8x8_t)0x8040201008040201LL)));
    v6.i16[0] = vaddlv_u8(v6);
    uint64_t v3 = v3 - v5.u32[0] + v6.u32[0] + 8;
    *a1 = ++v2;
  }

  while ((unint64_t)v4 < a2);
  return v3;
}

uint64_t static Int8.+ infix(_:_:)(char a1, char a2)
{
  uint64_t result = (a1 + a2);
  return result;
}

uint64_t static SIMD<>..< infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v62 = a1;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  unint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  unint64_t v13 = (char *)&v53 - v12;
  unint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  unint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  unint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  char v24 = (char *)&v53 - v23;
  uint64_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  unint64_t v65 = (char *)&v53 - v28;
  uint64_t v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a2, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  unint64_t v54 = v13;
  if (v31)
  {
    uint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  uint64_t v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  uint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  uint64_t v35 = swift_checkMetadataState(0LL, v66);
  unint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  uint64_t v66 = (uint64_t)v35;
  char v59 = v37;
  uint64_t v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    unint64_t v39 = 0LL;
    unint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    uint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      unint64_t v42 = v40;
      v40(v39, a3, v15);
      char v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 16))(v21, v41, v16);
      Swift::String::Index v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      unint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        unint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        unint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      uint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      uint64_t v34 = v65;
      unint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t (*v21)(unint64_t *, uint64_t);
  uint64_t result;
  unint64_t v23;
  void (*v24)(unint64_t, uint64_t, uint64_t);
  char *v25;
  char *v26;
  void (*v27)(unint64_t, uint64_t, uint64_t);
  unint64_t v28;
  char v29;
  void (*v30)(char *, unint64_t);
  char *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t AssociatedConformanceWitness;
  void (*v36)(void *, uint64_t, unint64_t, unint64_t);
  char *v37;
  void *v38;
  uint64_t v39;
  char *v40;
  uint64_t (*v41)(unint64_t *, uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  const char *v50;
  unint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v56 = a2;
  unint64_t v57 = a5;
  unint64_t v55 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                  + 48);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v50 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v47 = swift_getAssociatedTypeWitness( 0LL,  v50,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v47);
  unint64_t v46 = (char *)&v41 - v12;
  unint64_t v49 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v49);
  unint64_t v45 = (char *)&v41 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = a3;
  uint64_t v51 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v54 = *(void *)(v51 - 8);
  unint64_t v16 = MEMORY[0x1895F8858](v51);
  uint64_t v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v52 = (char *)&v41 - v18;
  uint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v10 + 48))(v19, v10);
  uint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v10 + 40);
  unint64_t v58 = a6;
  int64_t v21 = v20;
  uint64_t result = v20(v19, v10);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    uint64_t v23 = 0LL;
    char v24 = *(void (**)(unint64_t, uint64_t, uint64_t))(v14 + 56);
    char v43 = v15;
    Swift::String::Index v44 = result;
    unint64_t v48 = v10;
    uint64_t v25 = v53;
    while (1)
    {
      uint64_t v26 = v52;
      v24(v23, v15, v14);
      uint64_t v27 = v24;
      v24(v23, v15, v14);
      uint64_t v28 = v51;
      uint64_t v29 = (*(uint64_t (**)(char *, char *, unint64_t))(v57 + 16))(v26, v25, v51);
      uint64_t v30 = *(void (**)(char *, unint64_t))(v54 + 8);
      v30(v25, v28);
      uint64_t v31 = v26;
      uint64_t v32 = v48;
      v30(v31, v28);
      uint64_t v33 = v21(v19, v32);
      if ((v33 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v23 >= v33) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v41 = v21;
      uint64_t v34 = v47;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v50,  (uint64_t)v49,  v47,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v36 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      unint64_t v42 = v14;
      uint64_t v37 = v46;
      if ((v29 & 1) != 0)
      {
        uint64_t v38 = &unk_18180BE78;
        unint64_t v39 = 257LL;
      }

      else
      {
        uint64_t v38 = &unk_18180BE68;
        unint64_t v39 = 256LL;
      }

      v36(v38, v39, v34, AssociatedConformanceWitness);
      char v24 = v27;
      unint64_t v40 = v45;
      (*((void (**)(char *))v50 + 3))(v37);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v32 + 64))(v40, v23++, v19, v32);
      uint64_t result = v44;
      int64_t v21 = v41;
      uint64_t v14 = v42;
      uint64_t v15 = v43;
      if (v44 == v23) {
        return result;
      }
    }

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v62 = a2;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  unint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  unint64_t v13 = (char *)&v53 - v12;
  unint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  unint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  unint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  char v24 = (char *)&v53 - v23;
  uint64_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  unint64_t v65 = (char *)&v53 - v28;
  uint64_t v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a1, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  unint64_t v54 = v13;
  if (v31)
  {
    uint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  uint64_t v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  uint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  uint64_t v35 = swift_checkMetadataState(0LL, v66);
  unint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  uint64_t v66 = (uint64_t)v35;
  char v59 = v37;
  uint64_t v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    unint64_t v39 = 0LL;
    unint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    uint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      unint64_t v42 = v40;
      v40(v39, a3, v15);
      char v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 16))(v21, v41, v16);
      Swift::String::Index v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      unint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        unint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        unint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      uint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      uint64_t v34 = v65;
      unint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

uint64_t SIMD.replacing(with:where:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v83 = a2;
  uint64_t v73 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  size_t v82 = *(const char **)(AssociatedConformanceWitness + 48);
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  v82,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v11 = swift_getAssociatedConformanceWitness( a4,  a3,  v10,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  uint64_t v76 = *(void *)(v11 + 8);
  unint64_t v69 = *(const char **)(*(void *)(v76 + 24) + 16LL);
  unint64_t v68 = swift_getAssociatedTypeWitness( 0LL,  v69,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v68);
  unint64_t v67 = (char *)&v65 - v12;
  unint64_t v13 = swift_checkMetadataState(0LL, v10);
  uint64_t v74 = *(v13 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v66 = (char *)&v65 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v72 = (char *)&v65 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v80 = (char *)&v65 - v18;
  unint64_t v19 = swift_getAssociatedConformanceWitness( a4,  a3,  (uint64_t)v13,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  unint64_t v78 = AssociatedTypeWitness;
  v84[0] = AssociatedTypeWitness;
  v84[1] = AssociatedConformanceWitness;
  v84[2] = v11;
  v84[3] = v19;
  uint64_t v81 = type metadata accessor for SIMDMask(0LL, (uint64_t)v84);
  uint64_t v79 = *(void *)(v81 - 8);
  MEMORY[0x1895F8858](v81);
  int64_t v21 = (char *)&v65 - v20;
  uint64_t v22 = *(void *)(a4 + 48);
  unint64_t v23 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v22,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1895F8858](v23);
  unint64_t v75 = (char *)&v65 - v24;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, v77, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v22 + 40))(a3, v22);
  if (result < 0) {
LABEL_22:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v26 = result;
  uint64_t v77 = a5;
  uint64_t v27 = v80;
  if (result)
  {
    unint64_t v28 = 0LL;
    uint64_t v29 = *(void (**)(void, void, void))(v79 + 16);
    while (1)
    {
      uint64_t v30 = v29;
      v29(v21, v83, v81);
      unint64_t v31 = v78;
      unint64_t v32 = (*((uint64_t (**)(unint64_t))v82 + 5))(v78);
      if ((v32 & 0x8000000000000000LL) != 0) {
        goto LABEL_22;
      }
      if (v28 >= v32) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
      }
      uint64_t v70 = v26;
      (*(void (**)(char *, uint64_t))(v79 + 8))(v21, v81);
      (*((void (**)(unint64_t, unint64_t))v82 + 7))(v28, v31);
      uint64_t v33 = v76;
      uint64_t v34 = *(uint64_t (**)(unint64_t *, uint64_t))(v76 + 64);
      char v35 = v34(v13, v76);
      uint64_t v71 = v21;
      if ((v35 & 1) != 0) {
        break;
      }
      char v45 = v34(v13, v33);
      uint64_t v46 = (*(uint64_t (**)(unint64_t *, uint64_t))(v33 + 128))(v13, v33);
      if ((v45 & 1) != 0)
      {
        if (v46 <= 64)
        {
          unint64_t v55 = v68;
          unint64_t v56 = v69;
          unint64_t v57 = swift_getAssociatedConformanceWitness( (uint64_t)v69,  (uint64_t)v13,  v68,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          unint64_t v58 = v67;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v57 + 8))( &unk_18180BE68,  256LL,  v55,  v57);
          char v59 = v72;
          (*((void (**)(char *, unint64_t *, const char *))v56 + 3))(v58, v13, v56);
          LOBYTE(v55) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v33 + 32)
                                                                                                  + 8LL)
                                                                                      + 16LL))( v80,  v59,  v13);
          uint64_t v60 = v74;
          unint64_t v61 = *(void (**)(char *, unint64_t *))(v74 + 8);
          v61(v59, v13);
          uint64_t v62 = *(void (**)(char *, char *, unint64_t *))(v60 + 32);
          uint64_t v63 = v66;
          v62(v66, v80, v13);
          if ((v55 & 1) == 0) {
            (*(void (**)(unint64_t *, uint64_t))(v33 + 120))(v13, v33);
          }
          v61(v63, v13);
          uint64_t v27 = v80;
          goto LABEL_19;
        }

        v84[0] = 0LL;
        unint64_t v49 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v33 + 96);
        unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
        uint64_t v51 = v72;
        v49(v84, &type metadata for Int, v50, v13, v33);
        uint64_t v52 = *(void (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v33 + 32) + 8LL) + 16LL);
        uint64_t v53 = v80;
        v52(v80, v51, v13);
        unint64_t v42 = *(void (**)(char *, unint64_t *))(v74 + 8);
        unint64_t v54 = v51;
        uint64_t v27 = v53;
        v42(v54, v13);
        Swift::String::Index v44 = v53;
LABEL_12:
        v42(v44, v13);
        goto LABEL_19;
      }

      if (v46 < 64)
      {
LABEL_15:
        (*(void (**)(unint64_t *, uint64_t))(v33 + 120))(v13, v33);
        (*(void (**)(char *, unint64_t *))(v74 + 8))(v27, v13);
        goto LABEL_19;
      }

      (*(void (**)(char *, unint64_t *))(v74 + 8))(v27, v13);
LABEL_19:
      uint64_t v64 = v75;
      (*(void (**)(unint64_t, uint64_t, uint64_t))(v22 + 56))(v28, a3, v22);
      uint64_t result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v64, v28++, a3, v22);
      int64_t v21 = v71;
      uint64_t v26 = v70;
      uint64_t v29 = v30;
      if (v70 == v28) {
        return result;
      }
    }

    uint64_t v36 = (*(uint64_t (**)(unint64_t *, uint64_t))(v33 + 128))(v13, v33);
    if (v36 < 64) {
      goto LABEL_15;
    }
    v84[0] = 0LL;
    unint64_t v39 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v33 + 96);
    unint64_t v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
    uint64_t v41 = v72;
    v39(v84, &type metadata for Int, v40, v13, v33);
    (*(void (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v33 + 32) + 8LL) + 16LL))( v80,  v41,  v13);
    unint64_t v42 = *(void (**)(char *, unint64_t *))(v74 + 8);
    char v43 = v41;
    uint64_t v27 = v80;
    v42(v43, v13);
    Swift::String::Index v44 = v27;
    goto LABEL_12;
  }

  return result;
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, uint64_t, unint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  unint64_t v48;
  void (*v49)(char *, uint64_t, uint64_t);
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void (*v62)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v63;
  char *v64;
  void (*v65)(char *, char *, uint64_t);
  char *v66;
  void (*v67)(char *, uint64_t);
  char *v68;
  char *v69;
  void (*v70)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  uint64_t v83;
  char *v84;
  void (*v85)(char *, uint64_t);
  void (*v86)(char *, char *, uint64_t);
  char *v87;
  uint64_t v89;
  char *v90;
  char *v91;
  unint64_t v92;
  const char *v93;
  char *v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t (*v99)(uint64_t, uint64_t);
  uint64_t v100;
  void (*v101)(char *, uint64_t, uint64_t);
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  unint64_t v107;
  char *v108;
  char *v109;
  uint64_t v110;
  const char *v111;
  void v112[5];
  uint64_t v102 = a5;
  unint64_t v106 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  uint64_t v111 = *(const char **)(AssociatedConformanceWitness + 48);
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  v111,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v11 = swift_getAssociatedConformanceWitness( a4,  a3,  v10,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  unint64_t v97 = *(void *)(v11 + 8);
  Swift::tuple_Unicode_Scalar_scalarLength_Int v93 = *(const char **)(*(void *)(v97 + 24) + 16LL);
  uint64_t v92 = swift_getAssociatedTypeWitness( 0LL,  v93,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v92);
  Swift::String::Index v91 = (char *)&v89 - v12;
  unint64_t v13 = swift_checkMetadataState(0LL, v10);
  uint64_t v96 = *(v13 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  unsigned int v90 = (char *)&v89 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unsigned int v94 = (char *)&v89 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v105 = (char *)&v89 - v18;
  unsigned __int128 v98 = v19;
  uint64_t v20 = swift_getAssociatedConformanceWitness( a4,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  unint64_t v107 = AssociatedTypeWitness;
  v112[0] = AssociatedTypeWitness;
  v112[1] = AssociatedConformanceWitness;
  v112[2] = v11;
  v112[3] = v20;
  unint64_t v110 = type metadata accessor for SIMDMask(0LL, (uint64_t)v112);
  unint64_t v103 = *(void *)(v110 - 8);
  MEMORY[0x1895F8858](v110);
  uint64_t v109 = (char *)&v89 - v21;
  uint64_t v22 = *(void *)(a4 + 48);
  unint64_t v23 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v22,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v24 = MEMORY[0x1895F8858](v23);
  uint64_t v26 = (char *)&v89 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v29 = (char *)&v89 - v28;
  uint64_t v30 = MEMORY[0x1895F8858](v27);
  unint64_t v32 = (char *)&v89 - v31;
  unint64_t v104 = *(void *)(a3 - 8);
  uint64_t v33 = MEMORY[0x1895F8858](v30);
  char v35 = (char *)&v89 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v33);
  uint64_t v108 = (char *)&v89 - v36;
  unint64_t v100 = v37;
  uint64_t v38 = *(void (**)(char *, uint64_t, unint64_t))(v37 + 16);
  v38(v32, a1, v23);
  (*(void (**)(uint64_t, uint64_t))(v22 + 48))(a3, v22);
  uint64_t v99 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  unint64_t v39 = v99(a3, v22);
  if (v39 < 0) {
    goto LABEL_29;
  }
  unint64_t v40 = v39;
  uint64_t v95 = v26;
  if (v39)
  {
    uint64_t v41 = 0LL;
    do
    {
      v38(v29, (uint64_t)v32, v23);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v29, v41++, a3, v22);
    }

    while (v40 != v41);
  }

  (*(void (**)(char *, unint64_t))(v100 + 8))(v32, v23);
  unint64_t v42 = v104;
  (*(void (**)(char *, char *, uint64_t))(v104 + 32))(v108, v35, a3);
  (*(void (**)(uint64_t, void, uint64_t))(v42 + 16))(v102, v101, a3);
  char v43 = v99(a3, v22);
  if (v43 < 0) {
LABEL_29:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  Swift::String::Index v44 = v43;
  uint64_t v46 = v106;
  char v45 = v107;
  uint64_t v47 = v105;
  if (v43)
  {
    uint64_t v48 = 0LL;
    unint64_t v49 = *(void (**)(char *, uint64_t, uint64_t))(v103 + 16);
    while (1)
    {
      v49(v109, v46, v110);
      unint64_t v50 = (*((uint64_t (**)(unint64_t))v111 + 5))(v45);
      if ((v50 & 0x8000000000000000LL) != 0) {
        goto LABEL_29;
      }
      if (v48 >= v50) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
      }
      unint64_t v101 = v49;
      (*(void (**)(char *, uint64_t))(v103 + 8))(v109, v110);
      (*((void (**)(unint64_t, unint64_t))v111 + 7))(v48, v45);
      uint64_t v51 = v97;
      uint64_t v52 = v98;
      uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v97 + 64);
      if ((v53(v98, v97) & 1) != 0) {
        break;
      }
      unint64_t v57 = v53(v52, v51);
      unint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v51 + 128))(v52, v51);
      if ((v57 & 1) != 0)
      {
        if (v58 <= 64)
        {
          uint64_t v76 = v93;
          uint64_t v77 = v98;
          unint64_t v78 = v92;
          uint64_t v79 = swift_getAssociatedConformanceWitness( (uint64_t)v93,  v98,  v92,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v80 = v91;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v79 + 8))( &unk_18180BE68,  256LL,  v78,  v79);
          uint64_t v81 = v94;
          (*((void (**)(char *, uint64_t, const char *))v76 + 3))(v80, v77, v76);
          size_t v82 = v105;
          LOBYTE(v78) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v97 + 32) + 8LL)
                                                                           + 16LL))( v105,  v81,  v77);
          uint64_t v83 = v96;
          uint64_t v84 = v81;
          uint64_t v47 = v82;
          uint64_t v85 = *(void (**)(char *, uint64_t))(v96 + 8);
          v85(v84, v77);
          uint64_t v86 = *(void (**)(char *, char *, uint64_t))(v83 + 32);
          uint64_t v87 = v90;
          v86(v90, v47, v77);
          if ((v78 & 1) != 0)
          {
            v85(v87, v77);
            uint64_t v74 = v95;
            uint64_t v46 = v106;
            goto LABEL_24;
          }

          (*(void (**)(uint64_t))(v97 + 120))(v77);
          v85(v87, v77);
          goto LABEL_21;
        }

        v112[0] = 0LL;
        unint64_t v61 = v97;
        uint64_t v62 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v97 + 96);
        uint64_t v63 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
        uint64_t v64 = v94;
        uint64_t v52 = v98;
        v62(v112, &type metadata for Int, v63, v98, v61);
        uint64_t v65 = *(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v61 + 32) + 8LL) + 16LL);
        uint64_t v66 = v105;
        v65(v105, v64, v52);
        unint64_t v67 = *(void (**)(char *, uint64_t))(v96 + 8);
        unint64_t v68 = v64;
        uint64_t v47 = v66;
        v67(v68, v52);
        unint64_t v69 = v66;
LABEL_17:
        v67(v69, v52);
        uint64_t v74 = v95;
        uint64_t v46 = v106;
        goto LABEL_24;
      }

      if (v58 < 64)
      {
        unint64_t v75 = v98;
        (*(void (**)(uint64_t))(v97 + 120))(v98);
        (*(void (**)(char *, uint64_t))(v96 + 8))(v47, v75);
        goto LABEL_21;
      }

      (*(void (**)(char *, uint64_t))(v96 + 8))(v47, v98);
      uint64_t v74 = v95;
      uint64_t v46 = v106;
LABEL_24:
      (*(void (**)(unint64_t, uint64_t, uint64_t))(v22 + 56))(v48, a3, v22);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v74, v48++, a3, v22);
      char v45 = v107;
      unint64_t v49 = v101;
      if (v44 == v48) {
        return (*(uint64_t (**)(char *, uint64_t))(v104 + 8))(v108, a3);
      }
    }

    unint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(v51 + 128))(v52, v51);
    if (v54 < 64)
    {
      (*(void (**)(uint64_t, uint64_t))(v51 + 120))(v52, v51);
      (*(void (**)(char *, uint64_t))(v96 + 8))(v47, v52);
LABEL_21:
      uint64_t v74 = v95;
      uint64_t v46 = v106;
      goto LABEL_24;
    }

    v112[0] = 0LL;
    uint64_t v70 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v51 + 96);
    uint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    unint64_t v72 = v94;
    v70(v112, &type metadata for Int, v71, v52, v51);
    (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v51 + 32) + 8LL) + 16LL))(v105, v72, v52);
    unint64_t v67 = *(void (**)(char *, uint64_t))(v96 + 8);
    uint64_t v73 = v72;
    uint64_t v47 = v105;
    v67(v73, v52);
    unint64_t v69 = v47;
    goto LABEL_17;
  }

  return (*(uint64_t (**)(char *, uint64_t))(v104 + 8))(v108, a3);
}

uint64_t static SIMD<>..>= infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v62 = a1;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  unint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  unint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  unint64_t v13 = (char *)&v53 - v12;
  unint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  unint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  unint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v53 - v23;
  uint64_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v65 = (char *)&v53 - v28;
  uint64_t v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a2, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  unint64_t v54 = v13;
  if (v31)
  {
    uint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  uint64_t v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  uint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  char v35 = swift_checkMetadataState(0LL, v66);
  uint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  uint64_t v66 = (uint64_t)v35;
  char v59 = v37;
  uint64_t v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    unint64_t v39 = 0LL;
    unint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    uint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      unint64_t v42 = v40;
      v40(v39, a3, v15);
      char v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 24))(v21, v41, v16);
      Swift::String::Index v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      unint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        unint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        unint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      uint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      uint64_t v34 = v65;
      unint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t (*v21)(unint64_t *, uint64_t);
  uint64_t result;
  unint64_t v23;
  void (*v24)(unint64_t, uint64_t, uint64_t);
  char *v25;
  char *v26;
  void (*v27)(unint64_t, uint64_t, uint64_t);
  unint64_t v28;
  char v29;
  void (*v30)(char *, unint64_t);
  char *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t AssociatedConformanceWitness;
  void (*v36)(void *, uint64_t, unint64_t, unint64_t);
  char *v37;
  void *v38;
  uint64_t v39;
  char *v40;
  uint64_t (*v41)(unint64_t *, uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  const char *v50;
  unint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v56 = a2;
  unint64_t v57 = a5;
  unint64_t v55 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  unint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                  + 48);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v50 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  uint64_t v47 = swift_getAssociatedTypeWitness( 0LL,  v50,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v47);
  unint64_t v46 = (char *)&v41 - v12;
  unint64_t v49 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v49);
  unint64_t v45 = (char *)&v41 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = a3;
  uint64_t v51 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v54 = *(void *)(v51 - 8);
  unint64_t v16 = MEMORY[0x1895F8858](v51);
  uint64_t v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v52 = (char *)&v41 - v18;
  uint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v10 + 48))(v19, v10);
  uint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v10 + 40);
  unint64_t v58 = a6;
  int64_t v21 = v20;
  uint64_t result = v20(v19, v10);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    uint64_t v23 = 0LL;
    uint64_t v24 = *(void (**)(unint64_t, uint64_t, uint64_t))(v14 + 56);
    char v43 = v15;
    Swift::String::Index v44 = result;
    uint64_t v48 = v10;
    uint64_t v25 = v53;
    while (1)
    {
      uint64_t v26 = v52;
      v24(v23, v15, v14);
      uint64_t v27 = v24;
      v24(v23, v15, v14);
      uint64_t v28 = v51;
      uint64_t v29 = (*(uint64_t (**)(char *, char *, unint64_t))(v57 + 24))(v26, v25, v51);
      uint64_t v30 = *(void (**)(char *, unint64_t))(v54 + 8);
      v30(v25, v28);
      uint64_t v31 = v26;
      uint64_t v32 = v48;
      v30(v31, v28);
      uint64_t v33 = v21(v19, v32);
      if ((v33 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v23 >= v33) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v41 = v21;
      uint64_t v34 = v47;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v50,  (uint64_t)v49,  v47,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v36 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      unint64_t v42 = v14;
      uint64_t v37 = v46;
      if ((v29 & 1) != 0)
      {
        uint64_t v38 = &unk_18180BE78;
        unint64_t v39 = 257LL;
      }

      else
      {
        uint64_t v38 = &unk_18180BE68;
        unint64_t v39 = 256LL;
      }

      v36(v38, v39, v34, AssociatedConformanceWitness);
      uint64_t v24 = v27;
      unint64_t v40 = v45;
      (*((void (**)(char *))v50 + 3))(v37);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v32 + 64))(v40, v23++, v19, v32);
      uint64_t result = v44;
      int64_t v21 = v41;
      uint64_t v14 = v42;
      uint64_t v15 = v43;
      if (v44 == v23) {
        return result;
      }
    }

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v62 = a2;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  unint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  unint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  unint64_t v13 = (char *)&v53 - v12;
  unint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  unint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  unint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v53 - v23;
  uint64_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v65 = (char *)&v53 - v28;
  uint64_t v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a1, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  unint64_t v54 = v13;
  if (v31)
  {
    uint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  uint64_t v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  uint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  char v35 = swift_checkMetadataState(0LL, v66);
  uint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  uint64_t v66 = (uint64_t)v35;
  char v59 = v37;
  uint64_t v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    unint64_t v39 = 0LL;
    unint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    uint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      unint64_t v42 = v40;
      v40(v39, a3, v15);
      char v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 24))(v21, v41, v16);
      Swift::String::Index v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      unint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        unint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        unint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      uint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      uint64_t v34 = v65;
      unint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

uint64_t static SIMD<>.&- infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v34 = a2;
  uint64_t v27 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  unint64_t v16 = (char *)&v27 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = a6;
  uint64_t v32 = a5;
  uint64_t v30 = v18;
  if (result)
  {
    unint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = 0LL;
    uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v29 = result;
    do
    {
      uint64_t v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      uint64_t v23 = v9;
      uint64_t v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 88))(v30, v13, v20);
      uint64_t v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      uint64_t v26 = v24;
      uint64_t v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      uint64_t result = v29;
      ++v21;
    }

    while (v29 != v21);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, uint64_t);
  char *v46;
  char *v48;
  char *v49;
  char *v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  unint64_t v56 = a2;
  unint64_t v57 = a5;
  unint64_t v58 = a6;
  Swift::String v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v50 = (char *)&v48 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  char v59 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v18 = MEMORY[0x1895F8858]((char *)&v48 - v17);
  unint64_t v20 = (char *)&v48 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v48 - v22;
  unint64_t v55 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t))*((void *)v24 + 2);
  uint64_t v26 = v21;
  uint64_t v28 = v27;
  v25(v21, a1);
  uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v53(a3, v8);
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  unint64_t v54 = v20;
  uint64_t v30 = a3;
  uint64_t v51 = v29;
  uint64_t v31 = v29(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  uint64_t v48 = v12;
  unint64_t v49 = v23;
  uint64_t v33 = v59;
  uint64_t v34 = v54;
  if (v31)
  {
    char v35 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }

    while (v32 != v35);
  }

  uint64_t v36 = (void (*)(uint64_t, uint64_t))*((void *)v55 + 1);
  v36(v26, v28);
  uint64_t v37 = v49;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v49, v34, v30);
  v53(v30, v8);
  uint64_t v38 = v51(v30, v8);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  unint64_t v55 = v36;
  unint64_t v39 = v48;
  unint64_t v40 = v50;
  if (v38)
  {
    uint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v38;
    do
    {
      unint64_t v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v41, v30, v8);
      v42(v41, v30, v8);
      char v43 = v8;
      Swift::String::Index v44 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 88))(v59, v39, v28);
      unint64_t v45 = (void (*)(char *, uint64_t))v55;
      v55((uint64_t)v39, v28);
      v45(v40, v28);
      unint64_t v46 = v44;
      Swift::String v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v30, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v30);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  void (*v43)(char *, uint64_t, uint64_t);
  uint64_t v44;
  char *v45;
  void (*v46)(char *, uint64_t);
  char *v47;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  uint64_t v53;
  void (*v54)(uint64_t, uint64_t);
  char *v55;
  void (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  unint64_t v57 = a5;
  unint64_t v58 = a6;
  uint64_t v50 = a1;
  Swift::String v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v49 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v51 = (char *)&v49 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  char v59 = (char *)&v49 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v53 = *(void *)(a3 - 8);
  uint64_t v18 = MEMORY[0x1895F8858]((char *)&v49 - v17);
  unint64_t v20 = (char *)&v49 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v49 - v22;
  unint64_t v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t))*((void *)v24 + 2);
  uint64_t v26 = v21;
  uint64_t v28 = v27;
  v25(v21, a2);
  unint64_t v54 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v54(a3, v8);
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  unint64_t v55 = v20;
  uint64_t v30 = a3;
  uint64_t v52 = v29;
  uint64_t v31 = v29(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  uint64_t v60 = v23;
  unint64_t v49 = v12;
  uint64_t v33 = v59;
  uint64_t v34 = v55;
  if (v31)
  {
    char v35 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }

    while (v32 != v35);
  }

  uint64_t v36 = (void (*)(uint64_t, uint64_t))*((void *)v56 + 1);
  v36(v26, v28);
  (*(void (**)(char *, char *, uint64_t))(v53 + 32))(v60, v34, v30);
  v54(v30, v8);
  uint64_t v37 = v52(v30, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  unint64_t v56 = v36;
  unint64_t v39 = v49;
  uint64_t v38 = v50;
  unint64_t v40 = v51;
  if (v37)
  {
    uint64_t v41 = 0LL;
    unint64_t v54 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    unint64_t v55 = (char *)v37;
    do
    {
      unint64_t v42 = v38;
      char v43 = (void (*)(char *, uint64_t, uint64_t))v54;
      ((void (*)(char *, uint64_t, uint64_t))v54)(v41, v30, v8);
      v43(v41, v30, v8);
      Swift::String::Index v44 = v8;
      unint64_t v45 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 88))(v59, v39, v28);
      unint64_t v46 = (void (*)(char *, uint64_t))v56;
      v56((uint64_t)v39, v28);
      v46(v40, v28);
      uint64_t v47 = v45;
      Swift::String v8 = v44;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v44 + 64))(v47, v41, v30, v44);
      uint64_t v38 = v42;
      ++v41;
    }

    while (v55 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v60, v30);
}

Swift::Int __swiftcall _utf8ScalarLength(_:)(Swift::UInt8 a1)
{
  unsigned int v1 = __clz(~a1) - 24;
  if ((a1 & 0x80u) == 0) {
    return 1;
  }
  else {
    return v1;
  }
}

uint64_t (*String.UTF8View._guts.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t String.endIndex.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1;
  }
  uint64_t v3 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v3 = 11LL;
  }
  return v3 | (v2 << 16);
}

Swift::String::Index __swiftcall String.UTF8View.index(after:)(Swift::String::Index after)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((after._rawBits & 0xC) == 4LL << v5)
  {
    after._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(after)._rawBits;
    if ((v3 & 0x1000000000000000LL) == 0) {
      return (Swift::String::Index)((after._rawBits & 0xFFFFFFFFFFFF0000LL) + 65540);
    }
  }

  else if ((v2 & 0x1000000000000000LL) == 0)
  {
    return (Swift::String::Index)((after._rawBits & 0xFFFFFFFFFFFF0000LL) + 65540);
  }

  Swift::UInt64 v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v7 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 <= after._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
  }
  return String.UTF8View._foreignIndex(after:)(after);
}

Swift::String::Index __swiftcall String.UTF8View._foreignIndex(after:)(Swift::String::Index after)
{
  Swift::UInt64 rawBits = after._rawBits;
  if ((after._rawBits & 0xC001) == 0) {
    Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(after)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  }
  unint64_t v2 = rawBits & 0xFFFFFFFFFFFF0000LL;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v3 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL));
  unint64_t v4 = (unsigned __int16)rawBits >> 14;
  unint64_t v5 = 2LL;
  if (v3._0._value >= 0x10000) {
    unint64_t v5 = 3LL;
  }
  if (v3._0._value < 0x800) {
    unint64_t v5 = 1LL;
  }
  BOOL v6 = v4 >= v5;
  v7._Swift::UInt64 rawBits = v2 | ((v4 << 14) + 0x4000) | 8;
  if (v6) {
    v7._Swift::UInt64 rawBits = (rawBits + (v3.scalarLength << 16)) & 0xFFFFFFFFFFFF0000LL | 9;
  }
  if (v3._0._value >= 0x80) {
    return v7;
  }
  else {
    return (Swift::String::Index)(v2 + 65545);
  }
}

Swift::String::Index __swiftcall String.UTF8View.index(before:)(Swift::String::Index before)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((before._rawBits & 0xC) != 4LL << v5)
  {
    if (before._rawBits >> 14) {
      goto LABEL_5;
    }
LABEL_8:
    unint64_t v7 = 152LL;
    goto LABEL_9;
  }

  before._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(before)._rawBits;
  if (!(before._rawBits >> 14)) {
    goto LABEL_8;
  }
LABEL_5:
  if ((v3 & 0x1000000000000000LL) == 0) {
    return (Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000LL) - 65532);
  }
  Swift::UInt64 v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 < before._rawBits >> 16)
  {
    unint64_t v7 = 157LL;
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v7,  0);
  }

  return String.UTF8View._foreignIndex(before:)(before);
}

Swift::String::Index __swiftcall String.UTF8View._foreignIndex(before:)(Swift::String::Index before)
{
  Swift::UInt64 rawBits = before._rawBits;
  if ((before._rawBits & 0xC001) == 0) {
    Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(before)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  }
  unint64_t v2 = rawBits & 0xFFFFFFFFFFFF0000LL;
  if ((unsigned __int16)rawBits >> 14)
  {
    unint64_t v3 = (((unint64_t)((unsigned __int16)rawBits >> 14) << 14) - 0x4000) | v2;
  }

  else
  {
    Swift::tuple_Unicode_Scalar_scalarLength_Int v4 = _StringGuts.foreignErrorCorrectedScalar(endingAt:)((Swift::String::Index)v2);
    uint64_t v5 = 0x4000LL;
    uint64_t v6 = 49152LL;
    if (v4._0._value < 0x10000) {
      uint64_t v6 = 0x8000LL;
    }
    if (v4._0._value >= 0x800) {
      uint64_t v5 = v6;
    }
    if (v4._0._value <= 0x7F) {
      uint64_t v5 = 0LL;
    }
    unint64_t v3 = v5 | (rawBits - (v4.scalarLength << 16)) & 0xFFFFFFFFFFFF0000LL;
  }

  return (Swift::String::Index)(v3 | 8);
}

Swift::String::Index_optional __swiftcall String.UTF8View.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  unint64_t v6 = v3;
  uint64_t v9 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((_._rawBits & 0xC) != 4LL << v9)
  {
    if ((v4 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
LABEL_19:
    Swift::String::Index_optional v13 = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy);
    v13.is_nil &= 1u;
    return v13;
  }

  _._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_19;
  }
LABEL_5:
  Swift::UInt64 v10 = _._rawBits >> 16;
  int64_t v11 = (_._rawBits >> 16) + offsetBy;
  if (__OFADD__(_._rawBits >> 16, offsetBy))
  {
    __break(1u);
    goto LABEL_21;
  }

  Swift::UInt64 v12 = limitedBy._rawBits >> 16;
  if (offsetBy < 0)
  {
  }

  else if (v12 < v10 || (uint64_t)v12 >= v11)
  {
LABEL_13:
    if ((v11 & 0x8000000000000000LL) == 0)
    {
      unint64_t v14 = HIBYTE(v5) & 0xF;
      if ((v5 & 0x2000000000000000LL) == 0) {
        unint64_t v14 = v6 & 0xFFFFFFFFFFFFLL;
      }
      if (v14 >= v11)
      {
        v13.Swift::Bool is_nil = 0;
        v13.value._Swift::UInt64 rawBits = (v11 << 16) | 4;
        return v13;
      }
    }

Swift::String::Index_optional __swiftcall String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  Swift::UInt64 v5 = specialized BidirectionalCollection._index(_:offsetBy:limitedBy:)( _._rawBits,  offsetBy,  limitedBy._rawBits,  v3,  v4);
  Swift::Bool v7 = v6 & 1;
  result.value._Swift::UInt64 rawBits = v5;
  result.Swift::Bool is_nil = v7;
  return result;
}

Swift::Int __swiftcall String.UTF8View._foreignDistance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  v7._Swift::UInt64 rawBits = from._rawBits;
  if ((from._rawBits & 0xC001) == 0) {
    goto LABEL_18;
  }
  while (1)
  {
    if ((to._rawBits & 0xC001) == 0) {
      to._Swift::UInt64 rawBits = to._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(to)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    }
    if (to._rawBits >> 16 < v7._rawBits >> 16) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    if (to._rawBits >> 16 == v7._rawBits >> 16)
    {
      uint64_t v8 = 0LL;
    }

    else
    {
      uint64_t v15 = 0LL;
      uint64_t v16 = 0LL;
      uint64_t v14 = 0LL;
      if (!objc_msgSend( (id)(v4 & 0xFFFFFFFFFFFFFFFLL),  sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_,  0,  0,  &v14,  4,  0,  v7._rawBits >> 16,  (to._rawBits >> 16) - (v7._rawBits >> 16),  &v15)
        || v16)
      {
        return specialized BidirectionalCollection._distance(from:to:)(v7._rawBits, to._rawBits, v5, v4);
      }

      uint64_t v8 = v14;
    }

    uint64_t v9 = LOWORD(v7._rawBits) >> 14;
    BOOL v10 = __OFSUB__(v8, v9);
    uint64_t v11 = v8 - v9;
    if (!v10) {
      break;
    }
    __break(1u);
LABEL_18:
    v7._Swift::UInt64 rawBits = v7._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v7)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
  }

  uint64_t v12 = LOWORD(to._rawBits) >> 14;
  Swift::Int result = v11 + v12;
  if (!__OFADD__(v11, v12)) {
    return result;
  }
  __break(1u);
  return specialized BidirectionalCollection._distance(from:to:)(v7._rawBits, to._rawBits, v5, v4);
}

uint64_t String.UTF8View.subscript.getter(Swift::UInt64 rawBits, unint64_t a2, unint64_t a3)
{
  uint64_t v5 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v5) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v6 = rawBits >> 16;
  unint64_t v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 >= v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xE4uLL,  0);
  }
  if ((a3 & 0x1000000000000000LL) != 0) {
    return String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }
  if ((a3 & 0x2000000000000000LL) != 0)
  {
    v10[0] = a2;
    v10[1] = a3 & 0xFFFFFFFFFFFFFFLL;
    return *((unsigned __int8 *)v10 + v6);
  }

  else
  {
    if ((a2 & 0x1000000000000000LL) != 0) {
      uint64_t v8 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
    }
    return v8[v6];
  }

Swift::UInt8 __swiftcall String.UTF8View._foreignSubscript(position:)(Swift::String::Index position)
{
  Swift::UInt64 rawBits = position._rawBits;
  if ((position._rawBits & 0xC001) == 0) {
    Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(position)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  }
  Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
  if (value >= 0x80)
  {
    int v6 = (value & 0x3F) << 8;
    if (value > 0x7FF)
    {
      int v7 = (v6 | (value >> 6) & 0x3F) << 8;
      int v8 = (((v7 | (value >> 12) & 0x3F) << 8) | (value >> 18)) - 2122219023;
      unsigned int v3 = (v7 | (value >> 12)) + 8487393;
      if (HIWORD(value)) {
        unsigned int v3 = v8;
      }
    }

    else
    {
      unsigned int v3 = (v6 | (value >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v3 = value + 1;
  }

  unint64_t v4 = (unsigned __int16)rawBits >> 14;
  if (v4 > 4 - (__clz(v3) >> 3)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x8FuLL,  0);
  }
  return (v3 >> (4 * v4) >> (4 * v4)) - 1;
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(before:) in conformance String.UTF8View@<X0>( Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  uint64_t v7 = ((unint64_t)*v2 >> 59) & 1;
  if ((v5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) != 4LL << v7)
  {
    if (rawBits >> 14) {
      goto LABEL_5;
    }
LABEL_9:
    unint64_t v9 = 152LL;
    goto LABEL_10;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if (!(rawBits >> 14)) {
    goto LABEL_9;
  }
LABEL_5:
  if ((v5 & 0x1000000000000000LL) != 0)
  {
    unint64_t v10 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000LL) == 0) {
      unint64_t v10 = v6 & 0xFFFFFFFFFFFFLL;
    }
    if (v10 >= rawBits >> 16)
    {
      Swift::UInt64 result = String.UTF8View._foreignIndex(before:)((Swift::String::Index)rawBits)._rawBits;
      goto LABEL_7;
    }

    unint64_t v9 = 157LL;
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v9,  0);
  }

  Swift::UInt64 result = (rawBits & 0xFFFFFFFFFFFF0000LL) - 65532;
LABEL_7:
  *a2 = result;
  return result;
}

Swift::UInt64 protocol witness for BidirectionalCollection.formIndex(before:) in conformance String.UTF8View( Swift::UInt64 *a1)
{
  uint64_t v4 = *v1;
  unint64_t v3 = v1[1];
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = ((unint64_t)*v1 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) != 4LL << v6)
  {
    if (rawBits >> 14) {
      goto LABEL_5;
    }
LABEL_9:
    unint64_t v8 = 152LL;
    goto LABEL_10;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if (!(rawBits >> 14)) {
    goto LABEL_9;
  }
LABEL_5:
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    unint64_t v9 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000LL) == 0) {
      unint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (v9 >= rawBits >> 16)
    {
      Swift::UInt64 result = String.UTF8View._foreignIndex(before:)((Swift::String::Index)rawBits)._rawBits;
      goto LABEL_7;
    }

    unint64_t v8 = 157LL;
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v8,  0);
  }

  Swift::UInt64 result = (rawBits & 0xFFFFFFFFFFFF0000LL) - 65532;
LABEL_7:
  *a1 = result;
  return result;
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance String.UTF8View@<X0>( Swift::Int offsetBy@<X1>, Swift::UInt64 *a2@<X0>, Swift::UInt64 *a3@<X2>, uint64_t a4@<X8>)
{
  Swift::UInt64 rawBits = *a2;
  v8._Swift::UInt64 rawBits = *a3;
  uint64_t v10 = *v4;
  unint64_t v9 = v4[1];
  uint64_t v11 = ((unint64_t)*v4 >> 59) & 1;
  if ((v9 & 0x1000000000000000LL) == 0) {
    LOBYTE(v11) = 1;
  }
  if ((rawBits & 0xC) != 4LL << v11)
  {
    if ((v9 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
LABEL_20:
    Swift::String::Index_optional v15 = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)((Swift::String::Index)rawBits, offsetBy, v8);
    Swift::Bool is_nil = v15.is_nil;
    goto LABEL_18;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if ((v9 & 0x1000000000000000LL) != 0) {
    goto LABEL_20;
  }
LABEL_5:
  Swift::UInt64 v12 = rawBits >> 16;
  int64_t v13 = (rawBits >> 16) + offsetBy;
  if (__OFADD__(rawBits >> 16, offsetBy))
  {
    __break(1u);
    goto LABEL_22;
  }

  Swift::UInt64 v14 = v8._rawBits >> 16;
  if (offsetBy < 0)
  {
  }

  else if (v14 < v12 || (uint64_t)v14 >= v13)
  {
LABEL_13:
    if ((v13 & 0x8000000000000000LL) == 0)
    {
      unint64_t v17 = HIBYTE(v9) & 0xF;
      if ((v9 & 0x2000000000000000LL) == 0) {
        unint64_t v17 = v10 & 0xFFFFFFFFFFFFLL;
      }
      if (v17 >= v13)
      {
        Swift::Bool is_nil = 0;
        v15.value._Swift::UInt64 rawBits = (v13 << 16) | 4;
        goto LABEL_18;
      }
    }

void protocol witness for Collection.endIndex.getter in conformance String(uint64_t *a1@<X8>)
{
  unint64_t v2 = v1[1];
  uint64_t v3 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v3 = *v1;
  }
  uint64_t v4 = 7LL;
  if (((v2 >> 60) & ((*v1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v4 = 11LL;
  }
  *a1 = v4 | (v3 << 16);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance String.UTF8View( Swift::UInt8 *a1, Swift::UInt64 *a2))()
{
  Swift::UInt64 rawBits = *a2;
  unint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  uint64_t v7 = (v6 >> 59) & 1;
  if ((v5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((*a2 & 0xC) == 4LL << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v8 = rawBits >> 16;
  unint64_t v9 = HIBYTE(v5) & 0xF;
  if ((v5 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 >= v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xE4uLL,  0);
  }
  if ((v5 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt8 v10 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }

  else if ((v5 & 0x2000000000000000LL) != 0)
  {
    v12[0] = v6;
    v12[1] = v5 & 0xFFFFFFFFFFFFFFLL;
    Swift::UInt8 v10 = *((_BYTE *)v12 + v8);
  }

  else if ((v6 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt8 v10 = *(_BYTE *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 0x20 + (rawBits >> 16));
  }

  else
  {
    Swift::UInt8 v10 = *((_BYTE *)_StringObject.sharedUTF8.getter(v6, v5) + v8);
  }

  *a1 = v10;
  return EnumeratedSequence._base.modify;
}

Swift::Int protocol witness for Collection.count.getter in conformance String.UTF8View()
{
  unint64_t v1 = v0[1];
  if ((v1 & 0x1000000000000000LL) != 0) {
    return String.UTF8View._foreignCount()();
  }
  if ((v1 & 0x2000000000000000LL) != 0) {
    return HIBYTE(v1) & 0xF;
  }
  return *v0 & 0xFFFFFFFFFFFFLL;
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance String.UTF8View@<X0>( Swift::Int offsetBy@<X1>, Swift::UInt64 *a2@<X0>, Swift::UInt64 *a3@<X8>)
{
  Swift::UInt64 rawBits = *a2;
  uint64_t v8 = *v3;
  unint64_t v7 = v3[1];
  uint64_t v9 = ((unint64_t)*v3 >> 59) & 1;
  if ((v7 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((rawBits & 0xC) != 4LL << v9)
  {
    if ((v7 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
LABEL_13:
    Swift::UInt64 result = String.UTF8View._foreignIndex(_:offsetBy:)((Swift::String::Index)rawBits, offsetBy)._rawBits;
    goto LABEL_11;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if ((v7 & 0x1000000000000000LL) != 0) {
    goto LABEL_13;
  }
LABEL_5:
  unint64_t v10 = offsetBy + (rawBits >> 16);
  if (__OFADD__(offsetBy, rawBits >> 16))
  {
    __break(1u);
    goto LABEL_15;
  }

  if ((v10 & 0x8000000000000000LL) != 0) {
    goto LABEL_15;
  }
  unint64_t v11 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) == 0) {
    unint64_t v11 = v8 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < v10) {
LABEL_15:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xA7uLL,  0);
  Swift::UInt64 result = (v10 << 16) | 4;
LABEL_11:
  *a3 = result;
  return result;
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance String.UTF8View( Swift::String::Index *a1, Swift::UInt64 *a2)
{
  Swift::UInt64 rawBits = a1->_rawBits;
  Swift::UInt64 v4 = *a2;
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = (v5 >> 59) & 1;
  if ((v6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = 4LL << v7;
  if ((a1->_rawBits & 0xC) == 4LL << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  }
  if ((v4 & 0xC) == v8)
  {
    Swift::UInt64 v4 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v4)._rawBits;
    if ((v6 & 0x1000000000000000LL) == 0) {
      return (v4 >> 16) - (rawBits >> 16);
    }
  }

  else if ((v6 & 0x1000000000000000LL) == 0)
  {
    return (v4 >> 16) - (rawBits >> 16);
  }

  unint64_t v10 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    unint64_t v10 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v10 < rawBits >> 16 || v10 < v4 >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }
  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, (Swift::String::Index)v4);
}

Swift::UInt64 protocol witness for Collection.index(after:) in conformance String.UTF8View@<X0>( Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  uint64_t v7 = ((unint64_t)*v2 >> 59) & 1;
  if ((v5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v7)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if ((v5 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
  }

  else if ((v5 & 0x1000000000000000LL) == 0)
  {
LABEL_5:
    Swift::UInt64 result = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
    goto LABEL_6;
  }

  unint64_t v9 = HIBYTE(v5) & 0xF;
  if ((v5 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (v9 <= rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
  }
  Swift::UInt64 result = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_6:
  *a2 = result;
  return result;
}

Swift::UInt64 protocol witness for Collection.formIndex(after:) in conformance String.UTF8View( Swift::UInt64 *a1)
{
  uint64_t v4 = *v1;
  unint64_t v3 = v1[1];
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = ((unint64_t)*v1 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v6)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if ((v3 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
  }

  else if ((v3 & 0x1000000000000000LL) == 0)
  {
LABEL_5:
    Swift::UInt64 result = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
    goto LABEL_6;
  }

  unint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 <= rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
  }
  Swift::UInt64 result = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_6:
  *a1 = result;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance String.UTF8View(void *a1@<X8>)
{
  uint64_t v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
  a1[2] = 15LL;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance String.UTF8View( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance String( a1,  a2,  (uint64_t (*)(void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance String( uint64_t a1, uint64_t a2, uint64_t (*a3)(void, uint64_t))
{
  uint64_t v4 = v3[1];
  uint64_t v5 = a3(*v3, v4);
  swift_bridgeObjectRelease(v4);
  return v5;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance String.UTF8View( void *a1, char *__dst, uint64_t a3)
{
  if (!__dst) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to copy string contents into nil buffer pointer",  55LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x1AAuLL,  0);
  }
  unint64_t v5 = v3[1];
  uint64_t v6 = _StringGuts.copyUTF8(into:)(__dst, a3, *v3, v5);
  if ((v7 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy string contents",  52LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x1AEuLL,  0);
  }
  uint64_t v8 = v6;
  swift_bridgeObjectRelease(v5);
  *a1 = 0LL;
  a1[1] = 0xE000000000000000LL;
  a1[2] = 15LL;
  return v8;
}

uint64_t String.UTF8View._copyContents(initializing:)( char *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to copy string contents into nil buffer pointer",  55LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x1AAuLL,  0);
  }
  _StringGuts.copyUTF8(into:)(a1, a2, a3, a4);
  if ((v4 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy string contents",  52LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x1AEuLL,  0);
  }
  return 0LL;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance String.UTF8View@<X0>( uint64_t (*a1)(void *, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return String.UTF8View.withContiguousStorageIfAvailable<A>(_:)(a1, *(void *)v3, *(void *)(v3 + 8), a2, a3);
}

unint64_t specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:)( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = 0LL;
    char v163 = 0;
    goto LABEL_262;
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      char v7 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0)
      {
LABEL_5:
        int v9 = *v7;
        if (v9 != 43)
        {
          if (v9 != 45)
          {
            unint64_t v96 = 0LL;
            uint64_t v97 = 0LL;
            unsigned __int8 v98 = a3 + 48;
            unsigned __int8 v99 = a3 + 55;
            unsigned __int8 v100 = a3 + 87;
            if (a3 > 10)
            {
              unsigned __int8 v98 = 58;
            }

            else
            {
              unsigned __int8 v100 = 97;
              unsigned __int8 v99 = 65;
            }

            unint64_t v101 = abs64(a3);
            unint64_t v102 = -(v4 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
            while (1)
            {
              unsigned int v103 = *v7;
              if (v103 < 0x30 || v103 >= v98)
              {
                if (v103 < 0x41 || v103 >= v99)
                {
                  unint64_t result = 0LL;
                  char v10 = 1;
                  if (v103 < 0x61 || v103 >= v100) {
                    goto LABEL_261;
                  }
                  char v104 = -87;
                }

                else
                {
                  char v104 = -55;
                }
              }

              else
              {
                char v104 = -48;
              }

              BOOL v106 = !((__PAIR128__(v97 ^ (unint64_t)(v97 >> 63), v96 ^ (v97 >> 63))
                      - __PAIR128__(v97 >> 63, v97 >> 63)) >> 64)
                  || v102 == 0;
              BOOL v107 = v106 && (*((unint64_t *)&v105 + 1) * (unsigned __int128)v101) >> 64 == 0;
              BOOL v108 = v107 && (v102 * (unsigned __int128)(unint64_t)v105) >> 64 == 0;
              BOOL v109 = !v108;
              unint64_t v110 = (__PAIR128__(v102, v101) * v105) >> 64;
              char v111 = __CFADD__( ((unint64_t)v105 * (unsigned __int128)v101) >> 64,  v102 * v105 + *((void *)&v105 + 1) * v101)
                  || v109;
              unint64_t v112 = v105 * v101;
              if ((v97 ^ (a3 >> 63)) < 0)
              {
                if ((v111 & 1) != 0) {
                  goto LABEL_260;
                }
                BOOL v39 = v112 == 0;
                unint64_t v112 = -(uint64_t)v112;
                unint64_t v110 = -(uint64_t)(v110 + !v39);
                LOBYTE(v113) = v112 != 0;
              }

              else
              {
                if ((v111 & 1) != 0) {
                  goto LABEL_260;
                }
                unint64_t v113 = v110 >> 63;
              }

              unint64_t result = 0LL;
              BOOL v39 = __CFADD__(v112, (v103 + v104));
              uint64_t v97 = (__PAIR128__(v110, v112) + (v103 + v104)) >> 64;
              unint64_t v96 = v112 + (v103 + v104);
              BOOL v114 = __OFADD__(v39, v110);
              char v10 = 1;
              if ((v113 & 1) != 0 || v114) {
                goto LABEL_261;
              }
              ++v7;
              if (!--v8) {
                goto LABEL_258;
              }
            }
          }

          char v10 = 1;
          uint64_t v11 = specialized Collection.subscript.getter(1LL, (uint64_t)v7, v8);
          uint64_t v15 = specialized UnsafeBufferPointer.init(rebasing:)(v11, v12, v13, v14);
          if (v16)
          {
            uint64_t v18 = (unsigned __int8 *)v15;
            unsigned __int8 v19 = a3 + 48;
            unsigned __int8 v20 = a3 + 55;
            unsigned __int8 v21 = a3 + 87;
            if (a3 > 10)
            {
              unsigned __int8 v19 = 58;
            }

            else
            {
              unsigned __int8 v21 = 97;
              unsigned __int8 v20 = 65;
            }

            if (v15)
            {
              uint64_t v22 = v16;
              unint64_t v23 = 0LL;
              uint64_t v24 = 0LL;
              unint64_t v25 = abs64(a3);
              unint64_t v26 = -(v17 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
              while (1)
              {
                unsigned int v27 = *v18;
                if (v27 < 0x30 || v27 >= v19)
                {
                  if (v27 < 0x41 || v27 >= v20)
                  {
                    unint64_t result = 0LL;
                    char v10 = 1;
                    if (v27 < 0x61 || v27 >= v21) {
                      goto LABEL_261;
                    }
                    char v28 = -87;
                  }

                  else
                  {
                    char v28 = -55;
                  }
                }

                else
                {
                  char v28 = -48;
                }

                BOOL v31 = !((__PAIR128__(v24 ^ (unint64_t)(v24 >> 63), v23 ^ (v24 >> 63))
                       - __PAIR128__(v24 >> 63, v24 >> 63)) >> 64)
                   || v26 == 0;
                BOOL v32 = v31 && (*((unint64_t *)&v30 + 1) * (unsigned __int128)v25) >> 64 == 0;
                BOOL v33 = v32 && (v26 * (unsigned __int128)(unint64_t)v30) >> 64 == 0;
                BOOL v34 = !v33;
                unint64_t v35 = (__PAIR128__(v26, v25) * v30) >> 64;
                char v36 = __CFADD__( ((unint64_t)v30 * (unsigned __int128)v25) >> 64,  v26 * v30 + *((void *)&v30 + 1) * v25)
                   || v34;
                unint64_t v37 = v30 * v25;
                if ((v24 ^ (a3 >> 63)) < 0)
                {
                  if ((v36 & 1) != 0) {
                    goto LABEL_260;
                  }
                  BOOL v39 = v37 == 0;
                  unint64_t v37 = -(uint64_t)v37;
                  unint64_t v35 = -(uint64_t)(v35 + !v39);
                  LOBYTE(v38) = v37 != 0;
                }

                else
                {
                  if ((v36 & 1) != 0) {
                    goto LABEL_260;
                  }
                  unint64_t v38 = v35 >> 63;
                }

                unint64_t result = 0LL;
                BOOL v39 = v37 >= (v27 + v28);
                uint64_t v24 = (__PAIR128__(v35, v37) - (v27 + v28)) >> 64;
                unint64_t v23 = v37 - (v27 + v28);
                BOOL v40 = __OFSUB__(v35, !v39);
                char v10 = 1;
                if ((v38 & 1) != 0 || v40) {
                  goto LABEL_261;
                }
                ++v18;
                if (!--v22) {
                  goto LABEL_217;
                }
              }
            }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  char v24;
  unint64_t result;
  unsigned __int8 v26;
  BOOL v27;
  char v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  unint64_t v34;
  unint64_t v35;
  BOOL v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 v46;
  unsigned __int8 v47;
  unsigned __int8 v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unsigned int v52;
  char v53;
  unsigned __int8 v54;
  BOOL v55;
  char v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  BOOL v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned __int8 *v71;
  unsigned __int8 v72;
  unsigned __int8 v73;
  unsigned __int8 v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unsigned int v78;
  char v79;
  unsigned __int8 v80;
  BOOL v81;
  char v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  BOOL v89;
  BOOL v90;
  uint64_t v91;
  unint64_t v92;
  unsigned __int8 v93;
  unsigned __int8 v94;
  unsigned __int8 v95;
  uint64_t v96;
  unsigned int v97;
  char v98;
  unsigned __int8 v99;
  BOOL v100;
  char v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  BOOL v108;
  BOOL v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unsigned __int8 *v116;
  unsigned __int8 v117;
  unsigned __int8 v118;
  unsigned __int8 v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unsigned int v123;
  char v124;
  unsigned __int8 v125;
  BOOL v126;
  char v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  BOOL v134;
  BOOL v135;
  uint64_t v136;
  unint64_t v137;
  unsigned __int8 v138;
  unsigned __int8 v139;
  unsigned __int8 v140;
  uint64_t v141;
  unsigned __int8 *v142;
  unsigned int v143;
  char v144;
  unsigned __int8 v145;
  BOOL v146;
  char v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  BOOL v154;
  BOOL v155;
  uint64_t v156;
  void v157[2];
  char v158;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = 0LL;
    unint64_t v158 = 0;
    goto LABEL_230;
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
        goto LABEL_5;
      }
    }

    else
    {
      unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v6 = v156;
      if (v156 > 0)
      {
LABEL_5:
        char v7 = *v5;
        if (v7 != 43)
        {
          if (v7 != 45)
          {
            unint64_t v91 = 0LL;
            char v92 = 0LL;
            unint64_t v93 = a3 + 48;
            unint64_t v94 = a3 + 55;
            BOOL v95 = a3 + 87;
            if (a3 > 10)
            {
              unint64_t v93 = 58;
            }

            else
            {
              BOOL v95 = 97;
              unint64_t v94 = 65;
            }

            unint64_t v96 = a3 >> 63;
            while (1)
            {
              uint64_t v97 = *v5;
              if (v97 < 0x30 || v97 >= v93)
              {
                if (v97 < 0x41 || v97 >= v94)
                {
                  unint64_t result = 0LL;
                  uint64_t v8 = 1;
                  if (v97 < 0x61 || v97 >= v95) {
                    goto LABEL_229;
                  }
                  unsigned __int8 v98 = -87;
                }

                else
                {
                  unsigned __int8 v98 = -55;
                }
              }

              else
              {
                unsigned __int8 v98 = -48;
              }

              unint64_t result = 0LL;
              unsigned __int8 v99 = v97 + v98;
              if (v92) {
                unsigned __int8 v100 = a3 >= 0;
              }
              else {
                unsigned __int8 v100 = 1;
              }
              unsigned int v103 = !v100
                  || (v92 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
                  || ((unint64_t)v96 * (unsigned __int128)(unint64_t)v91) >> 64 != 0;
              char v104 = v96 * v91 + v92 * a3;
              unsigned __int128 v105 = ((unint64_t)v91 * (unsigned __int128)(unint64_t)a3) >> 64;
              BOOL v33 = __CFADD__(v105, v104);
              BOOL v106 = v105 + v104;
              if (v33) {
                unsigned int v103 = 1;
              }
              BOOL v107 = v91 * a3;
              BOOL v33 = __CFADD__(v107, v99);
              unint64_t v91 = v107 + v99;
              BOOL v108 = v33;
              BOOL v33 = __CFADD__(v33, v106);
              char v92 = v108 + v106;
              BOOL v109 = v33;
              uint64_t v8 = 1;
              if ((v103 & 1) != 0 || v109) {
                goto LABEL_229;
              }
              ++v5;
              if (!--v6)
              {
                uint64_t v8 = 0;
                unint64_t result = v91;
                goto LABEL_229;
              }
            }
          }

          uint64_t v8 = 1;
          int v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
          uint64_t v13 = specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
          if (v14)
          {
            uint64_t v15 = (unsigned __int8 *)v13;
            uint64_t v16 = a3 + 55;
            uint64_t v17 = a3 + 87;
            if (a3 > 10)
            {
              uint64_t v18 = 58;
            }

            else
            {
              uint64_t v17 = 97;
              uint64_t v16 = 65;
              uint64_t v18 = a3 + 48;
            }

            if (v13)
            {
              unsigned __int8 v19 = v14;
              unsigned __int8 v20 = 0LL;
              unsigned __int8 v21 = 0LL;
              uint64_t v22 = a3 >> 63;
              while (1)
              {
                unint64_t v23 = *v15;
                if (v23 < 0x30 || v23 >= v18)
                {
                  if (v23 < 0x41 || v23 >= v16)
                  {
                    unint64_t result = 0LL;
                    uint64_t v8 = 1;
                    if (v23 < 0x61 || v23 >= v17) {
                      goto LABEL_229;
                    }
                    uint64_t v24 = -87;
                  }

                  else
                  {
                    uint64_t v24 = -55;
                  }
                }

                else
                {
                  uint64_t v24 = -48;
                }

                unint64_t result = 0LL;
                unint64_t v26 = v23 + v24;
                if (v21) {
                  unsigned int v27 = a3 >= 0;
                }
                else {
                  unsigned int v27 = 1;
                }
                unsigned __int128 v30 = !v27
                   || (v21 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
                   || ((unint64_t)v22 * (unsigned __int128)v20) >> 64 != 0;
                BOOL v31 = v22 * v20 + v21 * a3;
                BOOL v32 = (v20 * (unsigned __int128)(unint64_t)a3) >> 64;
                BOOL v33 = __CFADD__(v32, v31);
                BOOL v34 = v32 + v31;
                if (v33) {
                  unsigned __int128 v30 = 1;
                }
                unint64_t v35 = v20 * a3;
                BOOL v33 = v35 >= v26;
                unsigned __int8 v20 = v35 - v26;
                char v36 = v33;
                BOOL v33 = v34 >= !v33;
                unsigned __int8 v21 = v34 - !v36;
                unint64_t v37 = !v33;
                uint64_t v8 = 1;
                if ((v30 & 1) != 0 || v37) {
                  goto LABEL_229;
                }
                ++v15;
                if (!--v19) {
                  goto LABEL_192;
                }
              }
            }

            goto LABEL_193;
          }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned int v18;
  unsigned int v19;
  char v20;
  unsigned int v21;
  unsigned __int8 v22;
  unint64_t v23;
  BOOL v24;
  BOOL v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 *v32;
  uint64_t v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  unsigned __int8 v40;
  unint64_t v41;
  BOOL v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int8 *v48;
  uint64_t v49;
  unsigned __int8 v50;
  unsigned __int8 v51;
  unsigned __int8 v52;
  unsigned int v53;
  unsigned int v54;
  char v55;
  unsigned __int8 v56;
  unint64_t v57;
  BOOL v58;
  char v59;
  unsigned int v60;
  unsigned __int8 v61;
  unsigned __int8 v62;
  unsigned __int8 v63;
  unsigned int v64;
  char v65;
  unsigned __int8 v66;
  unint64_t v67;
  BOOL v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned __int8 *v74;
  uint64_t v75;
  unsigned __int8 v76;
  unsigned __int8 v77;
  unsigned __int8 v78;
  unsigned int v79;
  unsigned int v80;
  char v81;
  unsigned __int8 v82;
  unint64_t v83;
  BOOL v84;
  char v85;
  unsigned int v87;
  unsigned __int8 v88;
  unsigned __int8 v89;
  unsigned __int8 v90;
  unsigned __int8 *v91;
  unsigned int v92;
  char v93;
  unsigned __int8 v94;
  unint64_t v95;
  BOOL v96;
  char v97;
  uint64_t v98;
  void v99[2];
  unsigned __int8 v100;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unsigned __int8 v21 = 0;
    unsigned __int8 v100 = 0;
    return v21 | ((unint64_t)v100 << 32) | (((a2 >> 60) & 1) << 40);
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
        goto LABEL_5;
      }
    }

    else
    {
      unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v6 = v98;
      if (v98 > 0)
      {
LABEL_5:
        char v7 = *v5;
        if (v7 != 43)
        {
          if (v7 != 45)
          {
            BOOL v60 = 0;
            BOOL v61 = a3 + 55;
            BOOL v62 = a3 + 87;
            if (a3 > 10)
            {
              BOOL v63 = 58;
            }

            else
            {
              BOOL v62 = 97;
              BOOL v61 = 65;
              BOOL v63 = a3 + 48;
            }

            do
            {
              unint64_t v64 = *v5;
              if (v64 < 0x30 || v64 >= v63)
              {
                if (v64 < 0x41 || v64 >= v61)
                {
                  unsigned __int8 v21 = 0;
                  uint64_t v8 = 1;
                  if (v64 < 0x61 || v64 >= v62) {
                    goto LABEL_118;
                  }
                  char v65 = -87;
                }

                else
                {
                  char v65 = -55;
                }
              }

              else
              {
                char v65 = -48;
              }

              unsigned __int8 v21 = 0;
              unint64_t v66 = v64 + v65;
              unint64_t v67 = v60 * (unint64_t)a3;
              BOOL v68 = (v67 & 0xFFFFFFFF00000000LL) != 0;
              unint64_t v25 = __CFADD__((_DWORD)v67, v66);
              BOOL v60 = v67 + v66;
              uint64_t v69 = v25;
              uint64_t v8 = 1;
              if (v68) {
                break;
              }
              if ((v69 & 1) != 0) {
                break;
              }
              uint64_t v8 = 0;
              ++v5;
              unsigned __int8 v21 = v60;
              --v6;
            }

            while (v6);
            goto LABEL_118;
          }

          uint64_t v8 = 1;
          int v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
          uint64_t v13 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
          if (v14)
          {
            uint64_t v15 = a3 + 55;
            uint64_t v16 = a3 + 87;
            if (a3 > 10)
            {
              uint64_t v17 = 58;
            }

            else
            {
              uint64_t v16 = 97;
              uint64_t v15 = 65;
              uint64_t v17 = a3 + 48;
            }

            if (v13)
            {
              uint64_t v18 = 0;
              do
              {
                unsigned __int8 v19 = *v13;
                if (v19 < 0x30 || v19 >= v17)
                {
                  if (v19 < 0x41 || v19 >= v15)
                  {
                    unsigned __int8 v21 = 0;
                    uint64_t v8 = 1;
                    if (v19 < 0x61 || v19 >= v16) {
                      goto LABEL_118;
                    }
                    unsigned __int8 v20 = -87;
                  }

                  else
                  {
                    unsigned __int8 v20 = -55;
                  }
                }

                else
                {
                  unsigned __int8 v20 = -48;
                }

                unsigned __int8 v21 = 0;
                uint64_t v22 = v19 + v20;
                unint64_t v23 = v18 * (unint64_t)a3;
                uint64_t v24 = (v23 & 0xFFFFFFFF00000000LL) != 0;
                unint64_t v25 = v23 >= v22;
                uint64_t v18 = v23 - v22;
                unint64_t v26 = !v25;
                uint64_t v8 = 1;
                if (v24) {
                  break;
                }
                if ((v26 & 1) != 0) {
                  break;
                }
                uint64_t v8 = 0;
                ++v13;
                unsigned __int8 v21 = v18;
                --v14;
              }

              while (v14);
              goto LABEL_118;
            }

            goto LABEL_117;
          }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned int v18;
  unsigned int v19;
  char v20;
  unsigned int v21;
  unsigned __int8 v22;
  uint64_t v23;
  BOOL v24;
  BOOL v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 *v32;
  uint64_t v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  unsigned __int8 v40;
  uint64_t v41;
  BOOL v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int8 *v48;
  uint64_t v49;
  unsigned __int8 v50;
  unsigned __int8 v51;
  unsigned __int8 v52;
  unsigned int v53;
  unsigned int v54;
  char v55;
  unsigned __int8 v56;
  uint64_t v57;
  BOOL v58;
  char v59;
  unsigned int v60;
  unsigned __int8 v61;
  unsigned __int8 v62;
  unsigned __int8 v63;
  unsigned int v64;
  char v65;
  unsigned __int8 v66;
  uint64_t v67;
  BOOL v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned __int8 *v74;
  uint64_t v75;
  unsigned __int8 v76;
  unsigned __int8 v77;
  unsigned __int8 v78;
  unsigned int v79;
  unsigned int v80;
  char v81;
  unsigned __int8 v82;
  uint64_t v83;
  BOOL v84;
  char v85;
  unsigned int v87;
  unsigned __int8 v88;
  unsigned __int8 v89;
  unsigned __int8 v90;
  unsigned __int8 *v91;
  unsigned int v92;
  char v93;
  unsigned __int8 v94;
  uint64_t v95;
  BOOL v96;
  char v97;
  uint64_t v98;
  void v99[2];
  unsigned __int8 v100;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unsigned __int8 v21 = 0;
    unsigned __int8 v100 = 0;
    return v21 | ((unint64_t)v100 << 32) | (((a2 >> 60) & 1) << 40);
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
        goto LABEL_5;
      }
    }

    else
    {
      unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v6 = v98;
      if (v98 > 0)
      {
LABEL_5:
        char v7 = *v5;
        if (v7 != 43)
        {
          if (v7 != 45)
          {
            BOOL v60 = 0;
            BOOL v61 = a3 + 55;
            BOOL v62 = a3 + 87;
            if (a3 > 10)
            {
              BOOL v63 = 58;
            }

            else
            {
              BOOL v62 = 97;
              BOOL v61 = 65;
              BOOL v63 = a3 + 48;
            }

            do
            {
              unint64_t v64 = *v5;
              if (v64 < 0x30 || v64 >= v63)
              {
                if (v64 < 0x41 || v64 >= v61)
                {
                  unsigned __int8 v21 = 0;
                  uint64_t v8 = 1;
                  if (v64 < 0x61 || v64 >= v62) {
                    goto LABEL_118;
                  }
                  char v65 = -87;
                }

                else
                {
                  char v65 = -55;
                }
              }

              else
              {
                char v65 = -48;
              }

              unsigned __int8 v21 = 0;
              unint64_t v66 = v64 + v65;
              unint64_t v67 = (int)v60 * (uint64_t)(int)a3;
              BOOL v68 = v67 != (int)v67;
              unint64_t v25 = __OFADD__((_DWORD)v67, v66);
              BOOL v60 = v67 + v66;
              uint64_t v69 = v25;
              uint64_t v8 = 1;
              if (v68) {
                break;
              }
              if ((v69 & 1) != 0) {
                break;
              }
              uint64_t v8 = 0;
              ++v5;
              unsigned __int8 v21 = v60;
              --v6;
            }

            while (v6);
            goto LABEL_118;
          }

          uint64_t v8 = 1;
          int v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
          uint64_t v13 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
          if (v14)
          {
            uint64_t v15 = a3 + 55;
            uint64_t v16 = a3 + 87;
            if (a3 > 10)
            {
              uint64_t v17 = 58;
            }

            else
            {
              uint64_t v16 = 97;
              uint64_t v15 = 65;
              uint64_t v17 = a3 + 48;
            }

            if (v13)
            {
              uint64_t v18 = 0;
              do
              {
                unsigned __int8 v19 = *v13;
                if (v19 < 0x30 || v19 >= v17)
                {
                  if (v19 < 0x41 || v19 >= v15)
                  {
                    unsigned __int8 v21 = 0;
                    uint64_t v8 = 1;
                    if (v19 < 0x61 || v19 >= v16) {
                      goto LABEL_118;
                    }
                    unsigned __int8 v20 = -87;
                  }

                  else
                  {
                    unsigned __int8 v20 = -55;
                  }
                }

                else
                {
                  unsigned __int8 v20 = -48;
                }

                unsigned __int8 v21 = 0;
                uint64_t v22 = v19 + v20;
                unint64_t v23 = (int)v18 * (uint64_t)(int)a3;
                uint64_t v24 = v23 != (int)v23;
                unint64_t v25 = __OFSUB__((_DWORD)v23, v22);
                uint64_t v18 = v23 - v22;
                unint64_t v26 = v25;
                uint64_t v8 = 1;
                if (v24) {
                  break;
                }
                if ((v26 & 1) != 0) {
                  break;
                }
                uint64_t v8 = 0;
                ++v13;
                unsigned __int8 v21 = v18;
                --v14;
              }

              while (v14);
              goto LABEL_118;
            }

            goto LABEL_117;
          }

uint64_t specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:)( uint64_t a1, unint64_t a2, uint64_t a3)
{
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unsigned __int8 v21 = 0;
    unsigned __int8 v83 = 0;
    goto LABEL_104;
  }

  if ((a2 & 0x2000000000000000LL) != 0)
  {
    uint64_t v24 = HIBYTE(a2) & 0xF;
    v82[0] = a1;
    v82[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (v24)
    {
      if (a1 != 43)
      {
        if (a1 != 45)
        {
          LOBYTE(v73) = 0;
          unsigned __int8 v74 = a3 + 55;
          unsigned __int8 v75 = a3 + 87;
          if (a3 > 10)
          {
            unsigned __int8 v76 = 58;
          }

          else
          {
            unsigned __int8 v75 = 97;
            unsigned __int8 v74 = 65;
            unsigned __int8 v76 = a3 + 48;
          }

          unsigned __int8 v77 = (unsigned __int8 *)v82;
          while (1)
          {
            unsigned int v78 = *v77;
            if (v78 < 0x30 || v78 >= v76)
            {
              if (v78 < 0x41 || v78 >= v74)
              {
                unsigned __int8 v21 = 0;
                char v8 = 1;
                if (v78 < 0x61 || v78 >= v75) {
                  goto LABEL_103;
                }
                char v79 = -87;
              }

              else
              {
                char v79 = -55;
              }
            }

            else
            {
              char v79 = -48;
            }

            unsigned __int8 v21 = 0;
            __int16 v80 = v73 * a3;
            char v8 = 1;
            if ((v80 & 0xFF00) == 0)
            {
              unsigned int v73 = v80 + (v78 + v79);
              if (((v73 >> 8) & 1) == 0)
              {
                char v8 = 0;
                ++v77;
                unsigned __int8 v21 = v73;
                if (--v24) {
                  continue;
                }
              }
            }

            goto LABEL_103;
          }
        }

        char v8 = 1;
        uint64_t v25 = specialized Collection.subscript.getter(1LL, (uint64_t)v82, v24);
        uint64_t v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
        if (v30)
        {
          unsigned __int8 v31 = a3 + 55;
          unsigned __int8 v32 = a3 + 87;
          if (a3 > 10)
          {
            unsigned __int8 v33 = 58;
          }

          else
          {
            unsigned __int8 v32 = 97;
            unsigned __int8 v31 = 65;
            unsigned __int8 v33 = a3 + 48;
          }

          if (v29)
          {
            LOBYTE(v34) = 0;
            while (1)
            {
              unsigned int v35 = *v29;
              if (v35 < 0x30 || v35 >= v33)
              {
                if (v35 < 0x41 || v35 >= v31)
                {
                  unsigned __int8 v21 = 0;
                  char v8 = 1;
                  if (v35 < 0x61 || v35 >= v32) {
                    goto LABEL_103;
                  }
                  char v36 = -87;
                }

                else
                {
                  char v36 = -55;
                }
              }

              else
              {
                char v36 = -48;
              }

              unsigned __int8 v21 = 0;
              unsigned __int8 v37 = v35 + v36;
              __int16 v38 = v34 * a3;
              int v34 = (v34 * a3) - v37;
              char v8 = 1;
              if ((v38 & 0xFF00) == 0 && (v34 & 0xFFFFFF00) == 0)
              {
                char v8 = 0;
                ++v29;
                unsigned __int8 v21 = v34;
                if (--v30) {
                  continue;
                }
              }

              goto LABEL_103;
            }
          }

          goto LABEL_102;
        }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  int v18;
  unsigned int v19;
  char v20;
  unsigned __int8 v21;
  char v22;
  int v23;
  int v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  uint64_t v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  int v36;
  unsigned int v37;
  char v38;
  char v39;
  int v40;
  int v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 *v47;
  uint64_t v48;
  unsigned __int8 v49;
  unsigned __int8 v50;
  unsigned __int8 v51;
  int v52;
  unsigned int v53;
  char v54;
  char v55;
  int v56;
  int v57;
  BOOL v58;
  int v59;
  unsigned __int8 v60;
  unsigned __int8 v61;
  unsigned __int8 v62;
  unsigned int v63;
  char v64;
  char v65;
  int v66;
  int v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int8 *v73;
  uint64_t v74;
  unsigned __int8 v75;
  unsigned __int8 v76;
  unsigned __int8 v77;
  int v78;
  unsigned int v79;
  char v80;
  char v81;
  int v82;
  int v83;
  BOOL v84;
  int v86;
  unsigned __int8 v87;
  unsigned __int8 v88;
  unsigned __int8 v89;
  unsigned __int8 *v90;
  unsigned int v91;
  char v92;
  char v93;
  int v94;
  int v95;
  BOOL v96;
  uint64_t v97;
  void v98[2];
  unsigned __int8 v99;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unsigned __int8 v21 = 0;
    unsigned __int8 v99 = 0;
    goto LABEL_104;
  }

  if ((a2 & 0x2000000000000000LL) != 0)
  {
    uint64_t v26 = HIBYTE(a2) & 0xF;
    v98[0] = a1;
    v98[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (v26)
    {
      if (a1 != 43)
      {
        if (a1 != 45)
        {
          LOBYTE(v86) = 0;
          BOOL v87 = a3 + 55;
          BOOL v88 = a3 + 87;
          if (a3 > 10)
          {
            BOOL v89 = 58;
          }

          else
          {
            BOOL v88 = 97;
            BOOL v87 = 65;
            BOOL v89 = a3 + 48;
          }

          BOOL v90 = (unsigned __int8 *)v98;
          while (1)
          {
            unint64_t v91 = *v90;
            if (v91 < 0x30 || v91 >= v89)
            {
              if (v91 < 0x41 || v91 >= v87)
              {
                unsigned __int8 v21 = 0;
                char v8 = 1;
                if (v91 < 0x61 || v91 >= v88) {
                  goto LABEL_103;
                }
                char v92 = -87;
              }

              else
              {
                char v92 = -55;
              }
            }

            else
            {
              char v92 = -48;
            }

            unsigned __int8 v21 = 0;
            unint64_t v93 = v91 + v92;
            unint64_t v94 = (char)v86 * (char)a3;
            BOOL v95 = (char)(v86 * a3);
            unsigned __int128 v86 = v95 + v93;
            unint64_t v96 = v86 != (char)(v95 + v93);
            char v8 = 1;
            if (v95 == v94 && !v96)
            {
              char v8 = 0;
              ++v90;
              unsigned __int8 v21 = v86;
              if (--v26) {
                continue;
              }
            }

            goto LABEL_103;
          }
        }

        char v8 = 1;
        uint64_t v27 = specialized Collection.subscript.getter(1LL, (uint64_t)v98, v26);
        unsigned __int8 v31 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v27, v28, v29, v30);
        if (v32)
        {
          unsigned __int8 v33 = a3 + 55;
          int v34 = a3 + 87;
          if (a3 > 10)
          {
            unsigned int v35 = 58;
          }

          else
          {
            int v34 = 97;
            unsigned __int8 v33 = 65;
            unsigned int v35 = a3 + 48;
          }

          if (v31)
          {
            LOBYTE(v36) = 0;
            while (1)
            {
              unsigned __int8 v37 = *v31;
              if (v37 < 0x30 || v37 >= v35)
              {
                if (v37 < 0x41 || v37 >= v33)
                {
                  unsigned __int8 v21 = 0;
                  char v8 = 1;
                  if (v37 < 0x61 || v37 >= v34) {
                    goto LABEL_103;
                  }
                  __int16 v38 = -87;
                }

                else
                {
                  __int16 v38 = -55;
                }
              }

              else
              {
                __int16 v38 = -48;
              }

              unsigned __int8 v21 = 0;
              uint64_t v39 = v37 + v38;
              uint64_t v40 = (char)v36 * (char)a3;
              uint64_t v41 = (char)(v36 * a3);
              char v36 = v41 - v39;
              uint64_t v42 = v36 != (char)(v41 - v39);
              char v8 = 1;
              if (v41 == v40 && !v42)
              {
                char v8 = 0;
                ++v31;
                unsigned __int8 v21 = v36;
                if (--v32) {
                  continue;
                }
              }

              goto LABEL_103;
            }
          }

          goto LABEL_102;
        }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  int v18;
  unsigned int v19;
  char v20;
  unsigned __int16 v21;
  unsigned __int8 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  int v34;
  unsigned int v35;
  char v36;
  unsigned __int8 v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int8 *v43;
  uint64_t v44;
  unsigned __int8 v45;
  unsigned __int8 v46;
  unsigned __int8 v47;
  int v48;
  unsigned int v49;
  char v50;
  int v51;
  int v52;
  unsigned __int8 v53;
  unsigned __int8 v54;
  unsigned __int8 v55;
  unsigned int v56;
  char v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int8 *v63;
  uint64_t v64;
  unsigned __int8 v65;
  unsigned __int8 v66;
  unsigned __int8 v67;
  int v68;
  unsigned int v69;
  char v70;
  int v71;
  int v73;
  unsigned __int8 v74;
  unsigned __int8 v75;
  unsigned __int8 v76;
  unsigned __int8 *v77;
  unsigned int v78;
  char v79;
  int v80;
  uint64_t v81;
  void v82[2];
  unsigned __int8 v83;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unsigned __int8 v21 = 0;
    unsigned __int8 v83 = 0;
    goto LABEL_104;
  }

  if ((a2 & 0x2000000000000000LL) != 0)
  {
    uint64_t v24 = HIBYTE(a2) & 0xF;
    v82[0] = a1;
    v82[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (v24)
    {
      if (a1 != 43)
      {
        if (a1 != 45)
        {
          LOWORD(v73) = 0;
          unsigned __int8 v74 = a3 + 55;
          unsigned __int8 v75 = a3 + 87;
          if (a3 > 10)
          {
            unsigned __int8 v76 = 58;
          }

          else
          {
            unsigned __int8 v75 = 97;
            unsigned __int8 v74 = 65;
            unsigned __int8 v76 = a3 + 48;
          }

          unsigned __int8 v77 = (unsigned __int8 *)v82;
          while (1)
          {
            unsigned int v78 = *v77;
            if (v78 < 0x30 || v78 >= v76)
            {
              if (v78 < 0x41 || v78 >= v74)
              {
                unsigned __int8 v21 = 0;
                char v8 = 1;
                if (v78 < 0x61 || v78 >= v75) {
                  goto LABEL_103;
                }
                char v79 = -87;
              }

              else
              {
                char v79 = -55;
              }
            }

            else
            {
              char v79 = -48;
            }

            unsigned __int8 v21 = 0;
            __int16 v80 = (unsigned __int16)v73 * (unsigned __int16)a3;
            char v8 = 1;
            if ((v80 & 0xFFFF0000) == 0)
            {
              unsigned int v73 = (unsigned __int16)v80 + (v78 + v79);
              if ((v73 & 0x10000) == 0)
              {
                char v8 = 0;
                ++v77;
                unsigned __int8 v21 = v73;
                if (--v24) {
                  continue;
                }
              }
            }

            goto LABEL_103;
          }
        }

        char v8 = 1;
        uint64_t v25 = specialized Collection.subscript.getter(1LL, (uint64_t)v82, v24);
        uint64_t v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
        if (v30)
        {
          unsigned __int8 v31 = a3 + 55;
          unsigned __int8 v32 = a3 + 87;
          if (a3 > 10)
          {
            unsigned __int8 v33 = 58;
          }

          else
          {
            unsigned __int8 v32 = 97;
            unsigned __int8 v31 = 65;
            unsigned __int8 v33 = a3 + 48;
          }

          if (v29)
          {
            LOWORD(v34) = 0;
            while (1)
            {
              unsigned int v35 = *v29;
              if (v35 < 0x30 || v35 >= v33)
              {
                if (v35 < 0x41 || v35 >= v31)
                {
                  unsigned __int8 v21 = 0;
                  char v8 = 1;
                  if (v35 < 0x61 || v35 >= v32) {
                    goto LABEL_103;
                  }
                  char v36 = -87;
                }

                else
                {
                  char v36 = -55;
                }
              }

              else
              {
                char v36 = -48;
              }

              unsigned __int8 v21 = 0;
              unsigned __int8 v37 = v35 + v36;
              __int16 v38 = (unsigned __int16)v34 * (unsigned __int16)a3;
              int v34 = (unsigned __int16)(v34 * a3) - v37;
              char v8 = 1;
              if ((v38 & 0xFFFF0000) == 0 && (v34 & 0xFFFF0000) == 0)
              {
                char v8 = 0;
                ++v29;
                unsigned __int8 v21 = v34;
                if (--v30) {
                  continue;
                }
              }

              goto LABEL_103;
            }
          }

          goto LABEL_102;
        }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  int v18;
  unsigned int v19;
  char v20;
  unsigned __int16 v21;
  unsigned __int8 v22;
  int v23;
  int v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  uint64_t v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  int v36;
  unsigned int v37;
  char v38;
  unsigned __int8 v39;
  int v40;
  int v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 *v47;
  uint64_t v48;
  unsigned __int8 v49;
  unsigned __int8 v50;
  unsigned __int8 v51;
  int v52;
  unsigned int v53;
  char v54;
  unsigned __int8 v55;
  int v56;
  int v57;
  BOOL v58;
  int v59;
  unsigned __int8 v60;
  unsigned __int8 v61;
  unsigned __int8 v62;
  unsigned int v63;
  char v64;
  unsigned __int8 v65;
  int v66;
  int v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int8 *v73;
  uint64_t v74;
  unsigned __int8 v75;
  unsigned __int8 v76;
  unsigned __int8 v77;
  int v78;
  unsigned int v79;
  char v80;
  unsigned __int8 v81;
  int v82;
  int v83;
  BOOL v84;
  int v86;
  unsigned __int8 v87;
  unsigned __int8 v88;
  unsigned __int8 v89;
  unsigned __int8 *v90;
  unsigned int v91;
  char v92;
  unsigned __int8 v93;
  int v94;
  int v95;
  BOOL v96;
  uint64_t v97;
  void v98[2];
  unsigned __int8 v99;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unsigned __int8 v21 = 0;
    unsigned __int8 v99 = 0;
    goto LABEL_104;
  }

  if ((a2 & 0x2000000000000000LL) != 0)
  {
    uint64_t v26 = HIBYTE(a2) & 0xF;
    v98[0] = a1;
    v98[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (v26)
    {
      if (a1 != 43)
      {
        if (a1 != 45)
        {
          LOWORD(v86) = 0;
          BOOL v87 = a3 + 55;
          BOOL v88 = a3 + 87;
          if (a3 > 10)
          {
            BOOL v89 = 58;
          }

          else
          {
            BOOL v88 = 97;
            BOOL v87 = 65;
            BOOL v89 = a3 + 48;
          }

          BOOL v90 = (unsigned __int8 *)v98;
          while (1)
          {
            unint64_t v91 = *v90;
            if (v91 < 0x30 || v91 >= v89)
            {
              if (v91 < 0x41 || v91 >= v87)
              {
                unsigned __int8 v21 = 0;
                char v8 = 1;
                if (v91 < 0x61 || v91 >= v88) {
                  goto LABEL_103;
                }
                char v92 = -87;
              }

              else
              {
                char v92 = -55;
              }
            }

            else
            {
              char v92 = -48;
            }

            unsigned __int8 v21 = 0;
            unint64_t v93 = v91 + v92;
            unint64_t v94 = (__int16)v86 * (__int16)a3;
            BOOL v95 = (__int16)(v86 * a3);
            unsigned __int128 v86 = v95 + v93;
            unint64_t v96 = v86 != (__int16)(v95 + v93);
            char v8 = 1;
            if (v95 == v94 && !v96)
            {
              char v8 = 0;
              ++v90;
              unsigned __int8 v21 = v86;
              if (--v26) {
                continue;
              }
            }

            goto LABEL_103;
          }
        }

        char v8 = 1;
        uint64_t v27 = specialized Collection.subscript.getter(1LL, (uint64_t)v98, v26);
        unsigned __int8 v31 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v27, v28, v29, v30);
        if (v32)
        {
          unsigned __int8 v33 = a3 + 55;
          int v34 = a3 + 87;
          if (a3 > 10)
          {
            unsigned int v35 = 58;
          }

          else
          {
            int v34 = 97;
            unsigned __int8 v33 = 65;
            unsigned int v35 = a3 + 48;
          }

          if (v31)
          {
            LOWORD(v36) = 0;
            while (1)
            {
              unsigned __int8 v37 = *v31;
              if (v37 < 0x30 || v37 >= v35)
              {
                if (v37 < 0x41 || v37 >= v33)
                {
                  unsigned __int8 v21 = 0;
                  char v8 = 1;
                  if (v37 < 0x61 || v37 >= v34) {
                    goto LABEL_103;
                  }
                  __int16 v38 = -87;
                }

                else
                {
                  __int16 v38 = -55;
                }
              }

              else
              {
                __int16 v38 = -48;
              }

              unsigned __int8 v21 = 0;
              uint64_t v39 = v37 + v38;
              uint64_t v40 = (__int16)v36 * (__int16)a3;
              uint64_t v41 = (__int16)(v36 * a3);
              char v36 = v41 - v39;
              uint64_t v42 = v36 != (__int16)(v41 - v39);
              char v8 = 1;
              if (v41 == v40 && !v42)
              {
                char v8 = 0;
                ++v31;
                unsigned __int8 v21 = v36;
                if (--v32) {
                  continue;
                }
              }

              goto LABEL_103;
            }
          }

          goto LABEL_102;
        }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  uint64_t v19;
  unsigned int v20;
  char v21;
  uint64_t result;
  unsigned __int8 v23;
  uint64_t v24;
  BOOL v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  uint64_t v38;
  unsigned int v39;
  char v40;
  unsigned __int8 v41;
  uint64_t v42;
  BOOL v43;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned __int8 *v51;
  unsigned __int8 v52;
  unsigned __int8 v53;
  unsigned __int8 v54;
  uint64_t v55;
  unsigned int v56;
  char v57;
  unsigned __int8 v58;
  uint64_t v59;
  BOOL v60;
  BOOL v61;
  uint64_t v62;
  unsigned __int8 v63;
  unsigned __int8 v64;
  unsigned __int8 v65;
  unsigned int v66;
  char v67;
  unsigned __int8 v68;
  uint64_t v69;
  BOOL v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned __int8 *v78;
  unsigned __int8 v79;
  unsigned __int8 v80;
  unsigned __int8 v81;
  uint64_t v82;
  unsigned int v83;
  char v84;
  unsigned __int8 v85;
  uint64_t v86;
  BOOL v87;
  BOOL v88;
  uint64_t v89;
  unsigned __int8 v90;
  unsigned __int8 v91;
  unsigned __int8 v92;
  unsigned __int8 *v93;
  unsigned int v94;
  char v95;
  unsigned __int8 v96;
  uint64_t v97;
  BOOL v98;
  BOOL v99;
  uint64_t v100;
  void v101[2];
  char v102;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = 0LL;
    unint64_t v102 = 0;
    goto LABEL_119;
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
        goto LABEL_5;
      }
    }

    else
    {
      unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v6 = v100;
      if (v100 > 0)
      {
LABEL_5:
        int v7 = *v5;
        if (v7 != 43)
        {
          if (v7 != 45)
          {
            uint64_t v62 = 0LL;
            BOOL v63 = a3 + 48;
            uint64_t v64 = a3 + 55;
            unsigned __int8 v65 = a3 + 87;
            if (a3 > 10)
            {
              BOOL v63 = 58;
            }

            else
            {
              unsigned __int8 v65 = 97;
              uint64_t v64 = 65;
            }

            do
            {
              unsigned __int8 v66 = *v5;
              if (v66 < 0x30 || v66 >= v63)
              {
                if (v66 < 0x41 || v66 >= v64)
                {
                  unint64_t result = 0LL;
                  char v8 = 1;
                  if (v66 < 0x61 || v66 >= v65) {
                    goto LABEL_118;
                  }
                  unsigned __int8 v67 = -87;
                }

                else
                {
                  unsigned __int8 v67 = -55;
                }
              }

              else
              {
                unsigned __int8 v67 = -48;
              }

              unint64_t result = 0LL;
              unsigned int v68 = v66 + v67;
              unsigned int v69 = v62 * a3;
              char v70 = (unsigned __int128)(v62 * (__int128)a3) >> 64 != (v62 * a3) >> 63;
              uint64_t v62 = v62 * a3 + v68;
              __int16 v71 = __OFADD__(v69, v68);
              char v8 = 1;
              if (v70) {
                break;
              }
              if (v71) {
                break;
              }
              char v8 = 0;
              ++v5;
              unint64_t result = v62;
              --v6;
            }

            while (v6);
            goto LABEL_118;
          }

          char v8 = 1;
          uint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
          uint64_t v13 = specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
          if (v14)
          {
            unsigned __int8 v15 = (unsigned __int8 *)v13;
            unsigned __int8 v16 = a3 + 48;
            unsigned __int8 v17 = a3 + 55;
            int v18 = a3 + 87;
            if (a3 > 10)
            {
              unsigned __int8 v16 = 58;
            }

            else
            {
              int v18 = 97;
              unsigned __int8 v17 = 65;
            }

            if (v13)
            {
              unsigned int v19 = 0LL;
              do
              {
                char v20 = *v15;
                if (v20 < 0x30 || v20 >= v16)
                {
                  if (v20 < 0x41 || v20 >= v17)
                  {
                    unint64_t result = 0LL;
                    char v8 = 1;
                    if (v20 < 0x61 || v20 >= v18) {
                      goto LABEL_118;
                    }
                    unsigned __int8 v21 = -87;
                  }

                  else
                  {
                    unsigned __int8 v21 = -55;
                  }
                }

                else
                {
                  unsigned __int8 v21 = -48;
                }

                unint64_t result = 0LL;
                __int16 v23 = v20 + v21;
                uint64_t v24 = v19 * a3;
                uint64_t v25 = (unsigned __int128)(v19 * (__int128)a3) >> 64 != (v19 * a3) >> 63;
                unsigned int v19 = v19 * a3 - v23;
                uint64_t v26 = __OFSUB__(v24, v23);
                char v8 = 1;
                if (v25) {
                  break;
                }
                if (v26) {
                  break;
                }
                char v8 = 0;
                ++v15;
                unint64_t result = v19;
                --v14;
              }

              while (v14);
              goto LABEL_118;
            }

            goto LABEL_117;
          }

unint64_t specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:)( uint64_t a1, unint64_t a2, int64_t a3)
{
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = 0LL;
    char v103 = 0;
    goto LABEL_119;
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
        goto LABEL_5;
      }
    }

    else
    {
      unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v6 = v101;
      if (v101 > 0)
      {
LABEL_5:
        int v7 = *v5;
        if (v7 != 43)
        {
          if (v7 != 45)
          {
            unint64_t v63 = 0LL;
            unsigned __int8 v64 = a3 + 48;
            unsigned __int8 v65 = a3 + 55;
            unsigned __int8 v66 = a3 + 87;
            if (a3 > 10)
            {
              unsigned __int8 v64 = 58;
            }

            else
            {
              unsigned __int8 v66 = 97;
              unsigned __int8 v65 = 65;
            }

            do
            {
              unsigned int v67 = *v5;
              if (v67 < 0x30 || v67 >= v64)
              {
                if (v67 < 0x41 || v67 >= v65)
                {
                  unint64_t result = 0LL;
                  char v8 = 1;
                  if (v67 < 0x61 || v67 >= v66) {
                    goto LABEL_118;
                  }
                  char v68 = -87;
                }

                else
                {
                  char v68 = -55;
                }
              }

              else
              {
                char v68 = -48;
              }

              unint64_t result = 0LL;
              unsigned __int8 v69 = v67 + v68;
              BOOL v70 = !is_mul_ok(v63, a3);
              unint64_t v71 = v63 * a3;
              BOOL v26 = __CFADD__(v71, v69);
              unint64_t v63 = v71 + v69;
              char v72 = v26;
              char v8 = 1;
              if (v70) {
                break;
              }
              if ((v72 & 1) != 0) {
                break;
              }
              char v8 = 0;
              ++v5;
              unint64_t result = v63;
              --v6;
            }

            while (v6);
            goto LABEL_118;
          }

          char v8 = 1;
          uint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
          uint64_t v13 = specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
          if (v14)
          {
            unsigned __int8 v15 = (unsigned __int8 *)v13;
            unsigned __int8 v16 = a3 + 48;
            unsigned __int8 v17 = a3 + 55;
            unsigned __int8 v18 = a3 + 87;
            if (a3 > 10)
            {
              unsigned __int8 v16 = 58;
            }

            else
            {
              unsigned __int8 v18 = 97;
              unsigned __int8 v17 = 65;
            }

            if (v13)
            {
              unint64_t v19 = 0LL;
              do
              {
                unsigned int v20 = *v15;
                if (v20 < 0x30 || v20 >= v16)
                {
                  if (v20 < 0x41 || v20 >= v17)
                  {
                    unint64_t result = 0LL;
                    char v8 = 1;
                    if (v20 < 0x61 || v20 >= v18) {
                      goto LABEL_118;
                    }
                    char v21 = -87;
                  }

                  else
                  {
                    char v21 = -55;
                  }
                }

                else
                {
                  char v21 = -48;
                }

                unint64_t result = 0LL;
                unsigned __int8 v23 = v20 + v21;
                BOOL v24 = !is_mul_ok(v19, a3);
                unint64_t v25 = v19 * a3;
                BOOL v26 = v25 >= v23;
                unint64_t v19 = v25 - v23;
                char v27 = !v26;
                char v8 = 1;
                if (v24) {
                  break;
                }
                if ((v27 & 1) != 0) {
                  break;
                }
                char v8 = 0;
                ++v15;
                unint64_t result = v19;
                --v14;
              }

              while (v14);
              goto LABEL_118;
            }

            goto LABEL_117;
          }

{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  char v24;
  unint64_t result;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  unint64_t v29;
  BOOL v30;
  BOOL v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unsigned int v48;
  char v49;
  BOOL v50;
  BOOL v51;
  BOOL v52;
  unint64_t v53;
  BOOL v54;
  BOOL v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int8 *v63;
  unsigned __int8 v64;
  unsigned __int8 v65;
  unsigned __int8 v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unsigned __int8 v73;
  unsigned __int8 v74;
  unsigned __int8 v75;
  unint64_t v76;
  unsigned int v77;
  char v78;
  BOOL v79;
  BOOL v80;
  BOOL v81;
  unint64_t v82;
  BOOL v83;
  BOOL v84;
  unint64_t v85;
  BOOL v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unsigned __int8 *v94;
  unsigned __int8 v95;
  unsigned __int8 v96;
  unsigned __int8 v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unsigned __int8 v103;
  unsigned __int8 v104;
  unsigned __int8 v105;
  unint64_t v106;
  unsigned __int8 *v107;
  unsigned int v108;
  char v109;
  BOOL v110;
  BOOL v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  BOOL v115;
  unint64_t v116;
  int v117;
  unsigned int v118;
  char v119;
  BOOL v120;
  BOOL v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  BOOL v125;
  unint64_t v126;
  int v127;
  unsigned int v128;
  char v129;
  BOOL v130;
  BOOL v131;
  BOOL v132;
  unint64_t v133;
  BOOL v134;
  BOOL v135;
  unint64_t v136;
  int v137;
  uint64_t v138;
  void v139[2];
  char v140;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = 0LL;
    unint64_t v140 = 0;
    goto LABEL_249;
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0)
      {
LABEL_5:
        int v7 = *v5;
        if (v7 != 43)
        {
          if (v7 != 45)
          {
            unint64_t v71 = 0LL;
            char v72 = 0LL;
            uint64_t v73 = a3 + 48;
            uint64_t v74 = a3 + 55;
            uint64_t v75 = a3 + 87;
            if (a3 > 10)
            {
              uint64_t v73 = 58;
            }

            else
            {
              uint64_t v75 = 97;
              uint64_t v74 = 65;
            }

            uint64_t v76 = a3 >> 63;
            while (1)
            {
              uint64_t v77 = *v5;
              if (v77 < 0x30 || v77 >= v73)
              {
                if (v77 < 0x41 || v77 >= v74)
                {
                  unint64_t result = 0LL;
                  char v8 = 1;
                  if (v77 < 0x61 || v77 >= v75) {
                    goto LABEL_248;
                  }
                  uint64_t v78 = -87;
                }

                else
                {
                  uint64_t v78 = -55;
                }
              }

              else
              {
                uint64_t v78 = -48;
              }

              unint64_t result = 0LL;
              char v79 = !is_mul_ok(v72, a3);
              unsigned __int8 v80 = !is_mul_ok(v71, v76);
              unsigned __int8 v81 = __CFADD__(v72 * a3, v71 * v76);
              unsigned __int8 v82 = (a3 * __PAIR128__(v72, v71)) >> 64;
              unint64_t v83 = __CFADD__(v72 * a3 + v71 * v76, (v71 * (unsigned __int128)(unint64_t)a3) >> 64);
              unsigned int v84 = a3 >= 0 || v72 == 0;
              char v8 = 1;
              if (!v84 || v79 || v80 || v81) {
                goto LABEL_248;
              }
              char v85 = v71 * a3;
              unsigned __int8 v86 = __CFADD__(v85, (v77 + v78));
              unint64_t v71 = v85 + (v77 + v78);
              BOOL v87 = v86;
              if (v82 == -1LL)
              {
                if (((v87 | v83) & 1) != 0) {
                  goto LABEL_244;
                }
                char v72 = -1LL;
              }

              else if (v87)
              {
                if (v83) {
                  goto LABEL_244;
                }
                char v72 = v82 + 1;
              }

              else
              {
                char v72 = v82;
                if (v83) {
                  goto LABEL_244;
                }
              }

              ++v5;
              if (!--v6)
              {
                char v8 = 0;
                unint64_t result = v71;
                goto LABEL_248;
              }
            }
          }

          char v8 = 1;
          uint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
          uint64_t v13 = specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
          if (v14)
          {
            unsigned __int8 v15 = (unsigned __int8 *)v13;
            unsigned __int8 v16 = a3 + 48;
            unsigned __int8 v17 = a3 + 55;
            unsigned __int8 v18 = a3 + 87;
            if (a3 > 10)
            {
              unsigned __int8 v16 = 58;
            }

            else
            {
              unsigned __int8 v18 = 97;
              unsigned __int8 v17 = 65;
            }

            if (v13)
            {
              unint64_t v19 = v14;
              unsigned int v20 = 0LL;
              char v21 = 0LL;
              unsigned __int8 v22 = a3 >> 63;
              while (1)
              {
                unsigned __int8 v23 = *v15;
                if (v23 < 0x30 || v23 >= v16)
                {
                  if (v23 < 0x41 || v23 >= v17)
                  {
                    unint64_t result = 0LL;
                    char v8 = 1;
                    if (v23 < 0x61 || v23 >= v18) {
                      goto LABEL_248;
                    }
                    BOOL v24 = -87;
                  }

                  else
                  {
                    BOOL v24 = -55;
                  }
                }

                else
                {
                  BOOL v24 = -48;
                }

                unint64_t result = 0LL;
                BOOL v26 = !is_mul_ok(v21, a3);
                char v27 = !is_mul_ok(v20, v22);
                uint64_t v28 = __CFADD__(v21 * a3, v20 * v22);
                uint64_t v29 = (a3 * __PAIR128__(v21, v20)) >> 64;
                uint64_t v30 = __CFADD__(v21 * a3 + v20 * v22, (v20 * (unsigned __int128)(unint64_t)a3) >> 64);
                uint64_t v31 = a3 >= 0 || v21 == 0;
                char v8 = 1;
                if (!v31 || v26 || v27 || v28) {
                  goto LABEL_248;
                }
                uint64_t v32 = v20 * a3;
                unint64_t result = v32 - (v23 + v24);
                if (v29) {
                  goto LABEL_40;
                }
                if (v30) {
                  goto LABEL_85;
                }
LABEL_41:
                char v8 = 0;
                ++v15;
                unsigned int v20 = v32 - (v23 + v24);
                char v21 = v29;
                if (!--v19) {
                  goto LABEL_248;
                }
              }

              if (!v29) {
                goto LABEL_244;
              }
              --v29;
LABEL_40:
              if (v30) {
                goto LABEL_244;
              }
              goto LABEL_41;
            }

            goto LABEL_136;
          }

Swift::UInt64 specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:)( uint64_t a1, unint64_t a2, Swift::_Int128 by)
{
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    v22.partialValue.uint64_t low = 0LL;
    char v103 = 0;
    goto LABEL_194;
  }

  uint64_t low = by.low;
  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v5 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
        goto LABEL_5;
      }
    }

    else
    {
      unint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v6 = v100;
      if (v100 > 0)
      {
LABEL_5:
        int v7 = *v5;
        if (v7 != 43)
        {
          if (v7 != 45)
          {
            int v57 = low + 87;
            if (low <= 10) {
              int v57 = 97;
            }
            int v104 = v57;
            if (low <= 10) {
              unsigned __int8 v58 = 65;
            }
            else {
              unsigned __int8 v58 = low + 55;
            }
            if (low <= 10) {
              unsigned __int8 v59 = low + 48;
            }
            else {
              unsigned __int8 v59 = 58;
            }
            while (1)
            {
              unsigned int v60 = *v5;
              if (v60 < 0x30 || v60 >= v59)
              {
                if (v60 < 0x41 || v60 >= v58)
                {
                  v22.partialValue.uint64_t low = 0LL;
                  char v8 = 1;
                  char v61 = -87;
                }

                else
                {
                  char v61 = -55;
                }
              }

              else
              {
                char v61 = -48;
              }

              unsigned __int8 v62 = v60 + v61;
              v63.uint64_t low = low;
              v63.high = low >> 63;
              Swift::tuple_partialValue__Int128_overflow_Bool v22 = _Int128.multipliedReportingOverflow(by:)(v63);
              int v64 = *(_DWORD *)&v22.overflow;
              *(void *)&v22.overfuint64_t low = v22.partialValue.low + v62;
              BOOL v66 = __CFADD__(v22.partialValue.low, v62);
              if (v22.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
              {
                if (((v66 | v64) & 1) != 0) {
                  goto LABEL_191;
                }
              }

              else if (v66)
              {
                if ((v64 & 1) != 0) {
                  goto LABEL_191;
                }
              }

              else if ((v64 & 1) != 0)
              {
                goto LABEL_191;
              }

              ++v5;
              if (!--v6) {
                goto LABEL_192;
              }
            }
          }

          char v8 = 1;
          uint64_t v9 = specialized Collection.subscript.getter(1LL, (uint64_t)v5, v6);
          uint64_t v13 = specialized UnsafeBufferPointer.init(rebasing:)(v9, v10, v11, v12);
          if (v14)
          {
            unsigned __int8 v15 = (unsigned __int8 *)v13;
            if (low <= 10) {
              unsigned __int8 v16 = 97;
            }
            else {
              unsigned __int8 v16 = low + 87;
            }
            if (low <= 10) {
              unsigned __int8 v17 = 65;
            }
            else {
              unsigned __int8 v17 = low + 55;
            }
            if (low <= 10) {
              unsigned __int8 v18 = low + 48;
            }
            else {
              unsigned __int8 v18 = 58;
            }
            if (v13)
            {
              uint64_t v19 = v14;
              do
              {
                unsigned int v20 = *v15;
                if (v20 < 0x30 || v20 >= v18)
                {
                  if (v20 < 0x41 || v20 >= v17)
                  {
                    v22.partialValue.uint64_t low = 0LL;
                    char v8 = 1;
                    if (v20 < 0x61 || v20 >= v16) {
                      goto LABEL_193;
                    }
                    char v21 = -87;
                  }

                  else
                  {
                    char v21 = -55;
                  }
                }

                else
                {
                  char v21 = -48;
                }

                unsigned __int8 v23 = v20 + v21;
                v24.uint64_t low = low;
                v24.high = low >> 63;
                Swift::tuple_partialValue__Int128_overflow_Bool v22 = _Int128.multipliedReportingOverflow(by:)(v24);
                BOOL v26 = v22.partialValue.low >= v23;
                v22.partialValue.low -= v23;
                int v27 = !v26;
                if (v22.partialValue.high == 0x8000000000000000LL)
                {
                  if (((*(_DWORD *)&v22.overflow | v27) & 1) != 0) {
                    goto LABEL_191;
                  }
                }

                else if (v22.overflow)
                {
                  goto LABEL_191;
                }

                char v8 = 0;
                ++v15;
                --v19;
              }

              while (v19);
              goto LABEL_193;
            }

            goto LABEL_120;
          }

uint64_t String.UTF8View.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(void *, uint64_t)@<X0>, uint64_t a2@<X2>, unint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if ((a3 & 0x1000000000000000LL) != 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))( a5,  1LL,  1LL,  a4);
  }
  if ((a3 & 0x2000000000000000LL) != 0)
  {
    uint64_t v10 = HIBYTE(a3) & 0xF;
    v12[0] = a2;
    v12[1] = a3 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v9 = v12;
  }

  else if ((a2 & 0x1000000000000000LL) != 0)
  {
    uint64_t v9 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v10 = a2 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v9 = _StringObject.sharedUTF8.getter(a2, a3);
  }

  uint64_t result = a1(v9, v10);
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))(a5, 0LL, 1LL, a4);
  }
  return result;
}

uint64_t String.UTF8View.debugDescription.getter(uint64_t a1, unint64_t x1_0)
{
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(12LL);
  unint64_t v5 = (unint64_t)v4;
  v261._uint64_t countAndFlagsBits = v3;
  v261._unint64_t object = v4;
  Swift::String v8 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UTF8View(", 9uLL, 1);
  uint64_t v9 = HIBYTE(v5) & 0xF;
  uint64_t v10 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000LL) != 0) {
    uint64_t v11 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v11 = v3 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v251 = x1_0;
  if (v11 || (v3 & ~v5 & 0x2000000000000000LL) != 0)
  {
    uint64_t v12 = (uint64_t)v8._object & 0x2000000000000000LL;
    unint64_t v13 = ((unint64_t)v8._object >> 56) & 0xF;
    if ((v5 & 0x2000000000000000LL) != 0 && v12)
    {
      unint64_t v14 = v13 + v9;
      if (v13 + v9 <= 0xF)
      {
        if (v13)
        {
          char v66 = 0;
          unint64_t v67 = 0LL;
          unint64_t v68 = v5;
          x1_0 = v251;
          uint64_t v27 = a1;
          do
          {
            unint64_t v69 = v9 + v67;
            unint64_t v70 = v67 + 1;
            if (v67 >= 8) {
              unint64_t object = (unint64_t)v8._object;
            }
            else {
              unint64_t object = v8._countAndFlagsBits;
            }
            unint64_t v72 = object >> (v66 & 0x38);
            char v73 = (8 * v9 + v66) & 0x38;
            uint64_t v74 = (-255LL << v73) - 1;
            unint64_t v75 = (unint64_t)v72 << v73;
            unint64_t v76 = v75 | v74 & v68;
            unint64_t v77 = v75 | v74 & v3;
            if (v69 < 8) {
              unint64_t v3 = v77;
            }
            else {
              unint64_t v68 = v76;
            }
            v66 += 8;
            unint64_t v67 = v70;
          }

          while (v13 != v70);
        }

        else
        {
          unint64_t v68 = v5;
          x1_0 = v251;
          uint64_t v27 = a1;
        }

        swift_bridgeObjectRelease(v5);
        swift_bridgeObjectRelease((uint64_t)v8._object);
        unint64_t v83 = 0xA000000000000000LL;
        if (!(v3 & 0x8080808080808080LL | v68 & 0x80808080808080LL)) {
          unint64_t v83 = 0xE000000000000000LL;
        }
        unsigned __int8 v65 = (void *)(v83 & 0xFF00000000000000LL | (v14 << 56) | v68 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_88;
      }

      uint64_t v12 = 1LL;
    }

    if (v12) {
      int64_t v15 = ((unint64_t)v8._object >> 56) & 0xF;
    }
    else {
      int64_t v15 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v8._object, 2LL, v6, v7);
    uint64_t v254 = v15;
    if (((uint64_t)v8._object & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v8._object, 5LL, v16, v17);
      v235._Swift::UInt64 rawBits = 1LL;
      v236._Swift::UInt64 rawBits = (v15 << 16) | 1;
      v237._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v235,  v236,  v8._countAndFlagsBits,  (unint64_t)v8._object);
      if (v237._rawBits < 0x10000) {
        v237._rawBits |= 3;
      }
      int64_t v15 = specialized Collection.count.getter(v237, v238, v8._countAndFlagsBits, (unint64_t)v8._object);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      if ((v5 & 0x1000000000000000LL) == 0)
      {
LABEL_15:
        BOOL v18 = __OFADD__(v11, v15);
        Swift::Int v19 = v11 + v15;
        if (!v18)
        {
LABEL_16:
          unint64_t v20 = v3 & ~v5;
          if ((v20 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
            if ((v22 & 1) != 0)
            {
LABEL_286:
              unint64_t v243 = 258LL;
              goto LABEL_287;
            }

            if (v19 > 15) {
              goto LABEL_24;
            }
            if ((v5 & 0x2000000000000000LL) == 0)
            {
              if (v21 < v15)
              {
LABEL_46:
                swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
                if ((v5 & 0x1000000000000000LL) == 0)
                {
                  if ((v3 & 0x1000000000000000LL) != 0)
                  {
                    unsigned int v40 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  }

                  else
                  {
                    unsigned int v40 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v5);
                    uint64_t v10 = v37;
                  }

                  x1_0 = v251;
                  uint64_t v41 = v254;
                  swift_bridgeObjectRetain(v5, v37, v38, v39);
                  closure #1 in _StringGuts._convertedToSmall()(v40, v10, &v260);
                  swift_bridgeObjectRelease(v5);
                  unint64_t v3 = v260;
                  unint64_t v42 = *((void *)&v260 + 1);
                  goto LABEL_53;
                }

                goto LABEL_289;
              }

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance String.UTF8View()
{
  return String.UTF8View.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

void key path setter for String.utf16 : String(uint64_t *a1, void *a2, uint64_t a3, char *a4)
{
  uint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  uint64_t v7 = a2[1];
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  *a2 = v6;
  a2[1] = v5;
}

uint64_t (*String.utf8.modify(void *a1, uint64_t a2, uint64_t a3, char *a4))()
{
  a1[2] = v4;
  unint64_t v6 = v4[1];
  *a1 = *v4;
  a1[1] = v6;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  return String.utf16.modify;
}

void String.utf16.modify(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = a1[1];
  unint64_t v5 = (void *)a1[2];
  uint64_t v6 = *a1;
  uint64_t v7 = v5[1];
  if ((a2 & 1) != 0)
  {
    swift_bridgeObjectRetain(a1[1], a2, a3, a4);
    swift_bridgeObjectRelease(v7);
    *unint64_t v5 = v6;
    v5[1] = v4;
    swift_bridgeObjectRelease(v4);
  }

  else
  {
    swift_bridgeObjectRelease(v5[1]);
    *unint64_t v5 = v6;
    v5[1] = v4;
  }

__objc2_class **String._slowUTF8CString()(unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    unint64_t v6 = HIBYTE(a2) & 0xF;
  }
  else {
    unint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
  }
  char v24 = &_swiftEmptyArrayStorage;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, v6 + 1, 0);
  uint64_t v7 = &_swiftEmptyArrayStorage;
  if (v6)
  {
    uint64_t v8 = (a1 >> 59) & 1;
    if ((a2 & 0x1000000000000000LL) == 0) {
      LOBYTE(v8) = 1;
    }
    uint64_t v9 = 4LL << v8;
    Swift::UInt64 v10 = 15LL;
    do
    {
      Swift::UInt64 v11 = v10 & 0xC;
      Swift::UInt64 rawBits = v10;
      if (v11 == v9) {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v10)._rawBits;
      }
      Swift::UInt64 v13 = rawBits >> 16;
      if (rawBits >> 16 >= v6)
      {
        unint64_t v22 = 228LL;
        goto LABEL_34;
      }

      if ((a2 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt8 v15 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        if (v11 != v9) {
          goto LABEL_18;
        }
      }

      else if ((a2 & 0x2000000000000000LL) != 0)
      {
        v23[0] = a1;
        v23[1] = a2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt8 v15 = *((_BYTE *)v23 + v13);
        if (v11 != v9) {
          goto LABEL_18;
        }
      }

      else
      {
        unint64_t v14 = (_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a1 & 0x1000000000000000LL) == 0) {
          unint64_t v14 = _StringObject.sharedUTF8.getter(a1, a2);
        }
        Swift::UInt8 v15 = v14[v13];
        if (v11 != v9)
        {
LABEL_18:
          if ((a2 & 0x1000000000000000LL) == 0) {
            goto LABEL_19;
          }
          goto LABEL_22;
        }
      }

      Swift::UInt64 v10 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v10)._rawBits;
      if ((a2 & 0x1000000000000000LL) == 0)
      {
LABEL_19:
        Swift::UInt64 v10 = (v10 & 0xFFFFFFFFFFFF0000LL) + 65540;
        goto LABEL_24;
      }

Swift::Int __swiftcall String.UTF8View._foreignCount()()
{
  uint64_t v2 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = v0;
  }
  uint64_t v3 = 7LL;
  if (((v1 >> 60) & ((v0 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v3 = 11LL;
  }
  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)(v3 | (v2 << 16)));
}

BOOL String.Index._foreignIsWithin(_:)(int a1, int a2, Swift::String::Index a3)
{
  Swift::UInt64 rawBits = a3._rawBits;
  if ((a3._rawBits & 0xC001) == 0) {
    Swift::UInt64 rawBits = a3._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a3)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
  }
  return (rawBits ^ a3._rawBits) < 0x4000;
}

uint64_t String.UTF8View.customMirror.getter@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  a1,  a2,  8,  0LL,  0LL,  a5);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return protocol witness for CustomReflectable.customMirror.getter in conformance String.UnicodeScalarView( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void))specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:),  a4);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void), char *a4)
{
  uint64_t v6 = *v4;
  uint64_t v5 = v4[1];
  swift_bridgeObjectRetain_n(v5, 2LL, (uint64_t)a3, a4);
  return a3(v6, v5, v6, v5, 8LL, 0LL, 0LL);
}

uint64_t Substring.UTF8View.init(_:_bounds:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

Swift::tuple_Unicode_Scalar_scalarLength_Int __swiftcall _StringGuts.foreignErrorCorrectedScalar(endingAt:)( Swift::String::Index endingAt)
{
  Swift::UInt64 v3 = endingAt._rawBits >> 16;
  uint64_t v4 = (void *)(v1 & 0xFFFFFFFFFFFFFFFLL);
  unsigned int v5 = objc_msgSend((id)(v1 & 0xFFFFFFFFFFFFFFFLL), sel_characterAtIndex_, (endingAt._rawBits >> 16) - 1);
  if ((v5 & 0xFC00) != 0xD800)
  {
    int v6 = v5;
    if ((v5 & 0xFC00) != 0xDC00) {
      goto LABEL_4;
    }
    if (endingAt._rawBits >= 0x20000)
    {
      unsigned __int16 v9 = (unsigned __int16)objc_msgSend(v4, sel_characterAtIndex_, v3 - 2);
      if ((v9 & 0xFC00) == 0xD800)
      {
        int v6 = (v6 & 0x3FF | ((v9 & 0x3FF) << 10)) + 0x10000;
        Swift::Int v7 = 2LL;
        goto LABEL_5;
      }
    }
  }

  int v6 = 65533;
LABEL_4:
  Swift::Int v7 = 1LL;
LABEL_5:
  Swift::UInt32 v8 = v6;
  result.Swift::Int scalarLength = v7;
  result._0._unsigned int value = v8;
  return result;
}

Swift::_ValidUTF8Buffer::Index __swiftcall _ValidUTF8Buffer.index(_:offsetBy:)( Swift::_ValidUTF8Buffer::Index _, Swift::Int offsetBy)
{
  if (v2)
  {
    if (_._biasedBits)
    {
      unsigned int v3 = v2;
      while (v3 != _._biasedBits)
      {
        BOOL v4 = v3 >= 0x100;
        v3 >>= 8;
        if (!v4) {
          goto LABEL_6;
        }
      }
    }
  }

  else if (_._biasedBits)
  {
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x83uLL,  0);
  }

  unint64_t v5 = __clz(v2);
  uint64_t v6 = __clz(_._biasedBits);
  BOOL v7 = __OFADD__(offsetBy, (uint64_t)(v5 - v6) >> 3);
  unint64_t v8 = offsetBy + ((uint64_t)(v5 - v6) >> 3);
  if (v7)
  {
    __break(1u);
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x8EuLL,  0);
  }

  if ((v8 & 0x8000000000000000LL) != 0) {
    goto LABEL_14;
  }
  if (4 - (v5 >> 3) < v8) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x8FuLL,  0);
  }
  return (Swift::_ValidUTF8Buffer::Index)(v2 >> (4 * (v8 & 7)) >> (4 * (v8 & 7)));
}

uint64_t _ValidUTF8Buffer.subscript.getter(int a1)
{
  return (a1 - 1);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance UTF8ValidationResult( uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(void *)a1 == *(void *)a2 && *(void *)(a1 + 8) == *(void *)(a2 + 8);
  if ((*(_BYTE *)(a2 + 16) & 1) == 0) {
    BOOL v3 = 0;
  }
  char v4 = ((*(void *)a1 & 1LL) == 0) ^ *(void *)a2;
  if ((*(_BYTE *)(a2 + 16) & 1) != 0) {
    char v4 = 0;
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0) {
    char v4 = v3;
  }
  return v4 & 1;
}

uint64_t protocol witness for Error._domain.getter in conformance UTF8ValidationError(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError( a1,  a2,  &demangling cache variable for type metadata for UTF8ValidationError.Type);
}

uint64_t UnsafeBufferPointer.startIndex.getter()
{
  return 0LL;
}

uint64_t UInt16.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1) >> 16;
}

BOOL static UInt16.<= infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a2 >= a1;
}

uint64_t _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = specialized Collection.dropFirst(_:)(2LL, a1, a2);
  __int16 v12 = specialized Collection.first.getter(v8, v9, v10, v11);
  uint64_t v13 = specialized Collection.dropFirst(_:)(1LL, a1, a2);
  __int16 v17 = specialized Collection.first.getter(v13, v14, v15, v16);
  __int16 v18 = specialized Collection.first.getter(a1, a2, a3, a4);
  if ((v18 & 0x100) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringUTF8Validation.swift",  32LL,  2,  0x5FuLL,  0);
  }
  __int16 v19 = v12 << 8;
  if ((v12 & 0x100) != 0) {
    __int16 v19 = 0;
  }
  int v20 = v19 & 0xFF00;
  int v21 = (v19 & 0xFF00 | v17) << 8;
  if ((v17 & 0x100) != 0) {
    int v21 = v20;
  }
  if ((v21 & 0xC000 | v18 & 0xF0) == 0x80E0)
  {
    if ((v21 & 0x2000 | v18 & 0xF) == 0x200D || (v21 & 0x2000 | v18 & 0xF) == 0) {
      uint64_t v23 = 1LL;
    }
    else {
      uint64_t v23 = 2LL;
    }
  }

  else if ((v21 & 0xC000 | v18 & 0xF8) == 0x80F0)
  {
    uint64_t v23 = 1LL;
    if (v21 & 0x3000 | v18 & 7 && __rev16(v21 & 0x3000 | v18 & 7) <= 0x400)
    {
      if ((v21 & 0xC00000) == 0x800000) {
        uint64_t v23 = 3LL;
      }
      else {
        uint64_t v23 = 2LL;
      }
    }
  }

  else
  {
    uint64_t v23 = 1LL;
  }

  if (__OFADD__(a1, v23))
  {
    __break(1u);
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (a1 + v23 < a1) {
    goto LABEL_24;
  }
  return a1;
}

uint64_t findInvalidRange #1 (_:) in validateUTF8(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1;
  if (a1 != a2)
  {
    specialized Slice.subscript.getter(a1, a1, a2, a3, a4);
    uint64_t v8 = a1 + 1;
    if (__OFADD__(a1, 1LL)) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x5F5uLL,  0);
    }
  }

  uint64_t v9 = 0LL;
  uint64_t v10 = a2 + a1 - v8;
  if (v8 <= a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = v8;
  }
  if (v8 <= a4) {
    uint64_t v12 = a4;
  }
  else {
    uint64_t v12 = v8;
  }
  uint64_t v13 = v12 - v8;
  uint64_t v14 = v11 - v8;
  while (a2 - v8 != v9)
  {
    if (v8 < a1) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x714uLL,  0);
    }
    if (v14 == v9) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x715uLL,  0);
    }
    if (v8 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
    }
    if (v13 == v9) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
    }
    if ((*(_BYTE *)(a3 + v8 + v9) & 0xC0) != 0x80) {
      goto LABEL_19;
    }
    uint64_t v15 = a1 + v9++;
    if (__OFADD__(v15, 1LL))
    {
      __break(1u);
LABEL_19:
      uint64_t v10 = a1 + v9;
      break;
    }
  }

  if (v10 < a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
  }
  uint64_t v16 = v10 + 1;
  if (__OFADD__(v10, 1LL))
  {
    __break(1u);
LABEL_30:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x71CuLL,  0);
  }

  if (v16 > a2) {
    goto LABEL_30;
  }
  return _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(a1, v16, a3, a4);
}

Swift::Int __swiftcall _StringGuts.previousWordIndex(endingAt:)(Swift::Int endingAt)
{
  unint64_t v4 = v2;
  uint64_t v5 = v1;
  if ((v2 & 0x1000000000000000LL) != 0) {
    return _StringGuts._foreignPreviousWordIndex(endingAt:)(endingAt);
  }
  if ((v2 & 0x2000000000000000LL) != 0)
  {
    v14[0] = v1;
    v14[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain(v2, v1, v2, v3);
    uint64_t v11 = v14;
    Swift::Int v8 = endingAt;
    uint64_t v9 = v5;
    uint64_t v10 = v4;
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0) {
      BOOL v7 = (void *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      BOOL v7 = _StringObject.sharedUTF8.getter(v1, v2);
    }
    swift_bridgeObjectRetain(v4, v1, v2, v3);
    Swift::Int v8 = endingAt;
    uint64_t v9 = v5;
    uint64_t v10 = v4;
    uint64_t v11 = v7;
  }

  Swift::Int v12 = specialized _StringGuts.previousWordBoundary(endingAt:previousScalar:)(v8, v9, v10, (uint64_t)v11);
  swift_bridgeObjectRelease(v4);
  return v12;
}

Swift::Int __swiftcall _StringGuts.nextWordIndex(startingAt:)(Swift::Int startingAt)
{
  unint64_t v4 = v2;
  uint64_t v5 = v1;
  if ((v2 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain(v2, v1, v2, v3);
    Swift::Int v10 = specialized _StringGuts.nextWordBoundary(startingAt:nextScalar:)(startingAt, v5, v4, v5, v4);
    swift_bridgeObjectRelease(v4);
    return v10;
  }

  else if ((v2 & 0x2000000000000000LL) != 0)
  {
    v12[0] = v1;
    v12[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    return specialized _StringGuts.nextWordBoundary(startingAt:nextScalar:)( startingAt,  v1,  v2,  (uint64_t)v12,  HIBYTE(v2) & 0xF);
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0)
    {
      id v7 = (id)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v8 = v1 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      id v7 = _StringObject.sharedUTF8.getter(v1, v2);
      uint64_t v8 = v11;
    }

    return specialized _StringGuts.nextWordBoundary(startingAt:nextScalar:)(startingAt, v5, v4, (uint64_t)v7, v8);
  }

uint64_t specialized _StringGuts.nextWordBoundary(startingAt:nextScalar:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000LL) == 0) {
    uint64_t v5 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringWordBreaking.swift",  30LL,  2,  0x9AuLL,  0);
  }
  if (a1 >= a5) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringWordBreaking.swift",  30LL,  2,  0x9CuLL,  0);
  }
  unsigned int v9 = _decodeScalar(_:startingAt:)(a4, a2, a1);
  uint64_t v11 = v10 + a1;
  if (v11 >= a5) {
    return v11;
  }
  unsigned int v12 = v9;
  int v31 = 0;
  uint64_t v13 = 0LL;
  unint64_t v32 = 0LL;
  char v33 = 0;
  int v14 = 18;
  char v15 = 1;
  do
  {
    unsigned int v16 = v12;
    unsigned int v17 = _decodeScalar(_:startingAt:)(a4, v10, v11);
    unsigned int v12 = v17;
    uint64_t v18 = v10;
    if (v16 == 13 && v17 == 10) {
      goto LABEL_8;
    }
    if (v16 - 10 < 4 || v16 == 133 || v16 - 8234 >= 0xFFFFFFFE) {
      break;
    }
    switch(v16)
    {
      case 0x200Du:
        if (v17 >= 0xA)
        {
          if (v17 < 0xE || v17 == 133) {
            goto LABEL_258;
          }
          if (v17 >> 3 >= 0x405)
          {
            if (v17 < 0x202A) {
              goto LABEL_258;
            }
            int v20 = 17;
            if (v17 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v19) = 17;
              goto LABEL_65;
            }

            goto LABEL_206;
          }
        }

        int v19 = 17;
        break;
      case 0x27u:
        if (v17 >= 0xA)
        {
          if (v17 < 0xE || v17 == 133) {
            goto LABEL_258;
          }
          if (v17 >> 3 >= 0x405)
          {
            if (v17 < 0x202A) {
              goto LABEL_258;
            }
            int v20 = 15;
            if (v17 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v19) = 15;
              goto LABEL_65;
            }

            goto LABEL_206;
          }
        }

        int v19 = 15;
        break;
      case 0x22u:
        if (v17 >= 0xA)
        {
          if (v17 < 0xE || v17 == 133) {
            goto LABEL_258;
          }
          if (v17 >> 3 >= 0x405)
          {
            if (v17 < 0x202A) {
              goto LABEL_258;
            }
            int v20 = 2;
            if (v17 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v19) = 2;
              goto LABEL_65;
            }

            goto LABEL_206;
          }
        }

        int v19 = 2;
        break;
      default:
        if (v16 - 127488 < 0xFFFFFFE6)
        {
          switch(_swift_stdlib_getWordBreakProperty(v16))
          {
            case 0u:
              if (v12 < 0xA) {
                goto LABEL_43;
              }
              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 < 0x405)
              {
LABEL_43:
                int v19 = 3;
                goto LABEL_32;
              }

              if (v12 < 0x202A) {
                goto LABEL_258;
              }
              int v20 = 3;
              if (v12 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_206;
              }
              LOBYTE(v19) = 3;
              goto LABEL_65;
            case 1u:
              if (v12 < 0xA) {
                goto LABEL_87;
              }
              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 < 0x405)
              {
LABEL_87:
                int v19 = 6;
                goto LABEL_32;
              }

              if (v12 < 0x202A) {
                goto LABEL_258;
              }
              int v20 = 6;
              if (v12 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_206;
              }
              LOBYTE(v19) = 6;
              goto LABEL_65;
            case 2u:
              if (v12 < 0xA) {
                goto LABEL_92;
              }
              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 < 0x405)
              {
LABEL_92:
                int v19 = 8;
                goto LABEL_32;
              }

              if (v12 < 0x202A) {
                goto LABEL_258;
              }
              int v20 = 8;
              if (v12 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_206;
              }
              LOBYTE(v19) = 8;
              goto LABEL_65;
            case 3u:
              if (v12 < 0xA) {
                goto LABEL_97;
              }
              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 < 0x405)
              {
LABEL_97:
                int v19 = 7;
                goto LABEL_32;
              }

              if (v12 < 0x202A) {
                goto LABEL_258;
              }
              int v20 = 7;
              if (v12 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_206;
              }
              LOBYTE(v19) = 7;
              goto LABEL_65;
            case 4u:
              if (v12 < 0xA) {
                goto LABEL_102;
              }
              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 < 0x405)
              {
LABEL_102:
                int v20 = 0;
                LOBYTE(v19) = 0;
                goto LABEL_33;
              }

              if (v12 < 0x202A) {
                goto LABEL_258;
              }
              if (v12 - 127488 < 0xFFFFFFE6)
              {
                int v20 = 0;
                LOBYTE(v19) = 0;
                goto LABEL_65;
              }

              int v25 = 0;
              char v21 = 0;
              char v22 = 0;
              int v20 = 0;
              goto LABEL_207;
            case 5u:
              if (v12 < 0xA) {
                goto LABEL_107;
              }
              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 < 0x405)
              {
LABEL_107:
                int v19 = 11;
                goto LABEL_32;
              }

              if (v12 < 0x202A) {
                goto LABEL_258;
              }
              int v20 = 11;
              if (v12 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_206;
              }
              LOBYTE(v19) = 11;
              goto LABEL_65;
            case 6u:
              if (v12 < 0xA) {
                goto LABEL_112;
              }
              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 < 0x405)
              {
LABEL_112:
                int v19 = 9;
                goto LABEL_32;
              }

              if (v12 < 0x202A) {
                goto LABEL_258;
              }
              int v20 = 9;
              if (v12 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_206;
              }
              LOBYTE(v19) = 9;
              goto LABEL_65;
            case 7u:
              if (v12 < 0xA)
              {
                int v19 = 10;
                goto LABEL_32;
              }

              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 > 0x404)
              {
                if (v12 < 0x202A) {
                  goto LABEL_258;
                }
                int v20 = 10;
                if (v12 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_193;
                }
                goto LABEL_206;
              }

              int v20 = 10;
              if (v12 == 34) {
                goto LABEL_36;
              }
              if (v12 != 39)
              {
                if (v12 == 8205) {
                  goto LABEL_67;
                }
LABEL_193:
                LOBYTE(v19) = 10;
                goto LABEL_65;
              }

              goto LABEL_165;
            case 8u:
              if (v12 < 0xA)
              {
                int v19 = 13;
                goto LABEL_32;
              }

              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 > 0x404)
              {
                if (v12 < 0x202A) {
                  goto LABEL_258;
                }
                int v20 = 13;
                if (v12 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_196;
                }
                goto LABEL_206;
              }

              int v20 = 13;
              if (v12 == 34) {
                goto LABEL_36;
              }
              if (v12 != 39)
              {
                if (v12 == 8205) {
                  goto LABEL_67;
                }
LABEL_196:
                LOBYTE(v19) = 13;
                goto LABEL_65;
              }

              goto LABEL_165;
            case 9u:
              if (v12 < 0xA)
              {
                int v19 = 5;
                goto LABEL_32;
              }

              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 > 0x404)
              {
                if (v12 < 0x202A) {
                  goto LABEL_258;
                }
                int v20 = 5;
                if (v12 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_199;
                }
                goto LABEL_206;
              }

              int v20 = 5;
              if (v12 == 34) {
                goto LABEL_36;
              }
              if (v12 != 39)
              {
                if (v12 == 8205) {
                  goto LABEL_67;
                }
LABEL_199:
                LOBYTE(v19) = 5;
                goto LABEL_65;
              }

              goto LABEL_165;
            case 0xAu:
              if (v12 < 0xA)
              {
                int v19 = 16;
                goto LABEL_32;
              }

              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 > 0x404)
              {
                if (v12 < 0x202A) {
                  goto LABEL_258;
                }
                int v20 = 16;
                if (v12 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_202;
                }
                goto LABEL_206;
              }

              int v20 = 16;
              if (v12 == 34) {
                goto LABEL_36;
              }
              if (v12 != 39)
              {
                if (v12 == 8205)
                {
                  int v14 = 16;
                  goto LABEL_8;
                }

LABEL_202:
                LOBYTE(v19) = 16;
                goto LABEL_65;
              }

              goto LABEL_165;
            case 0xBu:
              if (v12 < 0xA)
              {
                int v19 = 4;
                goto LABEL_32;
              }

              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 > 0x404)
              {
                if (v12 < 0x202A) {
                  goto LABEL_258;
                }
                int v20 = 4;
                if (v12 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_205;
                }
                goto LABEL_206;
              }

              int v20 = 4;
              if (v12 == 34) {
                goto LABEL_36;
              }
              if (v12 != 39)
              {
                if (v12 == 8205)
                {
                  int v14 = 4;
                  goto LABEL_8;
                }

              v164 |= v163 << 8;
              while (1)
              {
                *(void *)uint64_t v179 = v164 | 5;
                if (_StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v164 | 5))) {
                  *(void *)uint64_t v179 = v164 | 7;
                }
                char v21 = startingAta + v158;
                if (!__OFADD__(startingAta, v158)) {
                  break;
                }
                __break(1u);
LABEL_221:
                uint64_t v167 = (char *)_StringObject.sharedUTF8.getter(v164, v155);
LABEL_192:
                if (startingAta + 1 == v168) {
                  goto LABEL_201;
                }
                if (!v167) {
                  goto LABEL_214;
                }
                unint64_t v169 = *(unsigned __int16 *)&v167[startingAta];
LABEL_199:
                if (v169 != 2573 && (v169 & 0x80808080) == 0) {
                  goto LABEL_201;
                }
LABEL_218:
                unint64_t v163 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(startingAta);
                uint64_t v164 = startingAta << 16;
                if (v163 <= 63) {
                  goto LABEL_202;
                }
              }

              int v19 = (Swift::String::Index *)v179;
              goto LABEL_141;
            }

              swift_getTypeByMangledName(&v268, 255LL, v67, v69, v70, &v264, &v260);
              uint64_t v112 = v263;
              if (v263 == &v260)
              {
                uint64_t v112 = &v260;
                uint64_t v113 = 4LL;
                a8 = v236;
              }

              else
              {
                a8 = v236;
                if (!v263) {
                  goto LABEL_207;
                }
                uint64_t v113 = 5LL;
              }

              (*(void (**)(void))(*v112 + 8 * v113))();
LABEL_207:
              int64_t v114 = v267;
              if (v267 == &v264)
              {
                int64_t v114 = &v264;
                uint64_t v115 = 4LL;
              }

              else
              {
                if (!v267) {
                  goto LABEL_212;
                }
                uint64_t v115 = 5LL;
              }

              (*(void (**)(void))(*v114 + 8 * v115))();
LABEL_212:
              if ((_WORD)v270)
              {
                if ((unsigned __int16)v270 == 1)
                {
                  uint64_t v116 = (uint64_t)v268;
                  Swift::Int v117 = v269;
                  *(void *)(a9 + 8) = v269;
                  *(void *)a9 = v117(v116, 2LL, 0LL);
                  int64_t v118 = 1;
                  goto LABEL_219;
                }

                if (!v37) {
                  goto LABEL_218;
                }
              }

              else if (v37 == v268)
              {
LABEL_218:
                int64_t v118 = 0;
                *(_BYTE *)a9 = 0;
LABEL_219:
                *(_BYTE *)(a9 + 16) = v118;
                unsigned int v12 = a5;
                if ((unsigned __int16)v270 != 1)
                {
LABEL_350:
LABEL_352:
                  uint64_t v192 = v246;
                  if (v246 == v245)
                  {
                    uint64_t v192 = v245;
                    unint64_t v193 = 4LL;
                  }

                  else
                  {
                    if (!v246)
                    {
LABEL_357:
                      uint64_t v194 = v248;
                      if (v248 != v247) {
                        goto LABEL_389;
                      }
                      uint64_t v194 = v247;
LABEL_392:
                      unint64_t v222 = 4LL;
LABEL_393:
                      (*(void (**)(void))(*v194 + 8 * v222))();
                      goto LABEL_394;
                    }

                    unint64_t v193 = 5LL;
                  }

                  (*(void (**)(void))(*v192 + 8 * v193))();
                  goto LABEL_357;
                }

LABEL_205:
                LOBYTE(v19) = 4;
                goto LABEL_65;
              }

              break;
            default:
              if (v12 < 0xA)
              {
                LOBYTE(v19) = 1;
                int v20 = 1;
                goto LABEL_65;
              }

              if (v12 < 0xE || v12 == 133) {
                goto LABEL_258;
              }
              if (v12 >> 3 > 0x404)
              {
                if (v12 < 0x202A) {
                  goto LABEL_258;
                }
                int v20 = 1;
                if (v12 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_190;
                }
                goto LABEL_206;
              }

              int v20 = 1;
              if (v12 == 34) {
                goto LABEL_36;
              }
              if (v12 != 39)
              {
                if (v12 == 8205)
                {
                  int v14 = 1;
                  goto LABEL_8;
                }

LABEL_190:
                LOBYTE(v19) = 1;
                goto LABEL_65;
              }

              goto LABEL_165;
          }

          goto LABEL_165;
        }

        if (v17 < 0xA)
        {
          LOBYTE(v19) = 14;
          int v20 = 14;
          goto LABEL_65;
        }

        if (v17 < 0xE || v17 == 133) {
          goto LABEL_258;
        }
        if (v17 >> 3 > 0x404)
        {
          if (v17 < 0x202A) {
            goto LABEL_258;
          }
          int v20 = 14;
          if (v17 - 127488 >= 0xFFFFFFE6)
          {
LABEL_206:
            int v25 = 0;
            char v21 = 0;
            char v22 = 0;
LABEL_207:
            unsigned int v23 = 14;
            goto LABEL_208;
          }
        }

        else
        {
          int v20 = 14;
          switch(v17)
          {
            case 0x22u:
LABEL_36:
              char v21 = 0;
              char v22 = 0;
              unsigned int v23 = 2;
              goto LABEL_166;
            case 0x27u:
              goto LABEL_165;
            case 0x200Du:
              int v14 = 14;
              goto LABEL_8;
          }
        }

        LOBYTE(v19) = 14;
        goto LABEL_65;
    }

          char v159 = v117;
          if (v158 >= 2) {
            char v159 = (int8x16_t *)v117->i64[0];
          }
          uint64_t v160 = v159->u64[i];
LABEL_195:
          unint64_t v161 = *(unsigned __int8 *)(v160 + 18);
          unint64_t v162 = v160;
          if (*(_WORD *)(*(void *)v162 + 16LL) == 123)
          {
            if ((v161 - 1) >= 2)
            {
              if (v161 != 5 || !*(_DWORD *)(v160 + 8))
              {
                unint64_t v163 = 0LL;
LABEL_205:
                uint64_t v165 = *((unsigned __int8 *)v163 + 18);
                if ((v165 - 1) >= 2)
                {
                  if (v165 != 5 || !*((_DWORD *)v163 + 2)) {
                    goto LABEL_216;
                  }
                  unint64_t v163 = *(swift::Demangle::__runtime::Node **)v163;
                }

                id v166 = *(swift::Demangle::__runtime::Node **)v163;
                if (*(void *)v163)
                {
                  uint64_t v160 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
                  if (!v160 || v160 + 24 > *((void *)this + 2))
                  {
                    uint64_t v167 = 2LL * *((void *)this + 4);
                    if (v167 <= 0x20) {
                      uint64_t v167 = 32LL;
                    }
                    *((void *)this + 4) = v167;
                    uint64_t v168 = v167 + 8;
                    unint64_t v169 = malloc(v167 + 8);
                    size_t v170 = (char *)v169 + v168;
                    *unint64_t v169 = *((void *)this + 3);
                    uint64_t v160 = ((unint64_t)v169 + 15) & 0xFFFFFFFFFFFFFFF8LL;
                    *((void *)this + 2) = v170;
                    *((void *)this + 3) = v169;
                  }

                  *((void *)this + 1) = v160 + 24;
                  *(_WORD *)(v160 + 16) = 232;
                  *(_BYTE *)(v160 + 18) = 0;
                  swift::Demangle::__runtime::Node::addChild((unsigned int *)v160, v166, this, v115, v116);
                  goto LABEL_217;
                }

uint64_t closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)( uint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((a3 & 0x2000000000000000LL) != 0) {
    uint64_t v4 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v4 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v4 <= a1) {
    return 0LL;
  }
  v8._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    unsigned int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v8._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
    v13._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
    String.UnicodeScalarView._foreignIndex(after:)(v13);
  }

  else
  {
    Swift::UInt64 v10 = v8._rawBits >> 16;
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v14 = a2;
      uint64_t v15 = a3 & 0xFFFFFFFFFFFFFFLL;
      unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)&v14, v9._rawBits, v10);
      _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
      uint64_t v14 = a2;
      uint64_t v15 = a3 & 0xFFFFFFFFFFFFFFLL;
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0) {
        id v11 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        id v11 = _StringObject.sharedUTF8.getter(a2, a3);
      }
      unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v11, v9._rawBits, v10);
      _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
      if ((a2 & 0x1000000000000000LL) == 0) {
        _StringObject.sharedUTF8.getter(a2, a3);
      }
    }
  }

  return value;
}

Swift::Int __swiftcall _StringGuts._foreignPreviousWordIndex(endingAt:)(Swift::Int endingAt)
{
  uint64_t v4 = v2;
  uint64_t v5 = v1;
  swift_bridgeObjectRetain(v2, v1, v2, v3);
  Swift::Int v7 = specialized _StringGuts.previousWordBoundary(endingAt:previousScalar:)(endingAt, v5, v4);
  swift_bridgeObjectRelease(v4);
  return v7;
}

uint64_t _decodeScalar(_:endingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  do
    int v4 = *(_BYTE *)(a1 + a3 - 1 + v3--) & 0xC0;
  while (v4 == 128);
  return _decodeScalar(_:startingAt:)(a1, a2, a3 + v3);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance _WordQuestion( uint64_t *a1, unint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  unint64_t v5 = *a2;
  unint64_t v4 = a2[1];
  if (*((_BYTE *)a1 + 16) == 1)
  {
    if (v3 | v2)
    {
      if (v3 ^ 1 | v2)
      {
        if (*((_BYTE *)a2 + 16) && __PAIR128__(v4, v5) >= 2) {
          return 1LL;
        }
      }

      else if (*((_BYTE *)a2 + 16) && !(v5 ^ 1 | v4))
      {
        return 1LL;
      }

      return 0LL;
    }

    uint64_t v8 = v5 | v4;
    return *((_BYTE *)a2 + 16) && v8 == 0;
  }

  else
  {
    unsigned int v6 = (v3 == v5) & ~*((unsigned __int8 *)a2 + 16);
    if (v2 == v4) {
      return v6;
    }
    else {
      return 0LL;
    }
  }

uint64_t (*Substring._slice.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 Substring.init(_:)(Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, char *a4)
{
  v8._Swift::UInt64 rawBits = a1;
  v9._Swift::UInt64 rawBits = a2;
  Swift::UInt64 v10 = _StringGuts.validateScalarRange(_:)(v8, v9, a3, (unint64_t)a4);
  swift_bridgeObjectRelease((uint64_t)a4);
  return v10;
}

uint64_t specialized Substring.init<A>(_:)()
{
  return 15LL;
}

uint64_t Substring.init<A>(_:)(uint64_t *a1, ValueMetadata *a2, uint64_t a3)
{
  uint64_t Description = a2[-1].Description;
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  Swift::String::Index v9 = (unint64_t *)((char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  unsigned int v12 = (uint64_t *)((char *)&v20 - v11);
  MEMORY[0x1895F8858](v10);
  unsigned int v17 = (uint64_t *)((char *)&v20 - v16);
  if (v13 != &type metadata for String)
  {
    if (a2 == &type metadata for Substring) {
      return *a1;
    }
    if (a2 == (ValueMetadata *)&unk_189B86C40) {
      return specialized Substring.init<A>(_:)(*a1, (uint64_t)v13, v14, v15);
    }
    uint64_t v18 = (void (*)(char *, uint64_t *, ValueMetadata *))Description[2];
    v18((char *)&v20 - v16, a1, a2);
    if ((swift_dynamicCast((char *)&v20, v17, (swift *)a2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
    {
      ((void (*)(uint64_t *, ValueMetadata *))Description[1])(a1, a2);
    }

    else
    {
      v18((char *)v12, a1, a2);
      if ((swift_dynamicCast((char *)&v20, v12, (swift *)a2, (const char *)&type metadata for Substring, 6uLL) & 1) != 0)
      {
        ((void (*)(uint64_t *, ValueMetadata *))Description[1])(a1, a2);
        return v20;
      }

      ((void (*)(unint64_t *, uint64_t *, ValueMetadata *))Description[4])(v9, a1, a2);
      String.init<A>(_:)(v9, (swift *)a2, a3);
    }
  }

  return 15LL;
}

uint64_t Substring.init()()
{
  return 15LL;
}

Swift::String::Index __swiftcall Substring.index(after:)(Swift::String::Index after)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  unint64_t v7 = v2;
  char v8 = v1;
  unint64_t v9 = _StringGuts.validateCharacterIndex(_:in:)(after._rawBits, v1, v2, v3, v4);
  uint64_t v10 = (v9 >> 8) & 0x3F;
  Swift::Int v11 = v9 >> 16;
  uint64_t v12 = v7 >> 16;
  if (!v10)
  {
    if (v11 == v12)
    {
      uint64_t v10 = 0LL;
      goto LABEL_20;
    }

    if ((v5 & 0x1000000000000000LL) != 0) {
      goto LABEL_48;
    }
    if ((v5 & 0x2000000000000000LL) != 0)
    {
      uint64_t v30 = v6;
      uint64_t v31 = v5 & 0xFFFFFFFFFFFFFFLL;
      if (v11 + 1 != (HIBYTE(v5) & 0xF))
      {
        int v16 = *(unsigned __int16 *)((char *)&v30 + v11);
        if (v16 == 2573 || (v16 & 0x80808080) != 0)
        {
LABEL_48:
          uint64_t v10 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v11);
          goto LABEL_20;
        }
      }
    }

    else
    {
      if ((v6 & 0x1000000000000000LL) != 0)
      {
        Swift::String::Index v13 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v14 = v6 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        Swift::String::Index v13 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
      }

      if (v11 + 1 != v14)
      {
        if (!v13) {
          goto LABEL_51;
        }
        int v15 = *(unsigned __int16 *)&v13[v11];
        if (v15 == 2573 || (v15 & 0x80808080) != 0) {
          goto LABEL_48;
        }
      }
    }

    uint64_t v10 = 1LL;
  }

Swift::String::Index __swiftcall Substring._uncheckedIndex(after:)(Swift::String::Index after)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  char v7 = v1;
  Swift::UInt64 v9 = (after._rawBits >> 8) & 0x3F;
  Swift::UInt64 v10 = after._rawBits >> 16;
  int64_t v11 = v2 >> 16;
  if (!v9)
  {
    if (v10 == v11)
    {
      Swift::UInt64 v9 = 0LL;
      goto LABEL_20;
    }

    if ((v4 & 0x1000000000000000LL) != 0) {
      goto LABEL_48;
    }
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      uint64_t v29 = v3;
      uint64_t v30 = v4 & 0xFFFFFFFFFFFFFFLL;
      if (v10 + 1 != (HIBYTE(v4) & 0xF))
      {
        int v15 = *(unsigned __int16 *)((char *)&v29 + v10);
        if (v15 == 2573 || (v15 & 0x80808080) != 0)
        {
LABEL_48:
          Swift::UInt64 v9 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v10);
          goto LABEL_20;
        }
      }
    }

    else
    {
      if ((v3 & 0x1000000000000000LL) != 0)
      {
        uint64_t v12 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v13 = v3 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v12 = (char *)_StringObject.sharedUTF8.getter(v3, v4);
      }

      if (v10 + 1 != v13)
      {
        if (!v12) {
          goto LABEL_51;
        }
        int v14 = *(unsigned __int16 *)&v12[v10];
        if (v14 == 2573 || (v14 & 0x80808080) != 0) {
          goto LABEL_48;
        }
      }
    }

    Swift::UInt64 v9 = 1LL;
  }

Swift::String::Index __swiftcall Substring.index(before:)(Swift::String::Index before)
{
  unint64_t v5 = v1;
  unint64_t v6 = _StringGuts.validateInclusiveCharacterIndex(_:in:)(before._rawBits, v1, v2, v3, v4);
  if (v5 >> 14 >= v6 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/Substring.swift",  21LL,  2,  0x10BuLL,  0);
  }
  return Substring._uncheckedIndex(before:)((Swift::String::Index)v6);
}

Swift::String::Index __swiftcall Substring._uncheckedIndex(before:)(Swift::String::Index before)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  char v7 = v1;
  Swift::UInt64 rawBits = before._rawBits;
  if ((v1 ^ before._rawBits) >= 0x4000)
  {
    uint64_t v10 = _StringGuts._opaqueCharacterStride(endingAt:in:)(before._rawBits >> 16, v1 >> 16, v2, v3, v4);
    rawBits -= v10 << 16;
    uint64_t v9 = v10 << 8;
    if (v10 > 63) {
      uint64_t v9 = 0LL;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  uint64_t v11 = 4LL;
  if (((v5 >> 60) & ((v6 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v11 = 8LL;
  }
  return (Swift::String::Index)(v7 & 2 | (unint64_t)v9 | rawBits & 0xFFFFFFFFFFFF0000LL | v11 | 1);
}

Swift::String::Index __swiftcall Substring.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v6 = v5;
  uint64_t v7 = v4;
  unint64_t v8 = v3;
  unint64_t v9 = v2;
  v11._Swift::UInt64 rawBits = _._rawBits;
  char v12 = (v5 & 0x1000000000000000LL) == 0 || (v4 & 0x800000000000000LL) != 0;
  uint64_t v13 = _._rawBits & 0xC;
  uint64_t v14 = 4LL << v12;
  if ((_._rawBits & 2) == 0 || v13 == v14)
  {
    if (v13 == v14) {
      v11._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
    }
    if (v11._rawBits >> 14 < v9 >> 14 || v8 >> 14 < v11._rawBits >> 14)
    {
      unint64_t v15 = 65LL;
LABEL_66:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v15,  0);
    }

    if ((v11._rawBits & 1) != 0)
    {
      if ((v9 & 2) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      v11._Swift::UInt64 rawBits = v11._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v11)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v9 & 2) != 0)
      {
LABEL_15:
        if ((v11._rawBits & 2) != 0) {
          goto LABEL_19;
        }
      }
    }

    if (v11._rawBits >> 14 != v9 >> 14 && v11._rawBits >> 14 != v8 >> 14) {
      v11._Swift::UInt64 rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(v11._rawBits, v9, v8, v7, v6);
    }
    goto LABEL_19;
  }

  if (_._rawBits >> 14 < v2 >> 14 || v3 >> 14 < _._rawBits >> 14)
  {
    unint64_t v15 = 296LL;
    goto LABEL_66;
  }

Swift::String::Index_optional __swiftcall Substring.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v7 = v6;
  uint64_t v8 = v5;
  unint64_t v9 = v4;
  unint64_t v10 = v3;
  Swift::UInt64 rawBits = limitedBy._rawBits;
  uint64_t v14 = (v5 >> 59) & 1;
  if ((v6 & 0x1000000000000000LL) == 0) {
    LOBYTE(vHasher._combine(_:)(*v0 >> 14) = 1;
  }
  uint64_t v15 = 4LL << v14;
  if ((limitedBy._rawBits & 0xC) == 4LL << v14) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(limitedBy)._rawBits;
  }
  if ((_._rawBits & 0xC) == v15)
  {
    Swift::UInt64 v59 = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
    unint64_t v16 = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
    _._Swift::UInt64 rawBits = v59;
  }

  else
  {
    if ((_._rawBits & 2) != 0)
    {
      if (_._rawBits >> 14 >= v10 >> 14)
      {
        unint64_t v16 = _._rawBits;
        if (v9 >> 14 >= _._rawBits >> 14) {
          goto LABEL_18;
        }
      }

      unint64_t v45 = 296LL;
LABEL_68:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v45,  0);
    }

    unint64_t v16 = _._rawBits;
  }

  if (v16 >> 14 < v10 >> 14 || v9 >> 14 < v16 >> 14)
  {
    unint64_t v45 = 65LL;
    goto LABEL_68;
  }

  if ((v16 & 1) != 0)
  {
    if ((v10 & 2) != 0) {
      goto LABEL_12;
    }
  }

  else
  {
    unint64_t v16 = v16 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v16)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((v10 & 2) != 0)
    {
LABEL_12:
      if ((v16 & 2) != 0) {
        goto LABEL_18;
      }
    }
  }

  if (v16 >> 14 != v10 >> 14 && v16 >> 14 != v9 >> 14) {
    unint64_t v16 = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(v16, v10, v9, v8, v7);
  }
LABEL_18:
  Swift::UInt64 v17 = rawBits >> 14;
  if (offsetBy < 0)
  {
    Swift::Int v46 = 0LL;
    Swift::UInt64 v47 = _._rawBits >> 14;
    unint64_t v48 = v10 >> 14;
    uint64_t v49 = v10 >> 16;
    uint64_t v50 = 4LL;
    if (((v7 >> 60) & ((v8 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v50 = 8LL;
    }
    unint64_t v51 = v10 & 2 | v50;
    while (1)
    {
      unint64_t v52 = v16 >> 14;
      if (v47 >= v17 && v17 >= v52) {
        break;
      }
      if (v48 >= v52)
      {
        unint64_t v58 = 360LL;
LABEL_88:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/Substring.swift",  21LL,  2,  v58,  0);
      }

      --v46;
      uint64_t v53 = _StringGuts._opaqueCharacterStride(endingAt:in:)(v16 >> 16, v49, limitedBy._rawBits, v8, v7);
      uint64_t v54 = v53 << 8;
      if (v53 > 63) {
        uint64_t v54 = 0LL;
      }
      unint64_t v55 = v51 | v54 | (v16 - (v53 << 16)) & 0xFFFFFFFFFFFF0000LL;
      unint64_t v16 = v55 | 1;
      if (v46 <= offsetBy)
      {
        if (v47 < v17 || v55 >> 14 >= v17) {
          goto LABEL_84;
        }
        break;
      }
    }
  }

  else
  {
    Swift::UInt64 v18 = _._rawBits >> 14;
    if (offsetBy)
    {
      unint64_t v19 = v9 >> 14;
      int64_t v20 = v9 >> 16;
      uint64_t v21 = HIBYTE(v7) & 0xF;
      uint64_t v22 = v7 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v23 = (v7 & 0xFFFFFFFFFFFFFFFLL) + 32;
      uint64_t v24 = v8 & 0xFFFFFFFFFFFFLL;
      uint64_t v25 = 4LL;
      if (((v7 >> 60) & ((v8 & 0x800000000000000LL) == 0)) != 0) {
        uint64_t v25 = 8LL;
      }
      unint64_t v26 = v10 & 2 | v25;
      while (1)
      {
        unint64_t v27 = v16 >> 14;
        if (v17 >= v18 && v27 >= v17) {
          goto LABEL_83;
        }
        if (v27 >= v19)
        {
          unint64_t v58 = 353LL;
          goto LABEL_88;
        }

        uint64_t v28 = (v16 >> 8) & 0x3F;
        Swift::Int v29 = v16 >> 16;
        if (!v28) {
          break;
        }
LABEL_41:
        uint64_t v33 = v28 + v29;
        if (v20 < v28 + v29) {
          uint64_t v33 = v20;
        }
        uint64_t v34 = v33 << 16;
        uint64_t v35 = v33 & 0xFFFFFFFFFFFFLL;
        if ((v33 & 0xFFFFFFFFFFFFLL) != v20)
        {
          if ((v7 & 0x1000000000000000LL) != 0) {
            goto LABEL_63;
          }
          if ((v7 & 0x2000000000000000LL) != 0)
          {
            uint64_t v73 = v8;
            uint64_t v74 = v22;
            if (v35 + 1 != v21)
            {
              int v39 = *(unsigned __int16 *)((char *)&v73 + v35);
LABEL_54:
              if (v39 == 2573 || (v39 & 0x8080) != 0)
              {
LABEL_63:
                uint64_t v61 = v24;
                uint64_t v65 = v23;
                uint64_t v69 = v21;
                Swift::Int v41 = v35;
                uint64_t v42 = v22;
                Swift::Int v36 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v41);
                uint64_t v24 = v61;
                uint64_t v23 = v65;
                uint64_t v22 = v42;
                uint64_t v21 = v69;
                if (v36 > 63) {
                  goto LABEL_61;
                }
                goto LABEL_60;
              }
            }
          }

          else
          {
            uint64_t v37 = (char *)v23;
            uint64_t v38 = v24;
            if ((v8 & 0x1000000000000000LL) == 0)
            {
              uint64_t v67 = v23;
              uint64_t v71 = v21;
              uint64_t v60 = v22;
              uint64_t v63 = v24;
              uint64_t v37 = (char *)_StringObject.sharedUTF8.getter(v8, v7);
              uint64_t v24 = v63;
              uint64_t v23 = v67;
              uint64_t v22 = v60;
              uint64_t v21 = v71;
            }

            if (v35 + 1 != v38)
            {
              if (!v37) {
LABEL_92:
              }
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
              int v39 = *(unsigned __int16 *)&v37[v35];
              goto LABEL_54;
            }
          }

          Swift::Int v36 = 1LL;
          goto LABEL_60;
        }

        Swift::Int v36 = 0LL;
LABEL_60:
        v34 |= v36 << 8;
LABEL_61:
        unint64_t v16 = v26 | v34 | 1;
        if (!--offsetBy) {
          goto LABEL_69;
        }
      }

      if (v29 == v20)
      {
        uint64_t v28 = 0LL;
        goto LABEL_41;
      }

      if ((v7 & 0x1000000000000000LL) == 0)
      {
        if ((v7 & 0x2000000000000000LL) == 0)
        {
          Swift::Int v30 = (char *)v23;
          uint64_t v31 = v24;
          if ((v8 & 0x1000000000000000LL) == 0)
          {
            uint64_t v68 = v23;
            uint64_t v72 = v21;
            uint64_t v44 = v22;
            uint64_t v64 = v24;
            Swift::Int v30 = (char *)_StringObject.sharedUTF8.getter(v8, v7);
            uint64_t v24 = v64;
            uint64_t v23 = v68;
            uint64_t v22 = v44;
            uint64_t v21 = v72;
          }

          if (v29 + 1 == v31)
          {
LABEL_40:
            uint64_t v28 = 1LL;
            goto LABEL_41;
          }

          if (!v30) {
            goto LABEL_92;
          }
          int v32 = *(unsigned __int16 *)&v30[v29];
          if (v32 == 2573) {
            goto LABEL_65;
          }
          goto LABEL_39;
        }

        uint64_t v73 = v8;
        uint64_t v74 = v22;
        if (v29 + 1 == v21) {
          goto LABEL_40;
        }
        int v32 = *(unsigned __int16 *)((char *)&v73 + v29);
        if (v32 != 2573)
        {
LABEL_39:
          if ((v32 & 0x80808080) == 0) {
            goto LABEL_40;
          }
        }
      }

Swift::Int __swiftcall Substring.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v6 = v5;
  uint64_t v7 = v4;
  unint64_t v8 = v3;
  unint64_t v9 = v2;
  unint64_t rawBits = from._rawBits;
  char v12 = (v5 & 0x1000000000000000LL) == 0 || (v4 & 0x800000000000000LL) != 0;
  uint64_t v13 = from._rawBits & 0xC;
  uint64_t v14 = 4LL << v12;
  Swift::UInt64 v15 = v3 >> 14;
  if ((from._rawBits & 2) == 0 || v13 == v14)
  {
    if (v13 == v14) {
      goto LABEL_94;
    }
    goto LABEL_10;
  }

  if (from._rawBits >> 14 < v2 >> 14 || v15 < from._rawBits >> 14)
  {
LABEL_22:
    unint64_t v17 = 296LL;
    goto LABEL_79;
  }

uint64_t Substring.subscript.getter( Swift::UInt64 rawBits, unint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  char v9 = (a5 & 0x1000000000000000LL) == 0 || (a4 & 0x800000000000000LL) != 0;
  Swift::UInt64 v10 = rawBits & 0xC;
  uint64_t v11 = 4LL << v9;
  Swift::UInt64 v12 = a3 >> 14;
  if ((rawBits & 1) == 0 || v10 == v11)
  {
    if (v10 == v11) {
      unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    if (rawBits >> 14 < a2 >> 14 || rawBits >> 14 >= v12)
    {
      unint64_t v13 = 43LL;
LABEL_27:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v13,  0);
    }

    if ((rawBits & 1) == 0) {
      unint64_t rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
    }
  }

  else if (rawBits >> 14 < a2 >> 14 || rawBits >> 14 >= v12)
  {
    unint64_t v13 = 143LL;
    goto LABEL_27;
  }

  uint64_t v14 = (rawBits >> 8) & 0x3F;
  Swift::Int v15 = rawBits >> 16;
  Swift::Int v16 = a3 >> 16;
  if (!v14)
  {
    if (v15 == v16)
    {
      uint64_t v14 = 0LL;
      goto LABEL_18;
    }

    if ((a5 & 0x1000000000000000LL) == 0)
    {
      if ((a5 & 0x2000000000000000LL) != 0)
      {
        uint64_t v28 = a4;
        uint64_t v29 = a5 & 0xFFFFFFFFFFFFFFLL;
        Swift::Int v25 = v15 + 1;
        if (v15 + 1 == (HIBYTE(a5) & 0xF)) {
          goto LABEL_42;
        }
        int v26 = *(unsigned __int16 *)((char *)&v28 + v15);
      }

      else
      {
        if ((a4 & 0x1000000000000000LL) != 0)
        {
          Swift::Int v23 = (char *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v24 = a4 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          Swift::Int v23 = (char *)_StringObject.sharedUTF8.getter(a4, a5);
        }

        Swift::Int v25 = v15 + 1;
        if (v15 + 1 == v24)
        {
LABEL_42:
          if (v16 >= v25) {
            Swift::Int v16 = v25;
          }
          if (v16 >= v15) {
            goto LABEL_22;
          }
LABEL_45:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
        }

        if (!v23) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }
        int v26 = *(unsigned __int16 *)&v23[v15];
      }

      if (v26 != 2573 && (v26 & 0x80808080) == 0) {
        goto LABEL_42;
      }
    }

    uint64_t v14 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v15);
  }

void specialized Substring._replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  v7._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v8 = (unint64_t)(v6 + 2);
  Swift::UInt64 v9 = v6[2];
  uint64_t v10 = v6[3];
  Swift::UInt64 v11 = *v6;
  Swift::UInt64 v12 = v6[1];
  LODWORD(v13) = (v10 & 0x1000000000000000LL) == 0 || (v9 & 0x800000000000000LL) != 0;
  unint64_t v14 = a1._rawBits & 0xC;
  uint64_t v15 = 4LL << v13;
  uint64_t v16 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) != 0 && v14 != v15 && (a2._rawBits & 1) != 0 && v16 != v15)
  {
    Swift::Int v17 = (uint64_t *)v213;
    if (a1._rawBits >> 14 < v11 >> 14 || v12 >> 14 < a2._rawBits >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
    }
    goto LABEL_18;
  }

  if (v16 == v15)
  {
    unint64_t v205 = a3;
    unint64_t v209 = a4;
    unint64_t v202 = a6;
    uint64_t v134 = a5;
    v135._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
    a3 = v205;
    a4 = v209;
    a5 = v134;
    a6 = v202;
    a2._Swift::UInt64 rawBits = v135._rawBits;
    if (v14 != v15) {
      goto LABEL_13;
    }
LABEL_130:
    v136._Swift::UInt64 rawBits = v7._rawBits;
    v203._Swift::UInt64 rawBits = a2._rawBits;
    unint64_t v137 = a3;
    unint64_t v138 = a6;
    uint64_t v139 = a5;
    unint64_t v14 = a4;
    v140._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v136)._rawBits;
    a2._Swift::UInt64 rawBits = v203._rawBits;
    a3 = v137;
    a4 = v14;
    a5 = v139;
    a6 = v138;
    v7._Swift::UInt64 rawBits = v140._rawBits;
    goto LABEL_13;
  }

  if (v14 == v15) {
    goto LABEL_130;
  }
LABEL_13:
  Swift::Int v17 = (uint64_t *)v213;
  if (v7._rawBits >> 14 < v11 >> 14 || a2._rawBits >> 14 < v7._rawBits >> 14 || v12 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
  }
  if ((a2._rawBits & 1) == 0) {
    goto LABEL_142;
  }
  if ((v7._rawBits & 1) == 0) {
    goto LABEL_143;
  }
LABEL_18:
  uint64_t v200 = a5;
  unint64_t v201 = a6;
  unint64_t v204 = a3;
  unint64_t v208 = a4;
  if (!(_DWORD)v13)
  {
    Swift::UInt64 rawBits = a2._rawBits;
    Swift::UInt64 v155 = v11;
    if ((v11 & 0xC) == 4) {
      Swift::UInt64 v155 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v11)._rawBits;
    }
    if ((v10 & 0x2000000000000000LL) != 0) {
      unint64_t v14 = HIBYTE(v10) & 0xF;
    }
    else {
      unint64_t v14 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (v14 < v155 >> 16) {
      goto LABEL_224;
    }
    unint64_t startingAt = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)v155);
    if ((v11 & 0xC) == 4) {
      Swift::UInt64 v11 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v11)._rawBits;
    }
    if ((v12 & 0xC) == 4)
    {
      Swift::UInt64 v12 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v12)._rawBits;
      if (v14 < v11 >> 16) {
        goto LABEL_224;
      }
    }

    else if (v14 < v11 >> 16)
    {
      goto LABEL_224;
    }

    if (v14 < v12 >> 16) {
      goto LABEL_224;
    }
    Swift::Int v156 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v11, (Swift::String::Index)v12);
    Swift::UInt64 v157 = v7._rawBits;
    if ((v7._rawBits & 0xC) != 4LL)
    {
LABEL_156:
      Swift::UInt64 v158 = rawBits;
      if ((rawBits & 0xC) == 4)
      {
        Swift::UInt64 v158 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
        if (v14 < v157 >> 16) {
          goto LABEL_224;
        }
      }

      else if (v14 < v157 >> 16)
      {
        goto LABEL_224;
      }

      if (v14 >= v158 >> 16)
      {
        Swift::Int v159 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v157, (Swift::String::Index)v158);
        unint64_t v160 = v8;
        uint64_t v161 = specialized _StringGuts.replaceSubrange<A>(_:with:)(v7._rawBits, rawBits, v204, v208, v200, v201);
        uint64_t v163 = v162 - v161;
        if (__OFSUB__(v162, v161))
        {
          __break(1u);
        }

        else
        {
          BOOL v87 = __OFADD__(v156, v163);
          Swift::Int v164 = v156 + v163;
          if (!v87)
          {
            Swift::Int v156 = v164 - v159;
            if (!__OFSUB__(v164, v159))
            {
              if (v161 == v162)
              {
                Swift::Int v165 = 0LL;
                unint64_t v166 = startingAt << 16;
LABEL_197:
                v166 |= v165 << 8;
LABEL_198:
                *(void *)uint64_t v213 = v166 | 5;
                if (_StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v166 | 5))) {
                  *(void *)uint64_t v213 = v166 | 7;
                }
                uint64_t v121 = startingAt + v156;
                if (!__OFADD__(startingAt, v156))
                {
                  Swift::Int v17 = (uint64_t *)v213;
                  goto LABEL_125;
                }

                __break(1u);
                goto LABEL_232;
              }

              uint64_t v183 = *(void *)(v213 + 16);
              unint64_t v160 = *(void *)(v213 + 24);
              if ((v160 & 0x1000000000000000LL) != 0) {
                goto LABEL_229;
              }
              if ((v160 & 0x2000000000000000LL) != 0)
              {
                Swift::UInt64 v221 = *(void *)(v213 + 16);
                unint64_t v222 = v160 & 0xFFFFFFFFFFFFFFLL;
                if (startingAt + 1 == (HIBYTE(v160) & 0xF))
                {
LABEL_196:
                  unint64_t v166 = startingAt << 16;
                  Swift::Int v165 = 1LL;
                  goto LABEL_197;
                }

                int v186 = *(unsigned __int16 *)((char *)&v221 + startingAt);
                goto LABEL_194;
              }

              if ((v183 & 0x1000000000000000LL) != 0)
              {
                Swift::String::Index v184 = (char *)((v160 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v185 = v183 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                Swift::String::Index v184 = (char *)_StringObject.sharedUTF8.getter(*(void *)(v213 + 16), *(void *)(v213 + 24));
              }

              if (startingAt + 1 == v185) {
                goto LABEL_196;
              }
              if (v184)
              {
                int v186 = *(unsigned __int16 *)&v184[startingAt];
LABEL_194:
                if (v186 != 2573 && (v186 & 0x80808080) == 0) {
                  goto LABEL_196;
                }
LABEL_229:
                Swift::Int v165 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(startingAt);
                unint64_t v166 = startingAt << 16;
                if (v165 > 63) {
                  goto LABEL_198;
                }
                goto LABEL_197;
              }

LABEL_224:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
    }

              swift_getTypeByMangledName(&v268, 255LL, v73, v75, v76, &v264, &v260);
              Swift::String_optional v127 = v263;
              if (v263 == &v260)
              {
                Swift::String_optional v127 = &v260;
                uint64_t v128 = 4LL;
                a6 = v237;
              }

              else
              {
                a6 = v237;
                if (!v263) {
                  goto LABEL_229;
                }
                uint64_t v128 = 5LL;
              }

              (*(void (**)(void))(*v127 + 8 * v128))();
LABEL_229:
              int v129 = v267;
              if (v267 == &v264)
              {
                int v129 = &v264;
                uint64_t v130 = 4LL;
              }

              else
              {
                if (!v267) {
                  goto LABEL_234;
                }
                uint64_t v130 = 5LL;
              }

              (*(void (**)(void))(*v129 + 8 * v130))();
LABEL_234:
              if ((_WORD)v270)
              {
                if ((unsigned __int16)v270 == 1)
                {
                  unint64_t v131 = (uint64_t)v268;
                  uint64_t v132 = v269;
                  *(void *)(a9 + 8) = v269;
                  *(void *)a9 = v132(v131, 2LL, 0LL);
                  size_t v133 = 1;
                  goto LABEL_348;
                }

                uint64_t v134 = 0LL;
              }

              else
              {
                uint64_t v134 = v268;
              }

              if (*v37 == 771)
              {
                Swift::String::Index v135 = (*((_BYTE *)v37 + 11) & 0x40) != 0 ? (uint64_t *)v37[2] : 0LL;
                if (v135) {
                  uint64_t v37 = v135;
                }
              }

              if ((isSubclass((uint64_t)v37, v134) & 1) != 0)
              {
                size_t v133 = 0;
                *(_BYTE *)a9 = 0;
              }

              else
              {
                swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v18 + *v18, a2);
                uint64_t v185 = (int)v184;
                int v186 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v18 + *v18, v184);
                swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v72 + *v72, v187);
                unint64_t v189 = (int)v188;
                unint64_t v190 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)v72 + *v72, v188);
                size_t v191 = operator new(0x28uLL);
                *(void *)size_t v191 = "%.*s is not subclass of %.*s";
                v191[2] = v185;
                *((void *)v191 + 2) = v186;
                v191[6] = v189;
                *((void *)v191 + 4) = v190;
                size_t v133 = 1;
                *(void *)a9 = v191;
                *(void *)(a9 + 8) = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*>(char const*,int,char const*,int,char const*)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,char const*,int,char const*>(char const*,int,char const*,int,char const*)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
              }

void specialized Substring._replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, Swift::UInt64 a4)
{
  unint64_t v5 = v4;
  v6._Swift::UInt64 rawBits = a2._rawBits;
  v7._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v10 = v4[2];
  unint64_t v8 = (unint64_t)(v4 + 2);
  uint64_t v9 = v10;
  unint64_t v11 = v5[3];
  unint64_t v13 = *v5;
  Swift::UInt64 v12 = v5[1];
  uint64_t v179 = (uint64_t)v5;
  uint64_t v14 = (v10 >> 59) & 1;
  if ((v11 & 0x1000000000000000LL) != 0) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 1LL;
  }
  uint64_t v16 = a1._rawBits & 0xC;
  uint64_t v17 = 4LL << v15;
  uint64_t v18 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) != 0 && v16 != v17 && (a2._rawBits & 1) != 0 && v18 != v17)
  {
    uint64_t v19 = (Swift::String::Index *)v179;
    if (a1._rawBits >> 14 < v13 >> 14 || v12 >> 14 < a2._rawBits >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
    }
    goto LABEL_18;
  }

  if (v18 == v17)
  {
    v6._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
    if (v16 != v17) {
      goto LABEL_13;
    }
  }

  else if (v16 != v17)
  {
    goto LABEL_13;
  }

  v7._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v7)._rawBits;
LABEL_13:
  uint64_t v19 = (Swift::String::Index *)v179;
  if (v7._rawBits >> 14 < v13 >> 14 || v6._rawBits >> 14 < v7._rawBits >> 14 || v12 >> 14 < v6._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
  }
  if ((v6._rawBits & 1) == 0) {
    goto LABEL_156;
  }
  if ((v7._rawBits & 1) == 0) {
    goto LABEL_157;
  }
LABEL_18:
  if (!(_DWORD)v15)
  {
LABEL_158:
    Swift::UInt64 rawBits = v13;
    if ((v13 & 0xC) == 4) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v13)._rawBits;
    }
    if ((v11 & 0x2000000000000000LL) != 0) {
      unint64_t v154 = HIBYTE(v11) & 0xF;
    }
    else {
      unint64_t v154 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (v154 >= rawBits >> 16)
    {
      startingAtBuiltin::Word a = String.UTF8View._foreignDistance(from:to:)( (Swift::String::Index)15LL,  (Swift::String::Index)rawBits);
      if ((v13 & 0xC) == 4) {
        unint64_t v13 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v13)._rawBits;
      }
      if ((v12 & 0xC) == 4)
      {
        Swift::UInt64 v12 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v12)._rawBits;
        if (v154 < v13 >> 16) {
          goto LABEL_213;
        }
      }

      else if (v154 < v13 >> 16)
      {
        goto LABEL_213;
      }

      if (v154 < v12 >> 16) {
        goto LABEL_213;
      }
      unint64_t v155 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v13, (Swift::String::Index)v12);
      Swift::UInt64 v156 = v7._rawBits;
      if ((v7._rawBits & 0xC) == 4LL) {
        Swift::UInt64 v156 = _StringGuts._slowEnsureMatchingEncoding(_:)(v7)._rawBits;
      }
      Swift::UInt64 v157 = v6._rawBits;
      if ((v6._rawBits & 0xC) == 4LL)
      {
        Swift::UInt64 v157 = _StringGuts._slowEnsureMatchingEncoding(_:)(v6)._rawBits;
        if (v154 < v156 >> 16) {
          goto LABEL_213;
        }
      }

      else if (v154 < v156 >> 16)
      {
        goto LABEL_213;
      }

      if (v154 >= v157 >> 16)
      {
        Swift::Int v158 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v156, (Swift::String::Index)v157);
        unint64_t v159 = specialized _StringGuts.replaceSubrange<A>(_:with:)(v7._rawBits, v6._rawBits, a3, a4);
        uint64_t v161 = v160 - v159;
        if (__OFSUB__(v160, v159))
        {
          __break(1u);
        }

        else
        {
          BOOL v95 = __OFADD__(v155, v161);
          uint64_t v162 = v155 + v161;
          if (!v95)
          {
            BOOL v95 = __OFSUB__(v162, v158);
            Swift::Int v158 = v162 - v158;
            if (!v95)
            {
              if (v159 == v160)
              {
                Swift::Int v163 = 0LL;
                uint64_t v164 = startingAta << 16;
              }

              else
              {
                uint64_t v164 = *(void *)(v179 + 16);
                unint64_t v155 = *(void *)(v179 + 24);
                if ((v155 & 0x1000000000000000LL) != 0) {
                  goto LABEL_218;
                }
                if ((v155 & 0x2000000000000000LL) == 0)
                {
                  if ((v164 & 0x1000000000000000LL) == 0) {
                    goto LABEL_221;
                  }
                  Swift::UInt64 v167 = (char *)((v155 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v168 = v164 & 0xFFFFFFFFFFFFLL;
                  goto LABEL_192;
                }

                unint64_t v182 = *(void *)(v179 + 16);
                unint64_t v183 = v155 & 0xFFFFFFFFFFFFFFLL;
                if (startingAta + 1 != (HIBYTE(v155) & 0xF))
                {
                  int v169 = *(unsigned __int16 *)((char *)&v182 + startingAta);
                  goto LABEL_199;
                }

void specialized Substring._replaceSubrange<A>(_:with:)(Swift::String::Index a1, Swift::String::Index a2)
{
  unint64_t v3 = v2;
  v4._Swift::UInt64 rawBits = a1._rawBits;
  Swift::UInt64 v7 = v2[2];
  unint64_t v5 = (unint64_t)(v2 + 2);
  Swift::UInt64 v6 = v7;
  unint64_t v8 = v3[3];
  Swift::UInt64 v9 = *v3;
  unint64_t v10 = v3[1];
  uint64_t v11 = (v7 >> 59) & 1;
  if ((v8 & 0x1000000000000000LL) != 0) {
    LODWORD(v12) = v11;
  }
  else {
    LODWORD(v12) = 1;
  }
  uint64_t v13 = a1._rawBits & 0xC;
  uint64_t v14 = 4LL << v12;
  uint64_t v15 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) != 0 && v13 != v14 && (a2._rawBits & 1) != 0 && v15 != v14)
  {
    if (a1._rawBits >> 14 < v9 >> 14 || v10 >> 14 < a2._rawBits >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
    }
    goto LABEL_18;
  }

  if (v15 == v14)
  {
    a2._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
    if (v13 != v14) {
      goto LABEL_13;
    }
  }

  else if (v13 != v14)
  {
    goto LABEL_13;
  }

  Swift::UInt64 rawBits = a2._rawBits;
  v136._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
  a2._Swift::UInt64 rawBits = rawBits;
  v4._Swift::UInt64 rawBits = v136._rawBits;
LABEL_13:
  if (v4._rawBits >> 14 < v9 >> 14 || a2._rawBits >> 14 < v4._rawBits >> 14 || v10 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
  }
  if ((a2._rawBits & 1) == 0) {
    goto LABEL_154;
  }
  if ((v4._rawBits & 1) == 0) {
    goto LABEL_155;
  }
LABEL_18:
  if (!(_DWORD)v12)
  {
LABEL_156:
    v148._Swift::UInt64 rawBits = a2._rawBits;
    Swift::UInt64 v149 = v9 & 0xC;
    Swift::UInt64 v150 = v9;
    if (v149 == 4) {
      Swift::UInt64 v150 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
    }
    if ((v8 & 0x2000000000000000LL) != 0) {
      unint64_t v151 = HIBYTE(v8) & 0xF;
    }
    else {
      unint64_t v151 = v6 & 0xFFFFFFFFFFFFLL;
    }
    if (v151 >= v150 >> 16)
    {
      startingAtBuiltin::Word a = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)v150);
      if (v149 == 4) {
        Swift::UInt64 v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
      }
      if ((v10 & 0xC) == 4)
      {
        unint64_t v10 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v10)._rawBits;
        if (v151 < v9 >> 16) {
          goto LABEL_213;
        }
      }

      else if (v151 < v9 >> 16)
      {
        goto LABEL_213;
      }

      if (v151 < v10 >> 16) {
        goto LABEL_213;
      }
      Swift::Int v152 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v9, (Swift::String::Index)v10);
      Swift::UInt64 v153 = v4._rawBits;
      if ((v4._rawBits & 0xC) == 4LL) {
        Swift::UInt64 v153 = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
      }
      Swift::UInt64 v154 = v148._rawBits;
      if ((v148._rawBits & 0xC) == 4LL)
      {
        Swift::UInt64 v154 = _StringGuts._slowEnsureMatchingEncoding(_:)(v148)._rawBits;
        if (v151 < v153 >> 16) {
          goto LABEL_213;
        }
      }

      else if (v151 < v153 >> 16)
      {
        goto LABEL_213;
      }

      if (v151 >= v154 >> 16)
      {
        Swift::Int v155 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v153, (Swift::String::Index)v154);
        uint64_t v156 = specialized _StringGuts.replaceSubrange<A>(_:with:)(v4._rawBits, v148._rawBits);
        uint64_t v158 = v157 - v156;
        if (__OFSUB__(v157, v156))
        {
          __break(1u);
        }

        else
        {
          BOOL v81 = __OFADD__(v152, v158);
          Swift::Int v159 = v152 + v158;
          if (!v81)
          {
            Swift::UInt64 v149 = v159 - v155;
            if (!__OFSUB__(v159, v155))
            {
              if (v156 == v157)
              {
                Swift::Int v160 = 0LL;
                Swift::Int v161 = startingAta << 16;
                goto LABEL_198;
              }

              uint64_t v164 = v3[2];
              unint64_t v165 = v3[3];
              if ((v165 & 0x1000000000000000LL) == 0)
              {
                if ((v165 & 0x2000000000000000LL) != 0)
                {
                  Swift::UInt64 v179 = v3[2];
                  unint64_t v180 = v165 & 0xFFFFFFFFFFFFFFLL;
                  if (startingAta + 1 == (HIBYTE(v165) & 0xF))
                  {
LABEL_197:
                    Swift::Int v161 = startingAta << 16;
                    Swift::Int v160 = 1LL;
                    goto LABEL_198;
                  }

                  int v168 = *(unsigned __int16 *)((char *)&v179 + startingAta);
                }

                else
                {
                  if ((v164 & 0x1000000000000000LL) != 0)
                  {
                    uint64_t v166 = (char *)((v165 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    uint64_t v167 = v164 & 0xFFFFFFFFFFFFLL;
                  }

                  else
                  {
                    uint64_t v166 = (char *)_StringObject.sharedUTF8.getter(v3[2], v3[3]);
                  }

                  if (startingAta + 1 == v167) {
                    goto LABEL_197;
                  }
                  if (!v166) {
                    goto LABEL_214;
                  }
                  int v168 = *(unsigned __int16 *)&v166[startingAta];
                }

                if (v168 != 2573 && (v168 & 0x80808080) == 0) {
                  goto LABEL_197;
                }
              }

void Substring._replaceSubrange<A>(_:with:)( uint64_t a1, Swift::UInt64 a2, unint64_t *a3, ValueMetadata *a4, Swift::UInt64 a5)
{
  uint64_t v273 = a3;
  Swift::UInt64 v267 = a5;
  uint64_t v9 = *(void *)(a5 + 8);
  uint64_t v10 = type metadata accessor for LazySequence(0LL, (uint64_t)a4, v9, (uint64_t)a4);
  MEMORY[0x1895F8858](v10);
  Swift::UInt64 v266 = (char *)&v262 - v11;
  unint64_t v271 = v9;
  uint64_t v12 = type metadata accessor for LazyMapSequence(255LL, (uint64_t)a4, (uint64_t)&type metadata for String.UTF8View, v9);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, v12, v13);
  unint64_t v17 = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View( WitnessTable,  v15,  v16);
  int64_t v18 = type metadata accessor for FlattenSequence(255LL, v12, WitnessTable, v17);
  uint64_t v20 = swift_getWitnessTable(&protocol conformance descriptor for FlattenSequence<A>, v18, v19);
  type metadata accessor for LazySequence(0LL, v18, v20, v21);
  uint64_t v22 = MEMORY[0x1895F8858](a1);
  uint64_t v272 = (uint64_t)a4;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (uint64_t)&v262 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::UInt64 v26 = MEMORY[0x1895F8858](v23);
  uint64_t v32 = (uint64_t)&v262 - v31;
  int64_t v33 = (uint64_t *)(v5 + 2);
  unint64_t v34 = v5[2];
  unint64_t v35 = v5[3];
  v36._Swift::UInt64 rawBits = *v5;
  Swift::UInt64 v37 = v5[1];
  uint64_t v274 = (uint64_t *)v5;
  v38._Swift::UInt64 rawBits = a2;
  LOBYTE(v39) = (v35 & 0x1000000000000000LL) == 0 || (v34 & 0x800000000000000LL) != 0;
  Swift::UInt64 v40 = v26 & 0xC;
  uint64_t v41 = 4LL << (char)v39;
  uint64_t v42 = v38._rawBits & 0xC;
  if ((v26 & 1) != 0 && v40 != v41 && (v38._rawBits & 1) != 0 && v42 != v41)
  {
    if (v26 >> 14 < v36._rawBits >> 14 || v37 >> 14 < v38._rawBits >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
    }
    goto LABEL_18;
  }

  if (v42 == v41)
  {
    Swift::UInt64 v268 = v26;
    v168._Swift::UInt64 rawBits = v38._rawBits;
    Swift::UInt64 v265 = v33;
    Swift::UInt64 v270 = v27;
    uint64_t v263 = v28;
    uint64_t v264 = v30;
    uint64_t v262 = v29;
    Swift::UInt64 rawBits = v36._rawBits;
    Swift::UInt64 v269 = v37;
    v170._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v168)._rawBits;
    Swift::UInt64 v37 = v269;
    Swift::UInt64 v27 = v270;
    v36._Swift::UInt64 rawBits = rawBits;
    uint64_t v30 = v264;
    int64_t v33 = v265;
    uint64_t v29 = v262;
    uint64_t v28 = v263;
    v38._Swift::UInt64 rawBits = v170._rawBits;
    Swift::UInt64 v26 = v268;
    if (v40 != v41) {
      goto LABEL_13;
    }
LABEL_113:
    Swift::UInt64 v265 = v33;
    Swift::UInt64 v270 = v27;
    uint64_t v263 = v28;
    uint64_t v264 = v30;
    uint64_t v171 = v29;
    Swift::UInt64 v172 = v36._rawBits;
    Swift::UInt64 v269 = v37;
    Swift::UInt64 v26 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v26)._rawBits;
    Swift::UInt64 v37 = v269;
    Swift::UInt64 v27 = v270;
    v36._Swift::UInt64 rawBits = v172;
    uint64_t v30 = v264;
    int64_t v33 = v265;
    uint64_t v29 = v171;
    uint64_t v28 = v263;
    goto LABEL_13;
  }

  if (v40 == v41) {
    goto LABEL_113;
  }
LABEL_13:
  if (v26 >> 14 < v36._rawBits >> 14 || v38._rawBits >> 14 < v26 >> 14 || v37 >> 14 < v38._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
  }
  if ((v38._rawBits & 1) == 0) {
    goto LABEL_124;
  }
  if ((v26 & 1) == 0) {
    goto LABEL_125;
  }
LABEL_18:
  while (1)
  {
    Swift::UInt64 v268 = v26;
    Swift::UInt64 v269 = v26 >> 16;
    uint64_t v43 = v274;
    Swift::UInt64 v270 = v38._rawBits >> 16;
    if ((v34 & ~v35 & 0x2000000000000000LL) != 0)
    {
      Swift::UInt64 v44 = v27;
      uint64_t v264 = v30;
      uint64_t v262 = v29;
      uint64_t v263 = v28;
      Swift::UInt64 v265 = v33;
      if (swift_isUniquelyReferenced_nonNull_native(v35 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v45 = *(void (**)(uint64_t, unint64_t *, uint64_t))(v44 + 16);
        unint64_t v35 = v272;
        char v46 = v273;
        v45(v32, v273, v272);
        if ((swift_dynamicCast( (char *)&v278,  (uint64_t *)v32,  (swift *)v35,  (const char *)&type metadata for String,  6uLL) & 1) != 0)
        {
          unint64_t v47 = v279;
          if ((v279 & 0x1000000000000000LL) == 0)
          {
            unint64_t v48 = v278;
            uint64_t v49 = v270;
            if ((v279 & 0x2000000000000000LL) != 0)
            {
              size_t v51 = HIBYTE(v279) & 0xF;
              v279 &= 0xFFFFFFFFFFFFFFuLL;
              size_t v50 = (char *)&v278;
              goto LABEL_107;
            }

            if ((v278 & 0x1000000000000000LL) != 0)
            {
              size_t v50 = (char *)((v279 & 0xFFFFFFFFFFFFFFFLL) + 32);
              size_t v51 = v278 & 0xFFFFFFFFFFFFLL;
LABEL_107:
              unint64_t v164 = v268;
              unint64_t v165 = v38._rawBits;
LABEL_111:
              unint64_t v159 = specialized _StringGuts.uniqueNativeReplaceSubrange(_:with:isASCII:)(v164, v165, v50, v51);
              uint64_t v273 = v167;
              swift_bridgeObjectRelease(v47);
              unint64_t v131 = v269;
              goto LABEL_174;
            }

LABEL_212:
            size_t v50 = (char *)_StringObject.sharedUTF8.getter(v48, v47);
            size_t v51 = v250;
            goto LABEL_107;
          }
        }

        else
        {
          v45(v25, v46, v35);
          if ((swift_dynamicCast( (char *)&v278,  (uint64_t *)v25,  (swift *)v35,  (const char *)&type metadata for Substring,  6uLL) & 1) == 0)
          {
LABEL_149:
            Swift::UInt64 v212 = v266;
            v45((uint64_t)v266, v46, v35);
            v38._Swift::UInt64 rawBits = v264;
            (*(void (**)(uint64_t, char *, unint64_t))(v44 + 32))(v264, v212, v35);
            uint64_t v213 = (void *)(v38._rawBits + *(int *)(v12 + 44));
            *uint64_t v213 = closure #3 in _StringGuts.replaceSubrange<A>(_:with:);
            v213[1] = 0LL;
            Swift::UInt64 v277 = v267;
            unint64_t v47 = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v12, &v277);
            unint64_t v216 = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View( v47,  v214,  v215);
            v276[0] = v47;
            v276[1] = v216;
            uint64_t v217 = swift_getWitnessTable(&protocol conformance descriptor for <> FlattenSequence<A>, v18, v276);
            unint64_t v48 = Collection.count.getter(v18, v217);
            unint64_t v131 = v269;
            uint64_t v49 = v270;
            Swift::UInt64 v218 = v269 + v48;
            if (__OFADD__(v269, v48))
            {
              __break(1u);
            }

            else
            {
              unint64_t v219 = v43[3];
              if ((v219 & 0x2000000000000000LL) != 0) {
                uint64_t v220 = HIBYTE(v219) & 0xF;
              }
              else {
                uint64_t v220 = v43[2] & 0xFFFFFFFFFFFFLL;
              }
              Swift::UInt64 v221 = v220 - v270;
              uint64_t v273 = (unint64_t *)(v269 + v48);
              uint64_t v32 = v218 + v221;
              if (!__OFADD__(v218, v221))
              {
                unint64_t v47 = v48;
                unint64_t v159 = v269;
                if (v32 >= 16)
                {
                  uint64_t v222 = _StringGuts.uniqueNativeCapacity.getter();
                  if ((v223 & 1) != 0 || v222 < v32)
                  {
                    uint64_t v224 = _StringGuts.uniqueNativeCapacity.getter();
                    if ((v225 & 1) != 0)
                    {
                      unint64_t v227 = v43[3];
                      if ((v227 & 0x1000000000000000LL) != 0)
                      {
                        Swift::Int v226 = String.UTF8View._foreignCount()();
                      }

                      else if ((v227 & 0x2000000000000000LL) != 0)
                      {
                        Swift::Int v226 = HIBYTE(v227) & 0xF;
                      }

                      else
                      {
                        Swift::Int v226 = v43[2] & 0xFFFFFFFFFFFFLL;
                      }
                    }

                    else
                    {
                      Swift::Int v226 = 2 * v224;
                    }

                    if (v226 <= v32) {
                      int64_t v228 = v32;
                    }
                    else {
                      int64_t v228 = v226;
                    }
                    unint64_t v229 = v43[3];
                    if ((v229 & 0x1000000000000000LL) != 0)
                    {
                      _StringGuts._foreignGrow(_:)(v228);
                    }

                    else
                    {
                      unint64_t v230 = *v265;
                      if ((v229 & 0x2000000000000000LL) != 0)
                      {
                        uint64_t v233 = (v229 >> 62) & 1;
                        unint64_t v278 = *v265;
                        unint64_t v279 = v229 & 0xFFFFFFFFFFFFFFLL;
                        uint64_t v231 = (char *)&v278;
                        size_t v232 = HIBYTE(v229) & 0xF;
                      }

                      else
                      {
                        if ((v230 & 0x1000000000000000LL) != 0)
                        {
                          uint64_t v231 = (char *)((v229 & 0xFFFFFFFFFFFFFFFLL) + 32);
                          size_t v232 = v230 & 0xFFFFFFFFFFFFLL;
                        }

                        else
                        {
                          uint64_t v231 = (char *)_StringObject.sharedUTF8.getter(*v265, v229);
                        }

                        uint64_t v233 = v230 >> 63;
                      }

                      int64_t v234 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v231,  v232,  v228,  v233);
                      uint64_t v235 = *(void *)(v234 + 24);
                      swift_bridgeObjectRelease(v43[3]);
                      v43[2] = v235;
                      v43[3] = v234;
                    }
                  }
                }

                uint64_t v32 = v43[3];
                uint64_t v275 = v217;
                uint64_t v236 = v263;
                swift_getWitnessTable(&protocol conformance descriptor for <> LazySequence<A>, v263, &v275);
                uint64_t v237 = v264;
                __StringStorage.replace<A>(from:to:with:replacementCount:)(v131, v49, v264, v47, v236);
                (*(void (**)(uint64_t, uint64_t))(v262 + 8))(v237, v236);
                v43[2] = *(void *)(v32 + 24);
                goto LABEL_174;
              }
            }

            __break(1u);
            goto LABEL_212;
          }

          unint64_t v47 = v281;
          if ((v281 & 0x1000000000000000LL) == 0)
          {
            uint64_t v32 = v38._rawBits;
            unint64_t v106 = v278 >> 16;
            int64_t v107 = v279 >> 16;
            uint64_t v49 = v270;
            if ((v281 & 0x2000000000000000LL) != 0)
            {
              unint64_t v109 = HIBYTE(v281) & 0xF;
              unint64_t v278 = v280;
              unint64_t v279 = v281 & 0xFFFFFFFFFFFFFFLL;
              if (v109 < v107) {
                goto LABEL_221;
              }
              unint64_t v108 = &v278;
            }

            else if ((v280 & 0x1000000000000000LL) != 0)
            {
              unint64_t v108 = (unint64_t *)((v281 & 0xFFFFFFFFFFFFFFFLL) + 32);
              unint64_t v109 = v280 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              unint64_t v108 = (unint64_t *)_StringObject.sharedUTF8.getter(v280, v281);
              unint64_t v109 = v254;
              if (v254 < v107) {
                goto LABEL_221;
              }
            }

            size_t v50 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v106, v107, (uint64_t)v108, v109);
            size_t v51 = v166;
            unint64_t v164 = v268;
            unint64_t v165 = v32;
            goto LABEL_111;
          }
        }

        swift_bridgeObjectRelease(v47);
        char v46 = v273;
        goto LABEL_149;
      }

      unint64_t v34 = v43[2];
      unint64_t v35 = v43[3];
    }

    Swift::UInt64 v267 = v38._rawBits;
    unint64_t v52 = 0xE000000000000000LL;
    unint64_t v278 = 0LL;
    unint64_t v279 = 0xE000000000000000LL;
    uint64_t v53 = _StringGuts.nativeCapacity.getter(v34, v35);
    uint64_t v54 = 0LL;
    if ((v55 & 1) == 0)
    {
      int64_t v56 = v53;
      if (v53 > 15)
      {
        uint64_t v57 = _StringGuts.uniqueNativeCapacity.getter();
        if ((v58 & 1) != 0 || v57 < v56)
        {
          uint64_t v60 = 2 * _StringGuts.uniqueNativeCapacity.getter();
          if (v60 <= v56) {
            uint64_t v60 = v56;
          }
          if ((v59 & 1) != 0) {
            int64_t v61 = v56;
          }
          else {
            int64_t v61 = v60;
          }
          uint64_t v282 = 0LL;
          uint64_t v283 = 0LL;
          unint64_t v52 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v282,  0LL,  v61,  1);
          uint64_t v54 = *(void *)(v52 + 24);
          swift_bridgeObjectRelease(0xE000000000000000LL);
          unint64_t v278 = v54;
          unint64_t v279 = v52;
        }

        else
        {
          uint64_t v54 = 0LL;
          unint64_t v52 = 0xE000000000000000LL;
        }
      }
    }

    unint64_t v62 = v43[3];
    v63._Swift::UInt64 rawBits = v268;
    Swift::UInt64 v268 = v43[2];
    Swift::UInt64 v266 = (char *)v62;
    unint64_t v66 = specialized Collection.subscript.getter(v63, v268, v62);
    unint64_t v68 = v67;
    uint64_t v69 = v64;
    unint64_t v70 = v65;
    uint64_t v71 = v66 >> 16;
    uint64_t v72 = v67 >> 16;
    if ((v65 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v65, 3LL, v64, (char *)v65);
      v173._Swift::UInt64 rawBits = v66 & 0xFFFFFFFFFFFF0000LL | 1;
      v174._Swift::UInt64 rawBits = v68 & 0xFFFFFFFFFFFF0000LL | 1;
      v175._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v173, v174, v69, v70);
      if (v175._rawBits < 0x10000) {
        v175._rawBits |= 3;
      }
      Swift::Int v73 = specialized Collection.count.getter(v175, v176, v69, v70);
      swift_bridgeObjectRelease(v70);
      uint64_t v54 = v278;
      unint64_t v52 = v279;
      if ((v279 & 0x1000000000000000LL) != 0)
      {
LABEL_117:
        Swift::Int v177 = String.UTF8View._foreignCount()();
        int64_t v74 = v177 + v73;
        if (!__OFADD__(v177, v73)) {
          goto LABEL_46;
        }
        goto LABEL_44;
      }
    }

    else
    {
      Swift::Int v73 = v72 - v71;
      swift_bridgeObjectRetain_n(v65, 2LL, v64, (char *)v65);
      if ((v52 & 0x1000000000000000LL) != 0) {
        goto LABEL_117;
      }
    }

    if ((v52 & 0x2000000000000000LL) == 0)
    {
      int64_t v74 = (v54 & 0xFFFFFFFFFFFFLL) + v73;
      if (!__OFADD__(v54 & 0xFFFFFFFFFFFFLL, v73)) {
        goto LABEL_46;
      }
      goto LABEL_44;
    }

    while (1)
    {
      uint64_t v75 = HIBYTE(v52) & 0xF;
      int64_t v74 = v75 + v73;
      if (!__OFADD__(v75, v73)) {
        break;
      }
LABEL_44:
      __break(1u);
    }

        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        Swift::Int v240 = v315._countAndFlagsBits;
        unint64_t v241 = v315._object;
        swift_bridgeObjectRetain((unint64_t)v315._object, v242, v243, v244);
        uint64_t v245 = _StringGuts._convertedToSmall()(v240, (unint64_t)v241);
        uint64_t v247 = v246;
        swift_bridgeObjectRelease((uint64_t)v241);
        v248._Swift::UInt64 rawBits = 1LL;
        v249._Swift::UInt64 rawBits = 65537LL;
        v250._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v248, v249, 0x2EuLL, 0xE100000000000000LL);
        if (v250._rawBits < 0x10000) {
          v250._rawBits |= 3;
        }
        uint64_t v252 = specialized String.init(_:)(v250, v251, 0x2EuLL, 0xE100000000000000LL);
        int64_t v254 = v253;
        swift_bridgeObjectRelease(0xE100000000000000LL);
        unint64_t v255 = _StringGuts._convertedToSmall()(v252, v254);
        Swift::UInt64 v257 = v256;
        swift_bridgeObjectRelease(v254);
        Swift::UInt64 v258 = specialized _SmallString.init(_:appending:)(v245, v247, v255, v257);
        if ((v260 & 1) == 0)
        {
          Swift::String::Index v261 = v258;
          uint64_t v262 = v259;
          swift_bridgeObjectRelease(0xE100000000000000LL);
          uint64_t v239 = (uint64_t)v315._object;
          v315._uint64_t countAndFlagsBits = v261;
          v315._unint64_t object = v262;
          goto LABEL_217;
        }

      swift_instantiateObjCClass((objc_class *)a1);
      return 0LL;
    }

    if (qword_18C486BF0 != -1) {
      dispatch_once_f( &qword_18C486BF0,  &supportsLazyObjcClassNames(void)::$_0::operator() const(void)::TheLazy,  (dispatch_function_t)supportsLazyObjcClassNames(void)::$_0::operator() const(void)::{lambda(void *)#1}::__invoke);
    }
    if (supportsLazyObjcClassNames(void)::$_0::operator() const(void)::TheLazy)
    {
      *(void *)((*(void *)(a1 + 32) & 0x7FFFFFFFF8LL) + 0x18) = 0LL;
      unint64_t v142 = (uint64_t)object_getClass((id)a1)[4].isa & 0x7FFFFFFFF8LL;
      *(void *)(v142 + 16) = a1;
      *(void *)(v142 + 24) = 0LL;
      Swift::String::Index v143 = *(void *)(a1 + 32);
      if (!a3) {
        goto LABEL_212;
      }
    }

    else
    {
      unint64_t v164 = object_getClass((id)a1);
      unint64_t v165 = copyGenericClassObjCName(a1);
      Swift::String::Index v143 = *(void *)(a1 + 32);
      *(void *)((v143 & 0x7FFFFFFFF8LL) + 0x18) = v165;
      *(void *)(((uint64_t)v164[4].isa & 0x7FFFFFFFF8LL) + 0x18) = v165;
      if (!a3) {
        goto LABEL_212;
      }
    }

    Swift::String::Index v173 = a5;
    Swift::String::Index v144 = v143 & 0x7FFFFFFFF8LL;
    Swift::String::Index v145 = *(const void **)((v143 & 0x7FFFFFFFF8LL) + 0x30);
    Swift::String::Index v146 = swift::MetadataAllocator::Allocate( (swift::MetadataAllocator *)&getResilientMetadataAllocator(void)::allocator,  (32 * a3) | 8,  (const char *)4,  v141);
    memcpy(v146, v145, (32 * a3) | 8);
    Swift::String::Index v147 = 0LL;
    unint64_t v148 = 0;
    unint64_t v149 = 0LL;
    *(void *)(v144 + 48) = v146;
    unint64_t v150 = (char *)v146 + 8;
    do
    {
      unint64_t v151 = (objc_class *)a1;
      unint64_t v152 = *(void *)(v118 + 8 * v147);
      unint64_t v153 = &v150[32 * v147];
      unint64_t v154 = *(void *)v153;
      if (*(void *)v153)
      {
        if (!v149)
        {
          if (a3 > 8)
          {
            unint64_t v149 = calloc(a3, 8uLL);
          }

          else
          {
            unint64_t v149 = v175;
            bzero(v175, 8 * a3);
          }
        }

        *(void *)&v149[8 * v147] = v154;
      }

      *(void *)unint64_t v153 = v173 + 8 * v147;
      char v156 = *((_DWORD *)v153 + 7);
      unint64_t v155 = v153 + 28;
      a1 = (uint64_t)v151;
      if (*(void *)v152 != v156)
      {
        char *v155 = *(void *)v152;
        *(void *)&v150[32 * v147 + 16] = 0LL;
        unint64_t v157 = -1;
        do
          ++v157;
        while (*(unsigned __int8 *)(v152 + 16) + 1 != 1 << v157);
        *(_DWORD *)&v150[32 * v147 + 24] = v157;
      }

      Swift::String::Index v147 = ++v148;
      unint64_t v118 = a4;
    }

    while (v148 != a3);
    swift_instantiateObjCClass(v151);
    if (v149)
    {
      unint64_t v158 = 0LL;
      do
      {
        unint64_t v159 = *(void **)&v149[8 * v158];
        if (v159)
        {
          unint64_t v160 = *(void *)(v173 + 8 * v158);
          if (*v159 != v160) {
            *unint64_t v159 = v160;
          }
        }

        ++v158;
      }

      while (a3 != v158);
      if (v149 != v175) {
        free(v149);
      }
    }

    return 0LL;
  }

  uint64_t v16 = result;
  if (*(void *)result == 773LL) {
    uint64_t v16 = (swift *)*((void *)result + 1);
  }
  if (v10 >= v13)
  {
    *(void *)(a1 + 8) = v16;
    unint64_t v17 = (swift **)(a1 + 8);
    if (v16) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  return result;
}

LABEL_245:
          __break(1u);
          goto LABEL_246;
        }
      }

      __break(1u);
      goto LABEL_245;
    }
  }

  uint64_t v273 = v39;
  if ((v119 & ~v120 & 0x2000000000000000LL) != 0
    && swift_isUniquelyReferenced_nonNull_native(v120 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v128 = v279;
    int64_t v129 = _StringGuts.nativeUnusedCapacity.getter(v278, v279);
    if ((v130 & 1) != 0)
    {
LABEL_236:
      unint64_t v255 = 258LL;
      goto LABEL_237;
    }

    uint64_t v49 = v270;
    if (v32 <= 15 && ((v128 & 0x2000000000000000LL) != 0 || v129 < v12))
    {
LABEL_97:
      swift_bridgeObjectRelease(v34);
      unint64_t v137 = v278;
      swift_bridgeObjectRetain(v128, v138, v139, v140);
      uint64_t v32 = _StringGuts._convertedToSmall()(v137, v128);
      unint64_t v142 = v141;
      swift_bridgeObjectRelease(v128);
      v143._Swift::UInt64 rawBits = v38._rawBits & 0xFFFFFFFFFFFF0000LL | 1;
      v144._Swift::UInt64 rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
      Swift::String::Index v145 = (ValueMetadata *)v272;
      v146._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v143, v144, v272, v34);
      if (v146._rawBits < 0x10000) {
        v146._rawBits |= 3;
      }
      unint64_t v148 = specialized String.init(_:)(v146, v147, (unint64_t)v145, v34);
      unint64_t v150 = v149;
      swift_bridgeObjectRelease(v34);
      unint64_t v151 = _StringGuts._convertedToSmall()(v148, v150);
      unint64_t v153 = v152;
      swift_bridgeObjectRelease(v150);
      unint64_t v154 = specialized _SmallString.init(_:appending:)(v32, v142, v151, v153);
      uint64_t v43 = v274;
      if ((v156 & 1) == 0)
      {
        unint64_t v157 = v154;
        unint64_t v158 = v155;
        swift_bridgeObjectRelease(v128);
        unint64_t v278 = v157;
        unint64_t v279 = v158;
        goto LABEL_102;
      }

uint64_t Substring.init<A, B>(decoding:as:)(uint64_t a1, uint64_t a2, swift *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *((void *)a3 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (uint64_t *)((char *)v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  if (v10 != &type metadata for Unicode.UTF8)
  {
    static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, (uint64_t)v10, 1, a3, v11, a5, v12);
    if (!v21) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
    }
    goto LABEL_9;
  }

  MEMORY[0x1895F8858](v9);
  (*(void (**)(uint64_t *__return_ptr, uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, uint64_t *@<X8>)))(*(void *)(a5 + 8) + 72LL))( v24,  closure #1 in String.init<A, B>(decoding:as:)partial apply);
  if (v24[1])
  {
LABEL_9:
    (*(void (**)(uint64_t, swift *))(v8 + 8))(a1, a3);
    return 15LL;
  }

  (*(void (**)(uint64_t *, uint64_t, swift *))(v8 + 16))(v14, a1, a3);
  uint64_t v15 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasContiguousBytes);
  if ((swift_dynamicCast((char *)v22, v14, a3, v15, 6uLL) & 1) == 0)
  {
    uint64_t v23 = 0LL;
    memset(v22, 0, sizeof(v22));
    outlined destroy of _HasContiguousBytes?( (uint64_t)v22,  &demangling cache variable for type metadata for _HasContiguousBytes?);
LABEL_8:
    static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)(a1, (uint64_t)a3, a5);
    goto LABEL_9;
  }

  outlined init with take of MirrorPath(v22, (uint64_t)v24);
  uint64_t v16 = v25;
  uint64_t v17 = v26;
  __swift_project_boxed_opaque_existential_0Tm(v24, v25);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v17 + 16))(v16, v17) & 1) == 0)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(v24);
    goto LABEL_8;
  }

  (*(void (**)(uint64_t, swift *))(v8 + 8))(a1, a3);
  uint64_t v18 = v25;
  uint64_t v19 = v26;
  __swift_project_boxed_opaque_existential_0Tm(v24, v25);
  (*(void (**)(__int128 *__return_ptr, uint64_t (*)@<X0>(uint8x16_t *@<X0>, uint64_t@<X1>, uint64_t *@<X8>), void, ValueMetadata *, uint64_t, uint64_t))(v19 + 8))( v22,  closure #2 in String.init<A, B>(decoding:as:),  0LL,  &type metadata for String,  v18,  v19);
  __swift_destroy_boxed_opaque_existential_1Tm(v24);
  return 15LL;
}

uint64_t Substring.init<A>(decodingCString:as:)( uint8x16_t *a1, ValueMetadata *a2, ValueMetadata *a3, const char *a4)
{
  uint64_t v64 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v8 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)a4,  (uint64_t)a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)
                 + 8);
  Swift::String::Index v63 = *(const char **)(*(void *)(v8 + 24) + 16LL);
  unint64_t v62 = swift_getAssociatedTypeWitness( 0LL,  v63,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v62);
  uint64_t v10 = (char *)&v57 - v9;
  uint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v12 = *(v11 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v57 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v57 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v57 - v19;
  if (a3 == &type metadata for Unicode.UTF8)
  {
    size_t v25 = _swift_stdlib_strlen(a1->i8);
    if ((v25 & 0x8000000000000000LL) != 0) {
      goto LABEL_25;
    }
    uint64_t v22 = v25;
    goto LABEL_16;
  }

  if (a3 == &type metadata for Unicode.UTF16)
  {
    uint64_t v29 = a1;
    if (a1->i16[0])
    {
      uint64_t v29 = a1;
      do
      {
        int v30 = v29->u16[1];
        uint64_t v29 = (uint8x16_t *)((char *)v29 + 2);
      }

      while (v30);
    }

    uint64_t v31 = (char *)v29 - (char *)a1;
    if (v31 > -2)
    {
      specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, v31 / 2, v64, (char *)1);
      if (!v32) {
        goto LABEL_45;
      }
      return 15LL;
    }

    goto LABEL_25;
  }

  if (v64 == &type metadata for Unicode.UTF8)
  {
    int64_t v21 = _swift_stdlib_strlen(a1->i8);
    if (v21 < 0) {
      goto LABEL_25;
    }
    uint64_t v22 = v21;
    uint64_t v23 = *(void *)(v12 + 72);
    if (v23 != 1)
    {
      if ((unsigned __int128)(v21 * (__int128)v23) >> 64 != (v21 * v23) >> 63)
      {
        __break(1u);
LABEL_47:
        if (!v23) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x390EuLL,  0);
        }
        LODWORD(v59) = 0;
        uint64_t v58 = 2033LL;
        LOBYTE(v57) = 2;
        unint64_t v34 = "Buffer must contain a whole number of Element instances";
        uint64_t v35 = 55LL;
LABEL_26:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  v34,  v35,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  v54,  v55,  v56);
      }

      if (v23 < 1 && v23 != -1) {
        goto LABEL_47;
      }
      uint64_t v22 = v21 * v23;
      if (v21 * v23 < 0)
      {
LABEL_25:
        int v56 = 0;
        unint64_t v55 = 1343LL;
        char v54 = 2;
        unint64_t v34 = "UnsafeBufferPointer with negative count";
        uint64_t v35 = 39LL;
        goto LABEL_26;
      }
    }

void Substring.withCString<A>(_:)( void (*a1)(__objc2_class **), uint64_t a2, Swift::String::Index a3, Swift::String::Index a4, unint64_t a5, unint64_t a6)
{
  unint64_t v10 = specialized String.init(_:)(a3, a4, a5, a6);
  uint64_t v12 = (uint64_t)v11;
  String.withCString<A>(_:)(a1, a2, v10, v11);
  swift_bridgeObjectRelease(v12);
}

void Substring.withCString<A, B>(encodedAs:_:)( ValueMetadata *a1, uint64_t a2, uint64_t a3, Swift::String::Index a4, Swift::String::Index a5, unint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v16 = (char *)specialized String.init(_:)(a4, a5, a6, a7);
  uint64_t v18 = (char *)v17;
  if (a1 == &type metadata for Unicode.UTF8)
  {
    MEMORY[0x1895F8858](v16);
    void v20[2] = a8;
    v20[3] = a9;
    v20[4] = a10;
    void v20[5] = a2;
    v20[6] = a3;
    String.withCString<A>(_:)( (void (*)(__objc2_class **))partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:),  (uint64_t)v20,  v19,  v18);
    swift_bridgeObjectRelease((uint64_t)v18);
  }

  else
  {
    String._slowWithCString<A, B>(encodedAs:_:)((uint64_t)a1, a2, a3, v16, v17);
    swift_bridgeObjectRelease((uint64_t)v18);
  }

Swift::Int Substring.hashValue.getter( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  v5[0] = 0LL;
  v5[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  void v5[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v5[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  _StringGutsSlice._normalizedHash(into:)(v5, a3, a4, a1 >> 16, a2 >> 16);
  return Hasher._finalize()();
}

unint64_t protocol witness for StringProtocol.utf8.getter in conformance Substring@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(void *)(v4 + 16);
  unint64_t v5 = *(void *)(v4 + 24);
  *(_OWORD *)a4 = *(_OWORD *)v4;
  *(void *)(a4 + 16) = v6;
  *(void *)(a4 + 24) = v5;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

uint64_t protocol witness for StringProtocol.hasPrefix(_:) in conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for StringProtocol.hasPrefix(_:) in conformance Substring( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized Sequence<>.starts<A>(with:));
}

uint64_t protocol witness for StringProtocol.hasSuffix(_:) in conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for StringProtocol.hasPrefix(_:) in conformance Substring( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized Sequence<>.starts<A>(with:));
}

uint64_t protocol witness for StringProtocol.hasPrefix(_:) in conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, void, void, void, void))
{
  return a5(a1, a2, *v5, v5[1], v5[2], v5[3]);
}

uint64_t protocol witness for StringProtocol.lowercased() in conformance Substring(uint64_t a1, uint64_t a2)
{
  return protocol witness for StringProtocol.lowercased() in conformance Substring( a1,  a2,  (uint64_t (*)(uint64_t))String.lowercased());
}

Swift::String __swiftcall Substring.lowercased()()
{
  uint64_t v4 = Substring.lowercased()(v0, v1, v2, v3, (uint64_t (*)(uint64_t))String.lowercased());
  result._unint64_t object = v5;
  result._uint64_t countAndFlagsBits = v4;
  return result;
}

uint64_t protocol witness for StringProtocol.uppercased() in conformance Substring(uint64_t a1, uint64_t a2)
{
  return protocol witness for StringProtocol.lowercased() in conformance Substring( a1,  a2,  (uint64_t (*)(uint64_t))String.uppercased());
}

uint64_t protocol witness for StringProtocol.lowercased() in conformance Substring( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t))
{
  v5._Swift::UInt64 rawBits = *v3;
  v6._Swift::UInt64 rawBits = v3[1];
  uint64_t v7 = specialized String.init(_:)(v5, v6, v3[2], v3[3]);
  uint64_t v9 = v8;
  uint64_t v10 = a3(v7);
  swift_bridgeObjectRelease(v9);
  return v10;
}

Swift::String __swiftcall Substring.uppercased()()
{
  uint64_t v4 = Substring.lowercased()(v0, v1, v2, v3, (uint64_t (*)(uint64_t))String.uppercased());
  result._unint64_t object = v5;
  result._uint64_t countAndFlagsBits = v4;
  return result;
}

uint64_t Substring.lowercased()( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t))
{
  uint64_t v6 = specialized String.init(_:)(a1, a2, a3, a4);
  uint64_t v8 = v7;
  uint64_t v9 = a5(v6);
  swift_bridgeObjectRelease(v8);
  return v9;
}

uint64_t protocol witness for StringProtocol.init<A, B>(decoding:as:) in conformance Substring@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, swift *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  uint64_t result = Substring.init<A, B>(decoding:as:)(a1, a2, a3, a4, a5);
  *a6 = 15LL;
  a6[1] = v8;
  a6[2] = v9;
  a6[3] = v10;
  return result;
}

uint64_t protocol witness for StringProtocol.init(cString:) in conformance Substring@<X0>( uint8x16_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized Substring.init(cString:)(a1);
  *a2 = result;
  a2[1] = v4;
  a2[2] = v5;
  a2[3] = v6;
  return result;
}

uint64_t protocol witness for StringProtocol.init<A>(decodingCString:as:) in conformance Substring@<X0>( uint8x16_t *a1@<X0>, ValueMetadata *a2@<X1>, ValueMetadata *a3@<X2>, const char *a4@<X3>, void *a5@<X8>)
{
  uint64_t result = Substring.init<A>(decodingCString:as:)(a1, a2, a3, a4);
  *a5 = 15LL;
  a5[1] = v7;
  a5[2] = v8;
  a5[3] = v9;
  return result;
}

void protocol witness for StringProtocol.withCString<A>(_:) in conformance Substring( void (*a1)(__objc2_class **), uint64_t a2)
{
  v3._Swift::UInt64 rawBits = *v2;
  v4._Swift::UInt64 rawBits = v2[1];
  Substring.withCString<A>(_:)(a1, a2, v3, v4, v2[2], v2[3]);
}

void protocol witness for StringProtocol.withCString<A, B>(encodedAs:_:) in conformance Substring( ValueMetadata *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v8._Swift::UInt64 rawBits = *v6;
  v9._Swift::UInt64 rawBits = v6[1];
  Substring.withCString<A, B>(encodedAs:_:)(a1, a2, a3, v8, v9, v6[2], v6[3], a4, a5, a6);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Substring@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance Substring( a1,  (uint64_t (*)(void, void, void, void, void))Substring.index(before:),  a2);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring( uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring( a1,  a2,  a3,  (uint64_t (*)(uint64_t, void, void, void, void))Substring.index(before:));
}

uint64_t protocol witness for ExpressibleByStringInterpolation.init(stringInterpolation:) in conformance Substring@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = specialized Substring.init<A>(_:)();
  *a1 = result;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return result;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Substring()
{
  unint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  unint64_t v3 = v0[2];
  unint64_t v4 = v0[3];
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  void v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  void v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  _StringGutsSlice._normalizedHash(into:)(v6, v3, v4, v1 >> 16, v2 >> 16);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Substring( unint64_t *a1, ValueMetadata *a2)
{
  unint64_t v4 = *v2;
  unint64_t v5 = v2[1];
  if (a2 == &type metadata for String)
  {
    if ((v5 & 0x2000000000000000LL) != 0) {
      uint64_t v7 = HIBYTE(v5) & 0xF;
    }
    else {
      uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = v4 >> 16;
    uint64_t v7 = v5 >> 16;
    unint64_t v4 = v2[2];
    unint64_t v5 = v2[3];
  }

  _StringGutsSlice._normalizedHash(into:)(a1, v4, v5, v6, v7);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Substring( uint64_t a1, ValueMetadata *a2)
{
  unint64_t v4 = *v2;
  unint64_t v5 = v2[1];
  unint64_t v6 = v2[2];
  unint64_t v7 = v2[3];
  v11[0] = 0LL;
  v11[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  void v11[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v11[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v11[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  if (a2 == &type metadata for String)
  {
    if ((v5 & 0x2000000000000000LL) != 0) {
      uint64_t v9 = HIBYTE(v5) & 0xF;
    }
    else {
      uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v8 = v4 >> 16;
    uint64_t v9 = v5 >> 16;
    unint64_t v4 = v6;
    unint64_t v5 = v7;
  }

  _StringGutsSlice._normalizedHash(into:)(v11, v4, v5, v8, v9);
  return Hasher._finalize()();
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance Substring( unint64_t *a1, void *a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = a1[2];
  unint64_t v7 = a1[3];
  uint64_t v8 = a2[2];
  unint64_t v9 = a2[3];
  uint64_t v10 = v4 >> 16;
  uint64_t v11 = v5 >> 16;
  uint64_t v12 = *a2 >> 16;
  uint64_t v13 = a2[1] >> 16;
  if (v6 == v8 && v7 == v9 && v10 == v12 && v11 == v13) {
    return 0LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(v6, v7, v10, v11, v8, v9, v12, v13, 1) & 1;
  }
}

uint64_t protocol witness for static Comparable.<= infix(_:_:) in conformance Substring( unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  uint64_t v4 = a1[2];
  unint64_t v5 = a1[3];
  unint64_t v6 = *a2;
  unint64_t v7 = a2[1];
  uint64_t v8 = a2[2];
  unint64_t v9 = a2[3];
  uint64_t v10 = v6 >> 16;
  uint64_t v11 = v7 >> 16;
  uint64_t v12 = v2 >> 16;
  uint64_t v13 = v3 >> 16;
  char v14 = 1;
  if (v8 != v4 || v9 != v5 || v10 != v12 || v11 != v13) {
    char v14 = _stringCompareInternal(_:_:_:_:expecting:)(v8, v9, v10, v11, v4, v5, v12, v13, 1) ^ 1;
  }
  return v14 & 1;
}

uint64_t protocol witness for static Comparable.>= infix(_:_:) in conformance Substring( unint64_t *a1, void *a2)
{
  unint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = a1[2];
  unint64_t v7 = a1[3];
  uint64_t v8 = a2[2];
  unint64_t v9 = a2[3];
  uint64_t v10 = v4 >> 16;
  uint64_t v11 = v5 >> 16;
  uint64_t v12 = *a2 >> 16;
  uint64_t v13 = a2[1] >> 16;
  char v14 = 1;
  if (v6 != v8 || v7 != v9 || v10 != v12 || v11 != v13) {
    char v14 = _stringCompareInternal(_:_:_:_:expecting:)(v6, v7, v10, v11, v8, v9, v12, v13, 1) ^ 1;
  }
  return v14 & 1;
}

uint64_t protocol witness for static Comparable.> infix(_:_:) in conformance Substring( unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  uint64_t v4 = a1[2];
  unint64_t v5 = a1[3];
  unint64_t v6 = *a2;
  unint64_t v7 = a2[1];
  uint64_t v8 = a2[2];
  unint64_t v9 = a2[3];
  uint64_t v10 = v6 >> 16;
  uint64_t v11 = v7 >> 16;
  uint64_t v12 = v2 >> 16;
  uint64_t v13 = v3 >> 16;
  if (v8 == v4 && v9 == v5 && v10 == v12 && v11 == v13) {
    return 0LL;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(v8, v9, v10, v11, v4, v5, v12, v13, 1) & 1;
  }
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Substring( uint64_t *a1, Swift::UInt64 *a2))()
{
  uint64_t v4 = Substring.subscript.getter(*a2, *(void *)v2, *(void *)(v2 + 8), *(void *)(v2 + 16), *(void *)(v2 + 24));
  a1[1] = v5;
  a1[2] = v5;
  *a1 = v4;
  return protocol witness for Collection.subscript.read in conformance Substring;
}

unint64_t protocol witness for Collection.subscript.getter in conformance Substring@<X0>( Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  v4._Swift::UInt64 rawBits = a1[1];
  v5._Swift::UInt64 rawBits = *a1;
  *a2 = specialized Substring.subscript.getter( v5,  v4,  *(void *)v2,  *(void *)(v2 + 8),  *(void *)(v2 + 16),  *(void *)(v2 + 24));
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = (Swift::UInt64)v8;
  return swift_bridgeObjectRetain((unint64_t)v8, v6, v7, v8);
}

Swift::UInt64 Substring.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 v6 = specialized Substring.subscript.getter(a1, a2, a3, a4, a5, a6);
  swift_bridgeObjectRetain((unint64_t)v9, v7, v8, v9);
  return v6;
}

unint64_t protocol witness for Collection.indices.getter in conformance Substring@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = *v4;
  unint64_t v6 = v4[3];
  *(void *)a4 = *v4;
  __int128 v7 = *(_OWORD *)(v4 + 1);
  *(_OWORD *)(a4 + 8) = v7;
  *(void *)(a4 + 24) = v6;
  *(void *)(a4 + 32) = v5;
  *(void *)(a4 + 4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = v7;
  return swift_bridgeObjectRetain(v6, a1, a2, a3);
}

Swift::Int protocol witness for Collection.count.getter in conformance Substring()
{
  return Substring.distance(from:to:)((Swift::String::Index)v0->_rawBits, v0[1]);
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Substring@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X2>, uint64_t a4@<X8>)
{
  Swift::String::Index_optional v6 = Substring.index(_:offsetBy:limitedBy:)( (Swift::String::Index)a1->_rawBits,  a2,  (Swift::String::Index)a3->_rawBits);
  *(void *)a4 = v6.value._rawBits;
  *(_BYTE *)(a4 + 8) = v6.is_nil;
  return v6.value;
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance Substring( Swift::String::Index *a1, Swift::String::Index *a2)
{
  return Substring.distance(from:to:)((Swift::String::Index)a1->_rawBits, (Swift::String::Index)a2->_rawBits);
}

uint64_t protocol witness for Collection.index(after:) in conformance Substring@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance Substring( a1,  (uint64_t (*)(void, void, void, void, void))Substring.index(after:),  a2);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Substring@<X0>( void *a1@<X0>, uint64_t (*a2)(void, void, void, void, void)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*a1, *v3, v3[1], v3[2], v3[3]);
  *a3 = result;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance Substring( uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring( a1,  a2,  a3,  (uint64_t (*)(uint64_t, void, void, void, void))Substring.index(after:));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, void, void, void, void))
{
  uint64_t result = a4(*a1, *v4, v4[1], v4[2], v4[3]);
  *a1 = result;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring( a1,  a2,  (uint64_t (*)(void, void, void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

uint64_t _StringGuts._opaqueCharacterStride(endingAt:in:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a1;
  if ((a5 & 0x1000000000000000LL) != 0) {
    JUMPOUT(0x181633BD0LL);
  }
  if ((a5 & 0x2000000000000000LL) != 0)
  {
    v91[0] = a4;
    v91[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    if (a2 >= a1) {
      goto LABEL_181;
    }
    uint64_t v14 = a1 - 1;
    if ((*((_BYTE *)v91 + a1 - 1) & 0xC0) == 0x80)
    {
      uint64_t v15 = a1;
      do
        int v16 = v90[v15--] & 0xC0;
      while (v16 == 128);
      uint64_t v14 = v15 - 1;
    }

    uint64_t v89 = a1;
    unsigned int v17 = _decodeScalar(_:startingAt:)((uint64_t)v91, a2, v14);
    if (v14 <= a2)
    {
      uint64_t v19 = v14;
      goto LABEL_18;
    }

    unsigned int v18 = v17;
    while (1)
    {
      unsigned int v21 = v18;
      uint64_t v19 = v14;
      uint64_t v22 = v14 - 1;
      unsigned int v18 = *((unsigned __int8 *)v91 + --v14);
      if ((v18 & 0xC0) == 0x80)
      {
        uint64_t v23 = v19;
        do
          unsigned int v18 = v90[v23--];
        while ((v18 & 0xC0) == 0x80);
        uint64_t v14 = v23 - 1;
      }

      if ((v18 & 0x80) != 0) {
        __asm { BR              X9 }
      }

      if (v18 == 13 && v21 == 10) {
        goto LABEL_21;
      }
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32( (uint32x4_t)xmmword_1817FFE70,  (uint32x4_t)vaddq_s32( vdupq_n_s32(v21),  (int32x4_t)xmmword_1817FFE60)))) & 1) != 0 || v21 - 8208 < 0x1A || v21 - 12288 < 0x2A || v21 - 65281 < 0x9D || v21 - 12439 > 0xFFFFFFA9 || v21 < 0x300 || v21 - 42192 > 0xFFFF8F2F)
      {
        goto LABEL_18;
      }

      unsigned __int8 v25 = Unicode._GraphemeBreakProperty.init(from:)(v18);
      unsigned __int8 v26 = Unicode._GraphemeBreakProperty.init(from:)(v21);
      if (v25)
      {
        if (v25 == 1) {
          goto LABEL_18;
        }
        switch(v26)
        {
          case 1u:
            goto LABEL_18;
          case 2u:
          case 9u:
          case 0xCu:
            break;
          case 4u:
            switch(v25)
            {
              case 4u:
              case 7u:
                goto LABEL_21;
              case 8u:
                goto LABEL_176;
              case 0xCu:
                goto LABEL_67;
              default:
                goto LABEL_81;
            }

          case 5u:
            switch(v25)
            {
              case 4u:
              case 7u:
                goto LABEL_21;
              case 8u:
                goto LABEL_176;
              case 0xCu:
                goto LABEL_67;
              default:
                goto LABEL_81;
            }

          case 6u:
            switch(v25)
            {
              case 4u:
              case 7u:
                goto LABEL_21;
              case 8u:
                goto LABEL_176;
              case 0xCu:
                goto LABEL_67;
              default:
                goto LABEL_81;
            }

          case 0xAu:
            int v34 = v25;
            if (v25 > 0xCu) {
              goto LABEL_81;
            }
            if (((1 << v25) & 0xCE0) == 0) {
              goto LABEL_66;
            }
            break;
          case 0xBu:
            int v34 = v25;
            if (v25 > 0xCu) {
              goto LABEL_81;
            }
            if (((1 << v25) & 0x8B0) != 0) {
              break;
            }
LABEL_66:
            if (v34 == 12) {
              goto LABEL_67;
            }
            if (v34 != 8) {
              goto LABEL_81;
            }
            goto LABEL_176;
          default:
            if (v25 == 7) {
              break;
            }
            if (v25 == 8)
            {
              if (v26 != 8) {
                goto LABEL_176;
              }
              if ((*((_BYTE *)v91 + v22) & 0xC0) == 0x80)
              {
                uint64_t v36 = v19;
                do
                  int v37 = v90[v36--] & 0xC0;
                while (v37 == 128);
                uint64_t v22 = v36 - 1;
              }

              _decodeScalar(_:startingAt:)((uint64_t)v91, v27, v22);
              uint64_t v38 = 0LL;
              while (1)
              {
                unsigned int v39 = specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( v22,  a2,  (uint64_t)v91);
                if ((v41 & 1) != 0) {
                  break;
                }
                uint64_t v22 = v40;
                BOOL v42 = __OFADD__(v38++, 1LL);
                if (v42)
                {
                  __break(1u);
LABEL_182:
                  __break(1u);
                  JUMPOUT(0x18161BA78LL);
                }
              }

              if ((v38 & 1) != 0) {
                goto LABEL_18;
              }
            }

            else
            {
              if (v25 == 12)
              {
                if (v26 == 3)
                {
                  if ((*((_BYTE *)v91 + v22) & 0xC0) == 0x80)
                  {
                    uint64_t v28 = v19;
                    do
                      int v29 = v90[v28--] & 0xC0;
                    while (v29 == 128);
                    uint64_t v22 = v28 - 1;
                  }

                  _decodeScalar(_:startingAt:)((uint64_t)v91, v27, v22);
                  do
                  {
                    unsigned int v30 = specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( v22,  a2,  (uint64_t)v91);
                    if ((v32 & 1) != 0) {
                      goto LABEL_18;
                    }
                    uint64_t v22 = v31;
                    int v33 = Unicode._GraphemeBreakProperty.init(from:)(v30);
                  }

                  while (v33 == 2);
                  if (v33 != 3) {
                    goto LABEL_18;
                  }
                  break;
                }

uint64_t Substring.customMirror.getter@<X0>( Swift::String::Index a1@<X0>, Swift::String::Index a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v5 = a4;
  uint64_t v6 = a3;
  uint64_t v8 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 16 || a2._rawBits >> 16 != v8)
  {
    uint64_t v6 = specialized static String._copying(_:)(a1, a2, a3, a4);
    uint64_t v5 = v9;
  }

  else
  {
    swift_bridgeObjectRetain(a4, a2._rawBits, a3, (char *)a4);
  }

  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( v6,  v5,  8,  0LL,  0LL,  a5);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Substring@<X0>( uint64_t a1@<X8>)
{
  return Substring.customMirror.getter((Swift::String::Index)v1->_rawBits, v1[1], v1[2]._rawBits, v1[3]._rawBits, a1);
}

uint64_t Substring.description.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3;
  uint64_t v5 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v5 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 16 || a2._rawBits >> 16 != v5) {
    return specialized static String._copying(_:)(a1, a2, a3, a4);
  }
  swift_bridgeObjectRetain(a4, a2._rawBits, a3, (char *)a4);
  return v4;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Substring()
{
  v1._Swift::UInt64 rawBits = *v0;
  v2._Swift::UInt64 rawBits = v0[1];
  return specialized String.init(_:)(v1, v2, v0[2], v0[3]);
}

uint64_t Substring.debugDescription.getter( Swift::String::Index a1, Swift::String::Index x1_0, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = HIBYTE(a4) & 0xF;
  uint64_t v242 = a3;
  uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000LL) != 0) {
    uint64_t v7 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v7 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 16 || x1_0._rawBits >> 16 != v7)
  {
    uint64_t v10 = specialized static String._copying(_:)(a1, x1_0, a3, a4);
    uint64_t v4 = v11;
    uint64_t v5 = HIBYTE(v11) & 0xF;
    uint64_t v242 = v10;
    uint64_t v6 = v10 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    swift_bridgeObjectRetain(a4, x1_0._rawBits, a3, (char *)a4);
  }

  *(void *)&unsigned __int128 v248 = 34LL;
  *((void *)&v248 + 1) = 0xE100000000000000LL;
  if ((v4 & 0x2000000000000000LL) != 0) {
    uint64_t v12 = v5;
  }
  else {
    uint64_t v12 = v6;
  }
  uint64_t v241 = v12;
  if (!v12)
  {
    swift_bridgeObjectRelease(v4);
LABEL_209:
    uint64_t v188 = 0xE100000000000000LL;
    uint64_t v246 = 34LL;
    uint64_t v247 = 0xE100000000000000LL;
    uint64_t v189 = v248;
    unint64_t v190 = (void *)*((void *)&v248 + 1);
    unint64_t v191 = HIBYTE(*((void *)&v248 + 1)) & 0xFLL;
    if ((*((void *)&v248 + 1) & 0x2000000000000000LL) == 0) {
      unint64_t v191 = v248 & 0xFFFFFFFFFFFFLL;
    }
    if (!v191)
    {
LABEL_264:
      swift_bridgeObjectRelease(v188);
      return v189;
    }

    while (1)
    {
      uint64_t v196 = v246;
      uint64_t v197 = v247;
      swift_bridgeObjectRetain(v247, v185, v186, v187);
      unint64_t v198 = specialized Collection.first.getter(v196, v197);
      swift_bridgeObjectRelease(v197);
      if ((v198 & 0x100000000LL) != 0)
      {
        unint64_t v236 = 839LL;
LABEL_275:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  v236,  0);
      }

      *(void *)&unsigned __int128 v245 = v189;
      *((void *)&v245 + 1) = v190;
      *(void *)&unsigned __int128 v248 = 0LL;
      *((void *)&v248 + 1) = 0xE000000000000000LL;
      unint64_t v199 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v198);
      uint64_t v201 = v200;
      _StringGuts.append(_:)(v199, v200);
      swift_bridgeObjectRelease(v201);
      unint64_t v22 = *((void *)&v245 + 1);
      uint64_t v34 = v245;
      swift_bridgeObjectRetain(*((unint64_t *)&v245 + 1), v202, v203, v204);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unsigned __int128 v248 = __PAIR128__(v22, v34);
      uint64_t v208 = HIBYTE(v22) & 0xF;
      if ((v22 & 0x2000000000000000LL) == 0) {
        uint64_t v208 = v34;
      }
      uint64_t v209 = 7LL;
      if (((v22 >> 60) & ((v34 & 0x800000000000000LL) == 0)) != 0) {
        uint64_t v209 = 11LL;
      }
      v210._Swift::UInt64 rawBits = v209 | (v208 << 16);
      swift_bridgeObjectRetain(v22, v205, v206, v207);
      v211._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(v210)._rawBits;
      Swift::UInt64 rawBits = v211._rawBits;
      if (v211._rawBits >> 14)
      {
        uint64_t v213 = v211._rawBits >> 16;
        if (v211._rawBits < 0x20000) {
          goto LABEL_240;
        }
        if ((v22 & 0x1000000000000000LL) != 0) {
          goto LABEL_239;
        }
        if ((v22 & 0x2000000000000000LL) != 0)
        {
          *(void *)&unsigned __int128 v245 = v34;
          *((void *)&v245 + 1) = v22 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v215 = (char *)&v245 + v213;
        }

        else
        {
          if ((v34 & 0x1000000000000000LL) != 0)
          {
            uint64_t v214 = (char *)((v22 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            uint64_t v214 = (char *)_StringObject.sharedUTF8.getter(v34, v22);
            if (!v214) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            }
          }

          uint64_t v215 = &v214[v213];
        }

        int v216 = *((unsigned __int16 *)v215 - 1);
        if (v216 == 2573 || (v216 & 0x80808080) != 0)
        {
LABEL_239:
          uint64_t v213 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(rawBits >> 16);
LABEL_240:
          if (v213 <= 63) {
            uint64_t v218 = v213 << 8;
          }
          else {
            uint64_t v218 = 63LL;
          }
          goto LABEL_243;
        }

        uint64_t v213 = 1LL;
      }

      else
      {
        if (_swift_stdlib_isExecutableLinkedOnOrAfter(0x50700u)) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringCharacterView.swift",  31LL,  2,  0x62uLL,  0);
        }
        uint64_t v213 = 0LL;
      }

      uint64_t v218 = v213 << 8;
LABEL_243:
      v219._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v210)._rawBits;
      if (!(v219._rawBits >> 14)) {
        goto LABEL_269;
      }
      Swift::UInt64 v220 = v219._rawBits;
      swift_bridgeObjectRelease(v22);
      if ((v22 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v225 = String.UnicodeScalarView._foreignIndex(before:)((Swift::String::Index)v220)._rawBits;
        swift_bridgeObjectRelease(v22);
      }

      else
      {
        if ((v22 & 0x2000000000000000LL) != 0)
        {
          uint64_t v222 = 0LL;
          *(void *)&unsigned __int128 v245 = v34;
          *((void *)&v245 + 1) = v22 & 0xFFFFFFFFFFFFFFLL;
          do
            int v224 = *(&v244 + (v220 >> 16) + v222--) & 0xC0;
          while (v224 == 128);
        }

        else
        {
          if ((v34 & 0x1000000000000000LL) != 0) {
            Swift::UInt64 v221 = (char *)((v22 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            Swift::UInt64 v221 = (char *)_StringObject.sharedUTF8.getter(v34, v22);
          }
          uint64_t v222 = 0LL;
          do
            int v223 = v221[(v220 >> 16) - 1 + v222--] & 0xC0;
          while (v223 == 128);
        }

        swift_bridgeObjectRelease(v22);
        Swift::UInt64 v225 = (v220 - -65536 * v222) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (((rawBits - (v213 << 16)) & 0xFFFFFFFFFFFF0000LL | v218) >> 14 >= v225 >> 14) {
        goto LABEL_262;
      }
      *(void *)&unsigned __int128 v245 = v34;
      *((void *)&v245 + 1) = v22;
      specialized RangeReplaceableCollection<>.removeLast()();
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unsigned int v226 = specialized RangeReplaceableCollection<>.removeLast()();
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unsigned __int128 v248 = v245;
      Swift::String_optional v228 = Unicode.Scalar._escaped(asASCII:)(1);
      unint64_t object = v228.value._object;
      if (v228.value._object) {
        uint64_t countAndFlagsBits = v228.value._countAndFlagsBits;
      }
      else {
        uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v226);
      }
      unint64_t v229 = (unint64_t)object;
      v193._Swift::UInt64 rawBits = 15LL;
      v194._Swift::UInt64 rawBits = 15LL;
      specialized String.UnicodeScalarView.replaceSubrange<A>(_:with:)(v193, v194, countAndFlagsBits, v229);
      swift_bridgeObjectRelease(v229);
      uint64_t v189 = v248;
      unint64_t v190 = (void *)*((void *)&v248 + 1);
      unint64_t v195 = HIBYTE(*((void *)&v248 + 1)) & 0xFLL;
      if ((*((void *)&v248 + 1) & 0x2000000000000000LL) == 0) {
        unint64_t v195 = v248 & 0xFFFFFFFFFFFFLL;
      }
      if (!v195)
      {
        uint64_t v188 = v247;
        goto LABEL_264;
      }
    }
  }

  uint64_t v237 = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
  uint64_t v238 = v4 & 0xFFFFFFFFFFFFFFLL;
  swift_bridgeObjectRetain_n(v4, 3LL, v8, v9);
  uint64_t v13 = 0LL;
  uint64_t v240 = v4;
  char v14 = 1;
  while (1)
  {
    if ((v4 & 0x1000000000000000LL) != 0)
    {
      Swift::tuple_Unicode_Scalar_scalarLength_Int v18 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v13 << 16));
      Swift::Int scalarLength = v18.scalarLength;
      Swift::UInt32 value = v18._0._value;
    }

    else
    {
      if ((v4 & 0x2000000000000000LL) != 0)
      {
        uint64_t v246 = v242;
        uint64_t v247 = v238;
        Swift::UInt32 value = *((unsigned __int8 *)&v246 + v13);
        if (*((char *)&v246 + v13) < 0) {
          __asm { BR              X9 }
        }
      }

      else
      {
        uint64_t v15 = (unsigned __int8 *)v237;
        if ((v242 & 0x1000000000000000LL) == 0) {
          uint64_t v15 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v242, v4);
        }
        Swift::UInt32 value = v15[v13];
        if ((char)v15[v13] < 0) {
          __asm { BR              X9 }
        }
      }

      Swift::Int scalarLength = 1LL;
    }

    v13 += scalarLength;
    unsigned __int128 v21 = (unsigned __int128)Unicode.Scalar._escaped(asASCII:)(0);
    if (*((void *)&v21 + 1)) {
      break;
    }
    uint64_t v243 = v13;
    uint64_t v60 = v248;
    unint64_t v59 = *((void *)&v248 + 1);
    if ((v14 & 1) == 0) {
      goto LABEL_54;
    }
    LODWORD(v246) = 0;
    swift_bridgeObjectRetain(*((unint64_t *)&v248 + 1), 0LL, v19, v20);
    unint64_t v61 = specialized BidirectionalCollection.last.getter(v60, v59);
    swift_bridgeObjectRelease(v59);
    if ((v61 & 0x100000000LL) != 0)
    {
      unint64_t v236 = 816LL;
      goto LABEL_275;
    }

    if (_GraphemeBreakingState.shouldBreak(between:and:)((Swift::Unicode::Scalar)v61, (Swift::Unicode::Scalar)value))
    {
LABEL_54:
      uint64_t v246 = v60;
      uint64_t v247 = v59;
      *(void *)&unsigned __int128 v248 = 0LL;
      *((void *)&v248 + 1) = 0xE000000000000000LL;
      uint64_t v65 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
      unint64_t v66 = v62;
      uint64_t v67 = v62 & 0x2000000000000000LL;
      uint64_t v68 = HIBYTE(v62) & 0xF;
      uint64_t v69 = HIBYTE(v59) & 0xF;
      if ((v59 & 0x2000000000000000LL) == 0 || !v67) {
        goto LABEL_58;
      }
      if ((unint64_t)(v68 + v69) > 0xF)
      {
        uint64_t v67 = 1LL;
LABEL_58:
        if (v67) {
          uint64_t v70 = HIBYTE(v62) & 0xF;
        }
        else {
          uint64_t v70 = v65 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain(v62, v62, v63, v64);
        uint64_t v239 = v70;
        if ((v66 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRetain_n(v66, 5LL, v71, v72);
          v171._Swift::UInt64 rawBits = 1LL;
          v172._Swift::UInt64 rawBits = (v70 << 16) | 1;
          v173._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v171, v172, v65, v66);
          if (v173._rawBits < 0x10000) {
            v173._rawBits |= 3;
          }
          uint64_t v70 = specialized Collection.count.getter(v173, v174, v65, v66);
          swift_bridgeObjectRelease(v66);
          if ((v59 & 0x1000000000000000LL) == 0) {
            goto LABEL_63;
          }
        }

        else
        {
          swift_bridgeObjectRetain_n(v66, 4LL, v71, v72);
          if ((v59 & 0x1000000000000000LL) == 0)
          {
LABEL_63:
            if ((v59 & 0x2000000000000000LL) != 0) {
              uint64_t v73 = HIBYTE(v59) & 0xF;
            }
            else {
              uint64_t v73 = v60 & 0xFFFFFFFFFFFFLL;
            }
            Swift::Int v74 = v73 + v70;
            if (__OFADD__(v73, v70))
            {
LABEL_266:
              __break(1u);
LABEL_267:
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
            }

LABEL_155:
            uint64_t v4 = v240;
            swift_bridgeObjectRelease_n(v66, 5LL);
            unint64_t v140 = v246;
            if (v112)
            {
              if ((v79 & 0x1000000000000000LL) != 0)
              {
                unint64_t v140 = _StringGuts._foreignConvertedToSmall()(v246, v75);
                unint64_t v79 = v182;
              }

              else
              {
                if ((v246 & 0x1000000000000000LL) != 0)
                {
                  Swift::String::Index v176 = (unsigned __int8 *)((v79 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v177 = v246 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  Swift::String::Index v176 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v246, v75);
                  uint64_t v177 = v137;
                }

                swift_bridgeObjectRetain(v75, v137, v138, v139);
                closure #1 in _StringGuts._convertedToSmall()(v176, v177, &v245);
                swift_bridgeObjectRelease(v75);
                unint64_t v79 = *((void *)&v245 + 1);
                unint64_t v140 = v245;
              }
            }

            v141._Swift::UInt64 rawBits = (v239 << 16) | 1;
            v142._Swift::UInt64 rawBits = 1LL;
            v143._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v142, v141, v65, v66);
            if (v143._rawBits < 0x10000) {
              v143._rawBits |= 3;
            }
            unint64_t v145 = specialized String.init(_:)(v143, v144, v65, v66);
            unint64_t v147 = v146;
            swift_bridgeObjectRelease(v66);
            if ((v147 & 0x2000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v147);
            }

            else if ((v147 & 0x1000000000000000LL) != 0)
            {
              unint64_t v145 = _StringGuts._foreignConvertedToSmall()(v145, v147);
              unint64_t v184 = v183;
              swift_bridgeObjectRelease(v147);
              unint64_t v147 = v184;
            }

            else
            {
              if ((v145 & 0x1000000000000000LL) != 0)
              {
                Swift::String::Index v178 = (unsigned __int8 *)((v147 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v179 = v145 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                Swift::String::Index v178 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v145, v147);
              }

              closure #1 in _StringGuts._convertedToSmall()(v178, v179, &v245);
              swift_bridgeObjectRelease(v147);
              unint64_t v147 = *((void *)&v245 + 1);
              unint64_t v145 = v245;
            }

            uint64_t v148 = HIBYTE(v79) & 0xF;
            uint64_t v149 = HIBYTE(v147) & 0xF;
            uint64_t v150 = v149 + v148;
            if ((unint64_t)(v149 + v148) > 0xF)
            {
LABEL_271:
              unint64_t v235 = 266LL;
              goto LABEL_273;
            }

            if (v149)
            {
              char v151 = 0;
              unint64_t v152 = 0LL;
              do
              {
                unint64_t v153 = v148 + v152;
                unint64_t v154 = v152 + 1;
                if (v152 >= 8) {
                  unint64_t v155 = v147;
                }
                else {
                  unint64_t v155 = v145;
                }
                unint64_t v156 = v155 >> (v151 & 0x38);
                char v157 = (8 * v148 + v151) & 0x38;
                uint64_t v158 = (-255LL << v157) - 1;
                unint64_t v159 = (unint64_t)v156 << v157;
                unint64_t v160 = v159 | v158 & v79;
                unint64_t v161 = v159 | v158 & v140;
                if (v153 < 8) {
                  unint64_t v140 = v161;
                }
                else {
                  unint64_t v79 = v160;
                }
                v151 += 8;
                unint64_t v152 = v154;
              }

              while (v149 != v154);
            }

            swift_bridgeObjectRelease(v75);
            unint64_t v162 = 0xE000000000000000LL;
            if (v140 & 0x8080808080808080LL | v79 & 0x80808080808080LL) {
              unint64_t v162 = 0xA000000000000000LL;
            }
            uint64_t v246 = v140;
            uint64_t v247 = v162 & 0xFF00000000000000LL | (v150 << 56) | v79 & 0xFFFFFFFFFFFFFFLL;
LABEL_177:
            uint64_t v13 = v243;
            goto LABEL_178;
          }
        }

        Swift::Int v175 = String.UTF8View._foreignCount()();
        Swift::Int v74 = v175 + v70;
        if (__OFADD__(v175, v70)) {
          goto LABEL_266;
        }
        goto LABEL_67;
      }

      swift_bridgeObjectRelease(v62);
      if (v68)
      {
        char v116 = 0;
        unint64_t v117 = 0LL;
        unint64_t v118 = v59;
        do
        {
          unint64_t v119 = v69 + v117;
          unint64_t v120 = v117 + 1;
          if (v117 >= 8) {
            unint64_t v121 = v66;
          }
          else {
            unint64_t v121 = v65;
          }
          unint64_t v122 = v121 >> (v116 & 0x38);
          char v123 = (8 * v69 + v116) & 0x38;
          uint64_t v124 = (-255LL << v123) - 1;
          unint64_t v125 = (unint64_t)v122 << v123;
          unint64_t v126 = v125 | v124 & v118;
          unint64_t v127 = v125 | v124 & v60;
          if (v119 < 8) {
            uint64_t v60 = v127;
          }
          else {
            unint64_t v118 = v126;
          }
          v116 += 8;
          unint64_t v117 = v120;
        }

        while (v68 != v120);
      }

      else
      {
        unint64_t v118 = v59;
      }

      swift_bridgeObjectRelease(v59);
      unint64_t v163 = 0xE000000000000000LL;
      if (v60 & 0x8080808080808080LL | v118 & 0x80808080808080LL) {
        unint64_t v163 = 0xA000000000000000LL;
      }
      uint64_t v246 = v60;
      uint64_t v247 = v163 & 0xFF00000000000000LL | ((v68 + v69) << 56) | v118 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v4 = v240;
      goto LABEL_177;
    }

    Swift::String_optional v103 = Unicode.Scalar._escaped(asASCII:)(1);
    unint64_t v100 = (unint64_t)v103.value._object;
    if (v103.value._object) {
      uint64_t v104 = v103.value._countAndFlagsBits;
    }
    else {
      uint64_t v104 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
    }
    unint64_t v105 = v100;
    uint64_t v128 = HIBYTE(v59) & 0xF;
    if ((v59 & 0x2000000000000000LL) == 0) {
      uint64_t v128 = v60 & 0xFFFFFFFFFFFFLL;
    }
    if (!v128 && (v60 & ~v59 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v59);
      *(void *)&unsigned __int128 v248 = v104;
      *((void *)&v248 + 1) = v105;
      goto LABEL_14;
    }

    if ((v59 & 0x2000000000000000LL) == 0)
    {
      if ((v100 & 0x2000000000000000LL) != 0) {
LABEL_152:
      }
        uint64_t v129 = HIBYTE(v105) & 0xF;
      else {
LABEL_146:
      }
        uint64_t v129 = v104 & 0xFFFFFFFFFFFFLL;
      swift_bridgeObjectRetain(v105, v100, v101, v102);
      _StringGuts.append(_:)(v104, v105, 0LL, v129);
      swift_bridgeObjectRelease_n(v105, 2LL);
      goto LABEL_14;
    }

    if ((v100 & 0x2000000000000000LL) == 0) {
      goto LABEL_146;
    }
    unint64_t v134 = specialized _SmallString.init(_:appending:)(v60, v59, v104, v100);
    if ((v101 & 1) != 0) {
      goto LABEL_152;
    }
    uint64_t v135 = v134;
    unint64_t v136 = v100;
    swift_bridgeObjectRelease(v59);
    swift_bridgeObjectRelease(v105);
    *(void *)&unsigned __int128 v248 = v135;
    *((void *)&v248 + 1) = v136;
LABEL_14:
    uint64_t v13 = v243;
LABEL_15:
    char v14 = 1;
LABEL_16:
    if (v13 >= v241)
    {
      swift_bridgeObjectRelease_n(v4, 4LL);
      goto LABEL_209;
    }
  }

  uint64_t v23 = v248;
  unint64_t v22 = *((void *)&v248 + 1);
  unint64_t v24 = HIBYTE(*((void *)&v248 + 1)) & 0xFLL;
  if ((*((void *)&v248 + 1) & 0x2000000000000000LL) != 0) {
    unint64_t v25 = HIBYTE(*((void *)&v248 + 1)) & 0xFLL;
  }
  else {
    unint64_t v25 = v248 & 0xFFFFFFFFFFFFLL;
  }
  if (!v25 && ((unint64_t)v248 & ~*((void *)&v248 + 1) & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(*((uint64_t *)&v248 + 1));
    unsigned __int128 v248 = v21;
    goto LABEL_15;
  }

  uint64_t v26 = *((void *)&v21 + 1) & 0x2000000000000000LL;
  unint64_t v27 = HIBYTE(*((void *)&v21 + 1)) & 0xFLL;
  if ((*((void *)&v21 + 1) & 0x2000000000000000LL & *((void *)&v248 + 1)) != 0)
  {
    unint64_t v28 = v24 + v27;
    if (v24 + v27 <= 0xF)
    {
      if (v27)
      {
        char v88 = 0;
        unint64_t v89 = 0LL;
        unint64_t v90 = *((void *)&v248 + 1);
        do
        {
          unint64_t v91 = v24 + v89;
          unint64_t v92 = v89 + 1;
          if (v89 >= 8) {
            unint64_t v93 = *((void *)&v21 + 1);
          }
          else {
            unint64_t v93 = v21;
          }
          unint64_t v94 = v93 >> (v88 & 0x38);
          char v95 = (8 * v24 + v88) & 0x38;
          uint64_t v96 = (-255LL << v95) - 1;
          unint64_t v97 = (unint64_t)v94 << v95;
          unint64_t v98 = v97 | v96 & v90;
          unint64_t v99 = v97 | v96 & v23;
          if (v91 < 8) {
            uint64_t v23 = v99;
          }
          else {
            unint64_t v90 = v98;
          }
          v88 += 8;
          unint64_t v89 = v92;
        }

        while (v27 != v92);
      }

      else
      {
        unint64_t v90 = *((void *)&v248 + 1);
      }

      swift_bridgeObjectRelease(*((uint64_t *)&v248 + 1));
      swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
      unint64_t v113 = 0xE000000000000000LL;
      if (v23 & 0x8080808080808080LL | v90 & 0x80808080808080LL) {
        unint64_t v113 = 0xA000000000000000LL;
      }
      *(void *)&unsigned __int128 v248 = v23;
      *((void *)&v248 + 1) = v113 & 0xFF00000000000000LL | (v28 << 56) | v90 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_15;
    }
  }

  uint64_t v243 = v13;
  if (v26) {
    uint64_t v29 = HIBYTE(*((void *)&v21 + 1)) & 0xFLL;
  }
  else {
    uint64_t v29 = v21 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v21 + 1), 2LL, v19, v20);
  if ((*((void *)&v21 + 1) & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain_n(*((uint64_t *)&v21 + 1), 5LL, v30, v31);
    v166._Swift::UInt64 rawBits = 1LL;
    v167._Swift::UInt64 rawBits = (v29 << 16) | 1;
    v168._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v166, v167, v21, *((unint64_t *)&v21 + 1));
    if (v168._rawBits < 0x10000) {
      v168._rawBits |= 3;
    }
    Swift::Int v32 = specialized Collection.count.getter(v168, v169, v21, *((unint64_t *)&v21 + 1));
    swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
    if ((v22 & 0x1000000000000000LL) == 0)
    {
LABEL_39:
      BOOL v33 = __OFADD__(v25, v32);
      uint64_t v34 = v25 + v32;
      if (v33) {
        goto LABEL_261;
      }
      goto LABEL_40;
    }
  }

  else
  {
    swift_bridgeObjectRetain_n(*((uint64_t *)&v21 + 1), 4LL, v30, v31);
    Swift::Int v32 = v29;
    if ((v22 & 0x1000000000000000LL) == 0) {
      goto LABEL_39;
    }
  }

  Swift::Int v170 = String.UTF8View._foreignCount()();
  uint64_t v34 = v170 + v32;
  if (!__OFADD__(v170, v32))
  {
LABEL_40:
    if ((v23 & ~v22 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v22 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v35 = _StringGuts.nativeUnusedCapacity.getter(v23, v22);
      if ((v36 & 1) != 0) {
        goto LABEL_272;
      }
      uint64_t v37 = (v22 >> 61) & 1;
      if (v35 < v32) {
        LODWORD(v37) = 1;
      }
      if (v34 > 15 || !(_DWORD)v37)
      {
LABEL_75:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v34, v32);
        swift_bridgeObjectRelease_n(*((uint64_t *)&v21 + 1), 4LL);
        if ((*((void *)&v21 + 1) & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
          _StringGuts._foreignAppendInPlace(_:)(v21, *((unint64_t *)&v21 + 1), 0LL, v29);
          swift_bridgeObjectRelease_n(*((uint64_t *)&v21 + 1), 2LL);
          uint64_t v4 = v240;
        }

        else
        {
          if (!v26)
          {
            if ((v21 & 0x1000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
              id v80 = (id)((*((void *)&v21 + 1) & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v81 = v21 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              id v80 = _StringObject.sharedUTF8.getter(v21, *((uint64_t *)&v21 + 1));
              uint64_t v81 = v180;
              swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
            }

            uint64_t v13 = v243;
            uint64_t v82 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v21 & 0xFFFFFFFFFFFFLL,  (uint64_t)v80,  v81);
            _StringGuts.appendInPlace(_:isASCII:)(v82, v83, (v21 & 0x8000000000000000LL) != 0LL);
            swift_bridgeObjectRelease_n(*((uint64_t *)&v21 + 1), 2LL);
            uint64_t v4 = v240;
            goto LABEL_15;
          }

          swift_bridgeObjectRelease_n(*((uint64_t *)&v21 + 1), 2LL);
          uint64_t v246 = v21;
          uint64_t v247 = *((void *)&v21 + 1) & 0xFFFFFFFFFFFFFFLL;
          unint64_t v114 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(*((void *)&v21 + 1)) & 0xFLL,  (uint64_t)&v246,  HIBYTE(*((void *)&v21 + 1)) & 0xFLL);
          _StringGuts.appendInPlace(_:isASCII:)(v114, v115, (*((void *)&v21 + 1) & 0x4000000000000000LL) != 0);
          uint64_t v4 = v240;
          swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
        }

        goto LABEL_14;
      }
    }

    else if (v34 > 15)
    {
      goto LABEL_75;
    }

    swift_bridgeObjectRelease_n(*((uint64_t *)&v21 + 1), 5LL);
    swift_bridgeObjectRetain(v22, v38, v39, v40);
    unint64_t v41 = _StringGuts._convertedToSmall()(v23, v22);
    unint64_t v43 = v42;
    swift_bridgeObjectRelease(v22);
    v44._Swift::UInt64 rawBits = (v29 << 16) | 1;
    v45._Swift::UInt64 rawBits = 1LL;
    v46._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v45, v44, v21, *((unint64_t *)&v21 + 1));
    if (v46._rawBits < 0x10000) {
      v46._rawBits |= 3;
    }
    unint64_t v48 = specialized String.init(_:)(v46, v47, v21, *((unint64_t *)&v21 + 1));
    unint64_t v50 = v49;
    swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
    unint64_t v51 = _StringGuts._convertedToSmall()(v48, v50);
    unint64_t v53 = v52;
    swift_bridgeObjectRelease(v50);
    unint64_t v54 = specialized _SmallString.init(_:appending:)(v41, v43, v51, v53);
    uint64_t v4 = v240;
    if ((v56 & 1) != 0) {
      goto LABEL_271;
    }
    uint64_t v57 = v54;
    unsigned int v58 = v55;
    swift_bridgeObjectRelease(v22);
    swift_bridgeObjectRelease(*((uint64_t *)&v21 + 1));
    *(void *)&unsigned __int128 v248 = v57;
    *((void *)&v248 + 1) = v58;
    goto LABEL_14;
  }

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Substring()
{
  v1._Swift::UInt64 rawBits = *v0;
  v2._Swift::UInt64 rawBits = v0[1];
  return Substring.debugDescription.getter(v1, v2, v0[2], v0[3]);
}

uint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance Substring@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = specialized Substring.init<A>(_:)();
  *a1 = result;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return result;
}

uint64_t (*Substring.UTF8View._slice.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Substring.UTF8View.subscript.getter( Swift::UInt64 rawBits, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9 = (a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v9) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  if (rawBits >> 14 < a2 >> 14 || rawBits >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/Substring.swift",  21LL,  2,  0x29BuLL,  0);
  }
  if ((a5 & 0x1000000000000000LL) != 0) {
    return String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }
  if ((a5 & 0x2000000000000000LL) != 0)
  {
    v13[0] = a4;
    v13[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    return *((unsigned __int8 *)v13 + (rawBits >> 16));
  }

  else
  {
    if ((a4 & 0x1000000000000000LL) != 0)
    {
      uint64_t v10 = (unsigned __int8 *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      Swift::UInt64 v12 = rawBits;
      uint64_t v10 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a4, a5);
      Swift::UInt64 rawBits = v12;
    }

    return v10[rawBits >> 16];
  }

Swift::String::Index __swiftcall Substring.UTF8View.index(after:)(Swift::String::Index after)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((after._rawBits & 0xC) == 4LL << v5)
  {
    after._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(after)._rawBits;
    if ((v3 & 0x1000000000000000LL) == 0) {
      return (Swift::String::Index)((after._rawBits & 0xFFFFFFFFFFFF0000LL) + 65540);
    }
  }

  else if ((v2 & 0x1000000000000000LL) == 0)
  {
    return (Swift::String::Index)((after._rawBits & 0xFFFFFFFFFFFF0000LL) + 65540);
  }

  Swift::UInt64 v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v7 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 <= after._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
  }
  return String.UTF8View._foreignIndex(after:)(after);
}

Swift::Void __swiftcall Substring.UTF8View.formIndex(after:)(Swift::String::Index *after)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  Swift::UInt64 rawBits = after->_rawBits;
  uint64_t v7 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v7)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if ((v3 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
  }

  else if ((v2 & 0x1000000000000000LL) == 0)
  {
LABEL_5:
    unint64_t v8 = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
    goto LABEL_6;
  }

  unint64_t v9 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v9 <= rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
  }
  unint64_t v8 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_6:
  after->_Swift::UInt64 rawBits = v8;
}

Swift::String::Index __swiftcall Substring.UTF8View.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  uint64_t v7 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((_._rawBits & 0xC) == 4LL << v7)
  {
    _._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
    if ((v4 & 0x1000000000000000LL) == 0)
    {
LABEL_5:
      Swift::UInt64 v8 = offsetBy + (_._rawBits >> 16);
      if (__OFADD__(offsetBy, _._rawBits >> 16))
      {
        __break(1u);
      }

      else if ((v8 & 0x8000000000000000LL) == 0)
      {
        unint64_t v9 = HIBYTE(v4) & 0xF;
        if ((v4 & 0x2000000000000000LL) == 0) {
          unint64_t v9 = v5 & 0xFFFFFFFFFFFFLL;
        }
        if (v9 >= v8) {
          return (Swift::String::Index)((v8 << 16) | 4);
        }
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xA7uLL,  0);
    }
  }

  else if ((v3 & 0x1000000000000000LL) == 0)
  {
    goto LABEL_5;
  }

  return String.UTF8View._foreignIndex(_:offsetBy:)(_, offsetBy);
}

Swift::String::Index_optional __swiftcall Substring.UTF8View.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  unint64_t v6 = v3;
  uint64_t v9 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((_._rawBits & 0xC) != 4LL << v9)
  {
    if ((v4 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
LABEL_19:
    Swift::String::Index_optional v13 = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy);
    v13.is_nil &= 1u;
    return v13;
  }

  _._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_19;
  }
LABEL_5:
  Swift::UInt64 v10 = _._rawBits >> 16;
  int64_t v11 = (_._rawBits >> 16) + offsetBy;
  if (__OFADD__(_._rawBits >> 16, offsetBy))
  {
    __break(1u);
    goto LABEL_21;
  }

  Swift::UInt64 v12 = limitedBy._rawBits >> 16;
  if (offsetBy < 0)
  {
  }

  else if (v12 < v10 || (uint64_t)v12 >= v11)
  {
LABEL_13:
    if ((v11 & 0x8000000000000000LL) == 0)
    {
      unint64_t v14 = HIBYTE(v5) & 0xF;
      if ((v5 & 0x2000000000000000LL) == 0) {
        unint64_t v14 = v6 & 0xFFFFFFFFFFFFLL;
      }
      if (v14 >= v11)
      {
        v13.Swift::Bool is_nil = 0;
        v13.value._Swift::UInt64 rawBits = (v11 << 16) | 4;
        return v13;
      }
    }

Swift::Int __swiftcall Substring.UTF8View.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  unint64_t v4 = v3;
  unint64_t v5 = v2;
  Swift::UInt64 rawBits = from._rawBits;
  uint64_t v8 = (v2 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = 4LL << v8;
  if ((from._rawBits & 0xC) == 4LL << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(from)._rawBits;
  }
  if ((to._rawBits & 0xC) == v9)
  {
    to._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
    if ((v4 & 0x1000000000000000LL) == 0) {
      return (to._rawBits >> 16) - (rawBits >> 16);
    }
  }

  else if ((v4 & 0x1000000000000000LL) == 0)
  {
    return (to._rawBits >> 16) - (rawBits >> 16);
  }

  unint64_t v11 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    unint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < rawBits >> 16 || v11 < to._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }
  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, to);
}

uint64_t Substring.UTF8View.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t)@<X0>, Swift::UInt64 a2@<X2>, Swift::UInt64 a3@<X3>, uint64_t a4@<X4>, unint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  return _ss5SliceV32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys5UInt8Vqd__Isgyrzo_ABySS8UTF8ViewVGADsAI_pAMRszr__lIetMggrzo_Tpq5( a1,  a2,  a3,  a4,  a5,  a6,  a7);
}

unint64_t Substring.UTF8View._failEarlyRangeCheck(_:bounds:)( unint64_t a1, unint64_t a2, unint64_t a3)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3);
}

unint64_t Substring.UTF8View._failEarlyRangeCheck(_:bounds:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4);
}

Swift::String::Index __swiftcall Substring.UTF8View.index(before:)(Swift::String::Index before)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((before._rawBits & 0xC) != 4LL << v5)
  {
    if (before._rawBits >> 14) {
      goto LABEL_5;
    }
LABEL_8:
    unint64_t v7 = 152LL;
    goto LABEL_9;
  }

  before._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(before)._rawBits;
  if (!(before._rawBits >> 14)) {
    goto LABEL_8;
  }
LABEL_5:
  if ((v3 & 0x1000000000000000LL) == 0) {
    return (Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000LL) - 65532);
  }
  Swift::UInt64 v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    Swift::UInt64 v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 < before._rawBits >> 16)
  {
    unint64_t v7 = 157LL;
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v7,  0);
  }

  return String.UTF8View._foreignIndex(before:)(before);
}

Swift::Void __swiftcall Substring.UTF8View.formIndex(before:)(Swift::String::Index *before)
{
  unint64_t v3 = v2;
  unint64_t v4 = v1;
  Swift::UInt64 rawBits = before->_rawBits;
  uint64_t v7 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) != 4LL << v7)
  {
    if (rawBits >> 14) {
      goto LABEL_5;
    }
LABEL_9:
    unint64_t v9 = 152LL;
    goto LABEL_10;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if (!(rawBits >> 14)) {
    goto LABEL_9;
  }
LABEL_5:
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    unint64_t v10 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000LL) == 0) {
      unint64_t v10 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (v10 >= rawBits >> 16)
    {
      unint64_t v8 = String.UTF8View._foreignIndex(before:)((Swift::String::Index)rawBits)._rawBits;
      goto LABEL_7;
    }

    unint64_t v9 = 157LL;
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v9,  0);
  }

  unint64_t v8 = (rawBits & 0xFFFFFFFFFFFF0000LL) - 65532;
LABEL_7:
  before->_Swift::UInt64 rawBits = v8;
}

Swift::UInt64 Substring.UTF16View.subscript.getter( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 v6 = specialized Substring.UTF8View.subscript.getter(a1, a2, a3, a4, a5, a6);
  swift_bridgeObjectRetain((unint64_t)v9, v7, v8, v9);
  return v6;
}

Swift::String::Index protocol witness for BidirectionalCollection.index(before:) in conformance Substring.UTF8View@<X0>( Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF8View.index(before:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

void protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring.UTF8View( Swift::String::Index *before)
{
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Substring.UTF8View@<X0>( Swift::Int offsetBy@<X1>, Swift::UInt64 *a2@<X0>, Swift::UInt64 *a3@<X8>)
{
  Swift::UInt64 rawBits = *a2;
  unint64_t v8 = *(void *)(v3 + 16);
  unint64_t v7 = *(void *)(v3 + 24);
  uint64_t v9 = (v8 >> 59) & 1;
  if ((v7 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  if ((rawBits & 0xC) != 4LL << v9)
  {
    if ((v7 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
LABEL_13:
    Swift::UInt64 result = String.UTF8View._foreignIndex(_:offsetBy:)((Swift::String::Index)rawBits, offsetBy)._rawBits;
    goto LABEL_11;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if ((v7 & 0x1000000000000000LL) != 0) {
    goto LABEL_13;
  }
LABEL_5:
  unint64_t v10 = offsetBy + (rawBits >> 16);
  if (__OFADD__(offsetBy, rawBits >> 16))
  {
    __break(1u);
    goto LABEL_15;
  }

  if ((v10 & 0x8000000000000000LL) != 0) {
    goto LABEL_15;
  }
  unint64_t v11 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) == 0) {
    unint64_t v11 = v8 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < v10) {
LABEL_15:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xA7uLL,  0);
  Swift::UInt64 result = (v10 << 16) | 4;
LABEL_11:
  *a3 = result;
  return result;
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View@<X0>( Swift::Int offsetBy@<X1>, Swift::UInt64 *a2@<X0>, Swift::UInt64 *a3@<X2>, uint64_t a4@<X8>)
{
  Swift::UInt64 rawBits = *a2;
  v8._Swift::UInt64 rawBits = *a3;
  unint64_t v10 = *(void *)(v4 + 16);
  unint64_t v9 = *(void *)(v4 + 24);
  uint64_t v11 = (v10 >> 59) & 1;
  if ((v9 & 0x1000000000000000LL) == 0) {
    LOBYTE(v11) = 1;
  }
  if ((rawBits & 0xC) != 4LL << v11)
  {
    if ((v9 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
LABEL_20:
    Swift::String::Index_optional v15 = String.UTF8View._foreignIndex(_:offsetBy:limitedBy:)((Swift::String::Index)rawBits, offsetBy, v8);
    Swift::Bool is_nil = v15.is_nil;
    goto LABEL_18;
  }

  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  if ((v9 & 0x1000000000000000LL) != 0) {
    goto LABEL_20;
  }
LABEL_5:
  Swift::UInt64 v12 = rawBits >> 16;
  int64_t v13 = (rawBits >> 16) + offsetBy;
  if (__OFADD__(rawBits >> 16, offsetBy))
  {
    __break(1u);
    goto LABEL_22;
  }

  Swift::UInt64 v14 = v8._rawBits >> 16;
  if (offsetBy < 0)
  {
  }

  else if (v14 < v12 || (uint64_t)v14 >= v13)
  {
LABEL_13:
    if ((v13 & 0x8000000000000000LL) == 0)
    {
      unint64_t v17 = HIBYTE(v9) & 0xF;
      if ((v9 & 0x2000000000000000LL) == 0) {
        unint64_t v17 = v10 & 0xFFFFFFFFFFFFLL;
      }
      if (v17 >= v13)
      {
        Swift::Bool is_nil = 0;
        v15.value._Swift::UInt64 rawBits = (v13 << 16) | 4;
        goto LABEL_18;
      }
    }

uint64_t (*protocol witness for Collection.subscript.read in conformance Substring.UTF8View( _BYTE *a1, Swift::UInt64 *a2))()
{
  *a1 = Substring.UTF8View.subscript.getter( *a2,  *(void *)v2,  *(void *)(v2 + 8),  *(void *)(v2 + 16),  *(void *)(v2 + 24));
  return EnumeratedSequence._base.modify;
}

unint64_t protocol witness for Collection.subscript.getter in conformance Substring.UTF16View@<X0>( Swift::UInt64 *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  v4._Swift::UInt64 rawBits = a1[1];
  v5._Swift::UInt64 rawBits = *a1;
  *a2 = specialized Substring.UTF8View.subscript.getter( v5,  v4,  *(void *)v2,  *(void *)(v2 + 8),  *(void *)(v2 + 16),  *(void *)(v2 + 24));
  a2[1] = v6;
  a2[2] = v7;
  a2[3] = (Swift::UInt64)v8;
  return swift_bridgeObjectRetain((unint64_t)v8, v6, v7, v8);
}

Swift::Int protocol witness for Collection.count.getter in conformance Substring.UTF8View()
{
  v1._Swift::UInt64 rawBits = *v0;
  v2._Swift::UInt64 rawBits = v0[1];
  return specialized Collection.count.getter(v1, v2, v0[2], v0[3]);
}

Swift::String::Index protocol witness for Collection.index(_:offsetBy:) in conformance Substring.UTF8View@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF8View.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, uint64_t, void, uint64_t, uint64_t, void, void))Substring.UTF8View.index(_:offsetBy:limitedBy:),  a6);
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance Substring.UTF8View( Swift::String::Index *a1, Swift::UInt64 *a2)
{
  Swift::UInt64 rawBits = a1->_rawBits;
  Swift::UInt64 v4 = *a2;
  unint64_t v5 = *(void *)(v2 + 16);
  unint64_t v6 = *(void *)(v2 + 24);
  uint64_t v7 = (v5 >> 59) & 1;
  if ((v6 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = 4LL << v7;
  if ((a1->_rawBits & 0xC) == 4LL << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  }
  if ((v4 & 0xC) == v8)
  {
    Swift::UInt64 v4 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v4)._rawBits;
    if ((v6 & 0x1000000000000000LL) == 0) {
      return (v4 >> 16) - (rawBits >> 16);
    }
  }

  else if ((v6 & 0x1000000000000000LL) == 0)
  {
    return (v4 >> 16) - (rawBits >> 16);
  }

  unint64_t v10 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    unint64_t v10 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v10 < rawBits >> 16 || v10 < v4 >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }
  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, (Swift::String::Index)v4);
}

Swift::String::Index protocol witness for Collection.index(after:) in conformance Substring.UTF8View@<X0>( Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF8View.index(after:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

Swift::UInt64 protocol witness for Collection.formIndex(after:) in conformance Substring.UTF8View( Swift::UInt64 *a1)
{
  unint64_t v4 = *(void *)(v1 + 16);
  unint64_t v3 = *(void *)(v1 + 24);
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = (v4 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v6)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if ((v3 & 0x1000000000000000LL) == 0) {
      goto LABEL_5;
    }
  }

  else if ((v3 & 0x1000000000000000LL) == 0)
  {
LABEL_5:
    Swift::UInt64 result = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
    goto LABEL_6;
  }

  unint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 <= rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
  }
  Swift::UInt64 result = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_6:
  *a1 = result;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring.UTF8View( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring( a1,  a2,  (uint64_t (*)(void, void, void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring.UTF8View( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring.UTF8View@<X0>( uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return Substring.UTF8View.withContiguousStorageIfAvailable<A>(_:)( a1,  *(void *)v3,  *(void *)(v3 + 8),  *(void *)(v3 + 16),  *(void *)(v3 + 24),  a2,  a3);
}

Swift::UInt64 Substring.init(_:)(Swift::String::Index a1, Swift::String::Index a2)
{
  return specialized Substring.init(_:)(a1, a2);
}

uint64_t (*Substring.utf8.modify(void *a1))()
{
  uint64_t v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4, v6, v7, v8);
  return Substring.utf8.modify;
}

uint64_t (*Substring.UTF16View._slice.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Substring.UTF16View.subscript.getter( Swift::String::Index a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v10 = (a4 >> 59) & 1;
  if ((a5 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
  }
  if ((a1._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if (rawBits >> 14 < a2 >> 14 || rawBits >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/Substring.swift",  21LL,  2,  0x33FuLL,  0);
  }
  if ((a5 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignSubscript(position:)((Swift::String::Index)rawBits);
  }
  if ((rawBits & 1) != 0)
  {
    uint64_t v11 = rawBits >> 16;
    if ((a5 & 0x2000000000000000LL) == 0) {
      goto LABEL_10;
    }
LABEL_15:
    v16[0] = a4;
    v16[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    Swift::UInt64 v12 = v16;
    goto LABEL_16;
  }

  uint64_t v11 = (_StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1) >> 16;
  if ((a5 & 0x2000000000000000LL) != 0) {
    goto LABEL_15;
  }
LABEL_10:
  if ((a4 & 0x1000000000000000LL) != 0) {
    Swift::UInt64 v12 = (void *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
  }
  else {
    Swift::UInt64 v12 = _StringObject.sharedUTF8.getter(a4, a5);
  }
LABEL_16:
  uint64_t v14 = _decodeScalar(_:startingAt:)((uint64_t)v12, a2, v11);
  if ((rawBits & 0xC000) == 0x4000)
  {
    if (!WORD1(v14)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
    }
    return v14 & 0x3FF | 0xFFFFDC00;
  }

  if (!WORD1(v14)) {
    return v14;
  }
  uint64_t v15 = (unsigned __int16)((v14 + 67043328) >> 10) + 55296;
  if ((v15 & 0x10000) != 0)
  {
    __break(1u);
    return v14;
  }

  return v15;
}

Swift::String::Index __swiftcall Substring.UTF16View.index(after:)(Swift::String::Index after)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((after._rawBits & 0xC) == 4LL << v5) {
    after._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(after)._rawBits;
  }
  Swift::UInt64 v6 = after._rawBits >> 16;
  unint64_t v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 >= v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
  }
  if ((v3 & 0x1000000000000000LL) != 0) {
    return (Swift::String::Index)specialized String.UTF16View._foreignIndex(after:)(after._rawBits);
  }
  uint64_t v8 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LOBYTE(v8) = v4 < 0;
  }
  if ((v8 & 1) != 0) {
    return (Swift::String::Index)((after._rawBits & 0xFFFFFFFFFFFF0000LL) + 65549);
  }
  if ((after._rawBits & 0xC001) != 0)
  {
    if ((v3 & 0x2000000000000000LL) == 0) {
      goto LABEL_15;
    }
LABEL_21:
    v16[0] = v4;
    v16[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = *((unsigned __int8 *)v16 + v6);
    if ((v10 & 0x80) != 0) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }

  Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(after)._rawBits;
  after._Swift::UInt64 rawBits = rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  Swift::UInt64 v6 = rawBits >> 16;
  if ((v3 & 0x2000000000000000LL) != 0) {
    goto LABEL_21;
  }
LABEL_15:
  if ((v4 & 0x1000000000000000LL) == 0)
  {
    Swift::UInt64 v15 = after._rawBits;
    uint64_t v12 = v3;
    Swift::UInt64 v13 = v6;
    uint64_t v10 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v12);
    after._Swift::UInt64 rawBits = v15;
    LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = *(unsigned __int8 *)(v10 + v13);
    if ((v10 & 0x80) != 0) {
      goto LABEL_24;
    }
LABEL_22:
    uint64_t v10 = 1LL;
    goto LABEL_28;
  }

  LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v6);
  if ((v10 & 0x80) == 0) {
    goto LABEL_22;
  }
LABEL_24:
  LODWORD(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = __clz(v10 ^ 0xFF) - 24;
  if ((_DWORD)v10 == 4)
  {
    if ((after._rawBits & 0xC000) == 0)
    {
      unsigned __int16 v14 = 16388;
      return (Swift::String::Index)(after._rawBits & 0xFFFFFFFFFFFF0000LL | v14);
    }

    uint64_t v10 = 4LL;
  }

  else
  {
    uint64_t v10 = v10;
  }

Swift::Void __swiftcall Substring.UTF16View.formIndex(after:)(Swift::String::Index *after)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 rawBits = after->_rawBits;
  uint64_t v7 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v7) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v8 = rawBits >> 16;
  unint64_t v9 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 >= v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
  }
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 v11 = specialized String.UTF16View._foreignIndex(after:)(rawBits);
    goto LABEL_29;
  }

  uint64_t v10 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = v4 < 0;
  }
  if ((v10 & 1) == 0)
  {
    if ((rawBits & 0xC001) != 0)
    {
      if ((v3 & 0x2000000000000000LL) == 0)
      {
LABEL_15:
        if ((v4 & 0x1000000000000000LL) != 0)
        {
          LODWORD(v12) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v8);
          if ((v12 & 0x80) != 0) {
            goto LABEL_17;
          }
LABEL_26:
          uint64_t v12 = 1LL;
          goto LABEL_27;
        }

        Swift::UInt64 v17 = rawBits;
        uint64_t v15 = v3;
        Swift::UInt64 v16 = v8;
        uint64_t v12 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v15);
        Swift::UInt64 rawBits = v17;
        LODWORD(v12) = *(unsigned __int8 *)(v12 + v16);
        if ((v12 & 0x80) == 0) {
          goto LABEL_26;
        }
LABEL_17:
        LODWORD(v12) = __clz(v12 ^ 0xFF) - 24;
        if ((_DWORD)v12 == 4)
        {
          if ((rawBits & 0xC000) == 0)
          {
            unsigned __int16 v13 = 16388;
LABEL_28:
            Swift::UInt64 v11 = rawBits & 0xFFFFFFFFFFFF0000LL | v13;
            goto LABEL_29;
          }

          uint64_t v12 = 4LL;
        }

        else
        {
          uint64_t v12 = v12;
        }

Swift::String::Index __swiftcall Substring.UTF16View.index(_:offsetBy:)(Swift::String::Index _, Swift::Int offsetBy)
{
  return String.UTF16View.index(_:offsetBy:)(_, offsetBy);
}

Swift::String::Index_optional __swiftcall Substring.UTF16View.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  Swift::String::Index_optional v3 = String.UTF16View.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy);
  v3.is_nil &= 1u;
  return v3;
}

Swift::Int __swiftcall Substring.UTF16View.distance(from:to:)(Swift::String::Index from, Swift::String::Index to)
{
  return String.UTF16View.distance(from:to:)(from, to);
}

unint64_t Substring.UTF16View._failEarlyRangeCheck(_:bounds:)( unint64_t a1, unint64_t a2, unint64_t a3)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3);
}

unint64_t Substring.UTF16View._failEarlyRangeCheck(_:bounds:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4);
}

Swift::String::Index __swiftcall Substring.UTF16View.index(before:)(Swift::String::Index before)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((before._rawBits & 0xC) == 4LL << v5)
  {
    before._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(before)._rawBits;
    if (before._rawBits < 0x4000) {
      goto LABEL_26;
    }
  }

  else if (before._rawBits < 0x4000)
  {
    goto LABEL_26;
  }

  unint64_t v6 = HIBYTE(v3) & 0xF;
  uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000LL) != 0) {
    uint64_t v8 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v8 < before._rawBits >> 14) {
LABEL_26:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0xAFuLL,  0);
  if ((v3 & 0x1000000000000000LL) != 0) {
    return (Swift::String::Index)specialized String.UTF16View._foreignIndex(before:)(before._rawBits);
  }
  uint64_t v9 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LOBYTE(v9) = v4 < 0;
  }
  if ((v9 & 1) != 0) {
    return (Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000LL) - 65523);
  }
  if ((before._rawBits & 0xC000) != 0) {
    return (Swift::String::Index)(before._rawBits & 0xFFFFFFFFFFFF0000LL | 5);
  }
  if ((before._rawBits & 1) != 0)
  {
    Swift::UInt64 v11 = before._rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) == 0) {
      goto LABEL_18;
    }
  }

  else
  {
    Swift::UInt64 rawBits = v4 & 0xFFFFFFFFFFFFLL;
    v15._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(before)._rawBits;
    unint64_t v6 = HIBYTE(v3) & 0xF;
    uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
    before._Swift::UInt64 rawBits = v15._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
    Swift::UInt64 v11 = before._rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) == 0)
    {
LABEL_18:
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        uint64_t v12 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
        if (before._rawBits >= 0x10000) {
          goto LABEL_20;
        }
      }

      else
      {
        Swift::UInt64 rawBits = before._rawBits;
        uint64_t v17 = v3;
        Swift::UInt64 v18 = v11;
        id v19 = _StringObject.sharedUTF8.getter(v4, v17);
        Swift::UInt64 v11 = v18;
        uint64_t v12 = (uint64_t)v19;
        before._Swift::UInt64 rawBits = rawBits;
        if (rawBits >= 0x10000)
        {
LABEL_20:
          uint64_t v13 = 0LL;
          uint64_t v14 = v11 + v12 - 1;
          while ((uint64_t)v11 <= v7)
          {
            if ((*(_BYTE *)(v14 + v13) & 0xC0) != 0x80) {
              goto LABEL_35;
            }
          }

Swift::Void __swiftcall Substring.UTF16View.formIndex(before:)(Swift::String::Index *before)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::UInt64 rawBits = before->_rawBits;
  uint64_t v7 = (v1 >> 59) & 1;
  if ((v2 & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v7)
  {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    if (rawBits < 0x4000) {
      goto LABEL_26;
    }
  }

  else if (rawBits < 0x4000)
  {
    goto LABEL_26;
  }

  unint64_t v8 = HIBYTE(v3) & 0xF;
  uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000LL) != 0) {
    uint64_t v10 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v10 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (4 * v10 < rawBits >> 14) {
LABEL_26:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0xAFuLL,  0);
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 v12 = specialized String.UTF16View._foreignIndex(before:)(rawBits);
    goto LABEL_38;
  }

  uint64_t v11 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LOBYTE(v11) = v4 < 0;
  }
  if ((v11 & 1) != 0)
  {
    Swift::UInt64 v12 = (rawBits & 0xFFFFFFFFFFFF0000LL) - 65523;
    goto LABEL_38;
  }

  if ((rawBits & 0xC000) != 0)
  {
    Swift::UInt64 v12 = rawBits & 0xFFFFFFFFFFFF0000LL | 5;
    goto LABEL_38;
  }

  if ((rawBits & 1) != 0)
  {
    Swift::UInt64 v13 = rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) == 0) {
      goto LABEL_18;
    }
  }

  else
  {
    unint64_t v22 = v4 & 0xFFFFFFFFFFFFLL;
    v17._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    unint64_t v8 = HIBYTE(v3) & 0xF;
    uint64_t v9 = v4 & 0xFFFFFFFFFFFFLL;
    Swift::UInt64 rawBits = v17._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
    Swift::UInt64 v13 = rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) == 0)
    {
LABEL_18:
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        uint64_t v14 = (v3 & 0xFFFFFFFFFFFFFFFLL) + 32;
        if (rawBits >= 0x10000) {
          goto LABEL_20;
        }
      }

      else
      {
        unint64_t v22 = rawBits;
        uint64_t v19 = v3;
        Swift::UInt64 v20 = v13;
        id v21 = _StringObject.sharedUTF8.getter(v4, v19);
        Swift::UInt64 v13 = v20;
        uint64_t v14 = (uint64_t)v21;
        Swift::UInt64 rawBits = v22;
        if (v22 >= 0x10000)
        {
LABEL_20:
          uint64_t v15 = 0LL;
          uint64_t v16 = v13 + v14 - 1;
          while ((uint64_t)v13 <= v9)
          {
            if ((*(_BYTE *)(v16 + v15) & 0xC0) != 0x80) {
              goto LABEL_35;
            }
          }

Swift::String::Index protocol witness for BidirectionalCollection.index(before:) in conformance Substring.UTF16View@<X0>( Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF16View.index(before:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

void protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring.UTF16View( Swift::String::Index *before)
{
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Substring.UTF16View@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = String.UTF16View.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void, void, void))String.UTF16View.index(_:offsetBy:limitedBy:),  a4);
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance Substring.UTF16View( Swift::String::Index *a1, Swift::String::Index *a2)
{
  return String.UTF16View.distance(from:to:)((Swift::String::Index)a1->_rawBits, (Swift::String::Index)a2->_rawBits);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Substring.UTF16View( _WORD *a1, Swift::UInt64 *a2))()
{
  v4._Swift::UInt64 rawBits = *a2;
  *a1 = Substring.UTF16View.subscript.getter( v4,  *(void *)v2,  *(void *)(v2 + 8),  *(void *)(v2 + 16),  *(void *)(v2 + 24));
  return EnumeratedSequence._base.modify;
}

Swift::String::Index protocol witness for Collection.index(after:) in conformance Substring.UTF16View@<X0>( Swift::String::Index *a1@<X0>, Swift::String::Index *a2@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UTF16View.index(after:)((Swift::String::Index)a1->_rawBits)._rawBits;
  a2->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

unint64_t protocol witness for Collection.formIndex(after:) in conformance Substring.UTF16View( Swift::UInt64 *a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  unint64_t v3 = *(void *)(v1 + 24);
  Swift::UInt64 rawBits = *a1;
  uint64_t v6 = ((unint64_t)v4 >> 59) & 1;
  if ((v3 & 0x1000000000000000LL) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((rawBits & 0xC) == 4LL << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  Swift::UInt64 v7 = rawBits >> 16;
  unint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    unint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
  }
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    unint64_t result = specialized String.UTF16View._foreignIndex(after:)(rawBits);
    goto LABEL_29;
  }

  uint64_t v9 = (v3 >> 62) & 1;
  if ((v3 & 0x2000000000000000LL) == 0) {
    LOBYTE(v9) = v4 < 0;
  }
  if ((v9 & 1) == 0)
  {
    if ((rawBits & 0xC001) != 0)
    {
      if ((v3 & 0x2000000000000000LL) == 0)
      {
LABEL_15:
        if ((v4 & 0x1000000000000000LL) != 0)
        {
          LODWORD(v11) = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32 + v7);
          if ((v11 & 0x80) != 0) {
            goto LABEL_17;
          }
LABEL_26:
          uint64_t v11 = 1LL;
          goto LABEL_27;
        }

        Swift::UInt64 v14 = rawBits;
        uint64_t v11 = (uint64_t)_StringObject.sharedUTF8.getter(v4, v3);
        Swift::UInt64 rawBits = v14;
        LODWORD(v11) = *(unsigned __int8 *)(v11 + v7);
        if ((v11 & 0x80) == 0) {
          goto LABEL_26;
        }
LABEL_17:
        LODWORD(v11) = __clz(v11 ^ 0xFF) - 24;
        if ((_DWORD)v11 == 4)
        {
          if ((rawBits & 0xC000) == 0)
          {
            unsigned __int16 v12 = 16388;
LABEL_28:
            unint64_t result = rawBits & 0xFFFFFFFFFFFF0000LL | v12;
            goto LABEL_29;
          }

          uint64_t v11 = 4LL;
        }

        else
        {
          uint64_t v11 = v11;
        }

Swift::Int protocol witness for Collection.count.getter in conformance Substring.UTF16View()
{
  return String.UTF16View.distance(from:to:)((Swift::String::Index)v0->_rawBits, v0[1]);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring.UTF16View( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring( a1,  a2,  (uint64_t (*)(void, void, void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring.UTF16View( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

Swift::UInt64 key path setter for Substring.utf8 : Substring( Swift::UInt64 *a1, Swift::UInt64 *a2, uint64_t a3, char *a4)
{
  Swift::UInt64 v5 = *a1;
  Swift::UInt64 v6 = a1[1];
  uint64_t v7 = a2[3];
  swift_bridgeObjectRetain(a1[3], (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  v8._Swift::UInt64 rawBits = v5;
  v9._Swift::UInt64 rawBits = v6;
  Swift::UInt64 result = specialized Substring.init(_:)(v8, v9);
  *a2 = result;
  a2[1] = v11;
  a2[2] = v12;
  a2[3] = v13;
  return result;
}

void Substring.utf8.setter(Swift::UInt64 a1, Swift::UInt64 a2, Swift::UInt64 a3, Swift::UInt64 a4)
{
  if ((a1 & 1) == 0)
  {
    a1 = a1 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)a1)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((a2 & 1) != 0) {
      goto LABEL_3;
    }
LABEL_5:
    a2 = a2 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)a2)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    goto LABEL_3;
  }

  if ((a2 & 1) == 0) {
    goto LABEL_5;
  }
LABEL_3:
  *uint64_t v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
}

uint64_t (*Substring.utf16.modify(void *a1))()
{
  unint64_t v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)unint64_t v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4, v6, v7, v8);
  return Substring.utf8.modify;
}

void Substring.utf8.modify(uint64_t **a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4 = *a1;
  uint64_t v6 = (*a1)[3];
  uint64_t v5 = (*a1)[4];
  Swift::UInt64 v7 = **a1;
  Swift::UInt64 v8 = (*a1)[1];
  uint64_t v9 = (*a1)[2];
  uint64_t v10 = *(void *)(v5 + 24);
  if ((a2 & 1) == 0)
  {
    swift_bridgeObjectRelease(*(void *)(v5 + 24));
    if ((v7 & 1) != 0)
    {
      if ((v8 & 1) != 0)
      {
LABEL_7:
        Swift::UInt64 v12 = (Swift::UInt64 *)v4[4];
        *Swift::UInt64 v12 = v7;
        v12[1] = v8;
        void v12[2] = v9;
        void v12[3] = v6;
        goto LABEL_8;
      }
    }

    else
    {
      Swift::UInt64 v7 = v7 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v7)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v8 & 1) != 0) {
        goto LABEL_7;
      }
    }

    Swift::UInt64 v8 = v8 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    goto LABEL_7;
  }

  swift_bridgeObjectRetain((*a1)[3], a2, a3, a4);
  swift_bridgeObjectRelease(v10);
  if ((v7 & 1) == 0)
  {
    Swift::UInt64 v7 = v7 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v7)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((v8 & 1) != 0) {
      goto LABEL_4;
    }
LABEL_10:
    Swift::UInt64 v8 = v8 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v8)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    goto LABEL_4;
  }

  if ((v8 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_4:
  Swift::UInt64 v11 = (Swift::UInt64 *)v4[4];
  *Swift::UInt64 v11 = v7;
  v11[1] = v8;
  void v11[2] = v9;
  uint64_t v11[3] = v6;
  swift_bridgeObjectRelease(v4[3]);
LABEL_8:
  free(v4);
}

uint64_t String.init(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  v7._Swift::UInt64 rawBits = a1._rawBits;
  if (!_StringGuts.isOnUnicodeScalarBoundary(_:)(a1) || !_StringGuts.isOnUnicodeScalarBoundary(_:)(a2))
  {
    swift_bridgeObjectRelease(a4);
    return 0LL;
  }

  if ((v7._rawBits & 1) == 0)
  {
    v7._Swift::UInt64 rawBits = v7._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v7)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((a2._rawBits & 1) != 0) {
      goto LABEL_5;
    }
LABEL_9:
    a2._Swift::UInt64 rawBits = a2._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a2)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    goto LABEL_5;
  }

  if ((a2._rawBits & 1) == 0) {
    goto LABEL_9;
  }
LABEL_5:
  v8._Swift::UInt64 rawBits = v7._rawBits;
  v9._Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v10 = specialized String.init(_:)(v8, v9, a3, a4);
  swift_bridgeObjectRelease(a4);
  return v10;
}

{
  uint64_t v5;
  uint64_t v5 = specialized String.init(_:)(a1, a2, a3, a4);
  swift_bridgeObjectRelease(a4);
  return v5;
}

uint64_t Substring.UnicodeScalarView._slice.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a1;
}

void Substring.UnicodeScalarView._slice.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *unint64_t v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
}

uint64_t (*Substring.UnicodeScalarView._slice.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 Substring.UnicodeScalarView.init(_:_bounds:)( int a1, int a2, Swift::String::Index a3, Swift::String::Index a4)
{
  Swift::UInt64 rawBits = a3._rawBits;
  if ((a3._rawBits & 1) == 0)
  {
    Swift::UInt64 rawBits = a3._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a3)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((a4._rawBits & 1) != 0) {
      return rawBits;
    }
LABEL_5:
    _StringGuts.scalarAlignSlow(_:)(a4)._rawBits;
    return rawBits;
  }

  if ((a4._rawBits & 1) == 0) {
    goto LABEL_5;
  }
  return rawBits;
}

uint64_t Substring.UnicodeScalarView.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t Substring.UnicodeScalarView.subscript.getter( Swift::String::Index a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  v7._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:in:)(a1, a2, a3, a4, a5)._rawBits;
  if ((a5 & 0x1000000000000000LL) != 0) {
    return *(_OWORD *)&_StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v7._rawBits & 0xFFFFFFFFFFFF0000LL));
  }
  Swift::UInt64 v9 = v7._rawBits >> 16;
  if ((a5 & 0x2000000000000000LL) != 0)
  {
    v12[0] = a4;
    v12[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    return _decodeScalar(_:startingAt:)((uint64_t)v12, v8._rawBits, v9);
  }

  else
  {
    if ((a4 & 0x1000000000000000LL) != 0) {
      id v10 = (id)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      id v10 = _StringObject.sharedUTF8.getter(a4, a5);
    }
    return _decodeScalar(_:startingAt:)((uint64_t)v10, v8._rawBits, v9);
  }

uint64_t Substring.UnicodeScalarView.indices.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a3;
}

Swift::String::Index __swiftcall Substring.UnicodeScalarView.index(after:)(Swift::String::Index after)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(after)._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0) {
    return String.UnicodeScalarView._foreignIndex(after:)(v5);
  }
  Swift::UInt64 v6 = v5._rawBits >> 16;
  if ((v3 & 0x2000000000000000LL) != 0)
  {
    v12[0] = v4;
    v12[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    int v8 = *((unsigned __int8 *)v12 + v6);
  }

  else
  {
    if ((v4 & 0x1000000000000000LL) != 0) {
      Swift::String::Index v7 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      Swift::String::Index v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
    }
    int v8 = v7[v6];
  }

  int v9 = (char)v8;
  unsigned int v10 = __clz(v8 ^ 0xFF) - 24;
  if (v9 >= 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
  }
  return (Swift::String::Index)(((v6 + v10) << 16) | 5);
}

Swift::Void __swiftcall Substring.UnicodeScalarView.formIndex(after:)(Swift::String::Index *after)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)after->_rawBits)._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }

  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      v13[0] = v4;
      v13[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      int v9 = *((unsigned __int8 *)v13 + v7);
    }

    else
    {
      if ((v4 & 0x1000000000000000LL) != 0) {
        int v8 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        int v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      int v9 = v8[v7];
    }

    int v10 = (char)v9;
    unsigned int v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0) {
      LOBYTE(v11) = 1;
    }
    Swift::UInt64 rawBits = ((v7 + v11) << 16) | 5;
  }

  after->_Swift::UInt64 rawBits = rawBits;
}

Swift::String::Index __swiftcall Substring.UnicodeScalarView.index(_:offsetBy:)( Swift::String::Index _, Swift::Int offsetBy)
{
  unint64_t v4 = v3;
  uint64_t v5 = v2;
  result._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(_)._rawBits;
  if (offsetBy < 0)
  {
    uint64_t v14 = 0LL;
    while (1)
    {
      Swift::UInt64 v15 = result._rawBits >> 16;
      if (!(result._rawBits >> 16)) {
        break;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        result._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(result)._rawBits;
      }

      else
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v23 = v5;
          uint64_t v24 = v4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v23 + v15 - 1) & 0xC0) == 0x80)
          {
            uint64_t v18 = 0LL;
            do
              int v19 = v22[v15 + v18--] & 0xC0;
            while (v19 == 128);
            uint64_t v20 = 1 - v18;
          }

          else
          {
            uint64_t v20 = 1LL;
          }

          v15 -= v20;
        }

        else
        {
          uint64_t v16 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            uint64_t v16 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          do
            int v17 = v16[--v15] & 0xC0;
          while (v17 == 128);
        }

        result._Swift::UInt64 rawBits = (v15 << 16) | 5;
      }

      if (--v14 <= offsetBy) {
        return result;
      }
    }

    unint64_t v21 = 206LL;
LABEL_40:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  v21,  0);
  }

  if (offsetBy)
  {
    if ((v4 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v8 = HIBYTE(v4) & 0xF;
    }
    else {
      Swift::UInt64 v8 = v5 & 0xFFFFFFFFFFFFLL;
    }
    while (1)
    {
      Swift::UInt64 v9 = result._rawBits >> 16;
      if (result._rawBits >> 16 >= v8) {
        break;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        result._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(result)._rawBits;
        if (!--offsetBy) {
          return result;
        }
      }

      else
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v23 = v5;
          uint64_t v24 = v4 & 0xFFFFFFFFFFFFFFLL;
          int v11 = *((unsigned __int8 *)&v23 + v9);
        }

        else
        {
          int v10 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v5 & 0x1000000000000000LL) == 0) {
            int v10 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int v11 = v10[v9];
        }

        int v12 = (char)v11;
        unsigned int v13 = __clz(v11 ^ 0xFF) - 24;
        if (v12 >= 0) {
          LOBYTE(v13) = 1;
        }
        result._Swift::UInt64 rawBits = ((v9 + v13) << 16) | 5;
        if (!--offsetBy) {
          return result;
        }
      }
    }

    unint64_t v21 = 201LL;
    goto LABEL_40;
  }

  return result;
}

Swift::String::Index_optional __swiftcall Substring.UnicodeScalarView.index(_:offsetBy:limitedBy:)( Swift::String::Index _, Swift::Int offsetBy, Swift::String::Index limitedBy)
{
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  Swift::UInt64 rawBits = limitedBy._rawBits;
  uint64_t v10 = (v3 >> 59) & 1;
  if ((v4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
  }
  uint64_t v11 = 4LL << v10;
  if ((limitedBy._rawBits & 0xC) == 4LL << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(limitedBy)._rawBits;
  }
  Swift::UInt64 v12 = _._rawBits;
  if ((_._rawBits & 0xC) == v11) {
    Swift::UInt64 v12 = _StringGuts._slowEnsureMatchingEncoding(_:)(_)._rawBits;
  }
  v13._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(_)._rawBits;
  Swift::UInt64 v14 = rawBits >> 14;
  if ((offsetBy & 0x8000000000000000LL) == 0)
  {
    Swift::UInt64 v15 = v12 >> 14;
    if (offsetBy)
    {
      if ((v5 & 0x2000000000000000LL) != 0) {
        Swift::UInt64 v16 = HIBYTE(v5) & 0xF;
      }
      else {
        Swift::UInt64 v16 = v6 & 0xFFFFFFFFFFFFLL;
      }
      while (1)
      {
        if (v14 >= v15 && v13._rawBits >> 14 >= v14) {
          goto LABEL_52;
        }
        Swift::UInt64 v17 = v13._rawBits >> 16;
        if (v13._rawBits >> 16 >= v16) {
          break;
        }
        if ((v5 & 0x1000000000000000LL) != 0)
        {
          v13._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v13)._rawBits;
        }

        else
        {
          if ((v5 & 0x2000000000000000LL) != 0)
          {
            uint64_t v35 = v6;
            uint64_t v36 = v5 & 0xFFFFFFFFFFFFFFLL;
            int v19 = *((unsigned __int8 *)&v35 + v17);
          }

          else
          {
            uint64_t v18 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
            if ((v6 & 0x1000000000000000LL) == 0) {
              uint64_t v18 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v6, v5);
            }
            int v19 = v18[v17];
          }

          int v20 = (char)v19;
          unsigned int v21 = __clz(v19 ^ 0xFF) - 24;
          if (v20 >= 0) {
            LOBYTE(v21) = 1;
          }
          v13._Swift::UInt64 rawBits = ((v17 + v21) << 16) | 5;
        }

        if (!--offsetBy) {
          goto LABEL_27;
        }
      }

      unint64_t v33 = 229LL;
LABEL_56:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  v33,  0);
    }

Swift::Int __swiftcall Substring.UnicodeScalarView.distance(from:to:)( Swift::String::Index from, Swift::String::Index to)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(from)._rawBits;
  Swift::Int result = _StringGuts.validateInclusiveScalarIndex(_:)(to)._rawBits;
  Swift::UInt64 v9 = (unint64_t)result >> 14;
  if (v7._rawBits >> 14 < (unint64_t)result >> 14)
  {
    for (uint64_t i = 0LL; ; ++i)
    {
      Swift::Int v11 = i + 1;
      if (__OFADD__(i, 1LL)) {
        break;
      }
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        Swift::Int result = String.UnicodeScalarView._foreignIndex(after:)(v7)._rawBits;
        v7._Swift::UInt64 rawBits = result;
      }

      else
      {
        Swift::UInt64 v12 = v7._rawBits >> 16;
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = v5;
          uint64_t v23 = v4 & 0xFFFFFFFFFFFFFFLL;
          int v13 = *((unsigned __int8 *)&v22 + v12);
        }

        else
        {
          Swift::Int result = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((v5 & 0x1000000000000000LL) == 0) {
            Swift::Int result = (Swift::Int)_StringObject.sharedUTF8.getter(v5, v4);
          }
          int v13 = *(unsigned __int8 *)(result + v12);
        }

        int v14 = (char)v13;
        unsigned int v15 = __clz(v13 ^ 0xFF) - 24;
        if (v14 >= 0) {
          LOBYTE(v15) = 1;
        }
        v7._Swift::UInt64 rawBits = ((v12 + v15) << 16) | 5;
      }

      if (v9 <= v7._rawBits >> 14) {
        return v11;
      }
    }

    __break(1u);
LABEL_36:
    __break(1u);
    return result;
  }

  if (v9 < v7._rawBits >> 14)
  {
    Swift::Int v11 = 0LL;
    while (!__OFSUB__(v11--, 1LL))
    {
      if ((v4 & 0x1000000000000000LL) != 0)
      {
        Swift::Int result = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
        v7._Swift::UInt64 rawBits = result;
      }

      else
      {
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = v5;
          uint64_t v23 = v4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v22 + (v7._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v20 = 0LL;
            do
              int v21 = *((_BYTE *)&v22 + (v7._rawBits >> 16) + v20-- - 2) & 0xC0;
            while (v21 == 128);
            uint64_t v19 = 1 - v20;
          }

          else
          {
            uint64_t v19 = 1LL;
          }
        }

        else
        {
          Swift::Int result = (v4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((v5 & 0x1000000000000000LL) == 0) {
            Swift::Int result = (Swift::Int)_StringObject.sharedUTF8.getter(v5, v4);
          }
          uint64_t v17 = 0LL;
          do
            int v18 = *(_BYTE *)(result + (v7._rawBits >> 16) - 1 + v17--) & 0xC0;
          while (v18 == 128);
          uint64_t v19 = -v17;
        }

        v7._Swift::UInt64 rawBits = (v7._rawBits - (v19 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (v9 >= v7._rawBits >> 14) {
        return v11;
      }
    }

    goto LABEL_36;
  }

  return 0LL;
}

unint64_t Substring.UnicodeScalarView._failEarlyRangeCheck(_:bounds:)( unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || result >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return result;
}

unint64_t Substring.UnicodeScalarView._failEarlyRangeCheck(_:bounds:)( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (result >> 14 < a3 >> 14 || a4 >> 14 < a2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  return result;
}

Swift::String::Index __swiftcall Substring.UnicodeScalarView.index(before:)(Swift::String::Index before)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(before)._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  Swift::UInt64 rawBits = v5._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0) {
    return String.UnicodeScalarView._foreignIndex(before:)(v5);
  }
  if ((v3 & 0x2000000000000000LL) != 0)
  {
    v16[0] = v4;
    v16[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    Swift::Int v11 = (char *)v16 + (v5._rawBits >> 16);
    if ((*(v11 - 1) & 0xC0) == 0x80)
    {
      uint64_t v12 = 0LL;
      int v13 = v11 - 2;
      do
        int v14 = v13[v12--] & 0xC0;
      while (v14 == 128);
      uint64_t v10 = 1 - v12;
    }

    else
    {
      uint64_t v10 = 1LL;
    }
  }

  else
  {
    if ((v4 & 0x1000000000000000LL) != 0) {
      Swift::String::Index v7 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      Swift::String::Index v7 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
    }
    uint64_t v8 = 0LL;
    do
      int v9 = v7[(rawBits >> 16) - 1 + v8--] & 0xC0;
    while (v9 == 128);
    uint64_t v10 = -v8;
  }

  return (Swift::String::Index)((rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000LL | 5);
}

Swift::Void __swiftcall Substring.UnicodeScalarView.formIndex(before:)(Swift::String::Index *before)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  v6._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)before->_rawBits)._rawBits;
  if (!(v6._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  Swift::UInt64 rawBits = v6._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 v16 = String.UnicodeScalarView._foreignIndex(before:)(v6)._rawBits;
  }

  else
  {
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      v17[0] = v4;
      v17[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v12 = (char *)v17 + (v6._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        uint64_t v13 = 0LL;
        int v14 = v12 - 2;
        do
          int v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        uint64_t v11 = 1 - v13;
      }

      else
      {
        uint64_t v11 = 1LL;
      }
    }

    else
    {
      if ((v4 & 0x1000000000000000LL) != 0) {
        uint64_t v8 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      uint64_t v9 = 0LL;
      do
        int v10 = v8[(rawBits >> 16) - 1 + v9--] & 0xC0;
      while (v10 == 128);
      uint64_t v11 = -v9;
    }

    Swift::UInt64 v16 = (rawBits - (v11 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
  }

  before->_Swift::UInt64 rawBits = v16;
}

Swift::UInt64 Substring.UnicodeScalarView.subscript.getter( Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, char *a4, unint64_t a5, unint64_t a6)
{
  v12._Swift::UInt64 rawBits = a1;
  v13._Swift::UInt64 rawBits = a2;
  return _StringGuts.validateScalarRange(_:in:)(v12, v13, a3, (unint64_t)a4, a5, a6);
}

Swift::UInt64 protocol witness for BidirectionalCollection.index(before:) in conformance Substring.UnicodeScalarView@<X0>( Swift::String::Index *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  uint64_t v5 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24);
  v6._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if (!(v6._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  Swift::UInt64 rawBits = v6._rawBits;
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(before:)(v6)._rawBits;
  }

  else
  {
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      v17[0] = v5;
      v17[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      Swift::String::Index v12 = (char *)v17 + (v6._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        uint64_t v13 = 0LL;
        int v14 = v12 - 2;
        do
          int v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        uint64_t v11 = 1 - v13;
      }

      else
      {
        uint64_t v11 = 1LL;
      }
    }

    else
    {
      if ((v5 & 0x1000000000000000LL) != 0) {
        uint64_t v8 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
      }
      uint64_t v9 = 0LL;
      do
        int v10 = v8[(rawBits >> 16) - 1 + v9--] & 0xC0;
      while (v10 == 128);
      uint64_t v11 = -v9;
    }

    Swift::UInt64 result = (rawBits - (v11 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
  }

  *a2 = result;
  return result;
}

void protocol witness for BidirectionalCollection.formIndex(before:) in conformance Substring.UnicodeScalarView( Swift::String::Index *before)
{
}

Swift::String::Index protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Substring.UnicodeScalarView@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = String.UnicodeScalarView.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UnicodeScalarView@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void, void, void))String.UnicodeScalarView.index(_:offsetBy:limitedBy:),  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF16View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, uint64_t, void, void, void)@<X5>, uint64_t a5@<X8>)
{
  uint64_t result = a4(*a1, a2, *a3, *(void *)(v5 + 16), *(void *)(v5 + 24));
  *(void *)a5 = result;
  *(_BYTE *)(a5 + 8) = v8 & 1;
  return result;
}

Swift::Int protocol witness for BidirectionalCollection.distance(from:to:) in conformance Substring.UnicodeScalarView( Swift::String::Index *a1, Swift::String::Index *a2)
{
  return String.UnicodeScalarView.distance(from:to:)( (Swift::String::Index)a1->_rawBits,  (Swift::String::Index)a2->_rawBits);
}

void protocol witness for Collection.startIndex.getter in conformance Substring.UnicodeScalarView( void *a1@<X8>)
{
  *a1 = *v1;
}

void protocol witness for Collection.endIndex.getter in conformance Substring.UnicodeScalarView( void *a1@<X8>)
{
  *a1 = *(void *)(v1 + 8);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Substring.UnicodeScalarView( uint64_t *a1, Swift::UInt64 *a2))()
{
  v4._Swift::UInt64 rawBits = *a2;
  uint64_t v6 = v2[2];
  uint64_t v5 = v2[3];
  v7._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:in:)(v4, *v2, v2[1], v6, v5)._rawBits;
  if ((v5 & 0x1000000000000000LL) != 0)
  {
    int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v7._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
  }

  else
  {
    Swift::UInt64 v9 = v7._rawBits >> 16;
    if ((v5 & 0x2000000000000000LL) != 0)
    {
      *a1 = v6;
      a1[1] = v5 & 0xFFFFFFFFFFFFFFLL;
      id v10 = a1;
    }

    else if ((v6 & 0x1000000000000000LL) != 0)
    {
      id v10 = (id)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      id v10 = _StringObject.sharedUTF8.getter(v6, v5);
    }

    int value = _decodeScalar(_:startingAt:)((uint64_t)v10, v8._rawBits, v9);
  }

  *(_DWORD *)a1 = value;
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 protocol witness for Collection.subscript.getter in conformance Substring.UnicodeScalarView@<X0>( Swift::UInt64 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, Swift::UInt64 *a5@<X8>)
{
  Swift::UInt64 v7 = *a1;
  Swift::UInt64 v8 = a1[1];
  unint64_t v9 = *v5;
  unint64_t v10 = v5[1];
  unint64_t v12 = v5[2];
  unint64_t v11 = v5[3];
  swift_bridgeObjectRetain(v11, a2, a3, a4);
  v13._Swift::UInt64 rawBits = v7;
  v14._Swift::UInt64 rawBits = v8;
  Swift::UInt64 result = _StringGuts.validateScalarRange(_:in:)(v13, v14, v9, v10, v12, v11);
  *a5 = result;
  a5[1] = v16;
  a5[2] = v12;
  a5[3] = v11;
  return result;
}

unint64_t protocol witness for Collection.indices.getter in conformance Substring.UTF8View@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v5 = *(void *)(v4 + 24);
  *(void *)a4 = *(void *)(v4 + 16);
  *(void *)(a4 + 8) = v5;
  *(_OWORD *)(a4 + 16) = *(_OWORD *)v4;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

BOOL protocol witness for Collection.isEmpty.getter in conformance Substring.UnicodeScalarView()
{
  return (v0[1] ^ *v0) < 0x4000uLL;
}

Swift::String::Index protocol witness for Collection.count.getter in conformance Substring.UnicodeScalarView()
{
  v1._Swift::UInt64 rawBits = *(void *)v0;
  v2._Swift::UInt64 rawBits = *(void *)(v0 + 8);
  return specialized Collection.count.getter(v1, v2, *(void *)(v0 + 16), *(void *)(v0 + 24));
}

Swift::String::Index protocol witness for Collection.index(_:offsetBy:) in conformance Substring.UnicodeScalarView@<X0>( Swift::String::Index *a1@<X0>, Swift::Int a2@<X1>, Swift::String::Index *a3@<X8>)
{
  result._Swift::UInt64 rawBits = Substring.UnicodeScalarView.index(_:offsetBy:)((Swift::String::Index)a1->_rawBits, a2)._rawBits;
  a3->_Swift::UInt64 rawBits = result._rawBits;
  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UnicodeScalarView@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, uint64_t, void, uint64_t, uint64_t, void, void))Substring.UnicodeScalarView.index(_:offsetBy:limitedBy:),  a6);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance Substring.UTF8View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t (*a6)(void, uint64_t, void, uint64_t, uint64_t, void, void)@<X5>, uint64_t a7@<X8>)
{
  uint64_t result = a6(*a1, a2, *a3, a4, a5, *(void *)(v7 + 16), *(void *)(v7 + 24));
  *(void *)a7 = result;
  *(_BYTE *)(a7 + 8) = v10 & 1;
  return result;
}

Swift::UInt64 protocol witness for Collection.index(after:) in conformance Substring.UnicodeScalarView@<X0>( Swift::String::Index *a1@<X0>, Swift::UInt64 *a2@<X8>)
{
  uint64_t v5 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24);
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }

  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      v13[0] = v5;
      v13[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      int v9 = *((unsigned __int8 *)v13 + v7);
    }

    else
    {
      if ((v5 & 0x1000000000000000LL) != 0) {
        Swift::UInt64 v8 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt64 v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v5, v4);
      }
      int v9 = v8[v7];
    }

    int v10 = (char)v9;
    unsigned int v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0) {
      LOBYTE(v11) = 1;
    }
    Swift::UInt64 result = ((v7 + v11) << 16) | 5;
  }

  *a2 = result;
  return result;
}

Swift::UInt64 protocol witness for Collection.formIndex(after:) in conformance Substring.UnicodeScalarView( Swift::String::Index *a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v5)._rawBits;
  }

  else
  {
    Swift::UInt64 v6 = v5._rawBits >> 16;
    if ((v3 & 0x2000000000000000LL) != 0)
    {
      v12[0] = v4;
      v12[1] = v3 & 0xFFFFFFFFFFFFFFLL;
      int v8 = *((unsigned __int8 *)v12 + v6);
    }

    else
    {
      if ((v4 & 0x1000000000000000LL) != 0) {
        Swift::UInt64 v7 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt64 v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v4, v3);
      }
      int v8 = v7[v6];
    }

    int v9 = (char)v8;
    unsigned int v10 = __clz(v8 ^ 0xFF) - 24;
    if (v9 >= 0) {
      LOBYTE(v1_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = 1;
    }
    Swift::UInt64 result = ((v6 + v10) << 16) | 5;
  }

  a1->_Swift::UInt64 rawBits = result;
  return result;
}

__n128 protocol witness for Sequence.makeIterator() in conformance Substring.UnicodeScalarView@<Q0>( __n128 *a1@<X8>)
{
  unint64_t v2 = v1[1].n128_u64[0];
  unint64_t v3 = v1[1].n128_u64[1];
  __n128 result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = v2;
  a1[1].n128_u64[1] = v3;
  a1[2].n128_u64[0] = result.n128_u64[0];
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring.UnicodeScalarView( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring( a1,  a2,  (uint64_t (*)(void, void, void, uint64_t))specialized _copyCollectionToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Substring( uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, uint64_t))
{
  uint64_t v4 = v3[3];
  uint64_t v5 = a3(*v3, v3[1], v3[2], v4);
  swift_bridgeObjectRelease(v4);
  return v5;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring.UnicodeScalarView( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, void, void, void, void))
{
  return a6(a1, a2, a3, *v6, v6[1], v6[2], v6[3]);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring.UnicodeScalarView@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys7UnicodeO6ScalarVqd__Isgyrzo_Ss0hI4ViewVABsAG_pAMRszr__lIetMggrzo_Tpq5Tm( a1,  a2);
}

unint64_t key path setter for Substring.unicodeScalars : Substring(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 24);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = v5;
  *(void *)(a2 + 24) = v4;
  return swift_bridgeObjectRetain(v4, v6, v7, v8);
}

void (*Substring.unicodeScalars.modify( void *a1))(uint64_t **a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)unint64_t v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4, v6, v7, v8);
  return Substring.unicodeScalars.modify;
}

void Substring.unicodeScalars.modify(uint64_t **a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v4 = *a1;
  uint64_t v5 = (*a1)[3];
  uint64_t v6 = (uint64_t *)(*a1)[4];
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = (*a1)[2];
  uint64_t v10 = v6[3];
  if ((a2 & 1) != 0)
  {
    swift_bridgeObjectRetain((*a1)[3], a2, a3, a4);
    swift_bridgeObjectRelease(v10);
    *uint64_t v6 = v8;
    v6[1] = v7;
    void v6[2] = v9;
    v6[3] = v5;
    swift_bridgeObjectRelease(v4[3]);
  }

  else
  {
    swift_bridgeObjectRelease(v6[3]);
    *uint64_t v6 = v8;
    v6[1] = v7;
    void v6[2] = v9;
    v6[3] = v5;
  }

  free(v4);
}

uint64_t specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2)
{
  v3._Swift::UInt64 rawBits = a2._rawBits;
  v4._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = (v2[2] >> 59) & 1;
  if ((v2[3] & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4LL << v7;
  uint64_t v10 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v9 || (a2._rawBits & 1) == 0 || v10 == v9)
  {
    if (v10 == v9)
    {
      a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      v3._Swift::UInt64 rawBits = a1._rawBits;
      if (v8 != v9) {
        goto LABEL_12;
      }
    }

    else if (v8 != v9)
    {
LABEL_12:
      if (v4._rawBits >> 14 < v5 >> 14 || v3._rawBits >> 14 < v4._rawBits >> 14 || v6 >> 14 < v3._rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
      }
      if ((v3._rawBits & 1) != 0)
      {
        if ((v4._rawBits & 1) != 0) {
          goto LABEL_17;
        }
      }

      else
      {
        a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v3)._rawBits;
        v3._Swift::UInt64 rawBits = v3._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        if ((v4._rawBits & 1) != 0) {
          goto LABEL_17;
        }
      }

      a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v4)._rawBits;
      v4._Swift::UInt64 rawBits = v4._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      goto LABEL_17;
    }

    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
    v4._Swift::UInt64 rawBits = a1._rawBits;
    goto LABEL_12;
  }

  if (a1._rawBits >> 14 < v5 >> 14 || v6 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
  }
LABEL_17:
  MEMORY[0x1895F8858](a1._rawBits);
  return _StringGuts.mutateSubrangeInSubstring(subrange:startIndex:endIndex:with:)( v4._rawBits,  v3._rawBits,  (uint64_t *)v2,  v2 + 1,  (uint64_t (*)(uint64_t *))partial apply for specialized closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

{
  unint64_t *v2;
  Swift::String::Index v3;
  Swift::String::Index v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  v3._Swift::UInt64 rawBits = a2._rawBits;
  v4._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = (v2[2] >> 59) & 1;
  if ((v2[3] & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4LL << v7;
  uint64_t v10 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v9 || (a2._rawBits & 1) == 0 || v10 == v9)
  {
    if (v10 == v9)
    {
      a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      v3._Swift::UInt64 rawBits = a1._rawBits;
      if (v8 != v9) {
        goto LABEL_12;
      }
    }

    else if (v8 != v9)
    {
LABEL_12:
      if (v4._rawBits >> 14 < v5 >> 14 || v3._rawBits >> 14 < v4._rawBits >> 14 || v6 >> 14 < v3._rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
      }
      if ((v3._rawBits & 1) != 0)
      {
        if ((v4._rawBits & 1) != 0) {
          goto LABEL_17;
        }
      }

      else
      {
        a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v3)._rawBits;
        v3._Swift::UInt64 rawBits = v3._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        if ((v4._rawBits & 1) != 0) {
          goto LABEL_17;
        }
      }

      a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v4)._rawBits;
      v4._Swift::UInt64 rawBits = v4._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      goto LABEL_17;
    }

    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
    v4._Swift::UInt64 rawBits = a1._rawBits;
    goto LABEL_12;
  }

  if (a1._rawBits >> 14 < v5 >> 14 || v6 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
  }
LABEL_17:
  MEMORY[0x1895F8858](a1._rawBits);
  return _StringGuts.mutateSubrangeInSubstring(subrange:startIndex:endIndex:with:)( v4._rawBits,  v3._rawBits,  (uint64_t *)v2,  v2 + 1,  (uint64_t (*)(uint64_t *))partial apply for specialized closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

uint64_t Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)( Swift::String::Index a1, Swift::String::Index a2)
{
  v3._Swift::UInt64 rawBits = a2._rawBits;
  v4._Swift::UInt64 rawBits = a1._rawBits;
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  uint64_t v7 = (v2[2] >> 59) & 1;
  if ((v2[3] & 0x1000000000000000LL) == 0) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4LL << v7;
  uint64_t v10 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v9 || (a2._rawBits & 1) == 0 || v10 == v9)
  {
    if (v10 == v9)
    {
      a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      v3._Swift::UInt64 rawBits = a1._rawBits;
      if (v8 != v9) {
        goto LABEL_12;
      }
    }

    else if (v8 != v9)
    {
LABEL_12:
      if (v4._rawBits >> 14 < v5 >> 14 || v3._rawBits >> 14 < v4._rawBits >> 14 || v6 >> 14 < v3._rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index range is out of bounds",  38LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0x63uLL,  0);
      }
      if ((v3._rawBits & 1) != 0)
      {
        if ((v4._rawBits & 1) != 0) {
          goto LABEL_17;
        }
      }

      else
      {
        a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v3)._rawBits;
        v3._Swift::UInt64 rawBits = v3._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        if ((v4._rawBits & 1) != 0) {
          goto LABEL_17;
        }
      }

      a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v4)._rawBits;
      v4._Swift::UInt64 rawBits = v4._rawBits & 0xC | a1._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      goto LABEL_17;
    }

    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v4)._rawBits;
    v4._Swift::UInt64 rawBits = a1._rawBits;
    goto LABEL_12;
  }

  if (a1._rawBits >> 14 < v5 >> 14 || v6 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xECuLL,  0);
  }
LABEL_17:
  MEMORY[0x1895F8858](a1._rawBits);
  return _StringGuts.mutateSubrangeInSubstring(subrange:startIndex:endIndex:with:)( v4._rawBits,  v3._rawBits,  (uint64_t *)v2,  v2 + 1,  (uint64_t (*)(uint64_t *))partial apply for closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

double protocol witness for RangeReplaceableCollection.init() in conformance Substring.UnicodeScalarView@<D0>( uint64_t a1@<X8>)
{
  *(void *)&double result = 15LL;
  *(_OWORD *)a1 = xmmword_1817FFCA0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0xE000000000000000LL;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance Substring.UnicodeScalarView( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(void, void, uint64_t, uint64_t, uint64_t))Substring.UnicodeScalarView.replaceSubrange<A>(_:with:));
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance Substring.UnicodeScalarView@<X0>( unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a2);
  *a3 = result;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance Substring.UnicodeScalarView@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append(_:) in conformance Substring.UnicodeScalarView()
{
  v1._Swift::UInt64 rawBits = *(void *)(v0 + 8);
  v2._Swift::UInt64 rawBits = v1._rawBits;
  return specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v1, v2);
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance Substring.UnicodeScalarView( uint64_t a1, Swift::UInt64 *a2)
{
  v3._Swift::UInt64 rawBits = *a2;
  v2._Swift::UInt64 rawBits = v3._rawBits;
  return specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v2, v3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance Substring.UnicodeScalarView( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(uint64_t, void))specialized RangeReplaceableCollection.insert<A>(contentsOf:at:));
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance Substring.UnicodeScalarView@<X0>( Swift::UInt64 *a1@<X0>, _DWORD *a2@<X8>)
{
  v3._Swift::UInt64 rawBits = *a1;
  uint64_t result = specialized RangeReplaceableCollection.remove(at:)(v3);
  *a2 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance Substring.UnicodeScalarView( Swift::UInt64 *a1)
{
  v1._Swift::UInt64 rawBits = a1[1];
  v2._Swift::UInt64 rawBits = *a1;
  return specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v2, v1);
}

uint64_t protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance Substring.UnicodeScalarView@<X0>( uint64_t a1@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection<>._customRemoveLast()();
  *(_DWORD *)a1 = result;
  *(_BYTE *)(a1 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance Substring.UnicodeScalarView@<X0>( _DWORD *a1@<X8>)
{
  unint64_t result = specialized RangeReplaceableCollection<>.removeFirst()();
  *a1 = result;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance Substring.UnicodeScalarView( uint64_t (*a1)(uint64_t *), uint64_t a2, uint64_t a3, char *a4)
{
}

void specialized Substring.append<A>(contentsOf:)( unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  v7._Swift::UInt64 rawBits = *v4;
  v8._Swift::UInt64 rawBits = v4[1];
  uint64_t v9 = v4[2];
  unint64_t v10 = v4[3];
  size_t v11 = HIBYTE(v10) & 0xF;
  uint64_t v12 = v9 & 0xFFFFFFFFFFFFLL;
  if ((v10 & 0x2000000000000000LL) != 0) {
    uint64_t v13 = HIBYTE(v10) & 0xF;
  }
  else {
    uint64_t v13 = v9 & 0xFFFFFFFFFFFFLL;
  }
  if (v7._rawBits >> 16) {
    BOOL v14 = 0;
  }
  else {
    BOOL v14 = v8._rawBits >> 16 == v13;
  }
  if (v14)
  {
    Swift::UInt64 rawBits = v4[3];
  }

  else
  {
    uint64_t v9 = specialized static String._copying(_:)(v7, v8, v4[2], v4[3]);
    Swift::UInt64 rawBits = v15;
    swift_bridgeObjectRelease(v10);
    size_t v11 = HIBYTE(rawBits) & 0xF;
    uint64_t v12 = v9 & 0xFFFFFFFFFFFFLL;
    unint64_t v10 = rawBits;
  }

  unint64_t v110 = v9;
  unint64_t v111 = v10;
  *(_OWORD *)Swift::String::Index v4 = xmmword_1817FFCA0;
  v4[2] = 0LL;
  v4[3] = 0xE000000000000000LL;
  if ((rawBits & 0x2000000000000000LL) != 0) {
    size_t v17 = v11;
  }
  else {
    size_t v17 = v12;
  }
  if (!v17 && (v9 & ~rawBits & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain(a2, v8._rawBits, a3, a4);
    swift_bridgeObjectRelease(v10);
    goto LABEL_108;
  }

  uint64_t v18 = a2 & 0x2000000000000000LL;
  uint64_t v19 = HIBYTE(a2) & 0xF;
  if ((rawBits & 0x2000000000000000LL) != 0 && v18)
  {
    uint64_t v20 = v11 + v19;
    if (v11 + v19 <= 0xF)
    {
      if (v19)
      {
        char v62 = 0;
        unint64_t v63 = 0LL;
        do
        {
          unint64_t v64 = v11 + v63;
          unint64_t v65 = v63 + 1;
          if (v63 >= 8) {
            unint64_t v66 = a2;
          }
          else {
            unint64_t v66 = a1;
          }
          unint64_t v67 = v66 >> (v62 & 0x38);
          char v68 = (8 * v11 + v62) & 0x38;
          uint64_t v69 = (-255LL << v68) - 1;
          unint64_t v70 = (unint64_t)v67 << v68;
          Swift::UInt64 v71 = v70 | v69 & rawBits;
          unint64_t v72 = v70 | v69 & v9;
          if (v64 < 8) {
            uint64_t v9 = v72;
          }
          else {
            Swift::UInt64 rawBits = v71;
          }
          v62 += 8;
          unint64_t v63 = v65;
        }

        while (v19 != v65);
      }

      goto LABEL_92;
    }

    uint64_t v18 = 1LL;
  }

  uint64_t v102 = a1 & 0xFFFFFFFFFFFFLL;
  if (v18) {
    int64_t v21 = HIBYTE(a2) & 0xF;
  }
  else {
    int64_t v21 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v105 = v21;
  uint64_t v106 = v18;
  Swift::Int v104 = v17;
  if ((a2 & 0x1000000000000000LL) == 0)
  {
    size_t v103 = v12;
    if ((rawBits & 0x1000000000000000LL) == 0) {
      goto LABEL_24;
    }
LABEL_103:
    Swift::Int v90 = String.UTF8View._foreignCount()();
    uint64_t v22 = v90 + v21;
    if (!__OFADD__(v90, v21)) {
      goto LABEL_25;
    }
LABEL_105:
    __break(1u);
    goto LABEL_106;
  }

  v80._Swift::UInt64 rawBits = (v21 << 16) | 1;
  v81._Swift::UInt64 rawBits = 1LL;
  Swift::UInt64 v82 = _StringGuts.validateScalarRange(_:)(v81, v80, a1, a2);
  Swift::UInt64 v86 = v83;
  if (v82 >= 0x10000) {
    Swift::UInt64 v87 = v82;
  }
  else {
    Swift::UInt64 v87 = v82 | 3;
  }
  swift_bridgeObjectRetain(a2, v83, v84, v85);
  v88._Swift::UInt64 rawBits = v87;
  v89._Swift::UInt64 rawBits = v86;
  int64_t v21 = specialized Collection.count.getter(v88, v89, a1, a2);
  swift_bridgeObjectRelease(a2);
  size_t v17 = v104;
  size_t v103 = v12;
  if ((rawBits & 0x1000000000000000LL) != 0) {
    goto LABEL_103;
  }
LABEL_24:
  uint64_t v22 = v17 + v21;
  if (__OFADD__(v17, v21)) {
    goto LABEL_105;
  }
LABEL_25:
  char v107 = v4;
  unint64_t v23 = v10;
  Swift::UInt64 v24 = v9 & ~rawBits;
  if ((v24 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(rawBits & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v25 = _StringGuts.nativeUnusedCapacity.getter(v9, v23);
    if ((v8._rawBits & 1) != 0)
    {
      unint64_t v97 = 258LL;
LABEL_126:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v97,  0);
    }

    if (v22 > 15 || (rawBits & 0x2000000000000000LL) == 0 && v25 >= v21) {
      goto LABEL_31;
    }
  }

  else if (v22 > 15)
  {
LABEL_31:
    int64_t v26 = _StringGuts.nativeUnusedCapacity.getter(v9, v23);
    BOOL v29 = (v27 & 1) == 0 && v26 >= v21;
    if ((v24 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(rawBits & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v29) {
        goto LABEL_79;
      }
    }

    else if (v29)
    {
      goto LABEL_61;
    }

    uint64_t v43 = 2 * _StringGuts.nativeCapacity.getter(v9, v23);
    if ((v44 & 1) != 0) {
      uint64_t v43 = 0LL;
    }
    if (v43 > v22) {
      uint64_t v22 = v43;
    }
LABEL_61:
    uint64_t v45 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v46 & 1) != 0)
    {
      Swift::Int v47 = v104;
      if ((rawBits & 0x1000000000000000LL) != 0) {
        Swift::Int v47 = String.UTF8View._foreignCount()();
      }
    }

    else
    {
      Swift::Int v47 = 2 * v45;
    }

    if (v47 <= v22) {
      int64_t v21 = v22;
    }
    else {
      int64_t v21 = v47;
    }
    if ((rawBits & 0x1000000000000000LL) == 0)
    {
      if ((rawBits & 0x2000000000000000LL) != 0)
      {
        unint64_t __src = v9;
        uint64_t v109 = rawBits & 0xFFFFFFFFFFFFFFLL;
        unint64_t v51 = v11 | 0xC000000000000000LL;
        if ((rawBits & 0x4000000000000000LL) == 0) {
          unint64_t v51 = v11;
        }
        uint64_t v52 = v51 | 0x3000000000000000LL;
        int64_t v50 = _allocateStringStorage(codeUnitCapacity:)(v21);
        *(void *)(v50 + 16) = v53;
        *(void *)(v50 + 24) = v52;
        if (v53 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
          uint64_t v52 = *(void *)(v50 + 24);
        }

        *(_BYTE *)(v50 + 32 + (v52 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v11, (char *)(v50 + 32));
      }

      else
      {
        if ((v9 & 0x1000000000000000LL) != 0)
        {
          unint64_t v48 = (char *)((rawBits & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v49 = v103;
        }

        else
        {
          unint64_t v48 = (char *)_StringObject.sharedUTF8.getter(v9, v23);
        }

        int64_t v50 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v48,  v49,  v21,  v9 < 0);
      }

      unint64_t v54 = *(void *)(v50 + 24);
      swift_bridgeObjectRelease(v111);
      unint64_t v110 = v54;
      unint64_t v111 = v50;
LABEL_79:
      if ((a2 & 0x1000000000000000LL) == 0)
      {
LABEL_80:
        Swift::String::Index v4 = v107;
        if (v106)
        {
          unint64_t __src = a1;
          uint64_t v109 = a2 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v55 = (a2 >> 62) & 1;
          uint64_t v56 = specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(a2) & 0xF,  (uint64_t)&__src,  HIBYTE(a2) & 0xF);
          unint64_t v61 = v57;
          a2 = v111;
          uint64_t v58 = v111 & 0xFFFFFFFFFFFFFFFLL;
          unint64_t v59 = (char *)v56;
          size_t v60 = v61;
          LOBYTE(v61) = v55;
        }

        else
        {
          if ((a1 & 0x1000000000000000LL) != 0)
          {
            uint64_t v74 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
            uint64_t v75 = a1 & 0xFFFFFFFFFFFFLL;
            uint64_t v76 = a1 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            id v95 = _StringObject.sharedUTF8.getter(a1, a2);
            if (v96 < v102) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
            }
            uint64_t v74 = (uint64_t)v95;
            uint64_t v76 = v96;
            Swift::String::Index v4 = v107;
            uint64_t v75 = a1 & 0xFFFFFFFFFFFFLL;
          }

          uint64_t v77 = specialized UnsafeBufferPointer.init(rebasing:)(0LL, v75, v74, v76);
          size_t v79 = v78;
          a2 = v111;
          uint64_t v58 = v111 & 0xFFFFFFFFFFFFFFFLL;
          unint64_t v61 = a1 >> 63;
          unint64_t v59 = (char *)v77;
          size_t v60 = v79;
        }

        closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v58, v59, v60, v61);
        a1 = *(void *)(a2 + 24);
        goto LABEL_108;
      }

void Substring.append<A>(contentsOf:)(unint64_t *a1, ValueMetadata *a2, uint64_t a3)
{
  Swift::String::Index v4 = v3;
  v8._Swift::UInt64 rawBits = *v3;
  v9._Swift::UInt64 rawBits = v3[1];
  unint64_t v10 = v3[2];
  unint64_t v11 = v3[3];
  uint64_t v12 = specialized String.init(_:)(v8, v9, v10, v11);
  Swift::UInt64 v14 = v13;
  swift_bridgeObjectRelease(v11);
  String.append<A>(contentsOf:)(a1, a2, a3);
  uint64_t v15 = HIBYTE(v14) & 0xF;
  if ((v14 & 0x2000000000000000LL) == 0) {
    uint64_t v15 = v12;
  }
  uint64_t v16 = 7LL;
  if (((v14 >> 60) & ((v12 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v16 = 11LL;
  }
  *Swift::String::Index v4 = 15LL;
  v4[1] = v16 | (v15 << 16);
  v4[2] = v12;
  v4[3] = v14;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance Substring( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(void, void, uint64_t, uint64_t, uint64_t))Substring.replaceSubrange<A>(_:with:));
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance Substring@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, char *a3@<X3>, uint64_t *a4@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a1[1], a2, a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance Substring@<X0>( uint64_t *a1@<X0>, ValueMetadata *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = Substring.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

void protocol witness for RangeReplaceableCollection.append(_:) in conformance Substring( unint64_t *a1)
{
  unint64_t v2 = *a1;
  Swift::UInt64 v3 = a1[1];
  v4._Swift::UInt64 rawBits = *(void *)(v1 + 8);
  v5._Swift::UInt64 rawBits = v4._rawBits;
  specialized Substring._replaceSubrange<A>(_:with:)(v4, v5, v2, v3);
  swift_bridgeObjectRelease(v3);
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance Substring( unint64_t *a1, ValueMetadata *a2, uint64_t a3)
{
  return (*((uint64_t (**)(unint64_t *, ValueMetadata *))a2[-1].Description + 1))(a1, a2);
}

void protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance Substring( unint64_t *a1, Swift::UInt64 *a2)
{
  unint64_t v2 = *a1;
  Swift::UInt64 v3 = a1[1];
  v5._Swift::UInt64 rawBits = *a2;
  v4._Swift::UInt64 rawBits = v5._rawBits;
  specialized Substring._replaceSubrange<A>(_:with:)(v4, v5, v2, v3);
  swift_bridgeObjectRelease(v3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance Substring( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance String( a1,  a2,  a3,  a4,  a5,  a6,  (void (*)(uint64_t, void))specialized RangeReplaceableCollection.insert<A>(contentsOf:at:));
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance Substring@<X0>( Swift::UInt64 *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.remove(at:)(*a1);
  *a2 = result;
  a2[1] = v4;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance Substring( Swift::UInt64 *a1)
{
  v1._Swift::UInt64 rawBits = a1[1];
  v2._Swift::UInt64 rawBits = *a1;
  specialized Substring._replaceSubrange<A>(_:with:)(v2, v1);
}

uint64_t protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance Substring@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection<>._customRemoveLast()();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance Substring@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection<>.removeFirst()();
  *a1 = result;
  a1[1] = v3;
  return result;
}

void protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance Substring( uint64_t (*a1)(void *), uint64_t a2)
{
}

void Substring.filter(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  if ((a3 ^ a4) >= 0x4000)
  {
    uint64_t v7 = &_swiftEmptyArrayStorage;
    Swift::UInt64 rawBits = a3;
    do
    {
      uint64_t v25 = (uint64_t)v7;
      while (1)
      {
        uint64_t v13 = Substring.subscript.getter(rawBits, a3, a4, a5, a6);
        uint64_t v15 = v14;
        unint64_t v16 = _StringGuts.validateCharacterIndex(_:in:)(rawBits, a3, a4, a5, a6);
        Swift::UInt64 rawBits = Substring._uncheckedIndex(after:)((Swift::String::Index)v16)._rawBits;
        char v17 = a1(v13, v15);
        if (v6)
        {
          swift_release(v25);
          swift_bridgeObjectRelease(v15);
          return;
        }

        if ((v17 & 1) != 0) {
          break;
        }
        swift_bridgeObjectRelease(v15);
        if (!((rawBits ^ a4) >> 14))
        {
          uint64_t v7 = (__objc2_class **)v25;
          goto LABEL_16;
        }
      }

      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v25);
      uint64_t v7 = (__objc2_class **)v25;
      uint64_t v28 = (__objc2_class **)v25;
      if (!isUniquelyReferenced_nonNull_native)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v25 + 16) + 1LL,  1);
        uint64_t v7 = (__objc2_class **)v25;
      }

      unint64_t v20 = (unint64_t)v7[2];
      unint64_t v19 = (unint64_t)v7[3];
      int64_t v21 = (__objc2_class *)(v20 + 1);
      if (v20 >= v19 >> 1)
      {
        Swift::UInt64 v24 = v7[2];
        int64_t v26 = (__objc2_class *)(v20 + 1);
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v19 > 1),  v20 + 1,  1);
        unint64_t v20 = (unint64_t)v24;
        int64_t v21 = v26;
        uint64_t v7 = v28;
      }

      void v7[2] = v21;
      uint64_t v22 = &v7[2 * v20];
      v22[4] = (__objc2_class *)v13;
      v22[5] = (__objc2_class *)v15;
    }

    while ((rawBits ^ a4) >= 0x4000);
  }

  else
  {
    uint64_t v7 = &_swiftEmptyArrayStorage;
  }

void protocol witness for TextOutputStream._writeASCII(_:) in conformance Substring( uint8x16_t *a1, uint64_t a2)
{
  unint64_t v2 = specialized static String._uncheckedFromASCII(_:)(a1, a2);
  uint64_t v4 = v3;
  specialized Substring.append<A>(contentsOf:)(v2, v3, v5, v6);
  swift_bridgeObjectRelease(v4);
}

void Substring.write<A>(to:)( uint64_t a1, Swift::String::Index a2, Swift::String::Index a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = specialized String.init(_:)(a2, a3, a4, a5);
  uint64_t v12 = v11;
  (*(void (**)(uint64_t))(a7 + 24))(v10);
  swift_bridgeObjectRelease(v12);
}

void protocol witness for TextOutputStreamable.write<A>(to:) in conformance Substring( uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6._Swift::UInt64 rawBits = *v3;
  v7._Swift::UInt64 rawBits = v3[1];
  Substring.write<A>(to:)(a1, v6, v7, v3[2], v3[3], a2, a3);
}

void *__SwiftNativeNSArrayWithContiguousStorage.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t __SwiftNativeNSArrayWithContiguousStorage.init()()
{
  return v0;
}

uint64_t __SwiftNativeNSArrayWithContiguousStorage.deinit()
{
  return v0;
}

void closure #1 in __SwiftNativeNSArrayWithContiguousStorage.count.getter(uint64_t a1@<X1>, void *a2@<X8>)
{
  *a2 = a1;
}

uint64_t closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (a3 < 0 || a3 >= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index out of range",  24LL,  2,  "Swift/SwiftNativeNSArray.swift",  30LL,  2,  0x50uLL,  0);
  }
  *a4 = *(void *)(result + 8 * a3);
  return result;
}

uint64_t @objc __SwiftNativeNSArrayWithContiguousStorage.objectAtSubscript(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v5[2] = a3;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void *, void *))(*(void *)a1 + 88LL))( &v6,  a4,  v5,  &unk_189B86EF8);
  return v6;
}

id @objc _SwiftNSMutableArray.objectAtSubscript(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 16);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(a3, (v4 & 0xC000000000000001LL) == 0, v4);
  if ((v4 & 0xC000000000000001LL) != 0)
  {
    id v8 = specialized _ArrayBuffer._getElementSlowPath(_:)(a3, v4, v6, v7);
  }

  else
  {
    id v8 = *(id *)(v4 + 8 * a3 + 32);
    swift_unknownObjectRetain(v8, v5, v6, v7);
  }

  swift_unknownObjectRelease(v8);
  return v8;
}

void _SwiftNSMutableArray.getObjects(_:range:)(void *__dst, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v8 = *(void *)(v4 + 16);
  if ((v8 & 0x8000000000000000LL) != 0 || (v8 & 0x4000000000000000LL) != 0)
  {
    unint64_t v13 = swift_bridgeObjectRetain(v8, a2, a3, a4);
    uint64_t v14 = specialized _copyCollectionToContiguousArray<A>(_:)(v13);
    specialized closure #1 in Array.withContiguousStorageIfAvailable<A>(_:)( (char *)v14 + 32,  (uint64_t)v14[2],  a2,  a3,  __dst);
    swift_release((uint64_t)v14);
    goto LABEL_13;
  }

  if (a2 < 0 || (uint64_t v9 = *(void *)((v8 & 0xFFFFFFFFFFFFFF8LL) + 0x10), v9 < a2))
  {
    unint64_t v12 = 188LL;
    goto LABEL_16;
  }

  uint64_t v10 = a2 + a3;
  if (__OFADD__(a2, a3))
  {
    __break(1u);
    goto LABEL_19;
  }

  if (v10 < 0 || v9 < v10)
  {
    unint64_t v12 = 192LL;
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index out of range",  24LL,  2,  "Swift/SwiftNativeNSArray.swift",  30LL,  2,  v12,  0);
  }

  if (v9)
  {
    if ((unint64_t)(a3 - 0x1000000000000000LL) >> 61 == 7)
    {
      size_t v11 = 8 * a3;
      if (((8 * a3) & 0x8000000000000000LL) == 0)
      {
        memmove(__dst, (const void *)((v8 & 0xFFFFFFFFFFFFFF8LL) + 8 * a2 + 32), v11);
        goto LABEL_12;
      }

Swift::Void __swiftcall _SwiftNSMutableArray.exchange(at:with:)(Swift::Int at, Swift::Int with)
{
  if (at != with)
  {
    uint64_t v5 = *(void *)(v2 + 16);
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(at, (v5 & 0xC000000000000001LL) == 0, v5);
    if ((v5 & 0xC000000000000001LL) != 0)
    {
      id v9 = specialized _ArrayBuffer._getElementSlowPath(_:)(at, v5, v7, v8);
    }

    else
    {
      id v9 = *(id *)(v5 + 8 * at + 32);
      swift_unknownObjectRetain(v9, v6, v7, v8);
    }

    uint64_t v10 = *(void *)(v2 + 16);
    specialized Array._checkSubscript(_:wasNativeTypeChecked:)(with, (v10 & 0xC000000000000001LL) == 0, v10);
    if ((v10 & 0xC000000000000001LL) != 0)
    {
      id v14 = specialized _ArrayBuffer._getElementSlowPath(_:)(with, v10, v12, v13);
    }

    else
    {
      id v14 = *(id *)(v10 + 8 * with + 32);
      swift_unknownObjectRetain(v14, v11, v12, v13);
    }

    uint64_t v15 = *(void *)(v2 + 16);
    int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(v15);
    *(void *)(v2 + 16) = v15;
    if (!isUniquelyReferenced_nonNull_bridgeObject || v15 < 0 || (v15 & 0x4000000000000000LL) != 0)
    {
      uint64_t v15 = specialized _ArrayBuffer._consumeAndCreateNew()(v15);
      *(void *)(v2 + 16) = v15;
    }

    specialized Array._checkSubscript_mutating(_:)(at, v15);
    char v17 = *(void **)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8LL) + 8 * at + 0x20);
    *(void *)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8LL) + 8 * at + 0x2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = v14;
    swift_unknownObjectRelease(v17);
    uint64_t v18 = *(void *)(v2 + 16);
    if (v18 < 0 || (v18 & 0x4000000000000000LL) != 0)
    {
      uint64_t v18 = specialized _ArrayBuffer._consumeAndCreateNew()(*(void *)(v2 + 16));
      *(void *)(v2 + 16) = v18;
    }

    specialized Array._checkSubscript_mutating(_:)(with, v18);
    unint64_t v19 = *(void **)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8LL) + 8 * with + 0x20);
    *(void *)((*(void *)(v2 + 16) & 0xFFFFFFFFFFFFFF8LL) + 8 * with + 0x2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = v9;
    swift_unknownObjectRelease(v19);
  }

void _SwiftNSMutableArray.replaceObjects(in:with:count:)(char *a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v5 = (uint64_t)&a1[a2];
  if (__OFADD__(a1, a2))
  {
    __break(1u);
    goto LABEL_11;
  }

  if (a4 < 0) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  unint64_t v11 = *(void *)(v4 + 16);
  uint64_t v10 = (uint64_t *)(v4 + 16);
  uint64_t v9 = v11;
  if (v11 >> 62)
  {
    if (v9 < 0) {
      uint64_t v15 = (void *)v9;
    }
    else {
      uint64_t v15 = (void *)(v9 & 0xFFFFFFFFFFFFFF8LL);
    }
    unint64_t v16 = (unint64_t)objc_msgSend(v15, sel_count);
    if ((v16 & 0x8000000000000000LL) == 0)
    {
      unint64_t v12 = v16;
      goto LABEL_6;
    }

uint64_t _SwiftNSMutableArray.index(ofObjectIdenticalTo:)(id a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v6 = *(void *)(v4 + 16);
  if ((unint64_t)v6 >> 62)
  {
    if (v6 < 0) {
      uint64_t v14 = *(void **)(v4 + 16);
    }
    else {
      uint64_t v14 = (void *)(v6 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(v6, a2, a3, a4);
    id v7 = objc_msgSend(v14, sel_count);
    if (!v7) {
      goto LABEL_15;
    }
  }

  else
  {
    id v7 = *(id *)((v6 & 0xFFFFFFFFFFFFF8LL) + 0x10);
    swift_bridgeObjectRetain(*(void *)(v4 + 16), a2, a3, a4);
    if (!v7) {
      goto LABEL_15;
    }
  }

  if ((v6 & 0xC000000000000001LL) == 0)
  {
    if (!*(void *)((v6 & 0xFFFFFFFFFFFFF8LL) + 0x10)) {
      goto LABEL_18;
    }
    if (*(id *)(v6 + 32) != a1) {
      goto LABEL_6;
    }
LABEL_25:
    swift_bridgeObjectRelease(v6);
    return 0LL;
  }

  id v15 = specialized _ArrayBuffer._getElementSlowPath(_:)(0LL, v6, v8, v9);
  swift_unknownObjectRelease(v15);
  if (v15 == a1) {
    goto LABEL_25;
  }
LABEL_6:
  if (v7 != (id)1)
  {
    uint64_t v10 = 5LL;
    while (1)
    {
      unint64_t v11 = v10 - 4;
      if ((v6 & 0xC000000000000001LL) != 0)
      {
        id v12 = specialized _ArrayBuffer._getElementSlowPath(_:)(v10 - 4, v6, v8, v9);
        swift_unknownObjectRelease(v12);
        if (v12 == a1) {
          goto LABEL_16;
        }
      }

      else
      {
        if (v11 >= *(void *)((v6 & 0xFFFFFFFFFFFFFF8LL) + 0x10)) {
          goto LABEL_18;
        }
        if (*(id *)(v6 + 8 * v10) == a1)
        {
LABEL_16:
          swift_bridgeObjectRelease(v6);
          return v11;
        }
      }

      id v13 = (id)(v10 - 3);
      if (__OFADD__(v11, 1LL)) {
        break;
      }
      ++v10;
      if (v13 == v7) {
        goto LABEL_15;
      }
    }

    __break(1u);
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }

void _SwiftNSMutableArray.setObject(_:at:)(void *a1, unint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v9 = *(void *)(v4 + 16);
  id v7 = (uint64_t *)(v4 + 16);
  uint64_t v8 = v9;
  if (v9 >> 62)
  {
    if (v8 < 0) {
      id v13 = (void *)v8;
    }
    else {
      id v13 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
    }
    if (objc_msgSend(v13, sel_count) == (id)a2) {
      goto LABEL_3;
    }
    uint64_t v8 = *v7;
  }

  else if (*(void *)((v8 & 0xFFFFFFFFFFFFF8LL) + 0x10) == a2)
  {
LABEL_3:
    swift_unknownObjectRetain(a1, a2, a3, a4);
    specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
    uint64_t v10 = *v7 & 0xFFFFFFFFFFFFFF8LL;
    unint64_t v12 = *(void *)(v10 + 0x10);
    unint64_t v11 = *(void *)(v10 + 0x18);
    if (v12 >= v11 >> 1)
    {
      uint64_t v16 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( v11 > 1,  v12 + 1,  1,  *v7);
      *id v7 = v16;
      uint64_t v10 = v16 & 0xFFFFFFFFFFFFFF8LL;
    }

    *(void *)(v10 + 16) = v12 + 1;
    *(void *)(v10 + 8 * v12 + 32) = a1;
    return;
  }

  swift_unknownObjectRetain(a1, a2, a3, a4);
  int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(v8);
  *id v7 = v8;
  if (!isUniquelyReferenced_nonNull_bridgeObject || v8 < 0 || (v8 & 0x4000000000000000LL) != 0)
  {
    uint64_t v8 = specialized _ArrayBuffer._consumeAndCreateNew()(v8);
    *id v7 = v8;
  }

  specialized Array._checkSubscript_mutating(_:)(a2, v8);
  id v15 = *(void **)((*v7 & 0xFFFFFFFFFFFFFF8LL) + 8 * a2 + 0x20);
  *(void *)((*v7 & 0xFFFFFFFFFFFFFF8LL) + 8 * a2 + 0x2_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = a1;
  swift_unknownObjectRelease(v15);
}

void @objc _SwiftNSMutableArray.setObject(_:at:)(unint64_t *a1, uint64_t a2, void *a3, char *a4)
{
}

void _SwiftNSMutableArray.__allocating_init()()
{
}

void _SwiftNSMutableArray.init()()
{
}

void _SwiftNSMutableArray.__ivar_destroyer()
{
}

uint64_t _SwiftNSMutableArray.deinit()
{
  return v0;
}

void _SwiftNSMutableArray.__deallocating_deinit()
{
}

unint64_t *__SwiftDeferredNSArray._nativeStorage.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain(*(unint64_t **)(v4 + 24), a2, a3, a4);
}

uint64_t __SwiftDeferredNSArray.init(_nativeStorage:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0LL;
  *(void *)(v1 + 24) = a1;
  return v1;
}

uint64_t _SwiftDeferredNSSet.__ivar_destroyer()
{
  return swift_release(*(void *)(v0 + 24));
}

uint64_t __SwiftDeferredNSArray.deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (void *)atomic_load((unint64_t *)(v4 + 16));
  if (v5)
  {
    uint64_t v6 = v5[2];
    swift_unknownObjectRetain(v5, a2, a3, a4);
    if (v6 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
    }
    swift_arrayDestroy((uint64_t)(v5 + 3), v6, (uint64_t)&unk_189B8D230);
    swift_unknownObjectRelease(v5);
    uint64_t v7 = *(void **)(v4 + 16);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  swift_unknownObjectRelease(v7);
  swift_release(*(void *)(v4 + 24));
  return v4;
}

void __SwiftDeferredNSArray.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (void *)atomic_load((unint64_t *)(v4 + 16));
  if (v5)
  {
    uint64_t v6 = v5[2];
    swift_unknownObjectRetain(v5, a2, a3, a4);
    if (v6 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
    }
    swift_arrayDestroy((uint64_t)(v5 + 3), v6, (uint64_t)&unk_189B8D230);
    swift_unknownObjectRelease(v5);
    uint64_t v7 = *(void **)(v4 + 16);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  swift_unknownObjectRelease(v7);
  swift_release(*(void *)(v4 + 24));
  swift_deallocClassInstance(v4);
}

uint64_t __SwiftDeferredNSArray.withUnsafeBufferOfObjects<A>(_:)(uint64_t (*a1)(unint64_t))
{
  uint64_t v2 = v1;
  unint64_t v3 = a1;
  uint64_t v4 = (unint64_t *)(v1 + 16);
  unint64_t v5 = atomic_load((unint64_t *)(v1 + 16));
  if (v5)
  {
    if ((*(void *)(v5 + 16) & 0x8000000000000000LL) != 0) {
      goto LABEL_18;
    }
  }

  else
  {
    uint64_t v23 = a1;
LABEL_7:
    while (2)
    {
      uint64_t v8 = *(void *)(v2 + 24);
      unint64_t v9 = (*(void *(**)(unint64_t *__return_ptr, uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X1>, void *@<X8>), void, void *))(*(void *)v8 + 112LL))( &v21,  protocol witness for LosslessStringConvertible.init(_:) in conformance String,  0LL,  &unk_189B871D8);
      if (v22 != 1)
      {
        unint64_t v6 = v21;
        unint64_t v3 = v23;
        return v3(v6);
      }

      uint64_t v10 = (unint64_t *)(*(uint64_t (**)(void *))(*(void *)v8 + 120LL))(v9);
      swift_retain_n((uint64_t)v10, 2LL, v11, v12);
      while (!__ldaxr(v4))
      {
        if (!__stlxr((unint64_t)v10, v4))
        {
          swift_release_n((uint64_t)v10, 2LL);
          unint64_t v5 = atomic_load(v4);
          if (v5) {
            goto LABEL_17;
          }
          goto LABEL_7;
        }
      }

      __clrex();
      swift_release_n((uint64_t)v10, 2LL);
      unint64_t v14 = type metadata accessor for __BridgingBufferStorage(0LL);
      uint64_t v18 = swift_retain(v10, v15, v16, v17);
      uint64_t v19 = swift_dynamicCastClass((uint64_t)v18, v14);
      swift_release((uint64_t)v10);
      if (!v19) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
      }
      uint64_t v20 = v10[2];
      if (v20 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
      }
      swift_arrayDestroy((uint64_t)(v10 + 3), v20, (uint64_t)&unk_189B8D230);
      swift_release((uint64_t)v10);
      unint64_t v5 = atomic_load(v4);
      if (!v5) {
        continue;
      }
      break;
    }

void __SwiftDeferredNSArray.__allocating_init()()
{
}

void __SwiftDeferredNSArray.init()()
{
}

uint64_t __SwiftDeferredStaticNSArray.withUnsafeBufferOfObjects<A>(_:)(uint64_t a1)
{
  uint64_t v2 = (uint64_t (*)(unint64_t))a1;
  unint64_t v3 = (unint64_t *)(v1 + 16);
  unint64_t v4 = atomic_load((unint64_t *)(v1 + 16));
  if (!v4)
  {
LABEL_6:
    while (2)
    {
      unint64_t v6 = (unint64_t *)__SwiftDeferredStaticNSArray.getNonVerbatimBridgingBuffer()(a1);
      swift_retain_n((uint64_t)v6, 2LL, v7, v8);
      do
      {
        if (__ldaxr(v3))
        {
          __clrex();
          swift_release_n((uint64_t)v6, 2LL);
          unint64_t v10 = type metadata accessor for __BridgingBufferStorage(0LL);
          unint64_t v14 = swift_retain(v6, v11, v12, v13);
          uint64_t v15 = swift_dynamicCastClass((uint64_t)v14, v10);
          swift_release((uint64_t)v6);
          if (!v15) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
          }
          uint64_t v16 = v6[2];
          if (v16 < 0) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
          }
          swift_arrayDestroy((uint64_t)(v6 + 3), v16, (uint64_t)&unk_189B8D230);
          a1 = swift_release((uint64_t)v6);
          unint64_t v4 = atomic_load(v3);
          if (v4) {
            goto LABEL_2;
          }
          goto LABEL_6;
        }
      }

      while (__stlxr((unint64_t)v6, v3));
      a1 = swift_release_n((uint64_t)v6, 2LL);
      unint64_t v4 = atomic_load(v3);
      if (!v4) {
        continue;
      }
      break;
    }
  }

unint64_t __SwiftDeferredStaticNSArray.getNonVerbatimBridgingBuffer()(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(*v1 + 120LL);
  uint64_t v3 = *(v2 - 1);
  uint64_t v4 = *(void *)(v3 + 64);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  int64_t v26 = (id *)((char *)&v25 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v5);
  uint64_t v7 = (id *)((char *)&v25 - v6);
  uint64_t v8 = (unint64_t *)v1[3];
  unint64_t v9 = v8[2];
  unint64_t result = type metadata accessor for __BridgingBufferStorage(0LL);
  if (v9 >> 60)
  {
    __break(1u);
    goto LABEL_14;
  }

  if (__OFADD__(8 * v9, 24LL))
  {
LABEL_14:
    __break(1u);
    return result;
  }

  char v27 = swift_bufferAllocate(result, 8 * v9 + 24, 7uLL);
  uint64_t v28 = v8;
  __int128 v27[2] = v9;
  swift_retain(v8, v11, v12, v13);
  if (v9)
  {
    unint64_t v14 = v27 + 3;
    uint64_t v15 = (char *)v28 + ((*(unsigned __int8 *)(v3 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
    uint64_t v16 = *(void *)(v3 + 72);
    char v17 = *(void (**)(id *, char *, uint64_t *))(v3 + 16);
    do
    {
      v17(v7, v15, v2);
      if (_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
      {
        if (v4 != 8) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }
        unint64_t v21 = *v7;
        swift_unknownObjectRetain(*v7, v18, v19, v20);
        (*(void (**)(id *, uint64_t *))(v3 + 8))(v7, v2);
      }

      else
      {
        char v22 = v26;
        (*(void (**)(id *, id *, uint64_t *))(v3 + 32))(v26, v7, v2);
        unint64_t v21 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v22, v2, v23, v24);
      }

      *v14++ = v21;
      v15 += v16;
      --v9;
    }

    while (v9);
  }

  swift_release((uint64_t)v28);
  return (unint64_t)v27;
}

void __SwiftDeferredStaticNSArray.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (void *)atomic_load((unint64_t *)(v4 + 16));
  if (v5)
  {
    uint64_t v6 = v5[2];
    swift_unknownObjectRetain(v5, a2, a3, a4);
    if (v6 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
    }
    swift_arrayDestroy((uint64_t)(v5 + 3), v6, (uint64_t)&unk_189B8D230);
    swift_unknownObjectRelease(v5);
    uint64_t v7 = *(void **)(v4 + 16);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  swift_unknownObjectRelease(v7);
  swift_release(*(void *)(v4 + 24));
  swift_deallocClassInstance(v4);
}

uint64_t __ContiguousArrayStorageBase.countAndCapacity.getter()
{
  return *(void *)(v0 + 16);
}

uint64_t __ContiguousArrayStorageBase.countAndCapacity.setter(uint64_t result, uint64_t a2)
{
  *(void *)(v2 + 16) = result;
  *(void *)(v2 + 24) = a2;
  return result;
}

uint64_t (*__ContiguousArrayStorageBase.countAndCapacity.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __ContiguousArrayStorageBase.index(ofObjectIdenticalTo:)(id a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (v4 < 0 || (v4 & 0x4000000000000000LL) != 0)
  {
    id v6 = objc_msgSend((id)v4, sel_count);
    if (!v6) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }

  else
  {
    id v6 = *(id *)(v4 + 16);
    if (!v6) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }

  if ((v4 & 0xC000000000000001LL) == 0)
  {
    if (!*(void *)(v4 + 16)) {
      goto LABEL_19;
    }
    if (*(id *)(v4 + 32) != a1) {
      goto LABEL_7;
    }
    return 0LL;
  }

  id v11 = specialized _ArrayBuffer._getElementSlowPath(_:)(0LL, v4, a3, a4);
  swift_unknownObjectRelease(v11);
  if (v11 == a1) {
    return 0LL;
  }
LABEL_7:
  if (v6 != (id)1)
  {
    uint64_t v7 = 1LL;
    for (uint64_t i = 5LL; ; ++i)
    {
      unint64_t v9 = i - 4;
      if ((v4 & 0xC000000000000001LL) != 0)
      {
        id v10 = specialized _ArrayBuffer._getElementSlowPath(_:)(i - 4, v4, a3, a4);
        swift_unknownObjectRelease(v10);
        if (v10 == a1) {
          return v7;
        }
      }

      else
      {
        if (v9 >= *(void *)(v4 + 16)) {
          goto LABEL_19;
        }
        if (*(id *)(v4 + 8 * i) == a1) {
          return i - 4;
        }
      }

      uint64_t v7 = i - 3;
      if (__OFADD__(v9, 1LL)) {
        break;
      }
      if ((id)v7 == v6) {
        return 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    __break(1u);
LABEL_19:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }

  return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t @objc _SwiftNSMutableArray.index(ofObjectIdenticalTo:)( unint64_t *a1, uint64_t a2, void *a3, char *a4)
{
  uint64_t v10 = ((uint64_t (*)(void *))a4)(a3);
  swift_unknownObjectRelease(a3);
  swift_release((uint64_t)a1);
  return v10;
}

void __ContiguousArrayStorageBase.init()()
{
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.multipliedReportingOverflow(by:)(Swift::Int by)
{
  Swift::Int v2 = v1 * by;
  Swift::Bool v3 = (unsigned __int128)(v1 * (__int128)by) >> 64 != (v1 * by) >> 63;
  Swift::Int v4 = v2;
  result.partialValue = v4;
  result.overfuint64_t low = v3;
  return result;
}

void *static UnsafeMutableRawPointer.allocate(byteCount:alignment:)(size_t a1, uint64_t a2)
{
  if (a2 <= 16) {
    unint64_t v2 = -1LL;
  }
  else {
    unint64_t v2 = a2 - 1;
  }
  return swift_slowAlloc(a1, v2);
}

int64_t static UnsafeMutablePointer.allocate(capacity:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 - 8);
  uint64_t v4 = *(void *)(v3 + 72);
  int64_t result = v4 * a1;
  if ((unsigned __int128)(v4 * (__int128)a1) >> 64 == result >> 63)
  {
    unsigned int v6 = *(unsigned __int8 *)(v3 + 80);
    if (v6 > 0xF) {
      uint64_t v7 = v6 + 1;
    }
    else {
      uint64_t v7 = 0LL;
    }
    return (int64_t)swift_slowAlloc(result, v7 - 1);
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t _UIntBuffer._storage.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*_UIntBuffer._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t _UIntBuffer._bitCount.getter(unint64_t a1)
{
  return HIDWORD(a1);
}

uint64_t _UIntBuffer._bitCount.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 4) = result;
  return result;
}

uint64_t (*_UIntBuffer._bitCount.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t _UIntBuffer.init(_storage:_bitCount:)(unsigned int a1, unsigned __int8 a2)
{
  return a1 | ((unint64_t)a2 << 32);
}

unint64_t _UIntBuffer.init(containing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)(a3 + 8) + 120LL))(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v6 | ((unint64_t)(*(unsigned __int8 (**)(uint64_t, uint64_t))(a3 + 56))(a2, a3) << 32);
}

uint64_t _UIntBuffer.Iterator._impl.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t _UIntBuffer.Iterator._impl.setter(uint64_t result)
{
  *(_DWORD *)uint64_t v1 = result;
  *(_BYTE *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t (*_UIntBuffer.Iterator._impl.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UIntBuffer.Iterator.init(_:)(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t _UIntBuffer.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int v7 = *((unsigned __int8 *)v4 + 4);
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v7) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56LL))( a4,  1LL,  1LL,  v8);
  }
  unsigned int v16 = *v5;
  unsigned int v9 = v16;
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = *(void *)(v10 + 8);
  uint64_t v12 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v11 + 96);
  unint64_t v13 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  v12(&v16, &type metadata for UInt32, v13, v8, v11);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56LL))(a4, 0LL, 1LL, v8);
  unint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 56);
  *uint64_t v5 = v9 >> v14(v8, v10);
  uint64_t result = v14(v8, v10);
  *((_BYTE *)v5 + 4) = v7 - result;
  return result;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _UIntBuffer<A>.Iterator@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int v7 = *((unsigned __int8 *)v4 + 4);
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v7) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56LL))( a4,  1LL,  1LL,  v8);
  }
  unsigned int v16 = *v5;
  unsigned int v9 = v16;
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = *(void *)(v10 + 8);
  uint64_t v12 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v11 + 96);
  unint64_t v13 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  v12(&v16, &type metadata for UInt32, v13, v8, v11);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56LL))(a4, 0LL, 1LL, v8);
  unint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 56);
  *uint64_t v5 = v9 >> v14(v8, v10);
  uint64_t result = v14(v8, v10);
  *((_BYTE *)v5 + 4) = v7 - result;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _UIntBuffer<A>.Iterator@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return Sequence<>.makeIterator()(a1, a2);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _UIntBuffer<A>.Iterator( uint64_t a1, uint64_t a2)
{
  return Sequence._copyToContiguousArray()(a1, a2);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _UIntBuffer<A>.Iterator()
{
  return Sequence._copyContents(initializing:)();
}

uint64_t _UIntBuffer.makeIterator()(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

void protocol witness for Sequence.makeIterator() in conformance _UIntBuffer<A>(uint64_t a1@<X8>)
{
  char v2 = *(_BYTE *)(v1 + 4);
  *(_DWORD *)a1 = *(_DWORD *)v1;
  *(_BYTE *)(a1 + 4) = v2;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t _UIntBuffer.Index.bitOffset.setter(uint64_t result)
{
  _BYTE *v1 = result;
  return result;
}

uint64_t (*_UIntBuffer.Index.bitOffset.modify())()
{
  return EnumeratedSequence._base.modify;
}

BOOL static _UIntBuffer.Index.== infix(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

BOOL static _UIntBuffer.Index.< infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance _UIntBuffer<A>.Index( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return static _UIntBuffer.Index.< infix(_:_:)(*a1, *a2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _UIntBuffer<A>.Index( char *a1, char *a2)
{
  return static _UIntBuffer.Index.== infix(_:_:)(*a1, *a2);
}

uint64_t _UIntBuffer.startIndex.getter()
{
  return 0LL;
}

unint64_t _UIntBuffer.endIndex.getter(unint64_t a1)
{
  return HIDWORD(a1);
}

uint64_t _UIntBuffer.index(after:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(unsigned int (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4) + a1;
}

uint64_t _UIntBuffer._elementWidth.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized _UIntBuffer._elementWidth.getter(a2, a3);
}

uint64_t _UIntBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v9 = a2 >> a1;
  uint64_t v5 = *(void *)(a4 + 8);
  unsigned int v6 = *(uint64_t (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
  unint64_t v7 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  return v6(&v9, &type metadata for UInt32, v7, a3, v5);
}

void protocol witness for Collection.startIndex.getter in conformance _UIntBuffer<A>(_BYTE *a1@<X8>)
{
  *a1 = 0;
}

void protocol witness for Collection.endIndex.getter in conformance _UIntBuffer<A>(_BYTE *a1@<X8>)
{
  *a1 = *(_BYTE *)(v1 + 4);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _UIntBuffer<A>( void *a1, char *a2, uint64_t a3))()
{
  unint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = _UIntBuffer.subscript.read(v7, *a2, *v3, *(void *)(a3 + 16), *(void *)(a3 + 24));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*_UIntBuffer.subscript.read( void *a1, char a2, unsigned int a3, uint64_t a4, uint64_t a5))()
{
  unsigned int v9 = a1;
  uint64_t v10 = *(void *)(a4 - 8);
  *a1 = a4;
  a1[1] = v10;
  uint64_t v11 = malloc(*(void *)(v10 + 64));
  *((_DWORD *)v9 + 6) = a3 >> a2;
  v9 += 3;
  *(v9 - 1) = v11;
  uint64_t v12 = *(void *)(a5 + 8);
  unint64_t v13 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v12 + 96);
  unint64_t v16 = lazy protocol witness table accessor for type UInt32 and conformance UInt32((uint64_t)v11, v14, v15);
  v13(v9, &type metadata for UInt32, v16, a4, v12);
  return _ArrayBuffer.subscript.read;
}

void protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance _UIntBuffer<A>( uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 0;
  *(_BYTE *)(a1 + 2) = 1;
}

uint64_t _UIntBuffer.index(_:offsetBy:)(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a1 + (*(unsigned int (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5) * a2;
}

uint64_t _UIntBuffer.distance(from:to:)( unsigned __int8 a1, unsigned __int8 a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5);
  if (!v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  return (uint64_t)(a2 - (unint64_t)a1) / v7;
}

uint64_t protocol witness for Collection.index(after:) in conformance _UIntBuffer<A>@<X0>( char *a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v4 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a3 = result + v4;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance _UIntBuffer<A>( char *a1, uint64_t a2)
{
  char v3 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a1 = result + v3;
  return result;
}

uint64_t _UIntBuffer.index(before:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 - (*(unsigned int (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _UIntBuffer<A>@<X0>( char *a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v4 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a3 = v4 - result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance _UIntBuffer<A>( char *a1, uint64_t a2)
{
  char v3 = *a1;
  uint64_t result = specialized _UIntBuffer._elementWidth.getter(*(void *)(a2 + 16), *(void *)(a2 + 24));
  *a1 = v3 - result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _UIntBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _UIntBuffer<A>@<X0>( char *a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  char v6 = *a1;
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a3 + 24) + 56LL))();
  *a4 = v6 + result * a2;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _UIntBuffer<A>( unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a2;
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(a3 + 24) + 56LL))();
  if (!v5) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  return (v4 - v3) / v5;
}

uint64_t FixedWidthInteger._fullShiftLeft<A>(_:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v52 = a6;
  uint64_t v55 = a4;
  size_t v49 = a1;
  uint64_t v53 = *(void *)(a5 + 8);
  uint64_t v9 = *(void *)(*(void *)(v53 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v13 = (char *)&v41 - v12;
  uint64_t v47 = *(void *)(a3 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  unint64_t v16 = (char *)&v41 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v41 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v48 = (char *)&v41 - v21;
  uint64_t v50 = *(void *)(a2 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::UInt64 v24 = (char *)&v41 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  unint64_t v54 = (char *)&v41 - v25;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v13, a3, v9);
  uint64_t v27 = a5;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 80))(v19, v16, a3, a5);
  uint64_t v28 = *(uint64_t (**)(char *, uint64_t))(v47 + 8);
  uint64_t v29 = v28(v16, a3);
  uint64_t v56 = 1LL;
  uint64_t v30 = v53;
  uint64_t v47 = *(void *)(v53 + 96);
  uint64_t v31 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v47;
  unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v29, v32, v33);
  v31(&v56, &type metadata for Int, v46, a3, v30);
  char v44 = *(void (**)(char *, char *, uint64_t, uint64_t))(v27 + 200);
  uint64_t v45 = v27;
  unint64_t v34 = v48;
  v44(v19, v16, a3, v27);
  v28(v16, a3);
  v28(v19, a3);
  uint64_t v35 = v55;
  uint64_t v36 = *(void *)(v55 + 8);
  uint64_t v43 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v36 + 96);
  uint64_t v37 = v53;
  v43(v34, a3, v53, a2, v36);
  unint64_t v42 = *(void (**)(uint64_t, char *, uint64_t, uint64_t))(v35 + 216);
  v42(v51, v24, a2, v35);
  char v38 = *(void (**)(char *, uint64_t))(v50 + 8);
  v38(v24, a2);
  uint64_t v56 = 1LL;
  ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v47)( &v56,  &type metadata for Int,  v46,  a3,  v37);
  v44(v49, v19, a3, v45);
  v28(v19, a3);
  v43(v34, a3, v37, a2, v36);
  uint64_t v39 = v54;
  v42((uint64_t)v54, v24, a2, v55);
  v38(v24, a2);
  return ((uint64_t (*)(char *, uint64_t))v38)(v39, a2);
}

uint64_t FixedWidthInteger._fullShiftRight<A>(_:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v52 = a6;
  uint64_t v55 = a4;
  size_t v49 = a1;
  uint64_t v53 = *(void *)(a5 + 8);
  uint64_t v9 = *(void *)(*(void *)(v53 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v13 = (char *)&v41 - v12;
  uint64_t v47 = *(void *)(a3 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  unint64_t v16 = (char *)&v41 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v41 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v48 = (char *)&v41 - v21;
  uint64_t v50 = *(void *)(a2 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::UInt64 v24 = (char *)&v41 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  unint64_t v54 = (char *)&v41 - v25;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v13, a3, v9);
  uint64_t v27 = a5;
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 80))(v19, v16, a3, a5);
  uint64_t v28 = *(uint64_t (**)(char *, uint64_t))(v47 + 8);
  uint64_t v29 = v28(v16, a3);
  uint64_t v56 = 1LL;
  uint64_t v30 = v53;
  uint64_t v47 = *(void *)(v53 + 96);
  uint64_t v31 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v47;
  unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v29, v32, v33);
  v31(&v56, &type metadata for Int, v46, a3, v30);
  char v44 = *(void (**)(char *, char *, uint64_t, uint64_t))(v27 + 200);
  uint64_t v45 = v27;
  unint64_t v34 = v48;
  v44(v19, v16, a3, v27);
  v28(v16, a3);
  v28(v19, a3);
  uint64_t v35 = v55;
  uint64_t v36 = *(void *)(v55 + 8);
  uint64_t v43 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v36 + 96);
  uint64_t v37 = v53;
  v43(v34, a3, v53, a2, v36);
  unint64_t v42 = *(void (**)(uint64_t, char *, uint64_t, uint64_t))(v35 + 200);
  v42(v51, v24, a2, v35);
  char v38 = *(void (**)(char *, uint64_t))(v50 + 8);
  v38(v24, a2);
  uint64_t v56 = 1LL;
  ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v47)( &v56,  &type metadata for Int,  v46,  a3,  v37);
  v44(v49, v19, a3, v45);
  v28(v19, a3);
  v43(v34, a3, v37, a2, v36);
  uint64_t v39 = v54;
  v42((uint64_t)v54, v24, a2, v55);
  v38(v24, a2);
  return ((uint64_t (*)(char *, uint64_t))v38)(v39, a2);
}

uint64_t static FixedWidthInteger._lowBits<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v73 = a5;
  uint64_t v74 = a4;
  uint64_t v75 = a1;
  uint64_t v70 = a6;
  uint64_t v68 = *(void *)(a5 + 8);
  unint64_t v63 = *(const char **)(*(void *)(v68 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = (void (*)(void, void, void, void, void))swift_getAssociatedTypeWitness( 0LL,  v63,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v61 = (char *)&v56 - v10;
  uint64_t v65 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  unint64_t v13 = (char *)&v56 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  char v62 = (char *)&v56 - v15;
  MEMORY[0x1895F8858](v14);
  unint64_t v66 = (char *)&v56 - v16;
  uint64_t v71 = *(void *)(a4 + 8);
  uint64_t v17 = *(void *)(*(void *)(v71 + 24) + 16LL);
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v17,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v21 = (char *)&v56 - v20;
  uint64_t v22 = *(void *)(a2 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v19);
  unint64_t v64 = (char *)&v56 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v56 - v26;
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  unint64_t v59 = (char *)&v56 - v29;
  MEMORY[0x1895F8858](v28);
  uint64_t v69 = (char *)&v56 - v30;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v17,  a2,  v18,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v18,  AssociatedConformanceWitness);
  uint64_t v32 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 24);
  uint64_t v58 = v27;
  v32(v21, a2, v17);
  unint64_t v67 = *(void (**)(char *, uint64_t))(v71 + 184);
  uint64_t v33 = v71;
  v67(v27, a2);
  unint64_t v72 = *(void (**)(char *, uint64_t))(v22 + 8);
  v72(v27, a2);
  unint64_t v34 = v63;
  uint64_t v35 = AssociatedTypeWitness;
  unint64_t v36 = swift_getAssociatedConformanceWitness( (uint64_t)v63,  a3,  (uint64_t)AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v37 = v61;
  (*(void (**)(uint64_t *, uint64_t, void (*)(void, void, void, void, void), unint64_t))(v36 + 8))( &qword_18180BE70,  512LL,  v35,  v36);
  (*((void (**)(char *, uint64_t, const char *))v34 + 3))(v37, a3, v34);
  char v38 = v62;
  uint64_t v39 = v73;
  (*(void (**)(char *, char *, uint64_t))(v73 + 80))(v62, v13, a3);
  unint64_t v40 = *(uint64_t (**)(char *, uint64_t))(v65 + 8);
  uint64_t v41 = v40(v13, a3);
  v76[0] = 1LL;
  uint64_t v42 = v68;
  uint64_t v65 = *(void *)(v68 + 96);
  uint64_t v43 = (void (*)(void *, ValueMetadata *, const char *, uint64_t, uint64_t))v65;
  unint64_t v63 = (const char *)lazy protocol witness table accessor for type Int and conformance Int(v41, v44, v45);
  v43(v76, &type metadata for Int, v63, a3, v42);
  uint64_t v46 = v39;
  unint64_t v61 = *(char **)(v39 + 200);
  uint64_t v47 = v66;
  ((void (*)(char *, char *, uint64_t, uint64_t))v61)(v38, v13, a3, v46);
  v40(v13, a3);
  v40(v38, a3);
  unint64_t AssociatedTypeWitness = *(void (**)(void, void, void, void, void))(v33 + 96);
  unint64_t v48 = v64;
  AssociatedTypeWitness(v47, a3, v42, a2, v33);
  unint64_t v57 = *(void (**)(char *, char *, uint64_t))(v74 + 216);
  uint64_t v50 = v58;
  size_t v49 = v59;
  v57(v59, v48, a2);
  uint64_t v51 = v72;
  v72(v48, a2);
  v51(v49, a2);
  v76[0] = 1LL;
  ((void (*)(void *, ValueMetadata *, const char *, uint64_t, uint64_t))v65)( v76,  &type metadata for Int,  v63,  a3,  v42);
  ((void (*)(uint64_t, char *, uint64_t, uint64_t))v61)(v75, v38, a3, v73);
  v40(v38, a3);
  uint64_t v52 = v71;
  AssociatedTypeWitness(v47, a3, v42, a2, v71);
  uint64_t v53 = v69;
  ((void (*)(char *, char *, uint64_t, uint64_t))v57)(v50, v48, a2, v74);
  unint64_t v54 = v72;
  v72(v48, a2);
  v54(v50, a2);
  ((void (*)(char *, uint64_t, uint64_t))v67)(v53, a2, v52);
  return ((uint64_t (*)(char *, uint64_t))v54)(v53, a2);
}

uint64_t Range._contains_(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v6, v6, "lower upper ", 0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v64 = (char *)&v62 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v62 - v10;
  uint64_t v12 = *(void *)(v6 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v9);
  uint64_t v15 = (char *)&v62 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  unint64_t v18 = (char *)&v62 - v17;
  uint64_t v71 = *(void *)(a2 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v70 = (char *)&v62 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v69 = (char *)&v62 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v63 = (char *)&v62 - v24;
  MEMORY[0x1895F8858](v23);
  unint64_t v67 = (char *)&v62 - v25;
  uint64_t v26 = *(char **)(a2 + 24);
  char v62 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, char *))*((void *)v26 + 5);
  char v27 = v62(v3, a1, v6, v26);
  uint64_t v66 = v12;
  if ((v27 & 1) != 0)
  {
    uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
    v28(v18, v3, v6);
    uint64_t v29 = v26;
    uint64_t v30 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))*((void *)v26 + 2);
  }

  else
  {
    uint64_t v73 = v15;
    uint64_t v31 = a1;
    uint64_t v32 = v3 + *(int *)(a2 + 36);
    uint64_t v33 = v26;
    uint64_t v30 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))*((void *)v26 + 2);
    unint64_t v34 = v33;
    char v35 = v30(v32, v31, v6);
    uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
    if ((v35 & 1) != 0)
    {
      unint64_t v36 = v18;
      uint64_t v37 = v32;
    }

    else
    {
      unint64_t v36 = v18;
      uint64_t v37 = v31;
    }

    v28(v36, v37, v6);
    a1 = v31;
    uint64_t v29 = v34;
    uint64_t v15 = v73;
  }

  uint64_t v65 = a2;
  uint64_t v38 = *(int *)(a2 + 36);
  uint64_t v39 = v3 + v38;
  uint64_t v72 = a1;
  uint64_t v73 = v29;
  uint64_t v40 = a1 + v38;
  if ((v30(v3 + v38, v40, v6) & 1) == 0)
  {
    if ((v62(v3, v40, v6, v73) & 1) != 0) {
      uint64_t v39 = v3;
    }
    else {
      uint64_t v39 = v40;
    }
  }

  v28(v15, v39, v6);
  uint64_t v41 = TupleTypeMetadata2;
  uint64_t v42 = &v11[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v43 = v66;
  uint64_t v44 = *(void (**)(char *, char *, uint64_t))(v66 + 32);
  v44(v11, v18, v6);
  v44(v42, v15, v6);
  uint64_t v45 = v64;
  uint64_t v46 = &v64[*((int *)v41 + 12)];
  v28(v64, (uint64_t)v11, v6);
  v28(v46, (uint64_t)v42, v6);
  uint64_t v47 = v63;
  v44(v63, v45, v6);
  unint64_t v48 = *(void (**)(char *, uint64_t))(v43 + 8);
  v48(v46, v6);
  size_t v49 = &v45[*((int *)v41 + 12)];
  v44(v45, v11, v6);
  v44(v49, v42, v6);
  uint64_t v50 = v65;
  v44(&v47[*(int *)(v65 + 36)], v49, v6);
  v48(v45, v6);
  uint64_t v51 = v71;
  uint64_t v52 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  uint64_t v53 = v67;
  v52(v67, v47, v50);
  uint64_t v54 = v72;
  uint64_t v55 = *((void *)v73 + 1);
  uint64_t v56 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v55 + 8);
  LOBYTE(v45) = v56(v53, v72, v6, v55);
  unint64_t v57 = v69;
  v52(v69, v53, v50);
  uint64_t v58 = v70;
  (*(void (**)(char *, uint64_t, uint64_t))(v51 + 16))(v70, v54, v50);
  else {
    char v59 = 0;
  }
  size_t v60 = *(void (**)(char *, uint64_t))(v51 + 8);
  v60(v58, v50);
  v60(v57, v50);
  return v59 & 1;
}

uint64_t _UIntBuffer.init()()
{
  return 0LL;
}

uint64_t _UIntBuffer.capacity.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized _UIntBuffer.capacity.getter(a2, a3);
}

uint64_t static UInt32.bitWidth.getter()
{
  return 32LL;
}

uint64_t _UIntBuffer.append(_:)(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2)
{
  uint64_t v3 = v2;
  unint64_t v113 = a1;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(v6 + 8);
  unint64_t v119 = *(const char **)(*(void *)(v7 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v119,  v5,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v117 = &v107[-v9];
  uint64_t v10 = *(void *)(v5 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v110 = &v107[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  size_t v115 = &v107[-v14];
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v111 = &v107[-v16];
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = &v107[-v18];
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v121 = &v107[-v21];
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v116 = &v107[-v23];
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v122 = &v107[-v25];
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = &v107[-v27];
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = &v107[-v29];
  char v31 = v2[4];
  int v123 = *(_DWORD *)v2;
  char v124 = v31;
  uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", a2, v32);
  uint64_t v34 = Collection.count.getter(a2, WitnessTable);
  if (__OFADD__(v34, 1LL))
  {
    __break(1u);
LABEL_39:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
  }

  if (specialized _UIntBuffer.capacity.getter(v5, v6) < v34 + 1) {
    goto LABEL_39;
  }
  uint64_t v109 = v19;
  char v35 = *(void (**)(uint64_t, uint64_t))(v6 + 64);
  uint64_t v112 = v6;
  v35(v5, v6);
  unint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  char v37 = v36(v5, v7);
  unint64_t v120 = v36;
  if ((v37 & 1) != 0)
  {
    (*(void (**)(_BYTE *, _BYTE *, uint64_t))(v10 + 16))(v28, v30, v5);
    unint64_t v38 = AssociatedTypeWitness;
    uint64_t v39 = v119;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v119,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v41 = v117;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v38,  AssociatedConformanceWitness);
    uint64_t v42 = v122;
    (*((void (**)(_BYTE *, uint64_t, const char *))v39 + 3))(v41, v5, v39);
    LOBYTE(v38) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 32LL))( v28,  v42,  v5);
    uint64_t v43 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
    v43(v42, v5);
    if ((v38 & 1) == 0) {
      goto LABEL_40;
    }
    v43(v28, v5);
    unint64_t v36 = v120;
  }

  uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 128);
  uint64_t v45 = v44(v5, v7);
  unint64_t v114 = v44;
  if (v45 >= 32)
  {
    uint64_t v46 = *(void (**)(_BYTE *, _BYTE *, uint64_t))(v10 + 16);
    v46(v116, v30, v5);
    unsigned int v125 = -1;
    char v47 = v36(v5, v7);
    uint64_t v44 = v114;
    uint64_t v48 = v114(v5, v7);
    if ((v47 & 1) != 0)
    {
      if (v48 < 33)
      {
        unint64_t v51 = AssociatedTypeWitness;
        uint64_t v52 = v119;
        unint64_t v53 = swift_getAssociatedConformanceWitness( (uint64_t)v119,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v117;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v53 + 8))( &unk_18180BE68,  256LL,  v51,  v53);
        uint64_t v55 = v122;
        (*((void (**)(_BYTE *, uint64_t, const char *))v52 + 3))(v54, v5, v52);
        uint64_t v56 = v116;
        LOBYTE(v51) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL)
                                                                           + 40LL))( v116,  v55,  v5);
        unint64_t v57 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
        v57(v55, v5);
        unsigned int v108 = v125;
        uint64_t v58 = v109;
        v46(v109, v56, v5);
        if ((v51 & 1) != 0)
        {
          unsigned int v59 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
          v57(v58, v5);
          unint64_t v36 = v120;
          size_t v60 = v116;
          uint64_t v44 = v114;
          if (v108 < v59) {
            goto LABEL_34;
          }
        }

        else
        {
          v57(v58, v5);
          unint64_t v36 = v120;
          size_t v60 = v116;
          uint64_t v44 = v114;
        }

uint64_t _UIntBuffer.removeFirst()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", a1, a3);
  uint64_t v7 = Collection.isEmpty.getter(a1, WitnessTable);
  if ((v7 & 1) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xC8uLL,  0);
  }
  unsigned int v19 = *v3;
  unsigned int v10 = v19;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v13 = *(void *)(v12 + 8);
  uint64_t v14 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v13 + 96);
  unint64_t v15 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v7, v8, v9);
  v14(&v19, &type metadata for UInt32, v15, v11, v13);
  char v16 = *((_BYTE *)v4 + 4);
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 56);
  *((_BYTE *)v4 + 4) = v16 - v17(v11, v12);
  uint64_t result = v17(v11, v12);
  *uint64_t v4 = v10 >> ((result + 1) >> 1) >> (result >> 1);
  return result;
}

uint64_t _UIntBuffer.replaceSubrange<A>(_:with:)( uint64_t a1, uint64_t (*a2)(uint64_t, void *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v189 = a2;
  unsigned int v8 = a1;
  uint64_t v161 = a1;
  uint64_t v9 = BYTE1(a1);
  uint64_t v11 = *(void *)(a3 + 16);
  uint64_t v10 = *(void *)(a3 + 24);
  uint64_t v175 = a3;
  uint64_t v188 = v10;
  uint64_t v12 = *(void **)(v10 + 8);
  uint64_t v180 = *(const char **)(v12[3] + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v180,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  Swift::String::Index v178 = (char *)&v158 - v14;
  Swift::String::Index v168 = *(void **)(v11 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v163 = (char *)&v158 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v162 = (char *)&v158 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  Swift::String::Index v173 = (char *)&v158 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v165 = (char *)&v158 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  Swift::String::Index v167 = (char *)&v158 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v186 = (char *)&v158 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  Swift::String::Index v166 = (char *)&v158 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  char v31 = (char *)&v158 - v30;
  MEMORY[0x1895F8858](v29);
  uint64_t v181 = (char *)&v158 - v32;
  uint64_t v35 = type metadata accessor for Optional(0LL, v11, v33, v34);
  MEMORY[0x1895F8858](v35);
  Swift::String::Index v174 = (char *)&v158 - v36;
  uint64_t v37 = *(void *)(a5 + 8);
  unint64_t v177 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v37,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v38 = MEMORY[0x1895F8858](v177);
  Swift::String::Index v176 = (char *)&v158 - v39;
  MEMORY[0x1895F8858](v38);
  uint64_t v43 = (char *)&v158 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v164 = v9;
  if (v9 < v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v160 = v5;
  unsigned int v44 = *(unsigned __int8 *)(v5 + 4);
  if (v44 < v8 || v44 < v164) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xD4uLL,  0);
  }
  uint64_t v158 = v41;
  (*(void (**)(char *, uint64_t (*)(uint64_t, void *), uint64_t))(v40 + 16))(v43, v189, a4);
  (*(void (**)(uint64_t, uint64_t))(v37 + 32))(a4, v37);
  unint64_t v45 = v177;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v37,  a4,  v177,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v47 = v45;
  uint64_t v48 = v174;
  Swift::String::Index v171 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v172 = AssociatedConformanceWitness;
  v171(v47);
  uint64_t v49 = v168;
  Swift::Int v170 = (uint64_t (*)(char *, uint64_t, uint64_t))v168[6];
  if (v170(v48, 1LL, v11) != 1)
  {
    int v51 = 0;
    uint64_t v52 = 0LL;
    Swift::String::Index v169 = (void (*)(char *, char *, uint64_t))v49[4];
    uint64_t v185 = v31;
    uint64_t v53 = v175;
    unint64_t v159 = v12;
    v169(v181, v48, v11);
    while (1)
    {
      unsigned int v190 = v51;
      char v191 = v52;
      uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", v53, v54);
      uint64_t v69 = Collection.count.getter(v53, WitnessTable);
      if (__OFADD__(v69, 1LL))
      {
        __break(1u);
LABEL_52:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
      }

      uint64_t v70 = v188;
      if (specialized _UIntBuffer.capacity.getter(v11, v188) < v69 + 1) {
        goto LABEL_52;
      }
      uint64_t v184 = v52;
      (*(void (**)(uint64_t, uint64_t))(v70 + 64))(v11, v70);
      uint64_t v189 = (uint64_t (*)(uint64_t, void *))v12[8];
      if ((v189(v11, v12) & 1) != 0)
      {
        int v71 = v51;
        uint64_t v72 = (void (*)(char *, char *, uint64_t))v49[2];
        unint64_t v73 = v12;
        uint64_t v74 = v49;
        unint64_t v75 = v166;
        v72(v166, v31, v11);
        unint64_t v76 = AssociatedTypeWitness;
        uint64_t v77 = v180;
        unint64_t v78 = swift_getAssociatedConformanceWitness( (uint64_t)v180,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v79 = v178;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v78 + 8))( &unk_18180BE68,  256LL,  v76,  v78);
        uint64_t v80 = v186;
        uint64_t v81 = v79;
        Swift::UInt64 v82 = v75;
        uint64_t v49 = v74;
        uint64_t v12 = v73;
        (*((void (**)(char *, uint64_t, const char *))v77 + 3))(v81, v11, v77);
        LOBYTE(v76) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v73[4] + 8LL) + 32LL))( v82,  v80,  v11);
        unint64_t v83 = (void (*)(char *, uint64_t))v49[1];
        v83(v80, v11);
        if ((v76 & 1) == 0) {
          goto LABEL_53;
        }
        v83(v82, v11);
        char v31 = v185;
        int v51 = v71;
      }

      int v183 = v51;
      uint64_t v84 = (uint64_t (*)(uint64_t, void *))v12[16];
      uint64_t v85 = v84(v11, v12);
      char v86 = v181;
      if (v85 >= 32) {
        break;
      }
LABEL_30:
      char v187 = (uint64_t (*)(uint64_t, void *))v12[15];
      uint64_t v182 = v187(v11, v12);
      unint64_t v113 = (void (*)(char *, uint64_t))v49[1];
      v113(v31, v11);
      if ((v189(v11, v12) & 1) != 0)
      {
        unint64_t v114 = (void (*)(char *, char *, uint64_t))v49[2];
        size_t v115 = v165;
        v114(v165, v86, v11);
        unint64_t v116 = AssociatedTypeWitness;
        unint64_t v117 = v180;
        unint64_t v118 = swift_getAssociatedConformanceWitness( (uint64_t)v180,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v119 = v178;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v118 + 8))( &unk_18180BE68,  256LL,  v116,  v118);
        unint64_t v120 = v186;
        (*((void (**)(char *, uint64_t, const char *))v117 + 3))(v119, v11, v117);
        LOBYTE(v116) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8LL) + 32LL))( v115,  v120,  v11);
        v113(v120, v11);
        if ((v116 & 1) == 0) {
LABEL_53:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
        v113(v115, v11);
        uint64_t v49 = v168;
        char v31 = v185;
        char v86 = v181;
      }

      if (v84(v11, v12) >= 32)
      {
        unint64_t v121 = v49;
        unint64_t v122 = (void (*)(char *, char *, uint64_t))v49[2];
        v122(v173, v86, v11);
        unsigned int v190 = -1;
        char v123 = v189(v11, v12);
        uint64_t v124 = v84(v11, v12);
        if ((v123 & 1) != 0)
        {
          if (v124 <= 32)
          {
            unint64_t v127 = AssociatedTypeWitness;
            uint64_t v128 = v180;
            unint64_t v129 = swift_getAssociatedConformanceWitness( (uint64_t)v180,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            id v130 = v178;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v129 + 8))( &unk_18180BE68,  256LL,  v127,  v129);
            uint64_t v131 = v186;
            (*((void (**)(char *, uint64_t, const char *))v128 + 3))(v130, v11, v128);
            uint64_t v58 = v173;
            LOBYTE(v127) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8LL) + 40LL))( v173,  v131,  v11);
            v113(v131, v11);
            unsigned int v132 = v190;
            size_t v133 = v162;
            v122(v162, v58, v11);
            if ((v127 & 1) != 0)
            {
              unsigned int v134 = v187(v11, v12);
              v113(v133, v11);
              BOOL v106 = v132 >= v134;
              uint64_t v49 = v168;
              char v86 = v181;
              if (!v106) {
                goto LABEL_54;
              }
            }

            else
            {
              v113(v133, v11);
              uint64_t v49 = v168;
              char v86 = v181;
            }

            goto LABEL_9;
          }
        }

        else if (v124 <= 32)
        {
          uint64_t v135 = v186;
          uint64_t v58 = v173;
          v122(v186, v173, v11);
          unsigned int v136 = v187(v11, v12);
          v113(v135, v11);
          uint64_t v49 = v121;
          if (v190 < v136) {
LABEL_54:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
          goto LABEL_9;
        }

        uint64_t v55 = (void (*)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, void *))v12[12];
        unint64_t v56 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v124, v125, v126);
        unint64_t v57 = v186;
        v55(&v190, &type metadata for UInt32, v56, v11, v12);
        uint64_t v58 = v173;
        char v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v12[4] + 8LL) + 16LL))(v57, v173, v11);
        v113(v57, v11);
        uint64_t v49 = v121;
        if ((v59 & 1) != 0) {
          goto LABEL_54;
        }
LABEL_9:
        v113(v58, v11);
        char v31 = v185;
      }

      int v60 = v184;
      char v61 = v184 & 0x1F;
      unint64_t v62 = v49;
      int v63 = v183 & ~((_DWORD)v182 << v184);
      int v64 = v187(v11, v12);
      v113(v86, v11);
      int v51 = (v64 << v61) | v63;
      uint64_t v49 = v62;
      uint64_t v65 = v86;
      uint64_t v52 = v60 + (*(unsigned int (**)(uint64_t))(v188 + 56))(v11);
      uint64_t v66 = v174;
      ((void (*)(unint64_t, unint64_t))v171)(v177, v172);
      int v67 = v170(v66, 1LL, v11);
      uint64_t v53 = v175;
      if (v67 == 1)
      {
        uint64_t v50 = v52;
        goto LABEL_44;
      }

      v169(v65, v66, v11);
    }

    Swift::UInt64 v87 = v49;
    Swift::String::Index v88 = (void (*)(char *, char *, uint64_t))v49[2];
    unint64_t v89 = v167;
    v88(v167, v31, v11);
    unsigned int v190 = -1;
    char v90 = v189(v11, v12);
    uint64_t v91 = v84(v11, v12);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 32)
      {
        unint64_t v94 = AssociatedTypeWitness;
        id v95 = v180;
        unint64_t v96 = swift_getAssociatedConformanceWitness( (uint64_t)v180,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v97 = v178;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v96 + 8))( &unk_18180BE68,  256LL,  v94,  v96);
        unsigned int v98 = v186;
        unint64_t v99 = v97;
        unsigned int v100 = v12;
        BOOL v101 = v168;
        (*((void (**)(char *, uint64_t, const char *))v95 + 3))(v99, v11, v95);
        LOBYTE(v10_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/StringRangeReplaceableCollection.swift",  44LL,  2,  0x168uLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v100[4] + 8LL) + 40LL))( v89,  v98,  v11);
        Swift::UInt64 v87 = v101;
        uint64_t v102 = (void (*)(char *, uint64_t))v101[1];
        v102(v98, v11);
        unsigned int v103 = v190;
        int v104 = v163;
        v88(v163, v89, v11);
        if ((v100 & 1) != 0)
        {
          uint64_t v12 = v159;
          unsigned int v105 = ((uint64_t (*)(uint64_t, void *))v159[15])(v11, v159);
          v102(v104, v11);
          BOOL v106 = v103 >= v105;
          unint64_t v89 = v167;
          char v86 = v181;
          if (!v106) {
            goto LABEL_54;
          }
        }

        else
        {
          v102(v104, v11);
          unint64_t v89 = v167;
          char v86 = v181;
          uint64_t v12 = v159;
        }

void protocol witness for RangeReplaceableCollection.init() in conformance _UIntBuffer<A>(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 0;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = v6;
  uint64_t v12 = (unsigned __int8 *)MEMORY[0x1895F8858](a1);
  uint64_t v16 = (char *)&v40 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *v12;
  uint64_t v18 = v12[1];
  if (v18 < v17) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unsigned int v19 = *((unsigned __int8 *)v9 + 4);
  if (v17 > v19 || v18 > v19) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xD4uLL,  0);
  }
  uint64_t v43 = v14;
  uint64_t v44 = v13;
  (*(void (**)(char *))(v14 + 16))(v16);
  RangeReplaceableCollection.init<A>(_:)((uint64_t)v16, a5, a3, a6, *(void *)(a4 + 8));
  int v21 = v49;
  char v22 = v50;
  uint64_t v23 = *(void *)(a5 + 16);
  uint64_t v24 = *(void *)(a5 + 24);
  uint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 56);
  uint64_t v25 = v42(v23, v24);
  if (!v25) {
LABEL_14:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  int v41 = v21;
  int v47 = v21;
  char v48 = v22;
  uint64_t v27 = (v18 - v17) / v25;
  uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", a5, v26);
  uint64_t v29 = Collection.count.getter(a5, WitnessTable);
  char v30 = *((_BYTE *)v9 + 4);
  unsigned int v45 = *v9;
  char v46 = v30;
  uint64_t v31 = WitnessTable;
  uint64_t v32 = v29 - v27;
  uint64_t v33 = Collection.count.getter(a5, v31);
  if (__OFADD__(v33, v32))
  {
    __break(1u);
LABEL_17:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xDDuLL,  0);
  }

  if (_UIntBuffer.capacity.getter(v33, v23, v24) < v33 + v32) {
    goto LABEL_17;
  }
  (*(void (**)(uint64_t, uint64_t))(v43 + 8))(v44, a3);
  uint64_t v34 = v42;
  uint64_t v35 = v42(v23, v24);
  if (!v35) {
    goto LABEL_14;
  }
  uint64_t v36 = v35;
  uint64_t v37 = v34(v23, v24);
  if (!v37) {
    goto LABEL_14;
  }
  uint64_t v38 = v18 / v37;
  uint64_t result = v34(v23, v24);
  unsigned int *v9 = (*v9 >> ((result * v38 + 1) >> 1) >> ((result * v38) >> 1) << (result * (v38 + v32))) | (v41 << (result * (v17 / v36))) | ((1 << ((result * (v17 / v36) + 1) >> 1) << ((result * (v17 / v36)) >> 1)) - 1) & *v9;
  *((_BYTE *)v9 + 4) += result * v32;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append(_:) in conformance _UIntBuffer<A>( _BYTE *a1, void *a2)
{
  uint64_t v4 = v2;
  unint64_t v108 = a1;
  uint64_t v5 = a2[2];
  uint64_t v6 = a2[3];
  uint64_t v7 = *(void *)(v6 + 8);
  BOOL v106 = *(const char **)(*(void *)(v7 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v106,  v5,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v104 = &v93[-v9];
  uint64_t v10 = *(_BYTE **)(v5 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v96 = &v93[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unsigned int v98 = &v93[-v14];
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v99 = &v93[-v16];
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v97 = &v93[-v18];
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unsigned int v103 = &v93[-v20];
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = &v93[-v22];
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = &v93[-v25];
  MEMORY[0x1895F8858](v24);
  uint64_t v28 = &v93[-v27];
  char v29 = *((_BYTE *)v2 + 4);
  int v109 = *v2;
  char v110 = v29;
  uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", a2, v30);
  uint64_t v32 = Collection.count.getter((uint64_t)a2, WitnessTable);
  if (__OFADD__(v32, 1LL))
  {
    __break(1u);
LABEL_37:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
  }

  uint64_t v33 = a2[4];
  if (_UIntBuffer.capacity.getter(v32, v5, v6) < v32 + 1) {
    goto LABEL_37;
  }
  uint64_t v100 = v33;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v5, v6);
  uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  char v35 = v34(v5, v7);
  uint64_t v101 = v6;
  uint64_t v102 = v34;
  if ((v35 & 1) != 0)
  {
    (*((void (**)(_BYTE *, _BYTE *, uint64_t))v10 + 2))(v26, v28, v5);
    unint64_t v36 = AssociatedTypeWitness;
    uint64_t v37 = v106;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v106,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v39 = v10;
    uint64_t v40 = v104;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v36,  AssociatedConformanceWitness);
    int v41 = v40;
    uint64_t v10 = v39;
    (*((void (**)(_BYTE *, uint64_t, const char *))v37 + 3))(v41, v5, v37);
    LOBYTE(v36) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 32LL))( v26,  v23,  v5);
    uint64_t v42 = (void (*)(_BYTE *, uint64_t))*((void *)v39 + 1);
    v42(v23, v5);
    if ((v36 & 1) == 0) {
      goto LABEL_38;
    }
    v42(v26, v5);
    uint64_t v34 = v102;
  }

  char v107 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 128);
  if (v107(v5, v7) >= 32)
  {
    id v95 = (void (*)(_BYTE *, _BYTE *, uint64_t))*((void *)v10 + 2);
    v95(v103, v28, v5);
    unsigned int v111 = -1;
    char v43 = v34(v5, v7);
    uint64_t v44 = v107(v5, v7);
    if ((v43 & 1) != 0)
    {
      if (v44 < 33)
      {
        unint64_t v47 = AssociatedTypeWitness;
        char v48 = v106;
        unint64_t v49 = swift_getAssociatedConformanceWitness( (uint64_t)v106,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v50 = v10;
        int v51 = v104;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v49 + 8))( &unk_18180BE68,  256LL,  v47,  v49);
        uint64_t v52 = v51;
        uint64_t v10 = v50;
        (*((void (**)(_BYTE *, uint64_t, const char *))v48 + 3))(v52, v5, v48);
        uint64_t v53 = v103;
        LOBYTE(v47) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL)
                                                                           + 40LL))( v103,  v23,  v5);
        uint64_t v54 = (void (*)(_BYTE *, uint64_t))*((void *)v50 + 1);
        v54(v23, v5);
        unsigned int v94 = v111;
        uint64_t v55 = v97;
        v95(v97, v53, v5);
        if ((v47 & 1) != 0)
        {
          unsigned int v56 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
          v54(v55, v5);
          uint64_t v34 = v102;
          unint64_t v57 = v103;
          if (v94 < v56) {
            goto LABEL_32;
          }
        }

        else
        {
          v54(v55, v5);
          uint64_t v34 = v102;
          unint64_t v57 = v103;
        }

uint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance _UIntBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = v3;
  uint64_t WitnessTable = swift_getWitnessTable(L"D\r\r\u0AD5", a1, a3);
  uint64_t v7 = Collection.isEmpty.getter(a1, WitnessTable);
  if ((v7 & 1) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xC8uLL,  0);
  }
  unsigned int v19 = *v3;
  unsigned int v10 = v19;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v13 = *(void *)(v12 + 8);
  uint64_t v14 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v13 + 96);
  unint64_t v15 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v7, v8, v9);
  v14(&v19, &type metadata for UInt32, v15, v11, v13);
  char v16 = *((_BYTE *)v5 + 4);
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 56);
  *((_BYTE *)v5 + 4) = v16 - v17(v11, v12);
  uint64_t result = v17(v11, v12);
  *uint64_t v5 = v10 >> ((result + 1) >> 1) >> (result >> 1);
  return result;
}

uint64_t static _UnicodeEncoding.transcode<A>(_:from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return static _UnicodeEncoding.transcode<A>(_:from:)(a1, a2, a5, a3, a6, a4);
}

{
  uint64_t v8;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a6 + 88))(a1, a4, a6);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 96))(v8, a3, a5);
}

uint64_t specialized static _UnicodeEncoding.transcode<A>(_:from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a4 + 88))(a1, a3, a4);
}

uint64_t static _UnicodeEncoding._isScalar(_:)()
{
  return 0LL;
}

uint64_t static _UnicodeEncoding._encode(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v11 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v15 = (char *)&v20 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v20 - v16;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 96))(a1, a2, a3);
  (*(void (**)(char *, char *, uint64_t))(v12 + 32))(v15, v17, v11);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t))(a3 + 80))(a2, a3);
  return (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v15, v11);
}

uint64_t static _UnicodeEncoding._transcode<A>(_:from:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v22 = a5;
  uint64_t v23 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a2,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v22 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  unsigned int v19 = (char *)&v22 - v18;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 104))(a1, a3, a3, v22, a2, a4);
  (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v17, v19, v13);
  uint64_t v20 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t))(a4 + 80))(a2, a4);
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v17, v13);
}

uint64_t static _UnicodeEncoding._transcode<A, B>(_:from:into:)( void (*a1)(char *, uint64_t, unint64_t, unint64_t, unint64_t), uint64_t a2, void (*a3)(char *), uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, const char *a8, const char *a9, const char *a10)
{
  uint64_t v10 = a8;
  uint64_t v81 = a4;
  unint64_t v82 = a6;
  unint64_t v80 = a3;
  unint64_t v83 = a1;
  int v62 = a9;
  uint64_t v88 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a8,  a5,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  unint64_t v84 = AssociatedTypeWitness;
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v75 = (char *)&v61 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v74 = (char *)&v61 - v20;
  uint64_t v21 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v73 = (char *)&v61 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  uint64_t v72 = (char *)&v61 - v24;
  unint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  a10,  a7,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v70 = *(void *)(v25 - 8);
  MEMORY[0x1895F8858](v25);
  unint64_t v69 = (char *)&v61 - v26;
  uint64_t v71 = v27;
  uint64_t v30 = type metadata accessor for Unicode.ParseResult(0LL, v27, v28, v29);
  uint64_t v31 = MEMORY[0x1895F8858](v30);
  uint64_t v33 = (unsigned __int8 *)&v61 - v32;
  uint64_t v64 = *(void *)(v82 - 8);
  MEMORY[0x1895F8858](v31);
  int v63 = (char *)&v61 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v78 = swift_getAssociatedTypeWitness( 0LL,  a9,  v35,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v66 = *(void *)(v78 - 8);
  MEMORY[0x1895F8858](v78);
  uint64_t v79 = (char *)&v61 - v36;
  unint64_t v37 = swift_getAssociatedTypeWitness( 0LL,  a10,  a7,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v65 = *(void *)(v37 - 8);
  MEMORY[0x1895F8858](v37);
  uint64_t v39 = (char *)&v61 - v38;
  uint64_t v76 = a10;
  uint64_t v77 = a7;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a10,  a7,  v37,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  char v86 = v39;
  uint64_t v40 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  unint64_t v87 = v37;
  v40(v37, AssociatedConformanceWitness);
  unint64_t v41 = v84;
  unint64_t v42 = v82;
  (*(void (**)(char *, void (*)(char *, uint64_t, unint64_t, unint64_t, unint64_t), unint64_t))(v64 + 16))( v63,  v83,  v82);
  uint64_t v43 = v78;
  unint64_t v44 = v42;
  uint64_t v45 = (uint64_t)v62;
  (*((void (**)(unint64_t))v62 + 4))(v44);
  unint64_t v83 = *(void (**)(char *, uint64_t, unint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 32);
  uint64_t v46 = v45;
  unint64_t v47 = v79;
  unint64_t v82 = swift_getAssociatedConformanceWitness( v46,  v82,  v43,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v68 = v30;
  unint64_t v67 = v33;
  while (1)
  {
    v83(v47, v43, v82, v87, AssociatedConformanceWitness);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v33, v30);
    if (EnumCaseMultiPayload) {
      break;
    }
    uint64_t v52 = v69;
    uint64_t v51 = v70;
    uint64_t v53 = v71;
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v70 + 32))(v69, v33, v71);
    uint64_t v54 = (void (*)(char *, uint64_t, uint64_t, const char *, uint64_t, const char *))*((void *)v10 + 13);
    uint64_t v55 = v10;
    unsigned int v56 = v74;
    v54(v52, v77, v77, v76, v88, v55);
    (*(void (**)(char *, uint64_t))(v51 + 8))(v52, v53);
    unint64_t v57 = v75;
    uint64_t v58 = v56;
    unint64_t v59 = v41;
    (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v75, v58, v15);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v21 + 48))(v57, 1LL, v41) == 1)
    {
      char v48 = v72;
      (*((void (**)(uint64_t, const char *))v55 + 10))(v88, v55);
      (*(void (**)(char *, uint64_t))(v16 + 8))(v57, v15);
    }

    else
    {
      char v48 = v72;
      (*(void (**)(char *, char *, unint64_t))(v21 + 32))(v72, v57, v59);
    }

    uint64_t v10 = v55;
    uint64_t v30 = v68;
    uint64_t v33 = v67;
    uint64_t v43 = v78;
    unint64_t v47 = v79;
LABEL_4:
    v80(v48);
    unint64_t v49 = v48;
    unint64_t v41 = v84;
    (*(void (**)(char *, unint64_t))(v21 + 8))(v49, v84);
  }

  if (EnumCaseMultiPayload == 1)
  {
    char v48 = v73;
    (*((void (**)(uint64_t, const char *))v10 + 10))(v88, v10);
    goto LABEL_4;
  }

  (*(void (**)(char *, uint64_t))(v66 + 8))(v47, v43);
  return (*(uint64_t (**)(char *, unint64_t))(v65 + 8))(v86, v87);
}

unint64_t Unicode._GraphemeBreakProperty.init(from:)(unsigned int a1)
{
  if (a1 < 0x20) {
    return 1LL;
  }
  if (a1 < 0x7F) {
    return 0LL;
  }
  if (a1 == 8205) {
    return 12LL;
  }
  uint64_t v2 = 4LL;
  if (a1 - 4448 > 0xFFFFFF9F) {
    return v2;
  }
  if (a1 - 43389 > 0xFFFFFFE2) {
    return v2;
  }
  uint64_t v2 = 11LL;
  if (a1 - 4520 > 0xFFFFFFB7) {
    return v2;
  }
  if (a1 - 55239 > 0xFFFFFFE8) {
    return v2;
  }
  uint64_t v2 = 10LL;
  if (a1 - 4608 > 0xFFFFFFA7 || a1 - 55292 > 0xFFFFFFCE) {
    return v2;
  }
  if (a1 - 55204 >= 0xFFFFD45C)
  {
    HIDWORD((*(void (**)(char *, uint64_t))(v11 + 16))((char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), v4) = -1227133513 * ((unsigned __int16)a1 - 16);
    LODWORD((*(void (**)(char *, uint64_t))(v11 + 16))((char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL), v4) = HIDWORD(v4);
    else {
      return 6LL;
    }
  }

  else if (a1 - 127488 > 0xFFFFFFE5)
  {
    return 8LL;
  }

  else
  {
    if (a1 - 131070 <= 0xFFFFFC01)
    {
      if (a1 - 921600 <= 0xFFFFF1EF)
      {
        unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(a1);
        if (GraphemeBreakProperty <= 5) {
          return 0x30309070201uLL >> (8 * GraphemeBreakProperty);
        }
        return 0LL;
      }

      return 1LL;
    }

    return 3LL;
  }

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:)(Swift::UInt8 a1)
{
  *(_DWORD *)&a1 = a1;
  LOBYTE(result._value) = a1;
  return result;
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:)(Swift::UInt8 a1, Swift::UInt8 a2)
{
  return (Swift::Unicode::Scalar)(a2 & 0x3F | ((a1 & 0x1F) << 6));
}

Swift::UInt32 __swiftcall _continuationPayload(_:)(Swift::UInt8 a1)
{
  return a1 & 0x3F;
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:_:)(Swift::UInt8 a1, Swift::UInt8 a2, Swift::UInt8 a3)
{
  return (Swift::Unicode::Scalar)(((a1 & 0xF) << 12) | ((a2 & 0x3F) << 6) | a3 & 0x3F);
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:_:_:)( Swift::UInt8 a1, Swift::UInt8 a2, Swift::UInt8 a3, Swift::UInt8 a4)
{
  return (Swift::Unicode::Scalar)(((a1 & 0xF) << 18) | ((a2 & 0x3F) << 12) | ((a3 & 0x3F) << 6) | a4 & 0x3F);
}

Swift::String::Index __swiftcall _StringGuts.scalarAlignSlow(_:)(Swift::String::Index result)
{
  if ((result._rawBits & 0xC000) != 0) {
    return (Swift::String::Index)(result._rawBits & 0xFFFFFFFFFFFF0000LL);
  }
  Swift::UInt64 v5 = result._rawBits >> 16;
  if (!(result._rawBits >> 16)) {
    return (Swift::String::Index)(result._rawBits & 0xFFFFFFFFFFFF0000LL);
  }
  if ((v2 & 0x1000000000000000LL) == 0)
  {
    void v13[2] = v3;
    v13[3] = v4;
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      v13[0] = v1;
      v13[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (v5 != (HIBYTE(v2) & 0xF) && (*((_BYTE *)v13 + v5) & 0xC0) == 0x80)
      {
        do
        {
          Swift::UInt64 v10 = v5 - 1;
          int v11 = *((_BYTE *)&v12 + v5-- + 7) & 0xC0;
        }

        while (v11 == 128);
        Swift::UInt64 v5 = v10;
      }

      return (Swift::String::Index)(v5 << 16);
    }

    if ((v1 & 0x1000000000000000LL) != 0)
    {
      uint64_t v6 = (_BYTE *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (v5 != (v1 & 0xFFFFFFFFFFFFLL))
      {
        do
LABEL_8:
          int v7 = v6[v5--] & 0xC0;
        while (v7 == 128);
        ++v5;
      }
    }

    else
    {
      Swift::UInt64 v12 = result._rawBits >> 16;
      uint64_t v6 = _StringObject.sharedUTF8.getter(v1, v2);
      Swift::UInt64 v5 = v12;
      if (v12 != v9) {
        goto LABEL_8;
      }
    }

    return (Swift::String::Index)(v5 << 16);
  }

  uint64_t v8 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 != v8) {
    return _StringGuts.foreignScalarAlign(_:)(result);
  }
  return result;
}

Swift::String::Index __swiftcall _StringGuts.foreignScalarAlign(_:)(Swift::String::Index a1)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v4 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v4 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (v4 != a1._rawBits >> 16 && _StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:)(a1) >> 10 == 55) {
    Swift::UInt64 rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) - 0x10000;
  }
  return (Swift::String::Index)(rawBits | 1);
}

uint64_t closure #1 in _StringGuts.fastUTF8ScalarLength(endingAt:)@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v4 = 1LL;
  uint64_t v5 = a3 - 1;
  while (1)
  {
    if (v5 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
    }
    if (a3 - 1 >= a2) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
    }
    if ((*(_BYTE *)(result + v5) & 0xC0) != 0x80) {
      break;
    }
    --v5;
    if (__OFADD__(v4++, 1LL))
    {
      __break(1u);
      break;
    }
  }

  *a4 = v4;
  return result;
}

uint64_t static Unicode.UTF16._decodeSurrogates(_:_:)(__int16 a1, __int16 a2)
{
  return (a2 & 0x3FF | ((unsigned __int16)(a1 & 0x3FF) << 10)) + 0x10000;
}

uint64_t static Unicode.UTF16._replacementCodeUnit.getter()
{
  return 65533LL;
}

Swift::String __swiftcall _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)( Swift::Int startingAt, Swift::Int endingAt)
{
  uint64_t v4 = v2;
  Swift::Int v5 = startingAt;
  v57[1] = *MEMORY[0x1895F89C0];
  int64_t v6 = endingAt - startingAt;
  BOOL v7 = __OFSUB__(endingAt, startingAt);
  if (startingAt - endingAt == 1)
  {
    Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(startingAt << 16))._0._value;
    uint64_t v9 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
    if ((v10 & 0x2000000000000000LL) != 0) {
      uint64_t v13 = HIBYTE(v10) & 0xF;
    }
    else {
      uint64_t v13 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (!v13) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't form a Character from an empty String",  43LL,  2,  "Swift/Character.swift",  21LL,  2,  0xAFuLL,  0);
    }
    unint64_t v14 = v9;
    unint64_t v15 = v10;
    swift_bridgeObjectRetain(v10, v10, v11, v12);
    v16._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15LL)._rawBits;
    Swift::UInt64 rawBits = String._uncheckedIndex(after:)(v16)._rawBits;
    swift_bridgeObjectRelease(v15);
    if (rawBits >> 14 == 4 * v13)
    {
      if (!(v15 & 0x2000000000000000LL | v14 & 0x1000000000000000LL))
      {
        unint64_t v14 = specialized static String._copying(_:)(v14, v15);
        unint64_t v19 = v18;
        swift_bridgeObjectRelease(v15);
        unint64_t v15 = v19;
      }

      goto LABEL_35;
    }

uint64_t Unicode.ParseResult._valid.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](a1);
  int64_t v6 = (unsigned __int8 *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *))(v4 + 16))(v6);
  if (swift_getEnumCaseMultiPayload(v6, a1))
  {
    (*(void (**)(unsigned __int8 *, uint64_t))(v4 + 8))(v6, a1);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(*(void *)(a1 + 16) - 8LL) + 56LL))( a2,  1LL,  1LL,  *(void *)(a1 + 16));
  }

  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v9 = *(void *)(v8 - 8);
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v9 + 32))(a2, v6, v8);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 56))(a2, 0LL, 1LL, v8);
  }

uint64_t Unicode.ParseResult._error.getter(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (unsigned __int8 *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *))(v2 + 16))(v4);
  (*(void (**)(unsigned __int8 *, uint64_t))(v2 + 8))(v4, a1);
  return 0LL;
}

uint64_t Unicode.Scalar.Properties._scalar.getter()
{
  return *v0;
}

uint64_t (*Unicode.Scalar.Properties._scalar.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t Unicode.Scalar.Properties.isAlphabetic.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 7) & 1;
}

unint64_t Unicode.Scalar.Properties.isASCIIHexDigit.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 6) & 1;
}

unint64_t Unicode.Scalar.Properties.isBidiControl.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 8) & 1;
}

unint64_t Unicode.Scalar.Properties.isBidiMirrored.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 9) & 1;
}

unint64_t Unicode.Scalar.Properties.isDash.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 12) & 1;
}

unint64_t Unicode.Scalar.Properties.isDefaultIgnorableCodePoint.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 13) & 1;
}

unint64_t Unicode.Scalar.Properties.isDeprecated.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 14) & 1;
}

unint64_t Unicode.Scalar.Properties.isDiacritic.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 15) & 1;
}

unint64_t Unicode.Scalar.Properties.isExtender.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 20) & 1;
}

unint64_t Unicode.Scalar.Properties.isFullCompositionExclusion.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 21) & 1;
}

unint64_t Unicode.Scalar.Properties.isGraphemeBase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 22) & 1;
}

unint64_t Unicode.Scalar.Properties.isGraphemeExtend.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 23) & 1;
}

unint64_t Unicode.Scalar.Properties.isHexDigit.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 24) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDContinue.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 25) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDStart.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 28) & 1;
}

unint64_t Unicode.Scalar.Properties.isIdeographic.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 29) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDSBinaryOperator.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 26) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDSTrinaryOperator.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 27) & 1;
}

unint64_t Unicode.Scalar.Properties.isJoinControl.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 30) & 1;
}

unint64_t Unicode.Scalar.Properties.isLogicalOrderException.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 31) & 1;
}

unint64_t Unicode.Scalar.Properties.isLowercase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 32) & 1;
}

unint64_t Unicode.Scalar.Properties.isMath.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 33) & 1;
}

unint64_t Unicode.Scalar.Properties.isNoncharacterCodePoint.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 34) & 1;
}

unint64_t Unicode.Scalar.Properties.isQuotationMark.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 37) & 1;
}

unint64_t Unicode.Scalar.Properties.isRadical.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 38) & 1;
}

unint64_t Unicode.Scalar.Properties.isSoftDotted.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 40) & 1;
}

unint64_t Unicode.Scalar.Properties.isTerminalPunctuation.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 41) & 1;
}

unint64_t Unicode.Scalar.Properties.isUnifiedIdeograph.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 42) & 1;
}

unint64_t Unicode.Scalar.Properties.isUppercase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 43) & 1;
}

unint64_t Unicode.Scalar.Properties.isWhitespace.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 45) & 1;
}

unint64_t Unicode.Scalar.Properties.isXIDContinue.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 46) & 1;
}

unint64_t Unicode.Scalar.Properties.isXIDStart.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 47) & 1;
}

unint64_t Unicode.Scalar.Properties.isSentenceTerminal.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 39) & 1;
}

unint64_t Unicode.Scalar.Properties.isVariationSelector.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 44) & 1;
}

unint64_t Unicode.Scalar.Properties.isPatternSyntax.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 35) & 1;
}

unint64_t Unicode.Scalar.Properties.isPatternWhitespace.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 36) & 1;
}

unint64_t Unicode.Scalar.Properties.isCased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 11) & 1;
}

unint64_t Unicode.Scalar.Properties.isCaseIgnorable.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 10) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenLowercased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 2) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenUppercased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 5) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenTitlecased.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 4) & 1;
}

uint64_t Unicode.Scalar.Properties.changesWhenCaseFolded.getter()
{
  return _swift_stdlib_getBinaryProperties(*v0) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenCaseMapped.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 1) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenNFKCCaseFolded.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 3) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmoji.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 16) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiPresentation.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 19) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiModifier.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 17) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiModifierBase.getter()
{
  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 18) & 1;
}

uint64_t Unicode.Scalar.Properties._getMapping(_:)(unsigned __int8 a1)
{
  v8[1] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *v1;
  v8[0] = 0LL;
  int v3 = a1;
  Specialint Mapping = (uint8x16_t *)_swift_stdlib_getSpecialMapping(v2, a1, v8);
  if (SpecialMapping && v8[0])
  {
    if (v8[0] < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(SpecialMapping, v8[0], 0);
  }

  else
  {
    int Mapping = _swift_stdlib_getMapping(v2, v3);
    if (Mapping)
    {
      uint64_t v7 = v2 + Mapping;
      if (v7 < 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
      }
      if (HIDWORD(v7)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
      }
    }

    else
    {
      LODWORD(v7) = v2;
    }

    return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v7);
  }

uint64_t Unicode.Scalar.Properties.titlecaseMapping.getter()
{
  return Unicode.Scalar.Properties._getMapping(_:)(2u);
}

uint64_t Unicode.Scalar.Properties.age.getter()
{
  LODWORD(result) = _swift_stdlib_getAge(*v0);
  if ((_DWORD)result == 0xFFFF) {
    return 0LL;
  }
  else {
    return result;
  }
}

Swift::Unicode::GeneralCategory __swiftcall Unicode.GeneralCategory.init(rawValue:)( Swift::Unicode::GeneralCategory rawValue)
{
  if (rawValue >= Swift_Unicode_GeneralCategory_unknownDefault)
  {
    Swift::Unicode::GeneralCategory v2 = rawValue;
    unint64_t countAndFlagsBits = 0xD000000000000019LL;
    unint64_t v4 = specialized static String._createEmpty(withInitialCapacity:)(27LL);
    uint64_t v6 = v5;
    v29._unint64_t countAndFlagsBits = v4;
    v29._unint64_t object = (void *)v5;
    uint64_t v7 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000LL) == 0) {
      uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (v7 || (v4 & ~v5 & 0x2000000000000000LL) != 0)
    {
      if ((v5 & 0x2000000000000000LL) == 0
        || (0x80000001818BB070LL & 0x2000000000000000LL) == 0
        || (unint64_t v9 = specialized _SmallString.init(_:appending:)( v4,  v5,  0xD000000000000019LL,  0x80000001818BB070LL | 0x8000000000000000LL),  (v11 & 1) != 0))
      {
        if ((0x80000001818BB070LL & 0x2000000000000000LL) != 0) {
          unint64_t v12 = (0x80000001818BB070LL >> 56) & 0xF;
        }
        else {
          unint64_t v12 = 25LL;
        }
        _StringGuts.append(_:)(0xD000000000000019LL, 0x80000001818BB070LL | 0x8000000000000000LL, 0LL, v12);
        swift_bridgeObjectRelease(0x80000001818BB070LL | 0x8000000000000000LL);
        unint64_t object = (unint64_t)v29._object;
        unint64_t countAndFlagsBits = v29._countAndFlagsBits;
LABEL_17:
        Swift::String v13 = _uint64ToString(_:radix:uppercase:)(v2, 10LL, 0);
        unint64_t v14 = v13._countAndFlagsBits;
        unint64_t v15 = (unint64_t)v13._object;
        uint64_t v16 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000LL) == 0) {
          uint64_t v16 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        if (!v16 && (countAndFlagsBits & ~object & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(object);
          Swift::String v29 = v13;
          goto LABEL_31;
        }

        if ((object & 0x2000000000000000LL) != 0)
        {
          if (((uint64_t)v13._object & 0x2000000000000000LL) != 0)
          {
            unint64_t v18 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  object,  v13._countAndFlagsBits,  (unint64_t)v13._object);
            if ((v20 & 1) == 0)
            {
              unint64_t v21 = v18;
              uint64_t v22 = v19;
              swift_bridgeObjectRelease(object);
              swift_bridgeObjectRelease((uint64_t)v13._object);
              v29._unint64_t countAndFlagsBits = v21;
              v29._unint64_t object = v22;
              unint64_t v15 = (unint64_t)v22;
              unint64_t v14 = v21;
              goto LABEL_31;
            }

            goto LABEL_29;
          }
        }

        else if (((uint64_t)v13._object & 0x2000000000000000LL) != 0)
        {
LABEL_29:
          uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
          goto LABEL_30;
        }

        uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_30:
        _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0LL, v17);
        swift_bridgeObjectRelease((uint64_t)v13._object);
        unint64_t v15 = (unint64_t)v29._object;
        unint64_t v14 = v29._countAndFlagsBits;
LABEL_31:
        uint64_t v23 = HIBYTE(v15) & 0xF;
        if ((v15 & 0x2000000000000000LL) == 0) {
          uint64_t v23 = v14 & 0xFFFFFFFFFFFFLL;
        }
        if (v23 || (v14 & ~v15 & 0x2000000000000000LL) != 0)
        {
          if ((v15 & 0x2000000000000000LL) == 0
            || (unint64_t v26 = specialized _SmallString.init(_:appending:)(v14, v15, 0LL, 0xE000000000000000LL), (v28 & 1) != 0))
          {
            _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
            swift_bridgeObjectRelease(0xE000000000000000LL);
            unint64_t v25 = (unint64_t)v29._object;
            uint64_t v24 = (char *)v29._countAndFlagsBits;
          }

          else
          {
            uint64_t v24 = (char *)v26;
            unint64_t v25 = v27;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(0xE000000000000000LL);
          }
        }

        else
        {
          swift_bridgeObjectRelease(v15);
          uint64_t v24 = 0LL;
          unint64_t v25 = 0xE000000000000000LL;
        }

        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v24,  v25,  "Swift/UnicodeScalarProperties.swift",  35LL,  2,  0x45EuLL,  0);
      }

      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x80000001818BB070LL | 0x8000000000000000LL);
    }

    else
    {
      swift_bridgeObjectRelease(v5);
      unint64_t object = 0x80000001818BB070LL | 0x8000000000000000LL;
    }

    v29._unint64_t countAndFlagsBits = countAndFlagsBits;
    v29._unint64_t object = (void *)object;
    goto LABEL_17;
  }

  Swift::Unicode::GeneralCategory *v1 = rawValue;
  return rawValue;
}

uint64_t Unicode.Scalar.Properties.generalCategory.getter()
{
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(*v0);
  return Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
}

Swift::String __swiftcall Unicode.Scalar.Properties._hangulName()()
{
  int v57 = *v0;
  uint64_t v1 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>();
  inited = swift_initStackObject(v1, v61);
  *((_OWORD *)inited + 1) = xmmword_1817FFED0;
  inited[4] = 71LL;
  inited[5] = 0xE100000000000000LL;
  inited[6] = 18247LL;
  inited[7] = 0xE200000000000000LL;
  inited[8] = 78LL;
  inited[9] = 0xE100000000000000LL;
  inited[10] = 68LL;
  inited[11] = 0xE100000000000000LL;
  inited[12] = 17476LL;
  inited[13] = 0xE200000000000000LL;
  inited[14] = 82LL;
  inited[15] = 0xE100000000000000LL;
  inited[16] = 77LL;
  inited[17] = 0xE100000000000000LL;
  inited[18] = 66LL;
  inited[19] = 0xE100000000000000LL;
  inited[20] = 16962LL;
  inited[21] = 0xE200000000000000LL;
  inited[22] = 83LL;
  inited[23] = 0xE100000000000000LL;
  inited[24] = 21331LL;
  inited[25] = 0xE200000000000000LL;
  inited[26] = 0LL;
  inited[27] = 0xE000000000000000LL;
  inited[28] = 74LL;
  inited[29] = 0xE100000000000000LL;
  inited[30] = 19018LL;
  inited[31] = 0xE200000000000000LL;
  inited[32] = 67LL;
  inited[33] = 0xE100000000000000LL;
  inited[34] = 75LL;
  inited[35] = 0xE100000000000000LL;
  inited[36] = 84LL;
  inited[37] = 0xE100000000000000LL;
  inited[38] = 80LL;
  inited[39] = 0xE100000000000000LL;
  inited[40] = 72LL;
  inited[41] = 0xE100000000000000LL;
  int v3 = swift_initStackObject(v1, v60);
  *((_OWORD *)v3 + 1) = xmmword_1817FFEE0;
  v3[4] = 65LL;
  void v3[5] = 0xE100000000000000LL;
  v3[6] = 17729LL;
  v3[7] = 0xE200000000000000LL;
  v3[8] = 16729LL;
  v3[9] = 0xE200000000000000LL;
  v3[10] = 4538713LL;
  v3[11] = 0xE300000000000000LL;
  v3[12] = 20293LL;
  v3[13] = 0xE200000000000000LL;
  v3[14] = 69LL;
  v3[15] = 0xE100000000000000LL;
  v3[16] = 5195097LL;
  v3[17] = 0xE300000000000000LL;
  v3[18] = 17753LL;
  v3[19] = 0xE200000000000000LL;
  v3[20] = 79LL;
  v3[21] = 0xE100000000000000LL;
  v3[22] = 16727LL;
  v3[23] = 0xE200000000000000LL;
  v3[24] = 4538711LL;
  v3[25] = 0xE300000000000000LL;
  v3[26] = 17743LL;
  v3[27] = 0xE200000000000000LL;
  v3[28] = 20313LL;
  v3[29] = 0xE200000000000000LL;
  v3[30] = 85LL;
  v3[31] = 0xE100000000000000LL;
  v3[32] = 5195095LL;
  v3[33] = 0xE300000000000000LL;
  v3[34] = 17751LL;
  v3[35] = 0xE200000000000000LL;
  v3[36] = 18775LL;
  v3[37] = 0xE200000000000000LL;
  v3[38] = 21849LL;
  v3[39] = 0xE200000000000000LL;
  v3[40] = 21829LL;
  v3[41] = 0xE200000000000000LL;
  v3[42] = 18777LL;
  v3[43] = 0xE200000000000000LL;
  v3[44] = 73LL;
  v3[45] = 0xE100000000000000LL;
  unint64_t v4 = swift_allocObject(v1, 0x1E0uLL, 7uLL);
  *((_OWORD *)v4 + 1) = xmmword_1817FFEF0;
  v4[4] = 0LL;
  v4[5] = 0xE000000000000000LL;
  v4[6] = 71LL;
  v4[7] = 0xE100000000000000LL;
  v4[8] = 18247LL;
  v4[9] = 0xE200000000000000LL;
  v4[10] = 21319LL;
  v4[11] = 0xE200000000000000LL;
  v4[12] = 78LL;
  v4[13] = 0xE100000000000000LL;
  v4[14] = 19022LL;
  v4[15] = 0xE200000000000000LL;
  v4[16] = 18510LL;
  v4[17] = 0xE200000000000000LL;
  v4[18] = 68LL;
  v4[19] = 0xE100000000000000LL;
  v4[20] = 76LL;
  v4[21] = 0xE100000000000000LL;
  v4[22] = 18252LL;
  v4[23] = 0xE200000000000000LL;
  v4[24] = 19788LL;
  v4[25] = 0xE200000000000000LL;
  v4[26] = 16972LL;
  v4[27] = 0xE200000000000000LL;
  v4[28] = 21324LL;
  v4[29] = 0xE200000000000000LL;
  v4[30] = 21580LL;
  v4[31] = 0xE200000000000000LL;
  v4[32] = 20556LL;
  v4[33] = 0xE200000000000000LL;
  v4[34] = 18508LL;
  v4[35] = 0xE200000000000000LL;
  v4[36] = 77LL;
  v4[37] = 0xE100000000000000LL;
  v4[38] = 66LL;
  v4[39] = 0xE100000000000000LL;
  v4[40] = 21314LL;
  v4[41] = 0xE200000000000000LL;
  v4[42] = 83LL;
  v4[43] = 0xE100000000000000LL;
  v4[44] = 21331LL;
  v4[45] = 0xE200000000000000LL;
  v4[46] = 18254LL;
  v4[47] = 0xE200000000000000LL;
  v4[48] = 74LL;
  v4[49] = 0xE100000000000000LL;
  v4[50] = 67LL;
  v4[51] = 0xE100000000000000LL;
  v4[52] = 75LL;
  v4[53] = 0xE100000000000000LL;
  v4[54] = 84LL;
  unint64_t v5 = (v57 - 44032) % 0x24Cu / 0x1C;
  v4[55] = 0xE100000000000000LL;
  v4[56] = 80LL;
  v4[57] = 0xE100000000000000LL;
  v4[58] = 72LL;
  unint64_t v6 = (v57 - 44032) % 0x1Cu;
  v4[59] = 0xE100000000000000LL;
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)((v57 - 44032) / 0x24CuLL, 1, (uint64_t)inited);
  uint64_t v7 = &inited[2 * ((v57 - 44032) / 0x24CuLL) + 4];
  unint64_t v8 = *v7;
  unint64_t v9 = v7[1];
  swift_bridgeObjectRetain(v9, v10, v11, v12);
  swift_bridgeObjectRelease((uint64_t)inited);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v5, 1, (uint64_t)v3);
  Swift::String v13 = &v3[2 * v5 + 4];
  uint64_t v14 = *v13;
  unint64_t v15 = v13[1];
  swift_bridgeObjectRetain(v15, v16, v17, v18);
  swift_bridgeObjectRelease((uint64_t)v3);
  unint64_t v19 = specialized static String.+ infix(_:_:)(v8, v9, v14, v15);
  unint64_t v21 = v20;
  swift_bridgeObjectRelease(v15);
  swift_bridgeObjectRelease(v9);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v6, 1, (uint64_t)v4);
  uint64_t v22 = &v4[2 * v6 + 4];
  uint64_t v23 = *v22;
  unint64_t v24 = v22[1];
  swift_setDeallocating((uint64_t)v4);
  swift_bridgeObjectRetain(v24, v25, v26, v27);
  swift_arrayDestroy((uint64_t)(v4 + 4), 28LL, (uint64_t)&type metadata for String);
  swift_deallocClassInstance((uint64_t)v4);
  unint64_t v28 = specialized static String.+ infix(_:_:)(v19, v21, v23, v24);
  unint64_t v30 = v29;
  swift_bridgeObjectRelease(v24);
  swift_bridgeObjectRelease(v21);
  unint64_t v31 = specialized static String._createEmpty(withInitialCapacity:)(18LL);
  uint64_t v33 = v32;
  unint64_t v58 = v31;
  unint64_t v59 = v32;
  uint64_t v34 = HIBYTE(v32) & 0xF;
  if ((v32 & 0x2000000000000000LL) == 0) {
    uint64_t v34 = v31 & 0xFFFFFFFFFFFFLL;
  }
  if (!v34 && (v31 & ~v32 & 0x2000000000000000LL) == 0)
  {
    unint64_t v38 = 0xD000000000000010LL;
    swift_bridgeObjectRelease(v32);
    unint64_t v39 = 0x80000001818BB050LL | 0x8000000000000000LL;
    goto LABEL_14;
  }

  if ((v32 & 0x2000000000000000LL) != 0 && (0x80000001818BB050LL & 0x2000000000000000LL) != 0)
  {
    unint64_t v35 = specialized _SmallString.init(_:appending:)( v31,  v32,  0xD000000000000010LL,  0x80000001818BB050LL | 0x8000000000000000LL);
    if ((v37 & 1) == 0)
    {
      unint64_t v38 = v35;
      unint64_t v39 = v36;
      swift_bridgeObjectRelease(v33);
      swift_bridgeObjectRelease(0x80000001818BB050LL | 0x8000000000000000LL);
LABEL_14:
      unint64_t v58 = v38;
      unint64_t v59 = v39;
      goto LABEL_15;
    }
  }

  if ((0x80000001818BB050LL & 0x2000000000000000LL) != 0) {
    unint64_t v40 = (0x80000001818BB050LL >> 56) & 0xF;
  }
  else {
    unint64_t v40 = 16LL;
  }
  _StringGuts.append(_:)(0xD000000000000010LL, 0x80000001818BB050LL | 0x8000000000000000LL, 0LL, v40);
  swift_bridgeObjectRelease(0x80000001818BB050LL | 0x8000000000000000LL);
  unint64_t v38 = v58;
  unint64_t v39 = v59;
LABEL_15:
  uint64_t v41 = HIBYTE(v39) & 0xF;
  if ((v39 & 0x2000000000000000LL) == 0) {
    uint64_t v41 = v38 & 0xFFFFFFFFFFFFLL;
  }
  if (v41 || (v38 & ~v39 & 0x2000000000000000LL) != 0)
  {
    if ((v39 & 0x2000000000000000LL) != 0)
    {
      if ((v30 & 0x2000000000000000LL) != 0)
      {
        unint64_t v43 = specialized _SmallString.init(_:appending:)(v38, v39, v28, v30);
        if ((v45 & 1) == 0)
        {
          unint64_t v46 = v43;
          unint64_t v47 = v44;
          swift_bridgeObjectRelease(v39);
          swift_bridgeObjectRelease(v30);
          unint64_t v58 = v46;
          unint64_t v59 = v47;
          unint64_t v30 = v47;
          unint64_t v28 = v46;
          goto LABEL_28;
        }

        goto LABEL_26;
      }
    }

    else if ((v30 & 0x2000000000000000LL) != 0)
    {
LABEL_26:
      uint64_t v42 = HIBYTE(v30) & 0xF;
      goto LABEL_27;
    }

    uint64_t v42 = v28 & 0xFFFFFFFFFFFFLL;
LABEL_27:
    _StringGuts.append(_:)(v28, v30, 0LL, v42);
    swift_bridgeObjectRelease(v30);
    unint64_t v28 = v58;
    unint64_t v30 = v59;
    goto LABEL_28;
  }

  swift_bridgeObjectRelease(v39);
  unint64_t v58 = v28;
  unint64_t v59 = v30;
LABEL_28:
  uint64_t v48 = HIBYTE(v30) & 0xF;
  if ((v30 & 0x2000000000000000LL) == 0) {
    uint64_t v48 = v28 & 0xFFFFFFFFFFFFLL;
  }
  if (v48 || (v28 & ~v30 & 0x2000000000000000LL) != 0)
  {
    if ((v30 & 0x2000000000000000LL) == 0
      || (unint64_t v49 = specialized _SmallString.init(_:appending:)(v28, v30, 0LL, 0xE000000000000000LL), (v51 & 1) != 0))
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v52 = v58;
      unint64_t v53 = v59;
    }

    else
    {
      unint64_t v52 = v49;
      unint64_t v53 = v50;
      swift_bridgeObjectRelease(v30);
      swift_bridgeObjectRelease(0xE000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v30);
    unint64_t v52 = 0LL;
    unint64_t v53 = 0xE000000000000000LL;
  }

  uint64_t v54 = v52;
  uint64_t v55 = (void *)v53;
  result._unint64_t object = v55;
  result._unint64_t countAndFlagsBits = v54;
  return result;
}